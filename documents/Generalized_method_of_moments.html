<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1878">Generalized method of moments</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Generalized method of moments</h1>
<hr/>

<p>In <a class="uri" href="econometrics" title="wikilink">econometrics</a>, the <strong>generalized method of moments</strong> (<strong>GMM</strong>) is a generic method for estimating <a href="statistical_parameter" title="wikilink">parameters</a> in <a href="statistical_model" title="wikilink">statistical models</a>. Usually it is applied in the context of <a href="semiparametric_model" title="wikilink">semiparametric models</a>, where the parameter of interest is finite-dimensional, whereas the full shape of the distribution function of the data may not be known, and therefore <a href="maximum_likelihood_estimation" title="wikilink">maximum likelihood estimation</a> is not applicable.</p>

<p>The method requires that a certain number of <em>moment conditions</em> were specified for the model. These moment conditions are functions of the model parameters and the data, such that their <a href="expected_value" title="wikilink">expectation</a> is zero at the true values of the parameters. The GMM method then minimizes a certain <a href="norm_(mathematics)" title="wikilink">norm</a> of the sample averages of the moment conditions.</p>

<p>The GMM <a href="estimator" title="wikilink">estimators</a> are known to be <a href="consistent_estimator" title="wikilink">consistent</a>, <a href="asymptotic_distribution" title="wikilink">asymptotically normal</a>, and <a href="efficient_estimator" title="wikilink">efficient</a> in the class of all estimators that don’t use any extra information aside from that contained in the moment conditions.</p>

<p>GMM was developed by <a href="Lars_Peter_Hansen" title="wikilink">Lars Peter Hansen</a> in 1982 as a generalization of the <a href="method_of_moments_(statistics)" title="wikilink">method of moments</a> which was introduced by <a href="Karl_Pearson" title="wikilink">Karl Pearson</a> in 1894. Hansen shared the 2013 <a href="Nobel_Prize_in_Economics" title="wikilink">Nobel Prize in Economics</a> in part for this work.</p>
<h2 id="description">Description</h2>

<p>Suppose the available data consists of <em>T</em> observations , where each observation <em>Y<sub>t</sub></em> is an <em>n</em>-dimensional <a href="multivariate_random_variable" title="wikilink">multivariate random variable</a>. We assume that the data come from a certain <a href="statistical_model" title="wikilink">statistical model</a>, defined up to an unknown <a class="uri" href="parameter" title="wikilink">parameter</a> . The goal of the estimation problem is to find the “true” value of this parameter, <em>θ</em><sub>0</sub>, or at least a reasonably close estimate.</p>

<p>A general assumption of GMM is that the data <em>Y<sub>t</sub></em> be generated by a <a href="stationary_process" title="wikilink">weakly stationary</a> <a href="ergodic_process" title="wikilink">ergodic</a> <a href="stochastic_process" title="wikilink">stochastic process</a>. (The case of <a href="independent_and_identically_distributed_random_variables" title="wikilink">independent and identically distributed</a> (iid) variables <em>Y<sub>t</sub></em> is a special case of this condition.)</p>

<p>In order to apply GMM, we need to have "moment conditions", i.e. we need to know a <a href="vector-valued_function" title="wikilink">vector-valued function</a> <em>g</em>(<em>Y</em>,<em>θ</em>) such that</p>

<p>

<math display="block" id="Generalized_method_of_moments:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>θ</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>Y</mi>
         <mi>t</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>θ</mi>
         <mn>0</mn>
        </msub>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <cn type="integer">0</cn>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m(\theta_{0})\equiv\operatorname{E}[\,g(Y_{t},\theta_{0})\,]=0,
  </annotation>
 </semantics>
</math>

 where E denotes <a href="Expected_value" title="wikilink">expectation</a>, and <em>Y<sub>t</sub></em> is a generic observation. Moreover, the function <em>m</em>(<em>θ</em>) must differ from zero for <mtpl></mtpl>, or otherwise the parameter <em>θ</em> will not be point-<a href="Identification_(parameter)" title="wikilink">identified</a>.</p>

<p>The basic idea behind GMM is to replace the theoretical expected value E[⋅] with its empirical analog — sample average:</p>

<p>

<math display="block" id="Generalized_method_of_moments:1">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>T</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>T</mi>
     </munderover>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>Y</mi>
        <mi>t</mi>
       </msub>
       <mo>,</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>m</ci>
     </apply>
     <ci>θ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>T</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>t</ci>
        </apply>
        <ci>θ</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}(\theta)\equiv\frac{1}{T}\sum_{t=1}^{T}g(Y_{t},\theta)
  </annotation>
 </semantics>
</math>

 and then to minimize the norm of this expression with respect to <em>θ</em>. The minimizing value of <em>θ</em> is our estimate for <em>θ</em><sub>0</sub>.</p>

<p>By the <a href="law_of_large_numbers" title="wikilink">law of large numbers</a>, 

<math display="inline" id="Generalized_method_of_moments:2">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="5.3pt">≈</mo>
   <mrow>
    <mo>E</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>Y</mi>
        <mi>t</mi>
       </msub>
       <mo>,</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <ci>θ</ci>
     </apply>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>t</ci>
        </apply>
        <ci>θ</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{m}(\theta)\,\approx\;\operatorname{E}[g(Y_{t},\theta)]\,=\,m(\theta)
  </annotation>
 </semantics>
</math>

 for large values of <em>T</em>, and thus we expect that 

<math display="inline" id="Generalized_method_of_moments:3">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>θ</mi>
      <mn>0</mn>
     </msub>
     <mo rspace="5.3pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="5.3pt">≈</mo>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>θ</mi>
      <mn>0</mn>
     </msub>
     <mo rspace="5.3pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{m}(\theta_{0})\;\approx\;m(\theta_{0})\;=\;0
  </annotation>
 </semantics>
</math>

. The generalized method of moments looks for a number 

<math display="inline" id="Generalized_method_of_moments:4">
 <semantics>
  <mover accent="true">
   <mi>θ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{\theta}
  </annotation>
 </semantics>
</math>

 which would make 

<math display="inline" id="Generalized_method_of_moments:5">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo rspace="3.6pt" stretchy="false">(</mo>
    <mpadded width="+1.1pt">
     <mover accent="true">
      <mi>θ</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mpadded>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{m}(\;\!\hat{\theta}\;\!)
  </annotation>
 </semantics>
</math>

 as close to zero as possible. Mathematically, this is equivalent to minimizing a certain <a href="norm_(mathematics)" title="wikilink">norm</a> of 

<math display="inline" id="Generalized_method_of_moments:6">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>m</ci>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{m}(\theta)
  </annotation>
 </semantics>
</math>

 (norm of <em>m</em>, denoted as ||<em>m</em>||, measures the distance between <em>m</em> and zero). The properties of the resulting estimator will depend on the particular choice of the norm function, and therefore the theory of GMM considers an entire family of norms, defined as</p>

<p>

<math display="block" id="Generalized_method_of_moments:7">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mover accent="true">
        <mi>m</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mi>W</mi>
     <mn>2</mn>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>θ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>′</mo>
      </msup>
     </mpadded>
     <mi>W</mi>
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <apply>
         <ci>normal-^</ci>
         <ci>m</ci>
        </apply>
        <ci>θ</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>W</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>θ</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>W</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>m</ci>
     </apply>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\hat{m}(\theta)\|^{2}_{W}=\hat{m}(\theta)^{\prime}\,W\hat{m}(\theta),
  </annotation>
 </semantics>
</math>

 where <em>W</em> is a <a href="Positive-definite_matrix" title="wikilink">positive-definite</a> weighting matrix, and <em>m′</em> denotes <a href="transpose" title="wikilink">transposition</a>. In practice, the weighting matrix <em>W</em> is computed based on the available data set, which will be denoted as 

<math display="inline" id="Generalized_method_of_moments:8">
 <semantics>
  <mover accent="true">
   <mi>W</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{W}
  </annotation>
 </semantics>
</math>

. Thus, the GMM estimator can be written as</p>

<p>

<math display="block" id="Generalized_method_of_moments:9">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>θ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mo>arg</mo>
   <munder>
    <mi>min</mi>
    <mrow>
     <mi>θ</mi>
     <mo>∈</mo>
     <mi mathvariant="normal">Θ</mi>
    </mrow>
   </munder>
   <msup>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mfrac>
      <mn>1</mn>
      <mi>T</mi>
     </mfrac>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>T</mi>
     </munderover>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>Y</mi>
       <mi>t</mi>
      </msub>
      <mo>,</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
    <mo>′</mo>
   </msup>
   <mover accent="true">
    <mi>W</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo maxsize="210%" minsize="210%">(</mo>
    <mfrac>
     <mn>1</mn>
     <mi>T</mi>
    </mfrac>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>t</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>T</mi>
    </munderover>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>Y</mi>
      <mi>t</mi>
     </msub>
     <mo>,</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo maxsize="210%" minsize="210%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>θ</ci>
    </apply>
    <eq></eq>
    <ci>arg</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <apply>
      <in></in>
      <ci>θ</ci>
      <ci>normal-Θ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
      <csymbol cd="unknown">g</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">θ</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <ci>W</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <csymbol cd="unknown">g</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>t</ci>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">θ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}=\operatorname{arg}\min_{\theta\in\Theta}\bigg(\frac{1}{T}\sum_{t=%
1}^{T}g(Y_{t},\theta)\bigg)^{\prime}\hat{W}\bigg(\frac{1}{T}\sum_{t=1}^{T}g(Y_%
{t},\theta)\bigg)
  </annotation>
 </semantics>
</math>

</p>

<p>Under suitable conditions this estimator is <a href="Consistent_estimator" title="wikilink">consistent</a>, <a href="Asymptotic_normality" title="wikilink">asymptotically normal</a>, and with right choice of weighting matrix 

<math display="inline" id="Generalized_method_of_moments:10">
 <semantics>
  <mover accent="true">
   <mi>W</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\hat{W}
  </annotation>
 </semantics>
</math>

 also <a href="efficient_estimator" title="wikilink">asymptotically efficient</a>.</p>
<h2 id="properties">Properties</h2>
<h3 id="consistency">Consistency</h3>

<p><a href="Consistent_estimator" title="wikilink">Consistency</a> is a statistical property of an estimator stating that, having a sufficient number of observations, the estimator will get arbitrarily close to the true value of parameter:</p>

<p>

<math display="block" id="Generalized_method_of_moments:11">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>θ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝑝</mo>
   </mover>
   <mrow>
    <mpadded width="+5pt">
     <msub>
      <mi>θ</mi>
      <mn>0</mn>
     </msub>
    </mpadded>
    <mpadded width="+5pt">
     <mtext>as</mtext>
    </mpadded>
    <mi>T</mi>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <ci>p</ci>
      <ci>normal-→</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>θ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
      <mtext>as</mtext>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}\xrightarrow{p}\theta_{0}\ \text{as}\ T\to\infty
  </annotation>
 </semantics>
</math>

 (see <a href="Convergence_in_probability" title="wikilink">Convergence in probability</a>). Necessary and sufficient conditions for a GMM estimator to be consistent are as follows:</p>
<ol>
<li>

<math display="inline" id="Generalized_method_of_moments:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>W</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>T</mi>
    </msub>
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑝</mo>
    </mover>
    <mi>W</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>p</ci>
     <ci>normal-→</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>W</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{W}_{T}\xrightarrow{p}W,
  </annotation>
 </semantics>
</math>

 where <em>W</em> is a <a href="Positive_definite_matrix#Negative-definite.2C_semidefinite_and_indefinite_matrices" title="wikilink">positive semi-definite matrix</a>,</li>
<li>

<math display="inline" id="Generalized_method_of_moments:13">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>W</mi>
    </mpadded>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>Y</mi>
         <mi>t</mi>
        </msub>
        <mo>,</mo>
        <mi>θ</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>W</ci>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>t</ci>
        </apply>
        <ci>θ</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,W\operatorname{E}[\,g(Y_{t},\theta)\,]=0
  </annotation>
 </semantics>
</math>

  only for 

<math display="inline" id="Generalized_method_of_moments:14">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>θ</mi>
    </mpadded>
    <mo>=</mo>
    <msub>
     <mi>θ</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\theta=\theta_{0},
  </annotation>
 </semantics>
</math>

</li>
<li>The set of possible parameters 

<math display="inline" id="Generalized_method_of_moments:15">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mo>⊂</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta\subset\mathbb{R}^{k}
  </annotation>
 </semantics>
</math>

 is <a href="Compact_space" title="wikilink">compact</a>,</li>
<li>

<math display="inline" id="Generalized_method_of_moments:16">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>g</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <interval closure="open">
     <ci>Y</ci>
     <ci>θ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,g(Y,\theta)
  </annotation>
 </semantics>
</math>

  is continuous at each <em>θ</em> with probability one,</li>
<li>

<math display="inline" id="Generalized_method_of_moments:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mrow>
       <msub>
        <mo>sup</mo>
        <mrow>
         <mi>θ</mi>
         <mo>∈</mo>
         <mi mathvariant="normal">Θ</mi>
        </mrow>
       </msub>
       <mrow>
        <mo fence="true">∥</mo>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>Y</mi>
          <mo>,</mo>
          <mi>θ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo fence="true" rspace="4.2pt">∥</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <ci>normal-E</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <apply>
        <in></in>
        <ci>θ</ci>
        <ci>normal-Θ</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>g</ci>
        <interval closure="open">
         <ci>Y</ci>
         <ci>θ</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{E}[\,\textstyle\sup_{\theta\in\Theta}\lVert g(Y,\theta)\rVert\,]%
<\infty.
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>The second condition here (so-called <strong>Global identification</strong> condition) is often particularly hard to verify. There exist simpler necessary but not sufficient conditions, which may be used to detect non-identification problem:</p>
<ul>
<li><strong>Order condition</strong>. The dimension of moment function <em>m(θ)</em> should be at least as large as the dimension of parameter vector <em>θ</em>.</li>
<li><strong>Local identification</strong>. If <em>g(Y,θ)</em> is continuously differentiable in a neighborhood of 

<math display="inline" id="Generalized_method_of_moments:18">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

, then matrix 

<math display="inline" id="Generalized_method_of_moments:19">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo>E</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <msub>
        <mo>∇</mo>
        <mi>θ</mi>
       </msub>
       <mi>g</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>Y</mi>
        <mi>t</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>θ</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <apply>
     <ci>normal-E</ci>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <ci>θ</ci>
       </apply>
       <ci>g</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\operatorname{E}[\nabla_{\theta}g(Y_{t},\theta_{0})]
  </annotation>
 </semantics>
</math>

 must have full <a href="Rank_(linear_algebra)" title="wikilink">column rank</a>.</li>
</ul>

<p>In practice applied econometricians often simply <em>assume</em> that global identification holds, without actually proving it.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="asymptotic-normality">Asymptotic normality</h3>

<p><a href="Asymptotic_normality" title="wikilink">Asymptotic normality</a> is a useful property, as it allows us to construct <a href="Confidence_interval" title="wikilink">confidence bands</a> for the estimator, and conduct different tests. Before we can make a statement about the asymptotic distribution of the GMM estimator, we need to define two auxiliary matrices:</p>

<p>

<math display="block" id="Generalized_method_of_moments:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>=</mo>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mpadded width="+1.7pt">
         <msub>
          <mo>∇</mo>
          <mpadded lspace="-1.7pt" width="-1.7pt">
           <mi>θ</mi>
          </mpadded>
         </msub>
        </mpadded>
        <mi>g</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>Y</mi>
         <mi>t</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>θ</mi>
         <mn>0</mn>
        </msub>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>=</mo>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>Y</mi>
         <mi>t</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>θ</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>g</mi>
       <mpadded width="+1.7pt">
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>Y</mi>
           <mi>t</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>θ</mi>
           <mn>0</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>′</mo>
        </msup>
       </mpadded>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>G</ci>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-∇</ci>
         <ci>θ</ci>
        </apply>
        <ci>g</ci>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <cn type="integer">0</cn>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>normal-Ω</ci>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <cn type="integer">0</cn>
        </apply>
       </interval>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>θ</ci>
          <cn type="integer">0</cn>
         </apply>
        </interval>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\operatorname{E}[\,\nabla_{\!\theta}\,g(Y_{t},\theta_{0})\,],\qquad\Omega=%
\operatorname{E}[\,g(Y_{t},\theta_{0})g(Y_{t},\theta_{0})^{\prime}\,]
  </annotation>
 </semantics>
</math>

 Then under conditions 1–6 listed below, the GMM estimator will be asymptotically normal with limiting distribution</p>

<p>

<math display="block" id="Generalized_method_of_moments:21">
 <semantics>
  <mrow>
   <mrow>
    <msqrt>
     <mi>T</mi>
    </msqrt>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mrow>
      <mover accent="true">
       <mi>θ</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo>-</mo>
      <msub>
       <mi>θ</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo maxsize="120%" minsize="120%" rspace="7.5pt">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑑</mo>
    </mover>
   </mpadded>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo maxsize="120%" minsize="120%">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>G</mi>
          <mo>′</mo>
         </msup>
         <mi>W</mi>
         <mi>G</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mi>G</mi>
       <mo>′</mo>
      </msup>
      <mi>W</mi>
      <mi mathvariant="normal">Ω</mi>
      <msup>
       <mi>W</mi>
       <mo>′</mo>
      </msup>
      <mi>G</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>G</mi>
          <mo>′</mo>
         </msup>
         <msup>
          <mi>W</mi>
          <mo>′</mo>
         </msup>
         <mi>G</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo maxsize="120%" minsize="120%">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>d</ci>
     <ci>normal-→</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <ci>T</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-^</ci>
       <ci>θ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>G</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>W</ci>
         <ci>G</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>G</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>W</ci>
       <ci>normal-Ω</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>W</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>G</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>G</ci>
          <ci>normal-′</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>W</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>G</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{T}\big(\hat{\theta}-\theta_{0}\big)\ \xrightarrow{d}\ \mathcal{N}\big[0,%
(G^{\prime}WG)^{-1}G^{\prime}W\Omega W^{\prime}G(G^{\prime}W^{\prime}G)^{-1}\big]
  </annotation>
 </semantics>
</math>

 (see <a href="Convergence_in_distribution" title="wikilink">Convergence in distribution</a>). Conditions:</p>
<ol>
<li>

<math display="inline" id="Generalized_method_of_moments:22">
 <semantics>
  <mover accent="true">
   <mi>θ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}
  </annotation>
 </semantics>
</math>

 is consistent (see previous section),</li>
<li>The set of possible parameters 

<math display="inline" id="Generalized_method_of_moments:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mo>⊂</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta\subset\mathbb{R}^{k}
  </annotation>
 </semantics>
</math>

 is <a href="Compact_space" title="wikilink">compact</a>,</li>
<li>

<math display="inline" id="Generalized_method_of_moments:24">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>g</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <interval closure="open">
     <ci>Y</ci>
     <ci>θ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,g(Y,\theta)
  </annotation>
 </semantics>
</math>

 is continuously differentiable in some neighborhood <em>N</em> of 

<math display="inline" id="Generalized_method_of_moments:25">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

 with probability one,</li>
<li>

<math display="inline" id="Generalized_method_of_moments:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mpadded width="+1.7pt">
       <msup>
        <mrow>
         <mo fence="true">∥</mo>
         <mrow>
          <mi>g</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>Y</mi>
            <mi>t</mi>
           </msub>
           <mo>,</mo>
           <mi>θ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo fence="true">∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mpadded>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <ci>normal-E</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>g</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>t</ci>
         </apply>
         <ci>θ</ci>
        </interval>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{E}[\,\lVert g(Y_{t},\theta)\rVert^{2}\,]<\infty,
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Generalized_method_of_moments:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>E</mo>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mrow>
       <msub>
        <mo>sup</mo>
        <mrow>
         <mi>θ</mi>
         <mo>∈</mo>
         <mi>N</mi>
        </mrow>
       </msub>
       <mrow>
        <mo fence="true">∥</mo>
        <mrow>
         <mrow>
          <msub>
           <mo>∇</mo>
           <mi>θ</mi>
          </msub>
          <mi>g</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>Y</mi>
           <mi>t</mi>
          </msub>
          <mo>,</mo>
          <mi>θ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo fence="true" rspace="4.2pt">∥</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <ci>normal-E</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <apply>
        <in></in>
        <ci>θ</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-∇</ci>
          <ci>θ</ci>
         </apply>
         <ci>g</ci>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Y</ci>
          <ci>t</ci>
         </apply>
         <ci>θ</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{E}[\,\textstyle\sup_{\theta\in N}\lVert\nabla_{\theta}g(Y_{t},%
\theta)\rVert\,]<\infty,
  </annotation>
 </semantics>
</math>

</li>
<li>the matrix 

<math display="inline" id="Generalized_method_of_moments:28">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mi>W</mi>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>W</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}WG
  </annotation>
 </semantics>
</math>

 is nonsingular.</li>
</ol>
<h3 id="efficiency">Efficiency</h3>

<p>So far we have said nothing about the choice of matrix <em>W</em>, except that it must be positive semi-definite. In fact any such matrix will produce a consistent and asymptotically normal GMM estimator, the only difference will be in the asymptotic variance of that estimator. It can be shown that taking</p>

<p>

<math display="block" id="Generalized_method_of_moments:29">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo rspace="7.5pt">∝</mo>
   <msup>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Ω</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\propto\ \Omega^{-1}
  </annotation>
 </semantics>
</math>

 will result in the most efficient estimator in the class of all asymptotically normal estimators. Efficiency in this case means that such an estimator will have the smallest possible variance (we say that matrix <em>A</em> is smaller than matrix <em>B</em> if <em>B–A</em> is positive semi-definite).</p>

<p>In this case the formula for the asymptotic distribution of the GMM estimator simplifies to</p>

<p>

<math display="block" id="Generalized_method_of_moments:30">
 <semantics>
  <mrow>
   <mrow>
    <msqrt>
     <mi>T</mi>
    </msqrt>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mrow>
      <mover accent="true">
       <mi>θ</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo>-</mo>
      <msub>
       <mi>θ</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo maxsize="120%" minsize="120%" rspace="7.5pt">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑑</mo>
    </mover>
   </mpadded>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo maxsize="120%" minsize="120%">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <msup>
          <mi>G</mi>
          <mo>′</mo>
         </msup>
        </mpadded>
        <msup>
         <mi mathvariant="normal">Ω</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mi>G</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo maxsize="120%" minsize="120%">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>d</ci>
     <ci>normal-→</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <ci>T</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-^</ci>
       <ci>θ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>G</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Ω</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>G</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{T}\big(\hat{\theta}-\theta_{0}\big)\ \xrightarrow{d}\ \mathcal{N}\big[0,%
(G^{\prime}\,\Omega^{-1}G)^{-1}\big]
  </annotation>
 </semantics>
</math>

</p>

<p>The proof that such a choice of weighting matrix is indeed optimal is often adopted with slight modifications when establishing efficiency of other estimators. As a rule of thumb, a weighting matrix is optimal whenever it makes the “sandwich formula” for variance collapse into a simpler expression.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong><em>Proof</em></strong>. We will consider the difference between asymptotic variance with arbitrary <em>W</em> and asymptotic variance with 

<math display="inline" id="Generalized_method_of_moments:31">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <msup>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Ω</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W=\Omega^{-1}
  </annotation>
 </semantics>
</math>


. If we can factor this difference into a symmetric product of the form <em>CC</em>' for some matrix <em>C</em>, then it will guarantee that this difference is nonnegative-definite, and thus 

<math display="inline" id="Generalized_method_of_moments:32">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <msup>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Ω</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W=\Omega^{-1}
  </annotation>
 </semantics>
</math>

 will be optimal by definition.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Generalized_method_of_moments:33">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>V</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>W</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi mathvariant="normal">Ω</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>W</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Ω</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,V(W)-V(\Omega^{-1})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>where we introduced matrices <em>A</em> and <em>B</em> in order to slightly simplify notation; <em>I</em> is an <a href="identity_matrix" title="wikilink">identity matrix</a>. We can see that matrix <em>B</em> here is symmetric and <a href="Projection_(linear_algebra)" title="wikilink">idempotent</a>

<math display="block" id="Generalized_method_of_moments:34">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{2}=B
  </annotation>
 </semantics>
</math>

. This means <em>I–B</em> is symmetric and idempotent as well

<math display="block" id="Generalized_method_of_moments:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mo>-</mo>
    <mi>B</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>I</mi>
       <mo>-</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>I</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>I</ci>
       <ci>B</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I-B=(I-B)(I-B)^{\prime}
  </annotation>
 </semantics>
</math>

. Thus we can continue to factor the previous expression as</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="implementation">Implementation</h2>

<p>One difficulty with implementing the outlined method is that we cannot take <mtpl> Ω<sup>−1</sup>}}</mtpl> because, by the definition of matrix Ω, we need to know the value of <em>θ</em><sub>0</sub> in order to compute this matrix, and <em>θ</em><sub>0</sub> is precisely the quantity we don’t know and are trying to estimate in the first place.</p>

<p>Several approaches exist to deal with this issue, the first one being the most popular:</p>

<p>Another important issue in implementation of minimization procedure is that the function is supposed to search through (possibly high-dimensional) parameter space <em>Θ</em> and find the value of <em>θ</em> which minimizes the objective function. No generic recommendation for such procedure exists, it is a subject of its own field, <a href="numerical_optimization" title="wikilink">numerical optimization</a>.</p>
<h2 id="j-test">J-test</h2>

<p>When the number of moment conditions is greater than the dimension of the parameter vector <em>θ</em>, the model is said to be <em>over-identified</em>. Over-identification allows us to check whether the model's moment conditions match the data well or not.</p>

<p>Conceptually we can check whether 

<math display="inline" id="Generalized_method_of_moments:36">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>θ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}(\hat{\theta})
  </annotation>
 </semantics>
</math>


 is sufficiently close to zero to suggest that the model fits the data well. The GMM method has then replaced the problem of solving the equation 

<math display="inline" id="Generalized_method_of_moments:37">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>m</ci>
     </apply>
     <ci>θ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}(\theta)=0
  </annotation>
 </semantics>
</math>

, which chooses 

<math display="inline" id="Generalized_method_of_moments:38">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 to match the restrictions exactly, by a minimization calculation. The minimization can always be conducted even when no 

<math display="inline" id="Generalized_method_of_moments:39">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

 exists such that 

<math display="inline" id="Generalized_method_of_moments:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>θ</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m(\theta_{0})=0
  </annotation>
 </semantics>
</math>

. This is what J-test does. The J-test is also called a <em>test for over-identifying restrictions</em>.</p>

<p>Formally we consider two <a href="Statistical_hypothesis_testing" title="wikilink">hypotheses</a>:</p>
<ul>
<li>

<math display="inline" id="Generalized_method_of_moments:41">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="7.5pt">:</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>θ</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}:\ m(\theta_{0})=0
  </annotation>
 </semantics>
</math>


  (the <a href="null_hypothesis" title="wikilink">null hypothesis</a> that the model is “valid”), and</li>
<li>

<math display="inline" id="Generalized_method_of_moments:42">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="7.5pt">:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≠</mo>
     <mn>0</mn>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>θ</mi>
     </mrow>
     <mo>∈</mo>
     <mi mathvariant="normal">Θ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>θ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>θ</ci>
      </apply>
      <ci>normal-Θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}:\ m(\theta)\neq 0,\ \forall\theta\in\Theta
  </annotation>
 </semantics>
</math>

  (the <a href="alternative_hypothesis" title="wikilink">alternative hypothesis</a> that model is “invalid”; the data do not come close to meeting the restrictions)</li>
</ul>

<p>Under hypothesis 

<math display="inline" id="Generalized_method_of_moments:43">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}
  </annotation>
 </semantics>
</math>

, the following so-called J-statistic is asymptotically <em><a href="Chi-squared_distribution" title="wikilink">chi-squared</a></em> with <em>k–l</em> degrees of freedom. Define <em>J</em> to be:</p>

<p>

<math display="block" id="Generalized_method_of_moments:44">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mo>⋅</mo>
     <msup>
      <mrow>
       <mo maxsize="210%" minsize="210%">(</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mi>T</mi>
        </mfrac>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mrow>
           <mi>t</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>T</mi>
         </munderover>
         <mrow>
          <mi>g</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>Y</mi>
            <mi>t</mi>
           </msub>
           <mo>,</mo>
           <mover accent="true">
            <mi>θ</mi>
            <mo stretchy="false">^</mo>
           </mover>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo maxsize="210%" minsize="210%">)</mo>
      </mrow>
      <mo>′</mo>
     </msup>
    </mrow>
    <msub>
     <mover accent="true">
      <mi>W</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>T</mi>
      </mfrac>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>t</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>T</mi>
       </munderover>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>Y</mi>
          <mi>t</mi>
         </msub>
         <mo>,</mo>
         <mover accent="true">
          <mi>θ</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo maxsize="210%" minsize="210%" rspace="7.5pt">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑑</mo>
    </mover>
   </mpadded>
   <msubsup>
    <mi>χ</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mi mathvariant="normal">ℓ</mi>
    </mrow>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>J</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <ci>T</ci>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>t</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>T</ci>
          </apply>
          <apply>
           <times></times>
           <ci>g</ci>
           <interval closure="open">
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>Y</ci>
             <ci>t</ci>
            </apply>
            <apply>
             <ci>normal-^</ci>
             <ci>θ</ci>
            </apply>
           </interval>
          </apply>
         </apply>
        </apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>W</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>T</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>T</ci>
        </apply>
        <apply>
         <times></times>
         <ci>g</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Y</ci>
           <ci>t</ci>
          </apply>
          <apply>
           <ci>normal-^</ci>
           <ci>θ</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <ci>d</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>χ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J\equiv T\cdot\bigg(\frac{1}{T}\sum_{t=1}^{T}g(Y_{t},\hat{\theta})\bigg)^{%
\prime}\hat{W}_{T}\bigg(\frac{1}{T}\sum_{t=1}^{T}g(Y_{t},\hat{\theta})\bigg)\ %
\xrightarrow{d}\ \chi^{2}_{k-\ell}
  </annotation>
 </semantics>
</math>

   under 

<math display="inline" id="Generalized_method_of_moments:45">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Generalized_method_of_moments:46">
 <semantics>
  <mover accent="true">
   <mi>θ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}
  </annotation>
 </semantics>
</math>


 is the GMM estimator of the parameter 

<math display="inline" id="Generalized_method_of_moments:47">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

, <em>k</em> is the number of moment conditions (dimension of vector <em>g</em>), and <em>l</em> is the number of estimated parameters (dimension of vector <em>θ</em>). Matrix 

<math display="inline" id="Generalized_method_of_moments:48">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>W</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>W</ci>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{W}_{T}
  </annotation>
 </semantics>
</math>

 must converge in probability to 

<math display="inline" id="Generalized_method_of_moments:49">
 <semantics>
  <msup>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Ω</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega^{-1}
  </annotation>
 </semantics>
</math>

, the efficient weighting matrix (note that previously we only required that <em>W</em> be proportional to 

<math display="inline" id="Generalized_method_of_moments:50">
 <semantics>
  <msup>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Ω</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega^{-1}
  </annotation>
 </semantics>
</math>

 for estimator to be efficient; however in order to conduct the J-test <em>W</em> must be exactly equal to 

<math display="inline" id="Generalized_method_of_moments:51">
 <semantics>
  <msup>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Ω</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega^{-1}
  </annotation>
 </semantics>
</math>


, not simply proportional).</p>

<p>Under the alternative hypothesis 

<math display="inline" id="Generalized_method_of_moments:52">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}
  </annotation>
 </semantics>
</math>

, the J-statistic is asymptotically unbounded:</p>

<p>

<math display="block" id="Generalized_method_of_moments:53">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>J</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑝</mo>
    </mover>
   </mpadded>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>p</ci>
     <ci>normal-→</ci>
    </apply>
    <ci>J</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J\ \xrightarrow{p}\ \infty
  </annotation>
 </semantics>
</math>

  under 

<math display="inline" id="Generalized_method_of_moments:54">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}
  </annotation>
 </semantics>
</math>

</p>

<p>To conduct the test we compute the value of <em>J</em> from the data. It is a nonnegative number. We compare it with (for example) the 0.95 <a class="uri" href="quantile" title="wikilink">quantile</a> of the 

<math display="inline" id="Generalized_method_of_moments:55">
 <semantics>
  <msubsup>
   <mi>χ</mi>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mi mathvariant="normal">ℓ</mi>
   </mrow>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>χ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <ci>normal-ℓ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi^{2}_{k-\ell}
  </annotation>
 </semantics>
</math>

 distribution:</p>
<ul>
<li>

<math display="inline" id="Generalized_method_of_moments:56">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}
  </annotation>
 </semantics>
</math>


 is rejected at 95% confidence level if 

<math display="inline" id="Generalized_method_of_moments:57">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>></mo>
   <msubsup>
    <mi>q</mi>
    <mn>0.95</mn>
    <msubsup>
     <mi>χ</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mi mathvariant="normal">ℓ</mi>
     </mrow>
     <mn>2</mn>
    </msubsup>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>J</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="float">0.95</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>χ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J>q_{0.95}^{\chi^{2}_{k-\ell}}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Generalized_method_of_moments:58">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}
  </annotation>
 </semantics>
</math>

 cannot be rejected at 95% confidence level if 

<math display="inline" id="Generalized_method_of_moments:59">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo><</mo>
   <msubsup>
    <mi>q</mi>
    <mn>0.95</mn>
    <msubsup>
     <mi>χ</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mi mathvariant="normal">ℓ</mi>
     </mrow>
     <mn>2</mn>
    </msubsup>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>J</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="float">0.95</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>χ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J<q_{0.95}^{\chi^{2}_{k-\ell}}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h2 id="scope">Scope</h2>

<p>Many other popular estimation techniques can be cast in terms of GMM optimization:</p>
<h2 id="implementations">Implementations</h2>
<ul>
<li><a href="http://en.wikibooks.org/wiki/R_Programming/Method_of_Moments">R Programming wikibook, Method of Moments</a></li>
<li><a href="http://cran.r-project.org/web/packages/gmm/gmm.pdf">R</a></li>
<li><a href="https://www.stata.com/manuals13/rgmm.pdf">Stata</a></li>
<li><a href="http://www.eviews.com/EViews7/ev7features.html">EViews</a></li>
<li><a href="http://support.sas.com/documentation/cdl/en/etsug/60372/HTML/default/viewer.htm#etsug_model_sect035.htm">SAS</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Method_of_maximum_likelihood" title="wikilink">Method of maximum likelihood</a></li>
<li><a href="Generalized_empirical_likelihood" title="wikilink">Generalized empirical likelihood</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Kirby Faciane (2006): <em>Statistics for Empirical and Quantitative Finance</em>. H.C. Baird: Philadelphia. ISBN 0-9788208-9-4.</li>
<li>Alastair R. Hall (2005). <em>Generalized Method of Moments (Advanced Texts in Econometrics)</em>. Oxford University Press. ISBN 0-19-877520-2.</li>
<li></li>
<li>Lars Peter Hansen (2002): <em>Method of Moments</em> in International Encyclopedia of the Social and Behavior Sciences, <a href="N._J._Smelser" title="wikilink">N. J. Smelser</a> and P. B. Bates (editors), Pergamon: Oxford.</li>
<li></li>
<li></li>
<li>Newey W., McFadden D. (1994). <em>Large sample estimation and hypothesis testing</em>, in Handbook of Econometrics, Ch.36. Elsevier Science.</li>
<li>Special issues of Journal of Business and Economic Statistics: <a href="http://www.jstor.org/stable/i260360">vol. 14, no. 3</a> and <a href="http://pubs.amstat.org/toc/jbes/20/4">vol. 20, no. 4</a>.</li>
</ul>

<p><a href="ru:Обобщенный_метод_моментов" title="wikilink">ru:Обобщенный метод моментов</a>"</p>

<p><a href="Category:Estimation_theory" title="wikilink">Category:Estimation theory</a> <a class="uri" href="Category:Econometrics" title="wikilink">Category:Econometrics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Newey, McFadden (1994), p.2127<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
