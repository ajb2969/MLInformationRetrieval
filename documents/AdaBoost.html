<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1154">AdaBoost</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>AdaBoost</h1>
<hr>'''AdaBoost''', short for "Adaptive [[Boosting (meta-algorithm)|Boosting]]", i
<p>s a <a href="machine_learning" title="wikilink">machine learning</a> <a class="uri" href="meta-algorithm" title="wikilink">meta-algorithm</a> formulated by <a href="Yoav_Freund" title="wikilink">Yoav Freund</a> and <a href="Robert_Schapire" title="wikilink">Robert Schapire</a> who won the prestigious "<a href="Gödel_Prize" title="wikilink">Gödel Prize</a>" in 2003 for their work. It can be used in conjunction with many other types of learning algorithms to improve their performance. The output of the other learning algorithms ('weak learners') is combined into a weighted sum that represents the final output of the boosted classifier. AdaBoost is adaptive in the sense that subsequent weak learners are tweaked in favor of those instances misclassified by previous classifiers. AdaBoost is sensitive to noisy data and <a href="outlier" title="wikilink">outliers</a>. In some problems, however, it can be less susceptible to the <a href="overfitting_(machine_learning)" title="wikilink">overfitting</a> problem than other learning algorithms. The individual learners can be weak, but as long as the performance of each one is slightly better than random guessing (i.e., their error rate is smaller than 0.5 for binary classification), the final model can be proven to converge to a strong learner.</p>

<p>While every learning algorithm will tend to suit some problem types better than others, and will typically have many different parameters and configurations to be adjusted before achieving optimal performance on a dataset, AdaBoost (with <a href="Decision_tree_learning" title="wikilink">decision trees</a> as the weak learners) is often referred to as the best out-of-the-box classifier. When used with decision tree learning, information gathered at each stage of the AdaBoost algorithm about the relative 'hardness' of each training sample is fed into the tree growing algorithm such that later trees tend to focus on harder to classify examples.</p>
<h2 id="overview">Overview</h2>

<p>Problems in machine learning often suffer from the <a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a> — each sample may consist of a huge number of potential features (for instance, there can be 162,336 <a href="Haar-like_features" title="wikilink">Haar features</a>, as used by the <a href="Viola–Jones_object_detection_framework" title="wikilink">Viola–Jones object detection framework</a>, in a 24×24 pixel image window), and evaluating every feature can reduce not only the speed of classifier training and execution, but in fact reduce predictive power, per the <em>Hughes Effect</em>. Unlike <a href="neural_network" title="wikilink">neural networks</a> and <a href="Support_vector_machine" title="wikilink">SVMs</a>, the AdaBoost training process selects only those features known to improve the predictive power of the model, reducing dimensionality and potentially improving execution time as irrelevant features do not need to be computed.</p>
<h3 id="training">Training</h3>

<p>AdaBoost refers to a particular method of training a boosted classifier. A boost classifier is a classifier in the form</p>

<p>

<math display="block" id="AdaBoost:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>t</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>T</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>T</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>t</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{T}(x)=\sum_{t=1}^{T}f_{t}(x)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>where each 

<math display="inline" id="AdaBoost:1">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}
  </annotation>
 </semantics>
</math>

 is a weak learner that takes an object 

<math display="inline" id="AdaBoost:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 as input and returns a real valued result indicating the class of the object. The sign of the weak learner output identifies the predicted object class and the absolute value gives the confidence in that classification. Similarly, the 

<math display="inline" id="AdaBoost:3">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

-layer classifier will be positive if the sample is believed to be in the positive class and negative otherwise.</p>

<p>Each weak learner produces an output, hypothesis 

<math display="inline" id="AdaBoost:4">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x_{i})
  </annotation>
 </semantics>
</math>

, for each sample in the training set. At each iteration 

<math display="inline" id="AdaBoost:5">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, a weak learner is selected and assigned a coefficient 

<math display="inline" id="AdaBoost:6">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{t}
  </annotation>
 </semantics>
</math>

 such that the sum training error 

<math display="inline" id="AdaBoost:7">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{t}
  </annotation>
 </semantics>
</math>

 of the resulting 

<math display="inline" id="AdaBoost:8">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

-stage boost classifier is minimized.</p>

<p>

<math display="block" id="AdaBoost:9">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>F</mi>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>α</mi>
         <mi>t</mi>
        </msub>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <apply>
           <minus></minus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>t</ci>
         </apply>
         <ci>h</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{t}=\sum_{i}E[F_{t-1}(x_{i})+\alpha_{t}h(x_{i})]
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="AdaBoost:10">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{t-1}(x)
  </annotation>
 </semantics>
</math>

 is the boosted classifier that has been built up to the previous stage of training, 

<math display="inline" id="AdaBoost:11">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(F)
  </annotation>
 </semantics>
</math>

 is some error function and 

<math display="inline" id="AdaBoost:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>t</mi>
    </msub>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>t</ci>
     </apply>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}(x)=\alpha_{t}h(x)
  </annotation>
 </semantics>
</math>

 is the weak learner that is being considered for addition to the final classifier.</p>
<h3 id="weighting">Weighting</h3>

<p>At each iteration of the training process, a weight is assigned to each sample in the training set equal to the current error 

<math display="inline" id="AdaBoost:13">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(F_{t-1}(x_{i}))
  </annotation>
 </semantics>
</math>

 on that sample. These weights can be used to inform the training of the weak learner, for instance, decision trees can be grown that favor splitting sets of samples with high weights.</p>
<h2 id="derivation">Derivation</h2>

<p>This derivation follows Rojas (2009):<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Suppose we have a data set 

<math display="inline" id="AdaBoost:14">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>N</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x_{1},y_{1}),\ldots,(x_{N},y_{N})\}
  </annotation>
 </semantics>
</math>

 where each item 

<math display="inline" id="AdaBoost:15">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 has an associated class 

<math display="inline" id="AdaBoost:16">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\in\{-1,1\}
  </annotation>
 </semantics>
</math>

, and a set of weak classifiers 

<math display="inline" id="AdaBoost:17">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>k</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>k</mi>
    <mi>L</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>L</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{k_{1},\ldots,k_{L}\}
  </annotation>
 </semantics>
</math>

 each of which outputs a classification 

<math display="inline" id="AdaBoost:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>k</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{j}(x_{i})\in\{-1,1\}
  </annotation>
 </semantics>
</math>

 for each item. After the 

<math display="inline" id="AdaBoost:19">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-1
  </annotation>
 </semantics>
</math>

-th iteration our boosted classifier is a linear combination of the weak classifiers of the form:</p>

<p>

<math display="block" id="AdaBoost:20">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>k</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>k</mi>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{(m-1)}(x_{i})=\alpha_{1}k_{1}(x_{i})+\cdots+\alpha_{m-1}k_{m-1}(x_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>At the 

<math display="inline" id="AdaBoost:21">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-th iteration we want to extend this to a better boosted classifier by adding a multiple of one of the weak classifiers:</p>

<p>

<math display="block" id="AdaBoost:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>m</mi>
     </msub>
     <msub>
      <mi>k</mi>
      <mi>m</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{m}(x_{i})=C_{(m-1)}(x_{i})+\alpha_{m}k_{m}(x_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>So it remains to determine which weak classifier is the best choice for 

<math display="inline" id="AdaBoost:23">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{m}
  </annotation>
 </semantics>
</math>

, and what its weight 

<math display="inline" id="AdaBoost:24">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{m}
  </annotation>
 </semantics>
</math>

 should be. We define the total error 

<math display="inline" id="AdaBoost:25">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="AdaBoost:26">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{m}
  </annotation>
 </semantics>
</math>

 to be the sum of its exponential loss on each data point, given as follows:</p>

<p>

<math display="block" id="AdaBoost:27">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>C</mi>
        <mi>m</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=\sum_{i=1}^{N}e^{-y_{i}C_{m}(x_{i})}
  </annotation>
 </semantics>
</math>

</p>

<p>Letting 

<math display="inline" id="AdaBoost:28">
 <semantics>
  <mrow>
   <msubsup>
    <mi>w</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}^{(1)}=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="AdaBoost:29">
 <semantics>
  <mrow>
   <msubsup>
    <mi>w</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>C</mi>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}^{(m)}=e^{-y_{i}C_{m-1}(x_{i})}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="AdaBoost:30">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m>1
  </annotation>
 </semantics>
</math>

, we have:</p>

<p>

<math display="block" id="AdaBoost:31">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msubsup>
      <mi>w</mi>
      <mi>i</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <msub>
         <mi>α</mi>
         <mi>m</mi>
        </msub>
        <msub>
         <mi>k</mi>
         <mi>m</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=\sum_{i=1}^{N}w_{i}^{(m)}e^{-y_{i}\alpha_{m}k_{m}(x_{i})}
  </annotation>
 </semantics>
</math>

</p>

<p>We can split this summation between those data points that are correctly classified by 

<math display="inline" id="AdaBoost:32">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{m}
  </annotation>
 </semantics>
</math>

 (so 

<math display="inline" id="AdaBoost:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>k</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}k_{m}(x_{i})=1
  </annotation>
 </semantics>
</math>

) and those which are misclassified (so 

<math display="inline" id="AdaBoost:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>k</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}k_{m}(x_{i})=-1
  </annotation>
 </semantics>
</math>

):</p>

<p>

<math display="block" id="AdaBoost:35">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>=</mo>
       <mrow>
        <msub>
         <mi>k</mi>
         <mi>m</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msubsup>
       <mi>w</mi>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <msub>
         <mi>α</mi>
         <mi>m</mi>
        </msub>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>≠</mo>
       <mrow>
        <msub>
         <mi>k</mi>
         <mi>m</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msubsup>
       <mi>w</mi>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <msup>
       <mi>e</mi>
       <msub>
        <mi>α</mi>
        <mi>m</mi>
       </msub>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <msubsup>
       <mi>w</mi>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <msub>
         <mi>α</mi>
         <mi>m</mi>
        </msub>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>≠</mo>
       <mrow>
        <msub>
         <mi>k</mi>
         <mi>m</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msubsup>
       <mi>w</mi>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>e</mi>
         <msub>
          <mi>α</mi>
          <mi>m</mi>
         </msub>
        </msup>
        <mo>-</mo>
        <msup>
         <mi>e</mi>
         <mrow>
          <mo>-</mo>
          <msub>
           <mi>α</mi>
           <mi>m</mi>
          </msub>
         </mrow>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>E</ci>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <ci>m</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>m</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <neq></neq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <ci>m</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>m</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <neq></neq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <ci>m</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>m</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>α</ci>
            <ci>m</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=\sum_{y_{i}=k_{m}(x_{i})}w_{i}^{(m)}e^{-\alpha_{m}}+\sum_{y_{i}\neq k_{m}(x_%
{i})}w_{i}^{(m)}e^{\alpha_{m}}=\sum_{i=1}^{N}w_{i}^{(m)}e^{-\alpha_{m}}+\sum_{%
y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}(e^{\alpha_{m}}-e^{-\alpha_{m}})
  </annotation>
 </semantics>
</math>

</p>

<p>Since the only part of the right-hand side of this equation that depends on 

<math display="inline" id="AdaBoost:36">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{m}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="AdaBoost:37">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo>≠</mo>
     <mrow>
      <msub>
       <mi>k</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msub>
   <msubsup>
    <mi>w</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <neq></neq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}
  </annotation>
 </semantics>
</math>

, we see that the 

<math display="inline" id="AdaBoost:38">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{m}
  </annotation>
 </semantics>
</math>

 that minimizes 

<math display="inline" id="AdaBoost:39">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is the one that minimizes 

<math display="inline" id="AdaBoost:40">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo>≠</mo>
     <mrow>
      <msub>
       <mi>k</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msub>
   <msubsup>
    <mi>w</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <neq></neq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}
  </annotation>
 </semantics>
</math>

, i.e. the weak classifier with the lowest weighted error (with weights 

<math display="inline" id="AdaBoost:41">
 <semantics>
  <mrow>
   <msubsup>
    <mi>w</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>C</mi>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}^{(m)}=e^{-y_{i}C_{m-1}(x_{i})}
  </annotation>
 </semantics>
</math>

).</p>

<p>In order to determine the desired weight 

<math display="inline" id="AdaBoost:42">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{m}
  </annotation>
 </semantics>
</math>

 that minimizes 

<math display="inline" id="AdaBoost:43">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 with the 

<math display="inline" id="AdaBoost:44">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{m}
  </annotation>
 </semantics>
</math>

 that we just determined, we differentiate:</p>

<p>

<math display="block" id="AdaBoost:45">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mi>E</mi>
    </mrow>
    <mrow>
     <mi>d</mi>
     <msub>
      <mi>α</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>≠</mo>
       <mrow>
        <msub>
         <mi>k</mi>
         <mi>m</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msubsup>
       <mi>w</mi>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <msup>
       <mi>e</mi>
       <msub>
        <mi>α</mi>
        <mi>m</mi>
       </msub>
      </msup>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>=</mo>
       <mrow>
        <msub>
         <mi>k</mi>
         <mi>m</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msubsup>
       <mi>w</mi>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <msub>
         <mi>α</mi>
         <mi>m</mi>
        </msub>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>E</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{dE}{d\alpha_{m}}=\sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}e^{\alpha_{m}}-%
\sum_{y_{i}=k_{m}(x_{i})}w_{i}^{(m)}e^{-\alpha_{m}}
  </annotation>
 </semantics>
</math>

</p>

<p>Setting this to zero and solving for 

<math display="inline" id="AdaBoost:46">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{m}
  </annotation>
 </semantics>
</math>

 yields:</p>

<p>

<math display="block" id="AdaBoost:47">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mfrac>
       <mrow>
        <msub>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mo>=</mo>
          <mrow>
           <msub>
            <mi>k</mi>
            <mi>m</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </msub>
        <msubsup>
         <mi>w</mi>
         <mi>i</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
       </mrow>
       <mrow>
        <msub>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mo>≠</mo>
          <mrow>
           <msub>
            <mi>k</mi>
            <mi>m</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </msub>
        <msubsup>
         <mi>w</mi>
         <mi>i</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
       </mrow>
      </mfrac>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <divide></divide>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>k</ci>
            <ci>m</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <ci>m</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <neq></neq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>k</ci>
            <ci>m</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{m}=\frac{1}{2}\ln(\frac{\sum_{y_{i}=k_{m}(x_{i})}w_{i}^{(m)}}{\sum_{y_%
{i}\neq k_{m}(x_{i})}w_{i}^{(m)}})
  </annotation>
 </semantics>
</math>

</p>

<p>We calculate the weighted error rate of the weak classifier to be 

<math display="inline" id="AdaBoost:48">
 <semantics>
  <mrow>
   <msub>
    <mi>ϵ</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo>≠</mo>
      <mrow>
       <msub>
        <mi>k</mi>
        <mi>m</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <msubsup>
      <mi>w</mi>
      <mi>i</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo>/</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <msubsup>
       <mi>w</mi>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{m}=\sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}/\sum_{i=1}^{N}w_{i}^{(m)}
  </annotation>
 </semantics>
</math>

, so it follows that:</p>

<p>

<math display="block" id="AdaBoost:49">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mfrac>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msub>
         <mi>ϵ</mi>
         <mi>m</mi>
        </msub>
       </mrow>
       <msub>
        <mi>ϵ</mi>
        <mi>m</mi>
       </msub>
      </mfrac>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϵ</ci>
         <ci>m</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϵ</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{m}=\frac{1}{2}\ln(\frac{1-\epsilon_{m}}{\epsilon_{m}})
  </annotation>
 </semantics>
</math>

</p>

<p>Thus we have derived the AdaBoost algorithm: At each iteration, choose the classifier 

<math display="inline" id="AdaBoost:50">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{m}
  </annotation>
 </semantics>
</math>

 which minimizes the total weighted error 

<math display="inline" id="AdaBoost:51">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo>≠</mo>
     <mrow>
      <msub>
       <mi>k</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msub>
   <msubsup>
    <mi>w</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <neq></neq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}
  </annotation>
 </semantics>
</math>

, use this to calculate the error rate 

<math display="inline" id="AdaBoost:52">
 <semantics>
  <mrow>
   <msub>
    <mi>ϵ</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo>≠</mo>
      <mrow>
       <msub>
        <mi>k</mi>
        <mi>m</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <msubsup>
      <mi>w</mi>
      <mi>i</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo>/</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <msubsup>
       <mi>w</mi>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{m}=\sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}/\sum_{i=1}^{N}w_{i}^{(m)}
  </annotation>
 </semantics>
</math>

, use this to calculate the weight 

<math display="inline" id="AdaBoost:53">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mfrac>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msub>
         <mi>ϵ</mi>
         <mi>m</mi>
        </msub>
       </mrow>
       <msub>
        <mi>ϵ</mi>
        <mi>m</mi>
       </msub>
      </mfrac>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϵ</ci>
         <ci>m</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϵ</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{m}=\frac{1}{2}\ln(\frac{1-\epsilon_{m}}{\epsilon_{m}})
  </annotation>
 </semantics>
</math>

, and finally use this to improve the boosted classifier 

<math display="inline" id="AdaBoost:54">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>m</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <minus></minus>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{m-1}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="AdaBoost:55">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>m</mi>
     </msub>
     <msub>
      <mi>k</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{m}=C_{(m-1)}+\alpha_{m}k_{m}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="statistical-understanding-of-boosting">Statistical understanding of boosting</h2>

<p>Boosting is a form of linear <a href="Regression_analysis" title="wikilink">regression</a> in which the features of each sample 

<math display="inline" id="AdaBoost:56">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 are the outputs of some weak learner 

<math display="inline" id="AdaBoost:57">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 applied to 

<math display="inline" id="AdaBoost:58">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

. Specifically, in the case where all weak learners are known a priori, AdaBoost corresponds to a single iteration of the <a href="backfitting_algorithm" title="wikilink">backfitting algorithm</a> in which the <a href="smoothing_spline" title="wikilink">smoothing splines</a> are the minimizers of 

<math display="inline" id="AdaBoost:59">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>Y</mi>
        <mi>i</mi>
       </msub>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">∞</mi>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </msubsup>
     <mrow>
      <msup>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>′′</mi>
      </msup>
      <mpadded width="+1.7pt">
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mpadded>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <ci>normal-^</ci>
         <ci>μ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <infinity></infinity>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>μ</ci>
        </apply>
        <ci>′′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}e^{-Y_{i}\hat{\mu}(x_{i})}+\infty\int_{x_{1}}^{x_{n}}\hat{\mu}^{%
\prime\prime}(x)^{2}\,dx
  </annotation>
 </semantics>
</math>

, that is

<math display="block" id="AdaBoost:60">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>μ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>μ</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mu}_{i}
  </annotation>
 </semantics>
</math>

 fits an exponential cost function and is linear with respect to the observation. Thus, boosting is seen to be a specific type of linear regression.</p>

<p>While regression tries to fit 

<math display="inline" id="AdaBoost:61">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="AdaBoost:62">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(x)
  </annotation>
 </semantics>
</math>

 as precisely as possible without loss of generalization, typically using <a href="least_squares" title="wikilink">least square</a> error 

<math display="inline" id="AdaBoost:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(f)=(y(x)-f(x))^{2}
  </annotation>
 </semantics>
</math>

, the AdaBoost error function 

<math display="inline" id="AdaBoost:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>x</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(f)=e^{-y(x)f(x)}
  </annotation>
 </semantics>
</math>

 takes into account the fact that only the sign of the final result will be used, thus 

<math display="inline" id="AdaBoost:65">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |F(x)|
  </annotation>
 </semantics>
</math>

 can be far larger than 1 without increasing error. However, the exponential increase in the error for sample 

<math display="inline" id="AdaBoost:66">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="AdaBoost:67">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -y(x_{i})f(x_{i})
  </annotation>
 </semantics>
</math>

 increases results in excessive weight being assigned to outliers.</p>

<p>One feature of the choice of exponential error function is that the error of the final additive model is the product of the error of each stage, that is, 

<math display="inline" id="AdaBoost:68">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>i</mi>
      </msub>
     </mstyle>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mi>i</mi>
    </msub>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\sum_{i}-y_{i}f(x_{i})}=\prod_{i}e^{-y_{i}f(x_{i})}
  </annotation>
 </semantics>
</math>

. Thus it can be seen that the weight update in the AdaBoost algorithm is equivalent to recalculating the error on 

<math display="inline" id="AdaBoost:69">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>t</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{t}(x)
  </annotation>
 </semantics>
</math>

 after each stage.</p>

<p>There is a lot of flexibility allowed in the choice of loss function. As long as the loss function is <a href="monotonic_function" title="wikilink">monotonic</a> and <a href="continuously_differentiable_function" title="wikilink">continuously differentiable</a>, the classifier will always be driven toward purer solutions.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Zhang (2004) provides a loss function based on least squares, a modified <a href="Huber_loss_function" title="wikilink">Huber loss function</a>:</p>

<p>

<math display="block" id="AdaBoost:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo>-</mo>
        <mrow>
         <mn>4</mn>
         <mi>y</mi>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>y</mi>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo><</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>y</mi>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>≤</mo>
         <mrow>
          <mi>y</mi>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>≤</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>y</mi>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>></mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <interval closure="open">
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>y</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>y</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <apply>
        <minus></minus>
        <mtext>if</mtext>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>y</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(y,f(x))=\begin{cases}-4yf(x)&\mbox{if }yf(x)<-1,\\
(yf(x)-1)^{2}&\mbox{if }-1\leq yf(x)\leq 1,\\
0&\mbox{if }yf(x)>1\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>This function is more well-behaved than LogitBoost for 

<math display="inline" id="AdaBoost:71">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 close to 1 or -1, does not penalise ‘overconfident’ predictions (

<math display="inline" id="AdaBoost:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   yf(x)>1
  </annotation>
 </semantics>
</math>

), unlike unmodified least squares, and only penalises samples misclassified with confidence greater than 1 linearly, as opposed to quadratically or exponentially, and is thus less susceptible to the effects of outliers.</p>
<h2 id="boosting-as-gradient-descent">Boosting as Gradient Descent</h2>

<p>Boosting can be seen as minimization of a <a href="convex_function" title="wikilink">convex</a> loss function over a <a href="convex_set" title="wikilink">convex set</a> of functions.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Specifically, the loss being minimized by AdaBoost is the exponential loss 

<math display="inline" id="AdaBoost:73">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <vector>
       <ci>i</ci>
       <ci>y</ci>
       <ci>f</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}\phi(i,y,f)=\sum_{i}e^{-y_{i}f(x_{i})}
  </annotation>
 </semantics>
</math>

, whereas LogitBoost performs logistic regression, minimizing 

<math display="inline" id="AdaBoost:74">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <vector>
       <ci>i</ci>
       <ci>y</ci>
       <ci>f</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}\phi(i,y,f)=\sum_{i}\ln\left(1+e^{-y_{i}f(x_{i})}\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>In the gradient descent analogy, the output of the classifier for each training point is considered to be a point 

<math display="inline" id="AdaBoost:75">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(F_{t}(x_{1}),\dots,F_{t}(x_{n})\right)
  </annotation>
 </semantics>
</math>

 in n-dimensional space, where each axis corresponds to a training sample, each weak learner 

<math display="inline" id="AdaBoost:76">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)
  </annotation>
 </semantics>
</math>

 corresponds to a vector of fixed orientation and length, and the goal is to reach the target point 

<math display="inline" id="AdaBoost:77">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y_{1},\dots,y_{n})
  </annotation>
 </semantics>
</math>

 (or any region where the value of loss function 

<math display="inline" id="AdaBoost:78">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>T</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>T</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{T}(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

 is less than the value at that point), in the least number of steps. Thus AdaBoost algorithms perform either <a href="gradient_descent" title="wikilink">Cauchy</a> (find 

<math display="inline" id="AdaBoost:79">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)
  </annotation>
 </semantics>
</math>

 with the steepest gradient, choose 

<math display="inline" id="AdaBoost:80">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 to minimize test error) or <a href="Newton's_method" title="wikilink">Newton</a> (choose some target point, find 

<math display="inline" id="AdaBoost:81">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>h</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha h(x)
  </annotation>
 </semantics>
</math>

 that will bring 

<math display="inline" id="AdaBoost:82">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{t}
  </annotation>
 </semantics>
</math>

 closest to that point) optimization of training error.</p>
<h2 id="example-algorithm-discrete-adaboost">Example Algorithm (Discrete AdaBoost)</h2>

<p>With:</p>
<ul>
<li>Samples 

<math display="inline" id="AdaBoost:83">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\dots x_{n}
  </annotation>
 </semantics>
</math>

</li>
<li>Desired outputs 

<math display="inline" id="AdaBoost:84">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>y</ci>
    </list>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}\dots y_{n},y\in\{-1,1\}
  </annotation>
 </semantics>
</math>

</li>
<li>Initial weights 

<math display="inline" id="AdaBoost:85">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>w</mi>
    <mrow>
     <mi>n</mi>
     <mo>,</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </list>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <list>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1,1}\dots w_{n,1}
  </annotation>
 </semantics>
</math>

 set to 

<math display="inline" id="AdaBoost:86">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mi>n</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{n}
  </annotation>
 </semantics>
</math>

</li>
<li>Error function 

<math display="inline" id="AdaBoost:87">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <vector>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
      <ci>i</ci>
     </vector>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(f(x),y,i)=e^{-y_{i}f(x_{i})}
  </annotation>
 </semantics>
</math>

</li>
<li>Weak learners 

<math display="inline" id="AdaBoost:88">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>x</ci>
     <interval closure="closed">
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\colon x\rightarrow[-1,1]
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>For 

<math display="inline" id="AdaBoost:89">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="AdaBoost:90">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mi mathvariant="normal">…</mi>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\dots T
  </annotation>
 </semantics>
</math>

:</p>
<ul>
<li>Choose 

<math display="inline" id="AdaBoost:91">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}(x)
  </annotation>
 </semantics>
</math>

:
<ul>
<li>Find weak learner 

<math display="inline" id="AdaBoost:92">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{t}(x)
  </annotation>
 </semantics>
</math>

 that minimizes 

<math display="inline" id="AdaBoost:93">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{t}
  </annotation>
 </semantics>
</math>

, the weighted sum error for misclassified points 

<math display="inline" id="AdaBoost:94">
 <semantics>
  <mrow>
   <msub>
    <mi>ϵ</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>t</mi>
      </mrow>
     </msub>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <list>
        <ci>i</ci>
        <ci>t</ci>
       </list>
      </apply>
      <ci>E</ci>
      <vector>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>t</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <ci>y</ci>
       <ci>i</ci>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{t}=\sum_{i}w_{i,t}E(h_{t}(x),y,i)
  </annotation>
 </semantics>
</math>

</li>
<li>Choose 

<math display="inline" id="AdaBoost:95">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msub>
         <mi>ϵ</mi>
         <mi>t</mi>
        </msub>
       </mrow>
       <msub>
        <mi>ϵ</mi>
        <mi>t</mi>
       </msub>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϵ</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϵ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{t}=\frac{1}{2}\ln\left(\frac{1-\epsilon_{t}}{\epsilon_{t}}\right)
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
<li>Add to ensemble:
<ul>
<li>

<math display="inline" id="AdaBoost:96">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>t</mi>
     </msub>
     <msub>
      <mi>h</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>t</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{t}(x)=F_{t-1}(x)+\alpha_{t}h_{t}(x)
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
<li>Update weights:
<ul>
<li>

<math display="inline" id="AdaBoost:97">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>α</mi>
        <mi>t</mi>
       </msub>
       <msub>
        <mi>h</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <list>
      <ci>i</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <list>
       <ci>i</ci>
       <ci>t</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i,t+1}=w_{i,t}e^{-y_{i}\alpha_{t}h_{t}(x_{i})}
  </annotation>
 </semantics>
</math>

 for all i</li>
<li>Renormalize 

<math display="inline" id="AdaBoost:98">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <list>
     <ci>i</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i,t+1}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="AdaBoost:99">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <list>
       <ci>i</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}w_{i,t+1}=1
  </annotation>
 </semantics>
</math>

</li>
<li>(Note: It can be shown that 

<math display="inline" id="AdaBoost:100">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>t</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msub>
     </mstyle>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>t</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≠</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msub>
     </mstyle>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>h</mi>
          <mi>t</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msub>
     </mstyle>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>t</mi>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>h</mi>
          <mi>t</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≠</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msub>
     </mstyle>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>t</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <apply>
           <plus></plus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <list>
        <ci>i</ci>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </list>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <apply>
           <plus></plus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <list>
        <ci>i</ci>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <list>
        <ci>i</ci>
        <ci>t</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <list>
        <ci>i</ci>
        <ci>t</ci>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\sum_{h_{t+1}(x_{i})=y_{i}}w_{i,t+1}}{\sum_{h_{t+1}(x_{i})\neq y_{i}}w_{%
i,t+1}}=\frac{\sum_{h_{t}(x_{i})=y_{i}}w_{i,t}}{\sum_{h_{t}(x_{i})\neq y_{i}}w%
_{i,t}}
  </annotation>
 </semantics>
</math>

 at every step, which can simplify the calculation of the new weights.)</li>
</ul></li>
</ul>
<h3 id="choosing-alpha_t">Choosing 

<math display="inline" id="AdaBoost:101">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{t}
  </annotation>
 </semantics>
</math>

</h3>

<p>

<math display="inline" id="AdaBoost:102">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{t}
  </annotation>
 </semantics>
</math>

 is chosen as it can be analytically shown to be the minimizer of the exponential error function for Discrete AdaBoost.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Minimize:</p>

<p>

<math display="inline" id="AdaBoost:103">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>i</mi>
   </msub>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>h</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>α</mi>
        <mi>t</mi>
       </msub>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}w_{i}e^{-y_{i}h_{i}\alpha_{t}}
  </annotation>
 </semantics>
</math>

</p>

<p>Using the convexity of the exponential function, and assuming that 

<math display="inline" id="AdaBoost:104">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
    </list>
    <interval closure="closed">
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i,h_{i}\in[-1,1]
  </annotation>
 </semantics>
</math>

 we have:</p>

<p>

<math display="inline" id="AdaBoost:105">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mstyle displaystyle="true">
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mi>i</mi>
       </munder>
      </mstyle>
      <mrow>
       <msub>
        <mi>w</mi>
        <mi>i</mi>
       </msub>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <msub>
           <mi>h</mi>
           <mi>i</mi>
          </msub>
          <msub>
           <mi>α</mi>
           <mi>t</mi>
          </msub>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>≤</mo>
      <mrow>
       <mrow>
        <mstyle displaystyle="true">
         <munder>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mi>i</mi>
         </munder>
        </mstyle>
        <mrow>
         <mrow>
          <mo>(</mo>
          <mstyle displaystyle="true">
           <mfrac>
            <mrow>
             <mn>1</mn>
             <mo>-</mo>
             <mrow>
              <msub>
               <mi>y</mi>
               <mi>i</mi>
              </msub>
              <msub>
               <mi>h</mi>
               <mi>i</mi>
              </msub>
             </mrow>
            </mrow>
            <mn>2</mn>
           </mfrac>
          </mstyle>
          <mo>)</mo>
         </mrow>
         <msub>
          <mi>w</mi>
          <mi>i</mi>
         </msub>
         <msup>
          <mi>e</mi>
          <msub>
           <mi>α</mi>
           <mi>t</mi>
          </msub>
         </msup>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mstyle displaystyle="true">
         <munder>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mi>i</mi>
         </munder>
        </mstyle>
        <mrow>
         <mrow>
          <mo>(</mo>
          <mstyle displaystyle="true">
           <mfrac>
            <mrow>
             <mn>1</mn>
             <mo>+</mo>
             <mrow>
              <msub>
               <mi>y</mi>
               <mi>i</mi>
              </msub>
              <msub>
               <mi>h</mi>
               <mi>i</mi>
              </msub>
             </mrow>
            </mrow>
            <mn>2</mn>
           </mfrac>
          </mstyle>
          <mo>)</mo>
         </mrow>
         <msub>
          <mi>w</mi>
          <mi>i</mi>
         </msub>
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>-</mo>
           <msub>
            <mi>α</mi>
            <mi>t</mi>
           </msub>
          </mrow>
         </msup>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo>(</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mn>1</mn>
            <mo>+</mo>
            <msub>
             <mi>ϵ</mi>
             <mi>t</mi>
            </msub>
           </mrow>
           <mn>2</mn>
          </mfrac>
         </mstyle>
         <mo>)</mo>
        </mrow>
        <msup>
         <mi>e</mi>
         <msub>
          <mi>α</mi>
          <mi>t</mi>
         </msub>
        </msup>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo>(</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mn>1</mn>
            <mo>-</mo>
            <msub>
             <mi>ϵ</mi>
             <mi>t</mi>
            </msub>
           </mrow>
           <mn>2</mn>
          </mfrac>
         </mstyle>
         <mo>)</mo>
        </mrow>
        <msup>
         <mi>e</mi>
         <mrow>
          <mo>-</mo>
          <msub>
           <mi>α</mi>
           <mi>t</mi>
          </msub>
         </mrow>
        </msup>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>h</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <leq></leq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>y</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>h</ci>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <plus></plus>
           <cn type="integer">1</cn>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>y</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>h</ci>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>α</ci>
            <ci>t</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ϵ</ci>
           <ci>t</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ϵ</ci>
           <ci>t</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle\sum_{i}w_{i}e^{-y_{i}h_{i}\alpha_{t}}&%
\displaystyle\leq\sum_{i}\left(\frac{1-y_{i}h_{i}}{2}\right)w_{i}e^{\alpha_{t}%
}+\sum_{i}\left(\frac{1+y_{i}h_{i}}{2}\right)w_{i}e^{-\alpha_{t}}\\
&\displaystyle=\left(\frac{1+\epsilon_{t}}{2}\right)e^{\alpha_{t}}+\left(\frac%
{1-\epsilon_{t}}{2}\right)e^{-\alpha_{t}}\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>We then differentiate that expression with respect to 

<math display="inline" id="AdaBoost:106">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{t}
  </annotation>
 </semantics>
</math>

 and set it to zero to find the minimum of the upper bound:</p>

<p>

<math display="inline" id="AdaBoost:107">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mrow>
           <mn>1</mn>
           <mo>+</mo>
           <msub>
            <mi>ϵ</mi>
            <mi>t</mi>
           </msub>
          </mrow>
          <mn>2</mn>
         </mfrac>
        </mstyle>
        <mo>)</mo>
       </mrow>
       <msup>
        <mi>e</mi>
        <msub>
         <mi>α</mi>
         <mi>t</mi>
        </msub>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <msub>
            <mi>ϵ</mi>
            <mi>t</mi>
           </msub>
          </mrow>
          <mn>2</mn>
         </mfrac>
        </mstyle>
        <mo>)</mo>
       </mrow>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <msub>
          <mi>α</mi>
          <mi>t</mi>
         </msub>
        </mrow>
       </msup>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>α</mi>
      <mi>t</mi>
     </msub>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <mstyle displaystyle="true">
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mstyle>
       <mrow>
        <mi>ln</mi>
        <mrow>
         <mo>(</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <mrow>
            <mn>1</mn>
            <mo>-</mo>
            <msub>
             <mi>ϵ</mi>
             <mi>t</mi>
            </msub>
           </mrow>
           <mrow>
            <mn>1</mn>
            <mo>+</mo>
            <msub>
             <mi>ϵ</mi>
             <mi>t</mi>
            </msub>
           </mrow>
          </mfrac>
         </mstyle>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ϵ</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ϵ</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <cn type="integer">0</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <ln></ln>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ϵ</ci>
           <ci>t</ci>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ϵ</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle\left(\frac{1+\epsilon_{t}}{2}\right)e^{\alpha_{t}%
}-\left(\frac{1-\epsilon_{t}}{2}\right)e^{-\alpha_{t}}&\displaystyle=0\\
\displaystyle\alpha_{t}&\displaystyle=\frac{1}{2}\ln\left(\frac{1-\epsilon_{t}%
}{1+\epsilon_{t}}\right)\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that this only applies when 

<math display="inline" id="AdaBoost:108">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>i</ci>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}\in\{-1,1\}
  </annotation>
 </semantics>
</math>

, though it can be a good starting guess in other cases, such as when the weak learner is biased (

<math display="inline" id="AdaBoost:109">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mo>≠</mo>
    <mrow>
     <mo>-</mo>
     <mi>b</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <set>
      <ci>a</ci>
      <ci>b</ci>
     </set>
    </apply>
    <apply>
     <neq></neq>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)\in\{a,b\},a\neq-b
  </annotation>
 </semantics>
</math>

), has multiple leaves (

<math display="inline" id="AdaBoost:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <set>
     <ci>a</ci>
     <ci>b</ci>
     <ci>normal-…</ci>
     <ci>n</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)\in\{a,b,\dots,n\}
  </annotation>
 </semantics>
</math>

) or is some other function 

<math display="inline" id="AdaBoost:111">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)\in\mathbb{R}
  </annotation>
 </semantics>
</math>

. In such cases the choice of weak learner and coefficient can be condensed to a single step in which 

<math display="inline" id="AdaBoost:112">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>t</mi>
    </msub>
    <msub>
     <mi>h</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}=\alpha_{t}h_{t}(x)
  </annotation>
 </semantics>
</math>

 is chosen from all possible 

<math display="inline" id="AdaBoost:113">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>,</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>α</ci>
    <ci>h</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha,h
  </annotation>
 </semantics>
</math>

 as the minimizer of 

<math display="inline" id="AdaBoost:114">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>i</mi>
   </msub>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>f</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <list>
       <ci>i</ci>
       <ci>t</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}w_{i,t}e^{-y_{i}f_{t}(x_{i})}
  </annotation>
 </semantics>
</math>

 by some numerical searching routine.</p>
<h2 id="variants">Variants</h2>
<h3 id="real-adaboost">Real AdaBoost</h3>

<p>The output of decision trees is a class probability estimate 

<math display="inline" id="AdaBoost:115">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=P(y=1|x)
  </annotation>
 </semantics>
</math>

, the probability that 

<math display="inline" id="AdaBoost:116">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is in the positive class.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Friedman, Hastie and Tibshirani derive an analytical minimizer for 

<math display="inline" id="AdaBoost:117">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>F</mi>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>t</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{-y\left(F_{t-1}(x)+f_{t}(p(x))\right)}
  </annotation>
 </semantics>
</math>

 for some fixed 

<math display="inline" id="AdaBoost:118">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 (typically chosen using weighted least squares error):</p>

<p>

<math display="block" id="AdaBoost:119">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>x</mi>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>x</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <divide></divide>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}(x)=\frac{1}{2}\ln\left(\frac{x}{1-x}\right)
  </annotation>
 </semantics>
</math>

. Thus, rather than multiplying the output of the entire tree by some fixed value, each leaf node is changed to output half the <a class="uri" href="logit" title="wikilink">logit</a> transform of its previous value.</p>
<h3 id="logitboost">LogitBoost</h3>

<p>LogitBoost represents an application of established <a href="logistic_regression" title="wikilink">logistic regression</a> techniques to the AdaBoost method. Rather than minimizing error with respect to y, weak learners are chosen to minimize the (weighted least-squares) error of 

<math display="inline" id="AdaBoost:120">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}(x)
  </annotation>
 </semantics>
</math>

 with respect to</p>

<p>

<math display="block" id="AdaBoost:121">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>y</mi>
      <mo>*</mo>
     </msup>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>t</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>p</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>t</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <times></times>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>t</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>t</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{t}=\frac{y^{*}-p_{t}(x)}{2p_{t}(x)(1-p_{t}(x))}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="AdaBoost:122">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <msub>
       <mi>F</mi>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <msub>
        <mi>F</mi>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mo>+</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>F</mi>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <apply>
           <minus></minus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{t}(x)=\frac{e^{F_{t-1}(x)}}{e^{F_{t-1}(x)}+e^{-F_{t-1}(x)}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="AdaBoost:123">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>t</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>t</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{t}=p_{t}(x)(1-p_{t}(x))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="AdaBoost:124">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>y</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <times></times>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{*}=\frac{y+1}{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>That is 

<math display="inline" id="AdaBoost:125">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{t}
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="Newton-Raphson" title="wikilink">Newton-Raphson</a> approximation of the minimizer of the log-likelihood error at stage 

<math display="inline" id="AdaBoost:126">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, and the weak learner 

<math display="inline" id="AdaBoost:127">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}
  </annotation>
 </semantics>
</math>

 is chosen as the learner that best approximates 

<math display="inline" id="AdaBoost:128">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{t}
  </annotation>
 </semantics>
</math>

 by weighted least squares.</p>

<p>As p approaches either 1 or 0, the value of 

<math display="inline" id="AdaBoost:129">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>t</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{t}(x_{i})(1-p_{t}(x_{i}))
  </annotation>
 </semantics>
</math>

 becomes very small and the z term, which will be large for misclassified samples, can become <a href="numerical_instability" title="wikilink">numerically unstable</a>, due to machine precision rounding errors. This can be overcome by enforcing some limit on the absolute value of z and the minimum value of w.</p>
<h3 id="gentle-adaboost">Gentle AdaBoost</h3>

<p>While previous boosting algorithms choose 

<math display="inline" id="AdaBoost:130">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}
  </annotation>
 </semantics>
</math>

 greedily, minimizing the overall test error as much as possible at each step GentleBoost features a bounded step size. 

<math display="inline" id="AdaBoost:131">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}
  </annotation>
 </semantics>
</math>

 is chosen to minimize 

<math display="inline" id="AdaBoost:132">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>i</mi>
   </msub>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>t</mi>
      <mo>,</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>t</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <list>
       <ci>t</ci>
       <ci>i</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}w_{t,i}(y_{i}-f_{t}(x_{i}))^{2}
  </annotation>
 </semantics>
</math>

, and no further coefficient is applied. Thus, in the case where a weak learner exhibits perfect classification performance, GentleBoost will choose 

<math display="inline" id="AdaBoost:133">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>t</mi>
    </msub>
    <msub>
     <mi>h</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}(x)=\alpha_{t}h_{t}(x)
  </annotation>
 </semantics>
</math>

 exactly equal to 

<math display="inline" id="AdaBoost:134">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, while steepest descent algorithms will try to set 

<math display="inline" id="AdaBoost:135">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>t</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{t}=\infty
  </annotation>
 </semantics>
</math>

. Empirical observations about the good performance of GentleBoost appear to back up Schapire and Singer's remark that allowing excessively large values of 

<math display="inline" id="AdaBoost:136">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 can lead to poor generalization performance.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="early-termination">Early Termination</h3>

<p>A technique for speeding up processing of boosted classifiers, early termination refers to only testing each potential object with as many layers of the final classifier necessary to meet some confidence threshold, speeding up computation for cases where the class of the object can easily be determined. One such scheme is the object detection framework introduced by Viola and Jones:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> in an application with significantly more negative samples than positive, a cascade of separate boost classifiers is trained, the output of each stage biased such that some acceptably small fraction of positive samples is mislabeled as negative, and all samples marked as negative after each stage are discarded. If 50% of negative samples are filtered out by each stage, only a very small number of objects would pass through the entire classifier, reducing computation effort. This method has since been generalized, with a formula provided for choosing optimal thresholds at each stage to achieve some desired false positive and false negative rate.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>In the field of statistics, where AdaBoost is more commonly applied to problems of moderate dimensionality, <a href="early_stopping" title="wikilink">early stopping</a> is used as a strategy to reduce <a class="uri" href="overfitting" title="wikilink">overfitting</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> A validation set of samples is separated from the training set, performance of the classifier on the samples used for training is compared to performance on the validation samples, and training is terminated if performance on the validation sample is seen to decrease even as performance on the training set continues to improve.</p>
<h3 id="totally-corrective-algorithms">Totally Corrective Algorithms</h3>

<p>For steepest descent versions of AdaBoost, where 

<math display="inline" id="AdaBoost:137">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{t}
  </annotation>
 </semantics>
</math>

 is chosen at each layer <em>t</em> to minimize test error, the next layer added is said to be <em>maximally independent</em> of layer <em>t</em>:<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> it is unlikely that a weak learner <em>t+1</em> will be chosen that is similar to learner <em>t</em>. However, there remains the possibility that <em>t+1</em> produces similar information to some other earlier layer. Totally corrective algorithms, such as <a class="uri" href="LPBoost" title="wikilink">LPBoost</a>, optimize the value of every coefficient after each step, such that new layers added are always maximally independent of every previous layer. This can be accomplished by backfitting, <a href="linear_programming" title="wikilink">linear programming</a> or some other method.</p>
<h3 id="pruning">Pruning</h3>

<p>Pruning refers to the process of removing poorly performing weak classifiers, in order to improve the memory and execution-time cost of the boosted classifier. The simplest methods, which can be particularly effective in conjunction with totally corrective training, are weight- or margin-trimming: when the coefficient, or the contribution to the total test error, of some weak classifier falls below a certain threshold, that classifier is dropped. Margineantu &amp; Dietterich<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> suggest an alternative criteria for trimming: weak classifiers should be selected such that the diversity of the ensemble is maximized. If two weak learners produce very similar outputs, efficiency can be improved by removing one of them and increasing the coefficient of the remaining weak learner.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bootstrap_aggregating" title="wikilink">Bootstrap aggregating</a></li>
<li><a class="uri" href="CoBoosting" title="wikilink">CoBoosting</a></li>
<li><a class="uri" href="BrownBoost" title="wikilink">BrownBoost</a></li>
<li><a href="Gradient_boosting" title="wikilink">Gradient boosting</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="implementations">Implementations</h2>
<ul>
<li><a href="http://www.inf.fu-berlin.de/inst/ag-ki/adaboost4.pdf">AdaBoost and the Super Bowl of Classifiers - A Tutorial on AdaBoost.</a></li>
<li><a href="http://codingplayground.blogspot.com/2009/03/adaboost-improve-your-performance.html">AdaBoost in C++</a>, an implementation of AdaBoost in C++ and boost by Antonio Gulli</li>
<li><a href="http://code.google.com/p/icsiboost/">icsiboost</a>, an open source implementation of Boostexter</li>
<li><a href="http://jboost.sourceforge.net">JBoost</a>, a site offering a classification and visualization package, implementing AdaBoost among other boosting algorithms.</li>
<li><a href="http://graphics.cs.msu.ru/en/science/research/machinelearning/AdaBoosttoolbox">MATLAB AdaBoost toolbox. Includes Real AdaBoost, Gentle AdaBoost and Modest AdaBoost implementations.</a></li>
<li>[<a class="uri" href="http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=21317&amp;objectType">http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=21317&amp;objectType;</a>;=file A Matlab Implementation of AdaBoost]</li>
<li><a href="https://sites.google.com/site/carlosbecker/resources/gradient-boosting-boosted-trees">Multi-threaded MATLAB-compatible implementation of Boosted Trees</a></li>
<li><a href="http://luispedro.org/software/milk">milk</a> for Python implements <a href="http://packages.python.org/milk/AdaBoost.html">AdaBoost</a>.</li>
<li><a href="http://www.esuli.it/mpboost">MPBoost++</a>, a C++ implementation of the original AdaBoost.MH algorithm and of an improved variant, the MPBoost algorithm.</li>
<li><a href="http://www.multiboost.org/">multiboost</a>, a fast C++ implementation of multi-class/multi-label/multi-task boosting algorithms. It is based on AdaBoost.MH but also implements popular cascade classifiers and FilterBoost along with a batch of common multi-class base learners (stumps, trees, products, Haar filters).</li>
<li><a href="http://npatternrecognizer.codeplex.com/">NPatternRecognizer</a>, a fast machine learning algorithm library written in C#. It contains support vector machine, neural networks, bayes, boost, k-nearest neighbor, decision tree, ..., etc.</li>
<li><a href="http://docs.opencv.org/modules/ml/doc/boosting.html">OpenCV implementation of several boosting variants</a></li>
<li><a href="https://github.com/topiolli/into">Into</a> contains open source implementations of many AdaBoost and FloatBoost variants in C++.</li>
<li><a href="http://mallet.cs.umass.edu/">Mallet</a> Java implementation.</li>
<li><a href="http://cran.r-project.org/web/packages/adabag/">adabag</a> adabag: An R package for binary and multiclass Boosting and Bagging.</li>
<li><a href="http://scikit-learn.org/dev/modules/ensemble.html#AdaBoost">Scikit-learn</a> Python implementation.</li>
<li><a href="http://www.fertilized-forests.org">fertilized forests</a> A general purpose, platform independent, easy to extend decision forest library that supports boosted training based on multiclass AdaBoost.M2, Samme and Samme.R</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>

<p>original paper of Yoav Freund and Robert E.Schapire where AdaBoost is first introduced.</p></li>
<li>

<p>a site on boosting and related ensemble learning methods</p></li>
<li>

<p>presentation summarizing AdaBoost (see page 4 for an illustrated example of performance).</p></li>
<li>

<p>presentation showing an AdaBoost example.</p></li>
<li>

<p>introduction to AdaBoost</p></li>
<li></li>
<li>

<p>a tutorial article on ensemble systems including pseudocode, block diagrams and implementation issues for AdaBoost and other ensemble learning algorithms.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a> <a href="Category:Ensemble_learning" title="wikilink">Category:Ensemble learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Rojas, R. (2009). <a href="http://www.inf.fu-berlin.de/inst/ag-ki/adaboost4.pdf">AdaBoost and the super bowl of classifiers a tutorial introduction to adaptive boosting. Freie University, Berlin, Tech. Rep.</a><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3">T. Zhang, "Statistical behavior and consistency of classification methods based on convex risk minimization", Annals of Statistics 32 (1), pp. 56-85, 2004.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
</ol>
</section>
</hr></body>
</html>
