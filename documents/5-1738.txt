   Williams' p + 1 algorithm      Williams' p + 1 algorithm   In computational number theory , Williams' p + 1 algorithm is an integer factorization algorithm, one of the family of algebraic-group factorisation algorithms . It was invented by Hugh C. Williams in 1982.  It works well if the number N to be factored contains one or more prime factors p such that   p + 1   is smooth , i.e. p + 1 contains only small factors. It uses Lucas sequences to perform exponentiation in a quadratic field .  It is analogous to Pollard's p − 1 algorithm .  Algorithm  Choose some integer A greater than 2 which characterizes the Lucas sequence :        V  0   =  2   ,     V  1   =  A   ,    V  j   =    A   V   j  -  1     -   V   j  -  2          formulae-sequence     subscript  V  0   2    formulae-sequence     subscript  V  1   A      subscript  V  j       A   subscript  V    j  1      subscript  V    j  2         V_{0}=2,V_{1}=A,V_{j}=AV_{j-1}-V_{j-2}     where all operations are performed modulo N .  Then any odd prime p divides    gcd   (  N  ,    V  M   -  2   )       N     subscript  V  M   2     \gcd(N,V_{M}-2)   whenever M is a multiple of    p  -   (   D  /  p   )       p    D  p     p-(D/p)   , where    D  =    A  2   -  4       D     superscript  A  2   4     D=A^{2}-4   and    (   D  /  p   )      D  p    (D/p)   is the Jacobi symbol .  We require that     (   D  /  p   )   =   -  1         D  p     1     (D/p)=-1   , that is, D should be a quadratic non-residue modulo p . But as we don't know p beforehand, more than one value of A may be required before finding a solution. If     (   D  /  p   )   =   +  1         D  p     1     (D/p)=+1   , this algorithm degenerates into a slow version of Pollard's p − 1 algorithm .  So, for different values of M we calculate    gcd   (  N  ,    V  M   -  2   )       N     subscript  V  M   2     \gcd(N,V_{M}-2)   , and when the result is not equal to 1 or to N , we have found a non-trivial factor of N .  The values of M used are successive factorials, and    V  M     subscript  V  M    V_{M}   is the M -th value of the sequence characterized by    V   M  -  1      subscript  V    M  1     V_{M-1}   .  To find the M -th element V of the sequence characterized by B , we proceed in a manner similar to left-to-right exponentiation:  x=B  y=(B^2-2) mod N  for each bit of M to the right of the most significant bit  if the bit is 1  x=(x*y-B) mod N  y=(y^2-2) mod N  else  y=(x*y-B) mod N  x=(x^2-2) mod N  V=x  Example  With N =112729 and A =5, successive values of    V  M     subscript  V  M    V_{M}   are:   V 1 of seq(5) = V 1! of seq(5) = 5    V 2 of seq(5) = V 2! of seq(5) = 23    V 3 of seq(23) = V 3! of seq(5) = 12098    V 4 of seq(12098) = V 4! of seq(5) = 87680    V 5 of seq(87680) = V 5! of seq(5) = 53242    V 6 of seq(53242) = V 6! of seq(5) = 27666    V 7 of seq(27666) = V 7! of seq(5) = 110229.   At this point, gcd(110229-2,112729) = 139, so 139 is a non-trivial factor of 112729. Notice that p+1 = 140 = 2 2 × 5 × 7. The number 7! is the lowest factorial which is multiple of 140, so the proper factor 139 is found in this step.  Using another initial value, say A = 9, we get:   V 1 of seq(9) = V 1! of seq(9) = 9    V 2 of seq(9) = V 2! of seq(9) = 79    V 3 of seq(79) = V 3! of seq(9) = 41886    V 4 of seq(41886) = V 4! of seq(9) = 79378    V 5 of seq(79378) = V 5! of seq(9) = 1934    V 6 of seq(1934) = V 6! of seq(9) = 10582    V 7 of seq(10582) = V 7! of seq(9) = 84241    V 8 of seq(84241) = V 8! of seq(9) = 93973    V 9 of seq(93973) = V 9! of seq(9) = 91645.   At this point gcd(91645-2,112729) = 811, so 811 is a non-trivial factor of 112729. Notice that p-1 = 810 = 2 × 5 × 3 4 . The number 9! is the lowest factorial which is multiple of 810, so the proper factor 811 is found in this step. The factor 139 is not found this time because p-1 = 138 = 2 × 3 × 23 which is not a divisor of 9!  As can be seen in these examples we don't know in advance whether the prime that will be found has a smooth p+1 or p-1.  Generalization  Based on Pollard's p -1 and Williams' p +1 factoring algorithms, Eric Bach and Jeffrey Shallit developed techniques to factor n efficiently provided that it has a prime factor p such that any k th  cyclotomic polynomial  Φ k (p) is smooth . 1 The first few cyclotomic polynomials are given by the sequence Φ 1 (p) = p-1 , Φ 2 (p) = p+1 , Φ 3 (p) = p 2 +p+1 , and Φ 4 (p) = p 2 +1 .  References       External links   P Plus 1 Factorization Method , MersenneWiki.   "  Category:Integer factorization algorithms     ↩     