   Benaloh cryptosystem      Benaloh cryptosystem   The Benaloh Cryptosystem is an extension of the Goldwasser-Micali cryptosystem (GM) created in 1994 by Josh (Cohen) Benaloh. The main improvement of the Benaloh Cryptosystem over GM is that longer blocks of data can be encrypted at once, whereas in GM each bit is encrypted individually. 1  Scheme Definition  Like many public key cryptosystems , this scheme works in the group     (    ℤ  /  n   ℤ   )   *     superscript      ℤ  n   ℤ      (\mathbb{Z}/n\mathbb{Z})^{*}   where n is a product of two large primes . This scheme is homomorphic and hence malleable .  Key Generation  Given block size r , a public/private key pair is generated as follows:   Choose large primes p and q such that    r  |   (  p  -  1  )   ,  gcd   (  r  ,   (  p  -  1  )   /  r  )   =  1  ,     fragments  r  normal-|   fragments  normal-(  p   1  normal-)   normal-,  gcd   fragments  normal-(  r  normal-,   fragments  normal-(  p   1  normal-)    r  normal-)    1  normal-,    r|(p-1),\operatorname{gcd}(r,(p-1)/r)=1,   and     gcd   (  r  ,   (   q  -  1   )   )    =  1       gcd  r    q  1    1    \operatorname{gcd}(r,(q-1))=1     Set     n  =   p  q    ,   ϕ  =    (   p  -  1   )    (   q  -  1   )        formulae-sequence    n    p  q      ϕ      p  1     q  1       n=pq,\phi=(p-1)(q-1)     Choose    y  ∈   ℤ  n  *       y   subscript   superscript  ℤ    n     y\in\mathbb{Z}^{*}_{n}   such that     y   ϕ  /  r    ≢   1  mod  n      not-equivalent-to   superscript  y    ϕ  r     modulo  1  n     y^{\phi/r}\not\equiv 1\mod n   .     Note: If r is composite, it was pointed out by Fousse et al. in 2011 2 that the above conditions (i.e., those stated in the original paper) are insufficient to guarantee correct decryption, i.e., to guarantee that     D   (   E   (  m  )    )    =  m        D    E  m    m    D(E(m))=m   in all cases (as should be the case). To address this, the authors propose the following check: let    r  =    p  1    p  2   …   p  k        r     subscript  p  1    subscript  p  2   normal-…   subscript  p  k      r=p_{1}p_{2}\dots p_{k}   be the prime factorization of r . Choose    y  ∈   ℤ  n  *       y   subscript   superscript  ℤ    n     y\in\mathbb{Z}^{*}_{n}   such that for each factor    p  i     subscript  p  i    p_{i}   , it is the case that     y   ϕ  /   p  i     ≠   1  mod  n        superscript  y    ϕ   subscript  p  i      modulo  1  n     y^{\phi/p_{i}}\neq 1\mod n   .      Set    x  =    y   ϕ  /  r    mod  n       x   modulo   superscript  y    ϕ  r    n     x=y^{\phi/r}\mod n      The public key is then    y  ,  n     y  n    y,n   , and the private key is    ϕ  ,  x     ϕ  x    \phi,x   .  Message Encryption  To encrypt message    m  ∈   ℤ  r       m   subscript  ℤ  r     m\in\mathbb{Z}_{r}   :   Choose a random    u  ∈   ℤ  n  *       u   subscript   superscript  ℤ    n     u\in\mathbb{Z}^{*}_{n}     Set      E  r    (  m  )    =     y  m    u  r    mod  n          subscript  E  r   m    modulo     superscript  y  m    superscript  u  r    n     E_{r}(m)=y^{m}u^{r}\mod n      Message Decryption  To decrypt a ciphertext    c  ∈   ℤ  n  *       c   subscript   superscript  ℤ    n     c\in\mathbb{Z}^{*}_{n}   :   Compute    a  =    c   ϕ  /  r    mod  n       a   modulo   superscript  c    ϕ  r    n     a=c^{\phi/r}\mod n     Output    m  =    log  x    (  a  )        m    subscript   x   a     m=\log_{x}(a)   , i.e., find m such that     x  m   ≡   a  mod  n        superscript  x  m    modulo  a  n     x^{m}\equiv a\mod n      To understand decryption, first notice that for any    m  ∈   ℤ  r       m   subscript  ℤ  r     m\in\mathbb{Z}_{r}   and    u  ∈   ℤ  n  *       u   subscript   superscript  ℤ    n     u\in\mathbb{Z}^{*}_{n}   we have:      a  =    (  c  )    ϕ  /  r    ≡    (    y  m    u  r    )    ϕ  /  r    ≡     (   y  m   )    ϕ  /  r      (   u  r   )    ϕ  /  r     ≡     (   y   ϕ  /  r    )   m     (  u  )   ϕ    ≡     (  x  )   m     (  u  )   0    ≡    x  m   mod  n         a   superscript  c    ϕ  r          superscript     superscript  y  m    superscript  u  r      ϕ  r            superscript   superscript  y  m     ϕ  r     superscript   superscript  u  r     ϕ  r             superscript   superscript  y    ϕ  r    m    superscript  u  ϕ            superscript  x  m    superscript  u  0          modulo   superscript  x  m   n      a=(c)^{\phi/r}\equiv(y^{m}u^{r})^{\phi/r}\equiv(y^{m})^{\phi/r}(u^{r})^{\phi/r%
 }\equiv(y^{\phi/r})^{m}(u)^{\phi}\equiv(x)^{m}(u)^{0}\equiv x^{m}\mod n     To recover m from a , we take the discrete log of a base x . If r is small, we can recover m by an exhaustive search, i.e. checking if     x  i   ≡   a  mod  n        superscript  x  i    modulo  a  n     x^{i}\equiv a\mod n   for all    0  …   (   r  -  1   )       0  normal-…    r  1     0\dots(r-1)   . For larger values of r , the Baby-step giant-step algorithm can be used to recover m in    O   (   r   )       O    r     O(\sqrt{r})   time and space.  Security  The security of this scheme rests on the Higher residuosity problem , specifically, given z , r and n where the factorization of n is unknown, it is computationally infeasible to determine whether z is an r th residue mod n , i.e. if there exists an x such that    z  ≡    x  r   mod  n       z   modulo   superscript  x  r   n     z\equiv x^{r}\mod n   .  References  "  Category:Public-key encryption schemes     ↩  ↩     