   Occurs check      Occurs check   In computer science , the occurs check is a part of algorithms for syntactic unification . It causes unification of a variable  V and a structure S to fail if S contains V .  Application in theorem proving  In theorem proving , unification without the occurs check can lead to unsound  inference . For example, the Prolog goal    X  =   f   (  X  )        X    f  X     X=f(X)   will succeed, binding X to a cyclic structure which has no counterpart in the Herbrand universe . As another example, 1 without occurs-check, a resolution proof can be found for the non-theorem 2      (  ∀  x  ∃  y  .  p   (  x  ,  y  )   )   →   (  ∃  y  ∀  x  .  p   (  x  ,  y  )   )      fragments   fragments  normal-(  for-all  x   y  normal-.  p   fragments  normal-(  x  normal-,  y  normal-)   normal-)   normal-→   fragments  normal-(   y  for-all  x  normal-.  p   fragments  normal-(  x  normal-,  y  normal-)   normal-)     (\forall x\exists y.p(x,y))\rightarrow(\exists y\forall x.p(x,y))   : the negation of that formula has the conjunctive normal form      p   (  X  ,   f   (  X  )    )    ∧   ¬  p   (   g   (  Y  )    ,  Y  )          p   X    f  X        p     g  Y   Y      p(X,f(X))\land\lnot p(g(Y),Y)   , with   f   f   f   and   g   g   g   denoting the Skolem function for the first and second existential quantifier, respectively; the literals    p   (  X  ,   f   (  X  )    )       p   X    f  X      p(X,f(X))   and    p   (   g   (  Y  )    ,  Y  )       p     g  Y   Y     p(g(Y),Y)   are unifiable without occurs check, producing the refuting empty clause.  thumb|upright=0.5|Cycle by omitted occurs check  Prolog implementation  By default, Prolog implementations usually omit the occurs check for reasons of efficiency, which can lead to circular data structures and looping. By not performing the occurs check, the worst case complexity of unifying a term    t  1     subscript  t  1    t_{1}   with term    t  2     subscript  t  2    t_{2}   is reduced from    O   (    size   (   t  1   )    +   size   (   t  2   )     )       O      size   subscript  t  1      size   subscript  t  2       O(\text{size}(t_{1})+\text{size}(t_{2}))   to    O   (   min   (   size   (   t  1   )    ,   size   (   t  2   )    )    )       O    min     size   subscript  t  1      size   subscript  t  2        O(\text{min}(\text{size}(t_{1}),\text{size}(t_{2})))   ; in particular, the frequent case of variable-term unifications, runtime shrinks to    O   (  1  )       O  1    O(1)   . 3  A naive omission of the occurs check leads to the creation of cyclic structures and may cause unification to loop forever. Modern implementations, based on Colmerauer's Prolog II, 4  5  6  7 use rational tree unification to avoid looping. See image for an example run of the unification algorithm given in Unification (computer science)#A unification algorithm , trying to solve the goal     c  o  n  s   (  x  ,  y  )     =  ?    c  o  n  s   (  1  ,   c  o  n  s   (  x  ,   c  o  n  s   (  2  ,  y  )    )    )        superscript   normal-?     c  o  n  s   x  y      c  o  n  s   1    c  o  n  s   x    c  o  n  s   2  y          cons(x,y)\stackrel{?}{=}cons(1,cons(x,cons(2,y)))   , however without the occurs check rule (named "check" there); applying rule "eliminate" instead leads to a cyclic graph (i.e. an infinite term) in the last step.  ISO Prolog implementations have the built-in predicate unify_with_occurs_check/2 for sound unification but are free to use unsound or even looping algorithms when unification is invoked otherwise, provided the algorithm works correctly for all cases that are "not subject to occurs-check" (NSTO). 8 Implementations offering sound unification for all unifications (optionally, via a runtime flag) are XSB and SWI-Prolog .  References     "  Category:Automated theorem proving  Category:Logic programming  Category:Programming constructs  Category:Unification (computer science)     ; here: p.143 ↩  Informally, and taking    p   (  x  ,  y  )       p   x  y     p(x,y)   to mean e.g. " x loves y ", the formula reads " If everybody loves somebody, then a single person must exist that is loved by everyone. " ↩  ↩  ↩  ↩  ↩  ↩  7.3.4 Normal unification in Prolog of ISO/IEC 13211-1:1995. ↩     