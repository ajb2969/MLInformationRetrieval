<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1030">Expander code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Expander code</h1>
<hr/>

<p>In <a href="coding_theory" title="wikilink">coding theory</a>, <strong>expander codes</strong> form a class of <a href="Error_detection_and_correction" title="wikilink">error-correcting codes</a> that are constructed from <a href="Bipartite_graph" title="wikilink">bipartite</a> <a href="expander_graph" title="wikilink">expander graphs</a>. Along with <a href="Justesen_code" title="wikilink">Justesen codes</a>, expander codes are of particular interest since they have a constant positive <a href="Block_code#The_rate_R" title="wikilink">rate</a>, a constant positive relative <a href="Block_code#The_distance_d" title="wikilink">distance</a>, and a constant <a href="Block_code#The_alphabet_.CE.A3" title="wikilink">alphabet size</a>. In fact, the alphabet contains only two elements, so expander codes belong to the class of <a href="binary_code" title="wikilink">binary codes</a>. Furthermore, expander codes can be both encoded and decoded in time proportional to the block length of the code. Expander codes are the only known asymptotically good codes which can be both encoded and decoded from a constant fraction of errors in polynomial time.</p>
<h2 id="expander-codes">Expander codes</h2>

<p>In <a href="coding_theory" title="wikilink">coding theory</a>, an expander code is a 

<math display="inline" id="Expander_code:0">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo>,</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mn>2</mn>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <interval closure="closed">
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
    </interval>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n,n-m]_{2}\,
  </annotation>
 </semantics>
</math>

 <a href="linear_block_code" title="wikilink">linear block code</a> whose parity check matrix is the adjacency matrix of a bipartite <a href="expander_graph" title="wikilink">expander graph</a>. These codes have good relative <a href="Block_code#The_distance_d" title="wikilink">distance</a> 

<math display="inline" id="Expander_code:1">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>ε</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+1.7pt">
    <mi>γ</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>ε</ci>
    </apply>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2(1-\varepsilon)\gamma\,
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Expander_code:2">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>ε</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Expander_code:3">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>γ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\,
  </annotation>
 </semantics>
</math>

 are properties of the expander graph as defined later), <a href="Block_code#The_rate_R" title="wikilink">rate</a> 

<math display="inline" id="Expander_code:4">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mi>m</mi>
     <mi>n</mi>
    </mfrac>
   </mrow>
   <mo rspace="4.2pt">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(1-\tfrac{m}{n}\right)\,
  </annotation>
 </semantics>
</math>

, and decodability (algorithms of running time 

<math display="inline" id="Expander_code:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)\,
  </annotation>
 </semantics>
</math>

 exist).</p>
<h2 id="definition">Definition</h2>

<p>Consider a <a href="bipartite_graph" title="wikilink">bipartite graph</a> 

<math display="inline" id="Expander_code:6">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <vector>
     <ci>L</ci>
     <ci>R</ci>
     <ci>E</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(L,R,E)\,
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Expander_code:7">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>L</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Expander_code:8">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 are the vertex sets and 

<math display="inline" id="Expander_code:9">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>E</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\,
  </annotation>
 </semantics>
</math>

 is the set of edges connecting vertices in 

<math display="inline" id="Expander_code:10">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>L</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\,
  </annotation>
 </semantics>
</math>

 to vertices of 

<math display="inline" id="Expander_code:11">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

. Suppose every vertex in 

<math display="inline" id="Expander_code:12">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>L</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\,
  </annotation>
 </semantics>
</math>

 has <a href="degree_(graph_theory)" title="wikilink">degree</a> 

<math display="inline" id="Expander_code:13">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>d</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\,
  </annotation>
 </semantics>
</math>

 (the graph is 

<math display="inline" id="Expander_code:14">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>d</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\,
  </annotation>
 </semantics>
</math>

-<a href="Regular_graph" title="wikilink">regular</a>), 

<math display="inline" id="Expander_code:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>L</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>L</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |L|=n\,
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Expander_code:16">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>R</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mi>m</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>R</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |R|=m\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Expander_code:17">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m<n\,
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Expander_code:18">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>G</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\,
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Expander_code:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>N</mi>
   <mo>,</mo>
   <mi>M</mi>
   <mo>,</mo>
   <mi>d</mi>
   <mo>,</mo>
   <mi>γ</mi>
   <mo>,</mo>
   <mi>α</mi>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>N</ci>
    <ci>M</ci>
    <ci>d</ci>
    <ci>γ</ci>
    <ci>α</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N,M,d,\gamma,\alpha)\,
  </annotation>
 </semantics>
</math>

 expander graph if every small enough subset 

<math display="inline" id="Expander_code:20">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊂</mo>
   <mpadded width="+1.7pt">
    <mi>L</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subset L\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Expander_code:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|\leq\gamma n\,
  </annotation>
 </semantics>
</math>

 has the property that 

<math display="inline" id="Expander_code:22">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

 has at least 

<math display="inline" id="Expander_code:23">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo rspace="4.2pt" stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>α</ci>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\alpha|S|\,
  </annotation>
 </semantics>
</math>

 distinct neighbors in 

<math display="inline" id="Expander_code:24">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

. Note that this holds trivially for 

<math display="inline" id="Expander_code:25">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>≤</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>γ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\leq\tfrac{1}{n}\,
  </annotation>
 </semantics>
</math>

. When 

<math display="inline" id="Expander_code:26">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>n</mi>
   </mfrac>
   <mo><</mo>
   <mi>γ</mi>
   <mo>≤</mo>
   <mpadded width="+1.7pt">
    <mn>1</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <ci>γ</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{1}{n}<\gamma\leq 1\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Expander_code:27">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mi>ε</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=1-\varepsilon\,
  </annotation>
 </semantics>
</math>

 for a constant 

<math display="inline" id="Expander_code:28">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>ε</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon\,
  </annotation>
 </semantics>
</math>

, we say that 

<math display="inline" id="Expander_code:29">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>G</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\,
  </annotation>
 </semantics>
</math>

 is a lossless expander.</p>

<p>Since 

<math display="inline" id="Expander_code:30">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>G</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\,
  </annotation>
 </semantics>
</math>

 is a bipartite graph, we may consider its 

<math display="inline" id="Expander_code:31">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mpadded width="+1.7pt">
    <mi>m</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times m\,
  </annotation>
 </semantics>
</math>

 adjacency matrix. Then the linear code 

<math display="inline" id="Expander_code:32">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>C</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\,
  </annotation>
 </semantics>
</math>

 generated by viewing the transpose of this matrix as a parity check matrix is an expander code.</p>

<p>It has been shown that nontrivial lossless expander graphs exist. Moreover, we can explicitly construct them.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="rate">Rate</h2>

<p>The rate of 

<math display="inline" id="Expander_code:33">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>C</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\,
  </annotation>
 </semantics>
</math>

 is its dimension divided by its block length. In this case, the parity check matrix has size 

<math display="inline" id="Expander_code:34">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times n\,
  </annotation>
 </semantics>
</math>

, and hence 

<math display="inline" id="Expander_code:35">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>C</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\,
  </annotation>
 </semantics>
</math>

 has dimension at least 

<math display="inline" id="Expander_code:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mfrac>
      <mi>m</mi>
      <mi>n</mi>
     </mfrac>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-m)/n=1-\tfrac{m}{n}\,
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="distance">Distance</h2>

<p>Suppose 

<math display="inline" id="Expander_code:37">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>ε</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon<\tfrac{1}{2}\,
  </annotation>
 </semantics>
</math>

. Then the distance of a 

<math display="inline" id="Expander_code:38">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mi>d</mi>
   <mo>,</mo>
   <mi>γ</mi>
   <mo>,</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>ε</mi>
   </mrow>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>n</ci>
    <ci>m</ci>
    <ci>d</ci>
    <ci>γ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>ε</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,m,d,\gamma,1-\varepsilon)\,
  </annotation>
 </semantics>
</math>

 expander code 

<math display="inline" id="Expander_code:39">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>C</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\,
  </annotation>
 </semantics>
</math>

 is at least 

<math display="inline" id="Expander_code:40">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>ε</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>γ</mi>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>ε</ci>
    </apply>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2(1-\varepsilon)\gamma n\,
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="proof">Proof</h3>

<p>Note that we can consider every codeword 

<math display="inline" id="Expander_code:41">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>c</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Expander_code:42">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>C</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\,
  </annotation>
 </semantics>
</math>

 as a subset of vertices 

<math display="inline" id="Expander_code:43">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊂</mo>
   <mpadded width="+1.7pt">
    <mi>L</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subset L\,
  </annotation>
 </semantics>
</math>

, by saying that vertex 

<math display="inline" id="Expander_code:44">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <mi>S</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\in S\,
  </annotation>
 </semantics>
</math>

 if and only if the 

<math display="inline" id="Expander_code:45">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>i</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\,
  </annotation>
 </semantics>
</math>

th index of the codeword is a 1. Then 

<math display="inline" id="Expander_code:46">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>c</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,
  </annotation>
 </semantics>
</math>

 is a codeword iff every vertex 

<math display="inline" id="Expander_code:47">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <mi>R</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in R\,
  </annotation>
 </semantics>
</math>

 is adjacent to an even number of vertices in 

<math display="inline" id="Expander_code:48">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

. (In order to be a codeword, 

<math display="inline" id="Expander_code:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>P</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   cP=0\,
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Expander_code:50">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,
  </annotation>
 </semantics>
</math>

 is the parity check matrix. Then, each vertex in 

<math display="inline" id="Expander_code:51">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 corresponds to each column of 

<math display="inline" id="Expander_code:52">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,
  </annotation>
 </semantics>
</math>

. Matrix multiplication over 

<math display="inline" id="Expander_code:53">
 <semantics>
  <mrow>
   <mrow>
    <mtext>GF</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo rspace="4.2pt" stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>GF</mtext>
     <cn type="integer">2</cn>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{GF}(2)=\{0,1\}\,
  </annotation>
 </semantics>
</math>

 then gives the desired result.) So, if a vertex 

<math display="inline" id="Expander_code:54">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <mi>R</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in R\,
  </annotation>
 </semantics>
</math>

 is adjacent to a single vertex in 

<math display="inline" id="Expander_code:55">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

, we know immediately that 

<math display="inline" id="Expander_code:56">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>c</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,
  </annotation>
 </semantics>
</math>

 is not a codeword. Let 

<math display="inline" id="Expander_code:57">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(S)\,
  </annotation>
 </semantics>
</math>

 denote the neighbors in 

<math display="inline" id="Expander_code:58">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Expander_code:59">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Expander_code:60">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(S)\,
  </annotation>
 </semantics>
</math>

 denote those neighbors of 

<math display="inline" id="Expander_code:61">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

 which are unique, i.e., adjacent to a single vertex of 

<math display="inline" id="Expander_code:62">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="lemma-1">Lemma 1</h4>

<p>For every 

<math display="inline" id="Expander_code:63">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊂</mo>
   <mpadded width="+1.7pt">
    <mi>L</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subset L\,
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="Expander_code:64">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|\leq\gamma n\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Expander_code:65">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo rspace="4.2pt" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <abs></abs>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>U</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>ε</ci>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d|S|\geq|N(S)|\geq|U(S)|\geq d(1-2\varepsilon)|S|\,
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="proof-1">Proof</h4>

<p>Trivially, 

<math display="inline" id="Expander_code:66">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |N(S)|\geq|U(S)|\,
  </annotation>
 </semantics>
</math>

, since 

<math display="inline" id="Expander_code:67">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in U(S)\,
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Expander_code:68">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in N(S)\,
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Expander_code:69">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo rspace="4.2pt" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <abs></abs>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |N(S)|\leq d|S|\,
  </annotation>
 </semantics>
</math>

 follows since the degree of every vertex in 

<math display="inline" id="Expander_code:70">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Expander_code:71">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>d</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\,
  </annotation>
 </semantics>
</math>

. By the expansion property of the graph, there must be a set of 

<math display="inline" id="Expander_code:72">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>ε</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo rspace="4.2pt" stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>ε</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(1-\varepsilon)|S|\,
  </annotation>
 </semantics>
</math>

 edges which go to distinct vertices. The remaining 

<math display="inline" id="Expander_code:73">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>ε</mi>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo rspace="4.2pt" stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>ε</ci>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\varepsilon|S|\,
  </annotation>
 </semantics>
</math>

 edges make at most 

<math display="inline" id="Expander_code:74">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>ε</mi>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo rspace="4.2pt" stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>ε</ci>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\varepsilon|S|\,
  </annotation>
 </semantics>
</math>

 neighbors not unique, so 

<math display="inline" id="Expander_code:75">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>ε</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>S</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>d</mi>
     <mi>ε</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>S</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo rspace="4.2pt" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>ε</ci>
       </apply>
       <apply>
        <abs></abs>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>ε</ci>
       <apply>
        <abs></abs>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>ε</ci>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(S)\geq d(1-\varepsilon)|S|-d\varepsilon|S|=d(1-2\varepsilon)|S|\,
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="corollary">Corollary</h4>

<p>Every sufficiently small 

<math display="inline" id="Expander_code:76">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

 has a unique neighbor. This follows since 

<math display="inline" id="Expander_code:77">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>ε</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon<\tfrac{1}{2}\,
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="lemma-2">Lemma 2</h4>

<p>Every subset 

<math display="inline" id="Expander_code:78">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>⊂</mo>
   <mpadded width="+1.7pt">
    <mi>L</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>T</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\subset L\,
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Expander_code:79">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>T</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>ε</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>ε</ci>
     </apply>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |T|<2(1-\varepsilon)\gamma n\,
  </annotation>
 </semantics>
</math>

 has a unique neighbor.</p>
<h4 id="proof-2">Proof</h4>

<p>Lemma 1 proves the case 

<math display="inline" id="Expander_code:80">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>T</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |T|\leq\gamma n\,
  </annotation>
 </semantics>
</math>

, so suppose 

<math display="inline" id="Expander_code:81">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>ε</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>γ</mi>
    <mi>n</mi>
   </mrow>
   <mo>></mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>T</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ε</ci>
      </apply>
      <ci>γ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>γ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2(1-\varepsilon)\gamma n>|T|>\gamma n\,
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Expander_code:82">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊂</mo>
   <mpadded width="+1.7pt">
    <mi>T</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subset T\,
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Expander_code:83">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|=\gamma n\,
  </annotation>
 </semantics>
</math>

. By Lemma 1, we know that 

<math display="inline" id="Expander_code:84">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo rspace="4.2pt" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ε</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |U(S)|\geq d(1-2\varepsilon)|S|\,
  </annotation>
 </semantics>
</math>

. Then a vertex 

<math display="inline" id="Expander_code:85">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in U(S)\,
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Expander_code:86">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(T)\,
  </annotation>
 </semantics>
</math>

 iff 

<math display="inline" id="Expander_code:87">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∉</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>∖</mo>
      <mi>S</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>v</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <setdiff></setdiff>
      <ci>T</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\notin N(T\setminus S)\,
  </annotation>
 </semantics>
</math>

, and we know that 

<math display="inline" id="Expander_code:88">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>T</mi>
     <mo>∖</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>ε</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>γ</mi>
     <mi>n</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>γ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <setdiff></setdiff>
       <ci>T</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>ε</ci>
       </apply>
       <ci>γ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>γ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>ε</ci>
       </apply>
      </apply>
      <ci>γ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |T\setminus S|\leq 2(1-\varepsilon)\gamma n-\gamma n=(1-2\varepsilon)\gamma n\,
  </annotation>
 </semantics>
</math>

, so by the first part of Lemma 1, we know 

<math display="inline" id="Expander_code:89">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mo>∖</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <setdiff></setdiff>
       <ci>T</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ε</ci>
      </apply>
     </apply>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |N(T\setminus S)|\leq d(1-2\varepsilon)\gamma n\,
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Expander_code:90">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>ε</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon<\tfrac{1}{2}\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Expander_code:91">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>U</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∖</mo>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>T</mi>
        <mo>∖</mo>
        <mi>S</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>U</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>T</mi>
        <mo>∖</mo>
        <mi>S</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>U</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <setdiff></setdiff>
       <apply>
        <times></times>
        <ci>U</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <times></times>
        <ci>N</ci>
        <apply>
         <setdiff></setdiff>
         <ci>T</ci>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>U</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>N</ci>
        <apply>
         <setdiff></setdiff>
         <ci>T</ci>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |U(T)|\geq|U(S)\setminus N(T\setminus S)|\geq|U(S)|-|N(T\setminus S)|>0\,
  </annotation>
 </semantics>
</math>

, and hence 

<math display="inline" id="Expander_code:92">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(T)\,
  </annotation>
 </semantics>
</math>

 is not empty.</p>
<h4 id="corollary-1">Corollary</h4>

<p>Note that if a 

<math display="inline" id="Expander_code:93">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>⊂</mo>
   <mpadded width="+1.7pt">
    <mi>L</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>T</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\subset L\,
  </annotation>
 </semantics>
</math>

 has at least 1 unique neighbor, i.e. 

<math display="inline" id="Expander_code:94">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>></mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |U(T)|>0\,
  </annotation>
 </semantics>
</math>

, then the corresponding word 

<math display="inline" id="Expander_code:95">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>c</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,
  </annotation>
 </semantics>
</math>

 corresponding to 

<math display="inline" id="Expander_code:96">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>T</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\,
  </annotation>
 </semantics>
</math>

 cannot be a codeword, as it will not multiply to the all zeros vector by the parity check matrix. By the previous argument, 

<math display="inline" id="Expander_code:97">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mi>C</mi>
   <mo>⟹</mo>
   <mrow>
    <mi>w</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>ε</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>c</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>t</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ε</ci>
      </apply>
      <ci>γ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in C\implies wt(c)\geq 2(1-\varepsilon)\gamma n\,
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Expander_code:98">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>C</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\,
  </annotation>
 </semantics>
</math>

 is linear, we conclude that 

<math display="inline" id="Expander_code:99">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>C</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\,
  </annotation>
 </semantics>
</math>

 has distance at least 

<math display="inline" id="Expander_code:100">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>ε</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>γ</mi>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>ε</ci>
    </apply>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2(1-\varepsilon)\gamma n\,
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="encoding">Encoding</h2>

<p>The encoding time for an expander code is upper bounded by that of a general linear code - 

<math display="inline" id="Expander_code:101">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})\,
  </annotation>
 </semantics>
</math>

 by matrix multiplication. A result due to Spielman shows that encoding is possible in 

<math display="inline" id="Expander_code:102">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)\,
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="decoding">Decoding</h2>

<p>Decoding of expander codes is possible in 

<math display="inline" id="Expander_code:103">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)\,
  </annotation>
 </semantics>
</math>

 time when 

<math display="inline" id="Expander_code:104">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mn>1</mn>
     <mn>4</mn>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>ε</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon<\tfrac{1}{4}\,
  </annotation>
 </semantics>
</math>

 using the following algorithm.</p>

<p>Let 

<math display="inline" id="Expander_code:105">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\,
  </annotation>
 </semantics>
</math>

 be the vertex of 

<math display="inline" id="Expander_code:106">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>L</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\,
  </annotation>
 </semantics>
</math>

 that corresponds to the 

<math display="inline" id="Expander_code:107">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>i</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\,
  </annotation>
 </semantics>
</math>

th index in the codewords of 

<math display="inline" id="Expander_code:108">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>C</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\,
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Expander_code:109">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>n</mi>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\{0,1\}^{n}\,
  </annotation>
 </semantics>
</math>

 be a received word, and 

<math display="inline" id="Expander_code:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mrow>
     <mtext>the</mtext>
     <msup>
      <mi>i</mi>
      <mtext>th</mtext>
     </msup>
     <mtext>position of</mtext>
     <mi>y</mi>
     <mtext>is a</mtext>
     <mn>1</mn>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <mtext>the</mtext>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>i</ci>
       <mtext>th</mtext>
      </apply>
      <mtext>position of</mtext>
      <ci>y</ci>
      <mtext>is a</mtext>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(y)=\{v_{i}|\text{ the }i^{\text{th}}\text{ position of }y\text{ is a }1\}\,
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Expander_code:111">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(i)\,
  </annotation>
 </semantics>
</math>

 be 

<math display="inline" id="Expander_code:112">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>v</mi>
    <mo>∈</mo>
    <mi>R</mi>
    <mo stretchy="false">|</mo>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∩</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">v</csymbol>
     <in></in>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">N</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <intersect></intersect>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{v\in R|N(v)\cap V(y)\,
  </annotation>
 </semantics>
</math>

 is even

<math display="inline" id="Expander_code:113">
 <semantics>
  <mrow>
   <mo stretchy="false">}</mo>
   <mo rspace="4.2pt" stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-}</ci>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \}|\,
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Expander_code:114">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(i)\,
  </annotation>
 </semantics>
</math>

 be 

<math display="inline" id="Expander_code:115">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>v</mi>
    <mo>∈</mo>
    <mi>R</mi>
    <mo stretchy="false">|</mo>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∩</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">v</csymbol>
     <in></in>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">N</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <intersect></intersect>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{v\in R|N(v)\cap V(y)\,
  </annotation>
 </semantics>
</math>

 is odd

<math display="inline" id="Expander_code:116">
 <semantics>
  <mrow>
   <mo stretchy="false">}</mo>
   <mo rspace="4.2pt" stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-}</ci>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \}|\,
  </annotation>
 </semantics>
</math>

. Then consider the greedy algorithm:</p>
<hr/>

<p><strong>Input:</strong> received codeword 

<math display="inline" id="Expander_code:117">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\,
  </annotation>
 </semantics>
</math>

. <code>
 initialize y' to y
 while there is a v in R adjacent to an odd number of vertices in V(y')
     if there is an i such that o(i) &gt; e(i)
         flip entry i in y'
     else
         fail</code> <strong>Output:</strong> fail, or modified codeword 

<math display="inline" id="Expander_code:118">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}\,
  </annotation>
 </semantics>
</math>

.</p>
<hr/>
<h3 id="proof-3">Proof</h3>

<p>We show first the correctness of the algorithm, and then examine its running time.</p>
<h4 id="correctness">Correctness</h4>

<p>We must show that the algorithm terminates with the correct codeword when the received codeword is within half the code's distance of the original codeword. Let the set of corrupt variables be 

<math display="inline" id="Expander_code:119">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Expander_code:120">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo rspace="4.2pt" stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=|S|\,
  </annotation>
 </semantics>
</math>

, and the set of unsatisfied (adjacent to an odd number of vertices) vertices in 

<math display="inline" id="Expander_code:121">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 be 

<math display="inline" id="Expander_code:122">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>c</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,
  </annotation>
 </semantics>
</math>

. The following lemma will prove useful.</p>
<h5 id="lemma-3">Lemma 3</h5>

<p>If 

<math display="inline" id="Expander_code:123">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>s</mi>
   <mo><</mo>
   <mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>s</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>γ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<s<\gamma n\,
  </annotation>
 </semantics>
</math>

, then there is a 

<math display="inline" id="Expander_code:124">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\,
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Expander_code:125">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(i)>e(i)\,
  </annotation>
 </semantics>
</math>

.</p>
<h5 id="proof-4">Proof</h5>

<p>By Lemma 1, we know that 

<math display="inline" id="Expander_code:126">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mpadded width="+1.7pt">
     <mi>s</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ε</ci>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(S)\geq d(1-2\varepsilon)s\,
  </annotation>
 </semantics>
</math>

. So an average vertex has at least 

<math display="inline" id="Expander_code:127">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>d</mi>
    <mo>/</mo>
    <mpadded width="+1.7pt">
     <mn>2</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ε</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>d</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(1-2\varepsilon)>d/2\,
  </annotation>
 </semantics>
</math>

 unique neighbors (recall unique neighbors are unsatisfied and hence contribute to 

<math display="inline" id="Expander_code:128">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(i)\,
  </annotation>
 </semantics>
</math>

), since 

<math display="inline" id="Expander_code:129">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mn>1</mn>
     <mn>4</mn>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>ε</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon<\tfrac{1}{4}\,
  </annotation>
 </semantics>
</math>

, and thus there is a vertex 

<math display="inline" id="Expander_code:130">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\,
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Expander_code:131">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(i)>e(i)\,
  </annotation>
 </semantics>
</math>

.</p>

<p>So, if we have not yet reached a codeword, then there will always be some vertex to flip. Next, we show that the number of errors can never increase beyond 

<math display="inline" id="Expander_code:132">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma n\,
  </annotation>
 </semantics>
</math>

.</p>
<h5 id="lemma-4">Lemma 4</h5>

<p>If we start with 

<math display="inline" id="Expander_code:133">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo><</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>γ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ε</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s<\gamma(1-2\varepsilon)n\,
  </annotation>
 </semantics>
</math>

, then we never reach 

<math display="inline" id="Expander_code:134">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\gamma n\,
  </annotation>
 </semantics>
</math>

 at any point in the algorithm.</p>
<h5 id="proof-5">Proof</h5>

<p>When we flip a vertex 

<math display="inline" id="Expander_code:135">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Expander_code:136">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(i)\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Expander_code:137">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(i)\,
  </annotation>
 </semantics>
</math>

 are interchanged, and since we had 

<math display="inline" id="Expander_code:138">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(i)>e(i)\,
  </annotation>
 </semantics>
</math>

, this means the number of unsatisfied vertices on the right decreases by at least one after each flip. Since 

<math display="inline" id="Expander_code:139">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo><</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>γ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ε</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s<\gamma(1-2\varepsilon)n\,
  </annotation>
 </semantics>
</math>

, the initial number of unsatisfied vertices is at most 

<math display="inline" id="Expander_code:140">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>ε</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>γ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>ε</ci>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\gamma(1-2\varepsilon)n\,
  </annotation>
 </semantics>
</math>

, by the graph's 

<math display="inline" id="Expander_code:141">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>d</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\,
  </annotation>
 </semantics>
</math>

-regularity. If we reached a string with 

<math display="inline" id="Expander_code:142">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma n\,
  </annotation>
 </semantics>
</math>

 errors, then by Lemma 1, there would be at least 

<math display="inline" id="Expander_code:143">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>ε</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>γ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>ε</ci>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\gamma(1-2\varepsilon)n\,
  </annotation>
 </semantics>
</math>

 unique neighbors, which means there would be at least 

<math display="inline" id="Expander_code:144">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>ε</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>γ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>ε</ci>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\gamma(1-2\varepsilon)n\,
  </annotation>
 </semantics>
</math>

 unsatisfied vertices, a contradiction.</p>

<p>Lemmas 3 and 4 show us that if we start with 

<math display="inline" id="Expander_code:145">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo><</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ε</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>γ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ε</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s<\gamma(1-2\varepsilon)n\,
  </annotation>
 </semantics>
</math>

 (half the distance of 

<math display="inline" id="Expander_code:146">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>C</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\,
  </annotation>
 </semantics>
</math>

), then we will always find a vertex 

<math display="inline" id="Expander_code:147">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\,
  </annotation>
 </semantics>
</math>

 to flip. Each flip reduces the number of unsatisfied vertices in 

<math display="inline" id="Expander_code:148">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 by at least 1, and hence the algorithm terminates in at most 

<math display="inline" id="Expander_code:149">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>m</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\,
  </annotation>
 </semantics>
</math>

 steps, and it terminates at some codeword, by Lemma 3. (Were it not at a codeword, there would be some vertex to flip). Lemma 4 shows us that we can never be farther than 

<math display="inline" id="Expander_code:150">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma n\,
  </annotation>
 </semantics>
</math>

 away from the correct codeword. Since the code has distance 

<math display="inline" id="Expander_code:151">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>ε</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>γ</mi>
    <mi>n</mi>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>γ</mi>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>ε</ci>
     </apply>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2(1-\varepsilon)\gamma n>\gamma n\,
  </annotation>
 </semantics>
</math>

 (since 

<math display="inline" id="Expander_code:152">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>ε</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon<\tfrac{1}{2}\,
  </annotation>
 </semantics>
</math>

), the codeword it terminates on must be the correct codeword, since the number of bit flips is less than half the distance (so we couldn't have traveled far enough to reach any other codeword).</p>
<h4 id="complexity">Complexity</h4>

<p>We now show that the algorithm can achieve linear time decoding. Let 

<math display="inline" id="Expander_code:153">
 <semantics>
  <mpadded width="+1.7pt">
   <mfrac>
    <mi>n</mi>
    <mi>m</mi>
   </mfrac>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{n}{m}\,
  </annotation>
 </semantics>
</math>

 be constant, and 

<math display="inline" id="Expander_code:154">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>r</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\,
  </annotation>
 </semantics>
</math>

 be the maximum degree of any vertex in 

<math display="inline" id="Expander_code:155">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="Expander_code:156">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>r</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\,
  </annotation>
 </semantics>
</math>

 is also constant for known constructions.</p>
<ol>
<li>Pre-processing: It takes 

<math display="inline" id="Expander_code:157">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mi>r</mi>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(mr)\,
  </annotation>
 </semantics>
</math>

 time to compute whether each vertex in 

<math display="inline" id="Expander_code:158">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 has an odd or even number of neighbors.</li>
<li>Pre-processing 2: We take 

<math display="inline" id="Expander_code:159">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>m</mi>
      <mi>r</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>m</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(dn)=O(dmr)\,
  </annotation>
 </semantics>
</math>

 time to compute a list of vertices 

<math display="inline" id="Expander_code:160">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\,
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Expander_code:161">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>L</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\,
  </annotation>
 </semantics>
</math>

 which have 

<math display="inline" id="Expander_code:162">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(i)>e(i)\,
  </annotation>
 </semantics>
</math>

.</li>
<li>Each Iteration: We simply remove the first list element. To update the list of odd / even vertices in 

<math display="inline" id="Expander_code:163">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

, we need only update 

<math display="inline" id="Expander_code:164">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(d)\,
  </annotation>
 </semantics>
</math>

 entries, inserting / removing as necessary. We then update 

<math display="inline" id="Expander_code:165">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mi>r</mi>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(dr)\,
  </annotation>
 </semantics>
</math>

 entries in the list of vertices in 

<math display="inline" id="Expander_code:166">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>L</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\,
  </annotation>
 </semantics>
</math>

 with more odd than even neighbors, inserting / removing as necessary. Thus each iteration takes 

<math display="inline" id="Expander_code:167">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mi>r</mi>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(dr)\,
  </annotation>
 </semantics>
</math>

 time.</li>
<li>As argued above, the total number of iterations is at most 

<math display="inline" id="Expander_code:168">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>m</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\,
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>This gives a total runtime of 

<math display="inline" id="Expander_code:169">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mi>d</mi>
      <mi>r</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>d</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(mdr)=O(n)\,
  </annotation>
 </semantics>
</math>

 time, where 

<math display="inline" id="Expander_code:170">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>d</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Expander_code:171">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>r</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\,
  </annotation>
 </semantics>
</math>

 are constants.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Expander_graph" title="wikilink">Expander graph</a></li>
<li><a href="Low-density_parity-check_code" title="wikilink">Low-density parity-check code</a></li>
<li>Linear time encoding and decoding of error-correcting codes</li>
<li>ABNNR and AEL codes</li>
</ul>
<h2 id="notes">Notes</h2>

<p>This article is based on Dr. Venkatesan Guruswami's course notes.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Capacity-approaching_codes" title="wikilink">Category:Capacity-approaching codes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><br/>
<br/>
<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
