   Rabin cryptosystem      Rabin cryptosystem   The Rabin cryptosystem is an asymmetric cryptographic technique, whose security, like that of RSA , is related to the difficulty of factorization . However the Rabin cryptosystem has the advantage that the problem on which it relies has been proved to be as hard as integer factorization , which is not currently known to be true of the RSA problem . It has the disadvantage that each output of the Rabin function can be generated by any of four possible inputs; if each output is a ciphertext, extra complexity is required on decryption to identify which of the four possible inputs was the true plaintext.  History  The process was published in January 1979 by Michael O. Rabin . The Rabin cryptosystem was the first asymmetric cryptosystem where recovering the entire plaintext from the ciphertext could be proven to be as hard as factoring.  Key generation  As with all asymmetric cryptosystems, the Rabin system uses both a public and a private key . The public key is necessary for later encryption and can be published, while the private key must be possessed only by the recipient of the message.  The precise key-generation process follows:   Choose two large distinct primes p and q . One may choose    p  ‚â°  q  ‚â°   3     (   mod  4   )          p  q        annotated  3   pmod  4       p\equiv q\equiv 3\;\;(\mathop{{\rm mod}}4)   to simplify the computation of square roots modulo p and q (see below). But the scheme works with any primes.  Let    n  =   p  ‚ãÖ  q       n   normal-‚ãÖ  p  q     n=p\cdot q   . Then n is the public key. The primes p and q are the private key.   To encrypt a message only the public key n is needed. To decrypt a ciphertext the factors p and q of n are necessary.  As a (non-real-world) example, if    p  =  7      p  7    p=7   and    q  =  11      q  11    q=11   , then    n  =  77      n  77    n=77   . The public key, 77, would be released, and the message encoded using this key. And, in order to decode the message, the private keys, 7 and 11, would have to be known (of course, this would be a poor choice of keys, as the factorization of 77 is trivial; in reality much larger numbers would be used).  Encryption  For the encryption, only the public key n is used, thus producing a ciphertext out of the plaintext. The process follows:  Let    P  =   {  0  ,  ‚Ä¶  ,   n  -  1   }       P   0  normal-‚Ä¶    n  1      P=\{0,\dots,n-1\}   be the plaintext space (consisting of numbers) and    m  ‚àà  P      m  P    m\in P   be the plaintext . Now the ciphertext    c   c   c   is determined by      c  =     m  2    mod  n       c   modulo   superscript  m  2   n     c=m^{2}\,\bmod\,n   .  That is, c is the quadratic remainder of the square of the plaintext, modulo the key-number n .  In our simple example,    P  =   {  0  ,  ‚Ä¶  ,  76  }       P   0  normal-‚Ä¶  76     P=\{0,\dots,76\}   is our plaintext space. We will take    m  =  20      m  20    m=20   as our plaintext. The ciphertext is thus    c  =     m  2    mod  n   =    400   mod  77   =  15        c   modulo   superscript  m  2   n         modulo  400  77        15     c=m^{2}\,\bmod\,n=400\,\bmod\,77=15   .  For exactly four different values of m , the ciphertext 15 is produced, i.e. for    m  ‚àà   {  13  ,  20  ,  57  ,  64  }       m   13  20  57  64     m\in\{13,20,57,64\}   . This is true for most ciphertexts produced by the Rabin algorithm, i.e. it is a four-to-one function.  Decryption  To decode the ciphertext, the private keys are necessary. The process follows:  If c and n are known, the plaintext is then    m  ‚àà   {  0  ,  ‚Ä¶  ,   n  -  1   }       m   0  normal-‚Ä¶    n  1      m\in\{0,\dots,n-1\}   with     m  2   ‚â°   c     (   mod  n   )         superscript  m  2    annotated  c   pmod  n      m^{2}\equiv c\;\;(\mathop{{\rm mod}}n)   . For a composite  n (that is, like the Rabin algorithm's    n  =   p  ‚ãÖ  q       n   normal-‚ãÖ  p  q     n=p\cdot q   ) there is no efficient method known for the finding of m . If, however   n   n   n   is prime (as are p and q in the Rabin algorithm), the Chinese remainder theorem can be applied to solve for m .  Thus the square roots       m  p   =     c    mod  p        subscript  m  p    modulo    c   p     m_{p}=\sqrt{c}\,\bmod\,p     and       m  q   =     c    mod  q        subscript  m  q    modulo    c   q     m_{q}=\sqrt{c}\,\bmod\,q     must be calculated (see section below).  In our example we get     m  p   =  1       subscript  m  p   1    m_{p}=1   and     m  q   =  9       subscript  m  q   9    m_{q}=9   .  By applying the extended Euclidean algorithm , we wish to find    y  p     subscript  y  p    y_{p}   and    y  q     subscript  y  q    y_{q}   such that       y  p   ‚ãÖ  p   +    y  q   ‚ãÖ  q    =  1         normal-‚ãÖ   subscript  y  p   p    normal-‚ãÖ   subscript  y  q   q    1    y_{p}\cdot p+y_{q}\cdot q=1   . In our example, we have     y  p   =   -  3        subscript  y  p     3     y_{p}=-3   and     y  q   =  2       subscript  y  q   2    y_{q}=2   .  Now, by invocation of the Chinese remainder theorem, the four square roots    +  r      r    +r   ,    -  r      r    -r   ,    +  s      s    +s   and    -  s      s    -s   of     c  +   n  ‚Ñ§    ‚àà    ‚Ñ§  /  n   ‚Ñ§         c    n  ‚Ñ§        ‚Ñ§  n   ‚Ñ§     c+n\mathbb{Z}\in\mathbb{Z}/n\mathbb{Z}   are calculated (     ‚Ñ§  /  n   ‚Ñ§        ‚Ñ§  n   ‚Ñ§    \mathbb{Z}/n\mathbb{Z}   here stands for the ring of congruence classes modulo n ). The four square roots are in the set    {  0  ,  ‚Ä¶  ,   n  -  1   }     0  normal-‚Ä¶    n  1     \{0,\dots,n-1\}   :        r    =      (     y  p   ‚ãÖ  p  ‚ãÖ   m  q    +    y  q   ‚ãÖ  q  ‚ãÖ   m  p     )   mod  n        -  r     =     n  -  r       s    =      (     y  p   ‚ãÖ  p  ‚ãÖ   m  q    -    y  q   ‚ãÖ  q  ‚ãÖ   m  p     )   mod  n        -  s     =     n  -  s         r    modulo     normal-‚ãÖ   subscript  y  p   p   subscript  m  q     normal-‚ãÖ   subscript  y  q   q   subscript  m  p     n       r      n  r     s    modulo     normal-‚ãÖ   subscript  y  p   p   subscript  m  q     normal-‚ãÖ   subscript  y  q   q   subscript  m  p     n       s      n  s      \begin{matrix}r&=&(y_{p}\cdot p\cdot m_{q}+y_{q}\cdot q\cdot m_{p})\,\bmod\,n%
 \\
 -r&=&n-r\\
 s&=&(y_{p}\cdot p\cdot m_{q}-y_{q}\cdot q\cdot m_{p})\,\bmod\,n\\
 -s&=&n-s\end{matrix}     One of these square roots     mod  n     modulo  absent  n    \mod\,n   is the original plaintext m . In our example,    m  ‚àà   {  64  ,  ùüêùüé  ,  13  ,  57  }       m   64  20  13  57     m\in\{64,\mathbf{20},13,57\}   .  Rabin pointed out in his paper, that if someone is able to compute both ,   r   r   r   and   s   s   s   , then he is also able to find the factorization of   n   n   n   because:   either     gcd   (   |   r  -  s   |   ,  n  )    =  p            r  s    n   p    \gcd(|r-s|,n)=p   or     gcd   (   |   r  -  s   |   ,  n  )    =  q            r  s    n   q    \gcd(|r-s|,n)=q   , where   gcd     \gcd   means Greatest common divisor .   Since the Greatest common divisor can be calculated efficiently you are able to find the factorization of   n   n   n   efficiently if you know   r   r   r   and   s   s   s   . In our example (picking   57   57   57   and   13   13   13   as   r   r   r   and   s   s   s   ):       gcd   (   57  -  13   ,  77  )    =   gcd   (  44  ,  77  )    =  11  =  q            57  13   77     44  77        11       q     \gcd(57-13,77)=\gcd(44,77)=11=q     Computing square roots  The decryption requires to compute square roots of the ciphertext c modulo the primes p and q . Choosing    p  ‚â°  q  ‚â°   3     (   mod  4   )          p  q        annotated  3   pmod  4       p\equiv q\equiv 3\;\;(\mathop{{\rm mod}}4)   allows to compute square roots more easily by       m  p   =     c    1  4    (   p  +  1   )      mod  p        subscript  m  p    modulo   superscript  c      1  4     p  1     p     m_{p}=c^{\frac{1}{4}(p+1)}\,\bmod\,p     and       m  q   =     c    1  4    (   q  +  1   )      mod  q        subscript  m  q    modulo   superscript  c      1  4     q  1     q     m_{q}=c^{\frac{1}{4}(q+1)}\,\bmod\,q   .  We can show that this method works for p as follows. First    p  ‚â°    3      (   mod  4   )        p   annotated  3   pmod  4      p\equiv 3\!\!\!\;\;(\mathop{{\rm mod}}4)   implies that ( p +1)/4 is an integer. The assumption is trivial for c ‚â°0 (mod p ). Thus we may assume that p does not divide c . Then        m  p  2   ‚â°   c    1  2    (   p  +  1   )     ‚â°   c  ‚ãÖ   c    1  2    (   p  -  1   )      ‚â°    c  ‚ãÖ   (   c  p   )       (   mod  p   )     ,         superscript   subscript  m  p   2    superscript  c      1  2     p  1           normal-‚ãÖ  c   superscript  c      1  2     p  1            annotated   normal-‚ãÖ  c    c  p     pmod  p       m_{p}^{2}\equiv c^{\frac{1}{2}(p+1)}\equiv c\cdot c^{\frac{1}{2}(p-1)}\equiv c%
 \cdot\left({c\over p}\right)\;\;(\mathop{{\rm mod}}p),     where    (   c  p   )      c  p    \left({c\over p}\right)   is a Legendre symbol .  From    c  ‚â°    m  2      (   mod   p  q    )        c   annotated   superscript  m  2    pmod    p  q       c\equiv m^{2}\;\;(\mathop{{\rm mod}}pq)   follows that    c  ‚â°    m  2      (   mod  p   )        c   annotated   superscript  m  2    pmod  p      c\equiv m^{2}\;\;(\mathop{{\rm mod}}p)   . Thus c is a quadratic residue modulo p . Hence     (   c  p   )   =  1        c  p   1    \left({c\over p}\right)=1   and therefore        m  p  2   ‚â°   c     (   mod  p   )     .       superscript   subscript  m  p   2    annotated  c   pmod  p      m_{p}^{2}\equiv c\;\;(\mathop{{\rm mod}}p).     The relation    p  ‚â°   3     (   mod  4   )        p   annotated  3   pmod  4      p\equiv 3\;\;(\mathop{{\rm mod}}4)   is not a requirement because square roots modulo other primes can be computed too. E.g., Rabin proposes to find the square roots modulo primes by using a special case of Berlekamp's algorithm .  Evaluation of the algorithm  Effectiveness  Decoding produces three false results in addition to the correct one, so that the correct result must be guessed. This is the major disadvantage of the Rabin cryptosystem and one of the factors which have prevented it from finding widespread practical use.  If the plaintext is intended to represent a text message, guessing is not difficult; however, if the plaintext is intended to represent a numerical value, this issue becomes a problem that must be resolved by some kind of disambiguation scheme. It is possible to choose plaintexts with special structures, or to add padding , to eliminate this problem. A way of removing the ambiguity of inversion was suggested by Blum and Williams: the two primes used are restricted to primes congruent to 3 modulo 4 and the domain of the squaring is restricted to the set of quadratic residues. These restrictions make the squaring function into a trapdoor  permutation , eliminating the ambiguity. 1  Efficiency  For encryption, a square modulo n must be calculated. This is more efficient than RSA , which requires the calculation of at least a cube. (Unless the convention of setting e=3 in the public key is used)  For decryption, the Chinese remainder theorem is applied, along with two modular exponentiations . Here the efficiency is comparable to RSA.  Disambiguation introduces additional computational costs, and is what has prevented the Rabin cryptosystem from finding widespread practical use.  Security  The great advantage of the Rabin cryptosystem is that a random plaintext can be recovered entirely from the ciphertext only if the codebreaker is capable of efficiently factoring the public key n . Note that this is a very weak level of security. Extensions of the Rabin cryptosystem achieve stronger notions of security.  It has been proven that decoding the Rabin cryptosystem is equivalent to the integer factorization problem, something that has not been proven for RSA. Thus the Rabin system is 'more secure' in this sense than is RSA, and will remain so until a general solution for the factorization problem is discovered, or until the RSA problem is discovered to be equivalent to factorization. (This assumes that the plaintext was not created with a specific structure to ease decoding.)  Since the solution to the factorization problem is being sought on many different fronts, any solution (outside classified research organizations such as NSA ) would rapidly become available to the whole scientific community. However, a solution has been long in coming, and the factorization problem has been, thus, practically insoluble. Without such an advance, an attacker would have no chance today of breaking the code. This cryptosystem is provably secure (in a strong sense) against chosen plaintext attacks.  However, it has been proven an active attacker can break the system using a chosen ciphertext attack . By adding redundancies, for example, the repetition of the last 64 bits, the system can be made to produce a single root. This thwarts the chosen-ciphertext attack, since the decoding algorithm then only produces the root that the attacker already knows. If this technique is applied, the proof of the equivalence with the factorization problem fails, so it is uncertain as of 2004 if this variant is secure. The Handbook of Applied Cryptography by Menezes, Oorschot and Vanstone considers this equivalence probable, however, as long as the finding of the roots remains a two-part process (1. roots     mod  p     modulo  absent  p    \mod p   and     mod  q     modulo  absent  q    \mod q   and 2. application of the Chinese remainder theorem).  Since in the encoding process, only the modulo remainders of perfect squares are used (in our example with    n  =  77      n  77    n=77   , this is only 23 of the 76 possible values), other attacks on the process are possible.  See also   Topics in cryptography  Blum Blum Shub  Shanks‚ÄìTonelli algorithm  Schmidt‚ÄìSamoa cryptosystem   Notes  References   Buchmann, Johannes. Einf√ºhrung in die Kryptographie . Second Edition. Berlin: Springer, 2001. ISBN 3-540-41283-2  Menezes, Alfred; van Oorschot, Paul C.; and Vanstone, Scott A. Handbook of Applied Cryptography . CRC Press, October 1996. ISBN 0-8493-8523-7  Rabin, Michael. Digitalized Signatures and Public-Key Functions as Intractable as Factorization (in PDF). MIT Laboratory for Computer Science, January 1979.  Scott Lindhurst, An analysis of Shank's algorithm for computing square roots in finite fields. in R Gupta and K S Williams, Proc 5th Conf Can Nr Theo Assoc, 1999, vol 19 CRM Proc & Lec Notes, AMS, Aug 1999.  R Kumanduri and C Romero, Number Theory w/ Computer Applications, Alg 9.2.9, Prentice Hall, 1997. A probabilistic for square root of a quadratic residue modulo a prime.   External links   Menezes, Oorschot, Vanstone, Scott: Handbook of Applied Cryptography (free PDF downloads), see Chapter 8   "  Category:Public-key encryption schemes     Shafi Goldwasser and Mihir Bellare  "Lecture Notes on Cryptography" . Summer course on cryptography, MIT, 1996-2001 ‚Ü©     