<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1009">Betweenness centrality</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Betweenness centrality</h1>
<hr>'''Betweenness centrality''' is an indicator of a node's [[centrality]] in a [[Graph (mathematics)|network]]. It is equal to the number of shortest paths from all vertices to all others that pass through that node. A node with high betweenness centrality has a large influence on the transfer of items through the network, under the assumption that item transfer follows the shortest paths. The concept finds wide application, including computer and social networks,<ref name="brandes2008">{{cite journal |last1 = Brandes|first1 = Ulrik | year=2008| ti
<p>tle = On variants of shortest-path betweenness centrality and their generic computation | journal = Social Networks| volume=30| pages=136–145 | doi=10.1016/j.socnet.2007.11.001}}<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> biology,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> transport <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and scientific cooperation.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Development of <em>betweenness centrality</em> is generally attributed to <a class="uri" href="sociologist" title="wikilink">sociologist</a> Linton Freeman.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The idea was earlier proposed by mathematician J. Anthonisse, but his work was never published.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="definition">Definition</h2>

<p>The betweenness centrality of a node 

<math display="inline" id="Betweenness_centrality:0">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is given by the expression:</p>

<p>

<math display="block" id="Betweenness_centrality:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>s</mi>
      <mo>≠</mo>
      <mi>v</mi>
      <mo>≠</mo>
      <mi>t</mi>
     </mrow>
    </munder>
    <mfrac>
     <mrow>
      <msub>
       <mi>σ</mi>
       <mrow>
        <mi>s</mi>
        <mi>t</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msub>
      <mi>σ</mi>
      <mrow>
       <mi>s</mi>
       <mi>t</mi>
      </mrow>
     </msub>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <and></and>
       <apply>
        <neq></neq>
        <ci>s</ci>
        <ci>v</ci>
       </apply>
       <apply>
        <neq></neq>
        <share href="#.cmml">
        </share>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <apply>
         <times></times>
         <ci>s</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>v</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(v)=\sum_{s\neq v\neq t}\frac{\sigma_{st}(v)}{\sigma_{st}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Betweenness_centrality:2">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mrow>
    <mi>s</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{st}
  </annotation>
 </semantics>
</math>

 is the total number of shortest paths from node 

<math display="inline" id="Betweenness_centrality:3">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to node 

<math display="inline" id="Betweenness_centrality:4">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Betweenness_centrality:5">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mrow>
     <mi>s</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{st}(v)
  </annotation>
 </semantics>
</math>

 is the number of those paths that pass through 

<math display="inline" id="Betweenness_centrality:6">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that the betweenness centrality of a node scales with the number of pairs of nodes as implied by the summation indices. Therefore the calculation may be rescaled by dividing through by the number of pairs of nodes not including 

<math display="inline" id="Betweenness_centrality:7">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, so that 

<math display="inline" id="Betweenness_centrality:8">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in[0,1]
  </annotation>
 </semantics>
</math>

. The division is done by 

<math display="inline" id="Betweenness_centrality:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N-1)(N-2)
  </annotation>
 </semantics>
</math>

 for directed graphs and 

<math display="inline" id="Betweenness_centrality:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N-1)(N-2)/2
  </annotation>
 </semantics>
</math>

 for undirected graphs, where 

<math display="inline" id="Betweenness_centrality:11">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is the number of nodes in the giant component. Note that this scales for the highest possible value, where one node is crossed by every single shortest path. This is often not the case, and a normalization can be performed without a loss of precision</p>

<p>

<math display="block" id="Betweenness_centrality:12">
 <semantics>
  <mrow>
   <mrow>
    <mtext>normal</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>min</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>g</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>max</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>g</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>min</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>g</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>normal</mtext>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <min></min>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <max></max>
       <ci>g</ci>
      </apply>
      <apply>
       <min></min>
       <ci>g</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{normal}(g(v))=\frac{g(v)-\min(g)}{\max(g)-\min(g)}
  </annotation>
 </semantics>
</math>

 which results in:</p>

<p>

<math display="block" id="Betweenness_centrality:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi>o</mi>
      <mi>r</mi>
      <mi>m</mi>
      <mi>a</mi>
      <mi>l</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <max></max>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>o</ci>
      <ci>r</ci>
      <ci>m</ci>
      <ci>a</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(normal)=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Betweenness_centrality:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi>o</mi>
      <mi>r</mi>
      <mi>m</mi>
      <mi>a</mi>
      <mi>l</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>o</ci>
      <ci>r</ci>
      <ci>m</ci>
      <ci>a</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(normal)=0
  </annotation>
 </semantics>
</math>

 Note that this will always be a scaling from a smaller range into a larger range, so no precision is lost.</p>
<h2 id="the-load-distribution-in-real-and-model-networks">The load distribution in real and model networks</h2>
<h3 id="model-networks">Model networks</h3>

<p>It has been shown that the load distribution of a <a href="scale-free_network" title="wikilink">scale-free network</a> follows a <a href="power_law" title="wikilink">power law</a> given by a load exponent 

<math display="inline" id="Betweenness_centrality:15">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>

<math display="block" id="Betweenness_centrality:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <mo>-</mo>
     <mi>δ</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <ci>δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(g)\approx g^{-\delta}
  </annotation>
 </semantics>
</math>

 (1) this implies the scaling relation to the degree of the node,</p>

<p>

<math display="block" id="Betweenness_centrality:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <msup>
    <mi>k</mi>
    <mi>η</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <ci>η</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(k)\approx k^{\eta}
  </annotation>
 </semantics>
</math>

. Where 

<math display="inline" id="Betweenness_centrality:18">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(k)
  </annotation>
 </semantics>
</math>

 is the average load of vertices with degree 

<math display="inline" id="Betweenness_centrality:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. The exponents 

<math display="inline" id="Betweenness_centrality:20">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Betweenness_centrality:21">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

 are not independent since equation (1) implies <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>

<math display="block" id="Betweenness_centrality:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>d</mi>
     <mi>k</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <mo>-</mo>
       <msup>
        <mi>k</mi>
        <mi>η</mi>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>k</ci>
      <ci>P</ci>
      <ci>k</ci>
      <ci>δ</ci>
      <apply>
       <minus></minus>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <ci>η</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(g)=\int dkP(k)\delta(g-k^{\eta})
  </annotation>
 </semantics>
</math>

 For large g, and therefore large k, the expression becomes</p>

<p>

<math display="block" id="Betweenness_centrality:23">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>≫</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo largeop="true" symmetric="true">∫</mo>
   <mi>d</mi>
   <mi>k</mi>
   <msup>
    <mi>k</mi>
    <mrow>
     <mo>-</mo>
     <mi>γ</mi>
    </mrow>
   </msup>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>-</mo>
    <msup>
     <mi>k</mi>
     <mi>η</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="latexml">much-greater-than</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <int></int>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">k</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <minus></minus>
      <ci>γ</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">δ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">g</csymbol>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <ci>η</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(g\gg 1)=\int dkk^{-\gamma}\delta(g-k^{\eta})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Betweenness_centrality:24">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>∼</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>γ</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mi>η</mi>
     </mfrac>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>γ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>η</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim g^{-1-\frac{\gamma-1}{\eta}}
  </annotation>
 </semantics>
</math>

 which proves the following equality:</p>

<p>

<math display="block" id="Betweenness_centrality:25">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>γ</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>δ</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>η</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>γ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>δ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta=\frac{\gamma-1}{\delta-1}
  </annotation>
 </semantics>
</math>

</p>

<p>The important exponent appears to be 

<math display="inline" id="Betweenness_centrality:26">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

 which describes how the betweenness centrality depends on the connectivity. The situation which maximizes the betweenness centrality for a vertex is when all shortest paths are going through it, which corresponds to a tree structure (a network with no clustering). In the case of a tree network the maximum value of 

<math display="inline" id="Betweenness_centrality:27">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>η</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta=2
  </annotation>
 </semantics>
</math>

 is reached.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>

<math display="block" id="Betweenness_centrality:28">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>=</mo>
   <mn>2</mn>
   <mo>→</mo>
   <mi>δ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>γ</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>η</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>δ</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>γ</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta=2\rightarrow\delta=\frac{\gamma+1}{2}
  </annotation>
 </semantics>
</math>

 This maximal value of 

<math display="inline" id="Betweenness_centrality:29">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

 (and hence minimum of 

<math display="inline" id="Betweenness_centrality:30">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

) puts bounds on the load exponents for networks with non-vanishing clustering.</p>

<p>

<math display="block" id="Betweenness_centrality:31">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>≤</mo>
   <mn>2</mn>
   <mo>→</mo>
   <mi>δ</mi>
   <mo>≥</mo>
   <mfrac>
    <mrow>
     <mi>γ</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <ci>η</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>δ</ci>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>γ</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\leq 2\rightarrow\delta\geq\frac{\gamma+1}{2}
  </annotation>
 </semantics>
</math>

 In this case, the exponents 

<math display="inline" id="Betweenness_centrality:32">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>,</mo>
   <mi>η</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>δ</ci>
    <ci>η</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta,\eta
  </annotation>
 </semantics>
</math>

 are not universal and depend on the different details (average connectivity, correlations, etc.)</p>
<h3 id="real-networks">Real networks</h3>

<p>Real world scale free networks, such as the internet, also follow a power law load distribution.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> This is an intuitive result. Scale free networks arrange themselves to create short path lengths across the network by creating a few hub nodes with much higher connectivity than the majority of the network. These hubs will naturally experience much higher loads because of this added connectivity.</p>
<h2 id="weighted-networks">Weighted networks</h2>

<p>In a weighted network the links connecting the nodes are no longer treated as binary interactions, but are weighted in proportion to their capacity, influence, frequency, etc., which adds another dimension of heterogeneity within the network beyond the topological effects. A node's strength in a weighted network is given by the sum of the weights of its adjacent edges.</p>

<p>

<math display="block" id="Betweenness_centrality:33">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}=\sum_{j=1}^{N}a_{ij}w_{ij}
  </annotation>
 </semantics>
</math>

</p>

<p>With 

<math display="inline" id="Betweenness_centrality:34">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{ij}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Betweenness_centrality:35">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

 being adjacency and weight matrices between nodes 

<math display="inline" id="Betweenness_centrality:36">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Betweenness_centrality:37">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

, respectively. Analogous to the power law distribution of degree found in scale free networks, the strength of a given node follows a power law distribution as well.</p>

<p>

<math display="block" id="Betweenness_centrality:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mi>k</mi>
     <mi>β</mi>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(k)\approx k^{\beta}\,
  </annotation>
 </semantics>
</math>

</p>

<p>A study of the average value 

<math display="inline" id="Betweenness_centrality:39">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(b)
  </annotation>
 </semantics>
</math>

 of the strength for vertices with betweenness 

<math display="inline" id="Betweenness_centrality:40">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 shows that the functional behavior can be approximated by a scaling form <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>

<math display="block" id="Betweenness_centrality:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <msup>
    <mi>b</mi>
    <mi>α</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(b)\approx b^{\alpha}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="algorithms">Algorithms</h2>

<p>Calculating the betweenness and closeness centralities of all the <a href="Vertex_(graph_theory)" title="wikilink">vertices</a> in a graph involves calculating the shortest paths between all pairs of vertices on a graph, which takes <a href="big_theta" title="wikilink">

<math display="inline" id="Betweenness_centrality:42">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>V</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(|V|^{3})
  </annotation>
 </semantics>
</math>

</a> time with the <a href="Floyd–Warshall_algorithm" title="wikilink">Floyd–Warshall algorithm</a>, modified to not only find one but count all shortest paths between two nodes. On a sparse graph, <a href="Johnson's_algorithm" title="wikilink">Johnson's algorithm</a> may be more efficient, taking <a href="Big_O_notation" title="wikilink">

<math display="inline" id="Betweenness_centrality:43">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>V</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>V</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>V</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>E</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <ci>V</ci>
      </apply>
      <apply>
       <abs></abs>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|V|^{2}\log|V|+|V||E|)
  </annotation>
 </semantics>
</math>

</a> time. On unweighted graphs, calculating betweenness centrality takes <a href="Big_O_notation" title="wikilink">

<math display="inline" id="Betweenness_centrality:44">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>V</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>E</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|V||E|)
  </annotation>
 </semantics>
</math>

</a> time using Brandes' algorithm.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>In calculating betweenness and closeness centralities of all vertices in a graph, it is assumed that graphs are undirected and connected with the allowance of loops and multiple edges. When specifically dealing with network graphs, often graphs are without loops or multiple edges to maintain simple relationships (where edges represent connections between two people or vertices). In this case, using Brandes' algorithm will divide final centrality scores by 2 to account for each shortest path being counted twice.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>Another algorithm generalizes the Freeman's betweenness computed on geodesics and Newman's betweenness computed on all paths, by introducing a hyper-parameter controlling the trade-off between exploration and exploitation. The time complexity is the number of edges times the number of nodes in the graph.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The concept of centrality was extended to a group level as well.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Group betweenness centrality shows the proportion of geodesics connecting pairs of non-group members that pass through a group of nodes. Brandes' algorithm for computing the betweenness centrality of all vertices was modified to compute the group betweenness centrality of one group of nodes with the same asymptotic running time.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="related-concepts">Related concepts</h2>

<p><em>Betweenness centrality</em> is related to a network's <a href="Connectivity_(graph_theory)" title="wikilink">connectivity</a>, though in what way it is not fully understood<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Centrality" title="wikilink">Centrality</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a> <a href="Category:Network_theory" title="wikilink">Category:Network theory</a> <a href="Category:Graph_theory" title="wikilink">Category:Graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">M. Barthélemy Eur. Phys. J. B 38, 163–168 (2004)<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12">Kwang-Il Goh, Eulsik Oh, Hawoong Jeong, Byungnam Kahng, and Doochul Kim. PNAS (2002) vol. 99 no. 2<a href="#fnref12">↩</a></li>
<li id="fn13">A. Barrat, M. Barthelemy, R. Pastor-Satorras, and A. Vespignani. PNAS (2004) vol. 101 no. 11<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">Puzis, R., Yagil, D., Elovici, Y., Braha, D. (2009)<a href="http://necsi.edu/affiliates/braha/Internet_Research_Anonimity.pdf">Collaborative attack on Internet users’ anonymity</a>, <em>Internet Research</em> <strong>19</strong>(1)<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
</ol>
</section>
</ref></hr></body>
</html>
