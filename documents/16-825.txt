   Zemor's decoding algorithm      Zemor's decoding algorithm   In coding theory , Zemor's algorithm , designed and developed by Gilles Zemor, 1 is a recursive low-complexity approach to code construction. It is an improvement over the algorithm of Sipser and Spielman .  Zemor considered a typical class of Sipser‚ÄìSpielman construction of expander codes , where the underlying graph is bipartite graph . Sipser and Spielman introduced a constructive family of asymptotically good linear-error codes together with a simple parallel algorithm that will always remove a constant fraction of errors. The article is based on Dr. Venkatesan Guruswami's course notes 2  Code construction  Zemor's algorithm is based on a type of expander graphs called Tanner graph . The construction of code was first proposed by Tanner. 3 The codes are based on double cover    d   d   d   , regular expander   G   G   G   , which is a bipartite graph.   G   G   G   =    (  V  ,  E  )     V  E    \left(V,E\right)   , where   V   V   V   is the set of vertices and   E   E   E   is the set of edges and   V   V   V   =   A   A   A      ‚à™     \cup      B   B   B   and   A   A   A      ‚à©     \cap      B   B   B   =   ‚àÖ     \emptyset   , where   A   A   A   and   B   B   B   denotes the set of 2 vertices. Let   n   n   n   be the number of vertices in each group, i.e ,     |  A  |   =   |  B  |   =  n          A     B        n     |A|=|B|=n   . The edge set   E   E   E   be of size   N   N   N   =    n  d      n  d    nd   and every edge in   E   E   E   has one endpoint in both   A   A   A   and   B   B   B   .    E   (  v  )       E  v    E(v)   denotes the set of edges containing   v   v   v   .  Assume an ordering on   V   V   V   , therefore ordering will be done on every edges of    E   (  v  )       E  v    E(v)   for every    v  ‚àà  V      v  V    v\in V   . Let finite field     ùîΩ  =   G  F   (  2  )        ùîΩ    G  F  2     \mathbb{F}=GF(2)   , and for a word     x  =   (   x  e   )    ,   e  ‚àà  E      formulae-sequence    x   subscript  x  e      e  E     x=(x_{e}),e\in E   in    ùîΩ  N     superscript  ùîΩ  N    \mathbb{F}^{N}   , let the subword of the word will be indexed by    E   (  v  )       E  v    E(v)   . Let that word be denoted by     (  x  )   v     subscript  x  v    (x)_{v}   . The subset of vertices   A   A   A   and   B   B   B   induces every word    x  ‚àà   ùîΩ  N       x   superscript  ùîΩ  N     x\in\mathbb{F}^{N}   a partition into   n   n   n   non-overlapping sub-words      (  x  )   v   ‚àà   ùîΩ  d        subscript  x  v    superscript  ùîΩ  d     \left(x\right)_{v}\in\mathbb{F}^{d}   , where   v   v   v   ranges over the elements of   A   A   A   . For constructing a code   C   C   C   , consider a linear subcode    C  o     subscript  C  o    C_{o}   , which is a    [  d  ,    r  o   d   ,  Œ¥  ]     d     subscript  r  o   d   Œ¥    [d,r_{o}d,\delta]   code, where   q   q   q   , the size of the alphabet is   2   2   2   . For any vertex    v  ‚àà  V      v  V    v\in V   , let     v   (  1  )    ,   v   (  2  )    ,  ‚Ä¶  ,   v   (  d  )         v  1     v  2   normal-‚Ä¶    v  d     v(1),v(2),\ldots,v(d)   be some ordering of the   d   d   d   vertices of   E   E   E   adjacent to   v   v   v   . In this code, each bit    x  e     subscript  x  e    x_{e}   is linked with an edge   e   e   e   of   E   E   E   .  We can define the code   C   C   C   to be the set of binary vectors    x  =   (   x  1   ,   x  2   ,  ‚Ä¶  ,   x  N   )       x    subscript  x  1    subscript  x  2   normal-‚Ä¶   subscript  x  N      x=\left(x_{1},x_{2},\ldots,x_{N}\right)   of     {  0  ,  1  }   N     superscript   0  1   N    \{0,1\}^{N}   such that, for every vertex   v   v   v   of   V   V   V   ,    (   x   v   (  1  )     ,   x   v   (  2  )     ,  ‚Ä¶  ,   x   v   (  d  )     )      subscript  x    v  1     subscript  x    v  2    normal-‚Ä¶   subscript  x    v  d      \left(x_{v(1)},x_{v(2)},\ldots,x_{v(d)}\right)   is a code word of    C  o     subscript  C  o    C_{o}   . In this case, we can consider a special case when every vertex of   E   E   E   is adjacent to exactly   2   2   2   vertices of   V   V   V   . It means that   V   V   V   and   E   E   E   make up, respectively, the vertex set and edge set of   d   d   d   regular graph   G   G   G   .  Let us call the code   C   C   C   constructed in this way as    (  G  ,   C  o   )     G   subscript  C  o     \left(G,C_{o}\right)   code. For a given graph   G   G   G   and a given code    C  o     subscript  C  o    C_{o}   , there are several    (  G  ,   C  o   )     G   subscript  C  o     \left(G,C_{o}\right)   codes as there are different ways of ordering edges incident to a given vertex   v   v   v   , i.e.,     v   (  1  )    ,   v   (  2  )    ,  ‚Ä¶  ,   v   (  d  )         v  1     v  2   normal-‚Ä¶    v  d     v(1),v(2),\ldots,v(d)   . In fact our code   C   C   C   consist of all codewords such that     x  v   ‚àà   C  o        subscript  x  v    subscript  C  o     x_{v}\in C_{o}   for all    v  ‚àà   A  ,  B       v   A  B     v\in A,B   . The code   C   C   C   is linear    [  N  ,  K  ,  D  ]     N  K  D    [N,K,D]   in   ùîΩ   ùîΩ   \mathbb{F}   as it is generated from a subcode    C  o     subscript  C  o    C_{o}   , which is linear. The code   C   C   C   is defined as    C  =   {   c  ‚àà   ùîΩ  N    :     (  c  )   v   ‚àà   C  o    }       C   conditional-set    c   superscript  ùîΩ  N       subscript  c  v    subscript  C  o       C=\{c\in\mathbb{F}^{N}:(c)_{v}\in C_{o}\}   for every    v  ‚àà  V      v  V    v\in V   .  thumb|upright=2.0|alt=A |Graph G and code C  In this figure,      (  x  )   v   =   (   x   e  1    ,   x   e  2    ,   x   e  3    ,   x   e  4    )   ‚àà   C  o          subscript  x  v     subscript  x    e  1     subscript  x    e  2     subscript  x    e  3     subscript  x    e  4           subscript  C  o      (x)_{v}=\left(x_{e1},x_{e2},x_{e3},x_{e4}\right)\in C_{o}   . It shows the graph   G   G   G   and code   C   C   C   .  In matrix   G   G   G   , let   Œª   Œª   \lambda   is equal to the second largest eigen value of adjacency matrix of   G   G   G   . Here the largest eigen value is   d   d   d   . Two important claims are made:  Claim 1       (    K  N    )   ‚â•    2   r  o    -  1         K  N       2   subscript  r  o    1     \left(\dfrac{K}{N}\right)\geq 2r_{o}-1     . Let   R   R   R   be the rate of a linear code constructed from a bipartite graph whose digit nodes have degree   m   m   m   and whose subcode nodes have degree   n   n   n   . If a single linear code with parameters    (  n  ,  k  )     n  k    \left(n,k\right)   and rate    r  =   (    k  n    )       r    k  n     r=\left(\dfrac{k}{n}\right)   is associated with each of the subcode nodes, then    k  ‚â•   1  -    (   1  -  r   )   m        k    1      1  r   m      k\geq 1-\left(1-r\right)m    .  Proof  Let   R   R   R   be the rate of the linear code, which is equal to    K  /  N      K  N    K/N   Let there are   S   S   S   subcode nodes in the graph. If the degree of the subcode is   n   n   n   , then the code must have     (    n  m    )   S        n  m   S    \left(\dfrac{n}{m}\right)S   digits, as each digit node is connected to   m   m   m   of the     (  n  )   S      n  S    \left(n\right)S   edges in the graph. Each subcode node contributes    (   n  -  k   )      n  k    (n-k)   equations to parity check matrix for a total of     (   n  -  k   )   S        n  k   S    \left(n-k\right)S   . These equations may not be linearly independent. Therefore,     (    K  N    )   ‚â•   (       (    n  m    )   S   -    (   n  -  k   )   S      (    n  m    )   S     )         K  N           n  m   S       n  k   S        n  m   S      \left(\dfrac{K}{N}\right)\geq\left(\dfrac{(\dfrac{n}{m})S-(n-k)S}{(\dfrac{n}{m%
 })S}\right)         ‚â•   1  -   m   (     n  -  k   n    )         absent    1    m      n  k   n       \geq 1-m\left(\dfrac{n-k}{n}\right)         ‚â•   1  -   m   (   1  -  r   )         absent    1    m    1  r       \geq 1-m\left(1-r\right)   , Since the value of   m   m   m   ,i.e., the digit node of this bipartite graph is   2   2   2   and here    r  =   r  o       r   subscript  r  o     r=r_{o}   , we can write as:      (    K  N    )   ‚â•    2   r  o    -  1         K  N       2   subscript  r  o    1     \left(\dfrac{K}{N}\right)\geq 2r_{o}-1     Claim 2      D  ‚â•  N   (    (   Œ¥  -   (    Œª  d    )    )    (  1  -   (    Œª  d    )     )   )    2      fragments  D   N   fragments  normal-(      Œ¥    Œª  d     fragments  normal-(  1    fragments  normal-(    Œª  d   normal-)     normal-)   normal-)   2     D\geq N\left(\dfrac{(\delta-(\dfrac{\lambda}{d}))}{(1-(\dfrac{\lambda}{d})})%
 \right)^{2}          =   N   (    Œ¥  2   -   O   (   Œª  d   )     )        absent    N     superscript  Œ¥  2     O    Œª  d        =N\left(\delta^{2}-O\left(\dfrac{\lambda}{d}\right)\right)        ‚Üí   (  1  )      normal-‚Üí  absent  1    \rightarrow(1)     ''If   S   S   S   is linear code of rate   r   r   r   , block code length   d   d   d   , and minimum relative distance   Œ¥   Œ¥   \delta   , and if   B   B   B   is the edge vertex incidence graph of a   d   d   d   ‚Äì regular graph with second largest eigen value   Œª   Œª   \lambda   , then the code    C   (  B  ,  S  )       C   B  S     C(B,S)   has rate at least     2   r  o    -  1        2   subscript  r  o    1    2r_{o}-1   and minimum relative distance at least     (   (     Œ¥  -   (    Œª  d    )     1  -   (    Œª  d    )      )   )   2     superscript      Œ¥    Œª  d      1    Œª  d     2    \left(\left(\dfrac{\delta-\left(\dfrac{\lambda}{d}\right)}{1-\left(\dfrac{%
 \lambda}{d}\right)}\right)\right)^{2}   .  Proof  Let   B   B   B   be derived from the   d   d   d   regular graph   G   G   G   . So, the number of variables of    C   (  B  ,  S  )       C   B  S     C(B,S)   is    (     d  n   2    )        d  n   2    \left(\dfrac{dn}{2}\right)   and the number of constraints is   n   n   n   . According to Alon - Chung, 4 if   X   X   X   is a subset of vertices of   G   G   G   of size    Œ≥  n      Œ≥  n    \gamma n   , then the number of edges contained in the subgraph is induced by   X   X   X   in   G   G   G   is at most     (     d  n   2    )    (    Œ≥  2   +    (    Œª  d    )   Œ≥   (   1  -  Œ≥   )     )           d  n   2      superscript  Œ≥  2       Œª  d   Œ≥    1  Œ≥       \left(\dfrac{dn}{2}\right)\left(\gamma^{2}+(\dfrac{\lambda}{d})\gamma\left(1-%
 \gamma\right)\right)   .  As a result, any set of     (     d  n   2    )    (    Œ≥  2   +    (    Œª  d    )   Œ≥   (   1  -  Œ≥   )     )           d  n   2      superscript  Œ≥  2       Œª  d   Œ≥    1  Œ≥       \left(\dfrac{dn}{2}\right)\left(\gamma^{2}+\left(\dfrac{\lambda}{d}\right)%
 \gamma\left(1-\gamma\right)\right)   variables will be having at least    Œ≥  n      Œ≥  n    \gamma n   constraints as neighbours. So the average number of variables per constraint is    (     (     2  n  d   2    )    (    Œ≥  2   +    (    Œª  d    )   Œ≥   (   1  -  Œ≥   )     )     Œ≥  n    )            2  n  d   2      superscript  Œ≥  2       Œª  d   Œ≥    1  Œ≥        Œ≥  n     \left(\dfrac{(\dfrac{2nd}{2})\left(\gamma^{2}+(\dfrac{\lambda}{d})\gamma\left(%
 1-\gamma\right)\right)}{\gamma n}\right)        =   d   (   Œ≥  +    (    Œª  d    )    (   1  -  Œ≥   )     )        absent    d    Œ≥      Œª  d     1  Œ≥        =d\left(\gamma+(\dfrac{\lambda}{d})\left(1-\gamma\right)\right)        ‚Üí   (  2  )      normal-‚Üí  absent  2    \rightarrow(2)     So if     d   (   Œ≥  +    (    Œª  d    )    (   1  -  Œ≥   )     )    <   Œ≥  d         d    Œ≥      Œª  d     1  Œ≥        Œ≥  d     d\left(\gamma+(\dfrac{\lambda}{d})\left(1-\gamma\right)\right)<\gamma d   , then a word of relative weight    (    Œ≥  2   +    (    Œª  d    )   Œ≥   (   1  -  Œ≥   )     )       superscript  Œ≥  2       Œª  d   Œ≥    1  Œ≥      \left(\gamma^{2}+(\dfrac{\lambda}{d})\gamma\left(1-\gamma\right)\right)   , cannot be a codeword of    C   (  B  ,  S  )       C   B  S     C(B,S)   . The inequality    (  2  )    2   (2)   is satisfied for    Œ≥  <   (     1  -   (    Œª  d    )     Œ¥  -   (    Œª  d    )      )       Œ≥      1    Œª  d      Œ¥    Œª  d       \gamma<\left(\dfrac{1-(\dfrac{\lambda}{d})}{\delta-(\dfrac{\lambda}{d})}\right)   . Therefore,    C   (  B  ,  S  )       C   B  S     C(B,S)   cannot have a non zero codeword of relative weight     (     Œ¥  -   (    Œª  d    )     1  -   (    Œª  d    )      )   2     superscript      Œ¥    Œª  d      1    Œª  d     2    \left(\dfrac{\delta-(\dfrac{\lambda}{d})}{1-(\dfrac{\lambda}{d})}\right)^{2}   or less.  In matrix   G   G   G   , we can assume that    Œª  /  d      Œª  d    \lambda/d   is bounded away from   1   1   1   . For those values of   d   d   d   in which    d  -  1      d  1    d-1   is odd prime, there are explicit constructions of sequences of   d   d   d   - regular bipartite graphs with arbitrarily large number of vertices such that each graph   G   G   G   in the sequence is a Ramanujan graph . It is called Ramanujan graph as it satisfies the inequality     Œª   (  G  )    ‚â§   2    d  -  1           Œª  G     2      d  1       \lambda(G)\leq 2\sqrt{d-1}   . Certain expansion properties are visible in graph   G   G   G   as the separation between the eigen values   d   d   d   and   Œª   Œª   \lambda   . If the graph   G   G   G   is Ramanujan graph, then that expression    (  1  )    1   (1)   will become   0   0    eventually as   d   d   d   becomes large.  Zemor's algorithm  The iterative decoding algorithm written below alternates between the vertices   A   A   A   and   B   B   B   in   G   G   G   and corrects the codeword of    C  o     subscript  C  o    C_{o}   in   A   A   A   and then it switches to correct the codeword    C  o     subscript  C  o    C_{o}   in   B   B   B   . Here edges associated with a vertex on one side of a graph are not incident to other vertex on that side. In fact, it doesn't matter in which order, the set of nodes   A   A   A   and   B   B   B   are processed. The vertex processing can also be done in parallel.  The decoder    ùîª  :    ùîΩ  d   ‚Üí   C  o       normal-:  ùîª   normal-‚Üí   superscript  ùîΩ  d    subscript  C  o      \mathbb{D}:\mathbb{F}^{d}\rightarrow C_{o}   stands for a decoder for    C  o     subscript  C  o    C_{o}   that recovers correctly with any codewords with less than    (    d  2    )      d  2    \left(\dfrac{d}{2}\right)   errors.  Decoder algorithm  Received word     w  =   (   w  e   )    ,   e  ‚àà  E      formulae-sequence    w   subscript  w  e      e  E     w=(w_{e}),e\in E      z \leftarrow w For t \leftarrow 1 to m do         // m is the number of iterations { if ( t is odd)                                       // Here the algorithm will alternate between its two vertex sets.  X \leftarrow A else X \leftarrow B  Iteration t : For every v \in X , let (z)_v \leftarrow \mathbb{D}((z)_v) // Decoding z_v to its nearest codeword. }  Output   z   z   z     Explanation of the algorithm  Since   G   G   G   is bipartite, the set   A   A   A   of vertices induces the partition of the edge set   E   E   E   =     ‚à™   v  ‚àà  A     E  v       subscript     v  A     subscript  E  v     \cup_{v\in A}E_{v}   . The set   B   B   B   induces another partition,   E   E   E   =     ‚à™   v  ‚àà  B     E  v       subscript     v  B     subscript  E  v     \cup_{v\in B}E_{v}   .  Let    w  ‚àà    {  0  ,  1  }   N       w   superscript   0  1   N     w\in\{0,1\}^{N}   be the received vector, and recall that    N  =   d  n       N    d  n     N=dn   . The first iteration of the algorithm consists of applying the complete decoding for the code induced by    E  v     subscript  E  v    E_{v}   for every    v  ‚àà  A      v  A    v\in A   . This means that for replacing, for every    v  ‚àà  A      v  A    v\in A   , the vector    (   w   v   (  1  )     ,   w   v   (  2  )     ,  ‚Ä¶  ,   w   v   (  d  )     )      subscript  w    v  1     subscript  w    v  2    normal-‚Ä¶   subscript  w    v  d      \left(w_{v(1)},w_{v(2)},\ldots,w_{v(d)}\right)   by one of the closest codewords of    C  o     subscript  C  o    C_{o}   . Since the subsets of edges    E  v     subscript  E  v    E_{v}   are disjoint for    v  ‚àà  A      v  A    v\in A   , the decoding of these   n   n   n   subvectors of   w   w   w   may be done in parallel.  The iteration will yield a new vector   z   z   z   . The next iteration consists of applying the preceding procedure to   z   z   z   but with   A   A   A   replaced by   B   B   B   . In other words, it consists of decoding all the subvectors induced by the vertices of   B   B   B   . The coming iterations repeat those two steps alternately applying parallel decoding to the subvectors induced by the vertices of   A   A   A   and to the subvectors induced by the vertices of   B   B   B   .  Note: [If    d  =  n      d  n    d=n   and   G   G   G   is the complete bipartite graph, then   C   C   C   is a product code of    C  o     subscript  C  o    C_{o}   with itself and the above algorithm reduces to the natural hard iterative decoding of product codes].  Here, the number of iterations,   m   m   m   is    (     (   log  n   )    log   (   2  -  Œ±   )      )        n       2  Œ±      \left(\dfrac{(\log{n})}{\log(2-\alpha)}\right)   . In general, the above algorithm can correct a code word whose Hamming weight is no more than     (    1  2    )   .  Œ±  N  Œ¥   (   (    Œ¥  2    )   -   (    Œª  d    )   )   =   (   (    1  4    )   .  Œ±  N   (   Œ¥  2   -  O   (    Œª  d    )   )       fragments   fragments  normal-(    1  2   normal-)   normal-.  Œ±  N  Œ¥   fragments  normal-(   fragments  normal-(    Œ¥  2   normal-)     fragments  normal-(    Œª  d   normal-)   normal-)     fragments  normal-(   fragments  normal-(    1  4   normal-)   normal-.  Œ±  N   fragments  normal-(   superscript  Œ¥  2    O   fragments  normal-(    Œª  d   normal-)   normal-)      (\dfrac{1}{2}).\alpha N\delta\left((\dfrac{\delta}{2})-(\dfrac{\lambda}{d})%
 \right)=\left((\dfrac{1}{4}).\alpha N(\delta^{2}-O(\dfrac{\lambda}{d})\right)   for values of    Œ±  <  1      Œ±  1    \alpha<1   . Here, the decoding algorithm is implemented as a circuit of size    O   (   N   log  N    )       O    N    N      O(N\log{N})   and depth    O   (   log  N   )       O    N     O(\log{N})   that returns the codeword given that error vector has weight less than     Œ±  N   Œ¥  2    (   1  -  œµ   )    /  4        Œ±  N   superscript  Œ¥  2     1  œµ    4    \alpha N\delta^{2}(1-\epsilon)/4   .  Theorem  If   G   G   G   is a Ramanujan graph of sufficiently high degree, for any    Œ±  <  1      Œ±  1    \alpha<1   , the decoding algorithm can correct     (     Œ±   Œ¥  o  2    4    )    (  1  -  ‚àà  )   N     fragments   fragments  normal-(      Œ±   superscript   subscript  Œ¥  o   2    4   normal-)    fragments  normal-(  1    normal-)   N    (\dfrac{\alpha\delta_{o}^{2}}{4})(1-\in)N   errors, in    O   (   log  n   )       O    n     O(\log{n})   rounds ( where the big-   O   O   O   notation hides a dependence on   Œ±   Œ±   \alpha   ). This can be implemented in linear time on a single processor; on   n   n   n   processors each round can be implemented in constant time.  Proof  Since the decoding algorithm is insensitive to the value of the edges and by linearity, we can assume that the transmitted codeword is the all zeros - vector. Let the received codeword be   w   w   w   . The set of edges which has an incorrect value while decoding is considered. Here by incorrect value, we mean   1   1   1   in any of the bits. Let    w  =   w  0       w   superscript  w  0     w=w^{0}   be the initial value of the codeword,     w  1   ,   w  2   ,  ‚Ä¶  ,   w  t       superscript  w  1    superscript  w  2   normal-‚Ä¶   superscript  w  t     w^{1},w^{2},\ldots,w^{t}   be the values after first, second¬†.¬†.¬†.   t   t   t   stages of decoding. Here,     X  i   =  e  ‚àà  E  |   x  e  i   =  1     fragments   superscript  X  i    e   E  normal-|   superscript   subscript  x  e   i    1    X^{i}={e\in E|x_{e}^{i}=1}   , and     S  i   =  v  ‚àà   V  i   |   E  v   ‚à©   X   i  +  1    !  =  ‚àÖ     fragments   superscript  S  i    v    superscript  V  i   normal-|   subscript  E  v     superscript  X    i  1         S^{i}={v\in V^{i}|E_{v}\cap X^{i+1}!=\emptyset}   . Here    S  i     superscript  S  i    S^{i}   corresponds to those set of vertices that was not able to successfully decode their codeword in the    i   t  h      superscript  i    t  h     i^{th}   round. From the above algorithm     |   S   i  +  1    |   ‚â§    (    1   2  -  Œ±     )    |   S  i   |           subscript  S    i  1         1    2  Œ±       subscript  S  i       |S_{i+1}|<=(\dfrac{1}{2-\alpha})|S_{i}|   is a decreasing sequence. In fact,    Œ±  <  1      Œ±  1    \alpha<1   . As we are assuming,     ‚àë   |   S  i   |    =   n   ‚àë   (    1    (   2  -  Œ±   )   i     )     =   O   (  n  )               subscript  S  i       n      1   superscript    2  Œ±   i             O  n      \sum|S_{i}|=n\sum(\dfrac{1}{(2-\alpha)^{i}})=O(n)   , the above equation is in a geometric decreasing sequence . So, when    i   t  h      superscript  i    t  h     i^{th}   rounds are necessary. Furthermore,    O   (   |   S  i   |   )       O     subscript  S  i      O(|S_{i}|)   , and if we implement the   m   m   m   round in    [    (   log  n   )   /   (   log   (   2  -  Œ±   )    )    ]     delimited-[]      n       2  Œ±       [(\log{n})/(\log(2-\alpha))]   time, then the total sequential running time will be linear.  Drawbacks of Zemor's algorithm   It is lengthy process as the number of iterations $m$ in decoder algorithm takes is $[(\log{ n})/(\log(2-\alpha))]$  Zemor's decoding algorithm finds it difficult to decode erasures. A detailed way of how we can improve the algorithm is   given in. 5  See also   Expander codes  Tanner graph  Linear time encoding and decoding of error-correcting codes   References  "  Category:Coding theory  Category:Error detection and correction     Gilles Zemor ‚Ü©  http://www.cs.washington.edu/education/courses/cse590vg/03wi/scribes/1-27.ps ‚Ü©  http://www.cs.washington.edu/education/courses/cse533/06au/lecnotes/lecture14.pdf ‚Ü©  http://math.ucsd.edu/~fan/mypaps/fanpap/93tolerant.pdf ‚Ü©  http://www.cs.technion.ac.il/~vitalys/Papers/GMD-expander/GMD-decode-expander.ps ‚Ü©     