<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="326">Adiabatic quantum computation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Adiabatic quantum computation</h1><hr/>

<p><strong>Adiabatic quantum computation</strong> (<strong>AQC</strong>) relies on the <a href="adiabatic_theorem" title="wikilink">adiabatic theorem</a> to do calculations<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and is closely related to, and may be regarded as a subclass of, <a href="quantum_annealing" title="wikilink">quantum annealing</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> First, a (potentially complicated) <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a> is found whose ground state describes the solution to the problem of interest. Next, a system with a simple Hamiltonian is prepared and initialized to the ground state. Finally, the simple Hamiltonian is adiabatically evolved to the desired complicated Hamiltonian. By the adiabatic theorem, the system remains in the ground state, so at the end the state of the system describes the solution to the problem. Adiabatic Quantum Computing has been shown to be polynomially equivalent to conventional quantum computing in the circuit model.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The time complexity for an adiabatic algorithm is the time taken to complete the adiabatic evolution which is dependent on the gap in the energy eigenvalues (spectral gap) of the Hamiltonian. Specifically, if the system is to be kept in the ground state, the energy gap between the ground state and the first excited state of 

<math display="inline" id="Adiabatic_quantum_computation:0">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(t)
  </annotation>
 </semantics>
</math>

 provides an upper bound on the rate at which the Hamiltonian can be evolved at time 

<math display="inline" id="Adiabatic_quantum_computation:1">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> When the spectral gap is small, the Hamiltonian has to be evolved slowly. The runtime for the entire algorithm can be bounded by 

<math display="inline" id="Adiabatic_quantum_computation:2">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mn>1</mn>
      <msubsup>
       <mi>g</mi>
       <mrow>
        <mi>m</mi>
        <mi>i</mi>
        <mi>n</mi>
       </mrow>
       <mn>2</mn>
      </msubsup>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=O\left(\frac{1}{g_{min}^{2}}\right)
  </annotation>
 </semantics>
</math>

 Where 

<math display="inline" id="Adiabatic_quantum_computation:3">
 <semantics>
  <msub>
   <mi>g</mi>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{min}
  </annotation>
 </semantics>
</math>

 is the minimum spectral gap for 

<math display="inline" id="Adiabatic_quantum_computation:4">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(t)
  </annotation>
 </semantics>
</math>

.</p>

<p>AQC is a possible method to get around the problem of <a href="Quantum_dissipation" title="wikilink">energy relaxation</a>. Since the quantum system is in the ground state, interference with the outside world cannot make it move to a lower state. If the energy of the outside world (that is, the "temperature of the bath") is kept lower than the energy gap between the ground state and the next higher energy state, the system has a proportionally lower probability of going to a higher energy state. Thus the system can stay in a single system eigenstate as long as needed.</p>

<p>Universality results in the adiabatic model are tied to quantum complexity and <a class="uri" href="QMA" title="wikilink">QMA</a>-hard problems. The k-local Hamiltonian is QMA-complete for k ≥ 2.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> QMA-hardness results are known for physically realistic <a href="lattice_models" title="wikilink">lattice models</a> of <a class="uri" href="qubits" title="wikilink">qubits</a> such as <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> 

<math display="inline" id="Adiabatic_quantum_computation:5">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>z</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>σ</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>x</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{z},\sigma_{x}
  </annotation>
 </semantics>
</math>

 represent the <a href="Pauli_matrices" title="wikilink">Pauli matrices</a> 

<math display="inline" id="Adiabatic_quantum_computation:6">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>∧</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
   <mo>∧</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∧</mo>
   <msub>
    <mi>C</mi>
    <mi>M</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}\wedge C_{2}\wedge\cdots\wedge C_{M}
  </annotation>
 </semantics>
</math>

. Such models are used for universal adiabatic quantum computation. The Hamiltonians for the QMA-complete problem can also be restricted to act on a two dimensional grid of <a class="uri" href="qubits" title="wikilink">qubits</a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> or a line of quantum particles with 12 states per particle.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and if such models were found to be physically realisable, they too could be used to form the building blocks of a universal adiabatic quantum computer.</p>

<p>In practice, there are problems during a computation. As the Hamiltonian is gradually changed, the interesting parts (quantum behaviour as opposed to classical) occur when multiple <a href="qubit" title="wikilink">qubits</a> are close to a tipping point. It is exactly at this point when the ground state (one set of qubit orientations) gets very close to a first energy state (a different arrangement of orientations). Adding a slight amount of energy (from the external bath, or as a result of slowly changing the Hamiltonian) could take the system out of the ground state, and ruin the calculation. Trying to perform the calculation more quickly increases the external energy; scaling the number of qubits makes the energy gap at the tipping points smaller.</p>
<h2 id="adiabatic-quantum-computation-in-satisfiability-problems">Adiabatic quantum computation in satisfiability problems</h2>

<p>Adiabatic quantum computation solves satisfiability problems and other combinatorial search problems by the process below. Generally this kind of problem is to seek for a state that satisfies 

<math display="inline" id="Adiabatic_quantum_computation:7">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

. This expression contains the satisfiability of M clauses, each clause 

<math display="inline" id="Adiabatic_quantum_computation:8">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}\in\{0,1\}
  </annotation>
 </semantics>
</math>

 has the value True or False, and can involve n bits. Each bit here is a variable 

<math display="inline" id="Adiabatic_quantum_computation:9">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

 so 

<math display="inline" id="Adiabatic_quantum_computation:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},x_{2},\dots,x_{n}
  </annotation>
 </semantics>
</math>

 is a Boolean value function of 

<math display="inline" id="Adiabatic_quantum_computation:11">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{B}
  </annotation>
 </semantics>
</math>

. QAA solves this kind of problem using quantum adiabatic evolution. It starts with an Initial Hamiltonian 

<math display="inline" id="Adiabatic_quantum_computation:12">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>B</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <msub>
      <mi>B</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>H</mi>
     <msub>
      <mi>B</mi>
      <mn>2</mn>
     </msub>
    </msub>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
    <mo>+</mo>
    <msub>
     <mi>H</mi>
     <msub>
      <mi>B</mi>
      <mi>M</mi>
     </msub>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{B}=H_{B_{1}}+H_{B_{2}}+\dots+H_{B_{M}}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Adiabatic_quantum_computation:13">
 <semantics>
  <msub>
   <mi>H</mi>
   <msub>
    <mi>B</mi>
    <mi>i</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{B_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Adiabatic_quantum_computation:14">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

 shows the Hamiltonian corresponding to the clause 

<math display="inline" id="Adiabatic_quantum_computation:15">
 <semantics>
  <msub>
   <mi>H</mi>
   <msub>
    <mi>B</mi>
    <mi>i</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{B_{i}}
  </annotation>
 </semantics>
</math>

, usually the choice of 

<math display="inline" id="Adiabatic_quantum_computation:16">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{P}
  </annotation>
 </semantics>
</math>

 won't depend on different clauses, so only the total number of times each bit involved in all clauses matters. Then it goes through an adiabatic evolution, ending in the Problem Hamiltonian 

<math display="inline" id="Adiabatic_quantum_computation:17">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>P</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>C</mi>
    </munder>
    <msub>
     <mi>H</mi>
     <mrow>
      <mi>P</mi>
      <mo>,</mo>
      <mi>C</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>C</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <list>
       <ci>P</ci>
       <ci>C</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{P}=\sum\limits_{C}H_{P,C}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Adiabatic_quantum_computation:18">
 <semantics>
  <msub>
   <mi>H</mi>
   <mrow>
    <mi>P</mi>
    <mo>,</mo>
    <mi>C</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <list>
     <ci>P</ci>
     <ci>C</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{P,C}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Adiabatic_quantum_computation:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>C</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>z</mi>
      <mrow>
       <mn>1</mn>
       <mi>C</mi>
      </mrow>
     </msub>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>z</mi>
       <mrow>
        <mn>2</mn>
        <mi>C</mi>
       </mrow>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>z</mi>
       <mrow>
        <mi>n</mi>
        <mi>C</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>c</mi>
        <mi>l</mi>
        <mi>a</mi>
        <mi>u</mi>
        <mi>s</mi>
        <mpadded width="+5pt">
         <mi>e</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>C</mi>
        </mpadded>
        <mi>s</mi>
        <mi>a</mi>
        <mi>t</mi>
        <mi>i</mi>
        <mi>s</mi>
        <mi>f</mi>
        <mi>i</mi>
        <mi>e</mi>
        <mi>d</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>c</mi>
        <mi>l</mi>
        <mi>a</mi>
        <mi>u</mi>
        <mi>s</mi>
        <mpadded width="+5pt">
         <mi>e</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>C</mi>
        </mpadded>
        <mi>v</mi>
        <mi>i</mi>
        <mi>o</mi>
        <mi>l</mi>
        <mi>a</mi>
        <mi>t</mi>
        <mi>e</mi>
        <mi>d</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>C</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <times></times>
        <cn type="integer">1</cn>
        <ci>C</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>C</ci>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>C</ci>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>l</ci>
      <ci>a</ci>
      <ci>u</ci>
      <ci>s</ci>
      <ci>e</ci>
      <ci>C</ci>
      <ci>s</ci>
      <ci>a</ci>
      <ci>t</ci>
      <ci>i</ci>
      <ci>s</ci>
      <ci>f</ci>
      <ci>i</ci>
      <ci>e</ci>
      <ci>d</ci>
     </apply>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>l</ci>
      <ci>a</ci>
      <ci>u</ci>
      <ci>s</ci>
      <ci>e</ci>
      <ci>C</ci>
      <ci>v</ci>
      <ci>i</ci>
      <ci>o</ci>
      <ci>l</ci>
      <ci>a</ci>
      <ci>t</ci>
      <ci>e</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{C}(z_{1C},z_{2C}\dots z_{nC})=\begin{cases}0&clause\ C\ satisfied\\
1&clause\ C\ violated\end{cases}
  </annotation>
 </semantics>
</math>

 is the satisfying Hamiltonian of clause C. It has eigenvalues:</p>

<p>

<math display="inline" id="Adiabatic_quantum_computation:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mi>t</mi>
        <mo>/</mo>
        <mi>T</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>H</mi>
      <mi>B</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>/</mo>
       <mi>T</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>H</mi>
      <mi>P</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <ci>t</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>t</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>P</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(t)=(1-t/T)H_{B}+(t/T)H_{P}
  </annotation>
 </semantics>
</math>

</p>

<p>For a simple path of Adiabatic Evolution with running time T, consider: 

<math display="inline" id="Adiabatic_quantum_computation:21">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mo>/</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <divide></divide>
     <ci>t</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=t/T
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Adiabatic_quantum_computation:22">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>H</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>H</mi>
      <mi>B</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>s</mi>
     <msub>
      <mi>H</mi>
      <mi>P</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>H</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>P</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}(s)=(1-s)H_{B}+sH_{P}
  </annotation>
 </semantics>
</math>

, we have: 

<math display="inline" id="Adiabatic_quantum_computation:23">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{B}
  </annotation>
 </semantics>
</math>

, which is the adiabatic evolution Hamiltonian of our algorithm.</p>

<p>According to the adiabatic theorem, we start from the ground state of Hamiltonian 

<math display="inline" id="Adiabatic_quantum_computation:24">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{P}
  </annotation>
 </semantics>
</math>

 at beginning, go through an adiabatic process, and at last ending in the ground state of problem Hamiltonian 

<math display="inline" id="Adiabatic_quantum_computation:25">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>z</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>z</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1},z_{2},\dots,z_{n}
  </annotation>
 </semantics>
</math>

. Then we measure the z-component of each of the n spins in the final state, this will produce a string 

<math display="inline" id="Adiabatic_quantum_computation:26">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo>/</mo>
   <msubsup>
    <mi>g</mi>
    <mrow>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>ε</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon/g_{min}^{2}
  </annotation>
 </semantics>
</math>

 which is highly likely to be the result of our satisfiability problem. Here the running time T must be sufficiently long to assure the correctness of result, and according to adiabatic theorem, T is about 

<math display="inline" id="Adiabatic_quantum_computation:27">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mrow>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>min</mi>
     <mrow>
      <mn>0</mn>
      <mo>≤</mo>
      <mi>s</mi>
      <mo>≤</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>E</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>E</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <ci>s</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{min}=\min_{0\leq s\leq 1}(E_{1}(s)-E_{0}(s))
  </annotation>
 </semantics>
</math>

, where <span class="LaTeX">$g_{min}=\min_{0\le s\le 1}(E_1(s)-E_0(s))$</span> is the minimum energy gap between ground state and first excited state.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="d-wave-quantum-processors">D-Wave quantum processors</h2>

<p>The <a href="D-Wave_One" title="wikilink">D-Wave One</a> is a device made by a Canadian company <a href="D-Wave_Systems" title="wikilink">D-Wave Systems</a> which describes it as doing quantum annealing.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> In 2011, <a class="uri" href="Lockheed-Martin" title="wikilink">Lockheed-Martin</a> purchased one for about US$10 million; in May 2013, <a class="uri" href="Google" title="wikilink">Google</a> purchased a <a href="D-Wave_Two" title="wikilink">D-Wave Two</a> with 512 qubits.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> As of now, the question of whether the D-Wave processors offer a speedup over a classical processor is still unanswered. Tests performed by researchers at <a href="University_of_Southern_California" title="wikilink">USC</a>, <a href="ETH_Zurich" title="wikilink">ETH Zurich</a>, and <a class="uri" href="Google" title="wikilink">Google</a> show that as of now, there is no evidence of a quantum advantage.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="notes">Notes</h2>

<p>"</p>

<p><a href="Category:Quantum_mechanics" title="wikilink">Category:Quantum mechanics</a> <a href="Category:Physics_theorems" title="wikilink">Category:Physics theorems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
</ol>
</section>
</body>
</html>
