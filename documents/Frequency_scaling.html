<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="301">Frequency scaling</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Frequency scaling</h1>
<hr/>

<p>In <a href="computer_architecture" title="wikilink">computer architecture</a>, <strong>frequency scaling</strong> (also known as <strong>frequency ramping</strong>) is the technique of ramping a processor's <a class="uri" href="frequency" title="wikilink">frequency</a> so as to achieve performance gains. Frequency ramping was the dominant force in commodity processor performance increases from the mid-1980s until roughly the end of 2004.</p>

<p>The effect of processor <a class="uri" href="frequency" title="wikilink">frequency</a> on computer speed can be seen by looking at the equation for computer program runtime:</p>

<p>

<math display="block" id="Frequency_scaling:0">
 <semantics>
  <mrow>
   <mi>Runtime</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mi>Instructions</mi>
     <mi>Program</mi>
    </mfrac>
    <mo>×</mo>
    <mfrac>
     <mi>Cycles</mi>
     <mi>Instruction</mi>
    </mfrac>
    <mo>×</mo>
    <mfrac>
     <mi>Time</mi>
     <mi>Cycle</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Runtime</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>Instructions</ci>
      <ci>Program</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>Cycles</ci>
      <ci>Instruction</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>Time</ci>
      <ci>Cycle</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Runtime}=\frac{\mathrm{Instructions}}{\mathrm{Program}}\times\frac{%
\mathrm{Cycles}}{\mathrm{Instruction}}\times\frac{\mathrm{Time}}{\mathrm{Cycle}}
  </annotation>
 </semantics>
</math>

 where instructions per program is the total instructions being executed in a given program, cycles per instruction is a program-dependent, architecture-dependent average value, and seconds per cycles is by definition the inverse of frequency.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> An increase in frequency thus decreases runtime.</p>

<p>However, <a href="power_consumption" title="wikilink">power consumption</a> in a chip is given by the equation</p>

<p>

<math display="block" id="Frequency_scaling:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mo>×</mo>
    <msup>
     <mi>V</mi>
     <mn>2</mn>
    </msup>
    <mo>×</mo>
    <mi>F</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=C\times V^{2}\times F
  </annotation>
 </semantics>
</math>

 where P is power, C is the <a class="uri" href="capacitance" title="wikilink">capacitance</a> being switched per clock cycle, V is <a class="uri" href="voltage" title="wikilink">voltage</a>, and F is the processor frequency (cycles per second).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Increases in frequency thus increase the amount of power used in a processor. Increasing processor <a href="power_consumption" title="wikilink">power consumption</a> led ultimately to <a class="uri" href="Intel" title="wikilink">Intel</a>'s May 2004 cancellation of its <a href="Tejas_and_Jayhawk" title="wikilink">Tejas and Jayhawk</a> processors, which is generally cited as the end of frequency scaling as the dominant computer architecture paradigm.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p><a href="Moore's_Law" title="wikilink">Moore's Law</a>, despite predictions of its demise, is still in effect. Despite power issues, transistor densities are still doubling every 18 to 24 months. With the end of frequency scaling, these new transistors (which are no longer needed to facilitate frequency scaling) can be used to add extra hardware, such as additional cores, to facilitate parallel computing - a technique that is being referred to as <a href="parallel_scaling" title="wikilink">parallel scaling</a>.</p>

<p>The end of frequency scaling as the dominant cause of processor performance gains has caused an industry-wide shift to <a href="parallel_computing" title="wikilink">parallel computing</a> in the form of <a href="Multi-core_(computing)" title="wikilink">multicore processors</a>.</p>
<h2 id="references">References</h2>

<p><a href="fr:Fréquence_du_processeur" title="wikilink">fr:Fréquence du processeur</a>"</p>

<p><a href="Category:Computer_architecture" title="wikilink">Category:Computer architecture</a> <a href="Category:Central_processing_unit" title="wikilink">Category:Central processing unit</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="John_L._Hennessy" title="wikilink">John L. Hennessy</a> and <a href="David_A._Patterson_(scientist)" title="wikilink">David A. Patterson</a>. Computer Architecture: A Quantitative Approach. 3rd edition, 2002. Morgan Kaufmann, ISBN 1-55860-724-2. Page 43.<a href="#fnref1">↩</a></li>
<li id="fn2">J. M. Rabaey. Digital Integrated Circuits. Prentice Hall, 1996.<a href="#fnref2">↩</a></li>
<li id="fn3">Laurie J. Flynn. [<a class="uri" href="http://www.nytimes.com/2004/05/08/business/08chip.html?ex=1399348800&amp;en">http://www.nytimes.com/2004/05/08/business/08chip.html?ex=1399348800&amp;en;</a>;=98cc44ca97b1a562&amp;ei;=5007 Intel Halts Development of 2 New Microprocessors]. <em>New York Times</em>, May 8, 2004.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
