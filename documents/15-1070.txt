   Induction-recursion (type theory)      Induction-recursion (type theory)   In intuitionistic type theory (ITT), a discipline within mathematical logic , induction-recursion is a feature for simultaneously declaring a type and function on that type. It allows the creation of larger types, such as universes, than inductive types . The types created still remain predicative inside ITT.  An inductive definition is given by rules for generating elements of a type. One can then define functions from that type by induction on the way the elements of the type are generated. Induction-recursion generalizes this situation since one can simultaneously define the type and the function, because the rules for generating elements of the type are allowed to refer to the function. 1  Induction-recursion can be used to define large types including various universe constructions. It increases the proof-theoretic strength of type theory substantially. Nevertheless, inductive-recursive recursive definitions are still considered predicative .  Background  Induction-Recursion came out of investigations to the rules of Martin-Löf's intuitionistic type theory . The type theory has a number of "type formers" and 4 kinds rules for each one. Martin-Löf had hinted that the rules for each type former followed a pattern, which preserved the properties of the type theory (e.g., strong normalization , predicativity ). Researchers started looking for the most general description of the pattern, since that would tell what kinds of type formers could be added (or not added!) to extend the type theory.  The "universe" type former was the most interesting, because when the rules were written "ala Tarski", they simultaneously defined the "universe type" ''and ''a function that operated on it. This eventually lead Dybjer to Induction-Recursion.  Dybjer's initial papers called Induction-Recursion a "schema" for rules. It stated what type formers could be added to the type theory. Later, he and Setzer would write a new type former with rules that allowed new Induction-Recursion definitions to be made inside the type theory. 2 This was added to the Half proof assistant (a variant of Alf ).  The Idea  Before covering Inductive-Recursive types, the simpler case is Inductive Types. Constructors for Inductive types can be self-referential, but in a limited way. The constructor's parameters must be "positive":   not refer to the type being defined  be exactly the type being defined, or  be a function that returns the type being defined.   With Inductive types, a parameter's type can depend on earlier parameters, but they cannot refer to ones of the type being defined. Inductive-Recursive types go further and parameter's types can refer to earlier parameters that use the type being defined. These must be "half-positive":   be a function depending on an earlier parameter if that parameter is wrapped in the function being defined.   So, if   D   D   D   is the type being defined and   f   f   f   is the function being (simultaneously) defined, these parameter declarations are positive:       a  :  A     normal-:  a  A    a:A         d  :  D     normal-:  d  D    d:D         g  :   A  →   T  y  p  e       normal-:  g   normal-→  A    T  y  p  e      g:A\to Type         h  :   A  →  D      normal-:  h   normal-→  A  D     h:A\to D         i  :   A  →  B  →  D      normal-:  i     normal-→  A  B    normal-→    D      i:A\to B\to D         j  :    g   a      normal-:  j    g  a     j:g\ a   (Depends on earlier parameters, none of which are type   D   D   D   .)   This is half-positive:       k  :    (    f   d   )   →  D      normal-:  k   normal-→    f  d   D     k:(f\ d)\to D   (Depends on parameter   d   d   d   of type   D   D   D   but only through call to   f   f   f   .)   These are not positive nor half-positive:       k  :   D  →  A      normal-:  k   normal-→  D  A     k:D\to A   (   D   D   D   is a parameter to the function.)      l  :   (  A  →  D  )   →  A     fragments  l  normal-:   fragments  normal-(  A  normal-→  D  normal-)   normal-→  A    l:(A\to D)\to A   (The parameter takes a function that returns   D   D   D   , but returns   A   A   A   itself.)      m  :    z   d      normal-:  m    z  d     m:z\ d   (Depends on   d   d   d   of type   D   D   D   , but not through the function   f   f   f   .)   Universe Example  A simple common example is the Universe ala Tarski type former. It creates a type   U   U   U   and a function   T   T   T   . There is an element of   U   U   U   for every type in the type theory (except   U   U   U   itself!). The function   T   T   T   maps the elements of   U   U   U   to the associated type.  The type   U   U   U   has a constructor (or introduction rule) for each type former in the type theory. The one for dependent functions would be:      c  o  n  s  t  r  u  c  t  o   r  Π    (  u  :  U  )    (   u  ′   :   (  x  :  T   (  u  )   )   U  )   :  U     fragments  c  o  n  s  t  r  u  c  t  o   subscript  r  normal-Π    fragments  normal-(  u  normal-:  U  normal-)    fragments  normal-(   superscript  u  normal-′   normal-:   fragments  normal-(  x  normal-:  T   fragments  normal-(  u  normal-)   normal-)   U  normal-)   normal-:  U    constructor_{\Pi}(u:U)(u^{\prime}:(x:T(u))U):U     That is, it takes an element   u   u   u   of type   U   U   U   that will map to the type of the parameter and an element    u  ′     superscript  u  normal-′    u^{\prime}   that will map to the return type of the function (which is dependent on the value of the parameter). (The final     :  U     normal-:  absent  U    :U   says that the result of the constructor is an element of type   U   U   U   .)  The reduction (or computation rule) says that      T   (   c  o  n  s  t  r  u  c  t  o   r  Π    (  u  ,   u  ′   )    )       T    c  o  n  s  t  r  u  c  t  o   subscript  r  normal-Π    u   superscript  u  normal-′       T(constructor_{\Pi}(u,u^{\prime}))   becomes    Π   (   T   (  u  )    ,    (  x  )   T   (    u  ′    (  x  )    )    )       normal-Π     T  u     x  T     superscript  u  normal-′   x       \Pi(T(u),(x)T(u^{\prime}(x)))     After reduction, the function   T   T   T   is operating on a smaller part of the input. If that holds when   T   T   T   is applied to any constructor, then   T   T   T   will always terminate. Without going into the details, Induction-Recursion states what kinds of definitions (or rules) can be added to the theory such that the function calls will always terminate.  Usage  Induction-Recursion is implemented in Agda and Idris .  See also   Induction-Induction Further work that defines a type and family-of-types at the same time.   References  External links   A list of Peter Dybjer's publications on induction and induction-recursion    Slides covering Induction-Recursion and its derivatives   "  Category:Type theory     ↩  ↩     