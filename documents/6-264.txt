   Longest common substring problem      Longest common substring problem   In computer science , the longest common substring problem is to find the longest string (or strings) that is a substring (or are substrings) of two or more strings.  Example  The longest common substring of the strings "ABABC", "BABCA" and "ABCBA" is string "ABC" of length 3. Other common substrings are "A", "AB", "B", "BA", "BC" and "C".  ABABC  |||  BABCA  |||  ABCBA  Problem definition  Given two strings,   S   S   S   of length   m   m   m   and   T   T   T   of length   n   n   n   , find the longest strings which are substrings of both   S   S   S   and   T   T   T   .  A generalisation is the k-common substring problem . Given the set of strings    S  =   {   S  1   ,  â€¦  ,   S  K   }       S    subscript  S  1   normal-â€¦   subscript  S  K      S=\{S_{1},...,S_{K}\}   , where     |   S  i   |   =   n  i          subscript  S  i     subscript  n  i     |S_{i}|=n_{i}   and     Î£   n  i    =  N        normal-Î£   subscript  n  i    N    \Sigma n_{i}=N   . Find for each    2  â‰¤  k  â‰¤  K        2  k       K     2\leq k\leq K   , the longest strings which occur as substrings of at least   k   k   k   strings.  Algorithms  One can find the lengths and starting positions of the longest common substrings of   S   S   S   and   T   T   T   in    Î˜   (   n  +  m   )       normal-Î˜    n  m     \Theta(n+m)   with the help of a generalised suffix tree . Finding them by dynamic programming costs    Î˜   (   n  m   )       normal-Î˜    n  m     \Theta(nm)   . The solutions to the generalised problem take    Î˜   (    n  1   +  â€¦  +   n  K    )       normal-Î˜     subscript  n  1   normal-â€¦   subscript  n  K      \Theta(n_{1}+...+n_{K})   space and    Î˜   (   n  1       fragments  Î˜   fragments  normal-(   subscript  n  1      \Theta(n_{1}   Â·...Â·     n  K   )     fragments   subscript  n  K   normal-)    n_{K})   time with dynamic programming and take    Î˜   (   N  *  K   )       normal-Î˜    N  K     \Theta(N*K)   time with generalized suffix tree .  Suffix tree  The longest common substrings of a set of strings can be found by building a generalised suffix tree for the strings, and then finding the deepest internal nodes which have leaf nodes from all the strings in the subtree below it. The figure on the right is the suffix tree for the strings "ABAB", "BABA" and "ABBA", padded with unique string terminators, to become "ABAB$0", "BABA$1" and "ABBA$2". The nodes representing "A", "B", "AB" and "BA" all have descendant leaves from all of the strings, numbered 0, 1 and 2.  Building the suffix tree takes    Î˜   (  N  )       normal-Î˜  N    \Theta(N)   time (if the size of the alphabet is constant). If the tree is traversed from the bottom up with a bit vector telling which strings are seen below each node, the k-common substring problem can be solved in    Î˜   (   N  K   )       normal-Î˜    N  K     \Theta(NK)   time. If the suffix tree is prepared for constant time lowest common ancestor retrieval, it can be solved in    Î˜   (  N  )       normal-Î˜  N    \Theta(N)   time. 1  Dynamic programming  First find the longest common suffix for all pairs of prefixes of the strings. The longest common suffix is       ð¿ð¶ð‘†ð‘¢ð‘“ð‘“   (   S   1..  p    ,   T   1..  q    )    =   {       ð¿ð¶ð‘†ð‘¢ð‘“ð‘“   (   S    1..  p   -  1    ,   T    1..  q   -  1    )    +  1        if   S   [  p  ]    =   T   [  q  ]         0     otherwise  .             ð¿ð¶ð‘†ð‘¢ð‘“ð‘“    subscript  S    1..  p     subscript  T    1..  q       cases      ð¿ð¶ð‘†ð‘¢ð‘“ð‘“    subscript  S      1..  p   1     subscript  T      1..  q   1      1       if  S   delimited-[]  p      T   delimited-[]  q     0  otherwise     \mathit{LCSuff}(S_{1..p},T_{1..q})=\begin{cases}\mathit{LCSuff}(S_{1..p-1},T_{%
 1..q-1})+1&\mathrm{if}\;S[p]=T[q]\\
 0&\mathrm{otherwise}.\end{cases}     For the example strings "ABAB" and "BABA":        A   B   A   B        0   0   0   0   0     B   0   0   1   0   1     A   0   1   0   2   0     B   0   0   2   0   3     A   0   1   0   3   0     The maximal of these longest common suffixes of possible prefixes must be the longest common substrings of S and T . These are shown on diagonals, in red, in the table. For this example, the longest common substrings are "BAB" and "ABA".       ð¿ð¶ð‘†ð‘¢ð‘ð‘ ð‘¡ð‘Ÿ   (  S  ,  T  )    =     max    1  â‰¤  i  â‰¤  m   ,   1  â‰¤  j  â‰¤  n     ð¿ð¶ð‘†ð‘¢ð‘“ð‘“    (   S   1..  i    ,   T   1..  j    )          ð¿ð¶ð‘†ð‘¢ð‘ð‘ ð‘¡ð‘Ÿ   S  T        subscript    formulae-sequence      1  i       m        1  j       n      ð¿ð¶ð‘†ð‘¢ð‘“ð‘“     subscript  S    1..  i     subscript  T    1..  j        \mathit{LCSubstr}(S,T)=\max_{1\leq i\leq m,1\leq j\leq n}\mathit{LCSuff}(S_{1.%
 .i},T_{1..j})\;     This can be extended to more than two strings by adding more dimensions to the table.  Pseudocode  The following pseudocode finds the set of longest common substrings between two strings with dynamic programming:  function LCSubstr(S[1..m],Â T[1..n])  LÂ := array (1..m,Â 1..n)  zÂ :=Â 0  retÂ :=Â {}   for iÂ :=Â 1..m   for jÂ :=Â 1..n   if S[i]Â ==Â T[j]   if iÂ ==Â 1Â orÂ jÂ ==Â 1  L[i,j]Â :=Â 1   else  L[i,j]Â :=Â L[i-1,j-1]Â +Â 1   if L[i,j]Â >Â z  zÂ :=Â L[i,j]  retÂ :=Â {S[i-z+1..i]}   else   if L[i,j]Â ==Â z  retÂ :=Â retÂ âˆªÂ {S[i-z+1..i]}   else   L[i,j]Â :=Â 0   return ret  This algorithm runs in    O   (   n  m   )       O    n  m     O(nm)   time. The variable z is used to hold the length of the longest common substring found so far. The set ret is used to hold the set of strings which are of length z . The set ret can be saved efficiently by just storing the index i , which is the last character of the longest common substring (of size z) instead of S[i-z+1..i] . Thus all the longest common substrings would be, for each i in ret , S[(ret[i]-z)..(ret[i])] .  The following tricks can be used to reduce the memory usage of an implementation:   Keep only the last and current row of the DP table to save memory (    O   (   min   (  m  ,  n  )    )       O    m  n     O(\min(m,n))   instead of    O   (   n  m   )       O    n  m     O(nm)   )  Store only non-zero values in the rows. This can be done using hash tables instead of arrays. This is useful for large alphabets.   See also   Longest palindromic substring   References    External links   Dictionary of Algorithms and Data Structures: longest common substring  [ http://metacpan.org/module/String ::LCSS_XS Perl/XS implementation of the dynamic programming algorithm]  [ http://metacpan.org/module/Tree ::Suffix Perl/XS implementation of the suffix tree algorithm]  Dynamic programming implementations in various languages on wikibooks  working AS3 implementation of the dynamic programming algorithm  Suffix Tree based C implementation of Longest common substring for two strings   "  Category:Problems on strings  Category:Dynamic programming     â†©     