<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="491">Matroid oracle</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Matroid oracle</h1>
<hr/>

<p>In mathematics and computer science, a <strong>matroid oracle</strong> is a <a class="uri" href="subroutine" title="wikilink">subroutine</a> through which an <a class="uri" href="algorithm" title="wikilink">algorithm</a> may access a <a class="uri" href="matroid" title="wikilink">matroid</a>, an abstract combinatorial structure that can be used to describe the <a href="Linear_independence" title="wikilink">linear dependencies</a> between vectors in a <a href="vector_space" title="wikilink">vector space</a> or the <a href="spanning_tree" title="wikilink">spanning trees</a> of a <a href="undirected_graph" title="wikilink">graph</a>, among other applications.</p>

<p>The most commonly used oracle of this type is an independence oracle, a subroutine for testing whether a set of matroid elements is independent. Several other types of oracle have also been used; some of them have been shown to be weaker than independence oracles, some stronger, and some equivalent in computational power.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Many <a href="algorithm" title="wikilink">algorithms</a> that perform computations on matroids have been designed to take an oracle as input, allowing them to run efficiently without change on many different kinds of matroids, and without additional assumptions about what kind of matroid they are using. For instance, given an independence oracle for any matroid, it is possible to find the minimum weight basis of the matroid by applying a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> that adds elements to the basis in sorted order by weight, using the independence oracle to test whether each element can be added.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the <a href="Oracle_machine" title="wikilink">oracle model</a> has led to unconditional <a href="lower_bound" title="wikilink">lower bounds</a> proving that certain matroid problems cannot be solved in polynomial time, without invoking unproved assumptions such as the assumption that <a href="P_versus_NP_problem" title="wikilink">P ≠ NP</a>. Problems that have been shown to be hard in this way include testing whether a matroid is <a href="binary_matroid" title="wikilink">binary</a> or <a href="uniform_matroid" title="wikilink">uniform</a>, or testing whether it contains certain fixed <a href="matroid_minor" title="wikilink">minors</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="why-oracles">Why oracles?</h2>

<p>Although some authors have experimented with computer representations of matroids that explicitly list all independent sets or all basis sets of the matroid,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> these representations are not <em>succinct</em>: a matroid with 

<math display="inline" id="Matroid_oracle:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 elements may expand into a representation that takes space exponential in 

<math display="inline" id="Matroid_oracle:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

. Indeed, the number of distinct matroids on 

<math display="inline" id="Matroid_oracle:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 elements grows <a href="double_exponential_function" title="wikilink">doubly exponentially</a> as</p>

<p>

<math display="block" id="Matroid_oracle:3">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>n</mi>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>3</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>o</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">3</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>o</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2^{n}n^{-3/2+o(1)}}
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> from which it follows that any explicit representation capable of handling all possible matroids would necessarily use exponential space.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Instead, different types of matroids may be represented more efficiently from the other structures from which they are defined: <a href="uniform_matroid" title="wikilink">uniform matroids</a> from their two numeric parameters, <a href="graphic_matroid" title="wikilink">graphic matroids</a>, <a href="bicircular_matroid" title="wikilink">bicircular matroids</a>, and <a href="gammoid" title="wikilink">gammoids</a> from graphs, <a href="linear_matroid" title="wikilink">linear matroids</a> from <a href="matrix_(mathematics)" title="wikilink">matrices</a>, etc. However, an algorithm for performing computations on arbitrary matroids needs a uniform method of accessing its argument, rather than having to be redesigned for each of these matroid classes. The oracle model provides a convenient way of codifying and classifying the kinds of access that an algorithm might need.</p>
<h2 id="history">History</h2>

<p>Starting with , "independence functions" or "

<math display="inline" id="Matroid_oracle:4">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle I
  </annotation>
 </semantics>
</math>

-functions" have been studied as one of many equivalent ways of axiomatizing matroids. An independence function maps a set of matroid elements to the number 

<math display="inline" id="Matroid_oracle:5">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 1
  </annotation>
 </semantics>
</math>

 if the set is independent or 

<math display="inline" id="Matroid_oracle:6">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 0
  </annotation>
 </semantics>
</math>

 if it is dependent; that is, it is the <a href="indicator_function" title="wikilink">indicator function</a> of the family of independent sets, essentially the same thing as an independence oracle.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Matroid oracles have also been part of the earliest algorithmic work on matroids. Thus, , in studying matroid partition problems, assumed that the access to the given matroid was through a subroutine that takes as input an independent set 

<math display="inline" id="Matroid_oracle:7">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle I
  </annotation>
 </semantics>
</math>

 and an element 

<math display="inline" id="Matroid_oracle:8">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x
  </annotation>
 </semantics>
</math>

, and either returns a circuit in 

<math display="inline" id="Matroid_oracle:9">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>I</ci>
    <set>
     <ci>x</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle I\cup\{x\}
  </annotation>
 </semantics>
</math>

 (necessarily unique and containing 

<math display="inline" id="Matroid_oracle:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x
  </annotation>
 </semantics>
</math>

, if it exists) or determines that no such circuit exists.  used a subroutine that tests whether a given set is independent (that is, in more modern terminology, an independence oracle), and observed that the information it provides is sufficient to find the minimum weight basis in polynomial time.</p>

<p>Beginning from the work of  and , researchers began studying oracles from the point of view of proving lower bounds on algorithms for matroids and related structures. These two papers by Hausmann and Korte both concerned the problem of finding a maximum cardinality independent set, which is easy for matroids but (as they showed) harder to approximate or compute exactly for more general <a href="independence_system" title="wikilink">independence systems</a> represented by an independence oracle. This work kicked off a flurry of papers in the late 1970s and early 1980s showing similar hardness results for problems on matroids<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and comparing the power of different kinds of matroid oracles.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Since that time, the independence oracle has become standard for most research on matroid algorithms.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> There has also been continued research on lower bounds,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and comparisons of different types of oracle.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="types-of-oracles">Types of oracles</h2>

<p>The following types of matroid oracles have been considered.</p>
<ul>
<li>An <strong>independence oracle</strong> takes as its input a set of matroid elements, and returns as output a <a href="Boolean_value" title="wikilink">Boolean value</a>, true if the given set is independent and false otherwise.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> It may be implemented easily based on the underlying structure from which the matroid was defined for <a href="graphic_matroid" title="wikilink">graphic matroids</a>, <a href="transversal_matroid" title="wikilink">transversal matroids</a>, <a href="gammoid" title="wikilink">gammoids</a>, and linear matroids, and for matroids formed from these by standard operations such as direct sums.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></li>
<li>The oracle from  takes as input an independent set and an additional element, and either determines that their union is independent or finds a circuit in the union and returns it.</li>
<li>A <strong>rank oracle</strong> takes as its input a set of matroid elements, and returns as its output a numerical value, the <a href="Matroid_rank" title="wikilink">rank</a> of the given set.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
<li>A <strong>basis oracle</strong> takes as its input a set of matroid elements, and returns as output a Boolean value, true if the given set is a basis and false otherwise.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
<li>A <strong>circuit oracle</strong> takes as its input a set of matroid elements, and returns as output a Boolean value, true if the given set is a circuit and false otherwise.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></li>
<li>Three types of <strong>closure oracle</strong> have been considered: one that tests if a given element belongs to the closure of a given set, a second one that returns the closure of the set, and a third one that tests whether a given set is closed.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></li>
<li>A <strong>spanning oracle</strong> takes as its input a set of matroid elements, and returns as output a Boolean value, true if the given set is spanning (i.e. contains a basis and has the same rank as the whole matroid) and false otherwise.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></li>
<li>A <strong>girth oracle</strong> takes as its input a set of matroid elements, and returns as its output a numerical value, the size of the smallest circuit within that set (or 

<math display="inline" id="Matroid_oracle:11">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle+\infty
  </annotation>
 </semantics>
</math>

 if the given set is independent).<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li>A <strong>port oracle</strong> for a fixed element 

<math display="inline" id="Matroid_oracle:12">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x
  </annotation>
 </semantics>
</math>

 of the matroid takes as its input a set of matroid elements, and returns as output a Boolean value, true if the given set contains a circuit that includes 

<math display="inline" id="Matroid_oracle:13">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle x
  </annotation>
 </semantics>
</math>

 and false otherwise.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
</ul>
<h2 id="relative-power-of-different-oracles">Relative power of different oracles</h2>

<p>Although there are many known types of oracles, the choice of which to use can be simplified, because many of them are equivalent in computational power. An oracle 

<math display="inline" id="Matroid_oracle:14">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X
  </annotation>
 </semantics>
</math>

 is said to be <em>polynomially reducible</em> to another oracle 

<math display="inline" id="Matroid_oracle:15">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Y
  </annotation>
 </semantics>
</math>

 if any call to 

<math display="inline" id="Matroid_oracle:16">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X
  </annotation>
 </semantics>
</math>

 may be simulated by an algorithm that accesses the matroid using only oracle 

<math display="inline" id="Matroid_oracle:17">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Y
  </annotation>
 </semantics>
</math>

 and takes <a href="polynomial_time" title="wikilink">polynomial time</a> as measured in terms of the number of elements of the matroid; in complexity-theoretic terms, this is a <a href="Turing_reduction" title="wikilink">Turing reduction</a>. Two oracles are said to be <em>polynomially equivalent</em> if they are polynomially reducible to each other. If 

<math display="inline" id="Matroid_oracle:18">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Matroid_oracle:19">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Y
  </annotation>
 </semantics>
</math>

 are polynomially equivalent, then every result that proves the existence or nonexistence of a polynomial time algorithm for a matroid problem using oracle 

<math display="inline" id="Matroid_oracle:20">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X
  </annotation>
 </semantics>
</math>

 also proves the same thing for oracle 

<math display="inline" id="Matroid_oracle:21">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Y
  </annotation>
 </semantics>
</math>

.</p>

<p>For instance, the independence oracle is polynomially equivalent to the circuit-finding oracle of . If a circuit-finding oracle is available, a set may be tested for independence using at most 

<math display="inline" id="Matroid_oracle:22">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 calls to the oracle by starting from an <a href="empty_set" title="wikilink">empty set</a>, adding elements of the given set one element at a time, and using the circuit-finding oracle to test whether each addition preserves the independence of the set that has been constructed so far. In the other direction, if an independence oracle is available, the circuit in a set 

<math display="inline" id="Matroid_oracle:23">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>I</ci>
    <set>
     <ci>x</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle I\cup\{x\}
  </annotation>
 </semantics>
</math>

 may be found using at most 

<math display="inline" id="Matroid_oracle:24">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 calls to the oracle by testing, for each element 

<math display="inline" id="Matroid_oracle:25">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle y\in I
  </annotation>
 </semantics>
</math>

, whether 

<math display="inline" id="Matroid_oracle:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mo>∖</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>y</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <setdiff></setdiff>
     <ci>I</ci>
     <set>
      <ci>y</ci>
     </set>
    </apply>
    <set>
     <ci>x</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle I\setminus\{y\}\cup\{x\}
  </annotation>
 </semantics>
</math>

 is independent and returning the elements for which the answer is no. The independence oracle is also polynomially equivalent to the rank oracle, the spanning oracle, the first two types of closure oracle, and the port oracle.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>The basis oracle, the circuit oracle, and the oracle that tests whether a given set is closed are all weaker than the independence oracle: they can be simulated in polynomial time by an algorithm that accesses the matroid using an independence oracle, but not vice versa. Additionally, none of these three oracles can simulate each other within polynomial time. The girth oracle is stronger than the independence oracle, in the same sense.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>As well as polynomial time Turing reductions, other types of reducibility have been considered as well. In particular,  showed that, in <a href="parallel_algorithm" title="wikilink">parallel algorithms</a>, the rank and independence oracles are significantly different in computational power. The rank oracle allows the construction of a minimum weight basis by 

<math display="inline" id="Matroid_oracle:27">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 simultaneous queries, of the prefixes of the sorted order of the matroid elements: an element belongs to the optimal basis if and only if the rank of its prefix differs from the rank of the previous prefix. In contrast, finding a minimum basis with an independence oracle is much slower: it can be solved deterministically in 

<math display="inline" id="Matroid_oracle:28">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>n</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle O(\sqrt{n})
  </annotation>
 </semantics>
</math>

 time steps, and there is a lower bound of 

<math display="inline" id="Matroid_oracle:29">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mrow>
        <mi>log</mi>
        <mi>n</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\Omega((n/\log n)^{1/3})
  </annotation>
 </semantics>
</math>

 even for randomized parallel algorithms.</p>
<h2 id="algorithms">Algorithms</h2>

<p>Many problems on matroids are known to be solvable in <a href="polynomial_time" title="wikilink">polynomial time</a>, by algorithms that access the matroid only through an independence oracle or another oracle of equivalent power, without need of any additional assumptions about what kind of matroid has been given to them. These polynomially-solvable problems include:</p>
<ul>
<li>Finding a minimum or maximum weight basis of a <a href="weighted_matroid" title="wikilink">weighted matroid</a>, using a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></li>
<li>Partitioning the elements of a matroid into a minimum number of independent sets, and finding the largest set that is simultaneously independent in two given matroids. The latter problem is called <a href="matroid_intersection" title="wikilink">matroid intersection</a>, and the solutions to both problems are closely related to each other.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></li>
<li>Testing whether a matroid is 

<math display="inline" id="Matroid_oracle:30">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle k
  </annotation>
 </semantics>
</math>

-connected (in the sense of ) for 

<math display="inline" id="Matroid_oracle:31">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle k\leq 3
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></li>
<li>Testing whether a given matroid is <a href="graphic_matroid" title="wikilink">graphic</a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> or <a href="regular_matroid" title="wikilink">regular</a>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></li>
<li>Finding an <a href="ear_decomposition" title="wikilink">ear decomposition</a> of a given matroid, a sequence of circuits whose union is the matroid and in which each circuit remains a circuit after all previous circuits in the sequence are contracted. Such a decomposition may also be found with the additional property that a chosen matroid element belongs to every circuit.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></li>
<li>Finding a <a class="uri" href="branch-decomposition" title="wikilink">branch-decomposition</a> of a given matroid, whenever its branch-width is no more than a fixed constant.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></li>
<li>Listing all of the bases, flats, or circuits of a matroid, in polynomial time per output set.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></li>
<li>Approximating the number of bases by a <a href="Polynomial-time_approximation_scheme" title="wikilink">fully polynomial-time randomized approximation scheme</a>, for a matroid with 

<math display="inline" id="Matroid_oracle:32">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 elements and rank 

<math display="inline" id="Matroid_oracle:33">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle r
  </annotation>
 </semantics>
</math>

, with the additional assumption that the number of bases is within a polynomial factor of the number of 

<math display="inline" id="Matroid_oracle:34">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle r
  </annotation>
 </semantics>
</math>

-element sets.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></li>
</ul>
<h2 id="impossibility-proofs">Impossibility proofs</h2>

<p>For many matroid problems, it is possible to show that an independence oracle does not provide enough power to allow the problem to be solved in polynomial time. The main idea of these proofs is to find two matroids 

<math display="inline" id="Matroid_oracle:35">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Matroid_oracle:36">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M^{\prime}
  </annotation>
 </semantics>
</math>

 on which the answer to the problem differs and which are difficult for an algorithm to tell apart. In particular, if 

<math display="inline" id="Matroid_oracle:37">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 has a high degree of symmetry, and differs from 

<math display="inline" id="Matroid_oracle:38">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M^{\prime}
  </annotation>
 </semantics>
</math>

 only in the answers to a small number of queries, then it may take a very large number of queries for an algorithm to be sure of distinguishing an input of type 

<math display="inline" id="Matroid_oracle:39">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 from an input formed by using one of the symmetries of 

<math display="inline" id="Matroid_oracle:40">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 to permute 

<math display="inline" id="Matroid_oracle:41">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M^{\prime}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>A simple example of this approach can be used to show that it is difficult to test whether a matroid is <a href="uniform_matroid" title="wikilink">uniform</a>. For simplicity of exposition, let 

<math display="inline" id="Matroid_oracle:42">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 be even, let 

<math display="inline" id="Matroid_oracle:43">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 be the uniform matroid 

<math display="inline" id="Matroid_oracle:44">
 <semantics>
  <mrow>
   <mi>U</mi>
   <msubsup>
    <mi></mi>
    <mi>n</mi>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">U</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle U{}^{n/2}_{n}
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Matroid_oracle:45">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M^{\prime}
  </annotation>
 </semantics>
</math>

 be a matroid formed from 

<math display="inline" id="Matroid_oracle:46">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 by making a single one of the 

<math display="inline" id="Matroid_oracle:47">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n/2
  </annotation>
 </semantics>
</math>

-element basis sets of 

<math display="inline" id="Matroid_oracle:48">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 dependent instead of independent. In order for an algorithm to correctly test whether its input is uniform, it must be able to distinguish 

<math display="inline" id="Matroid_oracle:49">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 from every possible permutation of 

<math display="inline" id="Matroid_oracle:50">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M^{\prime}
  </annotation>
 </semantics>
</math>

. But in order for a deterministic algorithm to do so, it must test every one of the 

<math display="inline" id="Matroid_oracle:51">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n/2
  </annotation>
 </semantics>
</math>

-element subsets of the elements: if it missed one set, it could be fooled by an oracle that chose that same set as the one to make dependent. Therefore, testing for whether a matroid is uniform may require</p>

<p>

<math display="block" id="Matroid_oracle:52">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
      <msqrt>
       <mi>n</mi>
      </msqrt>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>n</ci>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Ω</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{n}\atop{n/2}}\right)}=\Omega\left(\frac{2^{n}}{\sqrt{n}}\right)
  </annotation>
 </semantics>
</math>

 independence queries, much higher than polynomial. Even a randomized algorithm must make nearly as many queries in order to be confident of distinguishing these two matroids.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a>  formalize this approach by proving that, whenever there exist two matroids 

<math display="inline" id="Matroid_oracle:53">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Matroid_oracle:54">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M^{\prime}
  </annotation>
 </semantics>
</math>

 on the same set of elements but with differing problem answers, an algorithm that correctly solves the given problem on those elements must use at least</p>

<p>

<math display="block" id="Matroid_oracle:55">
 <semantics>
  <mfrac>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo>aut</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo>fix</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo>,</mo>
       <msub>
        <mi>Q</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <abs></abs>
     <apply>
      <ci>aut</ci>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <ci>fix</ci>
       <ci>M</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{|\operatorname{aut}(M)|}{\sum_{i}|\operatorname{fix}(M,Q_{i})|}
  </annotation>
 </semantics>
</math>

 queries, where 

<math display="inline" id="Matroid_oracle:56">
 <semantics>
  <mrow>
   <mo>aut</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>aut</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\operatorname{aut}(M)
  </annotation>
 </semantics>
</math>

 denotes the <a href="automorphism_group" title="wikilink">automorphism group</a> of 

<math display="inline" id="Matroid_oracle:57">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Matroid_oracle:58">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Q_{i}
  </annotation>
 </semantics>
</math>

 denotes the family of sets whose independence differs from 

<math display="inline" id="Matroid_oracle:59">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Matroid_oracle:60">
 <semantics>
  <msup>
   <mi>M</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M^{\prime}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Matroid_oracle:61">
 <semantics>
  <mrow>
   <mo>fix</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <msub>
     <mi>Q</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>fix</ci>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\operatorname{fix}(M,Q_{i})
  </annotation>
 </semantics>
</math>

 denotes the subgroup of automorphisms that maps 

<math display="inline" id="Matroid_oracle:62">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Q_{i}
  </annotation>
 </semantics>
</math>

 to itself. For instance, the automorphism group of the uniform matroid is just the <a href="symmetric_group" title="wikilink">symmetric group</a>, with size 

<math display="inline" id="Matroid_oracle:63">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <factorial></factorial>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n!
  </annotation>
 </semantics>
</math>

, and in the problem of testing uniform matroids there was only one set 

<math display="inline" id="Matroid_oracle:64">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Q_{i}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Matroid_oracle:65">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo>fix</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <msub>
       <mi>Q</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <ci>fix</ci>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <factorial></factorial>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle|\operatorname{fix}(M,Q_{i})|=(n/2)!^{2}
  </annotation>
 </semantics>
</math>

, smaller by an exponential factor than 

<math display="inline" id="Matroid_oracle:66">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <factorial></factorial>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n!
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>Problems that have been proven to be impossible for a matroid oracle algorithm to compute in polynomial time include:</p>
<ul>
<li>Testing whether a given matroid is uniform.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></li>
<li>Testing whether a given matroid contains a fixed matroid 

<math display="inline" id="Matroid_oracle:67">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle H
  </annotation>
 </semantics>
</math>

 as a minor, except in the special cases that 

<math display="inline" id="Matroid_oracle:68">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle H
  </annotation>
 </semantics>
</math>

 is uniform with rank or corank at most one. More generally, if 

<math display="inline" id="Matroid_oracle:69">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathcal{H}
  </annotation>
 </semantics>
</math>

 is a fixed finite set of matroids, and there is no uniform matroid in 

<math display="inline" id="Matroid_oracle:70">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathcal{H}
  </annotation>
 </semantics>
</math>

, then it is not possible to test in polynomial time whether a given matroid contains one or more of the matroids in 

<math display="inline" id="Matroid_oracle:71">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathcal{H}
  </annotation>
 </semantics>
</math>

 as a minor.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></li>
<li>Testing whether a given matroid is <a href="binary_matroid" title="wikilink">binary</a>, is representable over any particular fixed <a href="field_(mathematics)" title="wikilink">field</a>, or whether there exists a field over which it is representable.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></li>
<li>Solving the matroid matching problem, in which the input is a graph and a matroid on its vertices, and the goal is to find a <a href="Matching_(graph_theory)" title="wikilink">matching</a> in the graph that is as large as possible, subject to the constraint that the matched vertices form an independent set.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></li>
<li>Testing whether a given matroid is <a href="dual_matroid" title="wikilink">self-dual</a>, <a href="transversal_matroid" title="wikilink">transversal</a>, <a href="bipartite_matroid" title="wikilink">bipartite</a>, <a href="Eulerian_matroid" title="wikilink">Eulerian</a>, or <a href="oriented_matroid" title="wikilink">orientable</a>.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></li>
<li>Computing the girth (size of the smallest circuit), size of the largest circuit, number of circuits, number of bases, number of flats, number of maximum-rank flats, size of the largest flat, <a href="Tutte_polynomial" title="wikilink">Tutte polynomial</a>, or connectivity of a given matroid.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></li>
</ul>

<p>Among the set of all properties of 

<math display="inline" id="Matroid_oracle:72">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

-element matroids, the fraction of the properties that do not require exponential time to test goes to zero, in the limit, as 

<math display="inline" id="Matroid_oracle:73">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 goes to infinity.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Black_box_group" title="wikilink">Black box group</a>, an oracle-like model for <a href="group_theory" title="wikilink">group theory</a></li>
<li><a href="Implicit_graph" title="wikilink">Implicit graph</a>, an oracle-like model for graph algorithms</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Matroid_theory" title="wikilink">Category:Matroid theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">; ; .<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">; ; ; .<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">For additional research on matroids based on the independence function axiomatization, see e.g. , , and .<a href="#fnref7">↩</a></li>
<li id="fn8">; ; ; ; .<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10">E.g. see ,  , , , and .<a href="#fnref10">↩</a></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12">; .<a href="#fnref12">↩</a></li>
<li id="fn13">; ; .<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">; .<a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21">.<a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25">; .<a href="#fnref25">↩</a></li>
<li id="fn26">. A paper claiming a similar result for any fixed constant 

<math display="inline" id="Matroid_oracle:74">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle k
  </annotation>
 </semantics>
</math>

 was announced by Cunningham and Edmonds at roughly the same time, but appears not to have been published. , pp. 186–187, writes "Locating 

<math display="inline" id="Matroid_oracle:75">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle k
  </annotation>
 </semantics>
</math>

-sums for general 

<math display="inline" id="Matroid_oracle:76">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≥</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle k\geq 4
  </annotation>
 </semantics>
</math>

 is much more diﬃcult ... We do not know how this can be eﬃciently accomplished for binary matroids, let alone for general matroids."<a href="#fnref26">↩</a></li>
<li id="fn27">.<a href="#fnref27">↩</a></li>
<li id="fn28">.<a href="#fnref28">↩</a></li>
<li id="fn29"></li>
<li id="fn30">.<a href="#fnref30">↩</a></li>
<li id="fn31">.<a href="#fnref31">↩</a></li>
<li id="fn32">. In contrast, it is not possible for deterministic algorithms to approximate the number of bases of a matroid accurately in polynomial time .<a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34">; .<a href="#fnref34">↩</a></li>
<li id="fn35">As well as being in , this formalization is surveyed in . In most of the applications of this technique in , 

<math display="inline" id="Matroid_oracle:77">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle M
  </annotation>
 </semantics>
</math>

 is uniform, but  applies the same idea to a non-uniform but highly symmetric matroid.<a href="#fnref35">↩</a></li>
<li id="fn36"></li>
<li id="fn37">. Results of  and  give special cases of this for the problems of finding a 

<math display="inline" id="Matroid_oracle:78">
 <semantics>
  <mrow>
   <mi>U</mi>
   <msubsup>
    <mi></mi>
    <mn>4</mn>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">U</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <cn type="integer">4</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle U{}^{2}_{4}
  </annotation>
 </semantics>
</math>

 minor and a <a href="Vamos_matroid" title="wikilink">Vamos matroid</a> minor, respectively. Testing whether a matroid is graphic or regular may be expressed in terms of a finite set of forbidden minors, and may be solved in polynomial time, but the forbidden minors for these problems include the uniform matroid 

<math display="inline" id="Matroid_oracle:79">
 <semantics>
  <mrow>
   <mi>U</mi>
   <msubsup>
    <mi></mi>
    <mn>4</mn>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">U</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <cn type="integer">4</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle U{}^{2}_{4}
  </annotation>
 </semantics>
</math>

, so they do not contradict this impossibility result.<a href="#fnref37">↩</a></li>
<li id="fn38"> showed this for binary matroids,  for finite fields,  for arbitrary fields, and  for the existence of a field over which the matroid is representable.<a href="#fnref38">↩</a></li>
<li id="fn39">; . However, the special case of this problem for <a href="bipartite_graph" title="wikilink">bipartite graphs</a> can be solved in polynomial time as a <a href="matroid_intersection" title="wikilink">matroid intersection</a> problem.<a href="#fnref39">↩</a></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"></li>
</ol>
</section>
</body>
</html>
