<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="548">Weighted matroid</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Weighted matroid</h1>
<hr/>

<p>In <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>, a branch of <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>weighted matroid</strong> is a <a class="uri" href="matroid" title="wikilink">matroid</a> endowed with function with respect to which one can perform a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>.</p>

<p>A <em>weight function</em> <em>w</em> : <em>E</em> → <strong>R</strong><sup>+</sup> for a matroid <em>M</em>=(<em>E</em>, <em>I</em>) assigns a strictly positive weight to each element of <em>E</em>. We extend the function to subsets of <em>E</em> by summation; <em>w</em>(<em>A</em>) is the sum of <em>w</em>(<em>x</em>) over <em>x</em> in <em>A</em>. A matroid with an associated weight function is called a weighted matroid.</p>
<h2 id="spanning-forest-algorithms">Spanning forest algorithms</h2>

<p>As a simple example, say we wish to find the <a href="spanning_tree_(mathematics)" title="wikilink">maximum spanning forest</a> of a graph. That is, given a graph and a weight for each edge, find a forest containing every vertex and maximizing the total weight of the edges in the tree. This problem arises in some clustering applications. If we look at the definition of the forest matroid above, we see that the maximum spanning forest is simply the independent set with largest total weight — such a set must span the graph, for otherwise we can add edges without creating cycles. But how do we find it?</p>
<h3 id="finding-a-basis">Finding a basis</h3>

<p>There is a simple algorithm for finding a basis:</p>
<ul>
<li>Initially let A be the empty set.</li>
<li>For each <em>x</em> in <em>E</em>
<ul>
<li>if A U {x} is independent, then set A to A U {x}.</li>
</ul></li>
</ul>

<p>The result is clearly an independent set. It is a maximal independent set because if B U {x} is not independent for some subset B of A, then A U {x} is not independent either (the contrapositive follows from the <a href="hereditary_property_(matroid)" title="wikilink">hereditary property</a>). Thus if we pass up an element, we'll never have an opportunity to use it later. We will generalize this algorithm to solve a harder problem.</p>
<h3 id="extension-to-optimal">Extension to optimal</h3>

<p>An independent set of largest total weight is called an <em>optimal</em> set. Optimal sets are always bases, because if an edge can be added, it should be; this only increases the total weight. As it turns out, there is a trivial <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> for computing an optimal set of a weighted matroid. It works as follows:</p>
<ul>
<li>Initially let A be the empty set.</li>
<li>For each <em>x</em> in <em>E</em>, taken in (monotonically) decreasing order by weight
<ul>
<li>if A U {x} is independent, then set A to A U {x}.</li>
</ul></li>
</ul>

<p>This algorithm finds a basis, since it is a special case of the above algorithm. It always chooses the element of largest weight that it can while preserving independence (thus the term "greedy"). This always produces an optimal set: suppose that it produces 

<math display="inline" id="Weighted_matroid:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mi>r</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>r</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\{e_{1},e_{2},\ldots,e_{r}\}
  </annotation>
 </semantics>
</math>

 and that 

<math display="inline" id="Weighted_matroid:1">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>f</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>f</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>f</mi>
     <mi>r</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>r</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=\{f_{1},f_{2},\ldots,f_{r}\}
  </annotation>
 </semantics>
</math>

. Now for any 

<math display="inline" id="Weighted_matroid:2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Weighted_matroid:3">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>k</mi>
   <mo>≤</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq k\leq r
  </annotation>
 </semantics>
</math>

, consider open sets 

<math display="inline" id="Weighted_matroid:4">
 <semantics>
  <mrow>
   <msub>
    <mi>O</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{1}=\{e_{1},\ldots,e_{k-1}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Weighted_matroid:5">
 <semantics>
  <mrow>
   <msub>
    <mi>O</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>f</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>f</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>O</ci>
     <cn type="integer">2</cn>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{2}=\{f_{1},\ldots,f_{k}\}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Weighted_matroid:6">
 <semantics>
  <msub>
   <mi>O</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{1}
  </annotation>
 </semantics>
</math>

 is smaller than 

<math display="inline" id="Weighted_matroid:7">
 <semantics>
  <msub>
   <mi>O</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{2}
  </annotation>
 </semantics>
</math>

, there is some element of 

<math display="inline" id="Weighted_matroid:8">
 <semantics>
  <msub>
   <mi>O</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{2}
  </annotation>
 </semantics>
</math>

 which can be put into 

<math display="inline" id="Weighted_matroid:9">
 <semantics>
  <msub>
   <mi>O</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{1}
  </annotation>
 </semantics>
</math>

 with the result still being independent. However 

<math display="inline" id="Weighted_matroid:10">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{k}
  </annotation>
 </semantics>
</math>

 is an element of maximal weight that can be added to 

<math display="inline" id="Weighted_matroid:11">
 <semantics>
  <msub>
   <mi>O</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{1}
  </annotation>
 </semantics>
</math>

 to maintain independence. Thus 

<math display="inline" id="Weighted_matroid:12">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{k}
  </annotation>
 </semantics>
</math>

 is of no smaller weight than some element of 

<math display="inline" id="Weighted_matroid:13">
 <semantics>
  <msub>
   <mi>O</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{2}
  </annotation>
 </semantics>
</math>

, and hence 

<math display="inline" id="Weighted_matroid:14">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{k}
  </annotation>
 </semantics>
</math>

 is of at least a large a weight as 

<math display="inline" id="Weighted_matroid:15">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{k}
  </annotation>
 </semantics>
</math>

. As this is true for all 

<math display="inline" id="Weighted_matroid:16">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Weighted_matroid:17">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is weightier than 

<math display="inline" id="Weighted_matroid:18">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="complexity-analysis">Complexity analysis</h3>

<p>The easiest way to traverse the members of <em>E</em> in the desired order is to sort them. This requires O(|E|log|E|) time using a comparison <a href="sorting_algorithm" title="wikilink">sorting algorithm</a>. We also need to test for each <em>x</em> whether A U {x} is independent; assuming independence tests require O(f(|E|)) time, the total time for the algorithm is O(|E|log|E| + |E|f(|E|)).</p>

<p>If we want to find a minimum spanning tree instead, we simply "invert" the weight function by subtracting it from a large constant. More specifically, let <em>w</em><sub>min</sub>(<em>x</em>) = <em>W</em> - <em>w</em>(<em>x</em>), where <em>W</em> exceeds the total weight over all graph edges. Many more optimization problems about all sorts of matroids and weight functions can be solved in this trivial way, although in many cases more efficient algorithms can be found that exploit more specialized properties.</p>
<h3 id="matroid-requirement">Matroid requirement</h3>

<p>Note also that if we take a set 

<math display="inline" id="Weighted_matroid:19">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 of "independent" sets which is a down-set but not a matroid, then the greedy algorithm will not always work. For then there are independent sets 

<math display="inline" id="Weighted_matroid:20">
 <semantics>
  <msub>
   <mi>I</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Weighted_matroid:21">
 <semantics>
  <msub>
   <mi>I</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{2}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Weighted_matroid:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>I</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>I</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |I_{1}|<|I_{2}|
  </annotation>
 </semantics>
</math>

, but such that for no 

<math display="inline" id="Weighted_matroid:23">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>I</mi>
     <mn>2</mn>
    </msub>
    <mo>∖</mo>
    <msub>
     <mi>I</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>e</ci>
    <apply>
     <setdiff></setdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\in I_{2}\setminus I_{1}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Weighted_matroid:24">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>1</mn>
   </msub>
   <mo>∪</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{1}\cup e
  </annotation>
 </semantics>
</math>

 independent.</p>

<p>Pick an 

<math display="inline" id="Weighted_matroid:25">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Weighted_matroid:26">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>τ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau>0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Weighted_matroid:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mn>2</mn>
        <mi>ϵ</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <msub>
       <mi>I</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>E</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>I</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>ϵ</ci>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>τ</ci>
      <apply>
       <abs></abs>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1+2\epsilon)|I_{1}|+\tau|E|<|I_{2}|
  </annotation>
 </semantics>
</math>

. Weight the elements of 

<math display="inline" id="Weighted_matroid:28">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>1</mn>
   </msub>
   <mo>∪</mo>
   <msub>
    <mi>I</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{1}\cup I_{2}
  </annotation>
 </semantics>
</math>

 in the range 

<math display="inline" id="Weighted_matroid:29">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Weighted_matroid:30">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <mi>ϵ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2+2\epsilon
  </annotation>
 </semantics>
</math>

, the elements of 

<math display="inline" id="Weighted_matroid:31">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>1</mn>
   </msub>
   <mo>∖</mo>
   <msub>
    <mi>I</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{1}\setminus I_{2}
  </annotation>
 </semantics>
</math>

 in the range 

<math display="inline" id="Weighted_matroid:32">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\epsilon
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Weighted_matroid:33">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <mi>ϵ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+2\epsilon
  </annotation>
 </semantics>
</math>

, the elements of 

<math display="inline" id="Weighted_matroid:34">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>2</mn>
   </msub>
   <mo>∖</mo>
   <msub>
    <mi>I</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{2}\setminus I_{1}
  </annotation>
 </semantics>
</math>

 in the range 

<math display="inline" id="Weighted_matroid:35">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Weighted_matroid:36">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\epsilon
  </annotation>
 </semantics>
</math>

, and the rest in the range 

<math display="inline" id="Weighted_matroid:37">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 to 

<math display="inline" id="Weighted_matroid:38">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. The greedy algorithm will select the elements of 

<math display="inline" id="Weighted_matroid:39">
 <semantics>
  <msub>
   <mi>I</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{1}
  </annotation>
 </semantics>
</math>

, and then cannot pick any elements of 

<math display="inline" id="Weighted_matroid:40">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>2</mn>
   </msub>
   <mo>∖</mo>
   <msub>
    <mi>I</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{2}\setminus I_{1}
  </annotation>
 </semantics>
</math>

. Therefore the independent set it constructs will be of weight at most 

<math display="inline" id="Weighted_matroid:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <mi>ϵ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>I</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>E</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mn>1</mn>
     </msub>
     <mo>∪</mo>
     <msub>
      <mi>I</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ϵ</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>τ</ci>
     <apply>
      <abs></abs>
      <ci>E</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <union></union>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1+2\epsilon)|I_{1}|+\tau|E|+|I_{1}\cup I_{2}|
  </annotation>
 </semantics>
</math>

, which is smaller than the weight of 

<math display="inline" id="Weighted_matroid:42">
 <semantics>
  <msub>
   <mi>I</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{2}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="history">History</h2>

<p>It was not until 1971 that <a href="Jack_Edmonds" title="wikilink">Jack Edmonds</a> connected weighted matroids to greedy algorithms in his paper "Matroids and the greedy algorithm". Korte and Lovász would generalize these ideas to objects called <em><a href="greedoid" title="wikilink">greedoids</a></em>, which allow even larger classes of problems to be solved by greedy algorithms.</p>
<h2 id="references">References</h2>
<ul>
<li>Jack Edmonds. Matroids and the Greedy Algorithm. Mathematical Programming, volume 1, p. 125–136. 1971.</li>
</ul>

<p>"</p>

<p><a href="Category:Matroid_theory" title="wikilink">Category:Matroid theory</a></p>
</body>
</html>
