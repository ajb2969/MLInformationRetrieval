<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="224">Intuitionistic type theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Intuitionistic type theory</h1>
<hr/>

<p><strong>Intuitionistic type theory</strong> (also known as <strong>constructive type theory</strong>, or <strong>Martin-Löf type theory</strong>) is a <a href="type_theory" title="wikilink">type theory</a> and an alternative <a href="Foundations_of_mathematics" title="wikilink">foundation of mathematics</a> based on the principles of <a href="mathematical_constructivism" title="wikilink">mathematical constructivism</a>. Intuitionistic type theory was introduced by <a href="Per_Martin-Löf" title="wikilink">Per Martin-Löf</a>, a <a href="Sweden" title="wikilink">Swedish</a> <a class="uri" href="mathematician" title="wikilink">mathematician</a> and <a class="uri" href="philosopher" title="wikilink">philosopher</a>, in 1972. Martin-Löf has modified his proposal a few times; his 1971 <a class="uri" href="impredicative" title="wikilink">impredicative</a> formulation was inconsistent as demonstrated by <a href="Girard's_paradox" title="wikilink">Girard's paradox</a>. Later formulations were <a href="Predicativity" title="wikilink">predicative</a>. He proposed both <a href="Intensional_logic" title="wikilink">intensional</a> and <a href="extensionality" title="wikilink">extensional</a> variants of the theory.</p>

<p>Intuitionistic type theory is based on a certain analogy or isomorphism between <a href="proposition" title="wikilink">propositions</a> and <a href="Type_theory" title="wikilink">types</a>: a proposition is identified with the type of its proofs. This identification is usually called the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a>, which was originally formulated for <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a> and <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a>. Type theory extends this identification to <a href="predicate_logic" title="wikilink">predicate logic</a> by introducing <a href="dependent_types" title="wikilink">dependent types</a>, that is types which contain values.</p>

<p>Type theory internalizes the interpretation of <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a> proposed by <a href="Luitzen_Egbertus_Jan_Brouwer" title="wikilink">Brouwer</a>, <a href="Arend_Heyting" title="wikilink">Heyting</a> and <a href="Andrey_Kolmogorov" title="wikilink">Kolmogorov</a>, the so-called <a href="BHK_interpretation" title="wikilink">BHK interpretation</a>. The types in type theory play a similar role to sets in <a href="set_theory" title="wikilink">set theory</a> but functions definable in type theory are always computable.</p>
<h2 id="connectives-of-type-theory">Connectives of type theory</h2>

<p>In the context of type theory a <a href="Logical_connective" title="wikilink">connective</a> is a way of constructing types, possibly using already given types. The basic connectives of type theory are:</p>
<h3 id="π-types">Π-types</h3>

<p>Π-types, also called dependent product types, are analogous to the indexed <a href="Cartesian_product" title="wikilink">products</a> of sets. As such, they generalize the normal <a href="function_space" title="wikilink">function space</a> to model functions whose result type may vary on their input. E.g. writing 

<math display="inline" id="Intuitionistic_type_theory:0">
 <semantics>
  <mrow>
   <mo>Vec</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ℝ</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Vec</ci>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Vec}({\mathbb{R}},n)
  </annotation>
 </semantics>
</math>

 for the type of <a href="tuple" title="wikilink"><em>n</em>-tuples</a> of <a href="real_numbers" title="wikilink">real numbers</a> and 

<math display="inline" id="Intuitionistic_type_theory:1">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

 for the type of <a href="natural_number" title="wikilink">natural numbers</a>,</p>

<p>

<math display="block" id="Intuitionistic_type_theory:2">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>n</mi>
      <mo separator="true">,</mo>
      <mi>ℕ</mi>
     </mrow>
    </mrow>
   </munder>
   <mrow>
    <mo>Vec</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ℝ</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <ci>normal-:</ci>
      <ci>n</ci>
      <ci>ℕ</ci>
     </apply>
    </apply>
    <apply>
     <ci>Vec</ci>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{n\mathbin{:}{\mathbb{N}}}\operatorname{Vec}({\mathbb{R}},n)
  </annotation>
 </semantics>
</math>

</p>

<p>stands for the type of a function that, given a natural number <em>n</em>, returns an <em>n</em>-tuple of real numbers. The usual function space arises as a special case when the range type does not actually depend on the input, e.g., 

<math display="inline" id="Intuitionistic_type_theory:3">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>n</mi>
      <mo separator="true">,</mo>
      <mi>ℕ</mi>
     </mrow>
    </mrow>
   </msub>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <ci>normal-:</ci>
      <ci>n</ci>
      <ci>ℕ</ci>
     </apply>
    </apply>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{n\mathbin{:}{\mathbb{N}}}{\mathbb{R}}
  </annotation>
 </semantics>
</math>


 is the type of functions from natural numbers to the real numbers, which is also written as 

<math display="inline" id="Intuitionistic_type_theory:4">
 <semantics>
  <mrow>
   <mi>ℕ</mi>
   <mo>→</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ℕ</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbb{N}}\to{\mathbb{R}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Using the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a> Π-types also serve to model <a href="material_conditional" title="wikilink">implication</a> and <a href="universal_quantification" title="wikilink">universal quantification</a>: e.g., a term inhabiting</p>

<p>

<math display="block" id="Intuitionistic_type_theory:5">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>m</mi>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">:</mi>
      <mrow>
       <mi>n</mi>
       <mo separator="true">,</mo>
       <mi>ℕ</mi>
      </mrow>
     </mrow>
    </mrow>
   </munder>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>+</mo>
    <mi>n</mi>
    <mo>=</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <list>
      <ci>m</ci>
      <apply>
       <ci>normal-:</ci>
       <ci>n</ci>
       <ci>ℕ</ci>
      </apply>
     </list>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <plus></plus>
     <csymbol cd="unknown">n</csymbol>
     <eq></eq>
     <csymbol cd="unknown">n</csymbol>
     <plus></plus>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{m,n\mathbin{:}{\mathbb{N}}}(m+n=n+m)
  </annotation>
 </semantics>
</math>

</p>

<p>is a function which assigns to any pair of natural numbers a proof that addition is <a class="uri" href="commutative" title="wikilink">commutative</a> for that pair and hence can be considered as a proof that addition is commutative for all natural numbers. (Here we have used the <em>equality type</em> (

<math display="inline" id="Intuitionistic_type_theory:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y
  </annotation>
 </semantics>
</math>

) as explained below.)</p>
<h3 id="σ-types">Σ-types</h3>

<p>Σ-types, also called dependent sum types, are analogous to the indexed <a href="disjoint_union" title="wikilink">disjoint unions</a> of sets. As such, they generalize the usual <a href="Cartesian_product" title="wikilink">Cartesian product</a> to model pairs where the type of the second component depends on the first. For example, the type 

<math display="inline" id="Intuitionistic_type_theory:7">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>n</mi>
      <mo separator="true">,</mo>
      <mi>ℕ</mi>
     </mrow>
    </mrow>
   </msub>
   <mrow>
    <mo>Vec</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ℝ</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <ci>normal-:</ci>
      <ci>n</ci>
      <ci>ℕ</ci>
     </apply>
    </apply>
    <apply>
     <ci>Vec</ci>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n\mathbin{:}{\mathbb{N}}}\operatorname{Vec}({\mathbb{R}},n)
  </annotation>
 </semantics>
</math>

 stands for the type of pairs of a natural number 

<math display="inline" id="Intuitionistic_type_theory:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 and an 

<math display="inline" id="Intuitionistic_type_theory:9">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-tuple of real numbers, i.e., this type can be used to model sequences of arbitrary but finite length (usually called lists). The conventional <a href="Cartesian_product" title="wikilink">Cartesian product</a> type arises as a special case when the type of the second component doesn't actually depend on the first, e.g., 

<math display="inline" id="Intuitionistic_type_theory:10">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>n</mi>
      <mo separator="true">,</mo>
      <mi>ℕ</mi>
     </mrow>
    </mrow>
   </msub>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <ci>normal-:</ci>
      <ci>n</ci>
      <ci>ℕ</ci>
     </apply>
    </apply>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n\mathbin{:}{\mathbb{N}}}{\mathbb{R}}
  </annotation>
 </semantics>
</math>

 is the type of pairs of a <a href="natural_number" title="wikilink">natural number</a> and a <a href="real_number" title="wikilink">real number</a>, which is also written as 

<math display="inline" id="Intuitionistic_type_theory:11">
 <semantics>
  <mrow>
   <mi>ℕ</mi>
   <mo>×</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℕ</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbb{N}}\times{\mathbb{R}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Again, using the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a>, Σ-types also serve to model <a href="Logical_conjunction" title="wikilink">conjunction</a> and <a href="existential_quantification" title="wikilink">existential quantification</a>.</p>
<h3 id="finite-types">Finite types</h3>

<p>Of special importance are <strong>0</strong> or ⊥ (the <a href="empty_type" title="wikilink">empty type</a>), <strong>1</strong> or ⊤ (the <a href="unit_type" title="wikilink">unit type</a>) and <strong>2</strong> (the type of <a href="Boolean_data_type" title="wikilink">Booleans</a> or classical <a href="truth_value" title="wikilink">truth values</a>). Invoking the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a> again, ⊥ stands for <em>false</em> and ⊤ for <em>true</em>.</p>

<p>Using finite types we can define <a class="uri" href="negation" title="wikilink">negation</a> as</p>

<p>

<math display="block" id="Intuitionistic_type_theory:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo>≡</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mo>⊥</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">bottom</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A\equiv A\to\bot.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="equality-type">Equality type</h3>

<p>Given 

<math display="inline" id="Intuitionistic_type_theory:13">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>b</mi>
     <mo separator="true">,</mo>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <apply>
     <ci>normal-:</ci>
     <ci>b</ci>
     <ci>A</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b\mathbin{:}A
  </annotation>
 </semantics>
</math>


, the expression 

<math display="inline" id="Intuitionistic_type_theory:14">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=b
  </annotation>
 </semantics>
</math>

 denotes the type of equality proofs for 

<math display="inline" id="Intuitionistic_type_theory:15">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is equal to 

<math display="inline" id="Intuitionistic_type_theory:16">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. That is, if 

<math display="inline" id="Intuitionistic_type_theory:17">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=b
  </annotation>
 </semantics>
</math>

 is inhabited, then 

<math display="inline" id="Intuitionistic_type_theory:18">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>


 is said to be <em>equal</em> to 

<math display="inline" id="Intuitionistic_type_theory:19">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. There is only one (canonical) inhabitant of 

<math display="inline" id="Intuitionistic_type_theory:20">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=a
  </annotation>
 </semantics>
</math>

 and this is the proof of reflexivity</p>

<p>

<math display="block" id="Intuitionistic_type_theory:21">
 <semantics>
  <mrow>
   <mo>refl</mo>
   <mi mathvariant="normal">:</mi>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>a</mi>
      <mo separator="true">,</mo>
      <mi>A</mi>
     </mrow>
    </mrow>
   </munder>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>=</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>refl</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <ci>normal-:</ci>
      <ci>a</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <eq></eq>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{refl}\mathbin{:}\prod_{a\mathbin{:}A}(a=a).
  </annotation>
 </semantics>
</math>

</p>

<p>Examination of the properties of the equality type, or rather, extending it to a notion of equivalence, lead to <a href="homotopy_type_theory" title="wikilink">homotopy type theory</a>.</p>
<h3 id="inductive-types">Inductive types</h3>

<p>A prime example of an <a href="inductive_type" title="wikilink">inductive type</a> is the type of <a href="natural_numbers" title="wikilink">natural numbers</a> 

<math display="inline" id="Intuitionistic_type_theory:22">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

 which is generated by 

<math display="inline" id="Intuitionistic_type_theory:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mn>0</mn>
    <mo separator="true">,</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <cn type="integer">0</cn>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\mathbin{:}{\mathbb{N}}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Intuitionistic_type_theory:24">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mo>succ</mo>
     <mo separator="true">,</mo>
     <mi>ℕ</mi>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <ci>normal-:</ci>
     <ci>succ</ci>
     <ci>ℕ</ci>
    </apply>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}\mathbin{:}{\mathbb{N}}\to{\mathbb{N}}
  </annotation>
 </semantics>
</math>

. An important application of the <a href="propositions_as_types_principle" title="wikilink">propositions as types principle</a> is the identification of (dependent) <a href="primitive_recursion" title="wikilink">primitive recursion</a> and <a href="mathematical_induction" title="wikilink">induction</a> by one elimination constant:</p>

<p>

<math display="block" id="Intuitionistic_type_theory:25">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mrow>
     <mi>ℕ</mi>
     <mo>-</mo>
     <mi>elim</mi>
    </mrow>
   </mpadded>
   <mi mathvariant="normal">:</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi mathvariant="normal">:</mi>
      <mrow>
       <mi>n</mi>
       <mo separator="true">,</mo>
       <mi>ℕ</mi>
      </mrow>
     </mrow>
    </munder>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>succ</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>n</mi>
      <mo separator="true">,</mo>
      <mi>ℕ</mi>
     </mrow>
    </mrow>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>ℕ</ci>
     <ci>elim</ci>
    </apply>
    <ci>normal-:</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <ci>normal-:</ci>
       <ci>n</ci>
       <ci>ℕ</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>succ</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <ci>normal-:</ci>
      <ci>n</ci>
      <ci>ℕ</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\operatorname{{\mathbb{N}}-elim}}\,\mathbin{:}P(0)\,\to\left(\prod_{n\mathbin%
{:}{\mathbb{N}}}P(n)\to P(\operatorname{succ}(n))\right)\to\prod_{n\mathbin{:}%
{\mathbb{N}}}P(n)
  </annotation>
 </semantics>
</math>

</p>

<p>for any given type 

<math display="inline" id="Intuitionistic_type_theory:26">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(n)
  </annotation>
 </semantics>
</math>

 indexed by 

<math display="inline" id="Intuitionistic_type_theory:27">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>n</mi>
    <mo separator="true">,</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\mathbin{:}{\mathbb{N}}
  </annotation>
 </semantics>
</math>

. In general inductive types can be defined in terms of W-types, the type of <a class="uri" href="well-founded" title="wikilink">well-founded</a> trees.</p>

<p>An important class of inductive types are inductive families like the type of vectors 

<math display="inline" id="Intuitionistic_type_theory:28">
 <semantics>
  <mrow>
   <mo>Vec</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Vec</ci>
    <ci>A</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Vec}(A,n)
  </annotation>
 </semantics>
</math>


 mentioned above, which is inductively generated by the constructors 

<math display="inline" id="Intuitionistic_type_theory:29">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mo>vnil</mo>
    <mo separator="true">,</mo>
    <mrow>
     <mo>Vec</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>vnil</ci>
    <apply>
     <ci>Vec</ci>
     <ci>A</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{vnil}\mathbin{:}\operatorname{Vec}(A,0)
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Intuitionistic_type_theory:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi mathvariant="normal">:</mi>
     </mpadded>
     <mrow>
      <mo rspace="4.2pt">vcons</mo>
      <mo separator="true">,</mo>
      <mi>A</mi>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi mathvariant="normal">:</mi>
       <mrow>
        <mi>n</mi>
        <mo separator="true">,</mo>
        <mi>ℕ</mi>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mo>Vec</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo>Vec</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mrow>
       <mo>succ</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <ci>normal-:</ci>
      <ci>vcons</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <ci>normal-:</ci>
        <ci>n</ci>
        <ci>ℕ</ci>
       </apply>
      </apply>
      <apply>
       <ci>Vec</ci>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>Vec</ci>
      <ci>A</ci>
      <apply>
       <ci>succ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{vcons}\,\mathbin{:}\,A\to\prod_{n\mathbin{:}{\mathbb{N}}}%
\operatorname{Vec}(A,n)\to\operatorname{Vec}(A,\operatorname{succ}(n)).
  </annotation>
 </semantics>
</math>

</p>

<p>Applying the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a> once more, inductive families correspond to inductively defined relations.</p>
<h3 id="universes">Universes</h3>

<p>An example of a universe is 

<math display="inline" id="Intuitionistic_type_theory:31">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒰</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}_{0}
  </annotation>
 </semantics>
</math>

, the universe of all small types, which contains names for all the types introduced so far. To every name 

<math display="inline" id="Intuitionistic_type_theory:32">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>a</mi>
    <mo separator="true">,</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒰</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒰</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\mathbin{:}\mathcal{U}_{0}
  </annotation>
 </semantics>
</math>

 we associate a type 

<math display="inline" id="Intuitionistic_type_theory:33">
 <semantics>
  <mrow>
   <mo>El</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>El</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{El}(a)
  </annotation>
 </semantics>
</math>


, its extension or meaning. It is standard to assume a <a href="Impredicativity" title="wikilink">predicative</a> hierarchy of universes

<math display="block" id="Intuitionistic_type_theory:34">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒰</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}_{n}
  </annotation>
 </semantics>
</math>

 for every natural number 

<math display="inline" id="Intuitionistic_type_theory:35">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>n</mi>
    <mo separator="true">,</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\mathbin{:}{\mathbb{N}}
  </annotation>
 </semantics>
</math>

, where the universe 

<math display="inline" id="Intuitionistic_type_theory:36">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒰</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}_{n+1}
  </annotation>
 </semantics>
</math>

 contains a code for the previous universe, i.e., we have 

<math display="inline" id="Intuitionistic_type_theory:37">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>n</mi>
    </msub>
    <mo separator="true">,</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒰</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒰</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{n}\mathbin{:}\mathcal{U}_{n+1}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Intuitionistic_type_theory:38">
 <semantics>
  <mrow>
   <mrow>
    <mo>El</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>u</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒰</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <ci>El</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒰</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{El}(u_{n})\equiv\mathcal{U}_{n}
  </annotation>
 </semantics>
</math>


. (A hierarchy with this property is called "cumulative".)</p>

<p>Stronger universe principles have been investigated, i.e., super universes and the Mahlo universe. In 1992 Huet and Coquand introduced the <a href="calculus_of_constructions" title="wikilink">calculus of constructions</a>, a type theory with an impredicative universe, thus combining type theory with <a href="Jean-Yves_Girard" title="wikilink">Girard</a>'s <a href="System_F" title="wikilink">System F</a>. This extension is not universally accepted by <a href="Intuitionist" title="wikilink">Intuitionists</a> since it allows impredicative, i.e., circular, constructions, which are often identified with classical reasoning.</p>
<h2 id="formalisation-of-type-theory">Formalisation of type theory</h2>

<p>This formalization is based on the discussion in Nordström, Petersson, and Smith.</p>

<p>The formal theory works with <em>types</em> and <em>objects</em>.</p>

<p>A type is declared by:</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_type_theory:39">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>A</mi>
   </mpadded>
   <mi>𝖳𝗒𝗉𝖾</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>𝖳𝗒𝗉𝖾</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\ \mathsf{Type}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>An object exists and is in a type if:</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_type_theory:40">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>a</mi>
    <mo separator="true">,</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\mathbin{:}A
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Objects can be equal</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_type_theory:41">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=b
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>and types can be equal</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_type_theory:42">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=B
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>A type that depends on an object from another type is declared</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_type_theory:43">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>x</mi>
      <mo separator="true">,</mo>
      <mi>A</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-:</ci>
     <ci>x</ci>
     <ci>A</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\mathbin{:}A)B
  </annotation>
 </semantics>
</math>


</li>
</ul>

<p>and removed by substitution</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_type_theory:44">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>x</mi>
     <mo>/</mo>
     <mi>a</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <divide></divide>
      <ci>x</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B[x/a]
  </annotation>
 </semantics>
</math>

, replacing the variable 

<math display="inline" id="Intuitionistic_type_theory:45">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 with the object 

<math display="inline" id="Intuitionistic_type_theory:46">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Intuitionistic_type_theory:47">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>An object that depends on an object from another type can be done two ways. If the object is "abstracted", then it is written</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_type_theory:48">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x]b
  </annotation>
 </semantics>
</math>


</li>
</ul>

<p>and removed by substitution</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_type_theory:49">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>x</mi>
     <mo>/</mo>
     <mi>a</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <divide></divide>
      <ci>x</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b[x/a]
  </annotation>
 </semantics>
</math>

, replacing the variable 

<math display="inline" id="Intuitionistic_type_theory:50">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 with the object 

<math display="inline" id="Intuitionistic_type_theory:51">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Intuitionistic_type_theory:52">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The object-depending-on-object can also be declared as a constant as part of a recursive type. An example of a recursive type is:</p>
<ul>
<li>

<math display="inline" id="Intuitionistic_type_theory:53">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mn>0</mn>
    <mo separator="true">,</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <cn type="integer">0</cn>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\mathbin{:}\mathbb{N}
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Intuitionistic_type_theory:54">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mo>succ</mo>
     <mo separator="true">,</mo>
     <mi>ℕ</mi>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <ci>normal-:</ci>
     <ci>succ</ci>
     <ci>ℕ</ci>
    </apply>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}\mathbin{:}\mathbb{N}\to\mathbb{N}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Here, 

<math display="inline" id="Intuitionistic_type_theory:55">
 <semantics>
  <mo>succ</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>succ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}
  </annotation>
 </semantics>
</math>

 is a constant object-depending-on-object. It is not associated with an abstraction. Constants like 

<math display="inline" id="Intuitionistic_type_theory:56">
 <semantics>
  <mo>succ</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>succ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}
  </annotation>
 </semantics>
</math>

 can be removed by defining equality. Here the relationship with addition is defined using equality and using pattern matching to handle the recursive aspect of 

<math display="inline" id="Intuitionistic_type_theory:57">
 <semantics>
  <mo>succ</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>succ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Intuitionistic_type_theory:58">
 <semantics>
  <mo>add</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>add</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\operatorname{add}
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Intuitionistic_type_theory:59">
 <semantics>
  <mo>succ</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>succ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}
  </annotation>
 </semantics>
</math>

 is manipulated as an opaque constant - it has no internal structure for substitution.</p>

<p>So, objects and types and these relations are used to express formulae in the theory. The following styles of judgements are used to create new objects, types and relations from existing ones:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_type_theory:60">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>σ</mi>
    </mpadded>
    <mi>𝖳𝗒𝗉𝖾</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝖳𝗒𝗉𝖾</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\sigma\ \mathsf{Type}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>σ</em> is a well-formed type in the context Γ.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_type_theory:61">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>t</mi>
     <mo separator="true">,</mo>
     <mi>σ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-:</ci>
     <ci>t</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash t\mathbin{:}\sigma
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>t</em> is a well-formed term of type <em>σ</em> in context Γ.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_type_theory:62">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>σ</mi>
    <mo>≡</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <equivalent></equivalent>
     <ci>σ</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\sigma\equiv\tau
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>σ</em> and <em>τ</em> are equal types in context Γ.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_type_theory:63">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>t</mi>
    <mo>≡</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>u</mi>
      <mo separator="true">,</mo>
      <mi>σ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <equivalent></equivalent>
     <ci>t</ci>
     <apply>
      <ci>normal-:</ci>
      <ci>u</ci>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash t\equiv u\mathbin{:}\sigma
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>t</em> and <em>u</em> are judgmentally equal terms of type <em>σ</em> in context Γ.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Intuitionistic_type_theory:64">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi mathvariant="normal">Γ</mi>
    </mpadded>
    <mi>𝖢𝗈𝗇𝗍𝖾𝗑𝗍</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <ci>𝖢𝗈𝗇𝗍𝖾𝗑𝗍</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\Gamma\ \mathsf{Context}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>Γ is a well-formed context of typing assumptions.</p></td>
</tr>
</tbody>
</table>

<p>By convention, there is a type that represents all other types. It is called 

<math display="inline" id="Intuitionistic_type_theory:65">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

 (or 

<math display="inline" id="Intuitionistic_type_theory:66">
 <semantics>
  <mo>Set</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>Set</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Set}
  </annotation>
 </semantics>
</math>

). Since 

<math display="inline" id="Intuitionistic_type_theory:67">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

 is a type, the member of it are objects. There is a dependent type 

<math display="inline" id="Intuitionistic_type_theory:68">
 <semantics>
  <mo>El</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>El</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{El}
  </annotation>
 </semantics>
</math>

 that maps each object to its corresponding type. <em>In most texts 

<math display="inline" id="Intuitionistic_type_theory:69">
 <semantics>
  <mo>El</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>El</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{El}
  </annotation>
 </semantics>
</math>

 is never written.</em> From the context of the statement, a reader can almost always tell whether 

<math display="inline" id="Intuitionistic_type_theory:70">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 refers to a type, or whether it refers to the object in 

<math display="inline" id="Intuitionistic_type_theory:71">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

 that corresponds to the type.</p>

<p>This is the complete foundation of the theory. Everything else is derived.</p>

<p>To implement logic, each proposition is given its own type. The objects in those types represent the different possible ways to prove the proposition. Obviously, if there is no proof for the proposition, then the type has no objects in it. Operators like "and" and "or" that work on propositions introduce new types and new objects. So 

<math display="inline" id="Intuitionistic_type_theory:72">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>×</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\times B
  </annotation>
 </semantics>
</math>

 is a type that depends on the type 

<math display="inline" id="Intuitionistic_type_theory:73">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and the type 

<math display="inline" id="Intuitionistic_type_theory:74">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. The objects in that dependent type are defined to exist for every pair of objects in 

<math display="inline" id="Intuitionistic_type_theory:75">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Intuitionistic_type_theory:76">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. Obviously, if 

<math display="inline" id="Intuitionistic_type_theory:77">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Intuitionistic_type_theory:78">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 has no proof and is an empty type, then the new type representing 

<math display="inline" id="Intuitionistic_type_theory:79">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>×</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\times B
  </annotation>
 </semantics>
</math>

 is also empty.</p>

<p>This can be done for other types (booleans, natural numbers, etc.) and their operators.</p>
<h2 id="categorical-models-of-type-theory">Categorical models of type theory</h2>

<p>Using the language of <a href="category_theory" title="wikilink">category theory</a>, <a href="R.A.G._Seely" title="wikilink">R.A.G. Seely</a> introduced the notion of a <a href="locally_cartesian_closed_category" title="wikilink">locally cartesian closed category</a> (LCCC) as the basic model of type theory. This has been refined by Hofmann and Dybjer to <em>Categories with Families</em> or <em>Categories with Attributes</em> based on earlier work by Cartmell.</p>

<p>A category with families is a category <em>C</em> of contexts (in which the objects are contexts, and the context morphisms are substitutions), together with a functor <em>T</em> : <em>C</em><sup>op</sup> → <em>Fam(Set)</em>.</p>

<p><em>Fam(Set)</em> is the <a href="category_of_families" title="wikilink">category of families</a> of Sets, in which objects are pairs <em>(A,B)</em> of an "index set" <em>A</em> and a function <em>B</em>: <em>X</em> → <em>A</em>, and morphisms are pairs of functions <em>f</em> : <em>A</em> → ''A' '' and <em>g</em> : <em>X</em> → ''X' '', such that ''B' '' <sub>°</sub> <em>g</em> = <em>f</em> <sub>°</sub> <em>B</em> - in other words, <em>f</em> maps <em>B<sub>a</sub></em> to <em>B'<sub>g(a)</sub></em>.</p>

<p>The functor <em>T</em> assigns to a context <em>G</em> a set <em>Ty(G)</em> of types, and for each <em>A</em> : <em>Ty(G)</em>, a set <em>Tm(G,A)</em> of terms. The axioms for a functor require that these play harmoniously with substitution. Substitution is usually written in the form <em>Af</em> or <em>af</em>, where <em>A</em> is a type in <em>Ty(G)</em> and <em>a</em> is a term in <em>Tm(G,A)</em>, and <em>f</em> is a substitution from <em>D</em> to <em>G</em>. Here <em>Af</em> : <em>Ty(D)</em> and <em>af</em> : <em>Tm(D,Af)</em>.</p>

<p>The category <em>C</em> must contain a terminal object (the empty context), and a final object for a form of product called comprehension, or context extension, in which the right element is a type in the context of the left element. If <em>G</em> is a context, and <em>A</em> : <em>Ty(G)</em>, then there should be an object <em>(G,A)</em> final among contexts <em>D</em> with mappings <em>p</em> : ''D → <em>G</em>, <em>q</em> : <em>Tm(D,Ap)</em>.</p>

<p>A logical framework, such as Martin-Löf's takes the form of closure conditions on the context dependent sets of types and terms: that there should be a type called Set, and for each set a type, that the types should be closed under forms of dependent sum and product, and so forth.</p>

<p>A theory such as that of predicative set theory expresses closure conditions on the types of sets and their elements: that they should be closed under operations that reflect dependent sum and product, and under various forms of inductive definition.</p>
<h2 id="extensional-versus-intensional">Extensional versus intensional</h2>

<p>A fundamental distinction is <a href="Extensional_definition" title="wikilink">extensional</a> vs <a href="Intensional_definition" title="wikilink">intensional</a> type theory. In extensional type theory definitional (i.e., computational) equality is not distinguished from propositional equality, which requires proof. As a consequence type checking becomes <a href="undecidable_problem" title="wikilink">undecidable</a> in extensional type theory because programs in the theory might not terminate. For example, such a theory allows one to give a type to <a href="Fixpoint_combinator" title="wikilink">Y-Combinator</a>, a detailed example of this can be found in.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> However, this doesn't prevent extensional type theory from being a basis for a practical tool, for example, <a class="uri" href="NuPRL" title="wikilink">NuPRL</a> is based on extensional type theory. From a practical standpoint there's no difference between a program which doesn't terminate and a program which takes a million years to terminate.</p>

<p>In contrast in intensional type theory <a href="type_checking" title="wikilink">type checking</a> is <a href="Decision_problem" title="wikilink">decidable</a>, but the representation of standard mathematical concepts is somewhat more cumbersome, since extensional reasoning requires using <a href="setoid" title="wikilink">setoids</a> or similar constructions. There are many common mathematical objects, which are hard to work with or can't be represented without this, for example, <a href="Integer" title="wikilink">integer numbers</a>, <a href="rational_number" title="wikilink">rational numbers</a>, and <a href="real_number" title="wikilink">real numbers</a>. Integers and rational numbers can be represented without setoids, but this representation isn't easy to work with. Real numbers can't be represented without this see.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p><a href="Homotopy_type_theory" title="wikilink">Homotopy type theory</a> works on resolving this problem. It allows one to define <a href="higher_inductive_type" title="wikilink">higher inductive types</a>, which not only define first order constructors (<a href="value_(computer_science)" title="wikilink">values</a> or <a href="point_(geometry)" title="wikilink">points</a>), but higher order constructors, i.e. equalities between elements (<a href="path_(topology)" title="wikilink">paths</a>), equalities between equalities (<a href="homotopy" title="wikilink">homotopies</a>), <em>ad infinitum</em>.</p>
<h2 id="implementations-of-type-theory">Implementations of type theory</h2>

<p>Type theory has been the base of a number of proof assistants, such as <a class="uri" href="NuPRL" title="wikilink">NuPRL</a>, <a href="LEGO_(programming)" title="wikilink">LEGO</a> and <a class="uri" href="Coq" title="wikilink">Coq</a>. Recently, <a href="dependent_types" title="wikilink">dependent types</a> also featured in the design of <a href="programming_languages" title="wikilink">programming languages</a> such as <a href="ATS_(programming_language)" title="wikilink">ATS</a>, <a href="Cayenne_(programming_language)" title="wikilink">Cayenne</a>, <a href="Epigram_(programming_language)" title="wikilink">Epigram</a>, <a href="Agda_(theorem_prover)" title="wikilink">Agda</a>, and <a href="Idris_(programming_language)" title="wikilink">Idris</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Calculus_of_constructions" title="wikilink">Calculus of constructions</a></li>
<li><a href="Intuitionistic_logic" title="wikilink">Intuitionistic logic</a></li>
<li><a href="Per_Martin-Löf" title="wikilink">Per Martin-Löf</a></li>
<li><a href="Type_theory" title="wikilink">Type theory</a></li>
<li><a href="Typed_lambda_calculus" title="wikilink">Typed lambda calculus</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Per Martin-Löf (1984). <em><a href="http://intuitionistic.files.wordpress.com/2010/07/martin-lof-tt.pdf">Intuitionistic Type Theory</a></em> Bibliopolis. ISBN 88-7088-105-9.</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Bengt Nordström; Kent Petersson; Jan M. Smith (1990). <em>Programming in Martin-Löf's Type Theory</em>. Oxford University Press. The book is out of print, but a free version can be picked up from <a href="http://www.cs.chalmers.se/Cs/Research/Logic/book/">here</a>.</li>
<li>Thompson, Simon (1991). <em><a href="http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/">Type Theory and Functional Programming</a></em> Addison-Wesley. ISBN 0-201-41667-0.</li>
<li>Granström, Johan G. (2011). <em><a href="http://www.springer.com/philosophy/book/978-94-007-1735-0">Treatise on Intuitionistic Type Theory</a></em> Springer. ISBN 978-94-007-1735-0.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.chalmers.se/Cs/Research/Logic/Types/tutorials.html">EU Types Project: Tutorials</a> - lecture notes and slides from the Types Summer School 2005</li>
<li><a href="http://math.ucr.edu/home/baez/ncat.def.html">n-Categories - Sketch of a Definition</a> - letter from John Baez and James Dolan to Ross Street, November 29, 1995</li>
</ul>
<h2 id="references-1">References</h2>

<p>"</p>

<p><a href="Category:Dependently_typed_programming" title="wikilink">Category:Dependently typed programming</a> <a href="Category:Constructivism_(mathematics)" title="wikilink">Category:Constructivism (mathematics)</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a class="uri" href="Category:Intuitionism" title="wikilink">Category:Intuitionism</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Bengt Nordström; Kent Petersson; Jan M. Smith (1990). <em>Programming in Martin-Löf's Type Theory</em>. Oxford University Press p.90<a href="#fnref1">↩</a></li>
<li id="fn2">Altenkirch, Thorsten, Thomas Anberrée, and Nuo Li. "Definable Quotients in Type Theory."<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
