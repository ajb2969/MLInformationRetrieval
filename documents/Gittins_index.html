<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="486">Gittins index</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Gittins index</h1>
<hr/>

<p>The <strong>Gittins index</strong> is a measure of the reward that can be achieved by a random process bearing a termination state and evolving from its present state onward, under the option of terminating the said process at every later stage with the accrual of the probabilistic expected reward from that stage up to the attainment of its termination state. It is a <a href="real_number" title="wikilink">real</a> <a href="scalar_(mathematics)" title="wikilink">scalar</a> value associated to the state of a <a href="stochastic_process" title="wikilink">stochastic process</a> with a reward function and a probability of termination.</p>
<h2 id="terminology">Terminology</h2>

<p>To illustrate the theory we can take two examples from a developing sector, such as from electricity generating technologies: wind power and wave power. If we are presented with the two technologies when they are both proposed as ideas we cannot say which will be better in the long run as we have no data, as yet, to base our judgments on.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It would be easy to say that wave power would be too problematic to develop as it seems easier to put up lots of wind turbines than to make the long floating generators, tow them out to sea and lay the cables necessary.</p>

<p>If we were to make a judgment call at that early time in development we could be condemning one technology to being put on the shelf and the other would be developed and put into operation. If we develop both technologies we would be able to make a judgment call on each by comparing the progress of each technology at a set time interval such as every three months. The decisions we make about investment in the next stage would be based on those results.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>In a paper in 1979 called <em>Bandit Processes and Dynamic Allocation Indices</em> <a href="John_C._Gittins" title="wikilink">John C. Gittins</a> suggests a solution for problems such as this. He takes the two basic functions of a "<a href="Scheduling_(computing)" title="wikilink">Scheduling</a> Problem" and a "Multi-armed bandit" problem<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and shows how these problems can be solved using <em>Dynamic allocation indices</em>. He first takes the "Scheduling Problem" and reduces it to a machine which has to perform jobs and has a set time period, every hour or day for example, to finish each job in. The machine is given a reward value, based on finishing or not within the time period, and a probability value of whether it will finish or not for each job is calculated. The problem is "to decide which job to process next at each stage so as to maximize the total expected reward."<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> He then moves on to the "Multi–armed bandit problem" where each pull on a "<a href="Slot_machine" title="wikilink">one armed bandit</a>" lever is allocated a reward function for a successful pull, and a zero reward for an unsuccessful pull. The sequence of successes forms a <a href="Bernoulli_process" title="wikilink">Bernoulli process</a> and has an unknown probability of success. There are multiple "bandits" and the distribution of successful pulls is calculated and different for each machine. Gittins states that the problem here is "to decide which arm to pull next at each stage so as to maximize the total expected reward from an infinite sequence of pulls."<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Gittins says that "Both the problems described above involve a sequence of decisions, each of which is based on more information than its predecessors, and these both problems may be tackled by dynamic allocation indices."<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="definition">Definition</h2>

<p>In applied mathematics, the "Gittins index" is a <a href="real_number" title="wikilink">real</a> <a href="scalar_(mathematics)" title="wikilink">scalar</a> value associated to the state of a <a href="stochastic_process" title="wikilink">stochastic process</a> with a reward function and with a probability of termination. It is a measure of the reward that can be achieved by the process evolving from that state on, under the probability that it will be terminated in future. The "index policy" induced by the Gittins index, consisting of choosing at any time the stochastic process with the currently highest Gittins index, is the solution of some <em><a href="Optimal_stopping" title="wikilink">stopping problems</a></em> such as the one of dynamic allocation, where a decision-maker has to maximize the total reward by distributing a limited amount of effort to a number of competing projects, each returning a stochastic reward. If the projects are independent from each other and only one project at a time may evolve, the problem is called <a href="multi-armed_bandit" title="wikilink">multi-armed bandit</a> and the Gittins index policy is optimal. If multiple projects can evolve, the problem is called <em>Restless bandit</em> and the Gittins index policy is a known good heuristic but no optimal solution exists in general. In fact, in general this problem is <a href="NP_(complexity)" title="wikilink">NP-complete</a> and it is generally accepted that no feasible solution can be found.</p>
<h2 id="history">History</h2>

<p>Questions about the optimal stopping policies in the context of clinical trials have been open from the 1940s and in the 1960s a few authors analyzed simple models leading to optimal index policies,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> but it was only in the 1970s that Gittins and his collaborators demonstrated in a markovian framework that the optimal solution of the general case is an index policy whose "dynamic allocation index" is computable in principle for every state of each project as a function of the single project's dynamics.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Soon after the seminal paper of Gittins, <a href="Peter_Whittle" title="wikilink">Peter Whittle</a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> demonstrated that the index emerges as a <a href="lagrangian_multiplier" title="wikilink">lagrangian multiplier</a> from a <a href="dynamic_programming" title="wikilink">dynamic programming</a> formulation of the problem called <em>retirement process</em> and conjectured that the same index would be a good heuristic in a more general setup named <em>Restless bandit</em>. The question of how to actually calculate the index for <a href="Markov_chain" title="wikilink">Markov chains</a> was first addressed by Varaiya and his collaborators<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> with an algorithm that computes the indexes from the largest first down to the smallest and by Chen and Katehakis <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> who showed that standard <a href="Linear_programming" title="wikilink">LP</a> could be used to calculate the index of a state without requiring its calculation for all states with higher index values. LCM Kallenberg <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> provided a parametric LP implementation to compute the indices for all states of a Markov chain. Further, Katehakis and Veinott<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> demonstrated that the index is the expected reward of a <a href="Markov_decision_process" title="wikilink">Markov decision process</a> constructed over the Markov chain and known as <em>Restart in State</em> and can be calculated exactly by solving that problem with the <em>policy iteration</em> algorithm, or approximately with the <em>value iteration</em> algorithm. This approach also has the advantage of calculating the index for one specific state without having to calculate all the greater indexes and it is valid under more general state space conditions. A faster algorithm for the calculation of all indices has been obtained in 2004 by Sonin<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> as a consequence of his <em>elimination algorithm</em> for the optimal stopping of a Markov chain. In this algorithm the termination probability of the process may depend on the current state rather than being a fixed factor. A faster algorithm has been proposed in 2007 by Niño-Mora <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> by exploiting the structure of a parametric simplex to reduce the computational effort of the pivot steps and thereby achieving the same complexity as the <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a> algorithm. Cowan, W. and Katehakis (2014),<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> provide a solution to the problem, with potentially non-Markovian, uncountable state space reward processes, under frameworks in which, either the discount factors may be non-uniform and vary over time, or the periods of activation of each bandit may be not be fixed or uniform, subject instead to a possibly stochastic duration of activation before a change to a different bandit is allowed. The solution is based on generalized restart-in-state indices.</p>
<h2 id="mathematical-definition">Mathematical definition</h2>
<h3 id="dynamic-allocation-index">Dynamic allocation index</h3>

<p>The classical definition by Gittins et al. is:</p>

<p>

<math display="block" id="Gittins_index:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>ν</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mi>τ</mi>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <mfrac>
     <msub>
      <mrow>
       <mo>⟨</mo>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>t</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>τ</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msubsup>
        <mrow>
         <msup>
          <mi>β</mi>
          <mi>t</mi>
         </msup>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mi>Z</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>t</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>⟩</mo>
      </mrow>
      <mrow>
       <mrow>
        <mi>Z</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mi>i</mi>
      </mrow>
     </msub>
     <msub>
      <mrow>
       <mo>⟨</mo>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>t</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>τ</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msubsup>
        <msup>
         <mi>β</mi>
         <mi>t</mi>
        </msup>
       </mrow>
       <mo>⟩</mo>
      </mrow>
      <mrow>
       <mrow>
        <mi>Z</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mi>i</mi>
      </mrow>
     </msub>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ν</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <gt></gt>
       <ci>τ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>t</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>β</ci>
           <ci>t</ci>
          </apply>
          <ci>R</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <times></times>
            <ci>Z</ci>
            <ci>t</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>Z</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>t</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>β</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>Z</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(i)=\sup_{\tau>0}\frac{\left\langle\sum_{t=0}^{\tau-1}\beta^{t}R[Z(t)]%
\right\rangle_{Z(0)=i}}{\left\langle\sum_{t=0}^{\tau-1}\beta^{t}\right\rangle_%
{Z(0)=i}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Gittins_index:1">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Z</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(\cdot)
  </annotation>
 </semantics>
</math>

 is a stochastic process, 

<math display="inline" id="Gittins_index:2">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(i)
  </annotation>
 </semantics>
</math>

 is the utility (also called reward) associated to the discrete state 

<math display="inline" id="Gittins_index:3">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Gittins_index:4">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>β</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta<1
  </annotation>
 </semantics>
</math>

 is the probability that the stochastic process does not terminate, and 

<math display="inline" id="Gittins_index:5">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mo>⋅</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>normal-⋅</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot\rangle_{c}
  </annotation>
 </semantics>
</math>

 is the conditional expectation operator given <em>c</em>:</p>

<p>

<math display="block" id="Gittins_index:6">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>X</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>c</mi>
   </msub>
   <mo>≐</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mi>χ</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>x</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>X</mi>
       <mo>=</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">|</mo>
      <mi>c</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">approaches-limit</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>X</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>χ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <apply>
        <eq></eq>
        <ci>X</ci>
        <ci>x</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle X\rangle_{c}\doteq\sum_{x\in\chi}xP\{X=x|c\}
  </annotation>
 </semantics>
</math>

</p>

<p>with 

<math display="inline" id="Gittins_index:7">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>

 being the <a href="Range_(mathematics)" title="wikilink">range</a> of <em>X</em>.</p>
<h3 id="retirement-process-formulation">Retirement process formulation</h3>

<p>The dynamic programming formulation in terms of retirement process, given by Whittle, is:</p>

<p>

<math display="block" id="Gittins_index:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo movablelimits="false">inf</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>k</mi>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mi>v</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo>,</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mi>k</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">infimum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>k</ci>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>v</ci>
        <interval closure="open">
         <ci>i</ci>
         <ci>k</ci>
        </interval>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(i)=\inf\{k:v(i,k)=k\}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Gittins_index:9">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(i,k)
  </annotation>
 </semantics>
</math>

 is the <em>value function</em></p>

<p>

<math display="block" id="Gittins_index:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mi>τ</mi>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <msub>
     <mrow>
      <mo>⟨</mo>
      <mrow>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>t</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>τ</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mrow>
         <msup>
          <mi>β</mi>
          <mi>t</mi>
         </msup>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mi>Z</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>t</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msup>
         <mi>β</mi>
         <mi>t</mi>
        </msup>
        <mi>k</mi>
       </mrow>
      </mrow>
      <mo>⟩</mo>
     </mrow>
     <mrow>
      <mrow>
       <mi>Z</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mi>i</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>k</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <gt></gt>
       <ci>τ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>t</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>β</ci>
           <ci>t</ci>
          </apply>
          <ci>R</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <times></times>
            <ci>Z</ci>
            <ci>t</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>β</ci>
          <ci>t</ci>
         </apply>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>Z</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(i,k)=\sup_{\tau>0}\left\langle\sum_{t=0}^{\tau-1}\beta^{t}R[Z(t)]+\beta^{t}k%
\right\rangle_{Z(0)=i}
  </annotation>
 </semantics>
</math>

</p>

<p>with the same notation as above. It holds that</p>

<p>

<math display="block" id="Gittins_index:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ν</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ν</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>β</ci>
     </apply>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(i)=(1-\beta)w(i).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="restart-in-state-formulation">Restart-in-state formulation</h3>

<p>If 

<math display="inline" id="Gittins_index:12">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Z</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(\cdot)
  </annotation>
 </semantics>
</math>

 is a Markov chain with rewards, the interpretation of <a href="Michael_Katehakis" title="wikilink">Katehakis</a> and Veinott (1987) associates to every state the action of restarting from one arbitrary state 

<math display="inline" id="Gittins_index:13">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, thereby constructing a Markov decision process 

<math display="inline" id="Gittins_index:14">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>The Gittins Index of that state 

<math display="inline" id="Gittins_index:15">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is the highest total reward which can be achieved on 

<math display="inline" id="Gittins_index:16">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>

 if one can always choose to continue or restart from that state 

<math display="inline" id="Gittins_index:17">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Gittins_index:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mi>π</mi>
    </munder>
    <msub>
     <mrow>
      <mo>⟨</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>t</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <mi>τ</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
       <mrow>
        <msup>
         <mi>β</mi>
         <mi>t</mi>
        </msup>
        <mi>R</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <msup>
           <mi>Z</mi>
           <mi>π</mi>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>⟩</mo>
     </mrow>
     <mrow>
      <mrow>
       <mi>Z</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mi>i</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <ci>π</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>t</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>τ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>β</ci>
          <ci>t</ci>
         </apply>
         <ci>R</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>Z</ci>
            <ci>π</ci>
           </apply>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>Z</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(i)=\sup_{\pi}\left\langle\sum_{t=0}^{\tau-1}\beta^{t}R[Z^{\pi}(t)]\right%
\rangle_{Z(0)=i}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Gittins_index:19">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 indicates a policy over 

<math display="inline" id="Gittins_index:20">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>

. It holds that</p>

<p>

<math display="block" id="Gittins_index:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(i)=w(i)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="generalized-index">Generalized index</h3>

<p>If the probability of termination 

<math display="inline" id="Gittins_index:22">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta(i)
  </annotation>
 </semantics>
</math>

 depends on the state 

<math display="inline" id="Gittins_index:23">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, a generalization introduced by Sonin (2008) defines the Gittins index 

<math display="inline" id="Gittins_index:24">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(i)
  </annotation>
 </semantics>
</math>

 as the maximum discounted total reward per chance of termination.</p>

<p>

<math display="block" id="Gittins_index:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mi>τ</mi>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <mfrac>
     <mrow>
      <msup>
       <mi>R</mi>
       <mi>τ</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>Q</mi>
       <mi>τ</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <gt></gt>
       <ci>τ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <ci>τ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Q</ci>
        <ci>τ</ci>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(i)=\sup_{\tau>0}\frac{R^{\tau}(i)}{Q^{\tau}(i)}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Gittins_index:26">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>R</mi>
     <mi>τ</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo>⟨</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>τ</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>Z</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>⟩</mo>
    </mrow>
    <mrow>
     <mrow>
      <mi>Z</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>i</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>τ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>t</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>τ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>R</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <ci>Z</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>Z</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\tau}(i)=\left\langle\sum_{t=0}^{\tau-1}R[Z(t)]\right\rangle_{Z(0)=i}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Gittins_index:27">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Q</mi>
     <mi>τ</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo>⟨</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>τ</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∏</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>t</mi>
       </msubsup>
       <mrow>
        <mi>β</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>Z</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>j</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo>⟩</mo>
    </mrow>
    <mrow>
     <mrow>
      <mi>Z</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>i</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>τ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>t</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>τ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>β</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <times></times>
           <ci>Z</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>Z</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q^{\tau}(i)=\left\langle\sum_{t=0}^{\tau-1}\prod_{j=0}^{t}\beta[Z(j)]\right%
\rangle_{Z(0)=i}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>If 

<math display="inline" id="Gittins_index:28">
 <semantics>
  <msup>
   <mi>β</mi>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>β</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta^{t}
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Gittins_index:29">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi>t</mi>
   </msubsup>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>Z</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>β</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>Z</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{j=0}^{t}\beta[Z(j)]
  </annotation>
 </semantics>
</math>

 in the definitions of 

<math display="inline" id="Gittins_index:30">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ν</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(i)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Gittins_index:31">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(i)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Gittins_index:32">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(i)
  </annotation>
 </semantics>
</math>

, then it holds that</p>

<p>

<math display="block" id="Gittins_index:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(i)=h(i)=w(i)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Gittins_index:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mi>ν</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>∀</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <list>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>ν</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(i)\neq k\nu(i),\forall k
  </annotation>
 </semantics>
</math>

 this observation leads Sonin to conclude that 

<math display="inline" id="Gittins_index:35">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(i)
  </annotation>
 </semantics>
</math>

 and not 

<math display="inline" id="Gittins_index:36">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ν</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(i)
  </annotation>
 </semantics>
</math>

 is the "true meaning" of the Gittins index.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://sites.google.com/site/lorenzodigregorio/gittins-index">1</a> Matlab/Octave implementation of the index computation algorithms</li>
</ul>
<ul>
<li>Cowan, R. <em><a href="http://links.jstor.org/sici?sici=0013-0133(199107)101%3A407%3C801%3ATAHCAT%3E2.0.CO%3B2-S">Tortoises and Hares: Choice among technologies of unknown merit</a></em></li>
</ul>
<ul>
<li>Bertsimas, D. and Niño-Mora, J. (1996). Conservation laws, extended polymatroids and multiarmed bandit problems: a polyhedral approach to indexable systems. Math. Oper. Res. 29 (1), 162–181.</li>
</ul>

<p>"</p>

<p><a href="Category:Decision_theory" title="wikilink">Category:Decision theory</a> <a href="Category:Design_of_experiments" title="wikilink">Category:Design of experiments</a> <a href="Category:Sequential_methods" title="wikilink">Category:Sequential methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3">J. C. Gittins, <em><a href="http://links.jstor.org/sici?sici=0035-9246%281979%2941%3A2%3C148%3ABPADAI%3E2.0.CO%3B2-0">Bandit Processes and Dynamic Allocation Indices</a></em>, Journal of the Royal Statistical Society, Series B, Vol. 41, No. 2. (1979), pp. 148–177.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7">Mitten, L. (1960). "An Analytic Solution to the Least Cost Testing Sequence Problem." <em>J. of Industrial Eng.</em>, 11, 1, 17.<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9">J. C. Gittins, D. M. Jones, <em><a href="http://links.jstor.org/sici?sici=0006-3444(197912)66%3A3%3C561%3AADAIFT%3E2.0.CO%3B2-H">A Dynamic Allocation Index for the Discounted Multiarmed Bandit Problem</a></em>, Biometrika, Vol 66, No. 3. (1979), pp. 561–565.<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">Varaiya, P., Walrand J., Buyukkoc C. (1985). "Extensions of the Multiarmed Bandit Problem." <em>IEEE Trans. Autom. Control</em>, AC-30, 426–439<a href="#fnref11">↩</a></li>
<li id="fn12">Chen, Y.R. and Katehakis, M.N. (1986). "Linear programming for finite state multi-armed bandit problems", <em>Math. Oper. Res.</em>, 11(1), 262–268<a href="#fnref12">↩</a></li>
<li id="fn13">Kallenberg, L.C.M.(1986). "A Note on MN Katehakis' and Y.-R. Chen's Computation of the Gittins Index", <em>Math. Oper. Res.</em>, 11(1), 262–268<a href="#fnref13">↩</a></li>
<li id="fn14">Katehakis, M., Veinott, A. (1987). "The multi-armed bandit problem: decomposition and computation." <em>Math. Oper. Res.</em>, 12(2), 262–268<a href="#fnref14">↩</a></li>
<li id="fn15">Sonin, I. (2008). "A generalized Gittins index for a Markov chain and its recursive calculation." <em>Statistics and Probability Letters</em>, 78, 1526–1533.<a href="#fnref15">↩</a></li>
<li id="fn16">Niño-Mora, J. (2007). "A (2/3)^n Fast-Pivoting Algorithm for the Gittins Index and Optimal Stopping of a Markov Chain." <em>INFORMS Journal of Computing</em>, 19(4), 596–606.<a href="#fnref16">↩</a></li>
<li id="fn17">Cowan, W. and M.N. Katehakis (2014). "Multi-armed Bandits under General Depreciation and Commitment". Probability in the Engineering and Informational Sciences. <a class="uri" href="doi:10.1017/S0269964814000217">doi:10.1017/S0269964814000217</a><a href="#fnref17">↩</a></li>
</ol>
</section>
</body>
</html>
