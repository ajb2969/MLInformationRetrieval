   Steffensen's method      Steffensen's method  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In numerical analysis , Steffensen's method is a root-finding method , similar to Newton's method , named after Johan Frederik Steffensen . Steffensen's method also achieves quadratic convergence , but without using derivatives as Newton's method does.  Simple description  The simplest form of the formula for Steffensen's method occurs when it is used to find the zeros, or roots, of a function   f   f   f   ; that is: to find the value    x  ⋆     subscript  x  normal-⋆    x_{\star}   that satisfies     f   (   x  ⋆   )    =  0        f   subscript  x  normal-⋆    0    f(x_{\star})=0   . Near the solution    x  ⋆     subscript  x  normal-⋆    x_{\star}   , the function   f   f   f   is supposed to approximately satisfy     -  1   <    f  ′    (   x  ⋆   )    <  0          1      superscript  f  normal-′    subscript  x  normal-⋆         0     -1   ; this condition makes the function   f   f   f   adequate as a correction for finding its own solution, although it is not required to work efficiently. For some functions, Steffensen's method can work even if this condition is not met, but in such a case, the starting value    x  0     subscript  x  0    x_{0}   must be very close to the actual solution    x  ⋆     subscript  x  normal-⋆    x_{\star}   , and convergence to the solution may be slow.  Given an adequate starting value    x  0     subscript  x  0    x_{0}   , a sequence of values     x  0   ,   x  1   ,   x  2   ,  …  ,   x  n   ,  …      subscript  x  0    subscript  x  1    subscript  x  2   normal-…   subscript  x  n   normal-…    x_{0},\ x_{1},\ x_{2},\dots,\ x_{n},\dots   can be generated using the formula below. When it works, each value in the sequence is much closer to the solution    x  ⋆     subscript  x  normal-⋆    x_{\star}   than the prior value. The value    x  n     subscript  x  n    x_{n}   from the current step generates the value    x   n  +  1      subscript  x    n  1     x_{n+1}   for the next step, via this formula: 1       x   n  +  1    =    x  n   -    f   (   x  n   )     g   (   x  n   )           subscript  x    n  1       subscript  x  n       f   subscript  x  n      g   subscript  x  n        x_{n+1}=x_{n}-\frac{f(x_{n})}{g(x_{n})}     for n = 0, 1, 2, 3, ... , where the slope function    g   (   x  n   )       g   subscript  x  n     g(x_{n})   is a composite of the original function   f   f   f   given by the following formula:        g   (   x  n   )    =     f   (    x  n   +   f   (   x  n   )     )    -   f   (   x  n   )      f   (   x  n   )      .        g   subscript  x  n          f     subscript  x  n     f   subscript  x  n        f   subscript  x  n       f   subscript  x  n       g(x_{n})=\frac{f(x_{n}+f(x_{n}))-f(x_{n})}{f(x_{n})}.     The function   g   g   g   is the average value for the slope of the function   f   f   f   between the last sequence point     (  x  ,  y  )   =   (   x  n   ,   f   (   x  n   )    )        x  y     subscript  x  n     f   subscript  x  n       (x,y)=(x_{n},\ f(x_{n}))   and the auxiliary point     (  x  ,  y  )   =   (    x  n   +  h   ,   f   (    x  n   +  h   )    )        x  y       subscript  x  n   h     f     subscript  x  n   h       (x,y)=(x_{n}+h,\ f(x_{n}+h))   , with the step    h  =   f   (   x  n   )        h    f   subscript  x  n      h=f(x_{n})   . It is also called the first-order divided difference of   f   f   f   between those two points.  It is only for the purpose of finding   h   h   h   for this auxiliary point that the value of the function   f   f   f   must be an adequate correction to get closer to its own solution, and for that reason fulfill the requirement that     -  1   <    f  ′    (   x  ⋆   )    <  0          1      superscript  f  normal-′    subscript  x  normal-⋆         0     -1   . For all other parts of the calculation, Steffensen's method only requires the function   f   f   f   to be continuous and to actually have a nearby solution. Several modest modifications of the step   h   h   h   in the slope calculation   g   g   g   exist to accommodate functions   f   f   f   that do not quite meet the requirement.  Advantages and drawbacks  The main advantage of Steffensen's method is that it has quadratic convergence like Newton's method – that is, both methods find roots to an equation   f   f   f   just as ‘quickly’. In this case quickly means that for both methods, the number of correct digits in the answer doubles with each step. But the formula for Newton's method requires a separate function for the derivative; Steffensen's method does not. So Steffensen's method can be programmed for a generic function, as long as that function meets the constraints mentioned above.  The price for the quick convergence is the double function evaluation: both    f   (   x  n   )       f   subscript  x  n     f(x_{n})   and    f   (    x  n   +  h   )       f     subscript  x  n   h     f(x_{n}+h)   must be calculated, which might be time-consuming if   f   f   f   is a complicated function. For comparison, the secant method needs only one function evaluation per step, so with two function evaluations the secant method can do two steps, and two steps of the secant method increase the number of correct digits by a factor of 1.6 . The equally time-consuming single step of Steffensen's (or Newton's) method increases the correct digits by a factor of 2 – which is only slightly less.  Similar to Newton's method and most other quadratically convergent algorithms, the crucial weakness in Steffensen's method is the choice of the starting value    x  0     subscript  x  0    x_{0}   . If the value of    x  0     subscript  x  0    x_{0}   is not close ‘enough’ to the actual solution    x  ⋆     subscript  x  normal-⋆    x_{\star}   , the method may fail and the sequence of values     x  0   ,   x  1   ,   x  2   ,   x  3   ,  …      subscript  x  0    subscript  x  1    subscript  x  2    subscript  x  3   normal-…    x_{0},x_{1},x_{2},x_{3},\dots   may either flip flop between two extremes, or diverge to infinity (possibly both!).  Derivation using Aitken's delta-squared process  The version of Steffensen's method implemented in the MATLAB code shown below can be found using the Aitken's delta-squared process for accelerating convergence of a sequence. To compare the following formulae to the formulae in the section above, notice that     x  n   =    p   -   p  n         subscript  x  n     p   subscript  p  n      x_{n}=p\ -\ p_{n}   . This method assumes starting with a linearly convergent sequence and increases the rate of convergence of that sequence. If the signs of     p  n   ,   p   n  +  1    ,   p   n  +  2        subscript  p  n    subscript  p    n  1     subscript  p    n  2      p_{n},\ p_{n+1},\ p_{n+2}   agree and    p  n     subscript  p  n    p_{n}   is sufficiently close to the desired limit of the sequence   p   p   p   , we can assume the following:         p   n  +  1    -  p     p  n   -  p    ≈     p   n  +  2    -  p     p   n  +  1    -  p             subscript  p    n  1    p      subscript  p  n   p         subscript  p    n  2    p      subscript  p    n  1    p      \frac{p_{n+1}-p}{p_{n}-p}\approx\frac{p_{n+2}-p}{p_{n+1}-p}   then        (    p   n  +  1    -  p   )   2   ≈    (    p   n  +  2    -  p   )    (    p  n   -  p   )         superscript     subscript  p    n  1    p   2        subscript  p    n  2    p      subscript  p  n   p      (p_{n+1}-p)^{2}\approx(p_{n+2}-p)(p_{n}-p)   so         p   n  +  1   2   -   2   p   n  +  1    p    +   p  2    ≈      p   n  +  2     p  n    -    (    p  n   +   p   n  +  2     )   p    +   p  2             superscript   subscript  p    n  1    2     2   subscript  p    n  1    p     superscript  p  2           subscript  p    n  2     subscript  p  n         subscript  p  n    subscript  p    n  2     p     superscript  p  2      p_{n+1}^{2}-2p_{n+1}p+p^{2}\approx p_{n+2}p_{n}-(p_{n}+p_{n+2})p+p^{2}   and hence        (     p   n  +  2    -   2   p   n  +  1      +   p  n    )   p   ≈     p   n  +  2     p  n    -   p   n  +  1   2               subscript  p    n  2      2   subscript  p    n  1       subscript  p  n    p        subscript  p    n  2     subscript  p  n     superscript   subscript  p    n  1    2      (p_{n+2}-2p_{n+1}+p_{n})p\approx p_{n+2}p_{n}-p_{n+1}^{2}   . Solving for the desired limit of the sequence   p   p   p   gives:     p  ≈      p   n  +  2     p  n    -   p   n  +  1   2       p   n  +  2    -   2   p   n  +  1      +   p  n         p         subscript  p    n  2     subscript  p  n     superscript   subscript  p    n  1    2         subscript  p    n  2      2   subscript  p    n  1       subscript  p  n       p\approx\frac{p_{n+2}p_{n}-p_{n+1}^{2}}{p_{n+2}-2p_{n+1}+p_{n}}         =      p  n  2   +    p  n    p   n  +  2     +   2   p  n    p   n  +  1      -   2   p  n    p   n  +  1     -   p  n  2   -   p   n  +  1   2       p   n  +  2    -   2   p   n  +  1      +   p  n         absent         superscript   subscript  p  n   2      subscript  p  n    subscript  p    n  2       2   subscript  p  n    subscript  p    n  1        2   subscript  p  n    subscript  p    n  1      superscript   subscript  p  n   2    superscript   subscript  p    n  1    2         subscript  p    n  2      2   subscript  p    n  1       subscript  p  n       =\frac{p_{n}^{2}+p_{n}p_{n+2}+2p_{n}p_{n+1}-2p_{n}p_{n+1}-p_{n}^{2}-p_{n+1}^{2%
 }}{p_{n+2}-2p_{n+1}+p_{n}}         =     (     p  n  2   +    p  n    p   n  +  2      -   2   p  n    p   n  +  1      )   -   (     p  n  2   -   2   p  n    p   n  +  1      +   p   n  +  1   2    )       p   n  +  2    -   2   p   n  +  1      +   p  n         absent           superscript   subscript  p  n   2      subscript  p  n    subscript  p    n  2        2   subscript  p  n    subscript  p    n  1           superscript   subscript  p  n   2     2   subscript  p  n    subscript  p    n  1       superscript   subscript  p    n  1    2          subscript  p    n  2      2   subscript  p    n  1       subscript  p  n       =\frac{(p_{n}^{2}+p_{n}p_{n+2}-2p_{n}p_{n+1})-(p_{n}^{2}-2p_{n}p_{n+1}+p_{n+1}%
 ^{2})}{p_{n+2}-2p_{n+1}+p_{n}}          =    p  n   -     (    p   n  +  1    -   p  n    )   2      p   n  +  2    -   2   p   n  +  1      +   p  n       ,      absent     subscript  p  n      superscript     subscript  p    n  1     subscript  p  n    2        subscript  p    n  2      2   subscript  p    n  1       subscript  p  n        =p_{n}-\frac{(p_{n+1}-p_{n})^{2}}{p_{n+2}-2p_{n+1}+p_{n}},    which results in the more rapidly convergent sequence:        p  ≈   p   n  +  3    =    p  n   -     (    p   n  +  1    -   p  n    )   2      p   n  +  2    -   2   p   n  +  1      +   p  n       .        p   subscript  p    n  3            subscript  p  n      superscript     subscript  p    n  1     subscript  p  n    2        subscript  p    n  2      2   subscript  p    n  1       subscript  p  n         p\approx p_{n+3}=p_{n}-\frac{(p_{n+1}-p_{n})^{2}}{p_{n+2}-2p_{n+1}+p_{n}}.     Implementation in Matlab  Here is the source for an implementation of Steffensen's Method in MATLAB .  function Steffensen(f,p0,tol) % This function takes as inputs: a fixed point iteration function, f,  % and initial guess to the fixed point, p0, and a tolerance, tol.  % The fixed point iteration function is assumed to be input as an  % inline function.  % This function will calculate and return the fixed point, p,  % that makes the expression f(x) = p true to within the desired  % tolerance, tol. format compact % This shortens the output. format long % This prints more decimal places. for i= 1 : 1000  % get ready to do a large, but finite, number of iterations.  % This is so that if the method fails to converge, we won't  % be stuck in an infinite loop. p1=f(p0); % calculate the next two guesses for the fixed point. p2=f(p1);
     p=p0-(p1-p0)^ 2 /(p2- 2 *p1+p0) % use Aitken's delta squared method to  % find a better approximation to p0. if abs(p-p0) %="" abs(p-p0)="" answer.="" are="" are,="" break="" end="" for="" have="" if="" iteration.="" iterations,="" next="" our="" p0="" see="" stop="" test="" the="" to="" tolerance.="" update="" we="" within="">tol       % If we fail to meet the tolerance, we output a  % message of failure.  'failed to converge in 1000 iterations.' end Generalization  Steffensen's method can also be used to find an input    x  =   x  ⋆       x   subscript  x  normal-⋆     x=x_{\star}   for a different kind of function   F   F   F   that produces output the same as its input     x  ⋆   =   F   (   x  ⋆   )         subscript  x  normal-⋆     F   subscript  x  normal-⋆      x_{\star}=F(x_{\star})   for the special value    x  ⋆     subscript  x  normal-⋆    x_{\star}   . Solutions like    x  ⋆     subscript  x  normal-⋆    x_{\star}   are called fixed points . Many such functions can be used to find their own solutions by repeatedly recycling the result back as input, but the rate of convergence can be slow, or the function can fail to converge at all, depending on the individual function. Steffensen's method accelerates this convergence, to make it quadratic .  This method for finding fixed points of a real-valued function has been generalised for functions    F  :   X  →  X      normal-:  F   normal-→  X  X     F:X\to X   on a Banach space    X   X   X   . The generalised method assumes that a family of bounded  linear operators     {   L   (  u  ,  v  )    :    u  ,  v   ∈  X   }     conditional-set    L   u  v       u  v   X     \{L(u,v):u,v\in X\}   associated with   u   u   u   and   v   v   v   can be found to satisfy the condition 2         F   (  u  )    -   F   (  v  )     =   L   (  u  ,  v  )    (   u  -  v   )     .          F  u     F  v      L   u  v     u  v      F(u)-F(v)=L(u,v)\ (u-v).     In the simple form given in the section above, the function   f   f   f   simply takes in and produces real numbers. There, the function   g   g   g   is a divided difference . In the generalized form here, the operator   L   L   L   is the analogue of a divided difference for use in the Banach space . The operator   L   L   L   is equivalent to a matrix whose entries are all functions of vector  arguments    u   u   u   and   v   v   v   .  Steffensen's method is then very similar to the Newton's method, except that it uses the divided difference    L   (   F   (  x  )    ,  x  )       L     F  x   x     L(F(x),x)   instead of the derivative     F  ′    (  x  )        superscript  F  normal-′   x    F^{\prime}(x)   . It is thus defined by        x   n  +  1    =    x  n   +     [   I  -   L   (   F   (   x  n   )    ,   x  n   )     ]    -  1     (    F   (   x  n   )    -   x  n    )      ,       subscript  x    n  1       subscript  x  n      superscript   delimited-[]    I    L     F   subscript  x  n     subscript  x  n         1        F   subscript  x  n     subscript  x  n        x_{n+1}=x_{n}+[I-L(F(x_{n}),x_{n})]^{-1}(F(x_{n})-x_{n}),     for    n  =   1  ,  2  ,  3  ,  …       n   1  2  3  normal-…     n=1,\ 2,\ 3,\ ...   , and where   I   I   I   is the identity operator.  If the operator   L   L   L   satisfies       ∥    L   (  u  ,  v  )    -   L   (  x  ,  y  )     ∥   ≤   K   (    ∥   u  -  x   ∥   +   ∥   v  -  y   ∥    )         norm      L   u  v      L   x  y        K     norm    u  x     norm    v  y        \|L(u,v)-L(x,y)\|\leq K\big(\|u-x\|+\|v-y\|\big)     for some constant   K   K   K   , then the method converges quadratically to a fixed point of   F   F   F   if the initial approximation    x  0     subscript  x  0    x_{0}   is "sufficiently close" to the desired solution    x  ⋆     subscript  x  normal-⋆    x_{\star}   , that satisfies     x  ⋆   =   F   (   x  ⋆   )         subscript  x  normal-⋆     F   subscript  x  normal-⋆      x_{\star}=F(x_{\star})   .  References    "  Category:Root-finding algorithms     Germund Dahlquist , Åke Björck, tr. Ned Anderson. (1974). Numerical Methods , pp. 230–231. Englewood Cliffs, NJ: Prentice Hall. ↩  Johnson, L. W. & Scholz, D. R. (1968). On Steffensen's Method. SIAM Journal on Numerical Analysis , 5 (2), 296–302, (June 1968). Stable URL: 1 ↩   