<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1997">Program structure tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Program structure tree</h1>
<hr/>

<p>A <strong>program structure tree</strong> (PST) is a <a class="uri" href="hierarchical" title="wikilink">hierarchical</a> diagram that displays the nesting relationship of <a href="single-entry_single-exit" title="wikilink">single-entry single-exit</a> (SESE) fragments/regions, showing the organization of a <a href="computer_program" title="wikilink">computer program</a>. Nodes in this tree represent SESE regions of the program, while edges represent <a href="nesting_(computing)" title="wikilink">nesting</a> regions. The PST is defined for all control flow graphs.</p>
<h2 id="bibliographical-notes">Bibliographical Notes</h2>

<p>These notes list important works which fueled research on parsing of programs and/or (work)flow graphs (adapted from Section 3.5 in ).</p>
<ul>
<li>The connectivity properties are the basic properties of graphs and are useful when testing whether a graph is planar or when determining if two graphs are isomorphic. John Hopcroft and Robert Endre Tarjan (1973) developed an optimal (to within a constant factor) algorithm for dividing a graph into triconnected components.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The algorithm is based on the depth-first search of graphs and requires 

<math display="inline" id="Program_structure_tree:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>V</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>E</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <abs></abs>
      <ci>V</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|V|+|E|)
  </annotation>
 </semantics>
</math>

 time and space to examine a graph with 

<math display="inline" id="Program_structure_tree:1">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>V</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|
  </annotation>
 </semantics>
</math>

 vertices and 

<math display="inline" id="Program_structure_tree:2">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>E</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E|
  </annotation>
 </semantics>
</math>

 edges.</li>
</ul>
<ul>
<li>Robert Endre Tarjan and Jacobo Valdes (1980) used triconnected components for structural analysis of biconnected flow graphs.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The triconnected components of the undirected version of a flow graph are shown to be useful for discovering structural information of directed flow graphs. The triconnected components can be discovered efficiently and form a hierarchy of SESE fragments of a flow graph.</li>
</ul>
<ul>
<li>Giuseppe Di Battista and Roberto Tamassia (1990) introduced SPQR-trees<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> - a data structure which represents decomposition of a biconnected graph with respect to its triconnected components. Essentially, SPQR-trees are the parse trees of Tarjan and Valdes.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The authors showed the usefulness of SPQR-trees for various on-line graph algorithms, e.g., transitive closure, planarity testing, and minimum spanning tree.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In particular, the authors proposed an efficient solution to the problem of on-line maintenance of the triconnected components of a graph.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul>
<ul>
<li>Richard C. Johnson et al. (1994) proposed a program structure tree (PST), a hierarchical representation of program structure based on single edge entry and single edge exit regions.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The PST can be computed in 

<math display="inline" id="Program_structure_tree:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>E</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <abs></abs>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|E|)
  </annotation>
 </semantics>
</math>

 time for an arbitrary flow graph, where 

<math display="inline" id="Program_structure_tree:4">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is the set of edges in the graph. The disadvantage of the PST is that it exploits the notion of a SESE fragment based on edge entries and exits only. Thus, the PST does not capture those SESE fragments which are based on vertex entries and exits.</li>
</ul>
<ul>
<li>Carsten Gutwenger and <a href="Petra_Mutzel" title="wikilink">Petra Mutzel</a> (2001) shared their practical experience on linear time computation of the triconnected components of biconnected graphs.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> They have identified and corrected the faulty parts of the algorithm in<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and applied the resulting algorithm to the computation of SPQR-trees. The implementation is publically available.</li>
</ul>
<ul>
<li>Chun Ouyang et al. (2006-2009) used parsing to translate BPMN diagrams into BPEL processes.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The employed notion of a fragment is similar to the notion of a region in.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> However, the developed parsing algorithm is non-deterministic, i.e., the parse tree is not unique for a given diagram.</li>
</ul>
<ul>
<li>Jussi Vanhatalo et al. (2008-2009) introduced the Refined Process Structure Tree (RPST).<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Given a workflow graph, the RPST is unique, modular, and is finer grained than any other known parse tree, i.e., it discovers more SESE fragments than any other technique. In fact, the RPST captures all canonical fragments of a workflow graph which, in turn, represent all SESE fragments of the graph. The RPST can be computed for an arbitrary program/workflow graph.</li>
</ul>
<ul>
<li>Artem Polyvyanyy, Jussi Vanhatalo, and Hagen Voelzer (2010) proposed a simplified algorithm for computation of the RPST.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> This simplified algorithm can be employed in a straightforward way as a subroutine for computation of the RPST of an arbitrary program/workflow graph. Both algorithms, the original and the simplified one, allow for an eﬃcient computation of the RPST. However, they provide different structural characterizations of canonical SESE fragments.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://code.google.com/p/jbpt/">Java implementation of the Refined Process Structure Tree</a> in the jBPT library (see RPST class in jbpt-deco module). The implementation follows the algorithm described in<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Programming_constructs" title="wikilink">Category:Programming constructs</a> <a href="Category:Trees_(data_structures)" title="wikilink">Category:Trees (data structures)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
</ol>
</section>
</body>
</html>
