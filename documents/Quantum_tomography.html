<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="35">Quantum tomography</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum tomography</h1>
<hr>'''Quantum [[tomography]]''' or '''quantum state tomography''' is the process of reconstructing the [[quantum state]] ([[density matrix]]) for a source of quantum systems by measurements on the systems coming from the source.<ref>Quantum State Tomography. http://research.physics.uiuc.edu/QI/Photonics/Tomography/#what_is_tomography</ref> The source may be any device or system which prepare
<p>s quantum states either consistently into quantum <a href="pure_states" title="wikilink">pure states</a> or otherwise into general <a href="mixed_state_(physics)" title="wikilink">mixed states</a>. To be able to uniquely identify the state, the measurements must be <strong>tomographically complete</strong>. That is, the measured <a href="Operator_(mathematics)" title="wikilink">operators</a> must form an <a href="Operator_(mathematics)" title="wikilink">operator</a> <a href="basis_(linear_algebra)" title="wikilink">basis</a> on the <a href="Hilbert_space" title="wikilink">Hilbert space</a> of the system, providing all the information about the state. Such a set of observations is sometimes called a <strong>quorum</strong>.  </p>

<p>In <strong>quantum process tomography</strong> on the other hand, known <a href="quantum_states" title="wikilink">quantum states</a> are used to probe a quantum process to find out how the process can be described. Similarly, <strong>quantum measurement tomography</strong> works to find out what measurement is being performed.</p>

<p>The general principle behind quantum state tomography is that by repeatedly performing many different measurements on quantum systems described by identical density matrices, frequency counts can be used to infer <a class="uri" href="probabilities" title="wikilink">probabilities</a>, and these probabilities are combined with <a href="Born's_rule" title="wikilink">Born's rule</a> to determine a <a href="density_matrix" title="wikilink">density matrix</a> which fits the best with the observations.</p>

<p>This can be easily understood by making a classical analogy. Let us consider a <a href="harmonic_oscillator" title="wikilink">harmonic oscillator</a> (e.g. a pendulum). The <a href="Position_(vector)" title="wikilink">position</a> and <a class="uri" href="momentum" title="wikilink">momentum</a> of the oscillator at any given point can be measured and therefore the motion can be completely described by the <a href="phase_space" title="wikilink">phase space</a>. This is shown in figure 1. By performing this measurement for a large number of identical oscillators we get a possibility distribution in the <a href="phase_space" title="wikilink">phase space</a> (figure 2). This distribution can be normalized (the oscillator at a given time has to be somewhere) and the distribution must be non-negative. So we have retrieved a function W(x,p) which gives a description of the chance of finding the particle at a given point with a given momentum. For quantum mechanical particles the same can be done. The only difference is that the Heisenberg’s <a href="uncertainty_principle" title="wikilink">uncertainty principle</a> mustn’t be violated, meaning that we cannot measure the particle’s momentum and position at the same time. The particle’s momentum and its position are called quadratures (see <a href="Optical_phase_space" title="wikilink">Optical phase space</a> for more information) in quantum related states. By measuring one of the quadratures of a large number of identical quantum states will give us a probability density corresponding to that particular quadrature. This is called the <a href="marginal_distribution" title="wikilink">marginal distribution</a>, pr(X) or pr(P) (see figure 3). In the following text we will see that this probability density is needed to characterize the particle’s quantum state, which is the whole point of quantum tomography. </p>
<h2 id="what-quantum-state-tomography-is-used-for">What quantum state tomography is used for</h2>

<p>Quantum tomography is applied on a source of systems, to determine what the <a href="quantum_state" title="wikilink">quantum state</a> is of the output of that source. Unlike a measurement on a single system, which determines the system's current state after the measurement (in general, the act of making a measurement alters the quantum state), quantum tomography works to determine the state(s) prior to the measurements.</p>

<p>Quantum tomography can be used for characterizing optical signals, including measuring the signal gain and loss of optical devices,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> as well as in <a href="quantum_computing" title="wikilink">quantum computing</a> and <a href="quantum_information_theory" title="wikilink">quantum information theory</a> to reliably determine the actual states of the <a class="uri" href="qubits" title="wikilink">qubits</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> One can imagine a situation in which a person Bob prepares some <a href="quantum_states" title="wikilink">quantum states</a> and then gives the states to Alice to look at. Not confident with Bob's description of the states, Alice may wish to do quantum tomography to classify the states herself.</p>
<h2 id="methods-of-quantum-state-tomography">Methods of quantum state tomography</h2>
<h3 id="linear-inversion">Linear inversion</h3>

<p>Using <a href="Born's_rule" title="wikilink">Born's rule</a>, one can derive the simplest form of quantum tomography. If it is known in advance that the state is represented by a <a href="pure_state" title="wikilink">pure state</a>, a single measurement can be performed repeatedly to build up a <a class="uri" href="histogram" title="wikilink">histogram</a> which can then be used to express the pure state in the <a href="basis_(linear_algebra)" title="wikilink">basis</a> of the measurement. Generally, being in a pure state is not known, and a state may be mixed. In this case, many different measurements will have to be performed, many times each. To fully reconstruct the <a href="density_matrix" title="wikilink">density matrix</a> for a <a href="mixed_state_(physics)" title="wikilink">mixed state</a> in a <a class="uri" href="finite-dimensional" title="wikilink">finite-dimensional</a> <a href="Hilbert_space" title="wikilink">Hilbert space</a>, the following technique may be used.</p>

<p><a href="Born's_rule" title="wikilink">Born's rule</a> states 

<math display="inline" id="Quantum_tomography:0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>E</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>Trace</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>E</mi>
     <mi>i</mi>
    </msub>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">Trace</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
     <csymbol cd="unknown">ρ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(E_{i}|\rho)=\mathrm{Trace}(E_{i}\rho)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Quantum_tomography:1">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}
  </annotation>
 </semantics>
</math>

 is a particular measurement outcome <a href="Projection_(linear_algebra)" title="wikilink">projector</a> and 

<math display="inline" id="Quantum_tomography:2">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 is the density matrix of the system. Given a <a class="uri" href="histogram" title="wikilink">histogram</a> of observations for each measurement, one has an approximation 

<math display="inline" id="Quantum_tomography:3">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Quantum_tomography:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>E</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(E_{i}|\rho)
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Quantum_tomography:5">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>Given <a href="linear_operators" title="wikilink">linear operators</a> 

<math display="inline" id="Quantum_tomography:6">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_tomography:7">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, define the inner product</p>

<p>

<math display="block" id="Quantum_tomography:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>⋅</mo>
    <mi>T</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Tr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msup>
       <mi>S</mi>
       <mo>†</mo>
      </msup>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mover accent="true">
      <mi>S</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>†</mo>
    </msup>
    <mover accent="true">
     <mi>T</mi>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-⋅</ci>
      <ci>S</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Tr</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <ci>normal-†</ci>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>S</ci>
       </apply>
       <ci>normal-†</ci>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cdot T=\mathrm{Tr}[S^{\dagger}T]=\vec{S}^{\dagger}\vec{T}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Quantum_tomography:9">
 <semantics>
  <mover accent="true">
   <mi>T</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{T}
  </annotation>
 </semantics>
</math>

 is representation of the 

<math display="inline" id="Quantum_tomography:10">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 operator as a column vector and 

<math display="inline" id="Quantum_tomography:11">
 <semantics>
  <msup>
   <mover accent="true">
    <mi>S</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>†</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
    </apply>
    <ci>normal-†</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{S}^{\dagger}
  </annotation>
 </semantics>
</math>

 a row vector such that 

<math display="inline" id="Quantum_tomography:12">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mi>S</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>†</mo>
   </msup>
   <mover accent="true">
    <mi>T</mi>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>S</ci>
     </apply>
     <ci>normal-†</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{S}^{\dagger}\vec{T}
  </annotation>
 </semantics>
</math>

 is the inner product in 

<math display="inline" id="Quantum_tomography:13">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{d}
  </annotation>
 </semantics>
</math>


 of the two.</p>

<p>Define the matrix 

<math display="inline" id="Quantum_tomography:14">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Quantum_tomography:15">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msubsup>
        <mover accent="true">
         <mi>E</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mn>1</mn>
        <mo>†</mo>
       </msubsup>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msubsup>
        <mover accent="true">
         <mi>E</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mn>2</mn>
        <mo>†</mo>
       </msubsup>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msubsup>
        <mover accent="true">
         <mi>E</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mn>3</mn>
        <mo>†</mo>
       </msubsup>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-→</ci>
         <ci>E</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-†</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-→</ci>
         <ci>E</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-†</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-→</ci>
         <ci>E</ci>
        </apply>
        <cn type="integer">3</cn>
       </apply>
       <ci>normal-†</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{pmatrix}\vec{E}_{1}^{\dagger}\\
\vec{E}_{2}^{\dagger}\\
\vec{E}_{3}^{\dagger}\\
\vdots\end{pmatrix}
  </annotation>
 </semantics>
</math>

. Here <em>E</em><sub>i</sub> is some fixed list of individual measurements (with binary outcomes), and <em>A</em> does all the measurements at once.</p>

<p>Then applying this to 

<math display="inline" id="Quantum_tomography:16">
 <semantics>
  <mover accent="true">
   <mi>ρ</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{\rho}
  </annotation>
 </semantics>
</math>

 yields the <a class="uri" href="probabilities" title="wikilink">probabilities</a>:</p>

<p>

<math display="block" id="Quantum_tomography:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mover accent="true">
     <mi>ρ</mi>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>E</mi>
         <mn>1</mn>
         <mo>†</mo>
        </msubsup>
        <mover accent="true">
         <mi>ρ</mi>
         <mo stretchy="false">→</mo>
        </mover>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>E</mi>
         <mn>2</mn>
         <mo>†</mo>
        </msubsup>
        <mover accent="true">
         <mi>ρ</mi>
         <mo stretchy="false">→</mo>
        </mover>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>E</mi>
         <mn>3</mn>
         <mo>†</mo>
        </msubsup>
        <mover accent="true">
         <mi>ρ</mi>
         <mo stretchy="false">→</mo>
        </mover>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>E</mi>
         <mn>1</mn>
        </msub>
        <mo>⋅</mo>
        <mi>ρ</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>E</mi>
         <mn>2</mn>
        </msub>
        <mo>⋅</mo>
        <mi>ρ</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>E</mi>
         <mn>3</mn>
        </msub>
        <mo>⋅</mo>
        <mi>ρ</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi mathvariant="normal">P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>E</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">|</mo>
         <mi>ρ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi mathvariant="normal">P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>E</mi>
          <mn>2</mn>
         </msub>
         <mo stretchy="false">|</mo>
         <mi>ρ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi mathvariant="normal">P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>E</mi>
          <mn>3</mn>
         </msub>
         <mo stretchy="false">|</mo>
         <mi>ρ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>p</mi>
        <mn>1</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>p</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>p</mi>
        <mn>3</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mover accent="true">
    <mi>p</mi>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>ρ</ci>
      </apply>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-†</ci>
        </apply>
        <apply>
         <ci>normal-→</ci>
         <ci>ρ</ci>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-†</ci>
        </apply>
        <apply>
         <ci>normal-→</ci>
         <ci>ρ</ci>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <cn type="integer">3</cn>
         </apply>
         <ci>normal-†</ci>
        </apply>
        <apply>
         <ci>normal-→</ci>
         <ci>ρ</ci>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>ρ</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>ρ</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <cn type="integer">3</cn>
        </apply>
        <ci>ρ</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">P</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-|</ci>
         <csymbol cd="unknown">ρ</csymbol>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
      </matrixrow>
      <matrixrow>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">P</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-|</ci>
         <csymbol cd="unknown">ρ</csymbol>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
      </matrixrow>
      <matrixrow>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">P</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <cn type="integer">3</cn>
         </apply>
         <ci>normal-|</ci>
         <csymbol cd="unknown">ρ</csymbol>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">3</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-→</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vec{\rho}=\begin{pmatrix}E_{1}^{\dagger}\vec{\rho}\\
E_{2}^{\dagger}\vec{\rho}\\
E_{3}^{\dagger}\vec{\rho}\\
\vdots\end{pmatrix}=\begin{pmatrix}E_{1}\cdot\rho\\
E_{2}\cdot\rho\\
E_{3}\cdot\rho\\
\vdots\end{pmatrix}=\begin{pmatrix}\mathrm{P}(E_{1}|\rho)\\
\mathrm{P}(E_{2}|\rho)\\
\mathrm{P}(E_{3}|\rho)\\
\vdots\end{pmatrix}\approx\begin{pmatrix}p_{1}\\
p_{2}\\
p_{3}\\
\vdots\end{pmatrix}=\vec{p}
  </annotation>
 </semantics>
</math>

.</p>

<p>Linear inversion corresponds to inverting this system using the observed relative frequencies 

<math display="inline" id="Quantum_tomography:18">
 <semantics>
  <mover accent="true">
   <mi>p</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{p}
  </annotation>
 </semantics>
</math>


 to derive 

<math display="inline" id="Quantum_tomography:19">
 <semantics>
  <mover accent="true">
   <mi>ρ</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{\rho}
  </annotation>
 </semantics>
</math>

 (which is isomorphic to 

<math display="inline" id="Quantum_tomography:20">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\rho
  </annotation>
 </semantics>
</math>

).</p>

<p>This system is not going to be square in general, as for each measurement being made there will generally be multiple measurement outcome <a href="Projection_(linear_algebra)" title="wikilink">projectors</a> 

<math display="inline" id="Quantum_tomography:21">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}
  </annotation>
 </semantics>
</math>

. For example, in a 2-D <a href="Hilbert_space" title="wikilink">Hilbert space</a> with 3 measurements 

<math display="inline" id="Quantum_tomography:22">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>x</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>σ</mi>
    <mi>y</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>σ</mi>
    <mi>z</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>z</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{x},\sigma_{y},\sigma_{z}
  </annotation>
 </semantics>
</math>

, each measurement has 2 outcomes, each of which has a projector <em>E</em><sub>i</sub>, for 6 projectors, whereas the real dimension of the space of density matrices is (2⋅2<sup>2</sup>)/2=4, leaving 

<math display="inline" id="Quantum_tomography:23">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 to be 6 x 4. To solve the system, multiply on the left by 

<math display="inline" id="Quantum_tomography:24">
 <semantics>
  <msup>
   <mi>A</mi>
   <mi>T</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{T}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Quantum_tomography:25">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>T</mi>
    </msup>
    <mi>A</mi>
    <mover accent="true">
     <mi>ρ</mi>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>T</mi>
    </msup>
    <mover accent="true">
     <mi>p</mi>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>T</ci>
     </apply>
     <ci>A</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>ρ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{T}A\vec{\rho}=A^{T}\vec{p}
  </annotation>
 </semantics>
</math>

. Now solving for 

<math display="inline" id="Quantum_tomography:26">
 <semantics>
  <mover accent="true">
   <mi>ρ</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{\rho}
  </annotation>
 </semantics>
</math>

 yields the <a class="uri" href="pseudoinverse" title="wikilink">pseudoinverse</a>:</p>

<p>

<math display="block" id="Quantum_tomography:27">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>ρ</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mi>T</mi>
       </msup>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>A</mi>
     <mi>T</mi>
    </msup>
    <mover accent="true">
     <mi>p</mi>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>ρ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>T</ci>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{\rho}=(A^{T}A)^{-1}A^{T}\vec{p}
  </annotation>
 </semantics>
</math>

.</p>

<p>This works in general only if the measurement list <em>E</em><sub>i</sub> is tomographically complete. Otherwise, the matrix 

<math display="inline" id="Quantum_tomography:28">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mi>T</mi>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{T}A
  </annotation>
 </semantics>
</math>


 will not be <a class="uri" href="invertible" title="wikilink">invertible</a>.</p>
<h4 id="continuous-variables-and-quantum-homodyne-tomography">Continuous variables and quantum homodyne tomography</h4>

<p>In infinite dimensional <a href="Hilbert_spaces" title="wikilink">Hilbert spaces</a>, e.g. in measurements of continuous variables such as position, the methodology is somewhat more complex. One notable example is in the <a class="uri" href="tomography" title="wikilink">tomography</a> of <a class="uri" href="light" title="wikilink">light</a>, known as optical <a class="uri" href="homodyne" title="wikilink">homodyne</a> <a class="uri" href="tomography" title="wikilink">tomography</a>. Using balanced <a class="uri" href="homodyne" title="wikilink">homodyne</a> measurements, one can derive the <a href="Wigner_function" title="wikilink">Wigner function</a> and a <a href="density_matrix" title="wikilink">density matrix</a> for the state of the <a class="uri" href="light" title="wikilink">light</a>.</p>

<p>One approach involves measurements along different rotated directions in <a href="phase_space" title="wikilink">phase space</a>. For each direction 

<math display="inline" id="Quantum_tomography:29">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

, one can find a <a href="probability_distribution" title="wikilink">probability distribution</a> 

<math display="inline" id="Quantum_tomography:30">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <interval closure="open">
     <ci>q</ci>
     <ci>θ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(q,\theta)
  </annotation>
 </semantics>
</math>

 for the <a href="probability_density_function" title="wikilink">probability density</a> of measurements in the 

<math display="inline" id="Quantum_tomography:31">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 direction of phase space yielding the value 

<math display="inline" id="Quantum_tomography:32">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

. Using an inverse <a href="Radon_transformation" title="wikilink">Radon transformation</a> (the filtered back projection) on 

<math display="inline" id="Quantum_tomography:33">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <interval closure="open">
     <ci>q</ci>
     <ci>θ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(q,\theta)
  </annotation>
 </semantics>
</math>


 leads to the <a href="Wigner_function" title="wikilink">Wigner function</a>, 

<math display="inline" id="Quantum_tomography:34">
 <semantics>
  <mrow>
   <mi mathvariant="normal">W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-W</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>p</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{W}(x,p)
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> which can be converted by an <a href="inverse_fourier_transform" title="wikilink">inverse fourier transform</a> into the <a href="density_matrix" title="wikilink">density matrix</a> for the state in any basis.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> A similar technique is often used in <a href="tomography" title="wikilink">medical tomography</a>.</p>
<h4 id="example-homodyne-tomography.">Example homodyne tomography.</h4>

<p>Field amplitudes or quadratures with high efficiencies can be measured with <a class="uri" href="photodetectors" title="wikilink">photodetectors</a> together with temporal mode selectivity. Balanced homodyne tomography is a reliable technique of reconstructing <a href="quantum_state" title="wikilink">quantum states</a> in the optical domain. This technique combines the advantages of the high efficiencies of photodiodes in measuring the intensity or <a href="photon_number" title="wikilink">photon number</a> of light, together with measuring the quantum features of light by a clever set-up called the homodyne <a class="uri" href="tomography" title="wikilink">tomography</a> detector. This is explained by the following example. A <a class="uri" href="laser" title="wikilink">laser</a> is directed onto a 50-50% <a class="uri" href="beamsplitter" title="wikilink">beamsplitter</a>, splitting the laserbeam into two beams. One is used as <a href="local_oscillator" title="wikilink">local oscillator</a> (LO) and the other is used to generate photons with a particular <a href="quantum_state" title="wikilink">quantum state</a>. The generation of quantum states can be realized, e.g. by directing the laser beam through a <a href="frequency_doubling" title="wikilink">frequency doubling</a> <a class="uri" href="crystal" title="wikilink">crystal</a> <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and then onto a <a href="parametric_down-conversion" title="wikilink">parametric down-conversion</a> crystal. This crystal generates two photons in a certain quantum state. One of the photons is used as a trigger signal used to trigger (start) the readout event of the homodyne tomography detector. The other photon is directed into the homodyne tomography detector, in order to reconstruct its quantum state. Since the trigger and signal photons are <a href="Quantum_entanglement" title="wikilink">entangled</a> (this is explained by the Spontaneous <a href="parametric_down-conversion" title="wikilink">parametric down-conversion</a> article), it is important to realize, that the <a href="optical_mode" title="wikilink">optical mode</a> of the signal state is created nonlocal only when the trigger photon impinges the photodetector (of the trigger event readout module) and is actually measured. More simply said, it is only when the trigger photon is measured, that the signal photon can be measured by the homodyne detector.</p>

<p>Now let us consider the <a class="uri" href="homodyne" title="wikilink">homodyne</a> <a class="uri" href="tomography" title="wikilink">tomography</a> detector as depicted in figure 4. The signal photon (this is the <a href="quantum_state" title="wikilink">quantum state</a> we want to reconstruct) interferes with the <a href="local_oscillator" title="wikilink">local oscillator</a>, when they are directed onto a 50-50% <a class="uri" href="beamsplitter" title="wikilink">beamsplitter</a>. Since the two beams originate from the same so called master <a class="uri" href="laser" title="wikilink">laser</a>, they have the same fixed <a href="Phase_(waves)" title="wikilink">phase</a> relation. The local oscillator must be intense, compared to the signal so it provides a precise phase reference. The local oscillator is so intense, that we can treat it classically (a = α) and neglect the quantum fluctuations. The signal field is spatially and temporally controlled by the local oscillator, which has a controlled shape. Where the local oscillator is zero, the signal is rejected. Therefore, we have temporal-spatial mode selectivity of the signal. The beamsplitter redirects the two beams to two photodetectors. The photodetectors generate an <a href="electric_current" title="wikilink">electric current</a> proportional to the <a href="photon_number" title="wikilink">photon number</a>. The two detector currents are subtracted and the resulting current is proportional to the electric <a href="field_operator" title="wikilink">field operator</a> in the signal mode, depended on relative optical phase of signal and local oscillator.</p>

<p>Since the electric field amplitude of the local oscillator is much higher than that of the signal the intensity or fluctuations in the signal field can be seen. The homodyne tomography system functions as an <a class="uri" href="amplifier" title="wikilink">amplifier</a>. The system can be seen as an <a class="uri" href="interferometer" title="wikilink">interferometer</a> with such a high intensity reference beam (the local oscillator) that unbalancing the interference by a single photon in the signal is measurable. This amplification is well above the photodetectors <a href="noise_floor" title="wikilink">noise floor</a>.</p>

<p>The measurement is reproduced a large number of times. Then the phase difference between the signal and local oscillator is changed in order to ‘scan’ a different <a class="uri" href="angle" title="wikilink">angle</a> in the <a href="phase_space" title="wikilink">phase space</a>. This can be seen from figure 4. The measurement is repeated again a large number of times and a <a href="marginal_distribution" title="wikilink">marginal distribution</a> is retrieved from the current difference. The <a href="marginal_distribution" title="wikilink">marginal distribution</a> can be transformed into the <a href="density_matrix" title="wikilink">density matrix</a> and/or the <a href="Wigner_function" title="wikilink">Wigner function</a>. Since the <a href="density_matrix" title="wikilink">density matrix</a> and the <a href="Wigner_function" title="wikilink">Wigner function</a> give information about the <a href="quantum_state" title="wikilink">quantum state</a> of the photon, we have reconstructed the quantum state of the photon.</p>

<p>The advantage of this method is that this arrangement is insensitive to fluctuations in the <a class="uri" href="frequency" title="wikilink">frequency</a> of the <a class="uri" href="laser" title="wikilink">laser</a>.</p>

<p>The quantum computations for retrieving the quadrature component from the current difference are performed as follows.</p>

<p>The <a href="photon_number" title="wikilink">photon number</a> <a href="Operator_(mathematics)" title="wikilink">operator</a> for the beams striking the photodetectors after the beamsplitter is given by:</p>

<p>

<math display="block" id="Quantum_tomography:35">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>n</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>i</mi>
     <mo>†</mo>
    </msubsup>
    <msub>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>n</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>a</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>normal-†</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>a</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{n}_{i}=\hat{a}_{i}^{\dagger}\hat{a}_{i}
  </annotation>
 </semantics>
</math>

, where i is 1 and 2, for respectively beam one and two. The mode operators of the field emerging the beamsplitters are given by:</p>

<p>

<math display="block" id="Quantum_tomography:36">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>a</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>α</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo>-</mo>
      <msub>
       <mi>α</mi>
       <mrow>
        <mi>L</mi>
        <mi>O</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>a</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-^</ci>
       <ci>α</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>O</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{a}_{1}=2^{-1/2}(\hat{\alpha}-\alpha_{LO})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantum_tomography:37">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>a</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>a</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{a}_{2}=2^{-1/2}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_tomography:38">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mover accent="true">
     <mi>α</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>+</mo>
    <msub>
     <mi>α</mi>
     <mrow>
      <mi>L</mi>
      <mi>O</mi>
     </mrow>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-^</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>O</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{\alpha}+\alpha_{LO})
  </annotation>
 </semantics>
</math>


 The 

<math display="inline" id="Quantum_tomography:39">
 <semantics>
  <mover accent="true">
   <mi>a</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{a}
  </annotation>
 </semantics>
</math>

 denotes the annihilation operator of the signal and alpha the complex amplitude of the local oscillator. The number of photon difference is eventually proportional to the quadrature and given by:</p>

<p>

<math display="block" id="Quantum_tomography:40">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>n</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>21</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>n</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>2</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mi>n</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>α</mi>
      <mrow>
       <mi>L</mi>
       <mi>O</mi>
      </mrow>
      <mo>*</mo>
     </msubsup>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mrow>
       <mi>L</mi>
       <mi>O</mi>
      </mrow>
     </msub>
     <msup>
      <mover accent="true">
       <mi>a</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo>†</mo>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">21</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>α</ci>
         <times></times>
        </apply>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>O</ci>
        </apply>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>a</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>O</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>a</ci>
        </apply>
        <ci>normal-†</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{n}_{21}=\hat{n}_{2}-\hat{n}_{1}=\alpha^{*}_{LO}\hat{a}+\alpha_{LO}\hat{a}%
^{\dagger}
  </annotation>
 </semantics>
</math>

, Rewriting this with the relation:</p>

<p>

<math display="block" id="Quantum_tomography:41">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>q</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo>†</mo>
      </msup>
      <mo>+</mo>
      <mover accent="true">
       <mi>a</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>a</ci>
       </apply>
       <ci>normal-†</ci>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{q}=2^{-1/2}(\hat{a}^{\dagger}+\hat{a})
  </annotation>
 </semantics>
</math>

 Results in the following relation:</p>

<p>

<math display="block" id="Quantum_tomography:42">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>n</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>21</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mover accent="true">
       <mi>α</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mrow>
       <mi>L</mi>
       <mi>O</mi>
      </mrow>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <msub>
     <mover accent="true">
      <mi>q</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>θ</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">21</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>α</ci>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>O</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>q</ci>
      </apply>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{n}_{21}=2^{1/2}|\hat{\alpha}_{LO}|\hat{q}_{\theta}
  </annotation>
 </semantics>
</math>

, where we see clear relation between the <a href="photon_number" title="wikilink">photon number</a> difference and the quadrature component 

<math display="inline" id="Quantum_tomography:43">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>q</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>θ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>q</ci>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{q}_{\theta}
  </annotation>
 </semantics>
</math>


. By keeping track of the sum current, one can recover information about the local oscillator’s intensity, since this is usually an unknown quantity, but an important quantity for calculating the quadrature component 

<math display="inline" id="Quantum_tomography:44">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>q</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>θ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>q</ci>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{q}_{\theta}
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="problems-with-linear-inversion">Problems with linear inversion</h4>

<p>One of the primary problems with using linear inversion to solve for the <a href="density_matrix" title="wikilink">density matrix</a> is that in general the computed solution will not be a valid density matrix. For example, it could give negative <a class="uri" href="probabilities" title="wikilink">probabilities</a> or probabilities greater than 1 to certain measurement outcomes. This is particularly an issue when fewer measurements are made.</p>

<p>Another issue is that in infinite dimensional <a href="Hilbert_spaces" title="wikilink">Hilbert spaces</a>, an infinite number of measurement outcomes would be required. Making assumptions about the structure and using a finite measurement basis leads to artifacts in the phase space density.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="maximum-likelihood-estimation">Maximum likelihood estimation</h3>

<p><a href="Maximum_likelihood_estimation" title="wikilink">Maximum likelihood estimation</a> (also known as MLE or MaxLik) is a popular technique for dealing with the problems of linear inversion. By restricting the domain of <a href="density_matrices" title="wikilink">density matrices</a> to the proper space, and searching for the density matrix which maximizes the <a class="uri" href="likelihood" title="wikilink">likelihood</a> of giving the experimental results, it guarantees the state to be theoretically valid while giving a close fit to the data. The likelihood of a state is the probability that would be assigned to the observed results had the system been in that state.</p>

<p>Suppose the measurements 

<math display="inline" id="Quantum_tomography:45">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\rang</mtext>
     </merror>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\lang</mtext>
     </merror>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
      <mtext>\rang</mtext>
      <mtext>\lang</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|y_{j}\rang\lang y_{j}|\}
  </annotation>
 </semantics>
</math>

 have been observed with frequencies 

<math display="inline" id="Quantum_tomography:46">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}
  </annotation>
 </semantics>
</math>

. Then the likelihood associated with a state 

<math display="inline" id="Quantum_tomography:47">
 <semantics>
  <mover accent="true">
   <mi>ρ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Quantum_tomography:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>ρ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mi>j</mi>
    </munder>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\lang</mtext>
     </merror>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <mover accent="true">
       <mi>ρ</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo stretchy="false">|</mo>
     </mrow>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
     <msup>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\rang</mtext>
      </merror>
      <msub>
       <mi>f</mi>
       <mi>j</mi>
      </msub>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>ρ</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <mtext>\lang</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <ci>normal-^</ci>
        <ci>ρ</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <mtext>\rang</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(\hat{\rho})=\prod_{j}\lang y_{j}|\hat{\rho}|y_{j}\rang^{f_{j}}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Quantum_tomography:49">
 <semantics>
  <mrow>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\lang</mtext>
   </merror>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>ρ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">|</mo>
   </mrow>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>\lang</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <ci>normal-^</ci>
      <ci>ρ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <mtext>\rang</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lang y_{j}|\hat{\rho}|y_{j}\rang
  </annotation>
 </semantics>
</math>

 is the probability of outcome 

<math display="inline" id="Quantum_tomography:50">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}
  </annotation>
 </semantics>
</math>

 for the state 

<math display="inline" id="Quantum_tomography:51">
 <semantics>
  <mover accent="true">
   <mi>ρ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}
  </annotation>
 </semantics>
</math>

.</p>

<p>Finding the maximum of this function is non-trivial and generally involves iterative methods.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The methods are an active topic of research.</p>
<h4 id="problems-with-maximum-likelihood-estimation">Problems with maximum likelihood estimation</h4>

<p>Maximum likelihood estimation suffers from some less obvious problems than linear inversion. One problem is that it makes predictions about probabilities that cannot be justified by the data. This is seen most easily by looking at the problem of zero <a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a>. The computed solution using MLE often contains <a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a> which are 0, i.e. it is <a href="rank_deficient" title="wikilink">rank deficient</a>. In these cases, the solution then lies on the <a href="Boundary_(topology)" title="wikilink">boundary</a> of the n-dimensional <a href="Bloch_sphere" title="wikilink">Bloch sphere</a>. This can be seen as related to linear inversion giving states which lie outside the valid space (the Bloch sphere). MLE in these cases picks a nearby point that is valid, and the nearest points are generally on the boundary.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>This is not physically a problem, the real state might have zero <a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a>. However, since no value may be less than 0, an estimate of an eigenvalue being 0 implies that the estimator is certain the value is 0, otherwise they would have estimated some 

<math display="inline" id="Quantum_tomography:52">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 greater than 0 with a small degree of <a class="uri" href="uncertainty" title="wikilink">uncertainty</a> as the best estimate. This is where the problem arises, in that it is not logical to conclude with absolute certainty after a finite number of measurements that any eigenvalue (that is, the probability of a particular outcome) is 0. For example, if a coin is flipped 5 times and each time heads was observed, it does not mean there is 0 probability of getting tails, despite that being the most <em>likely</em> description of the coin.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="bayesian-methods">Bayesian methods</h3>

<p><a href="Bayesian_average" title="wikilink">Bayesian</a> mean estimation (BME) is a relatively new approach which addresses the <a href="#Problems_with_maximum_likelihood_estimation" title="wikilink">problems of maximum likelihood estimation</a>. It focuses on finding optimal solutions which are also <em>honest</em> in that they include error bars in the estimate. The general idea is to start with a <a href="likelihood_function" title="wikilink">likelihood function</a> and a function describing the experimenter's prior knowledge (which might be a constant function), then integrate over all density matrices using the product of the <a href="likelihood_function" title="wikilink">likelihood function</a> and prior knowledge function as a weight.</p>

<p>Given a reasonable prior knowledge function, BME will yield a state strictly within the n-dimensional <a href="bloch_sphere" title="wikilink">bloch sphere</a>. In the case of a coin flipped N times to get N heads described above, with a constant prior knowledge function, BME would assign 

<math display="inline" id="Quantum_tomography:53">
 <semantics>
  <mstyle scriptlevel="+1">
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>N</mi>
     <mo>+</mo>
     <mn>2</mn>
    </mrow>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\frac{1}{N+2}
  </annotation>
 </semantics>
</math>


 as the probability for tails.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>BME provides a high degree of accuracy in that it minimizes the <em>operational divergences</em> of the estimate from the actual state.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="methods-for-incomplete-data">Methods for incomplete data</h3>

<p>The number of measurements needed for a full quantum state tomography for a multi-particle system scales exponentially with the number of particles, which makes such a procedure impossible even for modest system sizes. Hence, several methods have been developed to realize quantum tomography with fewer measurements.</p>

<p>The concept of <a href="matrix_completion" title="wikilink">matrix completion</a> and <a href="compressed_sensing" title="wikilink">compressed sensing</a> have been applied to reconstruct density matrices from an incomplete set of measurements (that is, a set of measurements which is not a quorum). In general, this is impossible, but under assumptions (for example, if the density matrix is a pure state, or a combination of just a few pure states) then the density matrix has fewer degrees of freedom, and it may be possible to reconstruct the state from the incomplete measurements.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Permutationally Invariant Quantum Tomography<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> is a procedure that has been developed mostly for states that are close to being permutationally symmetric, which is typical in nowadays experiments. For two-state particles, the number of measurements needed scales only quadratically with the number of particles. <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Besides the modest measurement effort, the processing of the measured data can also be done efficiently: It is possible to carry out the fitting of a physical density matrix on the measured data even for large systems. <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Permutationally Invariant Quantum Tomography has been combined with compressed sensing in a six-qubit photonic experiment.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="quantum-measurement-tomography">Quantum measurement tomography</h2>

<p>One can imagine a situation in which an apparatus performs some measurement on quantum systems, and determining what particular measurement is desired. The strategy is to send in systems of various known states, and use these states to estimate the outcomes of the unknown measurement. Also known as "quantum estimation", tomography techniques are increasingly important including those for quantum measurement tomography<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> and the very similar quantum state tomography. Since a measurement can always be characterized by a set of <a class="uri" href="POVM" title="wikilink">POVM</a>'s, the goal is to reconstruct the characterizing <a class="uri" href="POVM" title="wikilink">POVM</a>'s 

<math display="inline" id="Quantum_tomography:54">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{l}
  </annotation>
 </semantics>
</math>

. The simplest approach is linear inversion. Similar to in quantum state observation, use</p>

<p>

<math display="block" id="Quantum_tomography:55">
 <semantics>
  <mrow>
   <mi>Tr</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi mathvariant="normal">Π</mi>
     <mi>l</mi>
    </msub>
    <msub>
     <mi>ρ</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>ρ</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Tr</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Π</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathrm{Tr}[\Pi_{l}\rho_{m}]=\mathrm{P}(l|\rho_{m})
  </annotation>
 </semantics>
</math>

. Exploiting linearity as above, this can be inverted to solve for the 

<math display="inline" id="Quantum_tomography:56">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{l}
  </annotation>
 </semantics>
</math>

.</p>

<p>Not surprisingly, this suffers from the same pitfalls as in quantum state tomography. Namely, non-physical results, in particular negative probabilities. Here the 

<math display="inline" id="Quantum_tomography:57">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{l}
  </annotation>
 </semantics>
</math>

 will not be valid <a class="uri" href="POVM" title="wikilink">POVM</a>'s, as they will not be positive. Bayesian methods as well as <a href="Maximum_likelihood_estimation" title="wikilink">Maximum likelihood estimation</a> of the <a href="density_matrix" title="wikilink">density matrix</a> can be used <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> to restrict the operators to valid physical results.</p>
<h2 id="quantum-tomography-of-pre-measurement-states">Quantum tomography of pre-measurement states</h2>

<p>The main tool of the <a href="Quantum_Retrodiction" title="wikilink">retrodictive approach</a> of quantum physics is <strong>the pre-measurement state</strong> which allows predictions about state preparations of the measured system leading to a given measurement result. As it was shown in a recent work,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> such a state reveals interesting quantum properties of the corresponding measurement such as its <a href="Nonclassical_light" title="wikilink">non-classicality</a> or its <a href="Purity_(quantum_mechanics)" title="wikilink">projectivity</a>. However, we cannot realize the tomography of this state with the usual methods based on measurements, since it needs non-destructive measurements which are some particularly measurements. The experimental procedure, proposed in,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> is based on the <a href="Quantum_Retrodiction" title="wikilink">retrodictive approach</a> of quantum physics, in which we have an expression of retrodictive probabilities similar to Born's rule:</p>

<p>

<math display="block" id="Quantum_tomography:58">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo>(</mo>
    <mi>m</mi>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mi>Tr</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <msubsup>
     <mover accent="true">
      <mi>ρ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mi>t</mi>
      <mi>r</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </msubsup>
    <msub>
     <mover accent="true">
      <mi mathvariant="normal">Θ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Pr</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">Tr</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>ρ</ci>
       </apply>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>e</ci>
        <ci>t</ci>
        <ci>r</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>normal-Θ</ci>
      </apply>
      <ci>m</ci>
     </apply>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Pr}\left(m|n\right)=\mathrm{Tr}\{\hat{\rho}_{retr}^{[n]}\hat{\Theta}_{%
m}\},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Quantum_tomography:59">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi>ρ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>t</mi>
    <mi>r</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>ρ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>e</ci>
      <ci>t</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}_{retr}^{[n]}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_tomography:60">
 <semantics>
  <msub>
   <mover accent="true">
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>normal-Θ</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Theta}_{m}
  </annotation>
 </semantics>
</math>

 are respectively the pre-measurement state, corresponding to the measurement characterized by some a POVM element 

<math display="inline" id="Quantum_tomography:61">
 <semantics>
  <msub>
   <mover accent="true">
    <mi mathvariant="normal">Π</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>normal-Π</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Pi}_{n}
  </annotation>
 </semantics>
</math>

, and a hermitian and positive operator corresponding to the preparation of the measured system in a state 

<math display="inline" id="Quantum_tomography:62">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>ρ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>ρ</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}_{m}
  </annotation>
 </semantics>
</math>

. In the frame of the mathematical foundations of quantum physics, such an operator is a proposition about the state of the system, as a POVM element, and for having an exhaustive set of propositions, these operators must be a resolution of the Hilbert space:</p>

<p>

<math display="block" id="Quantum_tomography:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>m</mi>
      </munder>
     </mpadded>
     <msub>
      <mover accent="true">
       <mi mathvariant="normal">Θ</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>m</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mover accent="true">
     <mn>1</mn>
     <mo stretchy="false">^</mo>
    </mover>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>normal-Θ</ci>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{m}\,\hat{\Theta}_{m}=\hat{1}.
  </annotation>
 </semantics>
</math>

</p>

<p>From Born's, we can derive with Bayes' theorem,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> the expressions of the pre-measurement state 

<math display="inline" id="Quantum_tomography:64">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi>ρ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>t</mi>
    <mi>r</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>ρ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>e</ci>
      <ci>t</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}_{retr}^{[n]}
  </annotation>
 </semantics>
</math>

 and proposition operators 

<math display="inline" id="Quantum_tomography:65">
 <semantics>
  <msub>
   <mover accent="true">
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>normal-Θ</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Theta}_{m}
  </annotation>
 </semantics>
</math>

. The pre-measurement state simply corresponds to the normalized POVM element:</p>

<p>

<math display="block" id="Quantum_tomography:66">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi>ρ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mi>t</mi>
      <mi>r</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <msub>
      <mover accent="true">
       <mi mathvariant="normal">Π</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <mrow>
      <mi>Tr</mi>
      <mrow>
       <mo stretchy="false">{</mo>
       <msub>
        <mi mathvariant="normal">Π</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>ρ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>e</ci>
       <ci>t</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>normal-Π</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Tr</ci>
      <set>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Π</ci>
        <ci>n</ci>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}_{retr}^{[n]}=\frac{\hat{\Pi}_{n}}{\mathrm{Tr}\{\Pi_{n}\}},
  </annotation>
 </semantics>
</math>

 and the proposition operators are linked to the possible preparations of the system by:</p>

<p>

<math display="block" id="Quantum_tomography:67">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi mathvariant="normal">Θ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>m</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>D</mi>
     <msub>
      <mi class="ltx_font_mathcaligraphic">𝒫</mi>
      <mi>m</mi>
     </msub>
     <msub>
      <mover accent="true">
       <mi>ρ</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>normal-Θ</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒫</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>ρ</ci>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Theta}_{m}=D\mathcal{P}_{m}\hat{\rho}_{m},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Quantum_tomography:68">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>


 is the dimension of the Hilbert space and 

<math display="inline" id="Quantum_tomography:69">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒫</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}_{m}
  </annotation>
 </semantics>
</math>

 is the probability of preparing the state 

<math display="inline" id="Quantum_tomography:70">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>ρ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>ρ</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}_{m}
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus, we can probe the measurement apparatus with a statistical mixture:</p>

<p>

<math display="block" id="Quantum_tomography:71">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mover accent="true">
      <mi>ρ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi mathvariant="normal">?</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>m</mi>
      </munder>
     </mpadded>
     <mrow>
      <msub>
       <mi class="ltx_font_mathcaligraphic">𝒫</mi>
       <mi>m</mi>
      </msub>
      <msub>
       <mover accent="true">
        <mi>ρ</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>m</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mover accent="true">
      <mn>1</mn>
      <mo stretchy="false">^</mo>
     </mover>
     <mo>/</mo>
     <mi>D</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>ρ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>normal-?</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝒫</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>ρ</ci>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-^</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\rho}^{[?]}=\sum_{m}\,\mathcal{P}_{m}\hat{\rho}_{m}=\hat{1}/D,
  </annotation>
 </semantics>
</math>

 in order to measure the retrodictive probability 

<math display="inline" id="Quantum_tomography:72">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo>(</mo>
    <mi>m</mi>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Pr</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Pr}\left(m|n\right)
  </annotation>
 </semantics>
</math>

. This mixture could be obtained by preparations based on random choices 'm' with the probabilities 

<math display="inline" id="Quantum_tomography:73">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒫</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}_{m}
  </annotation>
 </semantics>
</math>


. Then, we replace the POVM elements describing the measurements in a usual method for the tomography of states by the operators 

<math display="inline" id="Quantum_tomography:74">
 <semantics>
  <msub>
   <mover accent="true">
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>normal-Θ</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Theta}_{m}
  </annotation>
 </semantics>
</math>

. The method will give the state giving the probabilities 

<math display="inline" id="Quantum_tomography:75">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo>(</mo>
    <mi>m</mi>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Pr</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Pr}\left(m|n\right)
  </annotation>
 </semantics>
</math>

 which are the most closest to those measured. This is the pre-measurement state with which we can have some interesting properties of the measurement giving the result 'n', as explained in.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h2 id="quantum-process-tomography">Quantum process tomography</h2>

<p>Quantum process tomography (QPT) deals with identifying an unknown quantum dynamical process. The first approach, introduced in 1996 and sometimes known as <strong>standard quantum process tomography</strong> (SQPT) involves preparing an ensemble of quantum states and sending them through the process, then using quantum state tomography to identify the resultant states.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Other techniques include <strong>ancilla-assisted process tomography</strong> (AAPT) and <strong>entanglement-assisted process tomography</strong> (EAPT) which require an extra copy of the system.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>Each of the techniques listed above are known as <em>indirect methods</em> for characterization of quantum dynamics, since they require the use of quantum state tomography to reconstruct the process. In contrast, there are <em>direct methods</em> such as <strong>direct characterization of quantum dynamics</strong> (DCQD) which provide a full characterization of quantum systems without any state tomography.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>

<p>The number of experimental configurations (state preparations and measurements) required for full quantum process tomography grows exponentially with the number of constituent particles of a system. Consequently, in general, QPT is an impossible task for large-scale quantum systems. However, under weak decoherence assumption, a quantum dynamical map can find a sparse representation. The method of <strong>compressed quantum process tomography</strong> (CQPT) uses the <a href="compressed_sensing" title="wikilink">compressed sensing</a> technique and applies the sparsity assumption to reconstruct a quantum dynamical map from an incomplete set of measurements or test state preparations.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h3 id="quantum-dynamical-maps">Quantum dynamical maps</h3>

<p>A quantum process, also known as a quantum dynamical map, 

<math display="inline" id="Quantum_tomography:76">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℰ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℰ</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(\rho)
  </annotation>
 </semantics>
</math>

, can be described by a <a href="completely_positive_map" title="wikilink">completely positive map</a></p>

<p>

<math display="block" id="Quantum_tomography:77">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ρ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>A</mi>
      <mi>i</mi>
     </msub>
     <mi>ρ</mi>
     <msubsup>
      <mi>A</mi>
      <mi>i</mi>
      <mo>†</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℰ</ci>
     <ci>ρ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>i</ci>
      </apply>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-†</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(\rho)=\sum_{i}A_{i}\rho A_{i}^{\dagger}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Quantum_tomography:78">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>∈</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>ℬ</ci>
     <ci>ℋ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho\in\mathcal{B(H)}
  </annotation>
 </semantics>
</math>


, the bounded operators on <a href="Hilbert_space" title="wikilink">Hilbert space</a>; with <em>operation elements</em> 

<math display="inline" id="Quantum_tomography:79">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A_{i}
  </annotation>
 </semantics>
</math>

 satisfying 

<math display="inline" id="Quantum_tomography:80">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <msubsup>
      <mi>A</mi>
      <mi>i</mi>
      <mo>†</mo>
     </msubsup>
     <msub>
      <mi>A</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-†</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\sum_{i}A_{i}^{\dagger}A_{i}\leq I
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Quantum_tomography:81">
 <semantics>
  <mrow>
   <mrow>
    <mi>Tr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ρ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>Tr</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>ℰ</ci>
       <ci>ρ</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Tr}[\mathcal{E}(\rho)]\leq 1
  </annotation>
 </semantics>
</math>

.</p>

<p>Let 

<math display="inline" id="Quantum_tomography:82">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>E</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\{E_{i}\}
  </annotation>
 </semantics>
</math>

 be an orthogonal basis for 

<math display="inline" id="Quantum_tomography:83">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℬ</ci>
    <ci>ℋ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B(H)}
  </annotation>
 </semantics>
</math>


. Write the 

<math display="inline" id="Quantum_tomography:84">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A_{i}
  </annotation>
 </semantics>
</math>

 operators in this basis</p>

<p>

<math display="block" id="Quantum_tomography:85">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>m</mi>
    </munder>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mi>m</mi>
      </mrow>
     </msub>
     <msub>
      <mi>E</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A_{i}=\sum_{m}a_{im}E_{m}
  </annotation>
 </semantics>
</math>

. This leads to</p>

<p>

<math display="block" id="Quantum_tomography:86">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ρ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>χ</mi>
      <mrow>
       <mi>m</mi>
       <mi>n</mi>
      </mrow>
     </msub>
     <msub>
      <mi>E</mi>
      <mi>m</mi>
     </msub>
     <mi>ρ</mi>
     <msubsup>
      <mi>E</mi>
      <mi>n</mi>
      <mo>†</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℰ</ci>
     <ci>ρ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <ci>m</ci>
       <ci>n</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>χ</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>m</ci>
      </apply>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-†</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(\rho)=\sum_{m,n}\chi_{mn}E_{m}\rho E_{n}^{\dagger}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Quantum_tomography:87">
 <semantics>
  <mrow>
   <msub>
    <mi>χ</mi>
    <mrow>
     <mi>m</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>m</mi>
       <mi>i</mi>
      </mrow>
     </msub>
     <msubsup>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mi>i</mi>
      </mrow>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>χ</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi_{mn}=\sum_{i}a_{mi}a_{ni}^{*}
  </annotation>
 </semantics>
</math>

.</p>

<p>The goal is then to solve for 

<math display="inline" id="Quantum_tomography:88">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\chi
  </annotation>
 </semantics>
</math>


, which is a positive <a class="uri" href="superoperator" title="wikilink">superoperator</a> and completely characterizes 

<math display="inline" id="Quantum_tomography:89">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℰ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℰ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

 with respect to the 

<math display="inline" id="Quantum_tomography:90">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>E</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\{E_{i}\}
  </annotation>
 </semantics>
</math>

 basis.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h3 id="standard-quantum-process-tomography">Standard quantum process tomography</h3>

<p>SQPT approaches this using 

<math display="inline" id="Quantum_tomography:91">
 <semantics>
  <msup>
   <mi>d</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{2}
  </annotation>
 </semantics>
</math>

 <a href="linearly_independent" title="wikilink">linearly independent</a> inputs 

<math display="inline" id="Quantum_tomography:92">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{j}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Quantum_tomography:93">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>


 is the dimension of the Hilbert space 

<math display="inline" id="Quantum_tomography:94">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

. For each of these input states 

<math display="inline" id="Quantum_tomography:95">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{j}
  </annotation>
 </semantics>
</math>

, sending it through the process gives an output state 

<math display="inline" id="Quantum_tomography:96">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℰ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℰ</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(\rho)
  </annotation>
 </semantics>
</math>

 which can be written as a linear combination of the 

<math display="inline" id="Quantum_tomography:97">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{j}
  </annotation>
 </semantics>
</math>

, i.e. 

<math display="inline" id="Quantum_tomography:98">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ρ</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>k</mi>
    </msub>
    <mrow>
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>j</mi>
       <mi>k</mi>
      </mrow>
     </msub>
     <msub>
      <mi>ρ</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℰ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\mathcal{E}(\rho_{j})=\sum_{k}c_{jk}\rho_{k}
  </annotation>
 </semantics>
</math>


. By sending each 

<math display="inline" id="Quantum_tomography:99">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{j}
  </annotation>
 </semantics>
</math>

 through many times, quantum state tomography can be used to determine the coefficients 

<math display="inline" id="Quantum_tomography:100">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>j</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{jk}
  </annotation>
 </semantics>
</math>

 experimentally.</p>

<p>Write</p>

<p>

<math display="block" id="Quantum_tomography:101">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>m</mi>
    </msub>
    <msub>
     <mi>ρ</mi>
     <mi>j</mi>
    </msub>
    <msubsup>
     <mi>E</mi>
     <mi>n</mi>
     <mo>†</mo>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>k</mi>
    </munder>
    <mrow>
     <msub>
      <mi>B</mi>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo>,</mo>
       <mi>k</mi>
      </mrow>
     </msub>
     <msub>
      <mi>ρ</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-†</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <list>
        <ci>m</ci>
        <ci>n</ci>
        <ci>j</ci>
        <ci>k</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{m}\rho_{j}E_{n}^{\dagger}=\sum_{k}B_{m,n,j,k}\rho_{k}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Quantum_tomography:102">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is a matrix of coefficients. Then</p>

<p>

<math display="block" id="Quantum_tomography:103">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>k</mi>
    </munder>
    <mrow>
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>j</mi>
       <mi>k</mi>
      </mrow>
     </msub>
     <msub>
      <mi>ρ</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ρ</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>χ</mi>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <msub>
      <mi>E</mi>
      <mi>m</mi>
     </msub>
     <msub>
      <mi>ρ</mi>
      <mi>j</mi>
     </msub>
     <msubsup>
      <mi>E</mi>
      <mi>n</mi>
      <mo>†</mo>
     </msubsup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </munder>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>k</mi>
     </munder>
     <mrow>
      <msub>
       <mi>χ</mi>
       <mrow>
        <mi>m</mi>
        <mo>,</mo>
        <mi>n</mi>
       </mrow>
      </msub>
      <msub>
       <mi>B</mi>
       <mrow>
        <mi>m</mi>
        <mo>,</mo>
        <mi>n</mi>
        <mo>,</mo>
        <mi>j</mi>
        <mo>,</mo>
        <mi>k</mi>
       </mrow>
      </msub>
      <msub>
       <mi>ρ</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ℰ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <list>
        <ci>m</ci>
        <ci>n</ci>
       </list>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>χ</ci>
        <list>
         <ci>m</ci>
         <ci>n</ci>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>n</ci>
        </apply>
        <ci>normal-†</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <list>
        <ci>m</ci>
        <ci>n</ci>
       </list>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>χ</ci>
         <list>
          <ci>m</ci>
          <ci>n</ci>
         </list>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <list>
          <ci>m</ci>
          <ci>n</ci>
          <ci>j</ci>
          <ci>k</ci>
         </list>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ρ</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k}c_{jk}\rho_{k}=\mathcal{E}(\rho_{j})=\sum_{m,n}\chi_{m,n}E_{m}\rho_{j}%
E_{n}^{\dagger}=\sum_{m,n}\sum_{k}\chi_{m,n}B_{m,n,j,k}\rho_{k}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Quantum_tomography:104">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{k}
  </annotation>
 </semantics>
</math>

 form a linearly independent basis,</p>

<p>

<math display="block" id="Quantum_tomography:105">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>j</mi>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>χ</mi>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <msub>
      <mi>B</mi>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo>,</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <ci>m</ci>
       <ci>n</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>χ</ci>
       <list>
        <ci>m</ci>
        <ci>n</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <list>
        <ci>m</ci>
        <ci>n</ci>
        <ci>j</ci>
        <ci>k</ci>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle c_{jk}=\sum_{m,n}\chi_{m,n}B_{m,n,j,k}
  </annotation>
 </semantics>
</math>

. Inverting 

<math display="inline" id="Quantum_tomography:106">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 gives 

<math display="inline" id="Quantum_tomography:107">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Quantum_tomography:108">
 <semantics>
  <mrow>
   <msub>
    <mi>χ</mi>
    <mrow>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>,</mo>
      <mi>k</mi>
     </mrow>
    </munder>
    <mrow>
     <msubsup>
      <mi>B</mi>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo>,</mo>
       <mi>k</mi>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>j</mi>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>χ</ci>
     <list>
      <ci>m</ci>
      <ci>n</ci>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <ci>j</ci>
       <ci>k</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <list>
        <ci>m</ci>
        <ci>n</ci>
        <ci>j</ci>
        <ci>k</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi_{m,n}=\sum_{j,k}B^{-1}_{m,n,j,k}c_{jk}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Quantum_mechanics" title="wikilink">Category:Quantum mechanicsre</a> <a class="uri" href="Category:Tomography" title="wikilink">Category:Tomography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">G. Mauro D’Ariano et al. Quantum tomography as a tool for the characterization of optical devices. <a class="uri" href="http://www.iop.org/EJ/abstract/1464-4266/4/3/366">http://www.iop.org/EJ/abstract/1464-4266/4/3/366</a><a href="#fnref1">↩</a></li>
<li id="fn2">Robin Blume-Kohout. Optimal, reliable estimation of quantum states. <a class="uri" href="http://arxiv.org/abs/quant-ph/0611080v1">http://arxiv.org/abs/quant-ph/0611080v1</a><a href="#fnref2">↩</a></li>
<li id="fn3">A.I.Lvovsky, M.G.Raymer. Continuous-variable optical quantum state tomography. <a class="uri" href="http://arxiv.org/abs/quant-ph/0511044v2">http://arxiv.org/abs/quant-ph/0511044v2</a><a href="#fnref3">↩</a></li>
<li id="fn4">K. Vogel and H. Risken. Determination of quasiprobability distributions in terms of probability distributions for the rotated quadrature phase. <a class="uri" href="http://prola.aps.org/abstract/PRA/v40/i5/p2847_1">http://prola.aps.org/abstract/PRA/v40/i5/p2847_1</a><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Online Encyclopedia of Laser Physics and Technology. <a class="uri" href="http://www.rp-photonics.com/frequency_doubling.html">http://www.rp-photonics.com/frequency_doubling.html</a><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8">A I Lvovsky. Iterative maximum-likelihood reconstruction in quantum homodyne tomography. <a class="uri" href="http://arxiv.org/abs/quant-ph/0311097">http://arxiv.org/abs/quant-ph/0311097</a><a href="#fnref8">↩</a></li>
<li id="fn9">J. Řeháček, Z. Hradil, and M. Ježek. Iterative algorithm for reconstruction of entangled states. Phys. Rev. A 63, 040303 (2001). <a class="uri" href="http://prola.aps.org/abstract/PRA/v63/i4/e040303">http://prola.aps.org/abstract/PRA/v63/i4/e040303</a><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">Permutationally Invariant Quantum Tomography. <a class="uri" href="http://www.pitomography.eu">http://www.pitomography.eu</a><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18">Schwemmer, C.; Tóth, G.; Niggebaum, A.; Moroder, T.; Gross, D.; Gühne, O.; Weinfurter, H. (2014). "Experimental Comparison of Efficient Tomography Schemes for a Six-Qubit State". <em>Physical Review Letters</em> <strong>113</strong> (04). <a class="uri" href="http://arxiv.org/abs/1401.7526">http://arxiv.org/abs/1401.7526</a>. . <a href="#fnref18">↩</a></li>
<li id="fn19">J. Fiurasek. Maximum-likelihood estimation of quantum measurement (http://www.seedwiki.com/wiki/spie) and Review (http://arxiv.org/abs/quant-ph/0302028)<a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21">Taoufik Amri, Quantum behavior of measurement apparatus, <a href="http://arxiv1.library.cornell.edu/abs/1001.3032">arXiv:1001.3032</a> (2010).<a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24">S. M. Barnett et al. <a href="http://arxiv.org/abs/quant-ph/0106139">arXiv:0106139</a> (2001).<a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26">I. L. Chuang, M. A. Nielsen. Prescription for Experimental Determination of the Dynamics of a Quantum Black Box. <a class="uri" href="http://arxiv.org/abs/quant-ph/9610001">http://arxiv.org/abs/quant-ph/9610001</a><a href="#fnref26">↩</a></li>
<li id="fn27">J. B. Altepeter et al. Ancilla-assisted quantum process tomography. <a class="uri" href="http://arxiv.org/abs/quant-ph/0303038v2">http://arxiv.org/abs/quant-ph/0303038v2</a><a href="#fnref27">↩</a></li>
<li id="fn28">M. Mohseni, A. T. Rezakhani, D. A. Lidar. Quantum Process Tomography: Resource Analysis of Different Strategies. <a class="uri" href="http://arxiv.org/abs/quant-ph/0702131">http://arxiv.org/abs/quant-ph/0702131</a><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"></li>
</ol>
</section>
</hr></body>
</html>
