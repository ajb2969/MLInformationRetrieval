<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1870">Abductive reasoning</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Abductive reasoning</h1>
<hr/>

<p><strong>Abductive reasoning</strong> (also called <strong>abduction</strong>,<ref name="abduction">* Magnani, L. "Abduction, Reason, and Science: Processes of Discovery and Explanation". <em>Kluwer Academic Plenum Publishers, New York, 2001</em>. xvii. 205 pages. Hard cover, ISBN 0-306-46514-0.</ref></p>
<ul>
<li>R. Josephson, J. &amp; G. Josephson, S. "Abductive Inference: Computation, Philosophy, Technology" <em>Cambridge University Press, New York &amp; Cambridge (U.K.)</em>. viii. 306 pages. Hard cover (1994), ISBN 0-521-43461-0, Paperback (1996), ISBN 0-521-57545-1.</li>
<li>Bunt, H. &amp; Black, W. "Abduction, Belief and Context in Dialogue: Studies in Computational Pragmatics" <em>(Natural Language Processing, 1.) John Benjamins, Amsterdam &amp; Philadelphia, 2000</em>. vi. 471 pages. Hard cover, ISBN 90-272-4983-0 (Europe), 1-58619-794-2 (U.S.)</li>
</ul>

<p> <strong>abductive inference</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> or <strong>retroduction</strong><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>) is a form of <a href="logic" title="wikilink">logical</a> <a class="uri" href="inference" title="wikilink">inference</a> that goes from an observation to a <a class="uri" href="hypothesis" title="wikilink">hypothesis</a> that accounts for the observation, ideally seeking to find the simplest and most likely explanation. In abductive reasoning, unlike in <a href="deductive_reasoning" title="wikilink">deductive reasoning</a>, the premises do not guarantee the conclusion. One can understand abductive reasoning as "inference to the best explanation".<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The fields of law,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a href="computer_science" title="wikilink">computer science</a>, and <a href="artificial_intelligence" title="wikilink">artificial intelligence</a> research<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> renewed interest in the subject of abduction. Diagnostic <a href="expert_system" title="wikilink">expert systems</a> frequently employ abduction.</p>
<h2 id="history">History</h2>

<p>The American philosopher <a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a> (1839–1914) first introduced the term as "guessing".<ref name="guess">Peirce, C. S.</ref></p>
<ul>
<li>"On the Logic of drawing History from Ancient Documents especially from Testimonies" (1901), <em>Collected Papers</em> v. 7, paragraph 219.</li>
<li>"PAP" ["Prolegomena to an Apology for Pragmatism"], MS 293 c. 1906, <em>New Elements of Mathematics</em> v. 4, pp. 319-320.</li>
<li>A Letter to F. A. Woods (1913), <em>Collected Papers</em> v. 8, paragraphs 385-388.</li>
</ul>

<p>(See under "<a href="http://www.helsinki.fi/science/commens/terms/abduction.html">Abduction</a>" and "<a href="http://www.helsinki.fi/science/commens/terms/retroduction.html">Retroduction</a>" at <em>Commens Dictionary of Peirce's Terms</em>.) Peirce said that to <em>abduce</em> a hypothetical explanation 

<math display="inline" id="Abductive_reasoning:0">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 from an observed circumstance 

<math display="inline" id="Abductive_reasoning:1">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is to surmise that 

<math display="inline" id="Abductive_reasoning:2">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 may be true because then 

<math display="inline" id="Abductive_reasoning:3">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>


 would be a matter of course.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Thus, to abduce 

<math display="inline" id="Abductive_reasoning:4">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Abductive_reasoning:5">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 involves determining that 

<math display="inline" id="Abductive_reasoning:6">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is <a href="necessary_and_sufficient_conditions" title="wikilink">sufficient, but not necessary</a>, for 

<math display="inline" id="Abductive_reasoning:7">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

.</p>

<p>For example, suppose we observe that <em>the lawn is wet</em>. If <em>it rained last night</em>, then it would be unsurprising that <em>the lawn is wet</em>. Therefore, by abductive reasoning, the possibility that <em>it rained last night</em> is reasonable (but note that Peirce did not remain convinced that a single logical form covers all abduction);<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>however, some other process may have also resulted in a wet lawn, i.e. dew or lawn sprinklers. Moreover, abducing that <em>it rained last night</em> from the observation of a wet lawn can lead to false conclusion(s).</p>

<p>Peirce argues that good abductive reasoning from <em>P</em> to <em>Q</em> involves not simply a determination that <em>Q</em> is sufficient for <em>P</em>, but also that <em>Q</em> is among the <a href="Occam's_razor" title="wikilink">most economical explanations</a> for <em>P</em>. Simplification and economy both call for that "leap" of abduction.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="deduction-induction-and-abduction">Deduction, induction, and abduction</h2>
<dl>
<dt><a href="Deductive_reasoning" title="wikilink">Deductive reasoning</a> (deduction) : allows deriving 

<math display="inline" id="Abductive_reasoning:8">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>


 from 

<math display="inline" id="Abductive_reasoning:9">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 only where 

<math display="inline" id="Abductive_reasoning:10">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is a formal <a href="logical_consequence" title="wikilink">logical consequence</a> of 

<math display="inline" id="Abductive_reasoning:11">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

. In other words, deduction derives the consequences of the assumed. Given the truth of the assumptions, a valid deduction guarantees the truth of the conclusion. For example, given that all bachelors are unmarried males, and given that this person is a bachelor, one can deduce that this person is an unmarried male.</dt>
</dl>
<dl>
<dt><a href="Inductive_reasoning" title="wikilink">Inductive reasoning</a> (induction) : allows inferring 

<math display="inline" id="Abductive_reasoning:12">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Abductive_reasoning:13">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Abductive_reasoning:14">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 does not follow necessarily from 

<math display="inline" id="Abductive_reasoning:15">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Abductive_reasoning:16">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 might give us very good reason to accept 

<math display="inline" id="Abductive_reasoning:17">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, but it does not ensure 

<math display="inline" id="Abductive_reasoning:18">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>


. For example, if all swans that we have observed so far are white, we may induce that the possibility that all swans are white is reasonable. We have good reason to believe the conclusion from the premise, but the truth of the conclusion is not guaranteed. (Indeed, it turns out that <a href="Black_swan" title="wikilink">some swans are black</a>.)</dt>
</dl>
<dl>
<dt>Abductive reasoning (abduction) : allows inferring 

<math display="inline" id="Abductive_reasoning:19">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 as an explanation of 

<math display="inline" id="Abductive_reasoning:20">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. Because of this inference, abduction allows the precondition 

<math display="inline" id="Abductive_reasoning:21">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 to be abduced from the consequence 

<math display="inline" id="Abductive_reasoning:22">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. <a href="Deductive_reasoning" title="wikilink">Deductive reasoning</a> and abductive reasoning thus differ in the direction in which a rule like "

<math display="inline" id="Abductive_reasoning:23">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>


 <a href="entailment" title="wikilink">entails</a> 

<math display="inline" id="Abductive_reasoning:24">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

" is used for inference. As such, abduction is formally equivalent to the logical fallacy of <a href="affirming_the_consequent" title="wikilink">affirming the consequent</a> (or <em><a href="Post_hoc_ergo_propter_hoc" title="wikilink">Post hoc ergo propter hoc</a></em>) because of multiple possible explanations for 

<math display="inline" id="Abductive_reasoning:25">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. For example, in a billiard game, after glancing and seeing the <em>eight</em> ball moving towards us, we may abduce that the cue ball struck the eight ball. The strike of the cue ball would account for the movement of the eight ball. It serves as a hypothesis that explains our observation. Given the many possible explanations for the movement of the eight ball, our abduction does not leave us certain that the cue ball in fact struck the eight ball, but our abduction, still useful, can serve to orient us in our surroundings. Despite many possible explanations for any physical process that we observe, we tend to abduce a single explanation (or a few explanations) for this process in the expectation that we can better orient ourselves in our surroundings and disregard some possibilities. Properly used, abductive reasoning can be a useful source of <a class="uri" href="priors" title="wikilink">priors</a> in <a href="Bayesian_statistics" title="wikilink">Bayesian statistics</a>.</dt>
</dl>
<h2 id="formalizations-of-abduction">Formalizations of abduction</h2>
<h3 id="logic-based-abduction">Logic-based abduction</h3>

<p>In <a class="uri" href="logic" title="wikilink">logic</a>, <a class="uri" href="explanation" title="wikilink">explanation</a> is done from a logical theory 

<math display="inline" id="Abductive_reasoning:26">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 representing a <a href="Domain_(mathematics)" title="wikilink">domain</a> and a set of observations 

<math display="inline" id="Abductive_reasoning:27">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

. Abduction is the process of deriving a set of explanations of 

<math display="inline" id="Abductive_reasoning:28">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>


 according to 

<math display="inline" id="Abductive_reasoning:29">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and picking out one of those explanations. For 

<math display="inline" id="Abductive_reasoning:30">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 to be an explanation of 

<math display="inline" id="Abductive_reasoning:31">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

 according to 

<math display="inline" id="Abductive_reasoning:32">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, it should satisfy two conditions:</p>
<ul>
<li>

<math display="inline" id="Abductive_reasoning:33">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>


 follows from 

<math display="inline" id="Abductive_reasoning:34">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Abductive_reasoning:35">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

;</li>
</ul>
<ul>
<li>

<math display="inline" id="Abductive_reasoning:36">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is consistent with 

<math display="inline" id="Abductive_reasoning:37">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>In formal logic, 

<math display="inline" id="Abductive_reasoning:38">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Abductive_reasoning:39">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 are assumed to be sets of literals. The two conditions for 

<math display="inline" id="Abductive_reasoning:40">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 being an explanation of 

<math display="inline" id="Abductive_reasoning:41">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

 according to theory 

<math display="inline" id="Abductive_reasoning:42">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 are formalized as:</p>

<p>

<math display="block" id="Abductive_reasoning:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>∪</mo>
    <mi>E</mi>
   </mrow>
   <mo>⊧</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <apply>
     <union></union>
     <ci>T</ci>
     <ci>E</ci>
    </apply>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cup E\models O
  </annotation>
 </semantics>
</math>

;</p>

<p>

<math display="block" id="Abductive_reasoning:44">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∪</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>T</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cup E
  </annotation>
 </semantics>
</math>

 is consistent.</p>

<p>Among the possible explanations 

<math display="inline" id="Abductive_reasoning:45">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 satisfying these two conditions, some other condition of minimality is usually imposed to avoid irrelevant facts (not contributing to the entailment of 

<math display="inline" id="Abductive_reasoning:46">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

) being included in the explanations. Abduction is then the process that picks out some member of 

<math display="inline" id="Abductive_reasoning:47">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

. Criteria for picking out a member representing "the best" explanation include the <a class="uri" href="simplicity" title="wikilink">simplicity</a>, the <a href="prior_probability" title="wikilink">prior probability</a>, or the explanatory power of the explanation.</p>

<p>A proof theoretical abduction method for first order classical logic based on the <a href="sequent_calculus" title="wikilink">sequent calculus</a> and a dual one, based on semantic tableaux (<a href="analytic_tableaux" title="wikilink">analytic tableaux</a>) have been proposed (Cialdea Mayer &amp; Pirri 1993). The methods are sound and complete and work for full first order logic, without requiring any preliminary reduction of formulae into normal forms. These methods have also been extended to <a href="modal_logic" title="wikilink">modal logic</a>.</p>

<p><a href="Abductive_Logic_Programming" title="wikilink">Abductive logic programming</a> is a computational framework that extends normal <a href="logic_programming" title="wikilink">logic programming</a> with abduction. It separates the theory 

<math display="inline" id="Abductive_reasoning:48">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>


 into two components, one of which is a normal logic program, used to generate 

<math display="inline" id="Abductive_reasoning:49">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 by means of <a href="backward_reasoning" title="wikilink">backward reasoning</a>, the other of which is a set of integrity constraints, used to filter the set of candidate explanations.</p>
<h3 id="set-cover-abduction">Set-cover abduction</h3>

<p>A different formalization of abduction is based on inverting the function that calculates the visible effects of the hypotheses. Formally, we are given a set of hypotheses 

<math display="inline" id="Abductive_reasoning:50">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 and a set of manifestations 

<math display="inline" id="Abductive_reasoning:51">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

; they are related by the domain knowledge, represented by a function 

<math display="inline" id="Abductive_reasoning:52">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 that takes as an argument a set of hypotheses and gives as a result the corresponding set of manifestations. In other words, for every subset of the hypotheses 

<math display="inline" id="Abductive_reasoning:53">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mo>′</mo>
   </msup>
   <mo>⊆</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{\prime}\subseteq H
  </annotation>
 </semantics>
</math>


, their effects are known to be 

<math display="inline" id="Abductive_reasoning:54">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>H</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(H^{\prime})
  </annotation>
 </semantics>
</math>

.</p>

<p>Abduction is performed by finding a set 

<math display="inline" id="Abductive_reasoning:55">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mo>′</mo>
   </msup>
   <mo>⊆</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{\prime}\subseteq H
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Abductive_reasoning:56">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>H</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\subseteq e(H^{\prime})
  </annotation>
 </semantics>
</math>

. In other words, abduction is performed by finding a set of hypotheses 

<math display="inline" id="Abductive_reasoning:57">
 <semantics>
  <msup>
   <mi>H</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>H</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{\prime}
  </annotation>
 </semantics>
</math>

 such that their effects 

<math display="inline" id="Abductive_reasoning:58">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>H</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(H^{\prime})
  </annotation>
 </semantics>
</math>


 include all observations 

<math display="inline" id="Abductive_reasoning:59">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

.</p>

<p>A common assumption is that the effects of the hypotheses are independent, that is, for every 

<math display="inline" id="Abductive_reasoning:60">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mo>′</mo>
   </msup>
   <mo>⊆</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{\prime}\subseteq H
  </annotation>
 </semantics>
</math>

, it holds that 

<math display="inline" id="Abductive_reasoning:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>H</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
     <mrow>
      <mi>h</mi>
      <mo>∈</mo>
      <msup>
       <mi>H</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>h</mi>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <in></in>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>e</ci>
      <set>
       <ci>h</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(H^{\prime})=\bigcup_{h\in H^{\prime}}e(\{h\})
  </annotation>
 </semantics>
</math>

. If this condition is met, abduction can be seen as a form of <a href="set_covering" title="wikilink">set covering</a>.</p>
<h3 id="abductive-validation">Abductive validation</h3>

<p>Abductive validation is the process of validating a given hypothesis through abductive reasoning. This can also be called reasoning through successive approximation. Under this principle, an explanation is valid if it is the best possible explanation of a set of known data. The best possible explanation is often defined in terms of simplicity and elegance (see <a href="Occam's_razor" title="wikilink">Occam's razor</a>). Abductive validation is common practice in hypothesis formation in <a class="uri" href="science" title="wikilink">science</a>; moreover, Peirce claims that it is a ubiquitous aspect of thought:</p>
<blockquote>

<p>Looking out my window this lovely spring morning, I see an azalea in full bloom. No, no! I don't see that; though that is the only way I can describe what I see. That is a proposition, a sentence, a fact; but what I perceive is not proposition, sentence, fact, but only an image, which I make intelligible in part by means of a statement of fact. This statement is abstract; but what I see is concrete. I perform an abduction when I so much as express in a sentence anything I see. The truth is that the whole fabric of our knowledge is one matted felt of pure hypothesis confirmed and refined by induction. Not the smallest advance can be made in knowledge beyond the stage of vacant staring, without making an abduction at every step.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
</blockquote>

<p>It was Peirce's own maxim that "Facts cannot be explained by a hypothesis more extraordinary than these facts themselves; and of various hypotheses the least extraordinary must be adopted."<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> After obtaining results from an inference procedure, we may be left with multiple assumptions, some of which may be contradictory. Abductive validation is a method for identifying the assumptions that will lead to your goal.</p>
<h3 id="probabilistic-abduction">Probabilistic abduction</h3>

<p>Probabilistic abductive reasoning is a form of abductive validation, and is used extensively in areas where conclusions about possible hypotheses need to be derived, such as for making diagnoses from medical tests. For example, a pharmaceutical company that develops a test for a particular infectious disease will typically determine the reliability of the test by hiring a group of infected and a group of non-infected people to undergo the test. Assume the statements 

<math display="inline" id="Abductive_reasoning:62">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

: "Positive test", 

<math display="inline" id="Abductive_reasoning:63">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{x}
  </annotation>
 </semantics>
</math>


: "Negative test", 

<math display="inline" id="Abductive_reasoning:64">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

: "Infected", and 

<math display="inline" id="Abductive_reasoning:65">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{y}
  </annotation>
 </semantics>
</math>

: "Not infected". The result of these trials will then determine the reliability of the test in terms of its <a href="Sensitivity_and_specificity" title="wikilink">sensitivity</a> 

<math display="inline" id="Abductive_reasoning:66">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x|y)
  </annotation>
 </semantics>
</math>

 and false positive rate 

<math display="inline" id="Abductive_reasoning:67">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x|\overline{y})
  </annotation>
 </semantics>
</math>

. The interpretations of the conditionals are

<math display="block" id="Abductive_reasoning:68">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x|y)
  </annotation>
 </semantics>
</math>

: "The probability of positive test given infection", and 

<math display="inline" id="Abductive_reasoning:69">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x|\overline{y})
  </annotation>
 </semantics>
</math>

: "The probability of positive test in the absence of infection". The problem with applying these conditionals in a practical setting is that they are expressed in the opposite direction to what the practitioner needs. The conditionals needed for making the diagnosis are

<math display="block" id="Abductive_reasoning:70">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y|x)
  </annotation>
 </semantics>
</math>

: "The probability of infection given positive test", and 

<math display="inline" id="Abductive_reasoning:71">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y|\overline{x})
  </annotation>
 </semantics>
</math>

: "The probability of infection given negative test". The probability of infection could then have been conditionally deduced as 

<math display="inline" id="Abductive_reasoning:72">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>∥</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y\|x)=p(x)p(y|x)+p(\overline{x})p(y|\overline{x})
  </annotation>
 </semantics>
</math>

, where "

<math display="inline" id="Abductive_reasoning:73">
 <semantics>
  <mo>∥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">parallel-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|
  </annotation>
 </semantics>
</math>


" denotes conditional deduction. Unfortunately the required conditionals are usually not directly available to the medical practitioner, but they can be obtained if the base rate of the infection in the population is known.</p>

<p>The required conditionals can be correctly derived by inverting the available conditionals using Bayes rule. The inverted conditionals are obtained as follows: 

<math display="inline" id="Abductive_reasoning:74">
 <semantics>
  <mrow>
   <mpadded width="+5.6pt">
    <mrow>
     <mo>{</mo>
     <mtable>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">|</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>=</mo>
         <mfrac>
          <mrow>
           <mi>p</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>x</mi>
             <mo>∧</mo>
             <mi>y</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mi>p</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>y</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mfrac>
        </mrow>
       </mtd>
       <mtd></mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">|</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>=</mo>
         <mfrac>
          <mrow>
           <mi>p</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>x</mi>
             <mo>∧</mo>
             <mi>y</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mi>p</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mfrac>
        </mrow>
       </mtd>
       <mtd></mtd>
      </mtr>
     </mtable>
    </mrow>
   </mpadded>
   <mo>⇒</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+2.8pt">
    <mfrac>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">|</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mpadded>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <eq></eq>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>p</ci>
        <apply>
         <and></and>
         <ci>x</ci>
         <ci>y</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </cerror>
     <mtext>otherwise</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <eq></eq>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>p</ci>
        <apply>
         <and></and>
         <ci>x</ci>
         <ci>y</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </cerror>
     <mtext>otherwise</mtext>
    </apply>
    <ci>normal-⇒</ci>
    <ci></ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}p(x|y)=\frac{p(x\land y)}{p(y)}\\
p(y|x)=\frac{p(x\land y)}{p(x)}\end{cases}\;\;\Rightarrow\;\;\;\;p(y|x)=\frac{%
p(y)p(x|y)}{p(x)}\;.
  </annotation>
 </semantics>
</math>

 The term 

<math display="inline" id="Abductive_reasoning:75">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y)
  </annotation>
 </semantics>
</math>

 on the right hand side of the equation expresses the base rate of the infection in the population. Similarly, the term 

<math display="inline" id="Abductive_reasoning:76">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 expresses the default likelihood of positive test on a random person in the population. In the expressions below 

<math display="inline" id="Abductive_reasoning:77">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(y)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Abductive_reasoning:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>y</mi>
      <mo>¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(\overline{y})=1-a(y)
  </annotation>
 </semantics>
</math>

 denote the base rates of 

<math display="inline" id="Abductive_reasoning:79">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 and its complement 

<math display="inline" id="Abductive_reasoning:80">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{y}
  </annotation>
 </semantics>
</math>

 respectively, so that e.g. 

<math display="inline" id="Abductive_reasoning:81">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=a(y)p(x|y)+a(\overline{y})p(x|\overline{y})
  </annotation>
 </semantics>
</math>

. The full expression for the required conditionals 

<math display="inline" id="Abductive_reasoning:82">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y|x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Abductive_reasoning:83">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y|\overline{x})
  </annotation>
 </semantics>
</math>

 are then</p>

<p>

<math display="inline" id="Abductive_reasoning:84">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>=</mo>
       <mfrac>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">|</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">|</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>+</mo>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>y</mi>
           <mo>¯</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">|</mo>
          <mover accent="true">
           <mi>y</mi>
           <mo>¯</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">|</mo>
        <mover accent="true">
         <mi>x</mi>
         <mo>¯</mo>
        </mover>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>=</mo>
       <mfrac>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>x</mi>
           <mo>¯</mo>
          </mover>
          <mo stretchy="false">|</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>x</mi>
           <mo>¯</mo>
          </mover>
          <mo stretchy="false">|</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>+</mo>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>y</mi>
           <mo>¯</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>x</mi>
           <mo>¯</mo>
          </mover>
          <mo stretchy="false">|</mo>
          <mover accent="true">
           <mi>y</mi>
           <mo>¯</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <plus></plus>
       <csymbol cd="unknown">a</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>y</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-|</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>y</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
    </cerror>
    <mtext>otherwise</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>x</ci>
        </apply>
        <ci>normal-|</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>x</ci>
        </apply>
        <ci>normal-|</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <plus></plus>
       <csymbol cd="unknown">a</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>y</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>x</ci>
        </apply>
        <ci>normal-|</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>y</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
    </cerror>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}p(y|x)=\frac{a(y)p(x|y)}{a(y)p(x|y)+a(\overline{y})p(x|\overline{%
y})}\\
p(y|\overline{x})=\frac{a(y)p(\overline{x}|y)}{a(y)p(\overline{x}|y)+a(%
\overline{y})p(\overline{x}|\overline{y})}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>The full expression for the conditionally abduced probability of infection in a tested person, expressed as 

<math display="inline" id="Abductive_reasoning:85">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>y</mi>
     <mover accent="true">
      <mo>∥</mo>
      <mo>¯</mo>
     </mover>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <ci>normal-¯</ci>
      <csymbol cd="latexml">parallel-to</csymbol>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y\overline{\|}x)
  </annotation>
 </semantics>
</math>

, given the outcome of the test, the base rate of the infection, as well as the test's sensitivity and false positive rate, is then given by</p>

<p>

<math display="inline" id="Abductive_reasoning:86">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mover accent="true">
       <mo>∥</mo>
       <mo>¯</mo>
      </mover>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">|</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">|</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>+</mo>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mover accent="true">
          <mi>y</mi>
          <mo>¯</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">|</mo>
         <mover accent="true">
          <mi>y</mi>
          <mo>¯</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>¯</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mover accent="true">
          <mi>x</mi>
          <mo>¯</mo>
         </mover>
         <mo stretchy="false">|</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mover accent="true">
          <mi>x</mi>
          <mo>¯</mo>
         </mover>
         <mo stretchy="false">|</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>+</mo>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mover accent="true">
          <mi>y</mi>
          <mo>¯</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mover accent="true">
          <mi>x</mi>
          <mo>¯</mo>
         </mover>
         <mo stretchy="false">|</mo>
         <mover accent="true">
          <mi>y</mi>
          <mo>¯</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <ci>normal-¯</ci>
       <csymbol cd="latexml">parallel-to</csymbol>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>x</ci>
      <apply>
       <divide></divide>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">a</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-|</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">a</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-|</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <plus></plus>
        <csymbol cd="unknown">a</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>y</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-|</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>y</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <divide></divide>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">a</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>x</ci>
         </apply>
         <ci>normal-|</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">a</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>x</ci>
         </apply>
         <ci>normal-|</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <plus></plus>
        <csymbol cd="unknown">a</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>y</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>x</ci>
         </apply>
         <ci>normal-|</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>y</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y\overline{\|}x)=p(x)\left(\frac{a(y)p(x|y)}{a(y)p(x|y)+a(\overline{y})p(x|%
\overline{y})}\right)+p(\overline{x})\left(\frac{a(y)p(\overline{x}|y)}{a(y)p(%
\overline{x}|y)+a(\overline{y})p(\overline{x}|\overline{y})}\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>This further simplifies to</p>

<p>

<math display="inline" id="Abductive_reasoning:87">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mover accent="true">
     <mo>∥</mo>
     <mo>¯</mo>
    </mover>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo>(</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>¯</mo>
     </mover>
     <mo stretchy="false">|</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <csymbol cd="latexml">parallel-to</csymbol>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-|</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y\overline{\|}x)=a(y)\left(p(x|y)+p(\overline{x}|y)\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>Probabilistic abduction can thus be described as a method for inverting conditionals in order to apply probabilistic deduction.</p>

<p>A medical test result is typically considered positive or negative, so when applying the above equation it can be assumed that either 

<math display="inline" id="Abductive_reasoning:88">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=1
  </annotation>
 </semantics>
</math>

 (positive) or 

<math display="inline" id="Abductive_reasoning:89">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\overline{x})=1
  </annotation>
 </semantics>
</math>

 (negative). In case the patient tests positive, the above equation can be simplified to 

<math display="inline" id="Abductive_reasoning:90">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mover accent="true">
     <mo>∥</mo>
     <mo>¯</mo>
    </mover>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <csymbol cd="latexml">parallel-to</csymbol>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y\overline{\|}x)=p(y|x)
  </annotation>
 </semantics>
</math>

 which will give the correct likelihood that the patient actually is infected.</p>

<p>The <a href="Base_rate_fallacy" title="wikilink">Base rate fallacy</a> in medicine,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> or the <a href="Prosecutor's_fallacy" title="wikilink">Prosecutor's fallacy</a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> in legal reasoning, consists of making the erroneous assumption that 

<math display="inline" id="Abductive_reasoning:91">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y|x)=p(x|y)
  </annotation>
 </semantics>
</math>

. While this reasoning error often can produce a relatively good approximation of the correct hypothesis probability value, it can lead to a completely wrong result and wrong conclusion in case the base rate is very low and the reliability of the test is not perfect. An extreme example of the base rate fallacy is to conclude that a male person is pregnant just because he tests positive in a pregnancy test. Obviously, the base rate of <a href="male_pregnancy" title="wikilink">male pregnancy</a> is zero, and assuming that the test is not perfect, it would be correct to conclude that the male person is not pregnant.</p>

<p>The expression for probabilistic abduction can be generalised to multinomial cases,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> i.e., with a state space 

<math display="inline" id="Abductive_reasoning:92">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 of multiple 

<math display="inline" id="Abductive_reasoning:93">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 and a state space 

<math display="inline" id="Abductive_reasoning:94">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 of multiple states 

<math display="inline" id="Abductive_reasoning:95">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="subjective-logic-abduction">Subjective logic abduction</h3>

<p><a href="Subjective_logic" title="wikilink">Subjective logic</a> generalises <a href="probabilistic_logic" title="wikilink">probabilistic logic</a> by including parameters for uncertainty in the input arguments. Abduction in subjective logic is thus similar to probabilistic abduction described above.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> The input arguments in subjective logic are composite functions called subjective opinions which can be binomial when the opinion applies to a single proposition or multinomial when it applies to a set of propositions. A multinomial opinion thus applies to a frame 

<math display="inline" id="Abductive_reasoning:96">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\,\!
  </annotation>
 </semantics>
</math>

 (i.e. a state space of exhaustive and mutually disjoint propositions 

<math display="inline" id="Abductive_reasoning:97">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\,\!
  </annotation>
 </semantics>
</math>

), and is denoted by the composite function 

<math display="inline" id="Abductive_reasoning:98">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mi>X</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>b</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>,</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>a</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>X</ci>
    </apply>
    <vector>
     <apply>
      <ci>normal-→</ci>
      <ci>b</ci>
     </apply>
     <ci>u</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>a</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{X}=(\vec{b},u,\vec{a})\,\!
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Abductive_reasoning:99">
 <semantics>
  <mover accent="true">
   <mi>b</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{b}\,\!
  </annotation>
 </semantics>
</math>

 is a vector of belief masses over the propositions of 

<math display="inline" id="Abductive_reasoning:100">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\,\!
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Abductive_reasoning:101">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\,\!
  </annotation>
 </semantics>
</math>

 is the uncertainty mass, and 

<math display="inline" id="Abductive_reasoning:102">
 <semantics>
  <mover accent="true">
   <mi>a</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{a}\,\!
  </annotation>
 </semantics>
</math>

 is a vector of base rate values over the propositions of 

<math display="inline" id="Abductive_reasoning:103">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\,\!
  </annotation>
 </semantics>
</math>

. These components satisfy 

<math display="inline" id="Abductive_reasoning:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mo>+</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mover accent="true">
       <mi>b</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>u</ci>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <apply>
        <ci>normal-→</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u+\sum\vec{b}(x_{i})=1\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Abductive_reasoning:105">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <sum></sum>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum\vec{a}(x_{i})=1\,\!
  </annotation>
 </semantics>
</math>

 as well as 

<math display="inline" id="Abductive_reasoning:106">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>b</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mrow>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>u</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </list>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{b}(x_{i}),u,\vec{a}(x_{i})\in[0,1]\,\!
  </annotation>
 </semantics>
</math>

.</p>

<p>Assume the frames 

<math display="inline" id="Abductive_reasoning:107">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Abductive_reasoning:108">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

, the sets of conditional opinions 

<math display="inline" id="Abductive_reasoning:109">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mrow>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{X|Y}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Abductive_reasoning:110">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mrow>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>Y</mi>
     <mo>¯</mo>
    </mover>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>Y</ci>
     </apply>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{X|\overline{Y}}
  </annotation>
 </semantics>
</math>

, the opinion 

<math display="inline" id="Abductive_reasoning:111">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{X}
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Abductive_reasoning:112">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, and the base rate function 

<math display="inline" id="Abductive_reasoning:113">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>Y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{Y}
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Abductive_reasoning:114">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. Based on these parameters, subjective logic provides a method for deriving the set of inverted conditionals 

<math display="inline" id="Abductive_reasoning:115">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mrow>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{Y|X}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Abductive_reasoning:116">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mrow>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>X</mi>
     <mo>¯</mo>
    </mover>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>X</ci>
     </apply>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{Y|\overline{X}}
  </annotation>
 </semantics>
</math>

. Using these inverted conditionals, subjective logic also provides a method for deduction. Abduction in subjective logic consists of inverting the conditionals and then applying deduction.</p>

<p>The symbolic notation for conditional abduction is "

<math display="inline" id="Abductive_reasoning:117">
 <semantics>
  <mover accent="true">
   <mo>∥</mo>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <csymbol cd="latexml">parallel-to</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{\|}
  </annotation>
 </semantics>
</math>

", and the operator itself is denoted as 

<math display="inline" id="Abductive_reasoning:118">
 <semantics>
  <mover accent="true">
   <mo>⊚</mo>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>normal-⊚</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{\circledcirc}
  </annotation>
 </semantics>
</math>

. The expression for subjective logic abduction is then:<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> 

<math display="inline" id="Abductive_reasoning:119">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mrow>
     <mi>Y</mi>
     <mover accent="true">
      <mo>∥</mo>
      <mo>¯</mo>
     </mover>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <msub>
      <mi>ω</mi>
      <mi>X</mi>
     </msub>
    </mpadded>
    <mpadded width="+2.8pt">
     <mover accent="true">
      <mo>⊚</mo>
      <mo>¯</mo>
     </mover>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mrow>
       <mi>X</mi>
       <mo stretchy="false">|</mo>
       <mi>Y</mi>
      </mrow>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ω</mi>
      <mrow>
       <mi>X</mi>
       <mo stretchy="false">|</mo>
       <mover accent="true">
        <mi>Y</mi>
        <mo>¯</mo>
       </mover>
      </mrow>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>Y</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <apply>
      <times></times>
      <ci>Y</ci>
      <apply>
       <ci>normal-¯</ci>
       <csymbol cd="latexml">parallel-to</csymbol>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>normal-⊚</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">X</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">Y</csymbol>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">X</csymbol>
        <ci>normal-|</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>Y</ci>
        </apply>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>Y</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{Y\overline{\|}X}=\omega_{X}\;\overline{\circledcirc}\;(\omega_{X|Y},%
\omega_{X|\overline{Y}},a_{Y})\,\!
  </annotation>
 </semantics>
</math>

.</p>

<p>The advantage of using subjective logic abduction compared to probabilistic abduction is that uncertainty about the probability values of the input arguments can be explicitly expressed and taken into account during the analysis. It is thus possible to perform abductive analysis in the presence of missing or incomplete input evidence, which normally results in degrees of uncertainty in the output conclusions.</p>
<h2 id="history-1">History</h2>

<p>The philosopher <a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a> (; 1839–1914) introduced abduction into modern logic. Over the years he called such inference <em>hypothesis</em>, <em>abduction</em>, <em>presumption</em>, and <em>retroduction</em>. He considered it a topic in logic as a normative field in philosophy, not in purely formal or mathematical logic, and eventually as a topic also in economics of research.</p>

<p>As two stages of the development, extension, etc., of a hypothesis in scientific inquiry, abduction and also <a href="inductive_reasoning" title="wikilink">induction</a> are often collapsed into one overarching concept — the hypothesis. That is why, in the <a href="scientific_method" title="wikilink">scientific method</a> pioneered by <a href="Galileo_Galilei" title="wikilink">Galileo</a> and <a href="Francis_Bacon" title="wikilink">Bacon</a>, the abductive stage of hypothesis formation is conceptualized simply as induction. Thus, in the twentieth century this collapse was reinforced by <a href="Karl_Popper" title="wikilink">Karl Popper</a>'s explication of the <a href="hypothetico-deductive_model" title="wikilink">hypothetico-deductive model</a>, where the hypothesis is considered to be just "a guess"<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> (in the spirit of Peirce). However, when the formation of a hypothesis is considered the result of a process it becomes clear that this "guess" has already been tried and made more robust in thought as a necessary stage of its acquiring the status of hypothesis. Indeed many abductions are rejected or heavily modified by subsequent abductions before they ever reach this stage.</p>

<p>Before 1900, Peirce treated abduction as the use of a known rule to explain an observation, e.g., it is a known rule that if it rains the grass is wet; so, to explain the fact that the grass is wet; one infers that it has rained. This remains the common use of the term "abduction" in the <a href="social_science" title="wikilink">social sciences</a> and in <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>.</p>

<p>Peirce consistently characterized it as the kind of inference that originates a hypothesis by concluding in an explanation, though an unassured one, for some very curious or surprising (anomalous) observation stated in a premise. As early as 1865 he wrote that all conceptions of cause and force are reached through hypothetical inference; in the 1900s he wrote that all explanatory content of theories is reached through abduction. In other respects Peirce revised his view of abduction over the years.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>In later years his view came to be:</p>
<ul>
<li>Abduction is guessing.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> It is "very little hampered" by rules of logic.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Even a well-prepared mind's individual guesses are more frequently wrong than right.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> But the success of our guesses far exceeds that of random luck and seems born of attunement to nature by instinct<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> (some speak of intuition in such contexts<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a>).</li>
<li>Abduction guesses a new or outside idea so as to account in a plausible, instinctive, economical way for a surprising or very complicated phenomenon. That is its proximate aim.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
<li>Its longer aim is to economize inquiry itself. Its rationale is inductive: it works often enough, is the only source of new ideas, and has no substitute in expediting the discovery of new truths.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> Its rationale especially involves its role in coordination with other modes of inference in inquiry. It is inference to explanatory hypotheses for selection of those best worth trying.</li>
<li><a class="uri" href="Pragmatism" title="wikilink">Pragmatism</a> is the logic of abduction. Upon the generation of an explanation (which he came to regard as instinctively guided), the <a href="pragmatic_maxim" title="wikilink">pragmatic maxim</a> gives the necessary and sufficient logical rule to abduction in general. The hypothesis, being insecure, needs to have conceivable<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> implications for informed practice, so as to be testable<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> and, through its trials, to expedite and economize inquiry. The economy of research is what calls for abduction and governs its art.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></li>
</ul>

<p>Writing in 1910, Peirce admits that "in almost everything I printed before the beginning of this century I more or less mixed up hypothesis and induction" and he traces the confusion of these two types of reasoning to logicians' too "narrow and formalistic a conception of inference, as necessarily having formulated judgments from its premises."<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>

<p>He started out in the 1860s treating hypothetical inference in a number of ways which he eventually peeled away as inessential or, in some cases, mistaken:</p>
<ul>
<li>as inferring the occurrence of a character (a characteristic) from the observed combined occurrence of multiple characters which its occurrence would necessarily involve;<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> for example, if any occurrence of <em>A</em> is known to necessitate occurrence of <em>B, C, D, E</em>, then the observation of <em>B, C, D, E</em> suggests by way of explanation the occurrence of <em>A</em>. (But by 1878 he no longer regarded such multiplicity as common to all hypothetical inference.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a>)</li>
<li>as aiming for a more or less probable hypothesis (in 1867 and 1883 but not in 1878; anyway by 1900 the justification is not probability but the lack of alternatives to guessing and the fact that guessing is fruitful;<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> by 1903 he speaks of the "likely" in the sense of nearing the truth in an "indefinite sense";<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> by 1908 he discusses <em>plausibility</em> as instinctive appeal.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a>) In a paper dated by editors as <em>circa</em> 1901, he discusses "instinct" and "naturalness", along with the kind of considerations (low cost of testing, logical caution, breadth, and incomplexity) that he later calls methodeutical.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></li>
<li>as induction from characters (but as early as 1900 he characterized abduction as guessing<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a>)</li>
<li>as citing a known rule in a premise rather than hypothesizing a rule in the conclusion (but by 1903 he allowed either approach<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><ref name="newidea">Peirce, C. S., "A Syllabus of Certain Topics of Logic" (1903), <em>Essential Peirce</em> v. 2, p. 287:</ref></li>
</ul>

<p>)</p>
<ul>
<li>as basically a transformation of a deductive categorical syllogism<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> (but in 1903 he offered a variation on <em>modus ponens</em> instead,<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> and by 1911 he was unconvinced that any one form covers all hypothetical inference<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a>).</li>
</ul>
<h3 id="section">1867</h3>

<p>In 1867, in "The Natural Classification of Arguments",<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> hypothetical inference always deals with a cluster of characters (call them <em>P′, P′′, P′′′,</em> etc.) known to occur at least whenever a certain character (<em>M</em>) occurs. Note that categorical syllogisms have elements traditionally called middles, predicates, and subjects. For example: All <em>men</em> [middle] are <em>mortal</em> [predicate]; <em>Socrates</em> [subject] is a <em>man</em> [middle]; ergo <em>Socrates</em> [subject] is <em>mortal</em> [predicate]". Below, 'M' stands for a middle; 'P' for a predicate; 'S' for a subject. Note also that Peirce held that all deduction can be put into the form of the categorical <a class="uri" href="syllogism" title="wikilink">syllogism</a> <a href="Syllogism#Modus_Barbara" title="wikilink">Barbara (AAA-1)</a>.</p>
<blockquote>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>[Deduction].</p></td>
<td style="text-align: left;">
<p>[Any] M is P<br/>
</p></td>
<td style="text-align: left;">
<p>[Any] S is M<br/>


<math display="inline" id="Abductive_reasoning:120">
 <semantics>
  <mo>∴</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">therefore</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \therefore
  </annotation>
 </semantics>
</math>

 [Any] S is P.</p></td>
<td style="text-align: left;">
<p>Induction. <em>S′, S′′, S′′′</em>, &amp;c.; are taken at random as <em>M</em>'s;<br/>
<em>S′, S′′, S′′′</em>, &amp;c.; are <em>P</em>:<br/>


<math display="inline" id="Abductive_reasoning:121">
 <semantics>
  <mo>∴</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">therefore</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \therefore
  </annotation>
 </semantics>
</math>

 Any <em>M</em> is probably <em>P</em>.</p></td>
<td style="text-align: left;">
<p>Hypothesis. Any <em>M</em> is, for instance, <em>P′, P′′, P′′′,</em> &amp;c.;<br/>
<em>S</em> is <em>P′, P′′, P′′′,</em> &amp;c.;:<br/>


<math display="inline" id="Abductive_reasoning:122">
 <semantics>
  <mo>∴</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">therefore</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \therefore
  </annotation>
 </semantics>
</math>

 <em>S</em> is probably <em>M</em>.</p></td>
</tr>
</tbody>
</table>

<p></p>
</blockquote>
<h3 id="section-1">1878</h3>

<p>In 1878, in "Deduction, Induction, and Hypothesis",<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> there is no longer a need for multiple characters or predicates in order for an inference to be hypothetical, although it is still helpful. Moreover Peirce no longer poses hypothetical inference as concluding in a <em>probable</em> hypothesis. In the forms themselves, it is understood but not explicit that induction involves random selection and that hypothetical inference involves response to a "very curious circumstance". The forms instead emphasize the modes of inference as rearrangements of one another's propositions (without the bracketed hints shown below).</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Deduction. <em>Rule:</em> All the beans from this bag are white.<br/>
<em>Case:</em> These beans are from this bag.<br/>


<math display="inline" id="Abductive_reasoning:123">
 <semantics>
  <mo>∴</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">therefore</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \therefore
  </annotation>
 </semantics>
</math>

 <em>Result:</em> These beans are white.</p></td>
<td style="text-align: left;">
<p>Induction. <em>Case:</em> These beans are [randomly selected] from this bag.<br/>
<em>Result:</em> These beans are white.<br/>


<math display="inline" id="Abductive_reasoning:124">
 <semantics>
  <mo>∴</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">therefore</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \therefore
  </annotation>
 </semantics>
</math>

 <em>Rule:</em> All the beans from this bag are white.</p></td>
<td style="text-align: left;">
<p>Hypothesis. <em>Rule:</em> All the beans from this bag are white.<br/>
<em>Result:</em> These beans [oddly] are white.<br/>


<math display="inline" id="Abductive_reasoning:125">
 <semantics>
  <mo>∴</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">therefore</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \therefore
  </annotation>
 </semantics>
</math>

 <em>Case:</em> These beans are from this bag.</p></td>
</tr>
</tbody>
</table>
<h3 id="section-2">1883</h3>

<p>Peirce long treated abduction in terms of induction from characters or traits (weighed, not counted like objects), explicitly so in his influential 1883 "A Theory of Probable Inference", in which he returns to involving probability in the hypothetical conclusion.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> Like "Deduction, Induction, and Hypothesis" in 1878, it was widely read (see the historical books on statistics by <a href="Stephen_Stigler" title="wikilink">Stephen Stigler</a>), unlike his later amendments of his conception of abduction. Today abduction remains most commonly understood as induction from characters and extension of a known rule to cover unexplained circumstances.</p>

<p><a href="Sherlock_Holmes" title="wikilink">Sherlock Holmes</a> uses this method of reasoning in the stories of <a href="Arthur_Conan_Doyle" title="wikilink">Arthur Conan Doyle</a>, although Holmes refers to it as <a href="deductive_reasoning" title="wikilink">deductive reasoning</a>.</p>
<h3 id="and-after">1902 and after</h3>

<p>In 1902 Peirce wrote that he now regarded the syllogistical forms and the doctrine of extension and comprehension (i.e., objects and characters as referenced by terms), as being less fundamental than he had earlier thought.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> In 1903 he offered the following form for abduction:<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a>  The hypothesis is framed, but not asserted, in a premise, then asserted as rationally suspectable in the conclusion. Thus, as in the earlier categorical syllogistic form, the conclusion is formulated from some premise(s). But all the same the hypothesis consists more clearly than ever in a new or outside idea beyond what is known or observed. Induction in a sense goes beyond observations already reported in the premises, but it merely amplifies ideas already known to represent occurrences, or tests an idea supplied by hypothesis; either way it requires previous abductions in order to get such ideas in the first place. Induction seeks facts to test a hypothesis; abduction seeks a hypothesis to account for facts.</p>

<p>Note that the hypothesis ("A") could be of a rule. It need not even be a rule strictly necessitating the surprising observation ("C"), which needs to follow only as a "matter of course"; or the "course" itself could amount to some known rule, merely alluded to, and also not necessarily a rule of strict necessity. In the same year, Peirce wrote that reaching a hypothesis may involve placing a surprising observation under either a newly hypothesized rule or a hypothesized combination of a known rule with a peculiar state of facts, so that the phenomenon would be not surprising but instead either necessarily implied or at least likely.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>

<p>Peirce did not remain quite convinced about any such form as the categorical syllogistic form or the 1903 form. In 1911, he wrote, "I do not, at present, feel quite convinced that any logical form can be assigned that will cover all 'Retroductions'. For what I mean by a Retroduction is simply a conjecture which arises in the mind."<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></p>
<h3 id="pragmatism">Pragmatism</h3>

<p>In 1901 Peirce wrote, "There would be no logic in imposing rules, and saying that they ought to be followed, until it is made out that the purpose of hypothesis requires them."<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> In 1903 Peirce called <a class="uri" href="pragmatism" title="wikilink">pragmatism</a> "the logic of abduction" and said that the <a href="pragmatic_maxim" title="wikilink">pragmatic maxim</a> gives the necessary and sufficient logical rule to abduction in general.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> The pragmatic maxim is: "Consider what effects, that might conceivably have practical bearings, we conceive the object of our conception to have. Then, our conception of these effects is the whole of our conception of the object." It is a method for fruitful clarification of conceptions by equating the meaning of a conception with the conceivable practical implications of its object's conceived effects. Peirce held that that is precisely tailored to abduction's purpose in inquiry, the forming of an idea that could conceivably shape informed conduct. In various writings in the 1900s<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a><a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> he said that the conduct of abduction (or retroduction) is governed by considerations of economy, belonging in particular to the economics of research. He regarded economics as a normative science whose analytic portion might be part of logical methodeutic (that is, theory of inquiry).<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a></p>
<h3 id="three-levels-of-logic-about-abduction">Three levels of logic about abduction</h3>

<p>Peirce came over the years to <a href="Classification_of_the_sciences_(Peirce)#Sciences" title="wikilink">divide (philosophical) logic</a> into three departments:</p>
<ol>
<li>Stechiology, or speculative grammar, on the conditions for meaningfulness. Classification of signs (semblances, symptoms, symbols, etc.) and their combinations (as well as their objects and <a href="interpretant" title="wikilink">interpretants</a>).</li>
<li>Logical critic, or logic proper, on validity or justifiability of inference, the conditions for true representation. Critique of arguments in their various modes (deduction, induction, abduction).</li>
<li>Methodeutic, or speculative rhetoric, on the conditions for determination of interpretations. Methodology of inquiry in its interplay of modes.</li>
</ol>

<p>Peirce had, from the start, seen the modes of inference as being coordinated together in scientific inquiry and, by the 1900s, held that hypothetical inference in particular is inadequately treated at the level of critique of arguments.<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a><a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> To increase the assurance of a hypothetical conclusion, one needs to deduce implications about evidence to be found, predictions which induction can test through observation so as to evaluate the hypothesis. That is <a href="Charles_Sanders_Peirce#Scientific_method" title="wikilink">Peirce's outline of the scientific method</a> of inquiry, as covered in his inquiry methodology, which includes <a class="uri" href="pragmatism" title="wikilink">pragmatism</a> or, as he later called it, <a class="uri" href="pragmaticism" title="wikilink">pragmaticism</a>, the clarification of ideas in terms of their conceivable implications regarding informed practice.</p>
<h4 id="classification-of-signs">Classification of signs</h4>

<p>As early as 1866,<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a> Peirce held that:</p>

<p>1. Hypothesis (abductive inference) is inference through an <em>icon</em> (also called a <em>likeness</em>).<br/>
2. Induction is inference through an <em>index</em> (a sign by factual connection); a sample is an index of the totality from which it is drawn.<br/>
3. Deduction is inference through a <em>symbol</em> (a sign by interpretive habit irrespective of resemblance or connection to its object).</p>

<p>In 1902, Peirce wrote that, in abduction: "It is recognized that the phenomena are <em>like</em>, i.e. constitute an Icon of, a replica of a general conception, or Symbol."<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a></p>
<h4 id="critique-of-arguments">Critique of arguments</h4>

<p>At the critical level Peirce examined the forms of abductive arguments (as discussed above), and came to hold that the hypothesis should economize explanation for plausibility in terms of the feasible and natural. In 1908 Peirce described this plausibility in some detail.<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> It involves not likeliness based on observations (which is instead the inductive evaluation of a hypothesis), but instead optimal simplicity in the sense of the "facile and natural", as by Galileo's natural light of reason and as distinct from "logical simplicity" (Peirce does not dismiss logical simplicity entirely but sees it in a subordinate role; taken to its logical extreme it would favor adding no explanation to the observation at all). Even a well-prepared mind guesses oftener wrong than right, but our guesses succeed better than random luck at reaching the truth or at least advancing the inquiry, and that indicates to Peirce that they are based in instinctive attunement to nature, an affinity between the mind's processes and the processes of the real, which would account for why appealingly "natural" guesses are the ones that oftenest (or least seldom) succeed; to which Peirce added the argument that such guesses are to be preferred since, without "a natural bent like nature's", people would have no hope of understanding nature. In 1910 Peirce made a three-way distinction between probability, verisimilitude, and plausibility, and defined plausibility with a normative "ought": "By plausibility, I mean the degree to which a theory ought to recommend itself to our belief independently of any kind of evidence other than our instinct urging us to regard it favorably."<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a> For Peirce, plausibility does not depend on observed frequencies or probabilities, or on verisimilitude, or even on testability, which is not a question of the critique of the hypothetical inference <em>as</em> an inference, but rather a question of the hypothesis's relation to the inquiry process.</p>

<p>The phrase "inference to the best explanation" (not used by Peirce but often applied to hypothetical inference) is not always understood as referring to the most simple and natural. However, in other senses of "best", such as "standing up best to tests", it is hard to know which is the best explanation to form, since one has not tested it yet. Still, for Peirce, any justification of an abductive inference as good is not completed upon its formation as an argument (unlike with induction and deduction) and instead depends also on its methodological role and promise (such as its testability) in advancing inquiry.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a><a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a><a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p>
<h4 id="methodology-of-inquiry">Methodology of inquiry</h4>

<p>At the methodeutical level Peirce held that a hypothesis is judged and selected<a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> for testing because it offers, via its trial, to expedite and economize the inquiry process itself toward new truths, first of all by being testable and also by further economies,<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a> in terms of cost, value, and relationships among guesses (hypotheses). Here, considerations such as probability, absent from the treatment of abduction at the critical level, come into play. For examples:</p>
<ul>
<li>Cost: A simple but low-odds guess, if low in cost to test for falsity, may belong first in line for testing, to get it out of the way. If surprisingly it stands up to tests, that is worth knowing early in the inquiry, which otherwise might have stayed long on a wrong though seemingly likelier track.</li>
<li>Value: A guess is intrinsically worth testing if it has instinctual plausibility or reasoned objective probability, while <a href="Subjective_probability" title="wikilink">subjective likelihood</a>, though reasoned, can be treacherous.</li>
<li>Interrelationships: Guesses can be chosen for trial strategically for their
<ul>
<li><em>caution</em>, for which Peirce gave as example the game of <a href="Twenty_Questions" title="wikilink">Twenty Questions</a>,</li>
<li><em>breadth</em> of applicability to explain various phenomena, and</li>
<li><em>incomplexity</em>, that of a hypothesis that seems too simple but whose trial "may give a good 'leave,' as the billiard-players say", and be instructive for the pursuit of various and conflicting hypotheses that are less simple.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a></li>
</ul></li>
</ul>
<h3 id="other-writers">Other writers</h3>

<p><a href="Norwood_Russell_Hanson" title="wikilink">Norwood Russell Hanson</a>, a <a href="philosopher_of_science" title="wikilink">philosopher of science</a>, wanted to grasp a logic explaining how scientific discoveries take place. He used Peirce's notion of abduction for this.<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a></p>

<p>Further development of the concept can be found in <a href="Peter_Lipton" title="wikilink">Peter Lipton</a>'s <em>Inference to the Best Explanation</em> (Lipton, 1991).</p>
<h2 id="applications">Applications</h2>

<p>Applications in <a href="artificial_intelligence" title="wikilink">artificial intelligence</a> include <a href="Diagnosis_(artificial_intelligence)" title="wikilink">fault diagnosis</a>, <a href="belief_revision" title="wikilink">belief revision</a>, and <a href="automated_planning" title="wikilink">automated planning</a>. The most direct application of abduction is that of automatically detecting faults in systems: given a theory relating faults with their effects and a set of observed effects, abduction can be used to derive sets of faults that are likely to be the cause of the problem.</p>

<p>In <a class="uri" href="medicine" title="wikilink">medicine</a>, abduction can be seen as a component of clinical evaluation and judgment.<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a><a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a></p>

<p>Abduction can also be used to model <a href="automated_planning" title="wikilink">automated planning</a>.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a> Given a logical theory relating action occurrences with their effects (for example, a formula of the <a href="event_calculus" title="wikilink">event calculus</a>), the problem of finding a plan for reaching a state can be modeled as the problem of abducting a set of literals implying that the final state is the goal state.</p>

<p>In <a href="intelligence_analysis" title="wikilink">intelligence analysis</a>, <a href="Analysis_of_Competing_Hypotheses" title="wikilink">Analysis of Competing Hypotheses</a> and <a href="Bayesian_network" title="wikilink">Bayesian networks</a>, probabilistic abductive reasoning is used extensively. Similarly in <a href="medical_diagnosis" title="wikilink">medical diagnosis</a> and legal reasoning, the same methods are being used, although there have been many examples of errors, especially caused by the <a href="base_rate_fallacy" title="wikilink">base rate fallacy</a> and the <a href="prosecutor's_fallacy" title="wikilink">prosecutor's fallacy</a>.</p>

<p><a href="Belief_revision" title="wikilink">Belief revision</a>, the process of adapting beliefs in view of new information, is another field in which abduction has been applied. The main problem of belief revision is that the new information may be inconsistent with the corpus of beliefs, while the result of the incorporation cannot be inconsistent. This process can be done by the use of abduction: once an explanation for the observation has been found, integrating it does not generate inconsistency. This use of abduction is not straightforward, as adding <a href="propositional_formula" title="wikilink">propositional formulae</a> to other propositional formulae can only make inconsistencies worse. Instead, abduction is done at the level of the ordering of preference of the possible worlds. Preference models use fuzzy logic or utility models.</p>

<p>In the <a href="philosophy_of_science" title="wikilink">philosophy of science</a>, abduction has been the key inference method to support <a href="scientific_realism" title="wikilink">scientific realism</a>, and much of the debate about scientific realism is focused on whether abduction is an acceptable method of inference.</p>

<p>In <a href="historical_linguistics" title="wikilink">historical linguistics</a>, abduction during language acquisition is often taken to be an essential part of processes of <a href="language_change" title="wikilink">language change</a> such as reanalysis and <a class="uri" href="analogy" title="wikilink">analogy</a>.<a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p>

<p>In <a class="uri" href="anthropology" title="wikilink">anthropology</a>, <a href="Alfred_Gell" title="wikilink">Alfred Gell</a> in his influential book <em>Art and Agency</em> defined abduction (after Eco<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a>) as "a case of synthetic inference 'where we find some very curious circumstances, which would be explained by the supposition that it was a case of some general rule, and thereupon adopt that supposition".<a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a> Gell criticizes existing 'anthropological' studies of art, for being too preoccupied with aesthetic value and not preoccupied enough with the central anthropological concern of uncovering 'social relationships,' specifically the social contexts in which artworks are produced, circulated, and received.<a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a> Abduction is used as the mechanism for getting from art to agency. That is, abduction can explain how works of art inspire a <em>sensus communis:</em> the commonly-held views shared by members that characterize a given society.<a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a> The question Gell asks in the book is, 'how does it initially 'speak' to people?' He answers by saying that "No reasonable person could suppose that art-like relations between people and things do not involve at least some form of <a class="uri" href="semiosis" title="wikilink">semiosis</a>."<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a> However, he rejects any intimation that semiosis can be thought of as a language because then he would have to admit to some pre-established existence of the <em>sensus communis</em> that he wants to claim only emerges afterwards out of art. Abduction is the answer to this conundrum because the tentative nature of the abduction concept (Peirce likened it to guessing) means that not only can it operate outside of any pre-existing framework, but moreover, it can actually intimate the existence of a framework. As Gell reasons in his analysis, the physical existence of the artwork prompts the viewer to perform an abduction that imbues the artwork with intentionality. A statue of a goddess, for example, in some senses actually becomes the goddess in the mind of the beholder; and represents not only the form of the deity but also her intentions (which are adduced from the feeling of her very presence). Therefore through abduction, Gell claims that art can have the kind of agency that plants the seeds that grow into cultural myths. The power of agency is the power to motivate actions and inspire ultimately the shared understanding that characterizes any given society.<a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Abductive_logic_programming" title="wikilink">Abductive logic programming</a></li>
<li><a class="uri" href="Analogy" title="wikilink">Analogy</a></li>
<li><a href="Analysis_of_Competing_Hypotheses" title="wikilink">Analysis of Competing Hypotheses</a></li>
<li><a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a></li>
<li><a href="Charles_Sanders_Peirce_bibliography" title="wikilink">Charles Sanders Peirce bibliography</a></li>
<li><a href="Deductive_reasoning" title="wikilink">Deductive reasoning</a></li>
<li><a href="Defeasible_reasoning" title="wikilink">Defeasible reasoning</a></li>
<li><a href="Doug_Walton" title="wikilink">Doug Walton</a></li>
<li><a href="Gregory_Bateson" title="wikilink">Gregory Bateson</a></li>
<li><a href="Inductive_inference" title="wikilink">Inductive inference</a></li>
<li><a href="Inductive_probability" title="wikilink">Inductive probability</a></li>
<li><a href="Inductive_reasoning" title="wikilink">Inductive reasoning</a></li>
<li><a class="uri" href="Inquiry" title="wikilink">Inquiry</a></li>
<li><a href="Portal:thinking#Topics_related_to_Thinking" title="wikilink">List of thinking-related topics</a></li>
<li><a class="uri" href="Practopoiesis" title="wikilink">Practopoiesis</a></li>
<li><a class="uri" href="Logic" title="wikilink">Logic</a></li>
<li><a href="Subjective_logic" title="wikilink">Subjective logic</a></li>
<li><a href="Logical_reasoning" title="wikilink">Logical reasoning</a></li>
<li><a href="Maximum_likelihood" title="wikilink">Maximum likelihood</a></li>
<li><a href="Scientific_method" title="wikilink">Scientific method</a></li>
<li><a href="Sherlock_Holmes" title="wikilink">Sherlock Holmes</a></li>
<li><a href="Sign_relation" title="wikilink">Sign relation</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>Awbrey, Jon, and Awbrey, Susan (1995), "Interpretation as Action: The Risk of Inquiry", <em>Inquiry: Critical Thinking Across the Disciplines</em>, 15, 40-52. <a href="http://www.chss.montclair.edu/inquiry/fall95/awbrey.html">Eprint</a></li>
<li>Cialdea Mayer, Marta and Pirri, Fiora (1993) "First order abduction via tableau and sequent calculi" Logic Jnl IGPL 1993 1: 99-117; . <a href="http://jigpal.oxfordjournals.org/content/vol1/issue1/index.dtl#ARTICLES">Oxford Journals</a></li>
<li>Cialdea Mayer, Marta and Pirri, Fiora (1995) "Propositional Abduction in Modal Logic", Logic Jnl IGPL 1995 3: 907-919;  <a href="http://jigpal.oxfordjournals.org/content/vol3/issue6/">Oxford Journals</a></li>
<li>Edwards, Paul (1967, eds.), "The Encyclopedia of Philosophy," Macmillan Publishing Co, Inc. &amp; The Free Press, New York. Collier Macmillan Publishers, London.</li>
<li>

<p>, T., and Gottlob, G. (1995), "The Complexity of Logic-Based Abduction, <em>Journal of the ACM</em>, 42.1, 3-42.</p></li>
<li>Hanson, N. R. (1958). <em>Patterns of Discovery: An Inquiry into the Conceptual Foundations of Science</em>, Cambridge: Cambridge University Press. ISBN 978-0-521-09261-6.</li>
<li></li>
<li>Josephson, John R., and Josephson, Susan G. (1995, eds.), <em>Abductive Inference: Computation, Philosophy, Technology</em>, Cambridge University Press, Cambridge, UK.</li>
<li>Lipton, Peter. (2001). <em>Inference to the Best Explanation</em>, London: Routledge. ISBN 0-415-24202-9.</li>
<li>McKaughan, Daniel J. (2008), "From Ugly Duckling to Swan: C. S. Peirce, Abduction, and the Pursuit of Scientific Theories", <em>Transactions of the Charles S. Peirce Society</em>, v. 44, no. 3 (summer), 446–468. <a href="http://inscribe.iupress.org/doi/abs/10.2979/TRA.2008.44.3.446">Abstract</a>.</li>
<li></li>
<li>Queiroz, Joao &amp; Merrell, Floyd (guest eds.). (2005). "Abduction - between subjectivity and objectivity". (special issue on abductive inference) Semiotica 153 (1/4). <a href="http://www.degruyter.com/view/j/semi.2005.2005.issue-153-1-4/issue-files/semi.2005.2005.issue-153-1-4.xml">1</a>.</li>
<li>Santaella, Lucia (1997) "The Development of Peirce's Three Types of Reasoning: Abduction, Deduction, and Induction", 6th Congress of the <a class="uri" href="IASS" title="wikilink">IASS</a>. <a href="http://www.pucsp.br/~lbraga/epap_peir1.htm">Eprint</a>.</li>
<li>Sebeok, T. (1981) "You Know My Method". In Sebeok, T. "The Play of Musement". Indiana. Bloomington, IA.</li>
<li>Yu, Chong Ho (1994), "Is There a Logic of Exploratory Data Analysis?", <em>Annual Meeting of American Educational Research Association</em>, New Orleans, LA, April, 1994. <a href="http://www.creative-wisdom.com/pub/Peirce/Logic_of_EDA.html">Website of Dr. Chong Ho (Alex) Yu</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li>"<a href="http://www.cse.ohio-state.edu/lair/research.html">Abductive Inference</a>" (once there, scroll down), John R. Josephson, Laboratory for Artificial Intelligence Research, Ohio State University. (<a href="https://web.archive.org/web/20110720020440/http://www.cse.ohio-state.edu/lair/Projects/Abduction/abduction.html">Former webpage</a> via the Wayback Machine.)</li>
<li>"<a href="http://plato.stanford.edu/entries/peirce/#dia">Deduction, Induction, and Abduction</a>", Chapter 3 in article "<a href="http://plato.stanford.edu/entries/peirce/">Charles Sanders Peirce</a>" by Robert Burch, 2001 and 2006, in the <a href="http://plato.stanford.edu/">Stanford Encyclopedia of Philosophy</a>.</li>
<li>"<a href="http://carbon.ucdenver.edu/~mryder/itc/abduction.html">Abduction</a>", links to articles and websites on abductive inference, <a href="http://carbon.ucdenver.edu/~mryder/martin.html">Martin Ryder</a>.</li>
<li><a href="http://user.uni-frankfurt.de/~wirth/">International Research Group on Abductive Inference</a>, <span lang="de">Uwe Wirth</span> and <span lang="de">Alexander Roesler</span>, eds. Uses frames. Click on link at bottom of its home page for English. Wirth moved to <a href="University_of_Gießen" title="wikilink">U. of <span lang="de">Gießen</span></a>, Germany, and set up <a href="http://www.abduktionsforschung.de/"><span lang="de">Abduktionsforschung</span></a>, home page not in English but see Artikel section there. [<a class="uri" href="http://translate.google.com/translate?js=n&amp;layout">http://translate.google.com/translate?js=n&amp;layout;</a>;=2&amp;eotf;=1&amp;sl;=de&amp;tl;=en&amp;u;=http%3A%2F%2Fwww.abduktionsforschung.de%2Fabduktionsforschung.html <span lang="de">Abduktionsforschung</span> home page via Google translation].</li>
<li>"<a href="http://www.visual-memory.co.uk/b_resources/abduction.html">'You Know My Method': A Juxtaposition of Charles S. Peirce and Sherlock Holmes</a>" (1981), by <a href="Thomas_Sebeok" title="wikilink">Thomas Sebeok</a> with Jean Umiker-Sebeok, from <em>The Play of Musement</em>, Thomas Sebeok, Bloomington, Indiana: Indiana University Press, pp. 17–52.</li>
<li><a href="http://www.helsinki.fi/science/commens/dictionary.html">Commens Dictionary of Peirce's Terms</a>, Mats Bergman and Sami Paavola, editors, Helsinki U. Peirce's own definitions, often many per term across the decades. There, see "Hypothesis [as a form of reasoning]", "Abduction", "Retroduction", and "Presumption [as a form of reasoning]".</li>
</ul>

<p>"</p>

<p><a href="Category:Belief_revision" title="wikilink">Category:Belief revision</a> <a href="Category:Logic_and_statistics" title="wikilink">Category:Logic and statistics</a> <a class="uri" href="Category:Epistemology" title="wikilink">Category:Epistemology</a> <a class="uri" href="Category:Reasoning" title="wikilink">Category:Reasoning</a> <a href="Category:Charles_Sanders_Peirce" title="wikilink">Category:Charles Sanders Peirce</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">R. Josephson, J. &amp; G. Josephson, S. "Abductive Inference: Computation, Philosophy, Technology" <em>Cambridge University Press, New York &amp; Cambridge (U.K.)</em>. viii. 306 pages. Hard cover (1994), ISBN 0-521-43461-0, Paperback (1996), ISBN 0-521-57545-1.<a href="#fnref1">↩</a></li>
<li id="fn2"><mtpl></mtpl><a href="#fnref2">↩</a></li>
<li id="fn3">Sober, Elliot. Core Questions in Philosophy,5th edition.<a href="#fnref3">↩</a></li>
<li id="fn4">See, e.g. <em>Analysis of Evidence, 2d ed.</em> by Terence Anderson (Cambridge University Press, 2005)<a href="#fnref4">↩</a></li>
<li id="fn5">For examples, see "<a href="https://web.archive.org/web/20110720020440/http://www.cse.ohio-state.edu/lair/Projects/Abduction/abduction.html">Abductive Inference in Reasoning and Perception</a>", John R. Josephson, Laboratory for Artificial Intelligence Research, Ohio State University, and <em>Abduction, Reason, and Science. Processes of Discovery and Explanation</em> by <a href="Lorenzo_Magnani" title="wikilink">Lorenzo Magnani</a> (Kluwer Academic/Plenum Publishers, New York, 2001).<a href="#fnref5">↩</a></li>
<li id="fn6">Peirce, C. S. (1903), Harvard lectures on pragmatism, <em>Collected Papers</em> v. 5, <a href="http://www.textlog.de/7664-2.html">paragraphs 188–189</a>.<a href="#fnref6">↩</a></li>
<li id="fn7">A Letter to J. H. Kehler (1911), <em>New Elements of Mathematics</em> v. 3, pp. 203–4, see under "<a href="http://www.helsinki.fi/science/commens/terms/retroduction.html">Retroduction</a>" at <em>Commens Dictionary of Peirce's Terms</em>.<a href="#fnref7">↩</a></li>
<li id="fn8">Peirce, C.S. (1902), application to the Carnegie Institution, see MS L75.329-330, from <a href="http://www.cspeirce.com/menu/library/bycsp/l75/ver1/l75v1-08.htm#m27">Draft D</a> of Memoir 27: <a href="#fnref8">↩</a></li>
<li id="fn9">Peirce MS. 692, quoted in Sebeok, T. (1981) "<a href="http://www.visual-memory.co.uk/b_resources/abduction.html">You Know My Method</a>" in Sebeok, T., <em>The Play of Musement</em>, Bloomington, IA: Indiana, page 24.<a href="#fnref9">↩</a></li>
<li id="fn10">Peirce MS. 696, quoted in Sebeok, T. (1981) "<a href="http://www.visual-memory.co.uk/b_resources/abduction.html">You Know My Method</a>" in Sebeok, T., <em>The Play of Musement</em>, Bloomington, IA: Indiana, page 31.<a href="#fnref10">↩</a></li>
<li id="fn11">Jonathan Koehler. The Base Rate Fallacy Reconsidered: Descriptive, Normative and Methodological Challenges. <em>Behavioral and Brain Sciences.</em> 19, 1996.<a href="#fnref11">↩</a></li>
<li id="fn12">Robertson, B., &amp; Vignaux, G. A. (1995). '' Interpreting evidence: Evaluating forensic evidence in the courtroom. '' Chichester: John Wiley and Sons.<a href="#fnref12">↩</a></li>
<li id="fn13">A. Jøsang. Conditional Reasoning with Subjective Logic. <em>Journal of multiple valued logic and soft computing</em>. 15(1), pp.5-38, 2008.<a href="http://persons.unik.no/josang/papers/Jos2008-JMVLSC.pdf">PDF</a><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16">Popper, Karl (2002), <em>Conjectures and Refutations: The Growth of Scientific Knowledge</em>, London, UK: Routledge. p 536<a href="#fnref16">↩</a></li>
<li id="fn17">See Santaella, Lucia (1997) "The Development of Peirce's Three Types of Reasoning: Abduction, Deduction, and Induction", 6th Congress of the <a class="uri" href="IASS" title="wikilink">IASS</a>. <a href="http://www.pucsp.br/~lbraga/epap_peir1.htm">Eprint</a>.<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20">Peirce, C. S. (1908), "<a href="s:A_Neglected_Argument_for_the_Reality_of_God" title="wikilink">A Neglected Argument for the Reality of God</a>", <em>Hibbert Journal</em> v. 7, pp. 90–112, see §4. In <em>Collected Papers</em> v. 6, see paragraph 476. In <em>The Essential Peirce</em> v. 2, see p. 444.<a href="#fnref20">↩</a></li>
<li id="fn21">Peirce, C. S. (1908), "<a href="s:A_Neglected_Argument_for_the_Reality_of_God" title="wikilink">A Neglected Argument for the Reality of God</a>", <em>Hibbert Journal</em> v. 7, pp. 90–112. See both part III and part IV. Reprinted, including originally unpublished portion, in <em>Collected Papers</em> v. 6, paragraphs 452–85, <em>Essential Peirce</em> v. 2, pp. 434–50, and elsewhere.<a href="#fnref21">↩</a></li>
<li id="fn22">Peirce used the term "intuition" not in the sense of an instinctive or anyway half-conscious inference as people often do currently. Instead he used "intuition" usually in the sense of a cognition devoid of logical determination by previous cognitions. He said, "We have no power of Intuition" in that sense. See his "Some Consequences of Four Incapacities" (1868), <a href="http://www.peirce.org/writings/p27.html">Eprint</a>.<a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24">For a relevant discussion of Peirce and the aims of abductive inference, see McKaughan, Daniel J. (2008), "From Ugly Duckling to Swan: C. S. Peirce, Abduction, and the Pursuit of Scientific Theories", <em>Transactions of the Charles S. Peirce Society</em>, v. 44, no. 3 (summer), 446–468.<a href="#fnref24">↩</a></li>
<li id="fn25">Peirce means "conceivable" very broadly. See <em>Collected Papers</em> v. 5, paragraph 196, or <em>Essential Peirce</em> v. 2, p. 235, "Pragmatism as the Logic of Abduction" (Lecture VII of the 1903 Harvard lectures on pragmatism): <a href="#fnref25">↩</a></li>
<li id="fn26">Peirce, C. S., Carnegie Application (L75, 1902, <em>New Elements of Mathematics</em> v. 4, pp. 37–38. See under "<a href="http://www.helsinki.fi/science/commens/terms/abduction.html">Abduction</a>" at the <em>Commens Dictionary of Peirce's Terms</em>: <a href="#fnref26">↩</a></li>
<li id="fn27">Peirce, "Pragmatism as the Logic of Abduction" (Lecture VII of the 1903 Harvard lectures on pragmatism), see parts III and IV. Published in part in <em>Collected Papers</em> v. 5, paragraphs 180–212 (see 196–200, <a href="http://www.textlog.de/7663.html">Eprint</a> and in full in <em>Essential Peirce</em> v. 2, pp. 226–241 (see sections III and IV). <a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29">Peirce, A Letter to <a href="Paul_Carus" title="wikilink">Paul Carus</a> circa 1910, <em>Collected Papers</em> v. 8, paragraphs 227–228. See under "<a href="http://www.helsinki.fi/science/commens/terms/hypothesis.html">Hypothesis</a>" at the <em>Commens Dictionary of Peirce's Terms</em>.<a href="#fnref29">↩</a></li>
<li id="fn30">(1867), "On the Natural Classification of Arguments", <em>Proceedings of the American Academy of Arts and Sciences</em> v. 7, pp. 261–287. Presented April 9, 1867. See especially starting at [<a class="uri" href="http://books.google.com/books?id=nG8UAAAAYAAJ&amp;pg">http://books.google.com/books?id=nG8UAAAAYAAJ&amp;pg;</a>;=PA284 p. 284] in Part III §1. Reprinted in ''Collected Papers v. 2, paragraphs 461–516 and <em>Writings</em> v. 2, pp. 23–49.''<a href="#fnref30">↩</a></li>
<li id="fn31">Peirce, C. S. (1878), "Deduction, Induction, and Hypothesis", <em>Popular Science Monthly</em>, v. 13, pp. 470–82, see [<a class="uri" href="http://books.google.com/books?id=u8sWAQAAIAAJ&amp;jtp">http://books.google.com/books?id=u8sWAQAAIAAJ&amp;jtp;</a>;=472 472]. <em>Collected Papers</em> 2.619–44, see 623.<a href="#fnref31">↩</a></li>
<li id="fn32">A letter to Langley, 1900, published in <em>Historical Perspectives on Peirce's Logic of Science</em>. See excerpts under "<a href="http://www.helsinki.fi/science/commens/terms/abduction.html">Abduction</a>" at the <em>Commens Dictionary of Peirce's Terms</em>.<a href="#fnref32">↩</a></li>
<li id="fn33">"A Syllabus of Certain Topics of Logic'" (1903 manuscript), <em>Essential Peirce</em> v. 2, see p. 287. See under "<a href="http://www.helsinki.fi/science/commens/terms/abduction.html">Abduction</a>" at the <em>Commens Dictionary of Peirce's Terms</em>.<a href="#fnref33">↩</a></li>
<li id="fn34"></li>
<li id="fn35">Peirce, C. S., "On the Logic of Drawing History from Ancient Documents", dated as <em>circa</em> 1901 both by the editors of <em>Collected Papers</em> (see CP v. 7, bk 2, ch. 3, footnote 1) and by those of the <em>Essential Peirce</em> (EP) (<a href="http://www.iupui.edu/~peirce/ep/ep2/headers/ep2headx.htm#8">Eprint</a>. The article's discussion of abduction is in CP v. 7, paragraphs 218–31 and in EP v. 2, pp. 107–14.<a href="#fnref35">↩</a></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"></li>
<li id="fn43">Peirce, C. S. (1883), "A Theory of Probable Inference" in <em><a href="Charles_Sanders_Peirce_bibliography#SIL" title="wikilink">Studies in Logic</a></em>).<a href="#fnref43">↩</a></li>
<li id="fn44">In Peirce, C. S., 'Minute Logic' circa 1902, <em>Collected Papers</em> v. 2, paragraph 102. See under "<a href="http://www.helsinki.fi/science/commens/terms/abduction.html">Abduction</a>" at <em>Commens Dictionary of Peirce's Terms</em>.<a href="#fnref44">↩</a></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47"></li>
<li id="fn48">Peirce, "On the Logic of drawing History from Ancient Documents", 1901 manuscript, <em>Collected Papers</em> v. 7, paragraphs 164–231, see 202, reprinted in <em>Essential Peirce</em> v. 2, pp. 75–114, see 95. See under "<a href="http://www.helsinki.fi/science/commens/terms/abduction.html">Abduction</a>" at <em>Commens Dictionary of Peirce's Terms</em>.<a href="#fnref48">↩</a></li>
<li id="fn49"></li>
<li id="fn50"></li>
<li id="fn51">Peirce, "On the Logic of Drawing Ancient History from Documents", <em>Essential Peirce</em> v. 2, see pp. 107–9.<a href="#fnref51">↩</a></li>
<li id="fn52">Peirce, Carnegie application, L75 (1902), Memoir 28: "On the Economics of Research", scroll down to Draft E. <a href="http://www.cspeirce.com/menu/library/bycsp/l75/ver1/l75v1-08.htm#m28">Eprint</a>.<a href="#fnref52">↩</a></li>
<li id="fn53"></li>
<li id="fn54"></li>
<li id="fn55">Peirce, C. S., the 1866 Lowell Lectures on the Logic of Science, <em><a href="Charles_Sanders_Peirce_bibliography#W" title="wikilink">Writings of Charles S. Peirce</a></em> v. 1, p. 485. See under "<a href="http://www.helsinki.fi/science/commens/terms/hypothesis.html">Hypothesis</a>" at <em>Commens Dictionary of Peirce's Terms</em>.<a href="#fnref55">↩</a></li>
<li id="fn56">Peirce, C. S., "A Syllabus of Certain Topics of Logic", written 1903. See <em><a href="Charles_Sanders_Peirce_bibliography#EP" title="wikilink">The Essential Peirce</a></em> v. 2, p. 287. Quote viewable under "<a href="http://www.helsinki.fi/science/commens/terms/abduction.html">Abduction</a>" at <em>Commens Dictionary of Peirce's Terms</em>.<a href="#fnref56">↩</a></li>
<li id="fn57"></li>
<li id="fn58">Peirce, A Letter to Paul Carus 1910, <em>Collected Papers</em> v. 8, see paragraph 223.<a href="#fnref58">↩</a></li>
<li id="fn59"></li>
<li id="fn60"></li>
<li id="fn61">Peirce, C. S. (1902), Application to the Carnegie Institution, Memoir 27, <a href="http://www.cspeirce.com/menu/library/bycsp/l75/ver1/l75v1-08.htm#m27">Eprint</a>: "Of the different classes of arguments, abductions are the only ones in which after they have been admitted to be just, it still remains to inquire whether they are advantageous."<a href="#fnref61">↩</a></li>
<li id="fn62"></li>
<li id="fn63"></li>
<li id="fn64">Peirce, "On the Logic of Drawing Ancient History from Documents", <em>Essential Peirce</em> v. 2, see pp. 107–9 and 113. On Twenty Questions, p. 109, Peirce has pointed out that if each question eliminates half the possibilities, twenty questions can choose from among 2<sup>20</sup> or 1,048,576 objects, and goes on to say: <a href="#fnref64">↩</a></li>
<li id="fn65">Schwendtner, Tibor and Ropolyi, László and Kiss, Olga (eds): Hermeneutika és a természettudományok. Áron Kiadó, Budapest, 2001. It is written in Hungarian. Meaning of the title: Hermeneutics and the natural sciences. See, e.g., Hanson's <em>Patterns of Discovery</em> (Hanson, 1958), especially pp. 85-92<a href="#fnref65">↩</a></li>
<li id="fn66"><a href="#fnref66">↩</a></li>
<li id="fn67"><a href="#fnref67">↩</a></li>
<li id="fn68">Kave Eshghi. Abductive planning with the event calculus. In Robert A. Kowalski, Kenneth A. Bowen editors: Logic Programming, Proceedings of the Fifth International Conference and Symposium, Seattle, Washington, August 15–19, 1988. MIT Press 1988, ISBN 0-262-61056-6<a href="#fnref68">↩</a></li>
<li id="fn69">April M. S. McMahon (1994): Understanding language change. Cambridge: Cambridge University Press. ISBN 0-521-44665-1<a href="#fnref69">↩</a></li>
<li id="fn70">Eco, U. (1976). "A theory of Semiotics". Bloomington, IA: Indiana. p 131<a href="#fnref70">↩</a></li>
<li id="fn71">Gell, A. 1984, Art and Agency. Oxford: Oxford. p 14<a href="#fnref71">↩</a></li>
<li id="fn72">Bowden, R. (2004) A critique of Alfred Gell on Art and Agency. Retrieved Sept 2007 from: <a href="http://findarticles.com/p/articles/mi_qa3654/is_200406/ai_n9453295">Find Articles at BNET</a><a href="#fnref72">↩</a></li>
<li id="fn73">Whitney D. (2006) 'Abduction the agency of art.' Retrieved May 2009 from: <a href="http://arthistory.berkeley.edu/davis/Gell.pdf">University of California, Berkeley</a><a href="#fnref73">↩</a></li>
<li id="fn74"></li>
<li id="fn75"></li>
</ol>
</section>
</body>
</html>
