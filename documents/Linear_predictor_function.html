<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="29">Linear predictor function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Linear predictor function</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a> and in <a href="machine_learning" title="wikilink">machine learning</a>, a <strong>linear predictor function</strong> is a <a href="linear_function" title="wikilink">linear function</a> (<a href="linear_combination" title="wikilink">linear combination</a>) of a set of coefficients and explanatory variables (<a href="independent_variable" title="wikilink">independent variables</a>), whose value is used to predict the outcome of a <a href="dependent_variable" title="wikilink">dependent variable</a>. Functions of this sort are standard in <a href="linear_regression" title="wikilink">linear regression</a>, where the coefficients are termed <a href="regression_coefficient" title="wikilink">regression coefficients</a>. However, they also occur in various types of <a href="linear_classifier" title="wikilink">linear classifiers</a> (e.g. <a href="logistic_regression" title="wikilink">logistic regression</a>, <a href="perceptron" title="wikilink">perceptrons</a>, <a href="support_vector_machine" title="wikilink">support vector machines</a>, and <a href="linear_discriminant_analysis" title="wikilink">linear discriminant analysis</a>), as well as in various other models, such as <a href="principal_component_analysis" title="wikilink">principal component analysis</a> and <a href="factor_analysis" title="wikilink">factor analysis</a>. In many of these models, the coefficients are referred to as "weights".</p>
<h2 id="basic-form">Basic form</h2>

<p>The basic form of a linear predictor function 

<math display="inline" id="Linear_predictor_function:0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)
  </annotation>
 </semantics>
</math>

 for data point <em>i</em> (consisting of <em>p</em> explanatory variables), for <em>i</em> = 1, ..., <em>n</em>, is</p>

<p>

<math display="block" id="Linear_predictor_function:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>β</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>β</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>β</mi>
       <mi>p</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mi>p</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)=\beta_{0}+\beta_{1}x_{i1}+\cdots+\beta_{p}x_{ip},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Linear_predictor_function:2">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>p</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{0},\ldots,\beta_{p}
  </annotation>
 </semantics>
</math>

 are the coefficients (regression coefficients, weights, etc.) indicating the relative effect of a particular explanatory variable on the outcome.</p>

<p>It is common to write the predictor function in a more compact form as follows:</p>
<ul>
<li>The coefficients <em>β</em><sub>0</sub>, <em>β</em><sub>1</sub>, ..., <em>β</em><sub><em>p</em></sub> are grouped into a single vector <strong><em>β</em></strong> of size <em>p</em> + 1.</li>
<li>For each data point <em>i</em>, an additional explanatory pseudo-variable <em>x</em><sub><em>i</em>0</sub> is added, with a fixed value of 1, corresponding to the <a href="Y-intercept" title="wikilink">intercept</a> coefficient <em>β</em><sub>0</sub>.</li>
<li>The resulting explanatory variables <em>x</em><sub><em>i0</em></sub>, <em>x</em><sub><em>i</em>1</sub>, ..., <em>x</em><sub><em>ip</em></sub> are then grouped into a single vector <strong><em>x<sub>i</sub></em></strong> of size <em>p</em> + 1.</li>
</ul>

<p>This makes it possible to write the linear predictor function as follows:</p>

<p>

<math display="block" id="Linear_predictor_function:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝜷</mi>
    <mo>⋅</mo>
    <msub>
     <mi>𝐱</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>𝜷</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)=\boldsymbol{\beta}\cdot\mathbf{x}_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>using the notation for a <a href="dot_product" title="wikilink">dot product</a> between two vectors.</p>

<p>An equivalent form using matrix notation is as follows:</p>

<p>

<math display="block" id="Linear_predictor_function:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝜷</mi>
     <mi mathvariant="normal">T</mi>
    </msup>
    <msub>
     <mi>𝐱</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>𝐱</mi>
     <mi>i</mi>
     <mi mathvariant="normal">T</mi>
    </msubsup>
    <mi>𝜷</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>𝜷</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i)=\boldsymbol{\beta}^{\mathrm{T}}\mathbf{x}_{i}=\mathbf{x}^{\mathrm{T}}_{i}%
\boldsymbol{\beta}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Linear_predictor_function:5">
 <semantics>
  <mi>𝜷</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜷</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Linear_predictor_function:6">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{i}
  </annotation>
 </semantics>
</math>

 are assumed to be a <em>p</em>-by-1 <a href="column_vector" title="wikilink">column vectors</a> (as is standard when representing vectors as matrices), 

<math display="inline" id="Linear_predictor_function:7">
 <semantics>
  <msup>
   <mi>𝜷</mi>
   <mi mathvariant="normal">T</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝜷</ci>
    <ci>normal-T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

 indicates the <a href="matrix_transpose" title="wikilink">matrix transpose</a> of 

<math display="inline" id="Linear_predictor_function:8">
 <semantics>
  <mi>𝜷</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜷</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}
  </annotation>
 </semantics>
</math>

 (which turns it into a 1-by-<em>p</em> <a href="row_vector" title="wikilink">row vector</a>), and 

<math display="inline" id="Linear_predictor_function:9">
 <semantics>
  <mrow>
   <msup>
    <mi>𝜷</mi>
    <mi mathvariant="normal">T</mi>
   </msup>
   <msub>
    <mi>𝐱</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <ci>normal-T</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{\mathrm{T}}\mathbf{x}_{i}
  </annotation>
 </semantics>
</math>

 indicates <a href="matrix_multiplication" title="wikilink">matrix multiplication</a> between the 1-by-<em>p</em> row vector and the <em>p</em>-by-1 column vector, producing a 1-by-1 matrix that is taken to be a <a href="scalar_(mathematics)" title="wikilink">scalar</a>.</p>

<p>An example of the usage of such a linear predictor function is in <a href="linear_regression" title="wikilink">linear regression</a>, where each data point is associated with a <a href="continuous_variable" title="wikilink">continuous</a> outcome <em>y</em><sub><em>i</em></sub>, and the relationship written</p>

<p>

<math display="block" id="Linear_predictor_function:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>ε</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>𝜷</mi>
       <mi mathvariant="normal">T</mi>
      </msup>
      <mpadded width="+5pt">
       <msub>
        <mi>𝐱</mi>
        <mi>i</mi>
       </msub>
      </mpadded>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>ε</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ε</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝜷</ci>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ε</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}=f(i)+\varepsilon_{i}=\boldsymbol{\beta}^{\mathrm{T}}\mathbf{x}_{i}\ +%
\varepsilon_{i},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Linear_predictor_function:11">
 <semantics>
  <msub>
   <mi>ε</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ε</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{i}
  </annotation>
 </semantics>
</math>

 is a <em>disturbance term</em> or <em><a href="error_variable" title="wikilink">error variable</a></em> — an unobserved <a href="random_variable" title="wikilink">random variable</a> that adds noise to the linear relationship between the dependent variable and predictor function.</p>
<h2 id="stacking">Stacking</h2>

<p>In some models (standard linear regression in particular), the equations for each of the data points <em>i</em> = 1, ..., <em>n</em> are stacked together and written in vector form as</p>

<p>

<math display="block" id="Linear_predictor_function:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐲</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>𝐗</mi>
      <mi>𝜷</mi>
     </mrow>
     <mo>+</mo>
     <mi>𝜺</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐲</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>𝐗</ci>
      <ci>𝜷</ci>
     </apply>
     <ci>𝜺</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}=\mathbf{X}\boldsymbol{\beta}+\boldsymbol{\varepsilon},\,
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Linear_predictor_function:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>𝐲</mi>
      <mo>=</mo>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>y</mi>
           <mn>1</mn>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>y</mi>
           <mn>2</mn>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>y</mi>
           <mi>n</mi>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mrow>
      <mi>𝐗</mi>
      <mo>=</mo>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msubsup>
           <mi>𝐱</mi>
           <mn>1</mn>
           <mo>′</mo>
          </msubsup>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msubsup>
           <mi>𝐱</mi>
           <mn>2</mn>
           <mo>′</mo>
          </msubsup>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msubsup>
           <mi>𝐱</mi>
           <mi>n</mi>
           <mo>′</mo>
          </msubsup>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>11</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋯</mi>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mrow>
            <mn>1</mn>
            <mi>p</mi>
           </mrow>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>21</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋯</mi>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mrow>
            <mn>2</mn>
            <mi>p</mi>
           </mrow>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋱</mi>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mrow>
            <mi>n</mi>
            <mn>1</mn>
           </mrow>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋯</mi>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mrow>
            <mi>n</mi>
            <mi>p</mi>
           </mrow>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>𝜷</mi>
      <mo>=</mo>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>β</mi>
           <mn>1</mn>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>β</mi>
           <mi>p</mi>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mrow>
      <mi>𝜺</mi>
      <mo>=</mo>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>ε</mi>
           <mn>1</mn>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>ε</mi>
           <mn>2</mn>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>ε</mi>
           <mi>n</mi>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>𝐲</ci>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <ci>normal-⋮</ci>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <ci>𝐗</ci>
       <matrix>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>𝐱</ci>
           <ci>normal-′</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>𝐱</ci>
           <ci>normal-′</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <ci>normal-⋮</ci>
        </matrixrow>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>𝐱</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>n</ci>
         </apply>
        </matrixrow>
       </matrix>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <matrix>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">11</cn>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <times></times>
           <cn type="integer">1</cn>
           <ci>p</ci>
          </apply>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">21</cn>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>p</ci>
          </apply>
         </apply>
        </matrixrow>
        <matrixrow>
         <ci>normal-⋮</ci>
         <ci>normal-⋱</ci>
         <ci>normal-⋮</ci>
        </matrixrow>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <times></times>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <times></times>
           <ci>n</ci>
           <ci>p</ci>
          </apply>
         </apply>
        </matrixrow>
       </matrix>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>𝜷</ci>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <ci>normal-⋮</ci>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>p</ci>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <eq></eq>
      <ci>𝜺</ci>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ε</ci>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ε</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <ci>normal-⋮</ci>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ε</ci>
         <ci>n</ci>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}=\begin{pmatrix}y_{1}\\
y_{2}\\
\vdots\\
y_{n}\end{pmatrix},\quad\mathbf{X}=\begin{pmatrix}\mathbf{x}^{\prime}_{1}\\
\mathbf{x}^{\prime}_{2}\\
\vdots\\
\mathbf{x}^{\prime}_{n}\end{pmatrix}=\begin{pmatrix}x_{11}&\cdots&x_{1p}\\
x_{21}&\cdots&x_{2p}\\
\vdots&\ddots&\vdots\\
x_{n1}&\cdots&x_{np}\end{pmatrix},\quad\boldsymbol{\beta}=\begin{pmatrix}\beta%
_{1}\\
\vdots\\
\beta_{p}\end{pmatrix},\quad\boldsymbol{\varepsilon}=\begin{pmatrix}%
\varepsilon_{1}\\
\varepsilon_{2}\\
\vdots\\
\varepsilon_{n}\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>The matrix <em>X</em> is known as the <a href="design_matrix" title="wikilink">design matrix</a> and encodes all known information about the <a href="independent_variables" title="wikilink">independent variables</a>. The variables 

<math display="inline" id="Linear_predictor_function:14">
 <semantics>
  <msub>
   <mi>ε</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ε</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{i}
  </annotation>
 </semantics>
</math>

 are <a href="random_variable" title="wikilink">random variables</a>, which in standard linear regression are distributed according to a <a href="standard_normal_distribution" title="wikilink">standard normal distribution</a>; they express the influence of any unknown factors on the outcome.</p>

<p>This makes it possible to find optimal coefficients through the <a href="method_of_least_squares" title="wikilink">method of least squares</a> using simple matrix operations. In particular, the optimal coefficients 

<math display="inline" id="Linear_predictor_function:15">
 <semantics>
  <mover accent="true">
   <mi>𝜷</mi>
   <mo mathvariant="bold" stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>bold-^</ci>
    <ci>𝜷</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\hat{\beta}}
  </annotation>
 </semantics>
</math>

 as estimated by least squares can be written as follows:</p>

<p>

<math display="block" id="Linear_predictor_function:16">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>𝜷</mi>
     <mo mathvariant="bold" stretchy="false">^</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>X</mi>
         <mi mathvariant="normal">T</mi>
        </msup>
        <mi>X</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>X</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
     <mi>𝐲</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>bold-^</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>X</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>normal-T</ci>
     </apply>
     <ci>𝐲</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\hat{\beta}}=(X^{\mathrm{T}}X)^{-1}X^{\mathrm{T}}\mathbf{y}.
  </annotation>
 </semantics>
</math>

</p>

<p>The matrix 

<math display="inline" id="Linear_predictor_function:17">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>X</mi>
       <mi mathvariant="normal">T</mi>
      </msup>
      <mi>X</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <msup>
    <mi>X</mi>
    <mi mathvariant="normal">T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <ci>normal-T</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>normal-T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X^{\mathrm{T}}X)^{-1}X^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

 is known as the <a href="Moore-Penrose_pseudoinverse" title="wikilink">Moore-Penrose pseudoinverse</a> of <em>X</em>. Note that this formula assumes that <em>X</em> is of <a href="full_rank" title="wikilink">full rank</a>, i.e. there is no <a class="uri" href="multicollinearity" title="wikilink">multicollinearity</a> among different explanatory variables (i.e. one variable can be perfectly, or almost perfectly, predicted from another). In such cases, the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> can be used to compute the pseudoinverse.</p>
<h2 id="the-explanatory-variables">The explanatory variables</h2>

<p>Although the outcomes (dependent variables) to be predicted are assumed to be <a href="random_variable" title="wikilink">random variables</a>, the explanatory variables themselves are usually not assumed to be random. Instead, they are assumed to be fixed values, and any random variables (e.g. the outcomes) are assumed to be <a href="conditional_probability" title="wikilink">conditional</a> on them. As a result, the model user is free to transform the explanatory variables in arbitrary ways, including creating multiple copies of a given explanatory variable, each transformed using a different function. Other common techniques are to create new explanatory variables in the form of <a href="interaction_variable" title="wikilink">interaction variables</a> by taking products of two (or sometimes more) existing explanatory variables.</p>

<p>When a fixed set of nonlinear functions are used to transform the value(s) of a data point, these functions are known as <a href="basis_function" title="wikilink">basis functions</a>. An example is <a href="polynomial_regression" title="wikilink">polynomial regression</a>, which uses a linear predictor function to fit an arbitrary degree <a class="uri" href="polynomial" title="wikilink">polynomial</a> relationship (up to a given order) between two sets of data points (i.e. a single <a class="uri" href="real-valued" title="wikilink">real-valued</a> explanatory variable and a related real-valued dependent variable), by adding multiple explanatory variables corresponding to various powers of the existing explanatory variable. Mathematically, the form looks like this:</p>

<p>

<math display="block" id="Linear_predictor_function:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>β</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>β</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>β</mi>
       <mn>2</mn>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>β</mi>
       <mi>p</mi>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mi>i</mi>
       <mi>p</mi>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}=\beta_{0}+\beta_{1}x_{i}+\beta_{2}x_{i}^{2}+\cdots+\beta_{p}x_{i}^{p},
  </annotation>
 </semantics>
</math>

</p>

<p>In this case, for each data point, a set of explanatory variables is created as follows:</p>

<p>

<math display="block" id="Linear_predictor_function:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mn>2</mn>
       </mrow>
      </msub>
      <mo>=</mo>
      <mrow>
       <msubsup>
        <mi>x</mi>
        <mi>i</mi>
        <mn>2</mn>
       </msubsup>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mi>p</mi>
       </mrow>
      </msub>
      <mo>=</mo>
      <msubsup>
       <mi>x</mi>
       <mi>i</mi>
       <mi>p</mi>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-…</ci>
      </list>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{i1}=x_{i},x_{i2}=x_{i}^{2},\ldots,x_{ip}=x_{i}^{p})
  </annotation>
 </semantics>
</math>

</p>

<p>and then standard <a href="linear_regression" title="wikilink">linear regression</a> is run. The basis functions in this example would be</p>

<p>

<math display="block" id="Linear_predictor_function:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="bold-italic">ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>ϕ</mi>
       <mi>p</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msup>
      <mi>x</mi>
      <mi>p</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>bold-italic-ϕ</ci>
      <ci>x</ci>
     </apply>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>x</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <ci>p</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>p</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\phi}(x)=(\phi_{1}(x),\phi_{2}(x),\ldots,\phi_{p}(x))=(x,x^{2},%
\ldots,x^{p}).
  </annotation>
 </semantics>
</math>

</p>

<p>This example shows that a linear predictor function can actually be much more powerful than it first appears: It only really needs to be linear in the <em>coefficients</em>. All sorts of non-linear functions of the explanatory variables can be fit by the model.</p>

<p>There is no particular need for the inputs to basis functions to be univariate or single-dimensional (or their outputs, for that matter, although in such a case, a <em>K</em>-dimensional output value is likely to be treated as <em>K</em> separate scalar-output basis functions). An example of this is <a href="radial_basis_function" title="wikilink">radial basis functions</a> (RBF's), which compute some transformed version of the distance to some fixed point:</p>

<p>

<math display="block" id="Linear_predictor_function:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>;</mo>
     <mi>𝐜</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo fence="true">||</mo>
      <mrow>
       <mi>𝐱</mi>
       <mo>-</mo>
       <mi>𝐜</mi>
      </mrow>
      <mo fence="true">||</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msqrt>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>c</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mi mathvariant="normal">…</mi>
       <mo>+</mo>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mi>K</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>c</mi>
           <mi>K</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </msqrt>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <list>
       <ci>𝐱</ci>
       <ci>𝐜</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>𝐱</ci>
        <ci>𝐜</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <apply>
       <root></root>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>K</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <ci>K</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(\mathbf{x};\mathbf{c})=\phi(||\mathbf{x}-\mathbf{c}||)=\phi(\sqrt{(x_{1}-%
c_{1})^{2}+\ldots+(x_{K}-c_{K})^{2}})
  </annotation>
 </semantics>
</math>

</p>

<p>An example is the <a href="Gaussian_function" title="wikilink">Gaussian</a> RBF, which has the same functional form as the <a href="normal_distribution" title="wikilink">normal distribution</a>:</p>

<p>

<math display="block" id="Linear_predictor_function:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>;</mo>
     <mi>𝐜</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>b</mi>
      <msup>
       <mrow>
        <mo fence="true">||</mo>
        <mrow>
         <mi>𝐱</mi>
         <mo>-</mo>
         <mi>𝐜</mi>
        </mrow>
        <mo fence="true">||</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <list>
      <ci>𝐱</ci>
      <ci>𝐜</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>b</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <ci>𝐱</ci>
          <ci>𝐜</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(\mathbf{x};\mathbf{c})=e^{-b||\mathbf{x}-\mathbf{c}||^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>which drops off rapidly as the distance from <strong><em>c</em></strong> increases.</p>

<p>A possible usage of RBF's is to create one for every observed data point. This means that the result of an RBF applied to a new data point will be close to 0 unless the new point is near to the point around which the RBF was applied. That is, the application of the radial basis functions will pick out the nearest point, and its regression coefficient will dominate. The result will be a form of <a href="nearest_neighbor_interpolation" title="wikilink">nearest neighbor interpolation</a>, where predictions are made by simply using the prediction of the nearest observed data point, possibly interpolating between multiple nearby data points when they are all similar distances away. This type of <a href="k-nearest_neighbor_algorithm" title="wikilink">nearest neighbor method</a> for prediction is often considered diametrically opposed to the type of prediction used in standard linear regression: But in fact, the transformations that can be applied to the explanatory variables in a linear predictor function are so powerful that even the nearest neighbor method can be implemented as a type of linear regression.</p>

<p>It is even possible to fit some functions that appear non-linear in the coefficients by transforming the coefficients into new coefficients that do appear linear. For example, a function of the form 

<math display="inline" id="Linear_predictor_function:23">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi>b</mi>
     <mn>2</mn>
    </msup>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msqrt>
     <mi>c</mi>
    </msqrt>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mn>2</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>a</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+b^{2}x_{i1}+\sqrt{c}x_{i2}
  </annotation>
 </semantics>
</math>

 for coefficients 

<math display="inline" id="Linear_predictor_function:24">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b,c
  </annotation>
 </semantics>
</math>

 could be transformed into the appropriate linear function by applying the substitutions 

<math display="inline" id="Linear_predictor_function:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>b</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <msup>
      <mi>b</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>c</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <msqrt>
      <mi>c</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <root></root>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{\prime}=b^{2},c^{\prime}=\sqrt{c},
  </annotation>
 </semantics>
</math>

 leading to 

<math display="inline" id="Linear_predictor_function:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>b</mi>
      <mo>′</mo>
     </msup>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>c</mi>
      <mo>′</mo>
     </msup>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mn>2</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>a</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+b^{\prime}x_{i1}+c^{\prime}x_{i2},
  </annotation>
 </semantics>
</math>

 which is linear. Linear regression and similar techniques could be applied and will often still find the optimal coefficients, but their error estimates and such will be wrong.</p>

<p>The explanatory variables may be of any <a href="statistical_data_type" title="wikilink">type</a>: <a class="uri" href="real-valued" title="wikilink">real-valued</a>, <a href="binary_variable" title="wikilink">binary</a>, <a href="categorical_variable" title="wikilink">categorical</a>, etc. The main distinction is between <a href="continuous_variable" title="wikilink">continuous variables</a> (e.g. income, age, <a href="blood_pressure" title="wikilink">blood pressure</a>, etc.) and <a href="discrete_variable" title="wikilink">discrete variables</a> (e.g. sex, race, political party, etc.). Discrete variables referring to more than two possible choices are typically coded using <a href="dummy_variable_(statistics)" title="wikilink">dummy variables</a> (or <a href="indicator_variable" title="wikilink">indicator variables</a>), i.e. separate explanatory variables taking the value 0 or 1 are created for each possible value of the discrete variable, with a 1 meaning "variable does have the given value" and a 0 meaning "variable does not have the given value". For example, a four-way discrete variable of <a href="blood_type" title="wikilink">blood type</a> with the possible values "A, B, AB, O" would be converted to separate two-way dummy variables, "is-A, is-B, is-AB, is-O", where only one of them has the value 1 and all the rest have the value 0. This allows for separate regression coefficients to be matched for each possible value of the discrete variable.</p>

<p>Note that, for <em>K</em> categories, not all <em>K</em> dummy variables are independent of each other. For example, in the above blood type example, only three of the four dummy variables are independent, in the sense that once the values of three of the variables are known, the fourth is automatically determined. Thus, it's really only necessary to encode three of the four possibilities as dummy variables, and in fact if all four possibilities are encoded, the overall model becomes non-<a class="uri" href="identifiable" title="wikilink">identifiable</a>. This causes problems for a number of methods, such as the simple closed-form solution used in linear regression. The solution is either to avoid such cases by eliminating one of the dummy variables, and/or introduce a <a href="regularization_(mathematics)" title="wikilink">regularization</a> constraint (which necessitates a more powerful, typically iterative, method for finding the optimal coefficients).</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Statistical_models" title="wikilink">Category:Statistical models</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
</body>
</html>
