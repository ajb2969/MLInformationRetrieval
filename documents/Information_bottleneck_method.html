<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1636">Information bottleneck method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Information bottleneck method</h1>
<hr/>

<p>The <strong>information bottleneck method</strong> is a technique introduced by <a href="Naftali_Tishby" title="wikilink">Naftali Tishby</a> et al. [1] for finding the best tradeoff between <a class="uri" href="accuracy" title="wikilink">accuracy</a> and complexity (<a href="Data_compression" title="wikilink">compression</a>) when <a href="random_variable" title="wikilink">summarizing</a> (e.g. <a href="data_clustering" title="wikilink">clustering</a>) a <a href="random_variable" title="wikilink">random variable</a> <strong>X</strong>, given a <a href="joint_probability_distribution" title="wikilink">joint probability distribution</a> between <strong>X</strong> and an observed relevant variable <strong>Y</strong>. Other applications include distributional clustering, and <a href="dimension_reduction" title="wikilink">dimension reduction</a>. In a well defined sense it generalized the classical notion of minimal <a href="sufficient_statistics" title="wikilink">sufficient statistics</a> from parametric statistics to arbitrary distributions, not necessarily of exponential form. It does so by relaxing the sufficiency condition to capture some fraction of the <a href="mutual_information" title="wikilink">mutual information</a> with the relevant variable <strong>Y</strong>.</p>

<p>The compressed variable is 

<math display="inline" id="Information_bottleneck_method:0">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>T</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\,
  </annotation>
 </semantics>
</math>

 and the algorithm minimises the following quantity</p>

<p>

<math display="block" id="Information_bottleneck_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+3.4pt">
      <munder>
       <mi>min</mi>
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">|</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </munder>
     </mpadded>
     <mi>I</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>;</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>β</mi>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>;</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">t</csymbol>
         <ci>normal-|</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
      </apply>
      <ci>I</ci>
     </apply>
     <list>
      <ci>X</ci>
      <ci>T</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>β</ci>
     <ci>I</ci>
     <list>
      <ci>T</ci>
      <ci>Y</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{p(t|x)}\,\,I(X;T)-\beta I(T;Y)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Information_bottleneck_method:2">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>;</mo>
    <mi>T</mi>
    <mo rspace="5.9pt" stretchy="false">)</mo>
   </mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>;</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <list>
     <ci>X</ci>
     <ci>T</ci>
    </list>
    <ci>I</ci>
    <list>
     <ci>T</ci>
     <ci>Y</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(X;T)\,\,I(T;Y)
  </annotation>
 </semantics>
</math>

 are the mutual information between 

<math display="inline" id="Information_bottleneck_method:3">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>;</mo>
   <mpadded width="+1.7pt">
    <mi>T</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>X</ci>
    <ci>T</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X;T\,
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Information_bottleneck_method:4">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>;</mo>
   <mpadded width="+1.7pt">
    <mi>Y</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>T</ci>
    <ci>Y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T;Y\,
  </annotation>
 </semantics>
</math>

 respectively, and 

<math display="inline" id="Information_bottleneck_method:5">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is a <a href="Lagrange_multiplier" title="wikilink">Lagrange multiplier</a>.</p>
<h2 id="gaussian-information-bottleneck">Gaussian information bottleneck</h2>

<p>A relatively simple application of the information bottleneck is to Gaussian variates and this has some semblance to a least squares reduced rank or <a href="canonical_correlation" title="wikilink">canonical correlation</a> [2]. Assume 

<math display="inline" id="Information_bottleneck_method:6">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>Y</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>X</ci>
    <ci>Y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y\,
  </annotation>
 </semantics>
</math>

 are jointly multivariate zero mean normal vectors with covariances 

<math display="inline" id="Information_bottleneck_method:7">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mrow>
     <mi>X</mi>
     <mi>X</mi>
    </mrow>
   </msub>
   <mo rspace="5.9pt">,</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mrow>
     <mi>Y</mi>
     <mi>Y</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{XX},\,\,\Sigma_{YY}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Information_bottleneck_method:8">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>T</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\,
  </annotation>
 </semantics>
</math>


 is a compressed version of 

<math display="inline" id="Information_bottleneck_method:9">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\,
  </annotation>
 </semantics>
</math>

 which must maintain a given value of mutual information with 

<math display="inline" id="Information_bottleneck_method:10">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\,
  </annotation>
 </semantics>
</math>

. It can be shown that the optimum 

<math display="inline" id="Information_bottleneck_method:11">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>T</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\,
  </annotation>
 </semantics>
</math>

 is a normal vector consisting of linear combinations of the elements of 

<math display="inline" id="Information_bottleneck_method:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo rspace="5.9pt">,</mo>
    <mi>T</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mpadded width="+1.7pt">
     <mi>X</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>X</ci>
     <ci>T</ci>
    </list>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,\,\,T=AX\,
  </annotation>
 </semantics>
</math>

 where matrix 

<math display="inline" id="Information_bottleneck_method:13">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,
  </annotation>
 </semantics>
</math>


 has orthogonal rows.</p>

<p>The projection matrix 

<math display="inline" id="Information_bottleneck_method:14">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,
  </annotation>
 </semantics>
</math>

 in fact contains 

<math display="inline" id="Information_bottleneck_method:15">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>M</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\,
  </annotation>
 </semantics>
</math>

 rows selected from the weighted left eigenvectors of the singular value decomposition of the following matrix (generally asymmetric)</p>

<p>

<math display="block" id="Information_bottleneck_method:16">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Σ</mi>
      <mrow>
       <mi>X</mi>
       <mo stretchy="false">|</mo>
       <mi>Y</mi>
      </mrow>
     </msub>
     <msubsup>
      <mi mathvariant="normal">Σ</mi>
      <mrow>
       <mi>X</mi>
       <mi>X</mi>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>I</mi>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">Σ</mi>
       <mrow>
        <mi>X</mi>
        <mi>Y</mi>
       </mrow>
      </msub>
      <msubsup>
       <mi mathvariant="normal">Σ</mi>
       <mrow>
        <mi>Y</mi>
        <mi>Y</mi>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <msubsup>
       <mi mathvariant="normal">Σ</mi>
       <mrow>
        <mi>X</mi>
        <mi>Y</mi>
       </mrow>
       <mi>T</mi>
      </msubsup>
      <msubsup>
       <mi mathvariant="normal">Σ</mi>
       <mrow>
        <mi>X</mi>
        <mi>X</mi>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>normal-Ω</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">X</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">Y</csymbol>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Σ</ci>
        <apply>
         <times></times>
         <ci>X</ci>
         <ci>X</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Σ</ci>
        <apply>
         <times></times>
         <ci>X</ci>
         <ci>Y</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Σ</ci>
         <apply>
          <times></times>
          <ci>Y</ci>
          <ci>Y</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Σ</ci>
         <apply>
          <times></times>
          <ci>X</ci>
          <ci>Y</ci>
         </apply>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Σ</ci>
         <apply>
          <times></times>
          <ci>X</ci>
          <ci>X</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\Sigma_{X|Y}\Sigma_{XX}^{-1}=I-\Sigma_{XY}\Sigma_{YY}^{-1}\Sigma_{XY}^{%
T}\Sigma_{XX}^{-1}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Define the singular value decomposition</p>

<p>

<math display="block" id="Information_bottleneck_method:17">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mi mathvariant="normal">Λ</mi>
    <msup>
     <mi>V</mi>
     <mi>T</mi>
    </msup>
    <mtext>with</mtext>
    <mi mathvariant="normal">Λ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>Diag</mo>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mn>1</mn>
      </msub>
      <mo>≤</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mn>2</mn>
       </msub>
       <mi mathvariant="normal">⋯</mi>
       <msub>
        <mi>λ</mi>
        <mi>N</mi>
       </msub>
      </mrow>
     </mrow>
     <mo maxsize="120%" minsize="120%" rspace="4.2pt">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>normal-Ω</ci>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>normal-Λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <ci>T</ci>
      </apply>
      <mtext>with</mtext>
      <ci>normal-Λ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>Diag</ci>
      <apply>
       <leq></leq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=U\Lambda V^{T}\text{ with }\Lambda=\operatorname{Diag}\big(\lambda_{1}%
\leq\lambda_{2}\cdots\lambda_{N}\big)\,
  </annotation>
 </semantics>
</math>

</p>

<p>and the critical values</p>

<p>

<math display="block" id="Information_bottleneck_method:18">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>β</mi>
     <mi>i</mi>
     <mi>C</mi>
    </msubsup>
    <munder accentunder="true">
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>i</mi>
      </msub>
      <mo><</mo>
      <mn>1</mn>
     </mrow>
    </munder>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>i</ci>
     </apply>
     <ci>C</ci>
    </apply>
    <apply>
     <apply>
      <lt></lt>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}^{C}\underset{\lambda_{i}<1}{=}(1-\lambda_{i})^{-1}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>then the number 

<math display="inline" id="Information_bottleneck_method:19">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>M</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\,
  </annotation>
 </semantics>
</math>

 of active eigenvectors in the projection, or order of approximation, is given by</p>

<p>

<math display="block" id="Information_bottleneck_method:20">
 <semantics>
  <mrow>
   <msubsup>
    <mi>β</mi>
    <mrow>
     <mi>M</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mi>C</mi>
   </msubsup>
   <mo><</mo>
   <mi>β</mi>
   <mo>≤</mo>
   <msubsup>
    <mi>β</mi>
    <mi>M</mi>
    <mi>C</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <apply>
        <minus></minus>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>C</ci>
     </apply>
     <ci>β</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>M</ci>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{M-1}^{C}<\beta\leq\beta_{M}^{C}
  </annotation>
 </semantics>
</math>

</p>

<p>And we finally get</p>

<p>

<math display="block" id="Information_bottleneck_method:21">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>w</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>U</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>M</mi>
      </msub>
      <msub>
       <mi>U</mi>
       <mi>M</mi>
      </msub>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>M</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <ci>M</ci>
       </apply>
      </apply>
     </list>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=[w_{1}U_{1},\dots,w_{M}U_{M}]^{T}
  </annotation>
 </semantics>
</math>

</p>

<p>In which the weights are given by</p>

<p>

<math display="block" id="Information_bottleneck_method:22">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>β</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>-</mo>
      <msub>
       <mi>λ</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <msub>
      <mi>λ</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <root></root>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">β</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="integer">1</cn>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}=\sqrt{(\beta(1-\lambda_{i})/\lambda_{i}r_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Information_bottleneck_method:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>U</mi>
      <mi>i</mi>
      <mi>T</mi>
     </msubsup>
     <msub>
      <mi mathvariant="normal">Σ</mi>
      <mrow>
       <mi>X</mi>
       <mi>X</mi>
      </mrow>
     </msub>
     <msub>
      <mi>U</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>i</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}=U_{i}^{T}\Sigma_{XX}U_{i}.\,
  </annotation>
 </semantics>
</math>


</p>

<p>Applying the Gaussian information bottleneck on time series, one gets optimal predictive coding. This procedure is formally equivalent to linear Slow Feature Analysis <a href="http://creutzig.berkeley.edu/neco.2008.pdf">[3</a>]. Optimal temporal structures in linear dynamic systems can be revealed in the so-called past-future information bottleneck <a href="http://www.user.tu-berlin.de/creutzig/Creutzig_PhysRevE.pdf">[4</a>].</p>
<h3 id="data-clustering-using-the-information-bottleneck">Data clustering using the information bottleneck</h3>

<p>This application of the bottleneck method to non-Gaussian sampled data is described in [4] by Tishby et. el. The concept, as treated there, is not without complication as there are two independent phases in the exercise: firstly estimation of the unknown parent probability densities from which the data samples are drawn and secondly the use of these densities within the information theoretic framework of the bottleneck.</p>
<h3 id="density-estimation">Density estimation</h3>

<p>Since the bottleneck method is framed in probabilistic rather than statistical terms, we first need to estimate the underlying probability density at the sample points 

<math display="inline" id="Information_bottleneck_method:24">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X={x_{i}}\,
  </annotation>
 </semantics>
</math>

. This is a well known problem with a number of solutions described by Silverman in [5]. In the present method, joint probabilities of the samples are found by use of a Markov transition matrix method and this has some mathematical synergy with the bottleneck method itself.</p>

<p>Define an arbitrarily increasing distance metric 

<math display="inline" id="Information_bottleneck_method:25">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>f</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\,
  </annotation>
 </semantics>
</math>

 between all sample pairs and <a href="distance_matrix" title="wikilink">distance matrix</a> 

<math display="inline" id="Information_bottleneck_method:26">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo maxsize="160%" minsize="160%">(</mo>
     <mrow>
      <mo mathsize="160%" stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo mathsize="160%" stretchy="false">|</mo>
     </mrow>
     <mo maxsize="160%" minsize="160%">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i,j}=f\Big(\Big|x_{i}-x_{j}\Big|\Big)
  </annotation>
 </semantics>
</math>

 . Then compute transition probabilities between sample pairs 

<math display="inline" id="Information_bottleneck_method:27">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>λ</mi>
       <msub>
        <mi>d</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i,j}=\exp(-\lambda d_{i,j})\,
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Information_bottleneck_method:28">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>></mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>λ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda>0\,
  </annotation>
 </semantics>
</math>


. Treating samples as states, and a normalised version of 

<math display="inline" id="Information_bottleneck_method:29">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,
  </annotation>
 </semantics>
</math>

 as a Markov state transition probability matrix, the vector of probabilities of the ‘states’ after 

<math display="inline" id="Information_bottleneck_method:30">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>t</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\,
  </annotation>
 </semantics>
</math>

 steps, conditioned on the initial state 

<math display="inline" id="Information_bottleneck_method:31">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(0)\,
  </annotation>
 </semantics>
</math>

, is 

<math display="inline" id="Information_bottleneck_method:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>P</mi>
     <mi>t</mi>
    </msup>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>t</ci>
     </apply>
     <ci>p</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(t)=P^{t}p(0)\,
  </annotation>
 </semantics>
</math>

. We are here interested only in the equilibrium probability vector 

<math display="inline" id="Information_bottleneck_method:33">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">∞</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\infty)\,
  </annotation>
 </semantics>
</math>


 given, in the usual way, by the dominant eigenvector of matrix 

<math display="inline" id="Information_bottleneck_method:34">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,
  </annotation>
 </semantics>
</math>

 which is independent of the initialising vector 

<math display="inline" id="Information_bottleneck_method:35">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(0)\,
  </annotation>
 </semantics>
</math>

. This Markov transition method establishes a probability at the sample points which is claimed to be proportional to the probabilities densities there.</p>

<p>Other interpretations of the use of the eigenvalues of distance matrix 

<math display="inline" id="Information_bottleneck_method:36">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>d</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\,
  </annotation>
 </semantics>
</math>

 are discussed in [6].</p>
<h3 id="clusters">Clusters</h3>

<p>In the following soft clustering example, the reference vector 

<math display="inline" id="Information_bottleneck_method:37">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\,
  </annotation>
 </semantics>
</math>

 contains sample categories and the joint probability 

<math display="inline" id="Information_bottleneck_method:38">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X,Y)\,
  </annotation>
 </semantics>
</math>


 is assumed known. A soft cluster 

<math display="inline" id="Information_bottleneck_method:39">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>c</mi>
    <mi>k</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{k}\,
  </annotation>
 </semantics>
</math>

 is defined by its probability distribution over the data samples 

<math display="inline" id="Information_bottleneck_method:40">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="7.6pt">:</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-:</ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}:\,\,\,p(c_{k}|x_{i})
  </annotation>
 </semantics>
</math>

. In [1] Tishby et al. present the following iterative set of equations to determine the clusters which are ultimately a generalization of the <a href="Rate–distortion_theory" title="wikilink">Blahut-Arimoto</a> algorithm, developed in rate distortion theory. The application of this type of algorithm in neural networks appears to originate in entropy arguments arising in application of Gibbs Distributions in deterministic annealing [7].</p>

<p>

<math display="block" id="Information_bottleneck_method:41">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>=</mo>
       <mi>K</mi>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>exp</mi>
       <mrow>
        <mo maxsize="160%" minsize="160%">(</mo>
        <mo>-</mo>
        <mpadded width="+1.7pt">
         <mi>β</mi>
        </mpadded>
        <msup>
         <mi>D</mi>
         <mrow>
          <mi>K</mi>
          <mi>L</mi>
         </mrow>
        </msup>
        <mrow>
         <mo maxsize="160%" minsize="160%">[</mo>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">|</mo>
          <mi>x</mi>
          <mo rspace="4.2pt" stretchy="false">)</mo>
         </mrow>
         <mo stretchy="false">|</mo>
         <mo rspace="4.2pt" stretchy="false">|</mo>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">|</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo maxsize="160%" minsize="160%">]</mo>
        </mrow>
        <mo maxsize="160%" minsize="160%">)</mo>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">|</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>=</mo>
       <mstyle displaystyle="false">
        <msub>
         <mo largeop="true" symmetric="true">∑</mo>
         <mi>x</mi>
        </msub>
       </mstyle>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo mathsize="120%" stretchy="false">/</mo>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>=</mo>
       <mstyle displaystyle="false">
        <msub>
         <mo largeop="true" symmetric="true">∑</mo>
         <mi>x</mi>
        </msub>
       </mstyle>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">K</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <exp></exp>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <minus></minus>
      <csymbol cd="unknown">β</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <apply>
        <times></times>
        <ci>K</ci>
        <ci>L</ci>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-|</ci>
       <ci>normal-|</ci>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">c</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
    <mtext>otherwise</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>x</ci>
     </apply>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <divide></divide>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
    <mtext>otherwise</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>x</ci>
     </apply>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}p(c|x)=Kp(c)\exp\Big(-\beta\,D^{KL}\Big[p(y|x)\,||\,p(y|c)\Big]%
\Big)\\
p(y|c)=\textstyle\sum_{x}p(y|x)p(c|x)p(x)\big/p(c)\\
p(c)=\textstyle\sum_{x}p(c|x)p(x)\\
\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>The function of each line of the iteration is expanded as follows.</p>

<p><strong>Line 1:</strong> This is a matrix valued set of conditional probabilities</p>

<p>

<math display="block" id="Information_bottleneck_method:42">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>K</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>exp</mi>
   <mrow>
    <mo maxsize="160%" minsize="160%">(</mo>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mi>β</mi>
    </mpadded>
    <msup>
     <mi>D</mi>
     <mrow>
      <mi>K</mi>
      <mi>L</mi>
     </mrow>
    </msup>
    <mrow>
     <mo maxsize="160%" minsize="160%">[</mo>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">|</mo>
     <mo rspace="4.2pt" stretchy="false">|</mo>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <msub>
       <mi>c</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo maxsize="160%" minsize="160%">]</mo>
    </mrow>
    <mo maxsize="160%" minsize="160%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">K</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <exp></exp>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <csymbol cd="unknown">β</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <ci>L</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-|</ci>
      <ci>normal-|</ci>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i,j}=p(c_{i}|x_{j})=Kp(c_{i})\exp\Big(-\beta\,D^{KL}\Big[p(y|x_{j})\,||\,p(%
y|c_{i})\Big]\Big)
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="Kullback–Leibler_distance" title="wikilink">Kullback–Leibler distance</a> 

<math display="inline" id="Information_bottleneck_method:43">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>D</mi>
    <mrow>
     <mi>K</mi>
     <mi>L</mi>
    </mrow>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>D</ci>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{KL}\,
  </annotation>
 </semantics>
</math>

 between the 

<math display="inline" id="Information_bottleneck_method:44">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\,
  </annotation>
 </semantics>
</math>

 vectors generated by the sample data 

<math display="inline" id="Information_bottleneck_method:45">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>x</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,
  </annotation>
 </semantics>
</math>

 and those generated by its reduced information proxy 

<math display="inline" id="Information_bottleneck_method:46">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>c</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,
  </annotation>
 </semantics>
</math>

 is applied to assess the fidelity of the compressed vector with respect to the reference (or categorical) data 

<math display="inline" id="Information_bottleneck_method:47">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\,
  </annotation>
 </semantics>
</math>

 in accordance with the fundamental bottleneck equation. 

<math display="inline" id="Information_bottleneck_method:48">
 <semantics>
  <mrow>
   <msup>
    <mi>D</mi>
    <mrow>
     <mi>K</mi>
     <mi>L</mi>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">|</mo>
    <mo stretchy="false">|</mo>
    <mi>b</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-|</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{KL}(a||b)\,
  </annotation>
 </semantics>
</math>

 is the Kullback Leibler distance between distributions 

<math display="inline" id="Information_bottleneck_method:49">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>b</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Information_bottleneck_method:50">
 <semantics>
  <mrow>
   <msup>
    <mi>D</mi>
    <mrow>
     <mi>K</mi>
     <mi>L</mi>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">|</mo>
    <mo stretchy="false">|</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>log</mi>
   <mrow>
    <mo maxsize="160%" minsize="160%">(</mo>
    <mfrac>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>b</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo maxsize="160%" minsize="160%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-|</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <log></log>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{KL}(a||b)=\sum_{i}p(a_{i})\log\Big(\frac{p(a_{i})}{p(b_{i})}\Big)
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Information_bottleneck_method:51">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>K</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\,
  </annotation>
 </semantics>
</math>

 is a scalar normalization. The weighting by the negative exponent of the distance means that prior cluster probabilities are downweighted in line 1 when the Kullback Liebler distance is large, thus successful clusters grow in probability while unsuccessful ones decay.</p>

<p>'''Line 2: '''This is a second matrix-valued set of conditional probabilities. The steps in deriving it are as follows. We have, by definition</p>

<p>

<math display="inline" id="Information_bottleneck_method:52">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>c</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p(y_{i}|c_{k})
  </annotation>
 </semantics>
</math>


 where the Bayes identities 

<math display="inline" id="Information_bottleneck_method:53">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">|</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">|</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a,b)=p(a|b)p(b)=p(b|a)p(a)\,
  </annotation>
 </semantics>
</math>

 are used.</p>

<p><strong>Line 3:</strong> this line finds the marginal distribution of the clusters 

<math display="inline" id="Information_bottleneck_method:54">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>c</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Information_bottleneck_method:55">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p(c_{i})
  </annotation>
 </semantics>
</math>


<br/>
 This is also a standard result.</p>

<p>Further inputs to the algorithm are the marginal sample distribution 

<math display="inline" id="Information_bottleneck_method:56">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)\,
  </annotation>
 </semantics>
</math>

 which has already been determined by the dominant eigenvector of 

<math display="inline" id="Information_bottleneck_method:57">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,
  </annotation>
 </semantics>
</math>

 and the matrix valued Kullback Leibler distance function</p>

<p>

<math display="block" id="Information_bottleneck_method:58">
 <semantics>
  <mrow>
   <msubsup>
    <mi>D</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mi>K</mi>
     <mi>L</mi>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <msup>
    <mi>D</mi>
    <mrow>
     <mi>K</mi>
     <mi>L</mi>
    </mrow>
   </msup>
   <mrow>
    <mo maxsize="160%" minsize="160%">[</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mo rspace="4.2pt" stretchy="false">|</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo maxsize="160%" minsize="160%">]</mo>
   </mrow>
   <mo maxsize="160%" minsize="160%">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{i,j}^{KL}=D^{KL}\Big[p(y|x_{j})\,||\,p(y|c_{i})\Big]\Big)
  </annotation>
 </semantics>
</math>

</p>

<p>derived from the sample spacings and transition probabilities.</p>

<p>The matrix 

<math display="inline" id="Information_bottleneck_method:59">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y_{i}|c_{j})\,
  </annotation>
 </semantics>
</math>

 can be initialised randomly or as a reasonable guess, while matrix 

<math display="inline" id="Information_bottleneck_method:60">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(c_{i}|x_{j})\,
  </annotation>
 </semantics>
</math>

 needs no prior values. Although the algorithm is converging, multiple minima may exist which need some action to resolve. Further details, including hard clustering methods, are found in [5].</p>
<h2 id="defining-decision-contours">Defining decision contours</h2>

<p>To categorize a new sample 

<math display="inline" id="Information_bottleneck_method:61">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}\,
  </annotation>
 </semantics>
</math>

 external to the training set 

<math display="inline" id="Information_bottleneck_method:62">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\,
  </annotation>
 </semantics>
</math>

, apply the previous distance metric to find the transition probabilities between 

<math display="inline" id="Information_bottleneck_method:63">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}\,
  </annotation>
 </semantics>
</math>

 and all samples in 

<math display="inline" id="Information_bottleneck_method:64">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo rspace="5.9pt">:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>X</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X:\,\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Information_bottleneck_method:65">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>p</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\Kappa</mtext>
   </merror>
   <mi>exp</mi>
   <mrow>
    <mo maxsize="160%" minsize="160%">(</mo>
    <mo>-</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mo mathsize="160%" stretchy="false">|</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>-</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo mathsize="160%" stretchy="false">|</mo>
     <mo maxsize="120%" minsize="120%">)</mo>
    </mrow>
    <mo maxsize="160%" minsize="160%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>p</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <mtext>\Kappa</mtext>
    <exp></exp>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-|</ci>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{p}(x_{i})=p(x_{i}|x^{\prime})=\Kappa\exp\Big(-\lambda f\big(\Big|x_{i}-%
x^{\prime}\Big|\big)\Big)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Information_bottleneck_method:66">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Kappa</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Kappa</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Kappa\,
  </annotation>
 </semantics>
</math>

 a normalisation. Secondly apply the last two lines of the 3-line algorithm to get cluster, and conditional category probabilities.</p>

<p>

<math display="inline" id="Information_bottleneck_method:67">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>p</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mstyle displaystyle="true">
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>j</mi>
    </munder>
   </mstyle>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mstyle displaystyle="true">
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>j</mi>
    </munder>
   </mstyle>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mover accent="true">
    <mi>p</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>p</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>j</ci>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>j</ci>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <ci>normal-~</ci>
     <ci>p</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\tilde{p}(c_{i})=p(c_{i}|x^{\prime})=\sum_{j}p(c_{i}|x_{j})p(x_{j%
}|x^{\prime})=\sum_{j}p(c_{i}|x_{j})\tilde{p}(x_{j})
  </annotation>
 </semantics>
</math>


</p>

<p>Finally we have</p>

<p>

<math display="block" id="Information_bottleneck_method:68">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>j</mi>
   </munder>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
   <msub>
    <mi></mi>
    <mi>j</mi>
   </msub>
   <mi>p</mi>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>c</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">)</mo>
   <mover accent="true">
    <mi>p</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>c</mi>
    <mi>j</mi>
   </msub>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>j</ci>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <eq></eq>
    <sum></sum>
    <apply>
     <ci>j</ci>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>j</ci>
    </apply>
    <ci>normal-)</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>p</ci>
    </apply>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>j</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y_{i}|x^{\prime})=\sum_{j}p(y_{i}|c_{j})p(c_{j}|x^{\prime}))=\sum_{j}p(y_{i}%
|c_{j})\tilde{p}(c_{j})\,
  </annotation>
 </semantics>
</math>

</p>

<p>Parameter 

<math display="inline" id="Information_bottleneck_method:69">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>β</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\,
  </annotation>
 </semantics>
</math>

 must be kept under close supervision since, as it is increased from zero, increasing numbers of features, in the category probability space, snap into focus at certain critical thresholds.</p>
<h3 id="an-example">An example</h3>

<p>The following case examines clustering in a four quadrant multiplier with random inputs 

<math display="inline" id="Information_bottleneck_method:70">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <mi>v</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>u</ci>
    <ci>v</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u,v\,
  </annotation>
 </semantics>
</math>


 and two categories of output, 

<math display="inline" id="Information_bottleneck_method:71">
 <semantics>
  <mrow>
   <mo>±</mo>
   <mpadded width="+1.7pt">
    <mn>1</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm 1\,
  </annotation>
 </semantics>
</math>

, generated by 

<math display="inline" id="Information_bottleneck_method:72">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mo>sign</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mi>v</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <ci>sign</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\operatorname{sign}(uv)\,
  </annotation>
 </semantics>
</math>

. This function has the property that there are two spatially separated clusters for each category and so it demonstrates that the method can handle such distributions.</p>

<p>20 samples are taken, uniformly distributed on the square 

<math display="inline" id="Information_bottleneck_method:73">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <interval closure="closed">
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </interval>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [-1,1]^{2}\,
  </annotation>
 </semantics>
</math>

 . The number of clusters used beyond the number of categories, two in this case, has little effect on performance and the results are shown for two clusters using parameters 

<math display="inline" id="Information_bottleneck_method:74">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mo>=</mo>
    <mn>3</mn>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mi>β</mi>
    <mo>=</mo>
    <mn>2.5</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>λ</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <eq></eq>
     <ci>β</ci>
     <cn type="float">2.5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=3,\,\beta=2.5
  </annotation>
 </semantics>
</math>

.</p>

<p>The distance function is 

<math display="inline" id="Information_bottleneck_method:75">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo mathsize="160%" stretchy="false">|</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo mathsize="160%" stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i,j}=\Big|x_{i}-x_{j}\Big|^{2}
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Information_bottleneck_method:76">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>u</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </interval>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=(u_{i},v_{i})^{T}\,
  </annotation>
 </semantics>
</math>

 while the conditional distribution 

<math display="inline" id="Information_bottleneck_method:77">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y|x)\,
  </annotation>
 </semantics>
</math>

 is a 2 × 20 matrix</p>

<p>

<math display="inline" id="Information_bottleneck_method:78">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
   <mtext>if</mtext>
   <mo>sign</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
    <mtext>if</mtext>
    <ci>sign</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle Pr(y_{i}=1)=1\text{ if }\operatorname{sign}(u_{i}v_{i})=1
  </annotation>
 </semantics>
</math>


</p>

<p>and zero elsewhere.</p>

<p>The summation in line 2 is only incorporates two values representing the training values of +1 or −1 but nevertheless seems to work quite well. Five iterations of the equations were used. The figure shows the locations of the twenty samples with '0' representing <em>Y</em> = 1 and 'x' representing <em>Y</em> = −1. The contour at the unity likelihood ratio level is shown,</p>

<p>

<math display="block" id="Information_bottleneck_method:79">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>L</ci>
     <apply>
      <divide></divide>
      <apply>
       <ci>Pr</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>Pr</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\frac{\Pr(1)}{\Pr(-1)}=1
  </annotation>
 </semantics>
</math>

</p>

<p>as a new sample 

<math display="inline" id="Information_bottleneck_method:80">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}\,
  </annotation>
 </semantics>
</math>

is scanned over the square. Theoretically the contour should align with the 

<math display="inline" id="Information_bottleneck_method:81">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=0\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Information_bottleneck_method:82">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=0\,
  </annotation>
 </semantics>
</math>

 coordinates but for such small sample numbers they have instead followed the spurious clusterings of the sample points. </p>
<h3 id="neural-networkfuzzy-logic-analogies">Neural network/fuzzy logic analogies</h3>

<p>There is some analogy between this algorithm and a neural network with a single hidden layer. The internal nodes are represented by the clusters 

<math display="inline" id="Information_bottleneck_method:83">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>c</mi>
    <mi>j</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{j}\,
  </annotation>
 </semantics>
</math>

 and the first and second layers of network weights are the conditional probabilities 

<math display="inline" id="Information_bottleneck_method:84">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(c_{j}|x_{i})\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Information_bottleneck_method:85">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y_{k}|c_{j})\,
  </annotation>
 </semantics>
</math>

 respectively. However, unlike a standard neural network, the present algorithm relies entirely on probabilities as inputs rather than the sample values themselves while internal and output values are all conditional probability density distributions. Nonlinear functions are encapsulated in distance metric 

<math display="inline" id="Information_bottleneck_method:86">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>.</mo>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-.</ci>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(.)\,
  </annotation>
 </semantics>
</math>

 (or <em>influence functions/radial basis functions</em>) and transition probabilities instead of sigmoid functions. The Blahut-Arimoto three-line algorithm is seen to converge rapidly, often in tens of iterations, and by varying 

<math display="inline" id="Information_bottleneck_method:87">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>β</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Information_bottleneck_method:88">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>λ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Information_bottleneck_method:89">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>f</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\,
  </annotation>
 </semantics>
</math>

 and the cardinality of the clusters, various levels of focus on data features can be achieved.<br/>
The statistical soft clustering definition 

<math display="inline" id="Information_bottleneck_method:90">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(c_{i}|x_{j})\,
  </annotation>
 </semantics>
</math>

 has some overlap with the verbal fuzzy membership concept of fuzzy logic.</p>
<h2 id="bibliography">Bibliography</h2>

<p>[1] N. Tishby, F.C. Pereira, and W. Bialek: <a href="http://www.cs.huji.ac.il/labs/learning/Papers/allerton.pdf">“The Information Bottleneck method”. The 37th annual Allerton Conference on Communication, Control, and Computing, Sep 1999: pp. 368–377</a></p>

<p>[2] G. Chechik, A Globerson, N. Tishby and Y. Weiss: <a href="http://www.jmlr.org/papers/volume6/chechik05a/chechik05a.pdf">“Information Bottleneck for Gaussian Variables”. Journal of Machine Learning Research 6, Jan 2005, pp. 165–188</a></p>

<p>[3] F. Creutzig, H. Sprekeler: <a href="http://www.user.tu-berlin.de/creutzig/neco.2008.pdf">Predictive Coding and the Slowness Principle: an Information-Theoretic Approach</a>, 2008, Neural Computation 20(4): 1026–1041</p>

<p>[4] F. Creutzig, A. Globerson, N. Tishby: <a href="http://www.user.tu-berlin.de/creutzig/Creutzig_PhysRevE.pdf">Past-future information bottleneck in dynamical systems</a>, 2009, Physical Review E 79, 041925</p>

<p>[5] N Tishby, N Slonim: “Data clustering by Markovian Relaxation and the Information Bottleneck Method”, Neural Information Processing Systems (NIPS) 2000, pp. 640–646</p>

<p>[6] B.W. Silverman: “Density Estimation for Statistical Data Analysis”, Chapman and Hall, 1986.</p>

<p>[7] N. Slonim, N. Tishby: "Document Clustering using Word Clusters via the Information Bottleneck Method", SIGIR 2000, pp. 208–215</p>

<p>[8] Y. Weiss: "Segmentation using eigenvectors: a unifying view", Proceedings IEEE International Conference on Computer Vision 1999, pp. 975–982</p>

<p>[9] D. J. Miller, A. V. Rao, K. Rose, A. Gersho: "An Information-theoretic Learning Algorithm for Neural Network Classification". NIPS 1995: pp. 591–597</p>

<p>[10] P. Harremoes and N. Tishby <a href="http://www.cs.huji.ac.il/labs/learning/Papers/flaske2.pdf">"The Information Bottleneck Revisited or How to Choose a Good Distortion Measure". In proceedings of the International Symposium on Information Theory (ISIT) 2007</a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Information_theory" title="wikilink">Information theory</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://citeseer.ist.psu.edu/tishby99information.html">Paper by N. Tishby, et al.</a></li>
</ul>

<p>"</p>

<p><a href="Category:Data_clustering_algorithms" title="wikilink">Category:Data clustering algorithms</a> <a href="Category:Multivariate_statistics" title="wikilink">Category:Multivariate statistics</a></p>
</body>
</html>
