<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1395">Maximally stable extremal regions</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Maximally stable extremal regions</h1>
<hr/>

<p>In <a href="computer_vision" title="wikilink">computer vision</a>, <strong>maximally stable extremal regions</strong> (<strong>MSER</strong>) are used as a method of <a href="blob_detection" title="wikilink">blob detection</a> in images. This technique was proposed by Matas et al.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> to find <a href="correspondence_problem" title="wikilink">correspondences</a> between image elements from two images with different viewpoints. This method of extracting a comprehensive number of corresponding image elements contributes to the wide-baseline matching, and it has led to better stereo matching and <a href="object_recognition" title="wikilink">object recognition</a> algorithms.</p>
<h2 id="terms-and-definitions">Terms and Definitions</h2>

<p><strong>Image</strong> 

<math display="inline" id="Maximally_stable_extremal_regions:0">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is a mapping 

<math display="inline" id="Maximally_stable_extremal_regions:1">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>:</mo>
   <mrow>
    <mi>D</mi>
    <mo>⊂</mo>
    <msup>
     <mi>ℤ</mi>
     <mn>2</mn>
    </msup>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>I</ci>
    <apply>
     <and></and>
     <apply>
      <subset></subset>
      <ci>D</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℤ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I:D\subset\mathbb{Z}^{2}\to S
  </annotation>
 </semantics>
</math>

. Extremal regions are well defined on images if:</p>
<ol>
<li>

<math display="inline" id="Maximally_stable_extremal_regions:2">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is totally ordered (total, antisymmetric and transitive binary relations 

<math display="inline" id="Maximally_stable_extremal_regions:3">
 <semantics>
  <mo>≤</mo>
  <annotation-xml encoding="MathML-Content">
   <leq></leq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq
  </annotation>
 </semantics>
</math>

 exist).</li>
<li>An adjacency relation 

<math display="inline" id="Maximally_stable_extremal_regions:4">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊂</mo>
   <mrow>
    <mi>D</mi>
    <mo>×</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\subset D\times D
  </annotation>
 </semantics>
</math>

 is defined.</li>
</ol>

<p><strong>Region</strong> 

<math display="inline" id="Maximally_stable_extremal_regions:5">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is a contiguous subset of 

<math display="inline" id="Maximally_stable_extremal_regions:6">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. (For each 

<math display="inline" id="Maximally_stable_extremal_regions:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
   </mrow>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>p</ci>
     <ci>q</ci>
    </list>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p,q\in Q
  </annotation>
 </semantics>
</math>

 there is a sequence 

<math display="inline" id="Maximally_stable_extremal_regions:8">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mo>.</mo>
   <mo>.</mo>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <mo>,</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-.</ci>
    <ci>normal-.</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-,</ci>
    <csymbol cd="unknown">q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p,a_{1},a_{2},..,a_{n},q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Maximally_stable_extremal_regions:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>A</mi>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mi>A</mi>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mi>A</mi>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
     <ci>q</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pAa_{1},a_{i}Aa_{i+1},a_{n}Aq
  </annotation>
 </semantics>
</math>

.)</p>

<p><strong>(Outer) Region Boundary</strong> 

<math display="inline" id="Maximally_stable_extremal_regions:10">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <mi>Q</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>q</mi>
     <mo>∈</mo>
     <mrow>
      <mi>D</mi>
      <mo>∖</mo>
      <mi>Q</mi>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>∃</mo>
       <mi>p</mi>
      </mrow>
      <mo>∈</mo>
      <mi>Q</mi>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mi>q</mi>
      <mi>A</mi>
      <mi>p</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <ci>Q</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>q</ci>
      <apply>
       <setdiff></setdiff>
       <ci>D</ci>
       <ci>Q</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <in></in>
       <apply>
        <exists></exists>
        <ci>p</ci>
       </apply>
       <ci>Q</ci>
      </apply>
      <apply>
       <times></times>
       <ci>q</ci>
       <ci>A</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial Q=\{q\in D\setminus Q:\exists p\in Q:qAp\}
  </annotation>
 </semantics>
</math>

, which means the boundary 

<math display="inline" id="Maximally_stable_extremal_regions:11">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial Q
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Maximally_stable_extremal_regions:12">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is the set of pixels adjacent to at least one pixel of 

<math display="inline" id="Maximally_stable_extremal_regions:13">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 but not belonging to 

<math display="inline" id="Maximally_stable_extremal_regions:14">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Extremal Region</strong> 

<math display="inline" id="Maximally_stable_extremal_regions:15">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>⊂</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>Q</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\subset D
  </annotation>
 </semantics>
</math>

 is a region such that either for all 

<math display="inline" id="Maximally_stable_extremal_regions:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mo>∈</mo>
     <mi>Q</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>q</mi>
     <mo>∈</mo>
     <mrow>
      <mo>∂</mo>
      <mi>Q</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>></mo>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>p</ci>
      <ci>Q</ci>
     </apply>
     <apply>
      <in></in>
      <ci>q</ci>
      <apply>
       <partialdiff></partialdiff>
       <ci>Q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in Q,q\in\partial Q:I(p)>I(q)
  </annotation>
 </semantics>
</math>

 (maximum intensity region) or for all 

<math display="inline" id="Maximally_stable_extremal_regions:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mo>∈</mo>
     <mi>Q</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>q</mi>
     <mo>∈</mo>
     <mrow>
      <mo>∂</mo>
      <mi>Q</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>p</ci>
      <ci>Q</ci>
     </apply>
     <apply>
      <in></in>
      <ci>q</ci>
      <apply>
       <partialdiff></partialdiff>
       <ci>Q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in Q,q\in\partial Q:I(p)<I(q)
  </annotation>
 </semantics>
</math>

 (minimum intensity region).</p>

<p><strong>Maximally Stable Extremal Region</strong> Let 

<math display="inline" id="Maximally_stable_extremal_regions:18">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mo>.</mo>
   <mo>.</mo>
   <mo>,</mo>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>Q</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-.</ci>
    <ci>normal-.</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1},..,Q_{i-1},Q_{i},...
  </annotation>
 </semantics>
</math>

 be a sequence of nested extremal regions (

<math display="inline" id="Maximally_stable_extremal_regions:19">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>i</mi>
   </msub>
   <mo>⊂</mo>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i}\subset Q_{i+1}
  </annotation>
 </semantics>
</math>

). Extremal region 

<math display="inline" id="Maximally_stable_extremal_regions:20">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mrow>
    <mi>i</mi>
    <mo>*</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <list>
     <ci>i</ci>
     <times></times>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i*}
  </annotation>
 </semantics>
</math>

 is maximally stable if and only if 

<math display="inline" id="Maximally_stable_extremal_regions:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mi mathvariant="normal">Δ</mi>
       </mrow>
      </msub>
      <mo>∖</mo>
      <msub>
       <mi>Q</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mi mathvariant="normal">Δ</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>Q</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <setdiff></setdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <ci>normal-Δ</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <ci>normal-Δ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(i)=|Q_{i+\Delta}\setminus Q_{i-\Delta}|/|Q_{i}|
  </annotation>
 </semantics>
</math>

 has a local minimum at 

<math display="inline" id="Maximally_stable_extremal_regions:22">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i*
  </annotation>
 </semantics>
</math>

. (Here 

<math display="inline" id="Maximally_stable_extremal_regions:23">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mo>⋅</mo>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <ci>normal-⋅</ci>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\cdot|
  </annotation>
 </semantics>
</math>

 denotes cardinality.)

<math display="inline" id="Maximally_stable_extremal_regions:24">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>normal-Δ</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\in S
  </annotation>
 </semantics>
</math>

 is a parameter of the method.</p>

<p>The equation checks for regions that remain stable over a certain number of thresholds. If a region 

<math display="inline" id="Maximally_stable_extremal_regions:25">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <ci>normal-Δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i+\Delta}
  </annotation>
 </semantics>
</math>

 is not significantly larger than a region 

<math display="inline" id="Maximally_stable_extremal_regions:26">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <ci>normal-Δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i-\Delta}
  </annotation>
 </semantics>
</math>

, region 

<math display="inline" id="Maximally_stable_extremal_regions:27">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i}
  </annotation>
 </semantics>
</math>

 is taken as a maximally stable region.</p>

<p>The concept more simply can be explained by <a href="Thresholding_(image_processing)" title="wikilink">thresholding</a>. All the pixels below a given threshold are 'black' and all those above or equal are 'white'. Given a source image, if we generate a sequence of thresholded result images 

<math display="inline" id="Maximally_stable_extremal_regions:28">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{t}
  </annotation>
 </semantics>
</math>

 where each image 

<math display="inline" id="Maximally_stable_extremal_regions:29">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 corresponds to a increasing threshold t, we would see first a white image, then 'black' spots corresponding to local intensity minima will appear then grow larger. These 'black' spots will eventually merge, until the whole image is black. The set of all connected components in the sequence is the set of all extremal regions. In that sense, the concept of MSER is linked to the one of component tree of the image.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The component tree indeed provide an easy way for implementing MSER.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="extremal-regions">Extremal regions</h3>

<p><em>Extremal regions</em> in this context have two important properties, that the set is closed under...</p>
<ol>
<li>continuous transformation of image coordinates. This means it is affine invariant and it doesn't matter if the image is warped or skewed.</li>
<li>monotonic transformation of image intensities. The approach is of course sensitive to natural lighting effects as change of day light or moving shadows.</li>
</ol>
<h2 id="advantages-of-mser">Advantages of MSER</h2>

<p>Because the regions are defined exclusively by the intensity function in the region and the outer border, this leads to many key characteristics of the regions which make them useful. Over a large range of thresholds, the local binarization is stable in certain regions, and have the properties listed below.</p>
<ul>
<li><em>Invariance to <a href="affine_transformation" title="wikilink">affine transformation</a> of image intensities</em></li>
<li><em>Covariance to adjacency preserving</em> (continuous)<em>transformation</em> 

<math display="inline" id="Maximally_stable_extremal_regions:30">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mrow>
    <mi>D</mi>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>D</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T:D\to D
  </annotation>
 </semantics>
</math>

 <em>on the image domain</em></li>
<li><em>Stability</em>: only regions whose support is nearly the same over a range of thresholds is selected.</li>
<li><em>Multi-scale detection</em> without any smoothing involved, both fine and large structure is detected.<br/>
Note however that detection of MSERs in a scale pyramid improves repeatability, and number of correspondences across scale changes.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
<li>The set of all extremal regions can be <em>enumerated</em> in worst-case 

<math display="inline" id="Maximally_stable_extremal_regions:31">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Maximally_stable_extremal_regions:32">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of pixels in the image.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>
<h3 id="comparison-to-other-region-detectors">Comparison to other region detectors</h3>

<p>In Mikolajczyk et al.,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> six region detectors are studied (Harris-affine, Hessian-affine, MSER, edge-based regions, intensity extrema, and salient regions). A summary of MSER performance in comparison to the other five follows.</p>
<ul>
<li><strong>Region density</strong> - in comparison to the others MSER offers the most variety detecting about 2600 regions for a textured blur scene and 230 for a light changed. scene, and variety is generally considered to be good. Also MSER had a repeatability of 92% for this test.</li>
<li><strong>Region size</strong> - MSER tended to detect many small regions, versus large regions which are more likely to be occluded or to not cover a planar part of the scene. Though large regions may be slightly easier to match.</li>
<li><strong>Viewpoint change</strong> - MSER outperforms the five other region detectors in both the original images and those with repeated texture motifs.</li>
<li><strong>Scale change</strong> - Following Hessian-affine detector, MSER comes in second under a scale change and in-plane rotation.</li>
<li><strong>Blur</strong> - MSER proved to be the most sensitive to this type of change in image, which is the only area that this type of detection is lacking in.<br/>
Note however that this evaluation did not make use of multi-resolution detection, which has been shown to improve repeatability under blur.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li><strong>Light change</strong> - MSER showed the highest repeatability score for this type of scene, with all the other having good robustness as well.</li>
</ul>

<p>MSER consistently resulted in the highest score through many tests, proving it to be a reliable region detector.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="implementation">Implementation</h2>

<p>The original algorithm of Matas et al.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> is 

<math display="inline" id="Maximally_stable_extremal_regions:33">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>n</mi>
     </mpadded>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\,\log(\log(n)))
  </annotation>
 </semantics>
</math>

 in the number 

<math display="inline" id="Maximally_stable_extremal_regions:34">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>n</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,
  </annotation>
 </semantics>
</math>

 of pixels. It proceeds by first sorting the pixels by intensity. This would take 

<math display="inline" id="Maximally_stable_extremal_regions:35">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)\,
  </annotation>
 </semantics>
</math>

 time, using <small>BINSORT</small>. After sorting, pixels are marked in the image, and the list of growing and merging connected components and their areas is maintained using the <a class="uri" href="union-find" title="wikilink">union-find</a> algorithm. This would take 

<math display="inline" id="Maximally_stable_extremal_regions:36">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>n</mi>
     </mpadded>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\,\log(\log(n)))
  </annotation>
 </semantics>
</math>

 time. In practice these steps are very fast. During this process, the area of each connected component as a function of intensity is stored producing a data structure. A merge of two components is viewed as termination of existence of the smaller component and an insertion of all pixels of the smaller component into the larger one. In the extremal regions, the 'maximally stable' ones are those corresponding to thresholds where the relative area change as a function of relative change of threshold is at a local minimum, i.e. the MSER are the parts of the image where local binarization is stable over a large range of thresholds.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>The component tree is the set of all connected components of the thresholds of the image, ordered by inclusion. Efficient (quasi-linear whatever the range of the weights) algorithms for computing it do exist.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Thus this structure offers an easy way for implementing MSER.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>More recently, Nister and Stewenius have proposed a truly (if the weight are small integers) worst-case 

<math display="inline" id="Maximally_stable_extremal_regions:37">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)\,
  </annotation>
 </semantics>
</math>

 method in,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> which is also much faster in practice. This algorithm is similar to the one of Ph. Salembier et al.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="robust-wide-baseline-algorithm">Robust wide-baseline algorithm</h2>

<p>The purpose of this algorithm is to match MSERs to establish correspondence points between images. First MSER regions are computed on the intensity image (MSER+) and on the inverted image (MSER-). Measurement regions are selected at multiple scales: the size of the actual region, 1.5x, 2x, and 3x scaled convex hull of the region. Matching is accomplished in a robust manner, so it is better to increase the distinctiveness of large regions without being severely affected by clutter or non-planarity of the region's pre-image. A measurement taken from an almost planar patch of the scene with stable invariant description are called a 'good measurement'. Unstable ones or those on non-planar surfaces or discontinuities are called 'corrupted measurements'. The robust similarity is computed: For each 

<math display="inline" id="Maximally_stable_extremal_regions:38">
 <semantics>
  <msubsup>
   <mi>M</mi>
   <mi>A</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>A</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{A}^{i}
  </annotation>
 </semantics>
</math>

 on region 

<math display="inline" id="Maximally_stable_extremal_regions:39">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>k</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,k
  </annotation>
 </semantics>
</math>

 regions 

<math display="inline" id="Maximally_stable_extremal_regions:40">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>B</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{1},\dots,B_{k}
  </annotation>
 </semantics>
</math>

 from the other image with the corresponding i-th measurement 

<math display="inline" id="Maximally_stable_extremal_regions:41">
 <semantics>
  <mrow>
   <msubsup>
    <mi>M</mi>
    <msub>
     <mi>B</mi>
     <mn>1</mn>
    </msub>
    <mi>i</mi>
   </msubsup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msubsup>
    <mi>M</mi>
    <msub>
     <mi>B</mi>
     <mi>k</mi>
    </msub>
    <mi>i</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>i</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{B_{1}}^{i},\dots,M_{B_{k}}^{i}
  </annotation>
 </semantics>
</math>

 nearest to 

<math display="inline" id="Maximally_stable_extremal_regions:42">
 <semantics>
  <msubsup>
   <mi>M</mi>
   <mi>A</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>A</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{A}^{i}
  </annotation>
 </semantics>
</math>

 are found and a vote is cast suggesting correspondence of A and each of 

<math display="inline" id="Maximally_stable_extremal_regions:43">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>B</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{1},\dots,B_{k}
  </annotation>
 </semantics>
</math>

. Votes are summed over all measurements, and using probability analysis, we pick out the 'good measurements' as the 'corrupt measurements' will likely spread their votes randomly. By applying <small><a class="uri" href="RANSAC" title="wikilink">RANSAC</a></small> to the centers of gravity of the regions, we can compute a rough <a href="epipolar_geometry" title="wikilink">epipolar geometry</a>. An affine transformation between pairs of potentially corresponding regions is computed, and correspondences define it up to a rotation, which is then determined by epipolar lines. The regions are then filtered, and the ones with correlation of their transformed images above a threshold are chosen. <small>RANSAC</small> is applied again with a more narrow threshold, and the final eipolar geometry is estimated by the <a href="eight-point_algorithm" title="wikilink">eight-point algorithm</a>.</p>

<p>This algorithm can be tested here (Epipolar or homography geometry constrained matches): <a href="http://cmp.felk.cvut.cz/~wbsdemo/demo/">WBS Image Matcher</a></p>
<h2 id="use-in-text-detection">Use in Text Detection</h2>

<p>The MSER algorithm has been used in text detection by Chen by combining MSER with Canny edges. Canny edges are used to help cope with the weakness of MSER to blur. MSER is first applied to the image in question to determine the character regions. To enhance the MSER regions any pixels outside the boundaries formed by Canny edges are removed. The separation of the letter provided by the edges greatly increase the usability of MSER in the extraction of blurred text.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> An alternative use of MSER in text detection is the work by Shi using a graph model. This method again applies MSER to the image to generate preliminary regions. These are then used to construct a graph model based on the position distance and color distance between each MSER, which is treated as a node. Next the nodes are separated into foreground and background using cost functions. One cost function is to relate the distance from the node to the foreground and background. The other penalizes nodes for being significantly different from its neighbor. When these are minimized the graph is then cut to separate the text nodes from the non-text nodes.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a>To enable text detection in a general scene, Neumann uses the MSER algorithm in a variety of projections. In addition to the greyscale intensity projection, he uses the red, blue, and green color channels to detect text regions that are color distinct but not necessarily distinct in greyscale intensity. This method allows for detection of more text than solely using the MSER+ and MSER- functions discussed above.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="extensions-and-adaptations">Extensions and Adaptations</h2>
<ul>
<li>The MSER algorithm has been adapted to colour images, by replacing thresholding of the intensity function with agglomerative <a href="Data_clustering" title="wikilink">clustering</a>, based on colour gradients.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></li>
<li>The MSER algorithm can be used to detect regions based on color as opposed to intensity. This is done by Chavez by creating an intensity function for red, green, and blue in the HSV color space. The MSER algorithm is then run five times; over the three color pseduo-intensities and then over the grey scale intensities using the standard MSER+ and MSER- functions.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li>The MSER algorithm can be used to track colour objects, by performing MSER detection on the <a href="Mahalanobis_distance" title="wikilink">Mahalanobis distance</a> to a colour distribution.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
<li>By detecting MSERs in multiple resolutions, robustness to blur, and scale change can be improved.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
</ul>
<h2 id="other-applications">Other Applications</h2>
<ul>
<li><a href="http://www.cs.ubc.ca/~lowe/papers/07forssen.pdf">Shape Descriptors for Maximally Stable Extremal Regions</a></li>
<li><a href="http://www.icg.tugraz.at/pub/pubobjects/docvpr2006">Efficient Maximally Stable Extremal Region (MSER) Tracking</a></li>
<li><a href="http://www.bmva.org/bmvc/2006/papers/276.pdf">N-tree Disjoint-Set Forests for Maximally Stable Extremal Regions</a></li>
<li><a href="http://www.cs.ucsd.edu/classes/fa05/cse252c/hewitt-2.pdf">Video Google and Object Level Grouping for Video Shots</a></li>
<li><a href="http://www.eecg.toronto.edu/~maclean/9501292851/iscas2007-Kristensen.pdf">Real-Time Extraction of Maximally Stable Extremal Regions on an FPGA</a></li>
<li><a href="http://www.cs.ubc.ca/~perfo/papers/forssen_cvpr07.pdf">Maximally Stable Colour Regions for Recognition and Matching</a></li>
<li></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="blob_detection" title="wikilink">blob detection</a></li>
<li><a href="feature_detection_(computer_vision)" title="wikilink">feature detection (computer vision)</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.vlfeat.org/">VLFeat</a>, an open source computer vision library in C (with a MEX interface to MATLAB), including an implementation of MSER</li>
<li><a href="http://opencv.willowgarage.com/wiki/">OpenCV</a>, an open source computer vision library in C/C++, including an implementation of Linear Time MSER</li>
<li><a href="http://www.featurespace.org/code.htm">Detector Repeatabilty Study</a>, Kristian Mikolajczyk Binaries (Win/Linux to compute MSER/HarrisAffine... . Binary used in his repeatability study.</li>
<li><a href="http://www.dubout.ch/en/coding.html">Linear Time MSER Implementation</a>, Charles Dubout, C++ implementation of MSER as a blob detector</li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Feature_detection_(computer_vision)" title="wikilink">Category:Feature detection (computer vision)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">J. Matas, O. Chum, M. Urban, and T. Pajdla. <a href="http://cmp.felk.cvut.cz/~matas/papers/matas-bmvc02.pdf">"Robust wide baseline stereo from maximally stable extremal regions."</a> Proc. of British Machine Vision Conference, pages 384-396, 2002.<a href="#fnref1">↩</a></li>
<li id="fn2">L. Najman and M. Couprie: <a href="http://www.esiee.fr/~info/a2si/Ps/comptreeTransImaging.pdf">"Building the component tree in quasi-linear time"</a>; IEEE Transaction on Image Processing, Volume 15, Numbers 11 , 2006, pp 3531-3539<a href="#fnref2">↩</a></li>
<li id="fn3">Donoser, M. and Bischof, H. <a href="http://www.icg.tugraz.at/pub/pubobjects/docvpr2006">Efficient Maximally Stable Extremal Region (MSER) Tracking</a> <a class="uri" href="CVPR" title="wikilink">CVPR</a>, 2006.<a href="#fnref3">↩</a></li>
<li id="fn4">Forssen, P-E. and Lowe, D.G. <a href="http://www.cs.ubc.ca/~perfo/papers/forssen_iccv07.pdf">"Shape Descriptors for Maximally Stable Extremal Regions"</a> ICCV, 2007.<a href="#fnref4">↩</a></li>
<li id="fn5">Nister, D. and Stewenius, H., <a href="http://webdocs.cs.ualberta.ca/~jag/papersVis2/08ECCV/papers/5303/53030183.pdf">"Linear Time Maximally Stable Extremal Regions"</a>, ECCV, 2008.<a href="#fnref5">↩</a></li>
<li id="fn6">K. Mikolajczyk, T. Tuytelaars, C. Schmid, A. Zisserman, T. Kadir and L. Van Gool: <a href="http://www.robots.ox.ac.uk/~vgg/publications/papers/mikolajczyk05.pdf">"A Comparison of Affine Region Detectors"</a>; International Journal of Computer Vision, Volume 65, Numbers 1-2 / November, 2005, pp 43-72<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19">Forssen, P-E. <a href="http://www.cs.ubc.ca/~perfo/papers/forssen_cvpr07.pdf">Maximally Stable Colour Regions for Recognition and Matching</a>, CVPR, 2007.<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"></li>
</ol>
</section>
</body>
</html>
