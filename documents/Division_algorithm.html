<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="207">Division algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Division algorithm</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>A <strong>division algorithm</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> which, given two integers N and D, computes their <a class="uri" href="quotient" title="wikilink">quotient</a> and/or <a class="uri" href="remainder" title="wikilink">remainder</a>, the result of <a href="division_(mathematics)" title="wikilink">division</a>. Some are applied by hand, while others are employed by digital circuit designs and software.</p>

<p>Division algorithms fall into two main categories: slow division and fast division. Slow division algorithms produce one digit of the final quotient per iteration. Examples of slow division include <a href="#Restoring_division" title="wikilink">restoring</a>, non-performing restoring, <a href="#Non-restoring_division" title="wikilink">non-restoring</a>, and <a href="#SRT_division" title="wikilink">SRT</a> division. Fast division methods start with a close approximation to the final quotient and produce twice as many digits of the final quotient on each iteration. <a href="#Newton–Raphson_division" title="wikilink">Newton–Raphson</a> and <a href="#Goldschmidt_division" title="wikilink">Goldschmidt</a> fall into this category.</p>

<p>Discussion will refer to the form 

<math display="inline" id="Division_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mo>/</mo>
    <mi>D</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>N</ci>
     <ci>D</ci>
    </apply>
    <interval closure="open">
     <ci>Q</ci>
     <ci>R</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N/D=(Q,R)
  </annotation>
 </semantics>
</math>

, where</p>
<ul>
<li><em>N</em> = Numerator (dividend)</li>
<li><em>D</em> = Denominator (divisor)</li>
</ul>

<p>is the input, and</p>
<ul>
<li><em>Q</em> = Quotient</li>
<li><em>R</em> = Remainder</li>
</ul>

<p>is the output.</p>
<h2 id="division-by-repeated-subtraction">Division by repeated subtraction</h2>

<p>The simplest division algorithm, historically incorporated into a <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> algorithm presented in <a href="Euclid's_Elements" title="wikilink">Euclid's <em>Elements</em></a>, Book VII, Proposition 1, finds the remainder given two positive integers using only subtractions and comparisons:</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">while</span>  N ≥ D <span class="kw">do</span>
  N :<span class="ot">=</span> N <span class="ot">-</span> D
<span class="kw">end</span>
<span class="kw">return</span> N</code></pre></div>

<p>The proof that the quotient and remainder exist and are unique, described at <a href="Euclidean_division" title="wikilink">Euclidean division</a>, gives rise to a complete division algorithm using additions, subtractions, and comparisons:</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> divide<span class="ot">(</span>N<span class="ot">,</span> D<span class="ot">)</span>
  <span class="kw">if</span> D <span class="ot">=</span> <span class="dv">0</span> <span class="kw">then</span> <span class="fu">error</span><span class="ot">(</span>DivisionByZero<span class="ot">)</span> <span class="kw">end</span>
  <span class="kw">if</span> D <span class="ot">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="ot">(</span>Q<span class="ot">,</span>R<span class="ot">)</span> :<span class="ot">=</span> divide<span class="ot">(</span>N<span class="ot">,</span> <span class="ot">-</span>D<span class="ot">);</span> <span class="kw">return</span> <span class="ot">(-</span>Q<span class="ot">,</span> R<span class="ot">)</span> <span class="kw">end</span>
  <span class="kw">if</span> N <span class="ot">&lt;</span> <span class="dv">0</span> <span class="kw">then</span>
    <span class="ot">(</span>Q<span class="ot">,</span>R<span class="ot">)</span> :<span class="ot">=</span> divide<span class="ot">(-</span>N<span class="ot">,</span> D<span class="ot">)</span>
    <span class="kw">if</span> R <span class="ot">=</span> <span class="dv">0</span> <span class="kw">then</span> <span class="kw">return</span> <span class="ot">(-</span>Q<span class="ot">,</span> <span class="dv">0</span><span class="ot">)</span>
    <span class="kw">else</span> <span class="kw">return</span> <span class="ot">(-</span>Q <span class="ot">-</span> <span class="dv">1</span><span class="ot">,</span> D <span class="ot">-</span> R<span class="ot">)</span> <span class="kw">end</span>
  <span class="kw">end</span>
  <span class="co">-- At this point, N ≥ 0 and D &gt; 0</span>
  Q :<span class="ot">=</span> <span class="dv">0</span><span class="ot">;</span> R :<span class="ot">=</span> N
  <span class="kw">while</span>  R ≥ D <span class="kw">do</span>
    Q :<span class="ot">=</span> Q <span class="ot">+</span> <span class="dv">1</span>
    R :<span class="ot">=</span> R <span class="ot">-</span> D
  <span class="kw">end</span>
  <span class="kw">return</span> <span class="ot">(</span>Q<span class="ot">,</span> R<span class="ot">)</span>
<span class="kw">end</span>  </code></pre></div>

<p>This procedure always produces R ≥ 0. Although very simple, it takes Ω(Q) steps, and so is exponentially slower than even slow division algorithms like long division. It is useful if Q is known to be small (being an <a href="output-sensitive_algorithm" title="wikilink">output-sensitive algorithm</a>), and can serve as an executable specification.</p>
<h2 id="long-division">Long division</h2>

<p>Long division is the standard algorithm used for pen-and-paper division of multidigit numbers expressed in decimal notation. It shifts gradually from the left to the right end of the dividend, subtracting the largest possible multiple of the divisor at each stage; the multiples become the digits of the quotient, and the final difference is the remainder. When used with a binary radix, it forms the basis for the integer division (unsigned) with remainder algorithm below. <a href="Short_division" title="wikilink">Short division</a> is an abbreviated form of long division suitable for one-digit divisors. <a href="Chunking_(division)" title="wikilink">Chunking</a> (also known as the partial quotients method or the hangman method) is a less-efficient form of long division which may be easier to understand.</p>
<h2 id="integer-division-unsigned-with-remainder">Integer division (unsigned) with remainder</h2>

<p>The following algorithm, the binary version of the famous <a href="long_division" title="wikilink">long division</a>, will divide <em>N</em> by <em>D</em>, placing the quotient in <em>Q</em> and the remainder in <em>R</em>. All values are treated as unsigned integers.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">if</span> D <span class="ot">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="fu">error</span><span class="ot">(</span>DivisionByZeroException<span class="ot">)</span> <span class="kw">end</span>
Q :<span class="ot">=</span> <span class="dv">0</span>                 <span class="co">-- initialize quotient and remainder to zero</span>
R :<span class="ot">=</span> <span class="dv">0</span>                     
<span class="kw">for</span> i <span class="ot">=</span> n<span class="ot">-</span><span class="dv">1</span><span class="ot">...</span><span class="dv">0</span> <span class="kw">do</span>     <span class="co">-- where n is number of bits in N</span>
  R :<span class="ot">=</span> R <span class="ot">&lt;&lt;</span> <span class="dv">1</span>          <span class="co">-- left-shift R by 1 bit</span>
  R<span class="ot">(</span><span class="dv">0</span><span class="ot">)</span> :<span class="ot">=</span> N<span class="ot">(</span>i<span class="ot">)</span>         <span class="co">-- set the least-significant bit of R equal to bit i of the numerator</span>
  <span class="kw">if</span> R <span class="ot">&gt;=</span> D <span class="kw">then</span>
    R :<span class="ot">=</span> R <span class="ot">-</span> D
    Q<span class="ot">(</span>i<span class="ot">)</span> :<span class="ot">=</span> <span class="dv">1</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<h3 id="example">Example</h3>

<p>If we take N=1100<sub>2</sub> (12<sub>10</sub>) and D=100<sub>2</sub> (4<sub>10</sub>)</p>

<p><em>Step 1</em>: Set R=0 and Q=0<br/>
<em>Step 2</em>: Take i=3 (one less than the number of bits in N)<br/>
<em>Step 3</em>: R=00 (left shifted by 1)<br/>
<em>Step 4</em>: R=01 (setting R(0) to N(i))<br/>
<em>Step 5</em>: R<d <em="">step="" ,="" 2</d></p></body>:="" <br i="2" set="" skip="" so="" statement=""/> <em>Step 3</em>: R=010<br/>
<em>Step 4</em>: R=011<br/>
<em>Step 5</em>: R<d <em="">step="" ,="" 2</d>:="" <br i="1" set="" skipped="" statement=""/> <em>Step 3</em>: R=0110<br/>
<em>Step 4</em>: R=0110<br/>
<em>Step 5</em>: R&gt;=D , statement entered<br/>
<em>Step 5b</em>: R=10 (R-D)<br/>
<em>Step 5c</em>: Q=10 (setting Q(i) to 1)

<p><em>Step 2</em>: Set i=0<br/>
<em>Step 3</em>: R=100<br/>
<em>Step 4</em>: R=100<br/>
<em>Step 5</em>: R&gt;=D , statement entered<br/>
<em>Step 5b</em>: R=0 (R-D)<br/>
<em>Step 5c</em>: Q=11 (setting Q(i) to 1)</p>

<p><strong>end</strong><br/>
Q=11<sub>2</sub> (3<sub>10</sub>) and R=0.</p>
<h2 id="slow-division-methods">Slow division methods</h2>

<p>Slow division methods are all based on a standard recurrence equation</p>

<p>

<math display="block" id="Division_algorithm:1">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mo>×</mo>
     <msub>
      <mi>P</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mo>×</mo>
     <mpadded width="+1.7pt">
      <mi>D</mi>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j+1}=R\times P_{j}-q_{n-(j+1)}\times D\,
  </annotation>
 </semantics>
</math>

, where:</p>
<ul>
<li><em>P</em><sub><em>j</em></sub> is <em>j</em>-th the partial remainder of the division</li>
<li><em>R</em> is the <a class="uri" href="radix" title="wikilink">radix</a></li>
<li><em>q</em><sub><em>n</em> − (<em>j</em> + 1)</sub> is the digit of the quotient in position <em>n-(j+1)</em>, where the digit positions are numbered from least-significant 0 to most significant <em>n</em> − 1</li>
<li><em>n</em> is number of digits in the quotient</li>
<li><em>D</em> is the divisor</li>
</ul>
<h3 id="restoring-division">Restoring division</h3>

<p>Restoring division operates on <a href="fixed_point_arithmetic" title="wikilink">fixed-point</a> fractional numbers and depends on the following assumptions: </p>
<ul>
<li><em>D</em> &lt; <em>N</em></li>
<li>0 &lt; <em>N</em>,<em>D</em> &lt; 1.</li>
</ul>

<p>The quotient digits <em>q</em> are formed from the digit set {0,1}.</p>

<p>The basic algorithm for binary (radix 2) restoring division is:</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">P :<span class="ot">=</span> N
D :<span class="ot">=</span> D <span class="ot">&lt;&lt;</span> n              <span class="co">-- P and D need twice the word width of N and Q</span>
<span class="kw">for</span> i <span class="ot">=</span> n<span class="ot">-</span><span class="dv">1</span><span class="ot">..</span><span class="dv">0</span> <span class="kw">do</span>        <span class="co">-- for example 31..0 for 32 bits</span>
  P :<span class="ot">=</span> 2P <span class="ot">-</span> D            <span class="co">-- trial subtraction from shifted value</span>
  <span class="kw">if</span> P <span class="ot">&gt;=</span> <span class="dv">0</span> <span class="kw">then</span>
    q<span class="ot">(</span>i<span class="ot">)</span> :<span class="ot">=</span> <span class="dv">1</span>            <span class="co">-- result-bit 1</span>
  <span class="kw">else</span>
    q<span class="ot">(</span>i<span class="ot">)</span> :<span class="ot">=</span> <span class="dv">0</span>            <span class="co">-- result-bit 0</span>
    P :<span class="ot">=</span> P <span class="ot">+</span> D           <span class="co">-- new partial remainder is (restored) shifted value</span>
  <span class="kw">end</span>
<span class="kw">end</span>

<span class="co">-- Where: N = Numerator, D = Denominator, n = #bits, P = Partial remainder, q(i) = bit #i of quotient</span></code></pre></div>

<p>The above restoring division algorithm can avoid the restoring step by saving the shifted value 2<em>P</em> before the subtraction in an additional register <em>T</em> (i.e., <em>T</em> = <em>P</em> 2*P[i] is saved, so <em>D</em> does not need to be added back in for the case of <code>TP[i] ≤ 0</code>.</p>
<h3 id="non-restoring-division">Non-restoring division</h3>

<p>Non-restoring division uses the digit set {−1,1} for the quotient digits instead of {0,1}. The basic algorithm for binary (radix 2) non-restoring division is:</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">P<span class="ot">[</span><span class="dv">0</span><span class="ot">]</span> :<span class="ot">=</span> N
D :<span class="ot">=</span> D <span class="ot">&lt;&lt;</span> n
i :<span class="ot">=</span> <span class="dv">0</span>
<span class="kw">while</span> i <span class="ot">&lt;</span> n <span class="kw">do</span>
  <span class="kw">if</span> P<span class="ot">[</span>i<span class="ot">]</span> <span class="ot">&gt;=</span> <span class="dv">0</span> <span class="kw">then</span>
    q<span class="ot">[</span>n<span class="ot">-(</span>i<span class="ot">+</span><span class="dv">1</span><span class="ot">)]</span> :<span class="ot">=</span> <span class="dv">1</span>
    P<span class="ot">[</span>i<span class="ot">+</span><span class="dv">1</span><span class="ot">]</span> :<span class="ot">=</span> <span class="dv">2</span><span class="ot">*</span>P<span class="ot">[</span>i<span class="ot">]</span> <span class="ot">-</span> D
  <span class="kw">else</span>
    q<span class="ot">[</span>n<span class="ot">-(</span>i<span class="ot">+</span><span class="dv">1</span><span class="ot">)]</span> :<span class="ot">=</span> <span class="ot">-</span><span class="dv">1</span>
    P<span class="ot">[</span>i<span class="ot">+</span><span class="dv">1</span><span class="ot">]</span> :<span class="ot">=</span> <span class="dv">2</span><span class="ot">*</span>P<span class="ot">[</span>i<span class="ot">]</span> <span class="ot">+</span> D
  <span class="kw">end</span> <span class="kw">if</span>
  i :<span class="ot">=</span> i <span class="ot">+</span> <span class="dv">1</span>
<span class="kw">end</span> <span class="kw">while</span></code></pre></div>

<p>Following this algorithm, the quotient is in a non-standard form consisting of digits of −1 and +1. This form needs to be converted to binary to form the final quotient. Example:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Convert the following quotient to the digit set {0,1}:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Division_algorithm:2">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mn>111</mn>
    <mover accent="true">
     <mn>1</mn>
     <mo stretchy="false">¯</mo>
    </mover>
    <mn>1</mn>
    <mover accent="true">
     <mn>1</mn>
     <mo stretchy="false">¯</mo>
    </mover>
    <mn>1</mn>
    <mover accent="true">
     <mn>1</mn>
     <mo stretchy="false">¯</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <times></times>
     <cn type="integer">111</cn>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
     <apply>
      <ci>normal-¯</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=111\bar{1}1\bar{1}1\bar{1}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Steps:</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1. Mask the negative term:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Division_algorithm:3">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>00010101</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">00010101</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=00010101\,
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2. Form the <a href="two's_complement" title="wikilink">two's complement</a> of N:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Division_algorithm:4">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>N</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mn>11101011</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">11101011</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{N}=11101011
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3. Mask the positive term:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Division_algorithm:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>11101010</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <cn type="integer">11101010</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=11101010\,
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4. Sum 

<math display="inline" id="Division_algorithm:6">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Division_algorithm:7">
 <semantics>
  <mover accent="true">
   <mi>N</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{N}
  </annotation>
 </semantics>
</math>

:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Division_algorithm:8">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>11010101</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <cn type="integer">11010101</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=11010101\,
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h3 id="srt-division">SRT division</h3>

<p>Named for its creators (Sweeney, Robertson, and Tocher), SRT division is a popular method for division in many <a class="uri" href="microprocessor" title="wikilink">microprocessor</a> implementations. SRT division is similar to non-restoring division, but it uses a <a href="lookup_table" title="wikilink">lookup table</a> based on the dividend and the divisor to determine each quotient digit. The <a href="Original_Intel_Pentium_(P5_microarchitecture)" title="wikilink">Intel Pentium</a> processor's infamous <a href="Pentium_FDIV_bug" title="wikilink">floating-point division bug</a> was caused by an incorrectly coded lookup table. Five of the 1066 entries had been mistakenly omitted.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="fast-division-methods">Fast division methods</h2>
<h3 id="newtonraphson-division">Newton–Raphson division</h3>

<p>Newton–Raphson uses <a href="Newton's_method" title="wikilink">Newton's method</a> to find the <a href="Multiplicative_inverse" title="wikilink">reciprocal</a> of 

<math display="inline" id="Division_algorithm:9">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, and multiply that reciprocal by 

<math display="inline" id="Division_algorithm:10">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 to find the <mtpl></mtpl></p>

<p>The steps of Newton–Raphson division are:</p>
<ol>
<li>Calculate an estimate 

<math display="inline" id="Division_algorithm:11">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}
  </annotation>
 </semantics>
</math>

 for the reciprocal 

<math display="inline" id="Division_algorithm:12">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/D
  </annotation>
 </semantics>
</math>

 of the divisor 

<math display="inline" id="Division_algorithm:13">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

.</li>
<li>Compute successively more accurate estimates 

<math display="inline" id="Division_algorithm:14">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>S</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>S</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},X_{2},\ldots,X_{S}
  </annotation>
 </semantics>
</math>

 of the reciprocal. This is where one employs the Newton–Raphson method as such.</li>
<li>Compute the quotient by multiplying the dividend by the reciprocal of the divisor

<math display="block" id="Division_algorithm:15">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <msub>
     <mi>X</mi>
     <mi>S</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=NX_{S}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>In order to apply Newton's method to find the reciprocal of 

<math display="inline" id="Division_algorithm:16">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, it is necessary to find a function 

<math display="inline" id="Division_algorithm:17">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X)
  </annotation>
 </semantics>
</math>

 which has a zero at 

<math display="inline" id="Division_algorithm:18">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=1/D
  </annotation>
 </semantics>
</math>

. The obvious such function is 

<math display="inline" id="Division_algorithm:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mi>X</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>X</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X)=DX-1
  </annotation>
 </semantics>
</math>

, but the Newton–Raphson iteration for this is unhelpful since it cannot be computed without already knowing the reciprocal of 

<math display="inline" id="Division_algorithm:20">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. Moreover multiple iterations for refining reciprocal are not possible since higher order derivatives do not exist for 

<math display="inline" id="Division_algorithm:21">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X)
  </annotation>
 </semantics>
</math>

. A function which does work is 

<math display="inline" id="Division_algorithm:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>X</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>X</ci>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X)=(1/X)-D
  </annotation>
 </semantics>
</math>

, for which the Newton–Raphson iteration gives</p>

<p>

<math display="block" id="Division_algorithm:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>X</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>X</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <msub>
         <mi>X</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo>-</mo>
       <mi>D</mi>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <msubsup>
         <mi>X</mi>
         <mi>i</mi>
         <mn>2</mn>
        </msubsup>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>X</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>D</mi>
         <msub>
          <mi>X</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mo>-</mo>
       <mrow>
        <mi>D</mi>
        <msub>
         <mi>X</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <ci>D</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>i</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>D</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <ci>D</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i+1}=X_{i}-{f(X_{i})\over f^{\prime}(X_{i})}=X_{i}-{1/X_{i}-D\over-1/X_{i}^%
{2}}=X_{i}+X_{i}(1-DX_{i})=X_{i}(2-DX_{i}),
  </annotation>
 </semantics>
</math>

 which can be calculated from 

<math display="inline" id="Division_algorithm:24">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 using only multiplication and subtraction, or using two <a href="fused_multiply–add" title="wikilink">fused multiply–adds</a>.</p>

<p>From a computation point of view the expressions 

<math display="inline" id="Division_algorithm:25">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mi>D</mi>
        <msub>
         <mi>X</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>D</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i+1}=X_{i}+X_{i}(1-DX_{i})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Division_algorithm:26">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <mrow>
       <mi>D</mi>
       <msub>
        <mi>X</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <ci>D</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i+1}=X_{i}(2-DX_{i})
  </annotation>
 </semantics>
</math>

 are not equivalent. To obtain a result with a precision of n bits while making use of the second expression one must compute the product between 

<math display="inline" id="Division_algorithm:27">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Division_algorithm:28">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>2</mn>
    <mo>-</mo>
    <mrow>
     <mi>D</mi>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2-DX_{i})
  </annotation>
 </semantics>
</math>

 with double the required precision (2n bits). In contrast the product between 

<math display="inline" id="Division_algorithm:29">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Division_algorithm:30">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>D</mi>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1-DX_{i})
  </annotation>
 </semantics>
</math>

 need only be computed with a precision of n bits.</p>

<p>If the error is defined as 

<math display="inline" id="Division_algorithm:31">
 <semantics>
  <mrow>
   <msub>
    <mi>ϵ</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>D</mi>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{i}=DX_{i}-1\,
  </annotation>
 </semantics>
</math>

, then:</p>

<p>

<math display="inline" id="Division_algorithm:32">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\epsilon_{i+1}
  </annotation>
 </semantics>
</math>


 This squaring of the error at each iteration step — the so-called <a href="Newton's_method#Practical_considerations" title="wikilink">quadratic convergence</a> of Newton–Raphson's method — has the effect that the number of correct digits in the result roughly <em>doubles for every iteration</em>, a property that becomes extremely valuable when the numbers involved have many digits (e.g. in the large integer domain). But it also means that the initial convergence of the method can be comparatively slow, especially if the initial estimate 

<math display="inline" id="Division_algorithm:33">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}
  </annotation>
 </semantics>
</math>

 is poorly chosen.</p>

<p>Apply a bit-shift to the divisor <em>D</em> to scale it so that 0.5 ≤ <em>D</em> ≤ 1 . The same bit-shift should be applied to the numerator <em>N</em> so that the quotient does not change. Then one could use a linear <a class="uri" href="approximation" title="wikilink">approximation</a> in the form</p>

<p>

<math display="block" id="Division_algorithm:34">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>T</mi>
      <mn>2</mn>
     </msub>
     <mi>D</mi>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mn>1</mn>
     <mi>D</mi>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}=T_{1}+T_{2}D\approx\frac{1}{D}\,
  </annotation>
 </semantics>
</math>

</p>

<p>to initialize Newton–Raphson. To minimize the maximum of the relative error of this approximation on interval 

<math display="inline" id="Division_algorithm:35">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0.5</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="float">0.5</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0.5,1]
  </annotation>
 </semantics>
</math>

 one should use</p>

<p>

<math display="block" id="Division_algorithm:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>48</mn>
      <mn>17</mn>
     </mfrac>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>32</mn>
       <mn>17</mn>
      </mfrac>
      <mi>D</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">48</cn>
      <cn type="integer">17</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">32</cn>
       <cn type="integer">17</cn>
      </apply>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}={48\over 17}-{32\over 17}D.\,
  </annotation>
 </semantics>
</math>

 The coefficients of the linear approximation are determined as follows. The relative error is 

<math display="inline" id="Division_algorithm:37">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>T</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>T</mi>
          <mn>2</mn>
         </msub>
         <mi>D</mi>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mi>D</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mi>D</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>D</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>T</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>T</mi>
          <mn>2</mn>
         </msub>
         <mi>D</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>D</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>D</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>D</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>D</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |(T_{1}+T_{2}D-1/D)/(1/D)|=|D(T_{1}+T_{2}D)-1|
  </annotation>
 </semantics>
</math>

. The minimum of the maximum relative error is determined by the <a href="Equioscillation_theorem" title="wikilink">Chebyshev equioscillation theorem</a> applied to 

<math display="inline" id="Division_algorithm:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>T</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>T</mi>
         <mn>2</mn>
        </msub>
        <mi>D</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>D</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>D</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(D)=D(T_{1}+T_{2}D)-1
  </annotation>
 </semantics>
</math>

. The local extremum of 

<math display="inline" id="Division_algorithm:39">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(D)
  </annotation>
 </semantics>
</math>

 occurs when 

<math display="inline" id="Division_algorithm:40">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>F</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>D</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}(D)=0
  </annotation>
 </semantics>
</math>

, which has solution 

<math display="inline" id="Division_algorithm:41">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>T</mi>
      <mn>1</mn>
     </msub>
     <mo>/</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>T</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=-T_{1}/(2T_{2})
  </annotation>
 </semantics>
</math>

. The function at the extremum must be of opposite sign as the function at the endpoints, namely, 

<math display="inline" id="Division_algorithm:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>T</mi>
         <mn>1</mn>
        </msub>
        <mo>/</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>2</mn>
          <msub>
           <mi>T</mi>
           <mn>2</mn>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>F</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>F</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>T</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(1/2)=F(1)=-F(-T_{1}/(2T_{2}))
  </annotation>
 </semantics>
</math>

. The two equations in the two unknowns have solution 

<math display="inline" id="Division_algorithm:43">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>48</mn>
    <mo>/</mo>
    <mn>17</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">48</cn>
     <cn type="integer">17</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}=48/17
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Division_algorithm:44">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>32</mn>
     <mo>/</mo>
     <mn>17</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">32</cn>
      <cn type="integer">17</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}=-32/17
  </annotation>
 </semantics>
</math>

, and the maximum relative error is 

<math display="inline" id="Division_algorithm:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>17</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">17</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(1)=1/17
  </annotation>
 </semantics>
</math>

. Using this approximation, the relative error of the initial value is less than</p>

<p>

<math display="block" id="Division_algorithm:46">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>ϵ</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mn>17</mn>
   </mfrac>
   <mo>≈</mo>
   <mpadded width="+1.7pt">
    <mn>0.059.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">17</cn>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <cn type="float">0.059.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\epsilon_{0}|\leq{1\over 17}\approx 0.059.\,
  </annotation>
 </semantics>
</math>

 It is possible to generate a polynomial fit of degree larger than 1, computing the coefficients using the <a href="Remez_algorithm" title="wikilink">Remez algorithm</a>. The trade-off is that the initial guess requires more computational cycles but hopefully in exchange for fewer iterations of Newton–Raphson.</p>

<p>Since for this method the <a href="rate_of_convergence" title="wikilink">convergence</a> is exactly quadratic, it follows that</p>

<p>

<math display="block" id="Division_algorithm:47">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo>⌈</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mfrac>
      <mrow>
       <mi>P</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>2</mn>
       </msub>
       <mn>17</mn>
      </mrow>
     </mfrac>
    </mrow>
    <mo rspace="4.2pt">⌉</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <ceiling></ceiling>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">17</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\left\lceil\log_{2}\frac{P+1}{\log_{2}17}\right\rceil\,
  </annotation>
 </semantics>
</math>

</p>

<p>steps is enough to calculate the value up to 

<math display="inline" id="Division_algorithm:48">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,
  </annotation>
 </semantics>
</math>

 binary places. This evaluates to 3 for IEEE <a href="single_precision" title="wikilink">single precision</a> and 4 for both <a href="double_precision" title="wikilink">double precision</a> and <a href="extended_precision" title="wikilink">double extended</a> formats.</p>
<h4 id="pseudocode">Pseudocode</h4>

<p>The following computes the quotient of N and D with a precision of P binary places: <code>
 Express D as M × 2<sup>e</sup> where 1 ≤ M &lt; 2 (standard floating point representation)
 D' := D / 2<sup>e+1</sup>   ''// scale between 0.5 and 1, can be performed with bit shift / exponent subtraction''
 N' := N / 2<sup>e+1</sup>
 X := 48/17 - 32/17 × D'   ''// precompute constants with same precision as D''
 '''repeat''' <math>\left \lceil \log_2 \frac{P + 1}{\log_2 17} \right \rceil \,</math> '''times'''   ''// can be precomputed based on fixed P''
     X := X + X × (1 - D' × X)
 '''end'''
 '''return''' N' × X
</code> For example, for a double-precision floating-point division, this method uses 10 multiplies, 9 adds, and 2 shifts.</p>
<h3 id="goldschmidt-division">Goldschmidt division</h3>

<p>Goldschmidt (after Robert Elliott Goldschmidt)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> division uses an iterative process of repeatedly multiplying both the dividend and divisor by a common factor <em>F</em><sub><em>i</em></sub>, chosen such that the divisor converges to 1. This causes the dividend to converge to the sought quotient <em>Q</em>:</p>

<p>

<math display="block" id="Division_algorithm:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mi>N</mi>
      <mi>D</mi>
     </mfrac>
     <mfrac>
      <msub>
       <mi>F</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>F</mi>
       <mn>1</mn>
      </msub>
     </mfrac>
     <mfrac>
      <msub>
       <mi>F</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>F</mi>
       <mn>2</mn>
      </msub>
     </mfrac>
     <mfrac>
      <msub>
       <mi>F</mi>
       <mi mathvariant="normal">…</mi>
      </msub>
      <msub>
       <mi>F</mi>
       <mi mathvariant="normal">…</mi>
      </msub>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>N</ci>
      <ci>D</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>normal-…</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>normal-…</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\frac{N}{D}\frac{F_{1}}{F_{1}}\frac{F_{2}}{F_{2}}\frac{F_{\ldots}}{F_{\ldots%
}}.
  </annotation>
 </semantics>
</math>

</p>

<p>The steps for Goldschmidt division are:</p>
<ol>
<li>Generate an estimate for the multiplication factor <em>F<sub>i</sub></em> .</li>
<li>Multiply the dividend and divisor by <em>F<sub>i</sub></em> .</li>
<li>If the divisor is sufficiently close to 1, return the dividend, otherwise, loop to step 1.</li>
</ol>

<p>Assuming <em>N</em>/<em>D</em> has been scaled so that 0 i'' is based on <em>D</em>:</p>

<p>

<math display="block" id="Division_algorithm:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mo>-</mo>
     <msub>
      <mi>D</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i+1}=2-D_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>Multiplying the dividend and divisor by the factor yields:</p>

<p>

<math display="block" id="Division_algorithm:51">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <msub>
      <mi>N</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>D</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <msub>
       <mi>N</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>D</mi>
       <mi>i</mi>
      </msub>
     </mfrac>
     <mfrac>
      <msub>
       <mi>F</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>F</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{N_{i+1}}{D_{i+1}}=\frac{N_{i}}{D_{i}}\frac{F_{i+1}}{F_{i+1}}.
  </annotation>
 </semantics>
</math>

</p>

<p>After a sufficient number <em>k</em> of iterations 

<math display="inline" id="Division_algorithm:52">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <msub>
    <mi>N</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=N_{k}
  </annotation>
 </semantics>
</math>

.</p>

<p>The Goldschmidt method is used in <a class="uri" href="AMD" title="wikilink">AMD</a> Athlon CPUs and later models.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="binomial-theorem">Binomial theorem</h3>

<p>The Goldschmidt method can be used with factors that allow simplifications by the <a href="binomial_theorem" title="wikilink">binomial theorem</a>. Assuming N/D has been scaled by a <a href="power_of_two" title="wikilink">power of two</a> such that 

<math display="inline" id="Division_algorithm:53">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>D</ci>
    <interval closure="open-closed">
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\in(\tfrac{1}{2},1]
  </annotation>
 </semantics>
</math>

. We choose 

<math display="inline" id="Division_algorithm:54">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=1-x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Division_algorithm:55">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <msup>
     <mi>x</mi>
     <msup>
      <mn>2</mn>
      <mi>i</mi>
     </msup>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i}=1+x^{2^{i}}
  </annotation>
 </semantics>
</math>

. This yields</p>

<p>

<math display="block" id="Division_algorithm:56">
 <semantics>
  <mrow>
   <mfrac>
    <mi>N</mi>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>x</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>N</mi>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>N</mi>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msup>
      <mi>x</mi>
      <mn>4</mn>
     </msup>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>=</mo>
   <msup>
    <mi>Q</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>N</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>N</mi>
       <mo>⋅</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mi>x</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>⋅</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <msup>
          <mi>x</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi mathvariant="normal">⋯</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <msup>
         <mi>x</mi>
         <msup>
          <mn>2</mn>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </msup>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <msup>
      <mi>D</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msup>
       <mi>x</mi>
       <msup>
        <mn>2</mn>
        <mi>n</mi>
       </msup>
      </msup>
     </mrow>
     <mo>≈</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>N</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-⋅</ci>
       <ci>N</ci>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-⋅</ci>
       <ci>N</ci>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <ci>x</ci>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>N</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <ci>N</ci>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <ci>x</ci>
         </apply>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <cn type="integer">2</cn>
           <apply>
            <minus></minus>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>D</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <cn type="integer">2</cn>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <approx></approx>
        <share href="#.cmml">
        </share>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{N}{1-x}=\frac{N\cdot(1+x)}{1-x^{2}}=\frac{N\cdot(1+x)\cdot(1+x^{2})}{1-x%
^{4}}=\cdots=Q^{\prime}=\frac{N^{\prime}=N\cdot(1+x)\cdot(1+x^{2})\cdot\cdot%
\cdot(1+x^{2^{(n-1)}})}{D^{\prime}=1-x^{2^{n}}\approx 1}
  </annotation>
 </semantics>
</math>

.</p>

<p>After 

<math display="inline" id="Division_algorithm:57">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 steps 

<math display="inline" id="Division_algorithm:58">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <interval closure="closed-open">
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\in[0,\tfrac{1}{2}))
  </annotation>
 </semantics>
</math>

, the denominator 

<math display="inline" id="Division_algorithm:59">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msup>
    <mi>x</mi>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-x^{2^{n}}
  </annotation>
 </semantics>
</math>

 can be rounded to 

<math display="inline" id="Division_algorithm:60">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 with a <a href="relative_error" title="wikilink">relative error</a></p>

<p>

<math display="block" id="Division_algorithm:61">
 <semantics>
  <mrow>
   <msub>
    <mi>ϵ</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>Q</mi>
      <mo>′</mo>
     </msup>
     <mo>-</mo>
     <msup>
      <mi>N</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <msup>
     <mi>Q</mi>
     <mo>′</mo>
    </msup>
   </mfrac>
   <mo>=</mo>
   <msup>
    <mi>x</mi>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϵ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Q</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>N</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Q</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{n}=\frac{Q^{\prime}-N^{\prime}}{Q^{\prime}}=x^{2^{n}}
  </annotation>
 </semantics>
</math>

</p>

<p>which is maximum at 

<math display="inline" id="Division_algorithm:62">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo>-</mo>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-2^{n}}
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Division_algorithm:63">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x={1\over 2}
  </annotation>
 </semantics>
</math>

, thus providing a minimum precision of 

<math display="inline" id="Division_algorithm:64">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 binary digits.</p>

<p>This algorithm is referred to as the IBM method in.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="large-integer-methods">Large integer methods</h2>

<p>Methods designed for hardware implementation generally do not scale to integers with thousands or millions of decimal digits; these frequently occur, for example, in <a href="Modular_arithmetic" title="wikilink">modular</a> reductions in <a class="uri" href="cryptography" title="wikilink">cryptography</a>. For these large integers, more efficient division algorithms transform the problem to use a small number of multiplications, which can then be done using an asymptotically efficient <a href="multiplication_algorithm" title="wikilink">multiplication algorithm</a> such as the <a href="Karatsuba_algorithm" title="wikilink">Karatsuba algorithm</a>, <a href="Toom–Cook_multiplication" title="wikilink">Toom–Cook multiplication</a> or the <a href="Schönhage–Strassen_algorithm" title="wikilink">Schönhage–Strassen algorithm</a>. It results that the <a href="Analysis_of_algorithms" title="wikilink">computational complexity</a> of the division is of the same order (up a multiplicative constant) as that of the multiplication. Examples include reduction to multiplication by <a href="Newton's_method" title="wikilink">Newton's method</a> as <a href="#Newton–Raphson_division" title="wikilink">described above</a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> as well as the slightly faster <a href="Barrett_reduction" title="wikilink">Barrett reduction</a> algorithm.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Newton's method is particularly efficient in scenarios where one must divide by the same divisor many times, since after the initial Newton inversion only one (truncated) multiplication is needed for each division.</p>
<h2 id="division-by-a-constant">Division by a constant</h2>

<p>The division by a constant <em>D</em> is equivalent to the multiplication by its <a href="Multiplicative_inverse" title="wikilink">reciprocal</a>. Since the denominator is constant, so is its reciprocal (1/<em>D</em>). Thus it is possible to compute the value of (1/<em>D</em>) once at compile time, and at run time perform the multiplication <em>N</em>·(1/<em>D</em>) rather than the division <em>N/D</em>. In <a href="floating_point" title="wikilink">floating point</a> arithmetic the use of (1/<em>D</em>) presents little problem, but in <a href="Integer_(computer_science)" title="wikilink">integer</a> arithmetic the reciprocal will always evaluate to zero (assuming |<em>D</em>| &gt; 1).</p>

<p>It is not necessary to use specifically (1/<em>D</em>); any value (<em>X</em>/<em>Y</em>) that reduces to (1/<em>D</em>) may be used. For example, for division by 3, the factors 1/3, 2/6, 3/9, or 194/582 could be used. Consequently, if <em>Y</em> were a power of two so the division step reduces to a fast right bit shift. The effect of calculating <em>N</em>/<em>D</em> as (<em>N</em>·<em>X</em>)/<em>Y</em> replaces a division with a multiply and a shift. Note that the parentheses are important, as <em>N</em>·(<em>X</em>/<em>Y</em>) will evaluate to zero.</p>

<p>However, unless <em>D</em> itself is a power of two, there is no <em>X</em> and <em>Y</em> that satisfies the conditions above. Fortunately, it is not necessary for (<em>X</em>/<em>Y</em>) to be exactly equal to 1/<em>D</em>, but only that it is "close enough" so that the error introduced by the approximation is in the bits that are discarded by the shift operation.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>As a concrete example, for 32 bit unsigned integers, division by 3 can be replaced with a multiply by 2863311531 / 2<sup>33</sup>, a multiplication by 2863311531 followed by a 33 right bit shift. The value of 2863311531 is calculated as 2<sup>33</sup> / 3 then rounded to nearest integer.</p>

<p>In some cases, division by a constant can be accomplished in even less time by converting the "multiply by a constant" into a <a href="Multiplication_algorithm#Shift_and_add" title="wikilink">series of shifts and adds or subtracts</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Of particular interest is division by 10, for which the exact quotient is obtained, with remainder if required.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="rounding-error">Rounding error</h2>

<p><a href="Round-off_error" title="wikilink">Round-off error</a> can be introduced by division operations due to limited <a href="Precision_(computer_science)" title="wikilink">precision</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Multiplication_algorithm" title="wikilink">Multiplication algorithm</a></li>
<li><a href="Pentium_FDIV_bug" title="wikilink">Pentium FDIV bug</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.ecs.umass.edu/ece/koren/arith/simulator/">Computer Arithmetic Algorithms JavaScript Simulator</a> – contains simulators for many different division algorithms</li>
<li>

<p>(Extends division by constants.)</p></li>
<li><a class="uri" href="http://www.dauniv.ac.in/downloads/CArch_PPTs/CompArchCh03L07IntegerDivision.pdf">http://www.dauniv.ac.in/downloads/CArch_PPTs/CompArchCh03L07IntegerDivision.pdf</a></li>
<li><a class="uri" href="http://www.seas.ucla.edu/~ingrid/ee213a/lectures/division_presentV2.pdf">http://www.seas.ucla.edu/~ingrid/ee213a/lectures/division_presentV2.pdf</a></li>
</ul>

<p>"</p>

<p><a href="Category:Binary_arithmetic" title="wikilink">Category:Binary arithmetic</a> <a href="Category:Computer_arithmetic" title="wikilink">Category:Computer arithmetic</a> <a href="Category:Division_(mathematics)" title="wikilink">Digital</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Computer_arithmetic_algorithms" title="wikilink">Category:Computer arithmetic algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Paul Molitor, <a href="https://mephisto.informatik.uni-halle.de/aufzeichnungen/vhdl/folien/vhdl06_sw.pdf">"Entwurf digitaler Systeme mit VHDL"</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="http://techref.massmind.org/techref/method/math/divconst.htm">Massmind: "Binary Division by a Constant"</a><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>


