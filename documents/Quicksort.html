<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="131">Quicksort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quicksort</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Quicksort</strong> (sometimes called <strong>partition-exchange sort</strong>) is an efficient <a href="sorting_algorithm" title="wikilink">sorting algorithm</a>, serving as a systematic method for placing the elements of an <a href="Array_data_structure" title="wikilink">array</a> in order. Developed by <a href="Tony_Hoare" title="wikilink">Tony Hoare</a> in 1959,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> with his work published in 1961,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> it is still a commonly used algorithm for sorting. When implemented well, it can be about two or three times faster than its main competitors, <a href="merge_sort" title="wikilink">merge sort</a> and <a class="uri" href="heapsort" title="wikilink">heapsort</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Quicksort is a <a href="comparison_sort" title="wikilink">comparison sort</a>, meaning that it can sort items of any type for which a "less-than" relation (formally, a <a href="total_order" title="wikilink">total order</a>) is defined. In efficient implementations it is not a <a href="stable_sort" title="wikilink">stable sort</a>, meaning that the relative order of equal sort items is not preserved. Quicksort can operate <a href="in-place_algorithm" title="wikilink">in-place</a> on an array, requiring small additional amounts of <a href="Main_memory" title="wikilink">memory</a> to perform the sorting.</p>

<p><a href="Analysis_of_algorithms" title="wikilink">Mathematical analysis</a> of quicksort shows that, <a href="best,_worst_and_average_case" title="wikilink">on average</a>, the algorithm takes <a href="Big_O_notation" title="wikilink">O</a>(<em>n</em> log <em>n</em>) comparisons to sort <em>n</em> items. In the <a href="best,_worst_and_average_case" title="wikilink">worst case</a>, it makes O(<em>n</em><sup>2</sup>) comparisons, though this behavior is rare.</p>
<h2 id="history">History</h2>

<p>The quicksort algorithm was developed in 1960 by <a href="Tony_Hoare" title="wikilink">Tony Hoare</a> while in the <a href="Soviet_Union" title="wikilink">Soviet Union</a>, as a visiting student at <a href="Moscow_State_University" title="wikilink">Moscow State University</a>. At that time, Hoare worked in a project on <a href="machine_translation" title="wikilink">machine translation</a> for the <a href="National_Physical_Laboratory,_UK" title="wikilink">National Physical Laboratory</a>. As a part of translation process, he needed to sort the words of Russian sentence prior to looking them up in a Russian-English dictionary which was already sorted in alphabetic order on <a href="magnetic_tape_data_storage" title="wikilink">magnetic tape</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> After recognizing that his first idea, <a href="insertion_sort" title="wikilink">insertion sort</a>, would be bit slow, he quickly came up with new idea that was Quicksort. He wrote a program in Mercury <a class="uri" href="Autocode" title="wikilink">Autocode</a> for the partition but couldn't write the program to account for the list of unsorted segments. On return to England, he was asked to write code for <a class="uri" href="Shellsort" title="wikilink">Shellsort</a> as part of his new job. Hoare mentioned to his boss that he knew of faster algorithm and his boss bet sixpence that he didn't. His boss ultimately accepted that he had lost the bet. Later, Hoare learned about <a class="uri" href="ALGOL" title="wikilink">ALGOL</a> and its ability to do recursion which enabled him to publish the code in <a href="Association_for_Computing_Machinery" title="wikilink">ACM</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Quicksort gained widespread adoption, appearing, for example, in <a class="uri" href="Unix" title="wikilink">Unix</a> as the default library sort function, hence it lent its name to the <a href="C_standard_library" title="wikilink">C standard library</a> function <code>[[qsort]]</code><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and in the reference implementation of <a href="Java_(programming_language)" title="wikilink">Java</a>.</p>

<p><a href="Robert_Sedgewick_(computer_scientist)" title="wikilink">Robert Sedgewick</a>'s Ph.D. thesis in 1975 is considered a milestone in the study of Quicksort where he resolved many open problems related to the analysis of various pivot selection schemes including <a class="uri" href="Samplesort" title="wikilink">Samplesort</a>, adaptive partitioning by Van Emden<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> as well as derivation of expected number of comparisons and swaps.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Bentley and McIlroy incorporated various improvements for use in programming libraries including technique to deal with equal elements and a pivot scheme known as <em>pseudomedian of nine</em> where sample of 9 elements are divided in groups of 3 and then median of the 3 medians from 3 groups is chosen.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> <a href="Jon_Bentley" title="wikilink">Jon Bentley</a> described another simpler and compact partitioning scheme in his book <a href="Programming_Pearls" title="wikilink">Programming Pearls</a> that he attributed to Nico Lomuto. Later Bentley wrote that he used Hoare's version for years but never really understood it but Lomuto's version was simple enough to prove correct.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Bentley described Quicksort as the "most beautiful code I had ever written" in the same essay. Lomuto's partition scheme was also popularized by the textbook <a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a> although it is inferior to Hoare's scheme because it does 3 times more swaps on average and degrades to 

<math display="inline" id="Quicksort:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 runtime when all elements are equal.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> </p>

<p>In 2009, Yaroslavskiy proposed the new dual pivot Quicksort implementation.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> In the Java core library mailing lists, he initiated a discussion claiming his new algorithm to be superior to the runtime library’s sorting method at that time based on the widely used and carefully tuned variant of classic Quicksort by Bently and McIlroy.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Yaroslavskiy’s Quicksort has been chosen as the new default sorting algorithm in Oracle’s Java 7 runtime library after extensive empirical performance tests.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="algorithm">Algorithm</h2>

<p> Quicksort is a <a href="divide_and_conquer_algorithm" title="wikilink">divide and conquer algorithm</a>. Quicksort first divides a large array into two smaller sub-arrays: the low elements and the high elements. Quicksort can then recursively sort the sub-arrays.</p>

<p>The steps are:</p>
<ol>
<li>Pick an element, called a <strong>pivot</strong>, from the array.</li>
<li>Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the <strong>partition</strong> operation.</li>
<li><a href="Recursion_(computer_science)" title="wikilink">Recursively</a> apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</li>
</ol>

<p>The base case of the recursion is arrays of size zero or one, which never need to be sorted. In <a class="uri" href="pseudocode" title="wikilink">pseudocode</a>, a quicksort that sorts elements 

<math display="inline" id="Quicksort:1">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   lo
  </annotation>
 </semantics>
</math>

 through 

<math display="inline" id="Quicksort:2">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   hi
  </annotation>
 </semantics>
</math>

 (inclusive) of an array 

<math display="inline" id="Quicksort:3">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 can be expressed compactly as<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">quicksort(A, lo, hi)
  <span class="cf">if</span> lo <span class="op">&lt;</span> hi
    p <span class="op">=</span> partition(A, lo, hi)
    quicksort(A, lo, p <span class="op">-</span> <span class="dv">1</span>)
    quicksort(A, p <span class="op">+</span> <span class="dv">1</span>, hi)</code></pre></div>
<figure><b>(Figure)</b>
<figcaption>In-place partition in action on a small list. The boxed element is the pivot element, blue elements are less or equal, and red elements are larger. Note: Appears to show partition using less-than-or-equal instead of strictly less-than as indicated in algorithm discussion.</figcaption>
</figure>

<p>Sorting the entire array is accomplished by calling <code>quicksort(A, 1, length(A))</code>.</p>

<p>The algorithm for <code>partition</code> has several variants. Some popular variants are described below.</p>
<h3 id="lomuto-partition-scheme">Lomuto partition scheme</h3>

<p>This scheme is attributed to Nico Lomuto and popularized by Bentley in his book Programming Pearls<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> and Cormen <em>et al.</em> in their book <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> This scheme chooses a pivot which is typically the last element in the array. The algorithm maintains the index to put pivot in variable <code>i</code> and each time when it finds an element less than or equal to pivot, this index is incremented and that element would be placed before the pivot. As this scheme is more compact and easy to understand, it is frequently used in introductory material, although it is less efficient than Hoare's original scheme.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> This scheme degrade to 

<math display="inline" id="Quicksort:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 when array is already sorted as well as when the array has all equal elements.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> There have been various variants proposed to boost performance including various ways to select pivot, deal with equal elements, use other sorting algorithms such as Insertion sort for small arrays and so on.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">partition(A, lo, hi)
    pivot <span class="op">=</span> A[hi]
    i <span class="op">=</span> lo <span class="op">-</span> <span class="dv">1</span> <span class="op">//</span>place <span class="cf">for</span> pivot
    <span class="cf">for</span> j <span class="op">=</span> lo to hi <span class="op">-</span> <span class="dv">1</span>
        <span class="cf">if</span> A[j] <span class="op">&lt;=</span> pivot
            i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span>
            swap A[i] <span class="cf">with</span> A[j]
    i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span>
    swap A[i] <span class="cf">with</span> A[hi]
    <span class="cf">return</span> i</code></pre></div>
<h3 id="hoare-partition-scheme">Hoare partition scheme</h3>

<p>This is the original partition scheme described by C.A.R. Hoare using two indices that moves in opposite direction until an inversion is found in which case the elements are swapped to bring them in relative sort order.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> When the indices crosses each other, algorithm stops and returns the index value. There are many variants of this algorithm, for example, selecting pivot from <code>A[hi]</code> instead of <code>A[lo]</code>. Hoare scheme is more efficient than Lomuto's partition scheme because it does 3 times less swaps on average and it creates efficient partitions even when all values are equal.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Like Lomuto's partition scheme, Hoare partitioning also causes Quicksort to degrade to 

<math display="inline" id="Quicksort:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 when array is already sorted and also doesn't produce stable sort.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">partition(A, lo, hi)
    pivot <span class="op">=</span> A[hi]
    i <span class="op">=</span> lo <span class="op">-</span> <span class="dv">1</span>
    j <span class="op">=</span> hi
    <span class="cf">while</span> <span class="va">True</span>
        do
            i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span>
        <span class="cf">while</span> A[i] <span class="op">&lt;</span> pivot
        do
            j <span class="op">=</span> j <span class="op">-</span> <span class="dv">1</span>
        <span class="cf">while</span> A[j] <span class="op">&gt;</span> pivot
        <span class="cf">if</span> (i <span class="op">&lt;</span> j)
            swap A[i] <span class="cf">with</span> A[j]
        <span class="cf">else</span> 
            swap A[i] <span class="cf">with</span> A[hi]
            <span class="cf">return</span> i</code></pre></div>
<h3 id="implementation-issues">Implementation issues</h3>
<h4 id="choice-of-pivot">Choice of pivot</h4>

<p>In the very early versions of quicksort, the leftmost element of the partition would often be chosen as the pivot element. Unfortunately, this causes worst-case behavior on already sorted arrays, which is a rather common use-case. The problem was easily solved by choosing either a random index for the pivot, choosing the middle index of the partition or (especially for longer partitions) choosing the <a class="uri" href="median" title="wikilink">median</a> of the first, middle and last element of the partition for the pivot (as recommended by <a href="Robert_Sedgewick_(computer_scientist)" title="wikilink">Sedgewick</a>).<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> This "median-of-three" rule counters the case of sorted (or reverse-sorted) input, and gives a better estimate of the optimal pivot (the true median) than selecting any single element, when no information about the ordering of the input is known.</p>

<p>Specifically, the expected number of comparisons needed to sort 

<math display="inline" id="Quicksort:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements (see ) with random pivot selection is 

<math display="inline" id="Quicksort:7">
 <semantics>
  <mrow>
   <mn>1.386</mn>
   <mi>n</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="float">1.386</cn>
    <ci>n</ci>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1.386nlogn
  </annotation>
 </semantics>
</math>

. Median-of-three pivoting brings this down to <mtpl></mtpl>, at the expense of a three-percent increase in the expected number of swaps. An even stronger pivoting rule, for larger arrays, is to pick the <a class="uri" href="ninther" title="wikilink">ninther</a>, a recursive median-of-three, defined as</p>
<dl>
<dd>

<math display="inline" id="Quicksort:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
    <mi>h</mi>
    <mi>e</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mi>e</mi>
    <mi>d</mi>
    <mi>i</mi>
    <mi>a</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>m</mi>
       <mi>e</mi>
       <mi>d</mi>
       <mi>i</mi>
       <mi>a</mi>
       <mi>n</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>o</mi>
       <mi>f</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>t</mi>
       <mi>h</mi>
       <mi>r</mi>
       <mi>e</mi>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>f</mi>
         <mi>i</mi>
         <mi>r</mi>
         <mi>s</mi>
         <mi>t</mi>
         <mi mathvariant="normal">⅓</mi>
         <mi>o</mi>
         <mi>f</mi>
         <mi>a</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>m</mi>
       <mi>e</mi>
       <mi>d</mi>
       <mi>i</mi>
       <mi>a</mi>
       <mi>n</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>o</mi>
       <mi>f</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>t</mi>
       <mi>h</mi>
       <mi>r</mi>
       <mi>e</mi>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>m</mi>
         <mi>i</mi>
         <mi>d</mi>
         <mi>d</mi>
         <mi>l</mi>
         <mi>e</mi>
         <mi mathvariant="normal">⅓</mi>
         <mi>o</mi>
         <mi>f</mi>
         <mi>a</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>m</mi>
       <mi>e</mi>
       <mi>d</mi>
       <mi>i</mi>
       <mi>a</mi>
       <mi>n</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>o</mi>
       <mi>f</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>t</mi>
       <mi>h</mi>
       <mi>r</mi>
       <mi>e</mi>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>f</mi>
         <mi>i</mi>
         <mi>n</mi>
         <mi>a</mi>
         <mi>l</mi>
         <mi mathvariant="normal">⅓</mi>
         <mi>o</mi>
         <mi>f</mi>
         <mi>a</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>t</ci>
     <ci>h</ci>
     <ci>e</ci>
     <ci>r</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>e</ci>
     <ci>d</ci>
     <ci>i</ci>
     <ci>a</ci>
     <ci>n</ci>
     <vector>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>e</ci>
        <ci>d</ci>
        <ci>i</ci>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>h</ci>
        <ci>r</ci>
        <ci>e</ci>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>i</ci>
         <ci>r</ci>
         <ci>s</ci>
         <ci>t</ci>
         <ci>normal-⅓</ci>
         <ci>o</ci>
         <ci>f</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>e</ci>
        <ci>d</ci>
        <ci>i</ci>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>h</ci>
        <ci>r</ci>
        <ci>e</ci>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>i</ci>
         <ci>d</ci>
         <ci>d</ci>
         <ci>l</ci>
         <ci>e</ci>
         <ci>normal-⅓</ci>
         <ci>o</ci>
         <ci>f</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>e</ci>
        <ci>d</ci>
        <ci>i</ci>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>h</ci>
        <ci>r</ci>
        <ci>e</ci>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>i</ci>
         <ci>n</ci>
         <ci>a</ci>
         <ci>l</ci>
         <ci>normal-⅓</ci>
         <ci>o</ci>
         <ci>f</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ninther(a)=median(median-of-three(first⅓ofa),median-of-three(middle⅓ofa),%
median-of-three(final⅓ofa))
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Selecting a pivot element is also complicated by the existence of <a href="integer_overflow" title="wikilink">integer overflow</a>. If the boundary indices of the subarray being sorted are sufficiently large, the naïve expression for the middle index, 

<math display="inline" id="Quicksort:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>l</mi>
      <mi>o</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mi>i</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>l</ci>
      <ci>o</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (lo+hi)/2
  </annotation>
 </semantics>
</math>

, will cause overflow and provide an invalid pivot index. This can be overcome by using, for example, 

<math display="inline" id="Quicksort:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mi>i</mi>
      <mi mathvariant="normal">−</mi>
      <mi>l</mi>
      <mi>o</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>i</ci>
      <ci>normal-−</ci>
      <ci>l</ci>
      <ci>o</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   lo+(hi−lo)/2
  </annotation>
 </semantics>
</math>

 to index the middle element, at the cost of more complex arithmetic. Similar issues arise in some other methods of selecting the pivot element.</p>
<h4 id="repeated-elements">Repeated elements</h4>

<p>With a partitioning algorithm such as the one described above (even with one that chooses good pivot values), quicksort exhibits poor performance for inputs that contain many repeated elements. The problem is clearly apparent when all the input elements are equal: at each recursion, the left partition is empty (no input values are less than the pivot), and the right partition has only decreased by one element (the pivot is removed). Consequently, the algorithm takes quadratic time to sort an array of equal values.</p>

<p>To solve this problem (sometimes called the <a href="Dutch_national_flag_problem" title="wikilink">Dutch national flag problem</a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a>), an alternative linear-time partition routine can be used that separates the values into three groups: values less than the pivot, values equal to the pivot, and values greater than the pivot. (Bentley and McIlroy call this a "fat partition" and note that it was already implemented in the  of <a href="Version_7_Unix" title="wikilink">Version 7 Unix</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a>) The values equal to the pivot are already sorted, so only the less-than and greater-than partitions need to be recursively sorted. In pseudocode, the quicksort algorithm becomes</p>

<p><code>quicksort(A, lo, hi)</code><br/>
<code>    </code><strong><code>if</code></strong><code> lo </code><code>$k ≪ n$</code><code> elements). In the case of all equal elements, the modified quicksort will perform at most two recursive calls on empty subarrays and thus finish in linear time.</code></p>
<h4 id="optimizations">Optimizations</h4>

<p>Two other important optimizations, also suggested by Sedgewick and widely used in practice are:<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<ul>
<li>To make sure at most 

<math display="inline" id="Quicksort:11">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 space is used, <a href="Wiktionary:recurse" title="wikilink">recurse</a> first into the smaller side of the partition, then use a <a href="tail_call" title="wikilink">tail call</a> to recurse into the other.</li>
<li>Use <a href="insertion_sort" title="wikilink">insertion sort</a>, which has a smaller constant factor and is thus faster on small arrays, for invocations on small arrays (i.e. where the length is less than a threshold 

<math display="inline" id="Quicksort:12">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 determined experimentally). This can be implemented by simply stopping the recursion when less than 

<math display="inline" id="Quicksort:13">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 elements are left, leaving the entire array 

<math display="inline" id="Quicksort:14">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-sorted: each element will be at most 

<math display="inline" id="Quicksort:15">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 positions away from its final position. Then, a single <a href="insertion_sort" title="wikilink">insertion sort</a> pass<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> finishes the sort in 

<math display="inline" id="Quicksort:16">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(kn)
  </annotation>
 </semantics>
</math>

 time. A separate insertion sort of each small segment as they are identified adds the overhead of starting and stopping many small sorts, but avoids wasting effort comparing keys across the many segment boundaries, where keys will be in order due to the workings of the quicksort process.</li>
</ul>
<h4 id="parallelization">Parallelization</h4>

<p>Quicksort's divide-and-conquer formulation makes it amenable to <a href="parallel_algorithm" title="wikilink">parallelization</a> using <a href="task_parallelism" title="wikilink">task parallelism</a>. The partitioning step is accomplished through the use of a <a href="prefix_sum" title="wikilink">parallel prefix sum</a> algorithm to compute an index for each array element in its section of the partitioned array.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> Given an array of size 

<math display="inline" id="Quicksort:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, the partitioning step performs 

<math display="inline" id="Quicksort:18">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 work in 

<math display="inline" id="Quicksort:19">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 time and requires 

<math display="inline" id="Quicksort:20">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 additional scratch space. After the array has been partitioned, the two partitions can be sorted recursively in parallel. Assuming an ideal choice of pivots, parallel quicksort sorts an array of size 

<math display="inline" id="Quicksort:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Quicksort:22">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

 work in 

<math display="inline" id="Quicksort:23">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi mathvariant="normal">²</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>normal-²</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(log²n)
  </annotation>
 </semantics>
</math>

 time using 

<math display="inline" id="Quicksort:24">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 additional space.</p>

<p>Quicksort has some disadvantages when compared to alternative sorting algorithms, like <a href="merge_sort" title="wikilink">merge sort</a>, which complicate its efficient parallelization. The depth of quicksort's divide-and-conquer tree directly impacts the algorithm's scalability, and this depth is highly dependent on the algorithm's choice of pivot. Additionally, it is difficult to parallelize the partitioning step efficiently in-place. The use of scratch space simplifies the partitioning step, but increases the algorithm's memory footprint and constant overheads.</p>

<p>Other more sophisticated parallel sorting algorithms can achieve even better time bounds.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> For example, in 1991 David Powers described a parallelized quicksort (and a related <a href="radix_sort" title="wikilink">radix sort</a>) that can operate in 

<math display="inline" id="Quicksort:25">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 time on a CRCW <a href="Parallel_Random_Access_Machine" title="wikilink">PRAM</a> with 

<math display="inline" id="Quicksort:26">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 processors by performing partitioning implicitly.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h2 id="formal-analysis">Formal analysis</h2>
<h3 id="average-case-analysis-using-discrete-probability">Average-case analysis using discrete probability</h3>

<p>To sort an array of 

<math display="inline" id="Quicksort:27">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 distinct elements, quicksort takes 

<math display="inline" id="Quicksort:28">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

 time in expectation, averaged over all 

<math display="inline" id="Quicksort:29">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <factorial></factorial>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n!
  </annotation>
 </semantics>
</math>

 permutations of 

<math display="inline" id="Quicksort:30">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements with <a href="Uniform_distribution_(discrete)" title="wikilink">equal probability</a>. Why? For a start, it is not hard to see that the partition operation takes 

<math display="inline" id="Quicksort:31">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time.</p>

<p>In the most unbalanced case, each time the partitioning is performed the list is divided into two sublists of 

<math display="inline" id="Quicksort:32">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 and 

<math display="inline" id="Quicksort:33">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

 sizes (for example, if all elements of the array are equal). This means each recursive call processes a list of size one less than the previous list. Consequently, we can make 

<math display="inline" id="Quicksort:34">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

 nested calls before we reach a list of size 1. This means that the <a href="Call_stack" title="wikilink">call tree</a> is a linear chain of 

<math display="inline" id="Quicksort:35">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

 nested calls. The 

<math display="inline" id="Quicksort:36">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

th call does 

<math display="inline" id="Quicksort:37">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi mathvariant="normal">−</mi>
     <mi>i</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>normal-−</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n−i)
  </annotation>
 </semantics>
</math>

 work to do the partition, and 

<math display="inline" id="Quicksort:38">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\sum_{i=0}^{n}(n-i)=O(n^{2})
  </annotation>
 </semantics>
</math>

, so in that case Quicksort takes 

<math display="inline" id="Quicksort:39">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi mathvariant="normal">²</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>normal-²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n²)
  </annotation>
 </semantics>
</math>

 time. That is the worst case: given knowledge of which comparisons are performed by the sort, there are adaptive algorithms that are effective at generating worst-case input for quicksort on-the-fly, regardless of the pivot selection strategy.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>In the most balanced case, each time we perform a partition we divide the list into two nearly equal pieces. This means each recursive call processes a list of half the size. Consequently, we can make only <mtpl></mtpl> nested calls before we reach a list of size 1. This means that the depth of the <a href="Call_stack" title="wikilink">call tree</a> is <mtpl></mtpl>. But no two calls at the same level of the call tree process the same part of the original list; thus, each level of calls needs only 

<math display="inline" id="Quicksort:40">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time all together (each call has some constant overhead, but since there are only 

<math display="inline" id="Quicksort:41">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 calls at each level, this is subsumed in the 

<math display="inline" id="Quicksort:42">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 factor). The result is that the algorithm uses only 

<math display="inline" id="Quicksort:43">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

 time.</p>

<p>In fact, it's not necessary to be perfectly balanced; even if each pivot splits the elements with 75% on one side and 25% on the other side (or any other fixed fraction), the call depth is still limited to 

<math display="inline" id="Quicksort:44">
 <semantics>
  <mrow>
   <msub>
    <mi>log</mi>
    <mrow>
     <mn>4</mn>
     <mo>/</mo>
     <mn>3</mn>
    </mrow>
   </msub>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{4/3}n
  </annotation>
 </semantics>
</math>

, so the total running time is still 

<math display="inline" id="Quicksort:45">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

.</p>

<p>On average, if the pivot has rank somewhere in the middle 50 percent, that is, between the 25th percentile and the 75th percentile, then it splits the elements with at least 25% and at most 75% on each side. If we could consistently choose a pivot from the two middle 50 percent, we would only have to split the list at most 

<math display="inline" id="Quicksort:46">
 <semantics>
  <mrow>
   <msub>
    <mi>log</mi>
    <mrow>
     <mn>4</mn>
     <mo>/</mo>
     <mn>3</mn>
    </mrow>
   </msub>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{4/3}n
  </annotation>
 </semantics>
</math>

 times before reaching lists of size 1, yielding an 

<math display="inline" id="Quicksort:47">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

 algorithm.</p>

<p>When the input is a random permutation, the pivot has a random rank, and so it is not guaranteed to be in the middle 50 percent. However, when we start from a random permutation, in each recursive call the pivot has a random rank in its list, and so it is in the middle 50 percent about half the time. That is good enough. Imagine that you flip a coin: heads means that the rank of the pivot is in the middle 50 percent, tail means that it isn't. Imagine that you are flipping a coin over and over until you get 

<math display="inline" id="Quicksort:48">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 heads. Although this could take a long time, on average only 

<math display="inline" id="Quicksort:49">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k
  </annotation>
 </semantics>
</math>

 flips are required, and the chance that you won't get 

<math display="inline" id="Quicksort:50">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 heads after 

<math display="inline" id="Quicksort:51">
 <semantics>
  <mrow>
   <mn>100</mn>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">100</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   100k
  </annotation>
 </semantics>
</math>

 flips is highly improbable (this can be made rigorous using Chernoff bounds). By the same argument, Quicksort's recursion will terminate on average at a call depth of only 

<math display="inline" id="Quicksort:52">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <msub>
     <mi>log</mi>
     <mrow>
      <mn>4</mn>
      <mo>/</mo>
      <mn>3</mn>
     </mrow>
    </msub>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <apply>
       <divide></divide>
       <cn type="integer">4</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\log_{4/3}n
  </annotation>
 </semantics>
</math>

. But if its average call depth is 

<math display="inline" id="Quicksort:53">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

, and each level of the call tree processes at most 

<math display="inline" id="Quicksort:54">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements, the total amount of work done on average is the product, 

<math display="inline" id="Quicksort:55">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

. Note that the algorithm does not have to verify that the pivot is in the middle half—if we hit it any constant fraction of the times, that is enough for the desired complexity.</p>
<h3 id="average-case-analysis-using-recurrences">Average-case analysis using recurrences</h3>

<p>An alternative approach is to set up a <a href="recurrence_relation" title="wikilink">recurrence relation</a> for the 

<math display="inline" id="Quicksort:56">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)
  </annotation>
 </semantics>
</math>

 factor, the time needed to sort a list of size 

<math display="inline" id="Quicksort:57">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. In the most unbalanced case, a single quicksort call involves 

<math display="inline" id="Quicksort:58">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 work plus two recursive calls on lists of size 

<math display="inline" id="Quicksort:59">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 and 

<math display="inline" id="Quicksort:60">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

, so the recurrence relation is</p>

<p>

<math display="block" id="Quicksort:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=O(n)+T(0)+T(n-1)=O(n)+T(n-1).
  </annotation>
 </semantics>
</math>

</p>

<p>This is the same relation as for <a href="insertion_sort" title="wikilink">insertion sort</a> and <a href="selection_sort" title="wikilink">selection sort</a>, and it solves to worst case 

<math display="inline" id="Quicksort:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi mathvariant="normal">²</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>normal-²</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=O(n²)
  </annotation>
 </semantics>
</math>

.</p>

<p>In the most balanced case, a single quicksort call involves 

<math display="inline" id="Quicksort:63">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 work plus two recursive calls on lists of size 

<math display="inline" id="Quicksort:64">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/2
  </annotation>
 </semantics>
</math>

, so the recurrence relation is</p>

<p>

<math display="block" id="Quicksort:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mi>T</mi>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mi>n</mi>
        <mn>2</mn>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>T</ci>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=O(n)+2T\left(\frac{n}{2}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="master_theorem" title="wikilink">master theorem</a> tells us that 

<math display="inline" id="Quicksort:66">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mi>l</mi>
      <mi>o</mi>
      <mi>g</mi>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>l</ci>
      <ci>o</ci>
      <ci>g</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=O(nlogn)
  </annotation>
 </semantics>
</math>

.</p>

<p>The outline of a formal proof of the 

<math display="inline" id="Quicksort:67">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

 expected time complexity follows. Assume that there are no duplicates as duplicates could be handled with linear time pre- and post-processing, or considered cases easier than the analyzed. When the input is a random permutation, the rank of the pivot is uniform random from 0 to 

<math display="inline" id="Quicksort:68">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

. Then the resulting parts of the partition have sizes 

<math display="inline" id="Quicksort:69">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quicksort:70">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mi>i</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <ci>i</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−i−1
  </annotation>
 </semantics>
</math>

, and i is uniform random from 0 to 

<math display="inline" id="Quicksort:71">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

. So, averaging over all possible splits and noting that the number of comparisons for the partition is 

<math display="inline" id="Quicksort:72">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

, the average number of comparisons over all permutations of the input sequence can be estimated accurately by solving the recurrence relation:</p>

<p>

<math display="block" id="Quicksort:73">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>C</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>C</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mi>i</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>C</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>C</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(n)=n-1+\frac{1}{n}\sum_{i=0}^{n-1}(C(i)+C(n-i-1))
  </annotation>
 </semantics>
</math>

</p>

<p>Solving the recurrence gives 

<math display="inline" id="Quicksort:74">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
    <mi>l</mi>
    <mi>n</mi>
    <mi>n</mi>
    <mi mathvariant="normal">≈</mi>
    <mn>1.39</mn>
    <mi>n</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>g</mi>
    <mi mathvariant="normal">₂</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
     <ci>l</ci>
     <ci>n</ci>
     <ci>n</ci>
     <ci>normal-≈</ci>
     <cn type="float">1.39</cn>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>normal-₂</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(n)=2nlnn≈1.39nlog₂n
  </annotation>
 </semantics>
</math>

.</p>

<p>This means that, on average, quicksort performs only about 39% worse than in its best case. In this sense it is closer to the best case than the worst case. Also note that a <a href="comparison_sort" title="wikilink">comparison sort</a> cannot use less than 

<math display="inline" id="Quicksort:75">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mi mathvariant="normal">₂</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>normal-₂</ci>
    <apply>
     <factorial></factorial>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   log₂(n!)
  </annotation>
 </semantics>
</math>

 comparisons on average to sort 

<math display="inline" id="Quicksort:76">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 items (as <a href="Comparison_sort#Lower_bound_for_the_average_number_of_comparisons" title="wikilink">explained in the article Comparison sort</a>) and in case of large 

<math display="inline" id="Quicksort:77">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, <a href="Stirling's_approximation" title="wikilink">Stirling's approximation</a> yields 

<math display="inline" id="Quicksort:78">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mi mathvariant="normal">₂</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">≈</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi mathvariant="normal">₂</mi>
     <mi>n</mi>
     <mi mathvariant="normal">−</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi mathvariant="normal">₂</mi>
     <mi>e</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>normal-₂</ci>
    <apply>
     <factorial></factorial>
     <ci>n</ci>
    </apply>
    <ci>normal-≈</ci>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>normal-₂</ci>
     <ci>n</ci>
     <ci>normal-−</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>normal-₂</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   log₂(n!)≈n(log₂n−log₂e)
  </annotation>
 </semantics>
</math>

, so quicksort is not much worse than an ideal comparison sort. This fast average runtime is another reason for quicksort's practical dominance over other sorting algorithms.</p>
<h3 id="analysis-of-randomized-quicksort">Analysis of randomized quicksort</h3>

<p>Using the same analysis, one can show that randomized quicksort has the desirable property that, for any input, it requires only 

<math display="inline" id="Quicksort:79">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

 <a href="expected_value" title="wikilink">expected</a> time (averaged over all choices of pivots). However, there also exists a combinatorial proof.</p>

<p>To each execution of quicksort corresponds the following <a href="binary_search_tree" title="wikilink">binary search tree</a> (BST): the initial pivot is the root node; the pivot of the left half is the root of the left subtree, the pivot of the right half is the root of the right subtree, and so on. The number of comparisons of the execution of quicksort equals the number of comparisons during the construction of the BST by a sequence of insertions. So, the average number of comparisons for randomized quicksort equals the average cost of constructing a BST when the values inserted 

<math display="inline" id="Quicksort:80">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},x_{2},...,x_{n})
  </annotation>
 </semantics>
</math>

 form a random permutation.</p>

<p>Consider a BST created by insertion of a sequence 

<math display="inline" id="Quicksort:81">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},x_{2},...,x_{n})
  </annotation>
 </semantics>
</math>

 of values forming a random permutation. Let 

<math display="inline" id="Quicksort:82">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 denote the cost of creation of the BST. We have 

<math display="inline" id="Quicksort:83">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is an binary random variable expressing whether during the insertion of 

<math display="inline" id="Quicksort:84">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 there was a comparison to 

<math display="inline" id="Quicksort:85">
 <semantics>
  <mrow>
   <mi>𝔼</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>C</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔼</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[C]
  </annotation>
 </semantics>
</math>

.</p>

<p>By <a href="Expected_value#Linearity" title="wikilink">linearity of expectation</a>, the expected value 

<math display="inline" id="Quicksort:86">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Quicksort:87">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Quicksort:88">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo><</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>j</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j<i
  </annotation>
 </semantics>
</math>

, once sorted, define 

<math display="inline" id="Quicksort:91">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 intervals. The core structural observation is that 

<math display="inline" id="Quicksort:92">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is compared to 

<math display="inline" id="Quicksort:93">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 in the algorithm if and only if 

<math display="inline" id="Quicksort:94">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},x_{2},...,x_{n})
  </annotation>
 </semantics>
</math>

 falls inside one of the two intervals adjacent to 

<math display="inline" id="Quicksort:95">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},x_{2},...,x_{j},x_{i})
  </annotation>
 </semantics>
</math>

.</p>

<p>Observe that since 

<math display="inline" id="Quicksort:96">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is a random permutation, 

<math display="inline" id="Quicksort:97">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 is also a random permutation, so the probability that 

<math display="inline" id="Quicksort:98">
 <semantics>
  <mfrac>
   <mn>2</mn>
   <mrow>
    <mi>j</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">2</cn>
    <apply>
     <plus></plus>
     <ci>j</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{2}{j+1}
  </annotation>
 </semantics>
</math>

 is adjacent to 

<math display="inline" id="Quicksort:99">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 is exactly 

<math display="inline" id="Quicksort:100">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

.</p>

<p>We end with a short calculation: 

<math display="inline" id="Quicksort:101">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 comparisons (close to the information theoretic lower bound) and <span class="LaTeX">${\Theta}(n\log n)$</span> operations; at worst they perform <span class="LaTeX">${\Theta}(n\log^2 n)$</span> comparisons (and also operations); these are in-place, requiring only additional <span class="LaTeX">${O}(\log n)$</span> space. Practical efficiency and smaller variance in performance were demonstrated against optimised quicksorts (of <a href="Robert_Sedgewick_(computer_scientist)" title="wikilink">Sedgewick</a> and <a href="Jon_Bentley" title="wikilink">Bentley</a>-<a href="Douglas_McIlroy" title="wikilink">McIlroy</a>).<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Introsort" title="wikilink">Introsort</a></li>
<li><a class="uri" href="Flashsort" title="wikilink">Flashsort</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(Reprinted in Hoare and Jones: <a href="http://portal.acm.org/citation.cfm?id=SERIES11430.63445"><em>Essays in computing science</em></a>, 1989.)</p></li>
<li></li>
<li><a href="Donald_Knuth" title="wikilink">Donald Knuth</a>. <em>The Art of Computer Programming</em>, Volume 3: <em>Sorting and Searching</em>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Pages 113–122 of section 5.2.2: Sorting by Exchanging.</li>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. <a href="MIT_Press" title="wikilink">MIT Press</a> and <a class="uri" href="McGraw-Hill" title="wikilink">McGraw-Hill</a>, 2001. ISBN 0-262-03293-7. Chapter 7: Quicksort, pp. 145–164.</li>
<li>A. LaMarca and R. E. Ladner. "The Influence of Caches on the Performance of Sorting." Proceedings of the Eighth Annual ACM-SIAM Symposium on Discrete Algorithms, 1997. pp. 370–379.</li>
<li><a href="Faron_Moller" title="wikilink">Faron Moller</a>. <a href="http://www.cs.swan.ac.uk/~csfm/Courses/CS_332/quicksort.pdf">Analysis of Quicksort</a>. CS 332: Designing Algorithms. Department of Computer Science, <a href="Swansea_University" title="wikilink">Swansea University</a>.</li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.sorting-algorithms.com/quick-sort">Animated Sorting Algorithms: Quick Sort</a> – graphical demonstration and discussion of quick sort</li>
<li><a href="http://opendatastructures.org/versions/edition-0.1e/ods-java/11_1_Comparison_Based_Sorti.html#SECTION001412000000000000000">Open Data Structures - Section 11.1.2 - Quicksort</a></li>
<li><a href="http://en.literateprograms.org/Category:Quicksort">Literate implementations of Quicksort in various languages</a> on LiteratePrograms</li>
</ul>

<p><a href="no:Sorteringsalgoritme#Quick_sort" title="wikilink">no:Sorteringsalgoritme#Quick sort</a>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a> <a href="Category:Comparison_sorts" title="wikilink">Category:Comparison sorts</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:1961_in_science" title="wikilink">Category:1961 in science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25">qsort.c in <a href="GNU_libc" title="wikilink">GNU libc</a>: <a href="http://www.cs.columbia.edu/~hgs/teaching/isp/hw/qsort.c">1</a>, <a href="http://repo.or.cz/w/glibc.git/blob/HEAD:/stdlib/qsort.c">2</a><a href="#fnref25">↩</a></li>
<li id="fn26"><a class="uri" href="http://www.ugrad.cs.ubc.ca/~cs260/chnotes/ch6/Ch6CovCompiled.html">http://www.ugrad.cs.ubc.ca/~cs260/chnotes/ch6/Ch6CovCompiled.html</a><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28">Umut A. Acar, Guy E Blelloch, Margaret Reid-Miller, and Kanat Tangwongsan, <a href="http://www.cs.cmu.edu/afs/cs/academic/class/15210-s13/www/lectures/lecture19.pdf">Quicksort and Sorting Lower Bounds</a>, <em>Parallel and Sequential Data Structures and Algorithms</em>. 2013.<a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33">Richard Cole, David C. Kandathil: <a href="http://www.cs.nyu.edu/cole/papers/part-sort.pdf">"The average case analysis of Partition sorts"</a>, European Symposium on Algorithms, 14–17 September 2004, Bergen, Norway. Published: Lecture Notes in Computer Science 3221, Springer Verlag, pp. 240-251.<a href="#fnref33">↩</a></li>
</ol>
</section>
</body>

