<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="319">Operational transformation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Operational transformation</h1>
<hr/>

<p><strong>Operational transformation</strong> (OT) is a technology for supporting a range of collaboration functionalities in advanced <a href="collaborative_software" title="wikilink">collaborative software</a> systems. OT was originally invented for consistency maintenance and <a href="concurrency_control" title="wikilink">concurrency control</a> in collaborative editing of plain text documents. Two decades of research has extended its capabilities and expanded its applications to include group undo, locking, conflict resolution, operation notification and compression, group-awareness, HTML/XML and tree-structured document editing, collaborative office productivity tools, application-sharing, and collaborative computer-aided media design tools (see <a href="http://www3.ntu.edu.sg/home/czsun/projects/otfaq/">OTFAQ</a>). In 2009 OT was adopted as a core technique behind the collaboration features in <a href="Apache_Wave" title="wikilink">Apache Wave</a> and <a href="Google_Docs" title="wikilink">Google Docs</a>.</p>
<h2 id="history">History</h2>

<p>Operational Transformation was pioneered by <a href="Clarence_Ellis_(computer_scientist)" title="wikilink">C. Ellis</a> and S. Gibbs<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in the GROVE (GRoup Outline Viewing Edit) system in 1989. Several years later, some correctness issues were identified and several approaches<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> were independently proposed to solve these issues, which was followed by another decade of continuous efforts of extending and improving OT by a community of dedicated researchers. In 1998, a Special Interest Group on Collaborative Editing (<a href="http://cooffice.ntu.edu.sg/sigce/">SIGCE</a>) was set up to promote communication and collaboration among CE and OT researchers. Since then, SIGCE holds annual CE workshops in conjunction with major CSCW (<a href="Computer_Supported_Cooperative_Work" title="wikilink">Computer Supported Cooperative Work</a>) conferences, such as ACM CSCW, GROUP and ECSCW.</p>
<h2 id="system-architecture">System architecture</h2>

<p>Collaborative systems using OT typically adopt a replicated architecture for the storage of shared documents to ensure good responsiveness in high latency environments, such as the Internet. The shared documents are replicated at the local storage of each collaborating site, so editing operations can be performed at local sites immediately and then propagated to remote sites. Remote editing operations arriving at a local site are typically transformed and then executed. The transformation ensures that application-dependent consistency criteria are achieved across all sites. The lock-free, nonblocking property of OT makes the local response time not sensitive to networking latencies. As a result, OT is particularly suitable for implementing collaboration features such as group editing in the Web/Internet context.</p>
<h2 id="basics">Basics</h2>

<p> The basic idea of OT can be illustrated by using a simple text editing scenario as follows. Given a text document with a string "abc" replicated at two collaborating sites; and two concurrent operations:</p>
<ol>
<li>O1 = Insert[0, "x"] (to insert character "x" at position "0")</li>
<li>O2 = Delete[2, "c"] (to delete the character "c" at position "2")</li>
</ol>

<p>generated by two users at collaborating sites 1 and 2, respectively. Suppose the two operations are executed in the order of O1 and O2 (at site 1). After executing O1, the document becomes "xabc". To execute O2 after O1, O2 must be transformed against O1 to become: O2' = Delete[3, "c"], whose positional parameter is incremented by one due to the insertion of one character "x" by O1. Executing O2' on "xabc" deletes the correct character "c" and the document becomes "xab". However, if O2 is executed without transformation, it incorrectly deletes character "b" rather than "c". The basic idea of OT is to transform (or adjust) the parameters of an editing operation according to the effects of previously executed concurrent operations so that the transformed operation can achieve the correct effect and maintain document consistency.</p>
<h2 id="consistency-models">Consistency models</h2>

<p>One functionality of OT is to support consistency maintenance in collaborative editing systems. A number of consistency models have been proposed in the research community, some generally for collaborative editing systems, and some specifically for OT algorithms.</p>
<h3 id="the-cc-model">The CC model</h3>

<p>In Ellis and Gibbs 1989 paper "Concurrency control in groupware systems",<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> two consistency properties are required for collaborative editing systems:</p>
<ul>
<li>Precedence (<strong>C</strong>ausality) property: ensures the execution order of causally dependent operations be the same as their natural cause-effect order during the process of collaboration. The causal relationship between two operations is defined formally by Lamport's "<a class="uri" href="happened-before" title="wikilink">happened-before</a>" relation. When two operations are not causally dependent, they are concurrent. Two concurrent operations can be executed in different order on two different document copies.</li>
<li><strong>C</strong>onvergence: ensures the replicated copies of the shared document be identical at all sites at quiescence (i.e., all generated operations have been executed at all sites).</li>
</ul>

<p>Since concurrent operations may be executed in different orders and editing operations are not commutative in general, copies of the document at different sites may diverge (inconsistent). The first OT algorithm was proposed in Ellis and Gibbs's paper<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> to achieve convergence in a group text editor; the state-vector (or <a href="vector_clock" title="wikilink">vector clock</a> in classic distributed computing) was used to preserve the precedence property.</p>
<h3 id="the-cci-model">The CCI model</h3>

<p>The CCI model was proposed as a genonsistency management in collaborative editing systems.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Under the CCI model, three consistency properties are grouped together:</p>
<ul>
<li><strong>C</strong>ausality Preservation : the same as the precedence property in the CC Model.</li>
<li><strong>C</strong>onvergence: the same as the convergence property in the CC Model.</li>
<li><strong>I</strong>ntention Preservation: ensures that the effect of executing an operation on any document state be the same as the intention of the operation. The intention of an operation O is defined as the execution effect which can be achieved by applying O on the document state from which O was generated.</li>
</ul>

<p>The CCI model extends the CC model with a new criterion: Intention Preservation. The essential difference between convergence and intention preservation is that the former can always be achieved by a serialization protocol, but the latter may not be achieved by any serialization protocol if operations were always executed in their original forms. Achieving the nonserialisable intention preservation property has been a major technical challenge. OT has been found particularly suitable for achieving convergence and intention preservation in collaborative editing systems.</p>

<p>The CCI model is independent of document types or data models, operation types, or supporting techniques (OT, multi-versioning, serialization, undo/redo). It was not intended for correctness verification for techniques (e.g. OT) that are designed for specific data and operation models and for specific applications. In,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> the notion of intention preservation was defined and refined at three levels: First, it was defined as a generic consistency requirement for collaborative editing systems; Second, it was defined as operation context-based pre- and post- transformation conditions for generic OT functions; Third, it was defined as specific operation verification criteria to guide the design of OT functions for two primitive operations: string-wise insert and delete, in collaborative plain text editors.</p>
<h3 id="the-csm-model">The CSM model</h3>

<p>The condition of intention preservation was not formally specified in the CCI model for purposes of formal proofs. The SDT<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and LBT<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> approaches try to formalize an alternative conditions that can be proved. The consistency model proposed in these two approaches consist of the following formal conditions:</p>
<ul>
<li><em><strong>C</strong>ausality</em>: the same definition as in CC Model</li>
</ul>
<ul>
<li><em><strong>S</strong>ingle-operation effects</em>: the effect of executing any operation in any execution state achieves the same effect as in its generation state</li>
</ul>
<ul>
<li><em><strong>M</strong>ulti-operation effects</em>: the effects relation of any two operations is maintained after they are both executed in any states</li>
</ul>
<h3 id="the-ca-model">The CA model</h3>

<p>The above CSM model requires that a total order of all objects in the system be specified. Effectively, the specification is reduced to new objects introduced by insert operations. However, specification of the total order entails application-specific policies such as those to break insertion ties (i.e., new objects inserted by two current operations at the same position). Consequently, the total order becomes application specific. Moreover, in the algorithm, the total order must be maintained in the transformation functions and control procedure, which increases time/space complexities of the algorithm.</p>

<p>Alternatively, the <strong>CA</strong> model is based on the <strong>Admissibility Theory</strong>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The CA model includes two aspects:</p>
<ul>
<li><em><strong>C</strong>ausality</em>: the same definition as in CC Model</li>
<li><em><strong>A</strong>dmissibility</em>: The invocation of every operation is admissible in its execution state, i.e., every invocation must not violate any effects relation (object ordering) that has been established by earlier invocations.</li>
</ul>

<p>These two conditions imply convergence. All cooperating sites converge in a state in which there is a same set of objects that are in the same order. Moreover, the ordering is effectively determined by the effects of the operations when they are generated. Since the two conditions also impose additional constraints on object ordering, they are actually stronger than convergence. The CA model and the design/prove approach are elaborated in the 2005 paper.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> It no longer requires that a total order of objects be specified in the consistency model and maintained in the algorithm, which hence results in reduced time/space complexities in the algorithm.</p>
<h2 id="ot-system-structure">OT system structure</h2>

<p>OT is a system of multiple components. One established strategy of designing OT systems<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> is to separate the high-level Transformation Control (or Integration) Algorithms from the low-level Transformation Functions. The transformation control algorithm is concerned with determining:</p>
<ol>
<li>Which operation should be transformed against a causally ready new operation</li>
<li>The order of the transformations</li>
</ol>

<p>The control algorithm invokes a corresponding set of transformation functions, which determine how to transform one operation against another according to the operation types, positions, and other parameters. The correctness responsibilities of these two layers are formally specified by a set of transformation properties and conditions. Different OT systems with different control algorithms, functions, and communication topologies require maintaining different sets of transformation properties. The separation of an OT system into these two layers allows for the design of generic control algorithms that are applicable to different kinds of application with different data and operation models.</p>

<p>The other alternative approach was proposed in.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> In their approach, an OT algorithm is correct if it satisfies two formalized correctness criteria:</p>
<ol>
<li>Causality preservation</li>
<li>Admissibility preservation</li>
</ol>

<p>As long as these two criteria are satisfied, the data replicas converge (with additional constraints) after all operations are executed at all sites. There is no need to enforce a total order of execution for the sake of achieving convergence. Their approach is generally to first identify and prove sufficient conditions for a few transformation functions, and then design a control procedure to ensure those sufficient conditions. This way the control procedure and transformation functions work synergistically to achieve correctness, i.e., causality and admissibility preservation. In their approach, there is no need to satisfy transformation properties such as TP2 because it does not require that the (inclusive) transformation functions work in all possible cases.</p>
<h2 id="ot-data-and-operation-models">OT data and operation models</h2>

<p>There exist two underlying models in each OT system: the data model that defines the way data objects in a document are addressed by operations, and the operation model that defines the set of operations that can be directly transformed by OT functions. Different OT systems may have different data and operation models. For example, the data model of the first OT system<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> is a single linear address space; and its operation model consists of two primitive operations: character-wise insert and delete. The basic operation model has been extended to include a third primitive operation update to support collaborative Word document processing<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> and 3D model editing.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> The basic OT data model has been extended into a hierarchy of multiple linear addressing domains,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> which is capable of modeling a broad range of documents. A data adaption process is often required to map application-specific data models to an OT-compliant data model.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>

<p>There exist two approaches to supporting application level operations in an OT system:</p>
<ol>
<li>Generic operation model approach: which is to devise transformation functions for three primitive operations: insert, delete, and update.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> This approach needs an operation adaptation process to map application operations to these primitive operations. In this approach, the OT operation model is generic, so transformation functions can be reused for different applications.</li>
<li>Application-specific operation model approach: which is to devise transformation functions for each pair of application operations.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> For an application with m different operations, m x m transformation functions are needed for supporting this application. In this approach, transformation functions are application-specific and cannot be reused in different applications.</li>
</ol>
<h2 id="ot-functions">OT functions</h2>

<p>Various OT functions have been designed for OT systems with different capabilities and used for different applications. OT functions used in different OT systems may be named differently, but they can be classified into two categories:</p>
<ul>
<li>one is Inclusion Transformation (or Forward Transformation): IT(Oa, Ob) or 

<math display="inline" id="Operational_transformation:0">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(op_{1},op_{2})
  </annotation>
 </semantics>
</math>

, which transforms operation Oa against another operation Ob in such a way that the impact of Ob is effectively included; and</li>
<li>the other is Exclusion Transformation (or Backward Transformation): ET (Oa, Ob) or 

<math display="inline" id="Operational_transformation:1">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{-1}(op_{1},op_{2})
  </annotation>
 </semantics>
</math>

, which transforms operation Oa against another operation Ob in such a way that the impact of Ob is effectively excluded.</li>
</ul>

<p>For example, suppose a type String with an operation ins(p, c,sid) where p is the position of insertion, c the character to insert and sid the identifier of the site that has generated the operation. We can write the following transformation function:</p>

<p><code>T(ins(</code>

<math display="inline" id="Operational_transformation:2">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},c_{1},sid_{1}
  </annotation>
 </semantics>
</math>

<code>),ins(</code>

<math display="inline" id="Operational_transformation:3">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{2},c_{2},sid_{2}
  </annotation>
 </semantics>
</math>

<code>)) :-</code><br/>
<code>  if (</code>

<math display="inline" id="Operational_transformation:4">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}<p_{2}
  </annotation>
 </semantics>
</math>

<code>) return ins(</code>

<math display="inline" id="Operational_transformation:5">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},c_{1},sid_{1}
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>  else if (</code>

<math display="inline" id="Operational_transformation:6">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}=p_{2}
  </annotation>
 </semantics>
</math>

<code> and </code>

<math display="inline" id="Operational_transformation:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sid_{1}<sid_{2}
  </annotation>
 </semantics>
</math>

<code>) return ins(</code>

<math display="inline" id="Operational_transformation:8">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},c_{1},sid_{1}
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>  else return ins(</code>

<math display="inline" id="Operational_transformation:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}+1,c_{1},sid_{1}
  </annotation>
 </semantics>
</math>

<code>)</code></p>

<p>

<math display="inline" id="Operational_transformation:10">
 <semantics>
  <msup>
   <mi>T</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>T</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{-1}
  </annotation>
 </semantics>
</math>

<code>(ins(</code>

<math display="inline" id="Operational_transformation:11">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},c_{1},sid_{1}
  </annotation>
 </semantics>
</math>

<code>),ins(</code>

<math display="inline" id="Operational_transformation:12">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{2},c_{2},sid_{2}
  </annotation>
 </semantics>
</math>

<code>)) :-</code><br/>
<code>  if (</code>

<math display="inline" id="Operational_transformation:13">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}<p_{2}
  </annotation>
 </semantics>
</math>

<code>) return ins(</code>

<math display="inline" id="Operational_transformation:14">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},c_{1},sid_{1}
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>  else if (</code>

<math display="inline" id="Operational_transformation:15">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}=p_{2}
  </annotation>
 </semantics>
</math>

<code> and </code>

<math display="inline" id="Operational_transformation:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sid_{1}<sid_{2}
  </annotation>
 </semantics>
</math>

<code>) return ins(</code>

<math display="inline" id="Operational_transformation:17">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},c_{1},sid_{1}
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>  else return ins(</code>

<math display="inline" id="Operational_transformation:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}-1,c_{1},sid_{1}
  </annotation>
 </semantics>
</math>

<code>)</code></p>

<p>Some OT systems use both IT and ET functions, and some use only IT functions. The complexity of OT function design is determined by various factors:</p>
<ul>
<li>the functionality of the OT system: whether the OT system supports do (consistency maintenance), undo, locking,<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> awareness, application sharing,<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><ref name="begoletochi1999"></ref></li>
</ul>

<p><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> etc.;</p>
<ul>
<li>the correctness responsibility in the OT system: what transformation properties (CP1/TP1, CP2/TP2, IP2, IP3, RP) to meet; whether ET is used;</li>
<li>the operation model of the OT system: whether the OT operation model is generic (e.g. primitive insert, delete, update), or application-specific (all operations of the target application); and</li>
<li>the data model of the OT system: whether the data in each operation is character-wise (an individual object), string-wise (a sequence of objects), hierarchical, or other structures.</li>
</ul>
<h2 id="transformation-properties">Transformation properties</h2>

<p>Various transformation properties for ensuring OT system correctness have been identified. These properties can be maintained by either the transformation control algorithm<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a><a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> or by the transformation functions.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> Different OT system designs have different division of responsibilities among these components. The specifications of these properties and preconditions of requiring them are given below.</p>
<h3 id="convergence-properties">Convergence properties</h3>

<p>  The following two properties are related to achieving convergence.</p>
<ul>
<li><strong>CP1/TP1</strong>: For every pair of concurrent operations 

<math display="inline" id="Operational_transformation:19">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Operational_transformation:20">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{2}
  </annotation>
 </semantics>
</math>

 defined on the same state, the transformation function T satisfies CP1/TP1 property if and only if

<math display="block" id="Operational_transformation:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>∘</mo>
     <mi>T</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>∘</mo>
     <mi>T</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{1}\circ T(op_{2},op_{1})\equiv op_{2}\circ T(op_{1},op_{2})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Operational_transformation:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>∘</mo>
    <mi>o</mi>
   </mrow>
   <msub>
    <mi>p</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>o</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{i}\circ op_{j}
  </annotation>
 </semantics>
</math>

 denotes the sequence of operations containing 

<math display="inline" id="Operational_transformation:23">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{i}
  </annotation>
 </semantics>
</math>

 followed by 

<math display="inline" id="Operational_transformation:24">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{j}
  </annotation>
 </semantics>
</math>

;and where 

<math display="inline" id="Operational_transformation:25">
 <semantics>
  <mo>≡</mo>
  <annotation-xml encoding="MathML-Content">
   <equivalent></equivalent>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv
  </annotation>
 </semantics>
</math>

 denotes equivalence of the two sequences of operations. <strong>CP1/TP1 Precondition</strong>: CP1/TP1 is required only if the OT system allows any two operations to be executed in different orders.</li>
<li><strong>CP2/TP2</strong>: For every three concurrent operations 

<math display="inline" id="Operational_transformation:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>o</mi>
    <msub>
     <mi>p</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{1},op_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Operational_transformation:27">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{3}
  </annotation>
 </semantics>
</math>

 defined on the same document state, the transformation function T satisfies CP2/TP2 property if and only if

<math display="block" id="Operational_transformation:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>3</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>o</mi>
        <msub>
         <mi>p</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>∘</mo>
       <mi>T</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>o</mi>
        <msub>
         <mi>p</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>o</mi>
        <msub>
         <mi>p</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>3</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>o</mi>
        <msub>
         <mi>p</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo>∘</mo>
       <mi>T</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>o</mi>
        <msub>
         <mi>p</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>o</mi>
        <msub>
         <mi>p</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <compose></compose>
        <apply>
         <times></times>
         <ci>o</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>T</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>o</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>o</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <compose></compose>
        <apply>
         <times></times>
         <ci>o</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>T</ci>
       </apply>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>o</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>o</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(op_{3},op_{1}\circ T(op_{2},op_{1}))=T(op_{3},op_{2}\circ T(op_{1},op_{2}))
  </annotation>
 </semantics>
</math>

. CP2/TP2 stipulates equality between two operations transformed with regard to two equivalent sequences of operations: the transformation of 

<math display="inline" id="Operational_transformation:29">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{3}
  </annotation>
 </semantics>
</math>

 against the sequence of operation 

<math display="inline" id="Operational_transformation:30">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{2}
  </annotation>
 </semantics>
</math>

 followed by 

<math display="inline" id="Operational_transformation:31">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(op_{1},op_{2})
  </annotation>
 </semantics>
</math>

 must give the same operation as the transformation of 

<math display="inline" id="Operational_transformation:32">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{3}
  </annotation>
 </semantics>
</math>

 against the sequence formed by 

<math display="inline" id="Operational_transformation:33">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Operational_transformation:34">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(op_{2},op_{1})
  </annotation>
 </semantics>
</math>

. <strong>CP2/TP2 Precondition</strong>: CP2/TP2 is required only if the OT systems allows two operations 

<math display="inline" id="Operational_transformation:35">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Operational_transformation:36">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{2}
  </annotation>
 </semantics>
</math>

 be IT-transformed in two different document states (or contexts).</li>
</ul>
<h3 id="inverse-properties">Inverse properties</h3>

<p>The following three properties are related to achieving the desired group undo effect. They are:</p>
<ul>
<li><strong>IP1</strong>: Given any document state S and the sequence 

<math display="inline" id="Operational_transformation:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
   </mrow>
   <mo>∘</mo>
   <mover accent="true">
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op\circ\overline{op}
  </annotation>
 </semantics>
</math>

, we have 

<math display="inline" id="Operational_transformation:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mo>∘</mo>
      <mi>o</mi>
     </mrow>
     <mi>p</mi>
    </mrow>
    <mo>∘</mo>
    <mover accent="true">
     <mrow>
      <mi>o</mi>
      <mi>p</mi>
     </mrow>
     <mo>¯</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <apply>
       <compose></compose>
       <ci>S</ci>
       <ci>o</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\circ op\circ\overline{op}=S
  </annotation>
 </semantics>
</math>

, which means the sequence 

<math display="inline" id="Operational_transformation:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
   </mrow>
   <mo>∘</mo>
   <mover accent="true">
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op\circ\overline{op}
  </annotation>
 </semantics>
</math>

 is equivalent to a single identity operation I with respect to the effect on the document state. This property is required in an OT system for achieving the correct undo effect, but is not related to IT functions.</li>
<li><strong>IP2</strong>: The property IP2 expresses that the sequence 

<math display="inline" id="Operational_transformation:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
   </mrow>
   <mo>∘</mo>
   <mover accent="true">
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op\circ\overline{op}
  </annotation>
 </semantics>
</math>

 has no effect on the transformation of other operations. The transformation functions satisfy IP2 if and only if

<math display="block" id="Operational_transformation:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mi>x</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>o</mi>
       <mi>p</mi>
      </mrow>
      <mo>∘</mo>
      <mover accent="true">
       <mrow>
        <mi>o</mi>
        <mi>p</mi>
       </mrow>
       <mo>¯</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>o</mi>
    <msub>
     <mi>p</mi>
     <mi>x</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <compose></compose>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(op_{x},op\circ\overline{op})=op_{x}
  </annotation>
 </semantics>
</math>

, which means that the outcome of transforming 

<math display="inline" id="Operational_transformation:42">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{x}
  </annotation>
 </semantics>
</math>

 against the sequence 

<math display="inline" id="Operational_transformation:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
   </mrow>
   <mo>∘</mo>
   <mover accent="true">
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op\circ\overline{op}
  </annotation>
 </semantics>
</math>

 is equivalent to the outcome of transforming 

<math display="inline" id="Operational_transformation:44">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{x}
  </annotation>
 </semantics>
</math>

 against the identity operation I. <strong>IP2-Precondition</strong>: IP2 is required only if the OT systems allows an operation 

<math display="inline" id="Operational_transformation:45">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{x}
  </annotation>
 </semantics>
</math>

 to be transformed against a pair of do and undo operations 

<math display="inline" id="Operational_transformation:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
   </mrow>
   <mo>∘</mo>
   <mover accent="true">
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op\circ\overline{op}
  </annotation>
 </semantics>
</math>

, one-by-one.</li>
<li><strong>IP3</strong>: Given two concurrent operations 

<math display="inline" id="Operational_transformation:47">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Operational_transformation:48">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{2}
  </annotation>
 </semantics>
</math>

 defined on the same document state (or context), if 

<math display="inline" id="Operational_transformation:49">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>¯</mo>
    </mover>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mrow>
       <mi>o</mi>
       <msub>
        <mi>p</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>¯</mo>
     </mover>
     <mo>,</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>o</mi>
        <msub>
         <mi>p</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>o</mi>
        <msub>
         <mi>p</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>o</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>o</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{op_{1}}^{\prime}=T(\overline{op_{1}},T(op_{2},op_{1}))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Operational_transformation:50">
 <semantics>
  <mrow>
   <mover accent="true">
    <mrow>
     <mi>o</mi>
     <msubsup>
      <mi>p</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
    </mrow>
    <mo>¯</mo>
   </mover>
   <mo>=</mo>
   <mover accent="true">
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>o</mi>
       <msub>
        <mi>p</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>o</mi>
       <msub>
        <mi>p</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>T</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>o</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>o</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{op_{1}^{\prime}}=\overline{T(op_{1},op_{2})}
  </annotation>
 </semantics>
</math>

. The transformation functions satisfy the property IP3 if and only if 

<math display="inline" id="Operational_transformation:51">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mrow>
      <mi>o</mi>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>¯</mo>
    </mover>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mover accent="true">
    <mrow>
     <mi>o</mi>
     <msubsup>
      <mi>p</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{op_{1}}^{\prime}=\overline{op_{1}^{\prime}}
  </annotation>
 </semantics>
</math>

, which means that the transformed inverse operation 

<math display="inline" id="Operational_transformation:52">
 <semantics>
  <msup>
   <mover accent="true">
    <mrow>
     <mi>o</mi>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>¯</mo>
   </mover>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{op_{1}}^{\prime}
  </annotation>
 </semantics>
</math>

 is equal to the inverse of the transformed operation 

<math display="inline" id="Operational_transformation:53">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>o</mi>
    <msubsup>
     <mi>p</mi>
     <mn>1</mn>
     <mo>′</mo>
    </msubsup>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{op_{1}^{\prime}}
  </annotation>
 </semantics>
</math>

. <strong>IP3-Precondition</strong>: IP3 is required only if the OT system allows an inverse operation 

<math display="inline" id="Operational_transformation:54">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>o</mi>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{op_{1}}
  </annotation>
 </semantics>
</math>

 to be transformed against an operation 

<math display="inline" id="Operational_transformation:55">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{2}
  </annotation>
 </semantics>
</math>

 that is concurrent and defined on the same document state as (or context-equivalent to) 

<math display="inline" id="Operational_transformation:56">
 <semantics>
  <mrow>
   <mi>o</mi>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op_{1}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="ot-control-integration-algorithms">OT control (integration) algorithms</h2>

<p>Various OT control algorithms have been designed for OT systems with different capabilities and for different applications. The complexity of OT control algorithm design is determined by multiple factors. A key differentiating factor is whether an algorithm is capable of supporting concurrency control (do) and/or group undo.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a><a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a><a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a><a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a><a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> In addition, different OT control algorithm designs make different tradeoffs in:</p>
<ul>
<li>assigning correctness responsibilities among the control algorithm and transformation functions, and</li>
<li>time-space complexity of the OT system.</li>
</ul>

<p>Most existing OT control algorithms for concurrency control adopts the theory of causality/concurrency as the theoretical basis: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution. However, it was well known that concurrency condition alone cannot capture all OT transformation conditions.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a><a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a><a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a><a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a><a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> In a recent work, the theory of operation context has been proposed to explicitly represent the notion of a document state, which can be used to formally express OT transformation conditions for supporting the design and verification of OT control algorithms.<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></p>

<p>The following table gives an overview of some existing OT control/integration algorithms</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>OT Control/Integration Algorithms(Systems)</p></th>
<th style="text-align: left;">
<p>Required Transformation Function Types</p></th>
<th style="text-align: left;">
<p>Support OT-based Do?</p></th>
<th style="text-align: left;">
<p>Support OT-based Undo?</p></th>
<th style="text-align: left;">
<p>Transformation Properties Supported By Control Algorithm</p></th>
<th style="text-align: left;">
<p>Transformation Properties Supported By Transformation Functions</p></th>
<th style="text-align: left;">
<p>Transformation Ordering and Propagation Constraints</p></th>
<th style="text-align: left;">
<p>Timestamp</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>dOPT<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> (GROVE)</p></td>
<td style="text-align: left;">
<p>T (IT)</p></td>
<td style="text-align: left;">
<p>Yes</p></td>
<td style="text-align: left;">
<p>No</p></td>
<td style="text-align: left;">
<p>None</p></td>
<td style="text-align: left;">
<p>CP1/TP1, CP2/TP2</p></td>
<td style="text-align: left;">
<p>Causal order</p></td>
<td style="text-align: left;">
<p>State vector</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>selective-undo<ref name="prakashtochi1994">{{cite journal</ref></p></td>
<td style="text-align: left;">
<p>author = Prakash, Atul and Knister, Michael J.</p></td>
<td style="text-align: left;">
<p>title = A framework for undoing actions in collaborative systems</p></td>
<td style="text-align: left;">
<p>journal = ACM Trans. Comput.-Hum. Interact.</p></td>
<td style="text-align: left;">
<p>volume = 1</p></td>
<td style="text-align: left;">
<p>year = 1994</p></td>
<td style="text-align: left;">
<p>pages = 295–330</p></td>
<td style="text-align: left;">
<p>doi = 10.1145/198425.198427</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>adOPTed<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a><ref name="resselgroup1999">{{cite conference</ref></p></td>
<td style="text-align: left;">
<p>author = M. Ressel and R. Gunzenhauser</p></td>
<td style="text-align: left;">
<p>title = Reducing the Problems of Group Undo</p></td>
<td style="text-align: left;">
<p>booktitle = Proc. of the ACM Conf. on Supporting Group Work</p></td>
<td style="text-align: left;">
<p>pages = 131–139</p></td>
<td style="text-align: left;">
<p>year = 1999 }} (JOINT EMACS)</p></td>
<td style="text-align: left;">
<p>LTransformation (IT)</p></td>
<td style="text-align: left;">
<p>Yes</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Jupiter<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a></p></td>
<td style="text-align: left;">
<p>xform (IT)</p></td>
<td style="text-align: left;">
<p>Yes</p></td>
<td style="text-align: left;">
<p>No</p></td>
<td style="text-align: left;">
<p>CP2/TP2</p></td>
<td style="text-align: left;">
<p>CP1/TP1</p></td>
<td style="text-align: left;">
<p>Causal order + Central transformation server</p></td>
<td style="text-align: left;">
<p>Scalar</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Google Wave OT<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a></p></td>
<td style="text-align: left;">
<p>transform and composition(IT)</p></td>
<td style="text-align: left;">
<p>Yes</p></td>
<td style="text-align: left;">
<p>??</p></td>
<td style="text-align: left;">
<p>CP2/TP2</p></td>
<td style="text-align: left;">
<p>CP1/TP1</p></td>
<td style="text-align: left;">
<p>Causal order + Central transformation server + stop'n'wait propagation protocol</p></td>
<td style="text-align: left;">
<p>Scalar</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>GOT<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a> (REDUCE)</p></td>
<td style="text-align: left;">
<p>IT and ET</p></td>
<td style="text-align: left;">
<p>Yes</p></td>
<td style="text-align: left;">
<p>No</p></td>
<td style="text-align: left;">
<p>CP1/TP1, CP2/TP2</p></td>
<td style="text-align: left;">
<p>None</p></td>
<td style="text-align: left;">
<p>Causal order + Discontinuous total order</p></td>
<td style="text-align: left;">
<p>State vector</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>GOTO<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a> (REDUCE, <a class="uri" href="CoWord" title="wikilink">CoWord</a>, CoPPT, CoMaya)</p></td>
<td style="text-align: left;">
<p>IT and ET</p></td>
<td style="text-align: left;">
<p>Yes</p></td>
<td style="text-align: left;">
<p>No</p></td>
<td style="text-align: left;">
<p>None</p></td>
<td style="text-align: left;">
<p>CP1/TP1, CP2/TP2</p></td>
<td style="text-align: left;">
<p>Causal order</p></td>
<td style="text-align: left;">
<p>State vector</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>AnyUndo<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> (REDUCE, <a class="uri" href="CoWord" title="wikilink">CoWord</a>, CoPPT, CoMaya)</p></td>
<td style="text-align: left;">
<p>IT and ET</p></td>
<td style="text-align: left;">
<p>No</p></td>
<td style="text-align: left;">
<p>Undo any operation</p></td>
<td style="text-align: left;">
<p>IP2, IP3, RP</p></td>
<td style="text-align: left;">
<p>IP1, CP1/TP1, CP2/TP2</p></td>
<td style="text-align: left;">
<p>Causal order</p></td>
<td style="text-align: left;">
<p>State vector</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>SCOP<ref name="shencscw2002"> {{cite conference</ref></p></td>
<td style="text-align: left;">
<p>author = Shen, Haifeng and Sun, Chengzheng</p></td>
<td style="text-align: left;">
<p>title = Flexible notification for collaborative systems</p></td>
<td style="text-align: left;">
<p>booktitle = CSCW '02: Proceedings of the 2002 ACM conference on Computer supported cooperative work</p></td>
<td style="text-align: left;">
<p>year = 2002</p></td>
<td style="text-align: left;">
<p>pages = 77-86</p></td>
<td style="text-align: left;">
<p>doi = 10.1145/587078.587090 }} (NICE)</p></td>
<td style="text-align: left;">
<p>IT</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>COT <ref name="suntpds2009">{{cite journal</ref></p></td>
<td style="text-align: left;">
<p>author = D. Sun and C. Sun</p></td>
<td style="text-align: left;">
<p>title = Context-based Operational Transformation for Distributed Collaborative Editing Systems</p></td>
<td style="text-align: left;">
<p>journal = IEEE Trans. on Parallel and Distributed Systems</p></td>
<td style="text-align: left;">
<p>year = 2009</p></td>
<td style="text-align: left;">
<p>url = <a class="uri" href="http://ieeexplore.ieee.org/xpl/freepre_abs_all.jsp?isnumber=4359390&amp;arnumber">http://ieeexplore.ieee.org/xpl/freepre_abs_all.jsp?isnumber=4359390&amp;arnumber;</a>;=4668339 }}  (REDUCE, <a class="uri" href="CoWord" title="wikilink">CoWord</a>, CoPPT, CoMaya)</p></td>
<td style="text-align: left;">
<p>IT</p></td>
<td style="text-align: left;">
<p>Yes</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>TIBOT <ref name="liicpads2004">{{cite conference</ref></p></td>
<td style="text-align: left;">
<p>author = R. Li, D. Li and C. Sun</p></td>
<td style="text-align: left;">
<p>title = A Time Interval Based Consistency Control Algorithm for Interactive Groupware Applications</p></td>
<td style="text-align: left;">
<p>booktitle = ICPADS '04: Proceedings of the Parallel and Distributed Systems, Tenth International Conference</p></td>
<td style="text-align: left;">
<p>year = 2004</p></td>
<td style="text-align: left;">
<p>pages = 429</p></td>
<td style="text-align: left;">
<p>doi = 10.1109/ICPADS.2004.12 }}</p></td>
<td style="text-align: left;">
<p>IT</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>SOCT4<ref name="Vidot2000">{{cite conference</ref></p></td>
<td style="text-align: left;">
<p>author = Vidot, N. |author2=Cart, M. |author3=Ferrie, J. |author4=Suleiman, M.</p></td>
<td style="text-align: left;">
<p>year = 2000</p></td>
<td style="text-align: left;">
<p>title = Copies convergence in a distributed real-time collaborative environment</p></td>
<td style="text-align: left;">
<p>conference =</p></td>
<td style="text-align: left;">
<p>booktitle = Proceedings of the 2000 ACM conference on Computer supported cooperative work</p></td>
<td style="text-align: left;">
<p>pages = 171–180</p></td>
<td style="text-align: left;">
<p>publisher = ACM Press New York, NY, USA</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>SOCT2<ref name="Suleiman1998">{{cite conference</ref></p></td>
<td style="text-align: left;">
<p>author = Suleiman, M. |author2=Cart, M. |author3=Ferrié, J.</p></td>
<td style="text-align: left;">
<p>year = 1998</p></td>
<td style="text-align: left;">
<p>title = Concurrent Operations in a Distributed and Mobile Collaborative Environment</p></td>
<td style="text-align: left;">
<p>conference =</p></td>
<td style="text-align: left;">
<p>booktitle = Proceedings of the Fourteenth International Conference on Data Engineering, February</p></td>
<td style="text-align: left;">
<p>pages = 23–27</p></td>
<td style="text-align: left;">
<p>publisher =</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>MOT2<ref name="mot2">{{cite conference</ref></p></td>
<td style="text-align: left;">
<p>author = M. Cart, Jean Ferrié,</p></td>
<td style="text-align: left;">
<p>year = 2007</p></td>
<td style="text-align: left;">
<p>title = Synchronizer Based on Operational Transformation for P2P Environments</p></td>
<td style="text-align: left;">
<p>booktitle = Proceedings of the 3rd International Conference on Collaborative Computing: Networking, Applications and Worksharing</p></td>
<td style="text-align: left;">
<p>url = <a class="uri" href="http://hal.archives-ouvertes.fr/docs/00/08/60/98/PDF/cart_document_RR_LIRMM.pdf">http://hal.archives-ouvertes.fr/docs/00/08/60/98/PDF/cart_document_RR_LIRMM.pdf</a></p></td>
<td style="text-align: left;">
<p>pages = 127–138</p></td>
<td style="text-align: left;">
<p>accessdate = 2007-07-26</p>

<p><code>}}</code></p></td>
</tr>
</tbody>
</table>
<blockquote>

<p>A continuous total order is a <a href="Total_order" title="wikilink">strict total order</a> where it possible to detect a missing element i.e. 1,2,3,4,... is a continuous total order, 1,2,3,5,... is not a continuous total order.</p>
</blockquote>

<p>The transformation-based algorithms proposed in <a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a><a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> are based on the alternative consistency models "CSM" and "CA" as described above. Their approaches differ from those listed in the table. They use vector timestamps for causality preservation. The other correctness conditions are "single-"/"multi-" operation effects relation preservation or "admissibility" preservation. Those conditions are ensured by the control procedure and transformation functions synergistically. There is no need to discuss TP1/TP2 in their work. Hence they are not listed in the above table.</p>

<p>There exist some other optimistic consistency control algorithms that seek alternative ways to design transformation algorithms, but do not fit well with the above taxonomy and characterization. For example, Mark and Retrace<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a></p>

<p>The correctness problems of OT led to introduction of transformationless post-OT schemes, such as WOOT,<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a> Logoot<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a> and Causal Trees (CT).<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a> "Post-OT" schemes decompose the document into atomic operations, but they workaround the need to transform operations by employing a combination of unique symbol identifiers, vector timestamps and/or tombstones.</p>
<h2 id="critique-of-ot">Critique of OT</h2>

<p>While the classic OT approach of defining operations through their offsets in the text seems to be simple and natural, real-world distributed systems raise serious issues. Namely, that operations propagate with finite speed, states of participants are often different, thus the resulting combinations of states and operations are extremely hard to foresee and understand. As Li and Li put it, <em>Due to the need to consider complicated case coverage, formal proofs are very complicated and error-prone, even for OT algorithms that only treat two characterwise primitives (insert and delete)</em>.<a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a></p>

<p>Similarly, Joseph Gentle who is an ex Google Wave engineer and an author of the Share.JS library wrote: <em>Unfortunately, implementing OT sucks. There's a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly. ... Wave took 2 years to write and if we rewrote it today, it would take almost as long to write a second time.</em><a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a></p>

<p>For OT to work, every single change to the data needs to be captured: "Obtaining a snapshot of the state is usually trivial, but capturing edits is a different matter altogether. [...] The richness of modern user interfaces can make this problematic, especially within a browser-based environment." A proposed alternative to OT is <a href="http://neil.fraser.name/writing/sync/">Differential Synchronization</a>.<a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Optimistic_replication" title="wikilink">Optimistic Replication</a></li>
<li><a href="Data_synchronization" title="wikilink">Data synchronization</a></li>
<li><a href="Collaborative_editing" title="wikilink">Collaborative Editing</a></li>
<li><a href="Consistency_model" title="wikilink">Consistency models</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www3.ntu.edu.sg/home/czsun/projects/otfaq/">OTFAQ: Operational Transformation Frequently Asked Questions and Answers</a></li>
<li><a href="http://cooffice.ntu.edu.sg/sigce/">SIGCE: Special Interest Group of Collaborative Editing</a></li>
<li><a href="http://cooffice.ntu.edu.sg/sigce/conferences.php">International Workshop on Collaborative Editing Systems</a></li>
<li>[<a class="uri" href="http://dsonline.computer.org/portal/site/dsonline/menuitem.20d6846e1c7ed783f1a516106bbe36ec/index.jsp">http://dsonline.computer.org/portal/site/dsonline/menuitem.20d6846e1c7ed783f1a516106bbe36ec/index.jsp</a>?&amp;pName;=dso_level1_home&amp;path;=dsonline/topics/collaborative&amp;file;=index.xml&amp;xsl;=generic.xsl&amp; Distributed System Online - Collaborative editing]</li>
<li><a href="http://googledocs.blogspot.com/2010/09/whats-different-about-new-google-docs_22.html">Simple explanation of OT in Google Docs</a></li>
<li><a href="http://opencoweb.org/ocwdocs/intro/openg.html">Basics of OT in the Open Coweb Framework</a></li>
</ul>
<h3 id="relevant-online-talks">Relevant online talks</h3>
<ul>
<li><a href="http://www.youtube.com/watch?v=3ykZYKCK7AM">Google Wave: Live collaborative editing</a></li>
<li><a href="http://www.youtube.com/watch?v=84zqbXUQIHc">Google Tech Talk: Issues and Experiences in Designing Real-time Collaborative Editing Systems</a></li>
<li><a href="http://cooffice.ntu.edu.sg/coword/vods/lecture.htm">Microsoft Research talk: Consistency maintenance in real-time collaborative editing systems</a></li>
</ul>

<p>"</p>

<p><a href="Category:Concurrency_control" title="wikilink">Category:Concurrency control</a> <a class="uri" href="Category:Collaboration" title="wikilink">Category:Collaboration</a> <a href="Category:Distributed_algorithms" title="wikilink">Category:Distributed algorithms</a> <a class="uri" href="Category:Groupware" title="wikilink">Category:Groupware</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47"></li>
<li id="fn48"></li>
<li id="fn49"></li>
<li id="fn50"></li>
<li id="fn51"></li>
<li id="fn52"></li>
<li id="fn53"></li>
<li id="fn54"></li>
<li id="fn55"></li>
<li id="fn56"></li>
<li id="fn57"></li>
<li id="fn58"></li>
<li id="fn59"></li>
<li id="fn60"></li>
<li id="fn61"></li>
<li id="fn62"></li>
<li id="fn63"><a href="#fnref63">↩</a></li>
<li id="fn64"><a href="#fnref64">↩</a></li>
<li id="fn65"><a href="#fnref65">↩</a></li>
<li id="fn66"><a href="#fnref66">↩</a></li>
<li id="fn67"><a href="#fnref67">↩</a></li>
<li id="fn68"><a href="http://sharejs.org/">ShareJS – Live concurrent editing in your app.</a>. Sharejs.org (2011-11-06). Retrieved on 2013-08-16.<a href="#fnref68">↩</a></li>
<li id="fn69"><a href="#fnref69">↩</a></li>
</ol>
</section>
</body>
</html>
