<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1394">Draft:Kernels on Graph</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Draft:Kernels on Graph</h1>
<hr/>
<hr/>

<p>A <a href="graph_theory" title="wikilink"> graph</a> can be represented in the form of an <a href="adjacency_matrix" title="wikilink">adjacency matrix</a>, which encodes local links information between nodes. <a href="community_structure" title="wikilink"> Community detection</a> requires the global similarity information between pairwise nodes. Given an adjacency matrix, <a href="kernel_method" title="wikilink"> kernels</a> on graph can be used to derive global <a href="similarity_matrix" title="wikilink">similarity matrix</a>. There're different ways to construct kernels on graph. In the following, we will summarize different methods and their respective assumptions.</p>
<h2 id="motivation">Motivation</h2>

<p>Community detection is a common procedure in network analysis. Different <a href="cluster_analysis" title="wikilink"> clustering</a> algorithms, such as <a href="spectral_clustering" title="wikilink">spectral clustering</a>, <a href="hierarchical_clustering" title="wikilink">hierarchical clustering</a>, can be applied to group nodes into communities. The performance of these algorithms is largely determined by the construction of similarity matrix, which encodes certain notion of distance metric. It has been proved that the difference between many clustering algorithms results from different choices of similarity metric.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>. Therefore, it will be meaningful to investigate the right way to construct similarity matrix in various networks.</p>
<h2 id="adjacency-and-laplacian-matrix-of-a-graph">Adjacency and Laplacian matrix of a graph</h2>

<p>In graph theory, adjacency matrix 

<math display="inline" id="Draft:Kernels_on_Graph:0">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is defined to represent a graph. In particular, for a simple graph 

<math display="inline" id="Draft:Kernels_on_Graph:1">
 <semantics>
  <mi>ùêÜ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÜ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Draft:Kernels_on_Graph:2">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{ij}=1
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Draft:Kernels_on_Graph:3">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th node and 

<math display="inline" id="Draft:Kernels_on_Graph:4">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

-th node are connected through a link, 

<math display="inline" id="Draft:Kernels_on_Graph:5">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{ij}=0
  </annotation>
 </semantics>
</math>

 otherwise. Diagonal elements 

<math display="inline" id="Draft:Kernels_on_Graph:6">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>i</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{ii}
  </annotation>
 </semantics>
</math>

 are set to be zeros. <a href="Laplacian_matrix" title="wikilink">Laplacian matrix</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is defined as:</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:7">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mo>-</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <minus></minus>
     <ci>D</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=D-A
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Draft:Kernels_on_Graph:8">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is <a href="degree_matrix" title="wikilink">degree matrix</a>. Each diagonal element 

<math display="inline" id="Draft:Kernels_on_Graph:9">
 <semantics>
  <msub>
   <mi>D</mi>
   <mrow>
    <mi>i</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{ii}
  </annotation>
 </semantics>
</math>

 is defined to be the degree of 

<math display="inline" id="Draft:Kernels_on_Graph:10">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th node and all the off-diagonal elements are zeros. Laplacian matrix is an important concept in <a href="spectral_graph_theory" title="wikilink">spectral graph theory</a>.</p>
<h2 id="kernel-methods">Kernel methods</h2>

<p>Kernel methods, such as <a href="support_vector_machine" title="wikilink">support vector machine</a>, <a href="gaussian_process" title="wikilink">gaussian process</a>, are widely used in <a href="machine_learning" title="wikilink">machine learning</a> and <a href="pattern_recognition" title="wikilink">pattern recognition</a>. Given inputs 

<math display="inline" id="Draft:Kernels_on_Graph:11">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Draft:Kernels_on_Graph:12">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

, a kernel function 

<math display="inline" id="Draft:Kernels_on_Graph:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>œï</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>‚ãÖ</mo>
     <mi>œï</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <times></times>
       <ci>œï</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>œï</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x_{1},x_{2})=\phi(x_{1})\cdot\phi(x_{2})
  </annotation>
 </semantics>
</math>

 can be defined to measure the similarity between 

<math display="inline" id="Draft:Kernels_on_Graph:14">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Draft:Kernels_on_Graph:15">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

. Kernel function implicitly maps data from original space into high dimensional space 

<math display="inline" id="Draft:Kernels_on_Graph:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>œï</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>œï</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>œï</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>œï</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x_{1}),\phi(x_{2})
  </annotation>
 </semantics>
</math>

 such that data can be well separated in the new space. The kernel function need to be <a href="positive-definite_function" title="wikilink"> positive-definite</a> in order to guarantee the existence of mapping function 

<math display="inline" id="Draft:Kernels_on_Graph:17">
 <semantics>
  <mi>œï</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œï</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="kernels-on-graph">Kernels on graph</h2>
<h3 id="von-neumann-kernel">Von Neumann kernel <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></h3>

<p>Similar to <a href="Latent_semantic_indexing" title="wikilink">Latent_semantic indexing</a>, Neumann kernels is firstly proposed to compute the similarity between documents. Each document is represented by the terms occurring in the document. In the context of document clustering, the adjacency matrix of document graph is derived from document correlation matrix. Then Von Neumann diffusion kernel can be written as</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:18">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>V</mi>
     <mi>N</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">‚àû</mi>
    </munderover>
    <mrow>
     <msup>
      <mi>Œ≥</mi>
      <mi>k</mi>
     </msup>
     <msup>
      <mi>A</mi>
      <mi>k</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ùêà</mi>
      <mo>-</mo>
      <mrow>
       <mi>Œ≥</mi>
       <mi>A</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Œ≥</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>ùêà</ci>
       <apply>
        <times></times>
        <ci>Œ≥</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{VN}=\sum_{k=0}^{\infty}\gamma^{k}A^{k}=(\mathbf{I}-\gamma A)^{-1}
  </annotation>
 </semantics>
</math>

 Instead of only considering immediately links between nodes in adjacency matrix, , 

<math display="inline" id="Draft:Kernels_on_Graph:19">
 <semantics>
  <msubsup>
   <mi>A</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
   <mi>k</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{k}_{ij}
  </annotation>
 </semantics>
</math>

 is the number of paths between 

<math display="inline" id="Draft:Kernels_on_Graph:20">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th node and 

<math display="inline" id="Draft:Kernels_on_Graph:21">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

-th node with 

<math display="inline" id="Draft:Kernels_on_Graph:22">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 steps in the co-citation graph. In this way, the kernel 

<math display="inline" id="Draft:Kernels_on_Graph:23">
 <semantics>
  <msub>
   <mi>K</mi>
   <mrow>
    <mi>V</mi>
    <mi>N</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{VN}
  </annotation>
 </semantics>
</math>

 integrates all possible paths between pairwise nodes in arbitrary number of steps. Apparently shorter paths should have higher weights. The Von Neumann kernel gives longer path smaller weights with decay factor 

<math display="inline" id="Draft:Kernels_on_Graph:24">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

. The limitation of Von Neumann diffusion kernel is the similarity between nodes 

<math display="inline" id="Draft:Kernels_on_Graph:25">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

 is determined by the number of nodes commonly citing 

<math display="inline" id="Draft:Kernels_on_Graph:26">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

. While nodes citing only one of them are ignored<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>.</p>
<h3 id="regularized-laplacian-kernel">Regularized Laplacian kernel<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></h3>

<p>The regularized Laplacian kernel is defined as</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:27">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>R</mi>
     <mi>L</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">‚àû</mi>
    </munderover>
    <mrow>
     <msup>
      <mi>Œ≥</mi>
      <mi>k</mi>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mi>L</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>I</mi>
      <mo>+</mo>
      <mrow>
       <mi>Œ≥</mi>
       <mi>L</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>L</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Œ≥</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>L</ci>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>I</ci>
       <apply>
        <times></times>
        <ci>Œ≥</ci>
        <ci>L</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{RL}=\sum_{k=0}^{\infty}\gamma^{k}(-L)^{k}=(I+\gamma L)^{-1}
  </annotation>
 </semantics>
</math>

 Here adjacency matrix is replaced by negative Laplacian matrix. Therefore to interpret this formulation, the counting of paths is carried out on negative Laplacian matrix. In this case, the self-loop edges are also taken into account and have negative weights. Tradeoff between node importance and relatedness can be achieved by controlling 

<math display="inline" id="Draft:Kernels_on_Graph:28">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="diffusion-kernel">Diffusion kernel<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></h3>

<p>A <a href="diffusion_process" title="wikilink"> diffusion</a> model can be defined on a graph. Suppose each node has 

<math display="inline" id="Draft:Kernels_on_Graph:29">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}(t)
  </annotation>
 </semantics>
</math>

 amount of particles at time 

<math display="inline" id="Draft:Kernels_on_Graph:30">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and it diffuses to node 

<math display="inline" id="Draft:Kernels_on_Graph:31">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 in its neighborhood with rate 

<math display="inline" id="Draft:Kernels_on_Graph:32">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{ij}
  </annotation>
 </semantics>
</math>

. Therefore, during a small time interval 

<math display="inline" id="Draft:Kernels_on_Graph:33">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œî</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Œî</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Draft:Kernels_on_Graph:34">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mi mathvariant="normal">Œî</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>normal-Œî</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}A_{ij}\Delta t
  </annotation>
 </semantics>
</math>

 amount of particles is transferred from 

<math display="inline" id="Draft:Kernels_on_Graph:35">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th node to 

<math display="inline" id="Draft:Kernels_on_Graph:36">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

-th node. Consider both the amount of input and output during 

<math display="inline" id="Draft:Kernels_on_Graph:37">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œî</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Œî</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

, the rate equation for 

<math display="inline" id="Draft:Kernels_on_Graph:38">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th node is given by</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mrow>
        <mi mathvariant="normal">Œî</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <msub>
       <mi>A</mi>
       <mrow>
        <mi>j</mi>
        <mi>i</mi>
       </mrow>
      </msub>
      <mi mathvariant="normal">Œî</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>A</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mi mathvariant="normal">Œî</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>normal-Œî</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <ci>normal-Œî</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>normal-Œî</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}(t+\Delta t)-x_{i}(t)=\sum_{j=1}^{n}x_{j}A_{ji}\Delta t-\sum_{j=1}^{n}x_{%
i}A_{ij}\Delta t
  </annotation>
 </semantics>
</math>

. Solve for 

<math display="inline" id="Draft:Kernels_on_Graph:40">
 <semantics>
  <mrow>
   <mi>ùê±</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùê±</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(t)
  </annotation>
 </semantics>
</math>

, we have 

<math display="inline" id="Draft:Kernels_on_Graph:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùê±</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ùê±</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ùê±</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ùê±</ci>
     <cn type="integer">0</cn>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(t)=\mathbf{x}(0)\exp(-Lt)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Draft:Kernels_on_Graph:42">
 <semantics>
  <mrow>
   <mi>ùê±</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùê±</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(0)
  </annotation>
 </semantics>
</math>

 is the initial amount of particles at time 

<math display="inline" id="Draft:Kernels_on_Graph:43">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>

. This leads to diffusion kernel</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:44">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>D</mi>
     <mi>L</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>Œ≥</mi>
       <mi>L</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>Œ≥</ci>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{DL}=\exp(-\gamma L)
  </annotation>
 </semantics>
</math>

 If negative Laplacian matrix is replaced by adjacency matrix, a new kernel can be derived</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:45">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>D</mi>
     <mi>A</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Œ≥</mi>
      <mi>A</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">‚àû</mi>
    </munderover>
    <mfrac>
     <mrow>
      <msup>
       <mi>Œ≥</mi>
       <mi>k</mi>
      </msup>
      <msup>
       <mi>A</mi>
       <mi>k</mi>
      </msup>
     </mrow>
     <mrow>
      <mi>k</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <times></times>
       <ci>Œ≥</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Œ≥</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{DA}=\exp(\gamma A)=\sum_{k=0}^{\infty}\frac{\gamma^{k}A^{k}}{k!}
  </annotation>
 </semantics>
</math>

 The difference between 

<math display="inline" id="Draft:Kernels_on_Graph:46">
 <semantics>
  <msub>
   <mi>K</mi>
   <mrow>
    <mi>D</mi>
    <mi>A</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{DA}
  </annotation>
 </semantics>
</math>

 and Von Neumann kernel is the decay factor changes from 

<math display="inline" id="Draft:Kernels_on_Graph:47">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Draft:Kernels_on_Graph:48">
 <semantics>
  <mrow>
   <msup>
    <mi>Œ≥</mi>
    <mi>k</mi>
   </msup>
   <mo>/</mo>
   <mrow>
    <mi>k</mi>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Œ≥</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <factorial></factorial>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma^{k}/k!
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="commute-time-kernel">Commute-time kernel <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></h3>

<p>Consider <a href="random_walk" title="wikilink">random walk</a> on the graph and define 

<math display="inline" id="Draft:Kernels_on_Graph:49">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 as the transition probability matrix, where 

<math display="inline" id="Draft:Kernels_on_Graph:50">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>/</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{ij}=A_{ij}/\sum_{j=1}^{n}A_{ij}
  </annotation>
 </semantics>
</math>

. The average commute time between node 

<math display="inline" id="Draft:Kernels_on_Graph:51">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

, which is the average number of steps that a random walker, starting from node 

<math display="inline" id="Draft:Kernels_on_Graph:52">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, will take before arriving node 

<math display="inline" id="Draft:Kernels_on_Graph:53">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 for the first time, and go back to 

<math display="inline" id="Draft:Kernels_on_Graph:54">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, can be computed from</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>G</mi>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>e</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>e</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
    <msup>
     <mi>L</mi>
     <mo>+</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>e</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>e</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <plus></plus>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(i,j)=V_{G}(e_{i}-e_{j})^{T}L^{+}(e_{i}-e_{j})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Draft:Kernels_on_Graph:56">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>e</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i},e_{j}
  </annotation>
 </semantics>
</math>

 are representations of node 

<math display="inline" id="Draft:Kernels_on_Graph:57">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Draft:Kernels_on_Graph:58">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>G</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{G}
  </annotation>
 </semantics>
</math>

 is the volume of the graph, 

<math display="inline" id="Draft:Kernels_on_Graph:59">
 <semantics>
  <msup>
   <mi>L</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{+}
  </annotation>
 </semantics>
</math>

 is <a href="Moore-Penrose_pseudoinverse" title="wikilink">Moore-Penrose pseudoinverse</a> of Laplacian matrix 

<math display="inline" id="Draft:Kernels_on_Graph:60">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Draft:Kernels_on_Graph:61">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(i,j)
  </annotation>
 </semantics>
</math>

 is the <a href="Mahalanobis_distance" title="wikilink">Mahalanobis distance</a> between node 

<math display="inline" id="Draft:Kernels_on_Graph:62">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

 with covariance matrix 

<math display="inline" id="Draft:Kernels_on_Graph:63">
 <semantics>
  <msup>
   <mi>L</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{+}
  </annotation>
 </semantics>
</math>

. Accordingly, the commute time kernel can be defined as</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:64">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>C</mi>
     <mi>T</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>L</mi>
    <mo>+</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{CT}=L^{+}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="random-walk-with-restart-similarity-kernel">Random-walk-with-restart similarity kernel <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></h3>

<p>In random walk that defines commute-time kernel, besides jumping from node 

<math display="inline" id="Draft:Kernels_on_Graph:65">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 to its neighbor 

<math display="inline" id="Draft:Kernels_on_Graph:66">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 proportional to edge weights, the walker is allowed to stay at node 

<math display="inline" id="Draft:Kernels_on_Graph:67">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 with probability 

<math display="inline" id="Draft:Kernels_on_Graph:68">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>Œ≥</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>Œ≥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\gamma
  </annotation>
 </semantics>
</math>

. From the final stable state, the random-walk-with-restart similarity kernel can be extracted</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:69">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>R</mi>
     <mi>W</mi>
     <mi>R</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>D</mi>
       <mo>-</mo>
       <mrow>
        <mi>Œ≥</mi>
        <mi>A</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>W</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>D</ci>
       <apply>
        <times></times>
        <ci>Œ≥</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{RWR}=(D-\gamma A)^{-1}D
  </annotation>
 </semantics>
</math>

</p>
<h3 id="markov-diffusion-kernel">Markov diffusion kernel <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></h3>

<p>The distance between two nodes can be defined by comparing their influence to the graph. If two nodes diffuse through the graph in the same way, then the distance between them is zero. Given the averaging visiting rate 

<math display="inline" id="Draft:Kernels_on_Graph:70">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mi>k</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ik}(t)
  </annotation>
 </semantics>
</math>

, which is the probability of finding the random walker starting from state 

<math display="inline" id="Draft:Kernels_on_Graph:71">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Draft:Kernels_on_Graph:72">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 after 

<math display="inline" id="Draft:Kernels_on_Graph:73">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 steps, the Markov diffusion distance between node 

<math display="inline" id="Draft:Kernels_on_Graph:74">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Draft:Kernels_on_Graph:75">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:76">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>i</mi>
          <mi>k</mi>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>j</mi>
          <mi>k</mi>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>e</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>e</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>Z</mi>
     <mi>T</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>e</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>e</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <times></times>
           <ci>j</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
      <ci>Z</ci>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Z</ci>
       <ci>T</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ij}(t)=\sum_{k=1}^{n}(x_{ik}(t)-x_{jk}(t))^{2}=(e_{i}-e_{j})^{T}Z(t)Z^{T}(t%
)(e_{i}-e_{j})
  </annotation>
 </semantics>
</math>

 Thus, the Markov diffusion kernel can be defined as</p>

<p>

<math display="block" id="Draft:Kernels_on_Graph:77">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>K</mi>
     <mrow>
      <mi>M</mi>
      <mi>D</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>Z</mi>
     <mi>T</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>D</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <ci>T</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{MD}(t)=Z(t)Z^{T}(t)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Draft:Kernels_on_Graph:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>t</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>œÑ</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>t</mi>
     </msubsup>
     <msup>
      <mi>P</mi>
      <mi>œÑ</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>t</mi>
    </mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>I</mi>
       <mo>-</mo>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <msup>
       <mi>P</mi>
       <mi>t</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Z</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>œÑ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <ci>œÑ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>I</ci>
        <ci>P</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>I</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(t)=\frac{1}{t}\sum_{\tau=1}^{t}P^{\tau}=\frac{1}{t}(I-P)^{-1}(I-P^{t})P
  </annotation>
 </semantics>
</math>

 If the Euclidean distance in 

<math display="inline" id="Draft:Kernels_on_Graph:79">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ij}
  </annotation>
 </semantics>
</math>

 is replaced with <a href="Kullback‚ÄìLeibler_divergence" title="wikilink">Kullback‚ÄìLeibler divergence</a>, then Relative-entropy diffusion kernel<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> can be derived.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li>"
</li>
</ul>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Yan, S., Xu, D., Zhang, B., Zhang, H. J., Yang, Q., &amp; Lin, S. (2007). Graph embedding and extensions: a general framework for dimensionality reduction. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 29(1), 40-51.<a href="#fnref1">‚Ü©</a></li>
<li id="fn2">.<a href="#fnref2">‚Ü©</a></li>
<li id="fn3">Kandola, J., Cristianini, N., &amp; Shawe-taylor, J. S. (2002). Learning semantic similarity. In Advances in neural information processing systems (pp. 657-664).<a href="#fnref3">‚Ü©</a></li>
<li id="fn4">Ito, T., Shimbo, M., Kudo, T., &amp; Matsumoto, Y. (2005, August). Application of kernels to link analysis. In Proceedings of the eleventh ACM SIGKDD international conference on Knowledge discovery in data mining (pp. 586-592). ACM.<a href="#fnref4">‚Ü©</a></li>
<li id="fn5">Chebotarev, P., &amp; Shamis, E. (2006). The matrix-forest theorem and measuring relations in small social groups. arXiv preprint math/0602070.<a href="#fnref5">‚Ü©</a></li>
<li id="fn6">Ito, T., Shimbo, M., Kudo, T., &amp; Matsumoto, Y. (2005, August). Application of kernels to link analysis. In Proceedings of the eleventh ACM SIGKDD international conference on Knowledge discovery in data mining (pp. 586-592). ACM.<a href="#fnref6">‚Ü©</a></li>
<li id="fn7">Kondor, R. I., &amp; Lafferty, J. (2002, July). Diffusion kernels on graphs and other discrete input spaces. In ICML (Vol. 2, pp. 315-322).<a href="#fnref7">‚Ü©</a></li>
<li id="fn8">Smola, A. J., &amp; Kondor, R. (2003). Kernels and regularization on graphs. In Learning theory and kernel machines (pp. 144-158). Springer Berlin Heidelberg.<a href="#fnref8">‚Ü©</a></li>
<li id="fn9">Saerens, M., Fouss, F., Yen, L., &amp; Dupont, P. (2004). The principal components analysis of a graph, and its relationships to spectral clustering. In Machine Learning: ECML 2004 (pp. 371-383). Springer Berlin Heidelberg.<a href="#fnref9">‚Ü©</a></li>
<li id="fn10">Pan, J. Y., Yang, H. J., Faloutsos, C., &amp; Duygulu, P. (2004, August). Automatic multimedia cross-modal correlation discovery. In Proceedings of the tenth ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 653-658). ACM.<a href="#fnref10">‚Ü©</a></li>
<li id="fn11">Nadler, B., Lafon, S., Coifman, R. R., &amp; Kevrekidis, I. G. (2005). Diffusion maps, spectral clustering and eigenfunctions of Fokker-Planck operators. arXiv preprint math/0506090.<a href="#fnref11">‚Ü©</a></li>
<li id="fn12">Fouss, F., Francoisse, K., Yen, L., Pirotte, A., &amp; Saerens, M. (2012). An experimental investigation of kernels on graphs for collaborative recommendation and semisupervised classification. Neural Networks, 31, 53-72.<a href="#fnref12">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
