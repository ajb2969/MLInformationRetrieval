<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="274">Neighbor joining</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Neighbor joining</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>This genetic distance map made in 2002 is an estimate of 18 world human groups by a <a class="uri" href="neighbour-joining" title="wikilink">neighbour-joining</a> method based on 23 kinds of genetic information. It was made by Saitou Naruya  professor at the (Japanese) National Institute for Genetics.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></figcaption>
</figure>

<p>In <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>, <strong>neighbor joining</strong> is a bottom-up (agglomerative) clustering method for the creation of <a href="phylogenetic_trees" title="wikilink">phylogenetic trees</a>, created by <a href="Naruya_Saitou" title="wikilink">Naruya Saitou</a> and <a href="Masatoshi_Nei" title="wikilink">Masatoshi Nei</a> in 1987.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Usually used for trees based on <a class="uri" href="DNA" title="wikilink">DNA</a> or <a class="uri" href="protein" title="wikilink">protein</a> <a href="primary_structure" title="wikilink">sequence</a> data, the algorithm requires knowledge of the distance between each pair of <a class="uri" href="taxa" title="wikilink">taxa</a> (e.g., species or sequences) to form the tree.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="the-algorithm">The algorithm</h2>
<figure><b>(Figure)</b>
<figcaption>Starting with a star tree (A), the Q matrix is calculated and used to choose a pair of nodes for joining, in this case f and g. These are joined to a newly created node, u, as shown in (B). The part of the tree shown as solid lines is now fixed and will not be changed in subsequent joining steps. The distances from node u to the nodes a-e are computed from equation (). This process is then repeated, using a matrix of just the distances between the nodes, a,b,c,d,e, and u, and a Q matrix derived from it. In this case u and e are joined to the newly created v, as shown in (C). Two more iterations lead first to (D), and then to (E), at which point the algorithm is done, as the tree is fully resolved.</figcaption>
</figure>

<p>Neighbor joining takes as input a <a href="distance_matrix" title="wikilink">distance matrix</a> specifying the distance between each pair of taxa. The algorithm starts with a completely unresolved tree, whose topology corresponds to that of a <a href="star_network" title="wikilink">star network</a>, and iterates over the following steps until the tree is completely resolved and all branch lengths are known:</p>
<ol>
<li>Based on the current distance matrix calculate the matrix 

<math display="inline" id="Neighbor_joining:0">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 (defined below).</li>
<li>Find the pair of distinct taxa i and j (i.e. with 

<math display="inline" id="Neighbor_joining:1">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>≠</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\neq j
  </annotation>
 </semantics>
</math>

) for which 

<math display="inline" id="Neighbor_joining:2">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(i,j)
  </annotation>
 </semantics>
</math>

 has its lowest value. These taxa are joined to a newly created node, which is connected to the central node. In the figure at right, f and g are joined to the new node u.</li>
<li>Calculate the distance from each of the <a href="taxon" title="wikilink">taxa</a> in the pair to this new node.</li>
<li>Calculate the distance from each of the taxa outside of this pair to the new node.</li>
<li>Start the algorithm again, replacing the pair of joined neighbors with the new node and using the distances calculated in the previous step.</li>
</ol>
<h3 id="the-q-matrix">The Q-matrix</h3>

<p>Based on a distance matrix relating the 

<math display="inline" id="Neighbor_joining:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 taxa, calculate 

<math display="inline" id="Neighbor_joining:4">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 as follows:</p>

<p>where 

<math display="inline" id="Neighbor_joining:5">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(i,j)
  </annotation>
 </semantics>
</math>

 is the distance between taxa 

<math display="inline" id="Neighbor_joining:6">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:7">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="distance-from-the-pair-members-to-the-new-node">Distance from the pair members to the new node</h3>

<p>For each of the taxa in the pair being joined, use the following formula to calculate the distance to the new node:</p>

<p>and:</p>

<p>

<math display="block" id="Neighbor_joining:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo>,</mo>
       <mi>g</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <ci>g</ci>
      <ci>u</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>f</ci>
       <ci>g</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <interval closure="open">
       <ci>f</ci>
       <ci>u</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(g,u)=d(f,g)-\delta(f,u)\quad
  </annotation>
 </semantics>
</math>

</p>

<p>Taxa 

<math display="inline" id="Neighbor_joining:9">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:10">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 are the paired taxa and 

<math display="inline" id="Neighbor_joining:11">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is the newly created node. The branches joining 

<math display="inline" id="Neighbor_joining:12">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:13">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:14">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:15">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

, and their lengths, 

<math display="inline" id="Neighbor_joining:16">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <interval closure="open">
     <ci>f</ci>
     <ci>u</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(f,u)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:17">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <interval closure="open">
     <ci>g</ci>
     <ci>u</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(g,u)
  </annotation>
 </semantics>
</math>

 are part of the tree which is gradually being created; they neither affect not are affected by later neighbor-joining steps.</p>
<h3 id="distance-of-the-other-taxa-from-the-new-node">Distance of the other taxa from the new node</h3>

<p>For each taxon not considered in the previous step, we calculate the distance to the new node as follows:</p>

<p>where 

<math display="inline" id="Neighbor_joining:18">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is the new node, 

<math display="inline" id="Neighbor_joining:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the node which we want to calculate the distance to and 

<math display="inline" id="Neighbor_joining:20">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:21">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 are the members of the pair just joined.</p>
<h3 id="complexity">Complexity</h3>

<p>Neighbor joining on a set of 

<math display="inline" id="Neighbor_joining:22">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 taxa requires 

<math display="inline" id="Neighbor_joining:23">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-3
  </annotation>
 </semantics>
</math>

 iterations. At each step one has to build and search a 

<math display="inline" id="Neighbor_joining:24">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 matrix. Initially the 

<math display="inline" id="Neighbor_joining:25">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 matrix is size 

<math display="inline" id="Neighbor_joining:26">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

, then the next step it is 

<math display="inline" id="Neighbor_joining:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)\times(n-1)
  </annotation>
 </semantics>
</math>

, etc. Implementing this in a straightforward way leads to an algorithm with a time complexity of 

<math display="inline" id="Neighbor_joining:28">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

; implementations exist which use heuristics to do much better than this on average.</p>
<h2 id="example">Example</h2>
<figure><b>(Figure)</b>
<figcaption>Neighbor joining with 5 taxa. In this case 2 neighbor joining steps give a tree with fully resolved topology. The branches of the resulting tree are labeled with their lengths.</figcaption>
</figure>

<p>Let us assume that we have five taxa 

<math display="inline" id="Neighbor_joining:29">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo>,</mo>
   <mi>d</mi>
   <mo>,</mo>
   <mi>e</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
    <ci>d</ci>
    <ci>e</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b,c,d,e)
  </annotation>
 </semantics>
</math>

 and the following distance matrix:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>a</p></th>
<th style="text-align: left;">
<p>b</p></th>
<th style="text-align: left;">
<p>c</p></th>
<th style="text-align: left;">
<p>d</p></th>
<th style="text-align: left;">
<p>e</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>b</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>9</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>c</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>e</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table>

<p>We obtain the following values for the 

<math display="inline" id="Neighbor_joining:30">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 matrix (the diagonal elements of the matrix are not used and are omitted here):</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>a</p></th>
<th style="text-align: left;">
<p>b</p></th>
<th style="text-align: left;">
<p>c</p></th>
<th style="text-align: left;">
<p>d</p></th>
<th style="text-align: left;">
<p>e</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>−50</p></td>
<td style="text-align: left;">
<p>−38</p></td>
<td style="text-align: left;">
<p>−34</p></td>
<td style="text-align: left;">
<p>−34</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>b</p></td>
<td style="text-align: left;">
<p>−50</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>−38</p></td>
<td style="text-align: left;">
<p>−34</p></td>
<td style="text-align: left;">
<p>−34</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>c</p></td>
<td style="text-align: left;">
<p>−38</p></td>
<td style="text-align: left;">
<p>−38</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>−40</p></td>
<td style="text-align: left;">
<p>−40</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>−34</p></td>
<td style="text-align: left;">
<p>−34</p></td>
<td style="text-align: left;">
<p>−40</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>−48</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>e</p></td>
<td style="text-align: left;">
<p>−34</p></td>
<td style="text-align: left;">
<p>−34</p></td>
<td style="text-align: left;">
<p>−40</p></td>
<td style="text-align: left;">
<p>−48</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>

<p>In the example above, 

<math display="inline" id="Neighbor_joining:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>50</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">50</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(a,b)=-50
  </annotation>
 </semantics>
</math>

. This is the smallest value of 

<math display="inline" id="Neighbor_joining:32">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, so we join nodes 

<math display="inline" id="Neighbor_joining:33">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:34">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Neighbor_joining:35">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 denote the new node; the branches joining 

<math display="inline" id="Neighbor_joining:36">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:37">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Neighbor_joining:38">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 then have lengths 

<math display="inline" id="Neighbor_joining:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>u</ci>
     </interval>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(a,u)=2
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <ci>b</ci>
      <ci>u</ci>
     </interval>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(b,u)=3
  </annotation>
 </semantics>
</math>

, by equation (), above.</p>

<p>We then proceed to update the distance matrix; using equation () above, we compute the distance from 

<math display="inline" id="Neighbor_joining:41">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 to each of the other nodes besides 

<math display="inline" id="Neighbor_joining:42">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:43">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. In this case, we obtain 

<math display="inline" id="Neighbor_joining:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>c</ci>
     </interval>
    </apply>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(u,c)=7
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Neighbor_joining:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>d</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>d</ci>
     </interval>
    </apply>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(u,d)=7
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Neighbor_joining:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>e</ci>
     </interval>
    </apply>
    <cn type="integer">6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(u,e)=6
  </annotation>
 </semantics>
</math>

. The resulting distance matrix is:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>u</p></th>
<th style="text-align: left;">
<p>c</p></th>
<th style="text-align: left;">
<p>d</p></th>
<th style="text-align: left;">
<p>e</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>u</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>c</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>7</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>e</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>The corresponding Q matrix is:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>u</p></th>
<th style="text-align: left;">
<p>c</p></th>
<th style="text-align: left;">
<p>d</p></th>
<th style="text-align: left;">
<p>e</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>u</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>−28</p></td>
<td style="text-align: left;">
<p>−24</p></td>
<td style="text-align: left;">
<p>−24</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>c</p></td>
<td style="text-align: left;">
<p>−28</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>−24</p></td>
<td style="text-align: left;">
<p>−24</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>−24</p></td>
<td style="text-align: left;">
<p>−24</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>−28</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>e</p></td>
<td style="text-align: left;">
<p>−24</p></td>
<td style="text-align: left;">
<p>−24</p></td>
<td style="text-align: left;">
<p>−28</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>We may choose either to join 

<math display="inline" id="Neighbor_joining:47">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:48">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, or to join 

<math display="inline" id="Neighbor_joining:49">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:50">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

; both pairs have the minimal 

<math display="inline" id="Neighbor_joining:51">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 value of 

<math display="inline" id="Neighbor_joining:52">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>28</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">28</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -28
  </annotation>
 </semantics>
</math>

, and either choice leads to the same result. For concreteness, let us join 

<math display="inline" id="Neighbor_joining:53">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:54">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 and call the new node 

<math display="inline" id="Neighbor_joining:55">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

; this gives branch lengths 

<math display="inline" id="Neighbor_joining:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(u,v)=3
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Neighbor_joining:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <ci>c</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(c,v)=4
  </annotation>
 </semantics>
</math>

 as shown in the figure, and the distance matrix for the remaining 3 nodes, 

<math display="inline" id="Neighbor_joining:58">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Neighbor_joining:59">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Neighbor_joining:60">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, is:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>v</p></th>
<th style="text-align: left;">
<p>d</p></th>
<th style="text-align: left;">
<p>e</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>v</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>e</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>

<p>The tree topology is fully resolved at this point, so we don't need to calculate 

<math display="inline" id="Neighbor_joining:61">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 or do any more joining of neighbors. However, we can use these distances to get the remaining 3 branch-lengths, as shown in the figure.</p>

<p>This example represents an idealized case: note that if we move from any taxon to any other along the branches of the tree, and sum the lengths of the branches traversed, the result is equal to the distance between those taxa in the input distance matrix. For example, going from 

<math display="inline" id="Neighbor_joining:62">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Neighbor_joining:63">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 we have 

<math display="inline" id="Neighbor_joining:64">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mo>+</mo>
    <mn>2</mn>
    <mo>+</mo>
    <mn>3</mn>
    <mo>+</mo>
    <mn>3</mn>
   </mrow>
   <mo>=</mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">2</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">10</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2+2+3+3=10
  </annotation>
 </semantics>
</math>

. A distance matrix whose distances agree in this way with some tree is said to be 'additive', a property which is rare in practice. Nonetheless it is important to note that, given an additive distance matrix as input, neighbor joining is guaranteed to find the tree whose distances between taxa agree with it.</p>
<h2 id="neighbor-joining-as-minimum-evolution">Neighbor joining as minimum evolution</h2>

<p>Neighbor joining may be viewed as a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> for optimizing a tree according to the 'balanced minimum evolution'<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (BME) criterion. For each topology, BME defines the tree length (sum of branch lengths) to be a particular weighted sum of the distances in the distance matrix, with the weights depending on the topology. The BME optimal topology is the one which minimizes this tree length. Neighbor joining at each step greedily joins that pair of taxa which will give the greatest decrease in the estimated tree length. This procedure is not guaranteed to find the topology which is optimal by the BME criterion, although it often does and is usually quite close.</p>
<h2 id="advantages-and-disadvantages">Advantages and disadvantages</h2>

<p>The main virtue of NJ is that it is fast, due in part to its being a polynomial-time algorithm. This makes it practical for analyzing large data sets (hundreds or thousands of taxa) and for <a href="bootstrapping_(statistics)" title="wikilink">bootstrapping</a>, for which purposes other means of analysis (e.g. <a href="maximum_parsimony" title="wikilink">maximum parsimony</a>, <a href="maximum_likelihood" title="wikilink">maximum likelihood</a>) may be <a href="computation" title="wikilink">computationally</a> prohibitive.</p>

<p>Neighbor joining has the property that if the input distance matrix is correct, then the output tree will be correct. Furthermore the correctness of the output tree topology is guaranteed as long as the distance matrix is 'nearly additive', specifically if each entry in the distance matrix differs from the true distance by less than half of the shortest branch length in the tree.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In practice the distance matrix rarely satisfies this condition, but neighbor joining often constructs the correct tree topology anyway.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The correctness of neighbor joining for nearly additive distance matrices implies that it is <a href="statistical_consistency" title="wikilink">statistically consistent</a> under many models of evolution; given data of sufficient length, neighbor joining will reconstruct the true tree with high probability. Compared with <a class="uri" href="UPGMA" title="wikilink">UPGMA</a>, neighbor joining has the advantage that it does not assume all lineages evolve at the same rate (<a href="molecular_clock_hypothesis" title="wikilink">molecular clock hypothesis</a>).</p>

<p>Nevertheless, neighbor joining has been largely superseded by phylogenetic methods that do not rely on distance measures and offer superior accuracy under most conditions. Neighbor joining has the undesirable feature that it often assigns negative lengths to some of the branches.</p>
<h2 id="implementations-and-variants">Implementations and variants</h2>

<p>There are many programs available implementing neighbor joining. <a href="http://birc.au.dk/Software/RapidNJ/">RapidNJ</a> and <a href="http://nimbletwist.com/software/ninja/">NINJA</a> are fast implementations with typical run times proportional to approximately the square of the number of taxa. <a href="http://www.atgc-montpellier.fr/bionj/">BIONJ</a> and <a href="http://www.t6.lanl.gov/billb/weighbor/">Weighbor</a> are variants of neighbor joining which improve on its accuracy by making use of the fact that the shorter distances in the distance matrix are generally better known than the longer distances. <a href="http://www.ncbi.nlm.nih.gov/CBBresearch/Desper/FastME.html">FastME</a> is an implementation of the closely related balanced minimum evolution method.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Human_genetic_clustering" title="wikilink">Human genetic clustering</a></li>
<li><a href="Nearest_neighbor_search" title="wikilink">Nearest neighbor search</a></li>
<li><a class="uri" href="UPGMA" title="wikilink">UPGMA</a></li>
</ul>
<h2 id="references">References</h2>
<dl>
<dt>Other sources</dt>
</dl>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.icp.be/~opperd/private/neighbor.html">The Neighbor-Joining Method</a> — a tutorial</li>
</ul>

<p>"</p>

<p><a href="Category:Bioinformatics_algorithms" title="wikilink">Category:Bioinformatics algorithms</a> <a class="uri" href="Category:Phylogenetics" title="wikilink">Category:Phylogenetics</a> <a href="Category:Computational_phylogenetics" title="wikilink">Category:Computational phylogenetics</a> <a href="Category:Data_clustering_algorithms" title="wikilink">Category:Data clustering algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.museum.kyushu-u.ac.jp/WAJIN/113.html">Saitou. Kyushu Museum. 2002. February 2, 2007</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://mbe.oxfordjournals.org/content/4/4/406.long">Saitou N, Nei M. "The neighbor-joining method: a new method for reconstructing phylogenetic trees." <em>Molecular Biology and Evolution</em>, volume 4, issue 4, pp. 406-425, July 1987.</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Atteson K (1997). "The performance of neighbor-joining algorithms of phylogeny reconstruction", pp. 101–110. <em>In</em> Jiang, T., and Lee, D., eds., <em>Lecture Notes in Computer Science, 1276</em>, Springer-Verlag, Berlin. COCOON '97.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
