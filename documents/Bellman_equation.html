<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="108">Bellman equation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bellman equation</h1>
<hr/>

<p>A <strong>Bellman equation</strong>, named after its discoverer, <a href="Richard_Bellman" title="wikilink">Richard Bellman</a>, also known as a <strong>dynamic programming equation</strong>, is a <a href="necessary_condition" title="wikilink">necessary condition</a> for optimality associated with the mathematical <a href="Optimization_(mathematics)" title="wikilink">optimization</a> method known as <a href="dynamic_programming" title="wikilink">dynamic programming</a>. It writes the value of a decision problem at a certain point in time in terms of the payoff from some initial choices and the value of the remaining decision problem that results from those initial choices. This breaks a dynamic optimization problem into simpler subproblems, as Bellman's <strong>Principle of Optimality</strong> prescribes.</p>

<p>The Bellman equation was first applied to engineering <a href="control_theory" title="wikilink">control theory</a> and to other topics in applied mathematics, and subsequently became an important tool in <a href="economic_theory" title="wikilink">economic theory</a>.</p>

<p>Almost any problem which can be solved using <a href="optimal_control_theory" title="wikilink">optimal control theory</a> can also be solved by analyzing the appropriate Bellman equation. However, the term 'Bellman equation' usually refers to the dynamic programming equation associated with <a class="uri" href="discrete-time" title="wikilink">discrete-time</a> optimization problems. In continuous-time optimization problems, the analogous equation is a <a href="partial_differential_equation" title="wikilink">partial differential equation</a> which is usually called the <a href="Hamilton–Jacobi–Bellman_equation" title="wikilink">Hamilton–Jacobi–Bellman equation</a>.</p>
<h2 id="analytical-concepts-in-dynamic-programming">Analytical concepts in dynamic programming</h2>

<p>To understand the Bellman equation, several underlying concepts must be understood. First, any optimization problem has some objective – minimizing travel time, minimizing cost, maximizing profits, maximizing utility, et cetera. The mathematical function that describes this objective is called the <strong><a href="Optimization_(mathematics)#Optimization_problems" title="wikilink">objective function</a></strong>.</p>

<p>Dynamic programming breaks a multi-period planning problem into simpler steps at different points in time. Therefore, it requires keeping track of how the decision situation is evolving over time. The information about the current situation which is needed to make a correct decision is called the <strong>state</strong> (See Bellman, 1957, Ch. III.2).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> For example, to decide how much to consume and spend at each point in time, people would need to know (among other things) their initial wealth. Therefore, wealth would be one of their <strong><a href="state_variable" title="wikilink">state variables</a></strong>, but there would probably be others.</p>

<p>The variables chosen at any given point in time are often called the <strong><a href="control_variable" title="wikilink">control variables</a></strong>. For example, given their current wealth, people might decide how much to consume now. Choosing the control variables now may be equivalent to choosing the next state; more generally, the next state is affected by other factors in addition to the current control. For example, in the simplest case, today's wealth (the state) and consumption (the control) might exactly determine tomorrow's wealth (the new state), though typically other factors will affect tomorrow's wealth too.</p>

<p>The dynamic programming approach describes the optimal plan by finding a rule that tells what the controls should be, given any possible value of the state. For example, if consumption (<em>c</em>) depends <em>only</em> on wealth (<em>W</em>), we would seek a rule 

<math display="inline" id="Bellman_equation:0">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(W)
  </annotation>
 </semantics>
</math>

 that gives consumption as a function of wealth. Such a rule, determining the controls as a function of the states, is called a <strong>policy function</strong> (See Bellman, 1957, Ch. III.2).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Finally, by definition, the optimal decision rule is the one that achieves the best possible value of the objective. For example, if someone chooses consumption, given wealth, in order to maximize happiness (assuming happiness <em>H</em> can be represented by a mathematical function, such as a <a class="uri" href="utility" title="wikilink">utility</a> function), then each level of wealth will be associated with some highest possible level of happiness, 

<math display="inline" id="Bellman_equation:1">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(W)
  </annotation>
 </semantics>
</math>

. The best possible value of the objective, written as a function of the state, is called the <strong>value function</strong>.</p>

<p><a href="Richard_Bellman" title="wikilink">Richard Bellman</a> showed that a dynamic <a href="Optimization_(mathematics)" title="wikilink">optimization</a> problem in <a href="discrete_time" title="wikilink">discrete time</a> can be stated in a <a href="recursion" title="wikilink">recursive</a>, step-by-step form known as <a href="backward_induction" title="wikilink">backward induction</a> by writing down the relationship between the value function in one period and the value function in the next period. The relationship between these two value functions is called the <strong>Bellman equation</strong>. In this approach, the optimal policy in the last time period is specified in advance as a function of the state variable's value at that time, and the resulting optimal value of the objective function is thus expressed in terms of that value of the state variable. Next, the next-to-last period's optimization involves maximizing the sum of that period's period-specific objective function and the optimal value of the future objective function, giving that period's optimal policy contingent upon the value of the state variable as of the next-to-last period decision. This logic continues recursively back in time, until the first period decision rule is derived, as a function of the initial state variable value, by optimizing the sum of the first-period-specific objective function and the value of the second period's value function, which gives the value for all the future periods. Thus, each period's decision is made by explicitly acknowledging that all future sections will be optimally made.</p>
<h2 id="deriving-the-bellman-equation">Deriving the Bellman equation</h2>
<h3 id="a-dynamic-decision-problem">A dynamic decision problem</h3>

<p>Let the state at time 

<math display="inline" id="Bellman_equation:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 be 

<math display="inline" id="Bellman_equation:3">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}
  </annotation>
 </semantics>
</math>


. For a decision that begins at time 0, we take as given the initial state 

<math display="inline" id="Bellman_equation:4">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

. At any time, the set of possible actions depends on the current state; we can write this as 

<math display="inline" id="Bellman_equation:5">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>t</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>t</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}\in\Gamma(x_{t})
  </annotation>
 </semantics>
</math>

, where the action 

<math display="inline" id="Bellman_equation:6">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}
  </annotation>
 </semantics>
</math>

 represents one or more control variables. We also assume that the state changes from 

<math display="inline" id="Bellman_equation:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to a new state 

<math display="inline" id="Bellman_equation:8">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(x,a)
  </annotation>
 </semantics>
</math>


 when action 

<math display="inline" id="Bellman_equation:9">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is taken, and that the current payoff from taking action 

<math display="inline" id="Bellman_equation:10">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Bellman_equation:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Bellman_equation:12">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,a)
  </annotation>
 </semantics>
</math>

. Finally, we assume impatience, represented by a <a href="discount_factor" title="wikilink">discount factor</a> 

<math display="inline" id="Bellman_equation:13">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>β</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>β</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\beta<1
  </annotation>
 </semantics>
</math>


.</p>

<p>Under these assumptions, an infinite-horizon decision problem takes the following form:</p>

<p>

<math display="block" id="Bellman_equation:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo rspace="5.3pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo rspace="5.3pt">=</mo>
    <mrow>
     <munder>
      <mi>max</mi>
      <msubsup>
       <mrow>
        <mo>{</mo>
        <msub>
         <mi>a</mi>
         <mi>t</mi>
        </msub>
        <mo>}</mo>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
     </munder>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </munderover>
      <mrow>
       <msup>
        <mi>β</mi>
        <mi>t</mi>
       </msup>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>t</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>a</mi>
         <mi>t</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <set>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>t</ci>
         </apply>
        </set>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>β</ci>
        <ci>t</ci>
       </apply>
       <ci>F</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>t</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x_{0})\;=\;\max_{\left\{a_{t}\right\}_{t=0}^{\infty}}\sum_{t=0}^{\infty}%
\beta^{t}F(x_{t},a_{t}),
  </annotation>
 </semantics>
</math>

</p>

<p>subject to the constraints</p>

<p>

<math display="block" id="Bellman_equation:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>t</mi>
    </msub>
    <mo>∈</mo>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="5.3pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>=</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>t</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mi>t</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="5.3pt">,</mo>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>t</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>t</ci>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>t</ci>
      </apply>
      <list>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
       <ci>normal-…</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}\in\Gamma(x_{t}),\;x_{t+1}=T(x_{t},a_{t}),\;\forall t=0,1,2,\dots
  </annotation>
 </semantics>
</math>

</p>

<p>Notice that we have defined notation 

<math display="inline" id="Bellman_equation:16">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x_{0})
  </annotation>
 </semantics>
</math>

 to denote the optimal value that can be obtained by maximizing this objective function subject to the assumed constraints. This function is the <em>value function</em>. It is a function of the initial state variable 

<math display="inline" id="Bellman_equation:17">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

, since the best value obtainable depends on the initial situation.</p>
<h3 id="bellmans-principle-of-optimality">Bellman's Principle of Optimality</h3>

<p>The dynamic programming method breaks this decision problem into smaller subproblems. Richard Bellman's <strong>Principle of Optimality</strong> describes how to do this:</p>
<blockquote>

<p>Principle of Optimality: An optimal policy has the property that whatever the initial state and initial decision are, the remaining decisions must constitute an optimal policy with regard to the state resulting from the first decision. (See Bellman, 1957, Chap. III.3.)<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
</blockquote>

<p>In computer science, a problem that can be broken apart like this is said to have <a href="optimal_substructure" title="wikilink">optimal substructure</a>. In the context of dynamic <a href="game_theory" title="wikilink">game theory</a>, this principle is analogous to the concept of <a href="subgame_perfect_equilibrium" title="wikilink">subgame perfect equilibrium</a>, although what constitutes an optimal policy in this case is conditioned on the decision-maker's opponents choosing similarly optimal policies from their points of view.</p>

<p>As suggested by the Principle of Optimality, we will consider the first decision separately, setting aside all future decisions (we will start afresh from time 1 with the new state 

<math display="inline" id="Bellman_equation:18">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>


). Collecting the future decisions in brackets on the right, the previous problem is equivalent to:</p>

<p>

<math display="block" id="Bellman_equation:19">
 <semantics>
  <mrow>
   <munder>
    <mi>max</mi>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
   </munder>
   <mrow>
    <mo>{</mo>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>β</mi>
    <mrow>
     <mo>[</mo>
     <munder>
      <mi>max</mi>
      <msubsup>
       <mrow>
        <mo>{</mo>
        <msub>
         <mi>a</mi>
         <mi>t</mi>
        </msub>
        <mo>}</mo>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
     </munder>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <msup>
      <mi>β</mi>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mi>t</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mi>t</mi>
     </msub>
     <mo>∈</mo>
     <mi mathvariant="normal">Γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="5.3pt">,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>=</mo>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mi>t</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="5.3pt">,</mo>
     <mo>∀</mo>
     <mi>t</mi>
     <mo>≥</mo>
     <mn>1</mn>
     <mo>]</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">F</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <csymbol cd="unknown">β</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <set>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <ci>t</ci>
          </apply>
         </set>
         <apply>
          <eq></eq>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <csymbol cd="unknown">F</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>t</ci>
      </apply>
      <in></in>
      <csymbol cd="unknown">Γ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <eq></eq>
      <csymbol cd="unknown">T</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">t</csymbol>
      <geq></geq>
      <cn type="integer">1</cn>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{a_{0}}\left\{F(x_{0},a_{0})+\beta\left[\max_{\left\{a_{t}\right\}_{t=1}^%
{\infty}}\sum_{t=1}^{\infty}\beta^{t-1}F(x_{t},a_{t}):a_{t}\in\Gamma(x_{t}),\;%
x_{t+1}=T(x_{t},a_{t}),\;\forall t\geq 1\right]\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>subject to the constraints</p>

<p>

<math display="block" id="Bellman_equation:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo>∈</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="5.3pt">,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0}\in\Gamma(x_{0}),\;x_{1}=T(x_{0},a_{0}).
  </annotation>
 </semantics>
</math>

</p>

<p>Here we are choosing 

<math display="inline" id="Bellman_equation:21">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0}
  </annotation>
 </semantics>
</math>

, knowing that our choice will cause the time 1 state to be 

<math display="inline" id="Bellman_equation:22">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=T(x_{0},a_{0})
  </annotation>
 </semantics>
</math>

. That new state will then affect the decision problem from time 1 on. The whole future decision problem appears inside the square brackets on the right.</p>
<h3 id="the-bellman-equation">The Bellman equation</h3>

<p>So far it seems we have only made the problem uglier by separating today's decision from future decisions. But we can simplify by noticing that what is inside the square brackets on the right is <em>the value</em> of the time 1 decision problem, starting from state 

<math display="inline" id="Bellman_equation:23">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=T(x_{0},a_{0})
  </annotation>
 </semantics>
</math>

.</p>

<p>Therefore we can rewrite the problem as a <a href="Recursion" title="wikilink">recursive</a> definition of the value function:</p>

<p>

<math display="block" id="Bellman_equation:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mi>max</mi>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
    </munder>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>a</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>β</mi>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>F</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">0</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x_{0})=\max_{a_{0}}\{F(x_{0},a_{0})+\beta V(x_{1})\}
  </annotation>
 </semantics>
</math>

, subject to the constraints

<math display="block" id="Bellman_equation:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo>∈</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="5.3pt">,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0}\in\Gamma(x_{0}),\;x_{1}=T(x_{0},a_{0}).
  </annotation>
 </semantics>
</math>

</p>

<p>This is the Bellman equation. It can be simplified even further if we drop time subscripts and plug in the value of the next state:</p>

<p>

<math display="block" id="Bellman_equation:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mi>max</mi>
      <mrow>
       <mi>a</mi>
       <mo>∈</mo>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>β</mi>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>T</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>a</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <in></in>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>normal-Γ</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>F</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>a</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>T</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>a</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x)=\max_{a\in\Gamma(x)}\{F(x,a)+\beta V(T(x,a))\}.
  </annotation>
 </semantics>
</math>

</p>

<p>The Bellman equation is classified as a <a href="functional_equation" title="wikilink">functional equation</a>, because solving it means finding the unknown function <em>V</em>, which is the <em>value function</em>. Recall that the value function describes the best possible value of the objective, as a function of the state <em>x</em>. By calculating the value function, we will also find the function <em>a</em>(<em>x</em>) that describes the optimal action as a function of the state; this is called the <em>policy function</em>.</p>
<h3 id="the-bellman-equation-in-a-stochastic-problem">The Bellman equation in a stochastic problem</h3>

<p>In the deterministic setting, other techniques besides dynamic programming can be used to tackle the above <a href="optimal_control" title="wikilink">optimal control</a> problem. Although the agent has to account for the stochasticity, this approach becomes convenient for certain problems.</p>

<p>For a specific example from economics, consider an infinitely-lived consumer with initial wealth endowment <em>a<sub>0</sub></em> at period 0. He has an instantaneous <a href="utility_function" title="wikilink">utility function</a> <em>u</em>(<em>c</em>) where <em>c</em> denotes consumption and discounts the next period utility at a rate of 0t''} that solves</p>

<p>

<math display="block" id="Bellman_equation:27">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>t</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <msup>
      <mi>β</mi>
      <mi>t</mi>
     </msup>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>c</mi>
       <mi>t</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <max></max>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>t</ci>
      </apply>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\sum_{t=0}^{\infty}\beta^{t}u(c_{t})
  </annotation>
 </semantics>
</math>

</p>

<p>subject to</p>

<p>

<math display="block" id="Bellman_equation:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mi>r</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>a</mi>
         <mi>t</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>c</mi>
         <mi>t</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="5.3pt">,</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>t</mi>
     </msub>
     <mo>≥</mo>
     <mn>0</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>r</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>t</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t+1}=(1+r)(a_{t}-c_{t}),\;c_{t}\geq 0,
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Bellman_equation:29">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>t</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </munder>
    <msub>
     <mi>a</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>t</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{t\rightarrow\infty}a_{t}\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>The first constraint is the capital accumulation/law of motion specified by the problem, while the second constraint is a <a href="Transversality_(mathematics)" title="wikilink">transversality condition</a> that the consumer does not carry debt at the end of his life. The Bellman equation is</p>

<p>

<math display="block" id="Bellman_equation:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mi>max</mi>
      <mrow>
       <mn>0</mn>
       <mo>≤</mo>
       <mi>c</mi>
       <mo>≤</mo>
       <mi>a</mi>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mrow>
        <mi>u</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>β</mi>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mn>1</mn>
            <mo>+</mo>
            <mi>r</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>a</mi>
            <mo>-</mo>
            <mi>c</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <ci>c</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>V</ci>
       <apply>
        <times></times>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <ci>r</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>a</ci>
         <ci>c</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(a)=\max_{0\leq c\leq a}\{u(c)+\beta V((1+r)(a-c))\},
  </annotation>
 </semantics>
</math>

</p>

<p>Alternatively, one can treat the sequence problem directly using, for example, the <a href="Hamiltonian_equation" title="wikilink">Hamiltonian equations</a>.</p>

<p>Now, if the interest rate varies from period to period, the consumer is face with a stochastic optimization problem. Let the interest <em>r</em> follow a <a href="Markov_process" title="wikilink">Markov process</a> with probability transition function <em>Q</em>(<em>r</em>, <em>dμ<sub>r</sub></em>) where <em>dμ<sub>r</sub></em> denotes the <a href="probability_measure" title="wikilink">probability measure</a> governing the distribution of interest rate next period if current interest rate is <em>r</em>. The timing of the model is that the consumer decides his current period consumption after the current period interest rate is announced.</p>

<p>Rather than simply choosing a single sequence {<em>c<sub>t</sub></em>}, the consumer now must chose a sequence {<em>c<sub>t</sub></em>} for each possible realization of a {<em>r<sub>t</sub></em>} in such a way that his lifetime expected utility is maximized:</p>

<p>

<math display="block" id="Bellman_equation:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>max</mi>
     <mi>E</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </munderover>
      <mrow>
       <msup>
        <mi>β</mi>
        <mi>t</mi>
       </msup>
       <mi>u</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>c</mi>
         <mi>t</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <max></max>
     <ci>E</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>t</ci>
      </apply>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max E(\sum_{t=0}^{\infty}\beta^{t}u(c_{t})).
  </annotation>
 </semantics>
</math>

</p>

<p>The expectation <em>E</em> is taken with respect to the appropriate probability measure given by <em>Q</em> on the sequences of <em>r</em>'s. Because <em>r</em> is governed by a Markov process, dynamic programming simplifies the problem significantly. Then Bellmann equation is simply</p>

<p>

<math display="block" id="Bellman_equation:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mi>max</mi>
      <mrow>
       <mn>0</mn>
       <mo>≤</mo>
       <mi>c</mi>
       <mo>≤</mo>
       <mi>a</mi>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mrow>
        <mi>u</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>β</mi>
        <mrow>
         <mo largeop="true" symmetric="true">∫</mo>
         <mrow>
          <mi>V</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mn>1</mn>
              <mo>+</mo>
              <mi>r</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>a</mi>
              <mo>-</mo>
              <mi>c</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>,</mo>
           <msup>
            <mi>r</mi>
            <mo>′</mo>
           </msup>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>Q</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>r</mi>
           <mo>,</mo>
           <mrow>
            <mi>d</mi>
            <msub>
             <mi>μ</mi>
             <mi>r</mi>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>r</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <ci>c</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <times></times>
       <ci>β</ci>
       <apply>
        <int></int>
        <apply>
         <times></times>
         <ci>V</ci>
         <interval closure="open">
          <apply>
           <times></times>
           <apply>
            <plus></plus>
            <cn type="integer">1</cn>
            <ci>r</ci>
           </apply>
           <apply>
            <minus></minus>
            <ci>a</ci>
            <ci>c</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>r</ci>
           <ci>normal-′</ci>
          </apply>
         </interval>
         <ci>Q</ci>
         <interval closure="open">
          <ci>r</ci>
          <apply>
           <times></times>
           <ci>d</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>μ</ci>
            <ci>r</ci>
           </apply>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(a,r)=\max_{0\leq c\leq a}\{u(c)+\beta\int V((1+r)(a-c),r^{\prime})Q(r,d\mu_{%
r})\}.
  </annotation>
 </semantics>
</math>

</p>

<p>Under some reasonable assumption, the resulting optimal policy function <em>g</em>(<em>a</em>,<em>r</em>) is <a class="uri" href="measurable" title="wikilink">measurable</a>.</p>

<p>For a general stochastic sequential optimization problem with Markovian shocks and where the agent is faced with his decision <em><a class="uri" href="ex-post" title="wikilink">ex-post</a></em>, the Bellmann equation takes a very similar form</p>

<p>

<math display="block" id="Bellman_equation:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <munder>
        <mi>max</mi>
        <mrow>
         <mi>c</mi>
         <mo>∈</mo>
         <mrow>
          <mi mathvariant="normal">Γ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>z</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </munder>
       <mi>F</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>c</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>β</mi>
      <mrow>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>T</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>c</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>,</mo>
         <msup>
          <mi>z</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <msub>
         <mi>μ</mi>
         <mi>z</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>z</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>z</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <max></max>
        <apply>
         <in></in>
         <ci>c</ci>
         <apply>
          <times></times>
          <ci>normal-Γ</ci>
          <interval closure="open">
           <ci>x</ci>
           <ci>z</ci>
          </interval>
         </apply>
        </apply>
       </apply>
       <ci>F</ci>
      </apply>
      <vector>
       <ci>x</ci>
       <ci>c</ci>
       <ci>z</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <apply>
       <int></int>
       <apply>
        <times></times>
        <ci>V</ci>
        <interval closure="open">
         <apply>
          <times></times>
          <ci>T</ci>
          <interval closure="open">
           <ci>x</ci>
           <ci>c</ci>
          </interval>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <ci>normal-′</ci>
         </apply>
        </interval>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x,z)=\max_{c\in\Gamma(x,z)}F(x,c,z)+\beta\int V(T(x,c),z^{\prime})d\mu_{z}(z%
^{\prime}).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="solution-methods">Solution methods</h2>
<ul>
<li>The <a href="method_of_undetermined_coefficients" title="wikilink">method of undetermined coefficients</a>, also known as 'guess and verify', can be used to solve some infinite-horizon, <a href="Autonomous_system_(mathematics)" title="wikilink">autonomous</a> Bellman equations.</li>
</ul>
<ul>
<li>The Bellman equation can be solved by <a href="backwards_induction" title="wikilink">backwards induction</a>, either <a href="Closed-form_expression" title="wikilink">analytically</a> in a few special cases, or <a href="numerical_analysis" title="wikilink">numerically</a> on a computer. Numerical backwards induction is applicable to a wide variety of problems, but may be infeasible when there are many state variables, due to the <a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a>. Approximate dynamic programming has been introduced by <a href="Dimitri_Bertsekas" title="wikilink">D. P. Bertsekas</a> and J. N. Tsitsiklis with the use of <a href="artificial_neural_network" title="wikilink">artificial neural networks</a> (<a href="multilayer_perceptron" title="wikilink">multilayer perceptrons</a>) for approximating the Bellman function.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> This is an effective mitigation strategy for reducing the impact of dimensionality by replacing the memorization of the complete function mapping for the whole space domain with the memorization of the sole neural network parameters.</li>
</ul>
<ul>
<li>By calculating the first-order conditions associated with the Bellman equation, and then using the <a href="envelope_theorem" title="wikilink">envelope theorem</a> to eliminate the derivatives of the value function, it is possible to obtain a system of <a href="difference_equation" title="wikilink">difference equations</a> or <a href="differential_equation" title="wikilink">differential equations</a> called the '<a href="Euler–Lagrange_equation" title="wikilink">Euler equations</a>'. Standard techniques for the solution of difference or differential equations can then be used to calculate the dynamics of the state variables and the control variables of the optimization problem.</li>
</ul>
<h2 id="applications-in-economics">Applications in economics</h2>

<p>The first known application of a Bellman equation in economics is due to <a href="Martin_Beckmann" title="wikilink">Martin Beckmann</a> and <a href="Richard_Muth" title="wikilink">Richard Muth</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Martin Beckmann also wrote extensively on consumption theory using the Bellman equation in 1959. His work influenced <a href="Edmund_S._Phelps" title="wikilink">Edmund S. Phelps</a>, among others.</p>

<p>A celebrated economic application of a Bellman equation is <a href="Robert_C._Merton" title="wikilink">Robert C. Merton</a>'s seminal 1973 article on the <a href="ICAPM" title="wikilink">intertemporal capital asset pricing model</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> (See also <a href="Merton's_portfolio_problem" title="wikilink">Merton's portfolio problem</a>).The solution to Merton's theoretical model, one in which investors chose between income today and future income or capital gains, is a form of Bellman's equation. Because economic applications of dynamic programming usually result in a Bellman equation that is a <a href="difference_equation" title="wikilink">difference equation</a>, economists refer to dynamic programming as a "recursive method" and a subfield of <a href="recursive_economics" title="wikilink">recursive economics</a> is now recognized within Economics.</p>

<p><a href="Nancy_Stokey" title="wikilink">Nancy Stokey</a>, <a href="Robert_E._Lucas" title="wikilink">Robert E. Lucas</a>, and <a href="Edward_Prescott" title="wikilink">Edward Prescott</a> describe stochastic and nonstochastic dynamic programming in considerable detail, and develop theorems for the existence of solutions to problems meeting certain conditions. They also describe many examples of modeling theoretical problems in economics using recursive methods.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This book led to dynamic programming being employed to solve a wide range of theoretical problems in economics, including optimal <a href="economic_growth" title="wikilink">economic growth</a>, <a href="resource_extraction" title="wikilink">resource extraction</a>, <a href="principal–agent_problem" title="wikilink">principal–agent problems</a>, <a href="public_finance" title="wikilink">public finance</a>, business <a class="uri" href="investment" title="wikilink">investment</a>, <a href="asset_pricing" title="wikilink">asset pricing</a>, <a href="factor_of_production" title="wikilink">factor</a> supply, and <a href="industrial_organization" title="wikilink">industrial organization</a>. <a href="Lars_Ljungqvist" title="wikilink">Lars Ljungqvist</a> and <a href="Thomas_Sargent" title="wikilink">Thomas Sargent</a> apply dynamic programming to study a variety of theoretical questions in <a href="monetary_policy" title="wikilink">monetary policy</a>, <a href="fiscal_policy" title="wikilink">fiscal policy</a>, <a class="uri" href="taxation" title="wikilink">taxation</a>, <a href="economic_growth" title="wikilink">economic growth</a>, <a href="search_theory" title="wikilink">search theory</a>, and <a href="labor_economics" title="wikilink">labor economics</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> <a href="Avinash_Dixit" title="wikilink">Avinash Dixit</a> and <a href="Robert_Pindyck" title="wikilink">Robert Pindyck</a> showed the value of the method for thinking about <a href="capital_budgeting" title="wikilink">capital budgeting</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Anderson adapted the technique to business valuation, including privately held businesses.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Using dynamic programming to solve concrete problems is complicated by informational difficulties, such as choosing the unobservable discount rate. There are also computational issues, the main one being the <a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a> arising from the vast number of possible actions and potential state variables that must be considered before an optimal strategy can be selected. For an extensive discussion of computational issues, see Miranda and Fackler,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> and Meyn 2007.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="example">Example</h2>

<p>In <a href="Markov_decision_process" title="wikilink">MDP</a>, a Bellman equation refers to a <a class="uri" href="recursion" title="wikilink">recursion</a> for expected rewards. For example, the expected reward for being in a particular state <em>s</em> and following some fixed policy 

<math display="inline" id="Bellman_equation:34">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 has the Bellman equation:</p>

<p>

<math display="block" id="Bellman_equation:35">
 <semantics>
  <mrow>
   <msup>
    <mi>V</mi>
    <mi>π</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>γ</mi>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>V</mi>
    <mi>π</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>π</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">π</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">π</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>π</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\pi}(s)=R(s,\pi(s))+\gamma\sum_{s^{\prime}}P(s^{\prime}|s,\pi(s))V^{\pi}(s^%
{\prime}).
  </annotation>
 </semantics>
</math>

</p>

<p>This equation describes the expected reward for taking the action prescribed by some policy 

<math display="inline" id="Bellman_equation:36">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

.</p>

<p>The equation for the optimal policy is referred to as the <em>Bellman optimality equation</em>:</p>

<p>

<math display="block" id="Bellman_equation:37">
 <semantics>
  <mrow>
   <msup>
    <mi>V</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mi>max</mi>
    <mi>a</mi>
   </munder>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>γ</mi>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>V</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <times></times>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <ci>a</ci>
    </apply>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">γ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <times></times>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{*}(s)=\max_{a}R(s,a)+\gamma\sum_{s^{\prime}}P(s^{\prime}|s,a)V^{*}(s^{%
\prime}).
  </annotation>
 </semantics>
</math>

</p>

<p>It describes the reward for taking the action giving the highest expected return.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Dynamic_programming" title="wikilink">Dynamic programming</a></li>
<li><a href="Hamilton–Jacobi–Bellman_equation" title="wikilink">Hamilton–Jacobi–Bellman equation</a></li>
<li><a href="Markov_decision_process" title="wikilink">Markov decision process</a></li>
<li><a href="Optimal_control_theory" title="wikilink">Optimal control theory</a></li>
<li><a href="Optimal_substructure" title="wikilink">Optimal substructure</a></li>
<li><a href="Recursive_competitive_equilibrium" title="wikilink">Recursive competitive equilibrium</a></li>
<li><a href="Bellman_pseudospectral_method" title="wikilink">Bellman pseudospectral method</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a class="uri" href="Category:Equations" title="wikilink">Category:Equations</a> <a href="Category:Dynamic_programming" title="wikilink">Category:Dynamic programming</a> <a href="Category:Control_theory" title="wikilink">Category:Control theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Bellman, R.E. 1957. <em>Dynamic Programming</em>. Princeton University Press, Princeton, NJ. Republished 2003: Dover, ISBN 0-486-42809-5.<a href="#fnref1">↩</a></li>
<li id="fn2">S. Dreyfus (2002), <a href="http://www.wu-wien.ac.at/usr/h99c/h9951826/bellman_dynprog.pdf">'Richard Bellman on the birth of dynamic programming'</a> <em>Operations Research</em> 50 (1), pp. 48–51.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6">R Bellman, <em>On the Theory of Dynamic Programming</em>, Proceedings of the National Academy of Sciences, 1952<a href="#fnref6">↩</a></li>
<li id="fn7">Bertsekas, D. P., Tsitsiklis, J. N., <em>Neuro-dynamic programming</em>. Athena Scientific, 1996<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">Anderson, Patrick L., Business Economics &amp; Finance, CRC Press, 2004 (chapter 10), ISBN 1-58488-348-0; The Value of Private Businesses in the United States, <em>Business Economics</em> (2009) 44, 87–108. . <em>Economics of Business Valuation</em>, Stanford University Press (2013); ISBN 9780804758307. <a href="http://www.sup.org/book.cgi?id=11400">Stanford Press</a><a href="#fnref13">↩</a></li>
<li id="fn14">Miranda, M., &amp; Fackler, P., 2002. <em>Applied Computational Economics and Finance</em>. MIT Press<a href="#fnref14">↩</a></li>
<li id="fn15">S. P. Meyn, 2007. <a href="http://decision.csl.uiuc.edu/~meyn/pages/CTCN/CTCN.html">Control Techniques for Complex Networks</a>, Cambridge University Press, 2007. Appendix contains abridged <a href="http://decision.csl.uiuc.edu/~meyn/pages/book.html">Meyn &amp; Tweedie</a>.<a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
