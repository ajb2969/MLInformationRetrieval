<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="205">Representer theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Representer theorem</h1>
<hr/>

<p>In <a href="Computational_learning_theory" title="wikilink">statistical learning theory</a>, a <strong>representer theorem</strong> is any of several related results stating that a minimizer 

<math display="inline" id="Representer_theorem:0">
 <semantics>
  <msup>
   <mi>f</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}
  </annotation>
 </semantics>
</math>

 of a regularized <a href="Empirical_risk_minimization" title="wikilink">empirical risk function</a> defined over a <a href="reproducing_kernel_Hilbert_space" title="wikilink">reproducing kernel Hilbert space</a> can be represented as a finite linear combination of kernel products evaluated on the input points in the training set data.</p>
<h2 id="formal-statement">Formal Statement</h2>

<p>The following Representer Theorem and its proof are due to <a href="Bernhard_Sch√∂lkopf" title="wikilink">Sch√∂lkopf</a>, Herbrich, and Smola:</p>

<p><strong>Theorem:</strong> Let 

<math display="inline" id="Representer_theorem:1">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùí≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}
  </annotation>
 </semantics>
</math>

 be a nonempty set and 

<math display="inline" id="Representer_theorem:2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 a positive-definite real-valued kernel on 

<math display="inline" id="Representer_theorem:3">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
   <mo>√ó</mo>
   <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùí≥</ci>
    <ci>ùí≥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}\times\mathcal{X}
  </annotation>
 </semantics>
</math>

 with corresponding reproducing kernel Hilbert space 

<math display="inline" id="Representer_theorem:4">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}
  </annotation>
 </semantics>
</math>

. Given a training sample 

<math display="inline" id="Representer_theorem:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
    <mo>√ó</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <ci>normal-‚Ä¶</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </list>
    <apply>
     <times></times>
     <ci>ùí≥</ci>
     <mtext>\R</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1}),\ldots,(x_{n},y_{n})\in\mathcal{X}\times\R
  </annotation>
 </semantics>
</math>

, a strictly monotonically increasing real-valued function 

<math display="inline" id="Representer_theorem:6">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">‚àû</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>‚Üí</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <interval closure="closed-open">
      <cn type="integer">0</cn>
      <infinity></infinity>
     </interval>
     <mtext>\R</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\colon[0,\infty)\to\R
  </annotation>
 </semantics>
</math>

, and an arbitrary empirical risk function 

<math display="inline" id="Representer_theorem:7">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
       <mo>√ó</mo>
       <msup>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\R</mtext>
        </merror>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
    <mo>‚Üí</mo>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\R</mtext>
     </merror>
     <mo>‚à™</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi mathvariant="normal">‚àû</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>E</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>ùí≥</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <mtext>\R</mtext>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <union></union>
      <mtext>\R</mtext>
      <set>
       <infinity></infinity>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\colon(\mathcal{X}\times\R^{2})^{n}\to\R\cup\{\infty\}
  </annotation>
 </semantics>
</math>

, then for any 

<math display="inline" id="Representer_theorem:8">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>*</mo>
   </msup>
   <mo>‚àà</mo>
   <msub>
    <mi>H</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}\in H_{k}
  </annotation>
 </semantics>
</math>

 satisfying</p>

<p>

<math display="block" id="Representer_theorem:9">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>argmin</mo>
      <mrow>
       <mi>f</mi>
       <mo>‚àà</mo>
       <msub>
        <mi>H</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </msub>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mn>1</mn>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>,</mo>
         <mi mathvariant="normal">‚Ä¶</mi>
         <mo>,</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>n</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mi>n</mi>
          </msub>
          <mo>,</mo>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>n</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mo fence="true">‚à•</mo>
          <mi>f</mi>
          <mo fence="true">‚à•</mo>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>*</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
    <list>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>argmin</ci>
       <apply>
        <in></in>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>E</ci>
        <vector>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </vector>
         <ci>normal-‚Ä¶</ci>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>n</ci>
           </apply>
          </apply>
         </vector>
        </vector>
       </apply>
       <apply>
        <times></times>
        <ci>g</ci>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>f</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <times></times>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}=\operatorname{argmin}_{f\in H_{k}}\left\{E\left((x_{1},y_{1},f(x_{1})),.%
..,(x_{n},y_{n},f(x_{n}))\right)+g\left(\lVert f\rVert\right)\right\},\quad(*)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Representer_theorem:10">
 <semantics>
  <msup>
   <mi>f</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}
  </annotation>
 </semantics>
</math>

 admits a representation of the form:</p>

<p>

<math display="block" id="Representer_theorem:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>‚ãÖ</mo>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>Œ±</mi>
       <mi>i</mi>
      </msub>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>‚ãÖ</mo>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <times></times>
     </apply>
     <ci>normal-‚ãÖ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œ±</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
      <interval closure="open">
       <ci>normal-‚ãÖ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}(\cdot)=\sum_{i=1}^{n}\alpha_{i}k(\cdot,x_{i}),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Representer_theorem:12">
 <semantics>
  <mrow>
   <msub>
    <mi>Œ±</mi>
    <mi>i</mi>
   </msub>
   <mo>‚àà</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œ±</ci>
     <ci>i</ci>
    </apply>
    <mtext>\R</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}\in\R
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Representer_theorem:13">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>‚â§</mo>
   <mi>i</mi>
   <mo>‚â§</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq n
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Proof:</strong> Define a mapping</p>

<p>

<math display="inline" id="Representer_theorem:14">
 <semantics>
  <mrow>
   <mi>œÜ</mi>
   <mo>:</mo>
   <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>œÜ</ci>
    <ci>ùí≥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\varphi\colon\mathcal{X}
  </annotation>
 </semantics>
</math>


</p>

<p>(so that 

<math display="inline" id="Representer_theorem:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>œÜ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>‚ãÖ</mo>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>œÜ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>normal-‚ãÖ</ci>
      <ci>x</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(x)=k(\cdot,x)
  </annotation>
 </semantics>
</math>

 is itself a map 

<math display="inline" id="Representer_theorem:16">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
   <mo>‚Üí</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <ci>ùí≥</ci>
    <mtext>\R</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}\to\R
  </annotation>
 </semantics>
</math>

). Since 

<math display="inline" id="Representer_theorem:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is reproducing kernel, then</p>

<p>

<math display="block" id="Representer_theorem:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>œÜ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>‚Ä≤</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>‚Ä≤</mo>
      </msup>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">‚ü®</mo>
     <mrow>
      <mi>œÜ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>‚Ä≤</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>œÜ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">‚ü©</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>œÜ</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
       <ci>x</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <times></times>
       <ci>œÜ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>œÜ</ci>
       <ci>x</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(x)(x^{\prime})=k(x^{\prime},x)=\langle\varphi(x^{\prime}),\varphi(x)\rangle,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Representer_theorem:19">
 <semantics>
  <mrow>
   <mo stretchy="false">‚ü®</mo>
   <mo>‚ãÖ</mo>
   <mo>,</mo>
   <mo>‚ãÖ</mo>
   <mo stretchy="false">‚ü©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-‚ãÖ</ci>
    <ci>normal-‚ãÖ</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle
  </annotation>
 </semantics>
</math>

 is the inner product on 

<math display="inline" id="Representer_theorem:20">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}
  </annotation>
 </semantics>
</math>

.</p>

<p>Given any 

<math display="inline" id="Representer_theorem:21">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},...,x_{n}
  </annotation>
 </semantics>
</math>

, one can use orthogonal projection to decompose any 

<math display="inline" id="Representer_theorem:22">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>‚àà</mo>
   <msub>
    <mi>H</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in H_{k}
  </annotation>
 </semantics>
</math>

 into a sum of two function, one lying in 

<math display="inline" id="Representer_theorem:23">
 <semantics>
  <mrow>
   <mo>span</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>œÜ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mrow>
     <mi>œÜ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>span</ci>
    <apply>
     <times></times>
     <ci>œÜ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <times></times>
     <ci>œÜ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{span}\left\{\varphi(x_{1}),...,\varphi(x_{n})\right\}
  </annotation>
 </semantics>
</math>

, and the other lying in the orthogonal complement:</p>

<p>

<math display="block" id="Representer_theorem:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>Œ±</mi>
        <mi>i</mi>
       </msub>
       <mi>œÜ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œ±</ci>
        <ci>i</ci>
       </apply>
       <ci>œÜ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\sum_{i=1}^{n}\alpha_{i}\varphi(x_{i})+v,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Representer_theorem:25">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">‚ü®</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mrow>
     <mi>œÜ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">‚ü©</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>v</ci>
     <apply>
      <times></times>
      <ci>œÜ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle v,\varphi(x_{i})\rangle=0
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Representer_theorem:26">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

.</p>

<p>The above orthogonal decomposition and the <a href="Reproducing_kernel_Hilbert_space#The_Reproducing_Property" title="wikilink">reproducing property</a> together show that applying 

<math display="inline" id="Representer_theorem:27">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 to any training point 

<math display="inline" id="Representer_theorem:28">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 produces</p>

<p>

<math display="block" id="Representer_theorem:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>‚ü®</mo>
     <mrow>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <msub>
         <mi>Œ±</mi>
         <mi>i</mi>
        </msub>
        <mi>œÜ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>v</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>œÜ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>‚ü©</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>Œ±</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">‚ü®</mo>
       <mrow>
        <mi>œÜ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>œÜ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">‚ü©</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <list>
      <apply>
       <plus></plus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Œ±</ci>
          <ci>i</ci>
         </apply>
         <ci>œÜ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <ci>v</ci>
      </apply>
      <apply>
       <times></times>
       <ci>œÜ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œ±</ci>
        <ci>i</ci>
       </apply>
       <list>
        <apply>
         <times></times>
         <ci>œÜ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>œÜ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{j})=\left\langle\sum_{i=1}^{n}\alpha_{i}\varphi(x_{i})+v,\varphi(x_{j})%
\right\rangle=\sum_{i=1}^{n}\alpha_{i}\langle\varphi(x_{i}),\varphi(x_{j})\rangle,
  </annotation>
 </semantics>
</math>

</p>

<p>which we observe is independent of 

<math display="inline" id="Representer_theorem:30">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. Consequently, the value of the empirical risk 

<math display="inline" id="Representer_theorem:31">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 in (*) is likewise independent of 

<math display="inline" id="Representer_theorem:32">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. For the second term (the regularization term), since 

<math display="inline" id="Representer_theorem:33">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is orthogonal to 

<math display="inline" id="Representer_theorem:34">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">‚àë</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <msub>
     <mi>Œ±</mi>
     <mi>i</mi>
    </msub>
    <mi>œÜ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œ±</ci>
      <ci>i</ci>
     </apply>
     <ci>œÜ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}\alpha_{i}\varphi(x_{i})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Representer_theorem:35">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is strictly monotonic, we have</p>

<p>

<math display="inline" id="Representer_theorem:36">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo fence="true">‚à•</mo>
     <mi>f</mi>
     <mo fence="true">‚à•</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle g\left(\lVert f\rVert\right)
  </annotation>
 </semantics>
</math>


</p>

<p>Therefore setting 

<math display="inline" id="Representer_theorem:37">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=0
  </annotation>
 </semantics>
</math>

 does not affect the first term of (*), while it strictly decreasing the second term. Consequently, any minimizer 

<math display="inline" id="Representer_theorem:38">
 <semantics>
  <msup>
   <mi>f</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}
  </annotation>
 </semantics>
</math>

 in (*) must have 

<math display="inline" id="Representer_theorem:39">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=0
  </annotation>
 </semantics>
</math>

, i.e., it must be of the form</p>

<p>

<math display="block" id="Representer_theorem:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>‚ãÖ</mo>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>Œ±</mi>
       <mi>i</mi>
      </msub>
      <mi>œÜ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>Œ±</mi>
       <mi>i</mi>
      </msub>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>‚ãÖ</mo>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <times></times>
      </apply>
      <ci>normal-‚ãÖ</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œ±</ci>
        <ci>i</ci>
       </apply>
       <ci>œÜ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œ±</ci>
        <ci>i</ci>
       </apply>
       <ci>k</ci>
       <interval closure="open">
        <ci>normal-‚ãÖ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}(\cdot)=\sum_{i=1}^{n}\alpha_{i}\varphi(x_{i})=\sum_{i=1}^{n}\alpha_{i}k(%
\cdot,x_{i}),
  </annotation>
 </semantics>
</math>

</p>

<p>which is the desired result.</p>
<h2 id="generalizations">Generalizations</h2>

<p>The Theorem stated above is a particular example of a family of results that are collectively referred to as "Representer Theorems"; here we describe several such.</p>

<p>The first statement of a Representer Theorem was due to Kimeldorf and Wahba for the special case in which</p>

<p>

<math display="inline" id="Representer_theorem:41">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <vector>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
     <ci>normal-‚Ä¶</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </vector>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle E\left((x_{1},y_{1},f(x_{1})),...,(x_{n},y_{n},f(x_{n}))\right)
  </annotation>
 </semantics>
</math>


</p>

<p>for 

<math display="inline" id="Representer_theorem:42">
 <semantics>
  <mrow>
   <mi>Œª</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>Œª</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda>0
  </annotation>
 </semantics>
</math>

. Sch√∂lkopf, Herbrich, and Smola generalized this result by relaxing the assumption of the squared-loss cost and allowing the regularizer to be any strictly monotonically increasing function 

<math display="inline" id="Representer_theorem:43">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>‚ãÖ</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>normal-‚ãÖ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\cdot)
  </annotation>
 </semantics>
</math>

 of the Hilbert space norm.</p>

<p>It is possible to generalize further by augmenting the regularized empirical risk function through the addition of unpenalized offset terms. For example, Sch√∂lkopf, Herbrich, and Smola also consider the minimization</p>

<p>

<math display="block" id="Representer_theorem:44">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>argmin</mo>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <mrow>
           <mover accent="true">
            <mi>f</mi>
            <mo stretchy="false">~</mo>
           </mover>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mn>1</mn>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>,</mo>
         <mi mathvariant="normal">‚Ä¶</mi>
         <mo>,</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>n</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mi>n</mi>
          </msub>
          <mo>,</mo>
          <mrow>
           <mover accent="true">
            <mi>f</mi>
            <mo stretchy="false">~</mo>
           </mover>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>n</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mo fence="true">‚à•</mo>
          <mi>f</mi>
          <mo fence="true">‚à•</mo>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>‚à£</mo>
      <mrow>
       <mover accent="true">
        <mi>f</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mo>=</mo>
       <mrow>
        <mi>f</mi>
        <mo>+</mo>
        <mi>h</mi>
       </mrow>
       <mo>‚àà</mo>
       <mrow>
        <msub>
         <mi>H</mi>
         <mi>k</mi>
        </msub>
        <mo>‚äï</mo>
        <mrow>
         <mo>span</mo>
         <mrow>
          <mo stretchy="false">{</mo>
          <msub>
           <mi>œà</mi>
           <mi>p</mi>
          </msub>
          <mo>‚à£</mo>
          <mrow>
           <mn>1</mn>
           <mo>‚â§</mo>
           <mi>p</mi>
           <mo>‚â§</mo>
           <mi>M</mi>
          </mrow>
          <mo stretchy="false">}</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>‚Ä†</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>f</ci>
     </apply>
     <times></times>
    </apply>
    <list>
     <apply>
      <ci>argmin</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>E</ci>
        <vector>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <times></times>
           <apply>
            <ci>normal-~</ci>
            <ci>f</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </vector>
         <ci>normal-‚Ä¶</ci>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <ci>normal-~</ci>
            <ci>f</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>n</ci>
           </apply>
          </apply>
         </vector>
        </vector>
       </apply>
       <apply>
        <times></times>
        <ci>g</ci>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>f</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <eq></eq>
        <apply>
         <ci>normal-~</ci>
         <ci>f</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>f</ci>
         <ci>h</ci>
        </apply>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <apply>
         <csymbol cd="latexml">direct-sum</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <ci>span</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>œà</ci>
           <ci>p</ci>
          </apply>
          <apply>
           <and></and>
           <apply>
            <leq></leq>
            <cn type="integer">1</cn>
            <ci>p</ci>
           </apply>
           <apply>
            <leq></leq>
            <share href="#.cmml">
            </share>
            <ci>M</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>normal-‚Ä†</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}^{*}=\operatorname{argmin}\left\{E\left((x_{1},y_{1},\tilde{f}(x_{1})%
),...,(x_{n},y_{n},\tilde{f}(x_{n}))\right)+g\left(\lVert f\rVert\right)\mid%
\tilde{f}=f+h\in H_{k}\oplus\operatorname{span}\{\psi_{p}\mid 1\leq p\leq M\}%
\right\},\quad(\dagger)
  </annotation>
 </semantics>
</math>

</p>

<p>i.e., we consider functions of the form 

<math display="inline" id="Representer_theorem:45">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mo>+</mo>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>f</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}=f+h
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Representer_theorem:46">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>‚àà</mo>
   <msub>
    <mi>H</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in H_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Representer_theorem:47">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is an unpenalized function lying in the span of a finite set of real-valued functions 

<math display="inline" id="Representer_theorem:48">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>œà</mi>
    <mi>p</mi>
   </msub>
   <mo>:</mo>
   <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
   <mo>‚Üí</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
   <mo>‚à£</mo>
   <mn>1</mn>
   <mo>‚â§</mo>
   <mi>p</mi>
   <mo>‚â§</mo>
   <mi>M</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œà</ci>
     <ci>p</ci>
    </apply>
    <ci>normal-:</ci>
    <csymbol cd="unknown">X</csymbol>
    <ci>normal-‚Üí</ci>
    <mtext>\R</mtext>
    <ci>normal-‚à£</ci>
    <cn type="integer">1</cn>
    <leq></leq>
    <csymbol cd="unknown">p</csymbol>
    <leq></leq>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\psi_{p}\colon\mathcal{X}\to\R\mid 1\leq p\leq M\}
  </annotation>
 </semantics>
</math>

. Under the assumption that the 

<math display="inline" id="Representer_theorem:49">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>√ó</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times M
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Representer_theorem:50">
 <semantics>
  <msub>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msub>
      <mi>œà</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mi>p</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œà</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\psi_{p}(x_{i})\right)_{ip}
  </annotation>
 </semantics>
</math>

 has rank 

<math display="inline" id="Representer_theorem:51">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, they show that the minimizer 

<math display="inline" id="Representer_theorem:52">
 <semantics>
  <msup>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>f</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}^{*}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Representer_theorem:53">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>‚Ä†</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚Ä†</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\dagger)
  </annotation>
 </semantics>
</math>

 admits a representation of the form</p>

<p>

<math display="block" id="Representer_theorem:54">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>‚ãÖ</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>Œ±</mi>
       <mi>i</mi>
      </msub>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>‚ãÖ</mo>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>p</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>M</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>Œ≤</mi>
       <mi>p</mi>
      </msub>
      <msub>
       <mi>œà</mi>
       <mi>p</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>‚ãÖ</mo>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>f</ci>
      </apply>
      <times></times>
     </apply>
     <ci>normal-‚ãÖ</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œ±</ci>
        <ci>i</ci>
       </apply>
       <ci>k</ci>
       <interval closure="open">
        <ci>normal-‚ãÖ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œ≤</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>œà</ci>
        <ci>p</ci>
       </apply>
       <ci>normal-‚ãÖ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}^{*}(\cdot)=\sum_{i=1}^{n}\alpha_{i}k(\cdot,x_{i})+\sum_{p=1}^{M}%
\beta_{p}\psi_{p}(\cdot)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Representer_theorem:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Œ±</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>Œ≤</mi>
     <mi>p</mi>
    </msub>
   </mrow>
   <mo>‚àà</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œ±</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œ≤</ci>
      <ci>p</ci>
     </apply>
    </list>
    <mtext>\R</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i},\beta_{p}\in\R
  </annotation>
 </semantics>
</math>

 and the 

<math display="inline" id="Representer_theorem:56">
 <semantics>
  <msub>
   <mi>Œ≤</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œ≤</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{p}
  </annotation>
 </semantics>
</math>

 are all uniquely determined.</p>

<p>The conditions under which a Representer Theorem exists were investigated by Argyriou, Miccheli, and Pontil, who proved the following:</p>

<p><strong>Theorem:</strong> Let 

<math display="inline" id="Representer_theorem:57">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùí≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}
  </annotation>
 </semantics>
</math>

 be a nonempty set, 

<math display="inline" id="Representer_theorem:58">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 a positive-definite real-valued kernel on 

<math display="inline" id="Representer_theorem:59">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
   <mo>√ó</mo>
   <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùí≥</ci>
    <ci>ùí≥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}\times\mathcal{X}
  </annotation>
 </semantics>
</math>

 with corresponding reproducing kernel Hilbert space 

<math display="inline" id="Representer_theorem:60">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Representer_theorem:61">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>k</mi>
    </msub>
    <mo>‚Üí</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>R</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <mtext>\R</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\colon H_{k}\to\R
  </annotation>
 </semantics>
</math>

 be a differentiable regularization function. Then given a training sample 

<math display="inline" id="Representer_theorem:62">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
    <mo>√ó</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <ci>normal-‚Ä¶</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </list>
    <apply>
     <times></times>
     <ci>ùí≥</ci>
     <mtext>\R</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1}),...,(x_{n},y_{n})\in\mathcal{X}\times\R
  </annotation>
 </semantics>
</math>

 and an arbitrary empirical risk function 

<math display="inline" id="Representer_theorem:63">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
       <mo>√ó</mo>
       <msup>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\R</mtext>
        </merror>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>m</mi>
    </msup>
    <mo>‚Üí</mo>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\R</mtext>
     </merror>
     <mo>‚à™</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi mathvariant="normal">‚àû</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>E</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>ùí≥</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <mtext>\R</mtext>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <union></union>
      <mtext>\R</mtext>
      <set>
       <infinity></infinity>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\colon(\mathcal{X}\times\R^{2})^{m}\to\R\cup\{\infty\}
  </annotation>
 </semantics>
</math>

, a minimizer</p>

<p>

<math display="block" id="Representer_theorem:64">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>argmin</mo>
      <mrow>
       <mi>f</mi>
       <mo>‚àà</mo>
       <msub>
        <mi>H</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </msub>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mn>1</mn>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>,</mo>
         <mi mathvariant="normal">‚Ä¶</mi>
         <mo>,</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>n</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mi>n</mi>
          </msub>
          <mo>,</mo>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>n</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>R</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>f</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>‚Ä°</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
    <list>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>argmin</ci>
       <apply>
        <in></in>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>E</ci>
        <vector>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </vector>
         <ci>normal-‚Ä¶</ci>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>n</ci>
           </apply>
          </apply>
         </vector>
        </vector>
       </apply>
       <apply>
        <times></times>
        <ci>R</ci>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
     <ci>normal-‚Ä°</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}=\operatorname{argmin}_{f\in H_{k}}\left\{E\left((x_{1},y_{1},f(x_{1})),.%
..,(x_{n},y_{n},f(x_{n}))\right)+R(f)\right\}\quad(\ddagger)
  </annotation>
 </semantics>
</math>

</p>

<p>of the regularized empirical risk minimization problem admits a representation of the form</p>

<p>

<math display="block" id="Representer_theorem:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>‚ãÖ</mo>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>Œ±</mi>
       <mi>i</mi>
      </msub>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>‚ãÖ</mo>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <times></times>
     </apply>
     <ci>normal-‚ãÖ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œ±</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
      <interval closure="open">
       <ci>normal-‚ãÖ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}(\cdot)=\sum_{i=1}^{n}\alpha_{i}k(\cdot,x_{i}),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Representer_theorem:66">
 <semantics>
  <mrow>
   <msub>
    <mi>Œ±</mi>
    <mi>i</mi>
   </msub>
   <mo>‚àà</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œ±</ci>
     <ci>i</ci>
    </apply>
    <mtext>\R</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}\in\R
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Representer_theorem:67">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>‚â§</mo>
   <mi>i</mi>
   <mo>‚â§</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq n
  </annotation>
 </semantics>
</math>

, if and only if there exists a nondecreasing function 

<math display="inline" id="Representer_theorem:68">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">‚àû</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>‚Üí</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <interval closure="closed-open">
      <cn type="integer">0</cn>
      <infinity></infinity>
     </interval>
     <mtext>\R</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\colon[0,\infty)\to\R
  </annotation>
 </semantics>
</math>

 for which</p>

<p>

<math display="block" id="Representer_theorem:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo fence="true">‚à•</mo>
       <mi>f</mi>
       <mo fence="true">‚à•</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(f)=h(\lVert f\rVert).
  </annotation>
 </semantics>
</math>

</p>

<p>Effectively, this result provides a necessary and sufficient condition on a differentiable regularizer 

<math display="inline" id="Representer_theorem:70">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>‚ãÖ</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>normal-‚ãÖ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\cdot)
  </annotation>
 </semantics>
</math>

 under which the corresponding regularized empirical risk minimization 

<math display="inline" id="Representer_theorem:71">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>‚Ä°</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚Ä°</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\ddagger)
  </annotation>
 </semantics>
</math>

 will have a Representer Theorem. In particular, this shows that a broad class of regularized risk minimizations (much broader than those originally considered by Kimeldorf and Wahba) have Representer Theorems.</p>
<h2 id="applications">Applications</h2>

<p>Representer theorems are useful from a practical standpoint because they dramatically simplify the regularized empirical risk minimization problem 

<math display="inline" id="Representer_theorem:72">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>‚Ä°</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚Ä°</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\ddagger)
  </annotation>
 </semantics>
</math>

. In most interesting applications, the search domain 

<math display="inline" id="Representer_theorem:73">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}
  </annotation>
 </semantics>
</math>

 for the minimization will be an infinite-dimensional subspace of 

<math display="inline" id="Representer_theorem:74">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>ùí≥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}(\mathcal{X})
  </annotation>
 </semantics>
</math>

, and therefore the search (as written) does not admit implementation on finite-memory and finite-precision computers. In contrast, the representation of 

<math display="inline" id="Representer_theorem:75">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>‚ãÖ</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
    <ci>normal-‚ãÖ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}(\cdot)
  </annotation>
 </semantics>
</math>

 afforded by a representer theorem reduces the original (infinite-dimensional) minimization problem to a search for the optimal 

<math display="inline" id="Representer_theorem:76">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-dimensional vector of coefficients 

<math display="inline" id="Representer_theorem:77">
 <semantics>
  <mrow>
   <mi>Œ±</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Œ±</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>Œ±</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚àà</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>Œ±</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œ±</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œ±</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>\R</mtext>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=(\alpha_{1},...,\alpha_{n})\in\R^{n}
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Representer_theorem:78">
 <semantics>
  <mi>Œ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 can then be obtained by applying any standard function minimization algorithm. Consequently, representer theorems provide the theoretical basis for the reduction of the general machine learning problem to algorithms that can actually be implemented on computers in practice.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Mercer's_theorem" title="wikilink">Mercer's theorem</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_learning_theory" title="wikilink">Category:Computational learning theory</a> <a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a> <a href="Category:Hilbert_space" title="wikilink">Category:Hilbert space</a></p>
</body>
</html>
