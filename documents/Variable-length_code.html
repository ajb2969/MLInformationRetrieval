<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1415">Variable-length code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Variable-length code</h1>
<hr/>

<p>In <a href="coding_theory" title="wikilink">coding theory</a> a <strong>variable-length code</strong> is a <a class="uri" href="code" title="wikilink">code</a> which maps source symbols to a <em>variable</em> number of bits.</p>

<p>Variable-length codes can allow sources to be <a href="data_compression" title="wikilink">compressed</a> and decompressed with <em>zero</em> error (<a href="lossless_data_compression" title="wikilink">lossless data compression</a>) and still be read back symbol by symbol. With the right coding strategy an <a href="independent_and_identically-distributed_random_variables" title="wikilink">independent and identically-distributed source</a> may be compressed almost arbitrarily close to its <a href="information_entropy" title="wikilink">entropy</a>. This is in contrast to fixed length coding methods, for which data compression is only possible for large blocks of data, and any compression beyond the logarithm of the total number of possibilities comes with a finite (though perhaps arbitrarily small) probability of failure.</p>

<p>Some examples of well-known variable-length coding strategies are <a href="Huffman_coding" title="wikilink">Huffman coding</a>, <a href="Lempel–Ziv" title="wikilink">Lempel–Ziv coding</a> and <a href="arithmetic_coding" title="wikilink">arithmetic coding</a>.</p>
<h2 id="codes-and-their-extensions">Codes and their extensions</h2>

<p>The extension of a code is the mapping of finite length source sequences to finite length bit strings, that is obtained by concatenating for each symbol of the source sequence the corresponding codeword produced by the original code.</p>

<p>Using terms from <a href="formal_language_theory" title="wikilink">formal language theory</a>, the precise mathematical definition is as follows: Let 

<math display="inline" id="Variable-length_code:0">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Variable-length_code:1">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 be two finite sets, called the source and target <a href="alphabet_(computer_science)" title="wikilink">alphabets</a>, respectively. A <strong>code</strong> 

<math display="inline" id="Variable-length_code:2">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <msup>
     <mi>T</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:S\to T^{*}
  </annotation>
 </semantics>
</math>

 is a <a href="total_function" title="wikilink">total function</a> mapping each symbol from 

<math display="inline" id="Variable-length_code:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 to a <a href="Word_(data_type)" title="wikilink">sequence of symbols</a> over 

<math display="inline" id="Variable-length_code:4">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, and the extension of 

<math display="inline" id="Variable-length_code:5">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 to a <a href="Homomorphism#Homomorphisms_and_e-free_homomorphisms_in_formal_language_theory" title="wikilink">homomorphism</a> of 

<math display="inline" id="Variable-length_code:6">
 <semantics>
  <msup>
   <mi>S</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{*}
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Variable-length_code:7">
 <semantics>
  <msup>
   <mi>T</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>T</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{*}
  </annotation>
 </semantics>
</math>

, which naturally maps each sequence of source symbols to a sequence of target symbols, is referred to as its <strong>extension</strong>.</p>
<h2 id="classes-of-variable-length-codes">Classes of variable-length codes</h2>

<p>Variable-length codes can be strictly nested in order of decreasing generality as non-singular codes, uniquely decodable codes and prefix codes. Prefix codes are always uniquely decodable, and these in turn are always non-singular:</p>
<h3 id="non-singular-codes">Non-singular codes</h3>

<p>A code is <strong>non-singular</strong> if each source symbol is mapped to a different non-empty bit string, i.e. the mapping from source symbols to bit strings is <a class="uri" href="injective" title="wikilink">injective</a>.</p>
<ul>
<li>For example the mapping 

<math display="inline" id="Variable-length_code:8">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo rspace="4.2pt" stretchy="false">{</mo>
    <mi>a</mi>
    <mo>↦</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi>b</mi>
    <mo>↦</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi>c</mi>
    <mo>↦</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1}=\{\,a\mapsto 0,b\mapsto 0,c\mapsto 1\,\}
  </annotation>
 </semantics>
</math>


 is <strong>not</strong> non-singular because both "a" and "b" map to the same bit string "0" ; any extension of this mapping will generate a lossy (non-lossless) coding. Such singular coding may still be useful when some loss of information is acceptable (for example when such code is used in audio or video compression, where a lossy coding becomes equivalent to source <a href="Quantization_(signal_processing)" title="wikilink">quantization</a>).</li>
<li>However, the mapping 

<math display="inline" id="Variable-length_code:9">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo rspace="4.2pt" stretchy="false">{</mo>
    <mi>a</mi>
    <mo>↦</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>b</mi>
    <mo>↦</mo>
    <mn>011</mn>
    <mo>,</mo>
    <mi>c</mi>
    <mo>↦</mo>
    <mn>01110</mn>
    <mo>,</mo>
    <mi>d</mi>
    <mo>↦</mo>
    <mn>1110</mn>
    <mo>,</mo>
    <mi>e</mi>
    <mo>↦</mo>
    <mpadded width="+1.7pt">
     <mn>10011</mn>
    </mpadded>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">011</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">01110</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">d</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">1110</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">10011</cn>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}=\{\,a\mapsto 1,b\mapsto 011,c\mapsto 01110,d\mapsto 1110,e\mapsto 10011\,\}
  </annotation>
 </semantics>
</math>

 is non-singular ; its extension will generate a lossless coding, which will be useful for general data transmission (but this feature is not always required). Note that it is not necessary for the non-singular code to be more compact than the source (and in many applications, a larger code is useful, for example as a way to detect and/or recover from encoding or transmission errors, or in security applications to protect a source from undetectable tampering).</li>
</ul>
<h3 id="uniquely-decodable-codes">Uniquely decodable codes</h3>

<p>A code is <strong>uniquely decodable</strong> if its extension is non-singular. Whether a given code is uniquely decodable can be decided with the <a href="Sardinas–Patterson_algorithm" title="wikilink">Sardinas–Patterson algorithm</a>.</p>
<ul>
<li>The mapping 

<math display="inline" id="Variable-length_code:10">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo rspace="4.2pt" stretchy="false">{</mo>
    <mi>a</mi>
    <mo>↦</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi>b</mi>
    <mo>↦</mo>
    <mn>01</mn>
    <mo>,</mo>
    <mi>c</mi>
    <mo>↦</mo>
    <mpadded width="+1.7pt">
     <mn>011</mn>
    </mpadded>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">3</cn>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">01</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">011</cn>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{3}=\{\,a\mapsto 0,b\mapsto 01,c\mapsto 011\,\}
  </annotation>
 </semantics>
</math>

 is uniquely decodable (this can be demonstrated by looking at the <em>follow-set</em> after each target bit string in the map, because each bitstring is terminated as soon as we see a 0 bit which cannot follow any existing code to create a longer valid code in the map, but unambiguously starts a new code).</li>
<li>Consider again the code 

<math display="inline" id="Variable-length_code:11">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}
  </annotation>
 </semantics>
</math>

 from the previous section. This code, which is based on an example found in,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is <strong>not</strong> uniquely decodable, since the string <em>011101110011</em> can be interpreted as the sequence of codewords <em>01110–1110 – 011</em>, but also as the sequence of codewords <em>011 – 1 – 011 – 10011</em>. Two possible decodings of this encoded string are thus given by <em>cdb</em> and <em>babe</em>. However, such a code is useful when the set of all possible source symbols is completely known and finite, or when there are restrictions (for example a formal syntax) that determine if source elements of this extension are acceptable. Such restrictions permit the decoding of the original message by checking which of the possible source symbols mapped to the same symbol are valid under those restrictions.</li>
</ul>
<h3 id="prefix-codes">Prefix codes</h3>

<p>A code is a <strong>prefix code</strong> if no target bit string in the mapping is a prefix of the target bit string of a different source symbol in the same mapping. This means that symbols can be decoded instantaneously after their entire codeword is received. Other commonly used names for this concept are <strong>prefix-free code</strong>, <strong>instantaneous code</strong>, or <strong>context-free code</strong>.</p>
<ul>
<li>The example mapping 

<math display="inline" id="Variable-length_code:12">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{3}
  </annotation>
 </semantics>
</math>

 in the previous paragraph is <strong>not</strong> a prefix code because we don't know after reading the bit string "0" if it encodes an "a" source symbol, or if it is the prefix of the encodings of the "b" or "c" symbols.</li>
<li>An example of a prefix code is shown below.</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Symbol</p></th>
<th style="text-align: left;">
<p>Codeword</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>b</p></td>
<td style="text-align: left;">
<p>10</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>c</p></td>
<td style="text-align: left;">
<p>110</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>111</p></td>
</tr>
</tbody>
</table>
<dl>
<dd><dl>
<dd>Example of encoding and decoding:
<dl>
<dd>aabacdab → 00100110111010 → |0|0|10|0|110|111|0|10| → aabacdab
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>A special case of prefix codes are <a href="block_code" title="wikilink">block codes</a>. Here all codewords must have the same length. The latter are not very useful in the context of <a href="data_compression" title="wikilink">source coding</a>, but often serve as <a href="forward_error_correction" title="wikilink">error correcting codes</a> in the context of <a href="channel_coding" title="wikilink">channel coding</a>.</p>
<h2 id="advantages">Advantages</h2>

<p>The advantage of a variable-length code is that unlikely source symbols can be assigned longer codewords and likely source symbols can be assigned shorter codewords, thus giving a low <a href="Expected_value" title="wikilink"><em>expected</em></a> codeword length. For the above example, if the probabilities of (a, b, c, d) were 

<math display="inline" id="Variable-length_code:13">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>,</mo>
   <mfrac>
    <mn>1</mn>
    <mn>4</mn>
   </mfrac>
   <mo>,</mo>
   <mfrac>
    <mn>1</mn>
    <mn>8</mn>
   </mfrac>
   <mo>,</mo>
   <mfrac>
    <mn>1</mn>
    <mn>8</mn>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">8</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">8</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\left(\frac{1}{2},\frac{1}{4},\frac{1}{8},\frac{1}{8}\right)
  </annotation>
 </semantics>
</math>


, the expected number of bits used to represent a source symbol using the code above would be:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Variable-length_code:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>×</mo>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>×</mo>
     <mfrac>
      <mn>1</mn>
      <mn>4</mn>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <mo>×</mo>
     <mfrac>
      <mn>1</mn>
      <mn>8</mn>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <mo>×</mo>
     <mfrac>
      <mn>1</mn>
      <mn>8</mn>
     </mfrac>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>7</mn>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">8</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">8</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">7</cn>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\times\frac{1}{2}+2\times\frac{1}{4}+3\times\frac{1}{8}+3\times\frac{1}{8}=%
\frac{7}{4}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>As the entropy of this source is 1.7500 bits per symbol, this code compresses the source as much as possible so that the source can be recovered with <em>zero</em> error.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>

<p><a href="http://www-igm.univ-mlv.fr/~berstel/LivreCodes/Codes.html">Draft available online</a></p></li>
</ul>

<p>"</p>

<p><a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Lossless_compression_algorithms" title="wikilink">Category:Lossless compression algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Berstel et al. (2009), Example 2.3.1, p. 63<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
