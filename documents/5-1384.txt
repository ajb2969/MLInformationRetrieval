   Semantics encoding      Semantics encoding   A semantics encoding is a translation between formal languages . For programmers, the most familiar form of encoding is the compilation of a programming language into machine code or byte-code. Conversion between document formats are also forms of encoding. Compilation of TeX or LaTeX documents to PostScript are also commonly encountered encoding processes. Some high-level preprocessors such as OCaml 's Camlp4 also involve encoding of a programming language into another.  Formally, an encoding of a language A into language B is a mapping of all terms of A into B. If there is a satisfactory encoding of A into B, B is considered at least as powerful (or at least as expressive ) as A.  Properties  An informal notion of translation is not sufficient to help determine expressivity of languages, as it permits trivial encodings such as mapping all elements of A to the same element of B. Therefore, it is necessary to determine the definition of a "good enough" encoding. This notion varies with the application.  Commonly, an encoding     [  ⋅  ]   :   A  ⟶  B      normal-:   delimited-[]  normal-⋅    normal-⟶  A  B     [\cdot]:A\longrightarrow B   is expected to preserve a number of properties.  Preservation of compositions   soundness : For every n-ary operator    o   p  A       o   subscript  p  A     op_{A}   of A, there exists an n-ary operator    o   p  B       o   subscript  p  B     op_{B}   of B such that        ∀   T  A  1    ,   T  A  2   ,  …  ,   T  A  n   ,   [   o   p  A    (   T  A  1   ,   T  A  2   ,  ⋯  ,   T  A  n   )    ]    =   o   p  B    (   [   T  A  1   ]   ,   [   T  A  2   ]   ,  ⋯  ,   [   T  A  n   ]   )          for-all   superscript   subscript  T  A   1     superscript   subscript  T  A   2   normal-…   superscript   subscript  T  A   n    delimited-[]    o   subscript  p  A     superscript   subscript  T  A   1    superscript   subscript  T  A   2   normal-⋯   superscript   subscript  T  A   n         o   subscript  p  B     delimited-[]   superscript   subscript  T  A   1     delimited-[]   superscript   subscript  T  A   2    normal-⋯   delimited-[]   superscript   subscript  T  A   n        \forall T_{A}^{1},T_{A}^{2},\dots,T_{A}^{n},[op_{A}(T_{A}^{1},T_{A}^{2},\cdots%
 ,T_{A}^{n})]=op_{B}([T_{A}^{1}],[T_{A}^{2}],\cdots,[T_{A}^{n}])     completeness : For every n-ary operator    o   p  A       o   subscript  p  A     op_{A}   of A, there exists an n-ary operator    o   p  B       o   subscript  p  B     op_{B}   of B such that        ∀   T  B  1    ,   T  B  2   ,  …  ,   T  B  n   ,   ∃   T  A  1    ,  …  ,   T  A  n   ,   o   p  B    (   T  B  1   ,  ⋯  ,   T  B  N   )     =   [   o   p  A    (   T  A  1   ,   T  A  2   ,  ⋯  ,   T  A  n   )    ]         for-all   superscript   subscript  T  B   1     superscript   subscript  T  B   2   normal-…   superscript   subscript  T  B   n      superscript   subscript  T  A   1    normal-…   superscript   subscript  T  A   n     o   subscript  p  B     superscript   subscript  T  B   1   normal-⋯   superscript   subscript  T  B   N       delimited-[]    o   subscript  p  A     superscript   subscript  T  A   1    superscript   subscript  T  A   2   normal-⋯   superscript   subscript  T  A   n        \forall T_{B}^{1},T_{B}^{2},\dots,T_{B}^{n},\exists T_{A}^{1},\dots,T_{A}^{n},%
 op_{B}(T_{B}^{1},\cdots,T_{B}^{N})=[op_{A}(T_{A}^{1},T_{A}^{2},\cdots,T_{A}^{n%
 })]      (Note: as far as the author is aware of, this criterion of completeness is never used.)  Preservation of compositions is useful insofar as it guarantees that components can be examined either separately or together without "breaking" any interesting property. In particular, in the case of compilations, this soundness guarantees the possibility of proceeding with separate compilation of components, while completeness guarantees the possibility of de-compilation.  Preservation of reductions  This assumes the existence of a notion of reduction on both language A and language B. Typically, in the case of a programming language, reduction is the relation which models the execution of a program.  We write   ⟶   normal-⟶   \longrightarrow   for one step of reduction and    ⟶  *     superscript  normal-⟶     \longrightarrow^{*}   for any number of steps of reduction.   soundness : For every terms     T  A  1   ,   T  A  2       superscript   subscript  T  A   1    superscript   subscript  T  A   2     T_{A}^{1},T_{A}^{2}   of language A, if     T  A  1    ⟶  *    T  A  2       superscript  normal-⟶     superscript   subscript  T  A   1    superscript   subscript  T  A   2     T_{A}^{1}\longrightarrow^{*}T_{A}^{2}   then     [   T  A  1   ]    ⟶  *    [   T  A  2   ]       superscript  normal-⟶     delimited-[]   superscript   subscript  T  A   1     delimited-[]   superscript   subscript  T  A   2      [T_{A}^{1}]\longrightarrow^{*}[T_{A}^{2}]   . completeness : For every term    T  A  1     superscript   subscript  T  A   1    T_{A}^{1}   of language A and every terms    T  B  2     superscript   subscript  T  B   2    T_{B}^{2}   of language B, if     [   T  A  1   ]    ⟶  *    T  B  2       superscript  normal-⟶     delimited-[]   superscript   subscript  T  A   1     superscript   subscript  T  B   2     [T_{A}^{1}]\longrightarrow^{*}T_{B}^{2}   then there exists some    T  A  2     superscript   subscript  T  A   2    T_{A}^{2}   such that     T  B  2   =   [   T  A  2   ]        superscript   subscript  T  B   2    delimited-[]   superscript   subscript  T  A   2      T_{B}^{2}=[T_{A}^{2}]   .   This preservation guarantees that both languages behave the same way. Soundness guarantees that all possible behaviours are preserved while completeness guarantees that no behaviour is added by the encoding. In particular, in the case of compilation of a programming language, soundness and completeness together mean that the compiled program behaves accordingly to the high-level semantics of the programming language.  Preservation of termination  This also assumes the existence of a notion of reduction on both language A and language B.   soundness : for any term    T  A     subscript  T  A    T_{A}   , if all reductions of    T  A     subscript  T  A    T_{A}   converge, then all reductions of    [   T  A   ]     delimited-[]   subscript  T  A     [T_{A}]   converge. completeness : for any term    [   T  A   ]     delimited-[]   subscript  T  A     [T_{A}]   , if all reductions of    [   T  A   ]     delimited-[]   subscript  T  A     [T_{A}]   converge, then all reductions of    T  A     subscript  T  A    T_{A}   converge.   In the case of compilation of a programming language, soundness guarantees that the compilation does not introduce non-termination such as endless loops or endless recursions. The completeness property is useful when language B is used to study or test a program written in language A, possibly by extracting key parts of the code: if this study or test proves that the program terminates in B, then it also terminates in A.  Preservation of observations  This assumes the existence of a notion of observation on both language A and language B. In programming languages, typical observables are results of inputs and outputs, by opposition to pure computation. In a description language such as HTML , a typical observable is the result of page rendering.   soundness : for every observable    o  b   s  A       o  b   subscript  s  A     obs_{A}   on terms of A, there exists an observable    o  b   s  B       o  b   subscript  s  B     obs_{B}   of terms of B such that for any term    T  A     subscript  T  A    T_{A}   with observable    o  b   s  A       o  b   subscript  s  A     obs_{A}   ,    [   T  A   ]     delimited-[]   subscript  T  A     [T_{A}]   has observable    o  b   s  B       o  b   subscript  s  B     obs_{B}   . completeness : for every observable    o  b   s  A       o  b   subscript  s  A     obs_{A}   on terms of A, there exists an observable    o  b   s  B       o  b   subscript  s  B     obs_{B}   on terms of B such that for any term    [   T  A   ]     delimited-[]   subscript  T  A     [T_{A}]   with observable    o  b   s  B       o  b   subscript  s  B     obs_{B}   ,    T  A     subscript  T  A    T_{A}   has observable    o  b   s  A       o  b   subscript  s  A     obs_{A}   .   Preservation of simulations  This assumes the existence of notion of simulation on both language A and language B. In a programming languages, a program simulates another if it can perform all the same (observable) tasks and possibly some others. Simulations are used typically to describe compile-time optimizations.   soundness : for every terms     T  A  1   ,   T  A  2       superscript   subscript  T  A   1    superscript   subscript  T  A   2     T_{A}^{1},T_{A}^{2}   , if    T  A  2     superscript   subscript  T  A   2    T_{A}^{2}   simulates    T  A  1     superscript   subscript  T  A   1    T_{A}^{1}   then    [   T  A  2   ]     delimited-[]   superscript   subscript  T  A   2     [T_{A}^{2}]   simulates    [   T  A  1   ]     delimited-[]   superscript   subscript  T  A   1     [T_{A}^{1}]   . completeness : for every terms     T  A  1   ,   T  A  2       superscript   subscript  T  A   1    superscript   subscript  T  A   2     T_{A}^{1},T_{A}^{2}   , if    [   T  A  2   ]     delimited-[]   superscript   subscript  T  A   2     [T_{A}^{2}]   simulates    [   T  A  1   ]     delimited-[]   superscript   subscript  T  A   1     [T_{A}^{1}]   then    T  A  2     superscript   subscript  T  A   2    T_{A}^{2}   simulates    T  A  1     superscript   subscript  T  A   1    T_{A}^{1}   .   Preservation of simulations is a much stronger property than preservation of observations, which it entails. In turn, it is weaker than a property of preservation of bisimulations . As in previous cases, soundness is important for compilation, while completeness is useful for testing or proving properties.  Preservation of equivalences  This assumes the existence of a notion of equivalence on both language A and language B. Typically, this can be a notion of equality of structured data or a notion of syntactically different yet semantically identical programs, such as structural congruence or structural equivalence.   soundness : if two terms    T  A  1     superscript   subscript  T  A   1    T_{A}^{1}   and    T  A  2     superscript   subscript  T  A   2    T_{A}^{2}   are equivalent in A, then    [   T  A  1   ]     delimited-[]   superscript   subscript  T  A   1     [T_{A}^{1}]   and    [   T  A  2   ]     delimited-[]   superscript   subscript  T  A   2     [T_{A}^{2}]   are equivalent in B. completeness : if two terms    [   T  A  1   ]     delimited-[]   superscript   subscript  T  A   1     [T_{A}^{1}]   and    [   T  A  2   ]     delimited-[]   superscript   subscript  T  A   2     [T_{A}^{2}]   are equivalent in B, then    T  A  1     superscript   subscript  T  A   1    T_{A}^{1}   and    T  A  2     superscript   subscript  T  A   2    T_{A}^{2}   are equivalent in A.   Preservation of distribution  This assumes the existence of a notion of distribution on both language A and language B. Typically, for compilation of distributed programs written in Acute , JoCaml or E, this means distribution of processes and data among several computers or CPUs.   soundness : if a term    T  A     subscript  T  A    T_{A}   is the composition of two agents      T  A  1    |   T  A  2      fragments   superscript   subscript  T  A   1   normal-|   superscript   subscript  T  A   2     T_{A}^{1}~{}|~{}T_{A}^{2}   then    [   T  A   ]     delimited-[]   subscript  T  A     [T_{A}]   must be the composition of two agents     [   T  A  1   ]   |   [   T  A  2   ]      fragments   fragments  normal-[   superscript   subscript  T  A   1   normal-]   normal-|   fragments  normal-[   superscript   subscript  T  A   2   normal-]     [T_{A}^{1}]~{}|~{}[T_{A}^{2}]   . completeness : if a term    [   T  A   ]     delimited-[]   subscript  T  A     [T_{A}]   is the composition of two agents      T  B  1    |   T  B  2      fragments   superscript   subscript  T  B   1   normal-|   superscript   subscript  T  B   2     T_{B}^{1}~{}|~{}T_{B}^{2}   then    T  B     subscript  T  B    T_{B}   must be the composition of two agents      T  A  1    |   T  A  2      fragments   superscript   subscript  T  A   1   normal-|   superscript   subscript  T  A   2     T_{A}^{1}~{}|~{}T_{A}^{2}   such that     [   T  A  1   ]   =   T  B  1        delimited-[]   superscript   subscript  T  A   1     superscript   subscript  T  B   1     [T_{A}^{1}]=T_{B}^{1}   and     [   T  A  2   ]   =   T  B  2        delimited-[]   superscript   subscript  T  A   2     superscript   subscript  T  B   2     [T_{A}^{2}]=T_{B}^{2}   .   See also   Bisimulation  Compiler  Semantics  Semantic dictionary encoding (SDE)   External links   Program Transformation Wiki   "  Category:Formal languages   