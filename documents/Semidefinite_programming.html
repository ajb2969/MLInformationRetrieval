<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1948">Semidefinite programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Semidefinite programming</h1>
<hr/>

<p><strong>Semidefinite programming</strong> (<strong>SDP</strong>) is a subfield of <a href="convex_optimization" title="wikilink">convex optimization</a> concerned with the optimization of a linear <a href="objective_function" title="wikilink">objective function</a> (that is, a function to be maximized or minimized) over the intersection of the <a href="Cone_(linear_algebra)" title="wikilink">cone</a> of <a href="Positive-definite_matrix#Negative-definite,_semidefinite_and_indefinite_matrices" title="wikilink">positive semidefinite</a> <a href="Matrix_(mathematics)" title="wikilink">matrices</a> with an <a href="affine_space" title="wikilink">affine space</a>, i.e., a <a class="uri" href="spectrahedron" title="wikilink">spectrahedron</a>.</p>

<p>Semidefinite programming is a relatively new field of optimization which is of growing interest for several reasons. Many practical problems in <a href="operations_research" title="wikilink">operations research</a> and <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a> can be modeled or approximated as semidefinite programming problems. In automatic control theory, SDPs are used in the context of <a href="linear_matrix_inequality" title="wikilink">linear matrix inequalities</a>. SDPs are in fact a special case of <a href="conic_optimization" title="wikilink">cone programming</a> and can be efficiently solved by <a href="interior_point_methods" title="wikilink">interior point methods</a>. All <a href="linear_programming" title="wikilink">linear programs</a> can be expressed as SDPs, and via hierarchies of SDPs the solutions of polynomial optimization problems can be approximated. Semidefinite programming has been used in the <a href="optimization" title="wikilink">optimization of complex systems</a>. In recent years, some quantum query complexity problems have been formulated in term of semidefinite programs.</p>
<h2 id="motivation-and-definition">Motivation and definition</h2>
<h3 id="initial-motivation">Initial motivation</h3>

<p>A <a href="linear_programming" title="wikilink">linear programming</a> problem is one in which we wish to maximize or minimize a linear objective function of real variables over a <a class="uri" href="polytope" title="wikilink">polytope</a>. In semidefinite programming, we instead use real-valued vectors and are allowed to take the dot product of vectors; nonnegativity constraints on real variables in LP are replaced by semidefiniteness constraints on matrix variables in SDP. Specifically, a general semidefinite programming problem can be defined as any mathematical programming problem of the form</p>

<p>

<math display="block" id="Semidefinite_programming:0">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <munder>
      <mi>min</mi>
      <mrow>
       <mrow>
        <msup>
         <mi>x</mi>
         <mn>1</mn>
        </msup>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msup>
         <mi>x</mi>
         <mi>n</mi>
        </msup>
       </mrow>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
        <mo>∈</mo>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>n</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>c</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>x</mi>
          <mi>i</mi>
         </msup>
         <mo>⋅</mo>
         <msup>
          <mi>x</mi>
          <mi>j</mi>
         </msup>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>j</mi>
          </mrow>
          <mo>∈</mo>
          <mrow>
           <mo stretchy="false">[</mo>
           <mi>n</mi>
           <mo stretchy="false">]</mo>
          </mrow>
         </mrow>
        </munder>
        <mrow>
         <msub>
          <mi>a</mi>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>j</mi>
           <mo>,</mo>
           <mi>k</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msup>
            <mi>x</mi>
            <mi>i</mi>
           </msup>
           <mo>⋅</mo>
           <msup>
            <mi>x</mi>
            <mi>j</mi>
           </msup>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>≤</mo>
       <mrow>
        <msub>
         <mi>b</mi>
         <mi>k</mi>
        </msub>
        <mrow>
         <mo>∀</mo>
         <mi>k</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>.</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <list>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <leq></leq>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <list>
          <ci>i</ci>
          <ci>j</ci>
         </list>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <list>
          <ci>i</ci>
          <ci>j</ci>
          <ci>k</ci>
         </list>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>k</ci>
       </apply>
      </list>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rl}{\displaystyle\min_{x^{1},\ldots,x^{n}\in\mathbb{R}^{n}}}&{%
\displaystyle\sum_{i,j\in[n]}c_{i,j}(x^{i}\cdot x^{j})}\\
\text{subject to}&{\displaystyle\sum_{i,j\in[n]}a_{i,j,k}(x^{i}\cdot x^{j})%
\leq b_{k}\qquad\forall k}.\\
\end{array}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="equivalent-formulations">Equivalent formulations</h3>

<p>An 

<math display="inline" id="Semidefinite_programming:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Semidefinite_programming:2">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is said to be <a href="Positive-definite_matrix#Positive-semidefinite" title="wikilink"> positive semidefinite</a> if it is the <a href="gramian_matrix" title="wikilink">gramian matrix</a> of some vectors (i.e. if there exist vectors 

<math display="inline" id="Semidefinite_programming:3">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{1},\ldots,x^{n}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Semidefinite_programming:4">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mi>i</mi>
    </msup>
    <mo>⋅</mo>
    <msup>
     <mi>x</mi>
     <mi>j</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i,j}=x^{i}\cdot x^{j}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Semidefinite_programming:5">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

). If this is the case, we denote this as 

<math display="inline" id="Semidefinite_programming:6">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>⪰</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">succeeds-or-equals</csymbol>
    <ci>M</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\succeq 0
  </annotation>
 </semantics>
</math>

. Note that there are several other equivalent definitions of being positive semidefinite, for example, positive semidefinite matrices have only non-negative eigenvalues and have a positive definite square root.</p>

<p>Denote by 

<math display="inline" id="Semidefinite_programming:7">
 <semantics>
  <msup>
   <mi>𝕊</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝕊</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{S}^{n}
  </annotation>
 </semantics>
</math>

 the space of all 

<math display="inline" id="Semidefinite_programming:8">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 real symmetric matrices. The space is equipped with the <a href="Inner_product_space" title="wikilink">inner product</a> (where 

<math display="inline" id="Semidefinite_programming:9">
 <semantics>
  <mi>tr</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>tr</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm tr}
  </annotation>
 </semantics>
</math>

 denotes the <a href="Trace_(linear_algebra)" title="wikilink">trace</a>) 

<math display="inline" id="Semidefinite_programming:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <msup>
      <mi>𝕊</mi>
      <mi>n</mi>
     </msup>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>tr</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mi>T</mi>
       </msup>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>A</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>B</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <ci>A</ci>
       <ci>B</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝕊</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>tr</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>T</ci>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A,B\rangle_{\mathbb{S}^{n}}={\rm tr}(A^{T}B)=\sum_{i=1,j=1}^{n}A_{ij}B%
_{ij}.
  </annotation>
 </semantics>
</math>

</p>

<p>We can rewrite the mathematical program given in the previous section equivalently as</p>

<p>

<math display="block" id="Semidefinite_programming:11">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>X</mi>
       <mo>∈</mo>
       <msup>
        <mi>𝕊</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>C</mi>
       <mo>,</mo>
       <mi>X</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msup>
       <mi>𝕊</mi>
       <mi>n</mi>
      </msup>
     </msub>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <msub>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <msub>
          <mi>A</mi>
          <mi>k</mi>
         </msub>
         <mo>,</mo>
         <mi>X</mi>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <msup>
         <mi>𝕊</mi>
         <mi>n</mi>
        </msup>
       </msub>
       <mo>≤</mo>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo rspace="12.5pt">,</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mrow>
        <mn>1</mn>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mi>m</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>X</mi>
      <mo>⪰</mo>
      <mn>0</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝕊</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <ci>C</ci>
       <ci>X</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝕊</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <leq></leq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>k</ci>
         </apply>
         <ci>X</ci>
        </list>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝕊</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <list>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>m</ci>
       </list>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">succeeds-or-equals</csymbol>
      <ci>X</ci>
      <cn type="integer">0</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rl}{\displaystyle\min_{X\in\mathbb{S}^{n}}}&\langle C,X\rangle%
_{\mathbb{S}^{n}}\\
\text{subject to}&\langle A_{k},X\rangle_{\mathbb{S}^{n}}\leq b_{k},\quad k=1,%
\ldots,m\\
&X\succeq 0\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>where entry 

<math display="inline" id="Semidefinite_programming:12">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Semidefinite_programming:13">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is given by 

<math display="inline" id="Semidefinite_programming:14">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <list>
     <ci>i</ci>
     <ci>j</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i,j}
  </annotation>
 </semantics>
</math>

 from the previous section and 

<math display="inline" id="Semidefinite_programming:15">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Semidefinite_programming:16">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 matrix having 

<math display="inline" id="Semidefinite_programming:17">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

th entry 

<math display="inline" id="Semidefinite_programming:18">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <list>
     <ci>i</ci>
     <ci>j</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i,j,k}
  </annotation>
 </semantics>
</math>

 from the previous section.</p>

<p>Note that if we add <a href="slack_variable" title="wikilink"> slack variables</a> appropriately, this SDP can be converted to one of the form</p>

<p>

<math display="block" id="Semidefinite_programming:19">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>X</mi>
       <mo>∈</mo>
       <msup>
        <mi>𝕊</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>C</mi>
       <mo>,</mo>
       <mi>X</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msup>
       <mi>𝕊</mi>
       <mi>n</mi>
      </msup>
     </msub>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <msub>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <msub>
          <mi>A</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <mi>X</mi>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <msup>
         <mi>𝕊</mi>
         <mi>n</mi>
        </msup>
       </msub>
       <mo>=</mo>
       <msub>
        <mi>b</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo rspace="12.5pt">,</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mn>1</mn>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mi>m</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>X</mi>
      <mo>⪰</mo>
      <mn>0.</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝕊</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <ci>C</ci>
       <ci>X</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝕊</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>i</ci>
         </apply>
         <ci>X</ci>
        </list>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝕊</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <list>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>m</ci>
       </list>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">succeeds-or-equals</csymbol>
      <ci>X</ci>
      <cn type="float">0.</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rl}{\displaystyle\min_{X\in\mathbb{S}^{n}}}&\langle C,X\rangle%
_{\mathbb{S}^{n}}\\
\text{subject to}&\langle A_{i},X\rangle_{\mathbb{S}^{n}}=b_{i},\quad i=1,%
\ldots,m\\
&X\succeq 0.\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>For convenience, an SDP may be specified in a slightly different, but equivalent form. For example, linear expressions involving nonnegative <a href="scalar_(mathematics)" title="wikilink">scalar</a> variables may be added to the program specification. This remains an SDP because each variable can be incorporated into the matrix 

<math display="inline" id="Semidefinite_programming:20">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 as a diagonal entry (

<math display="inline" id="Semidefinite_programming:21">
 <semantics>
  <msub>
   <mi>X</mi>
   <mrow>
    <mi>i</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{ii}
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Semidefinite_programming:22">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

). To ensure that 

<math display="inline" id="Semidefinite_programming:23">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>i</mi>
     <mi>i</mi>
    </mrow>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{ii}\geq 0
  </annotation>
 </semantics>
</math>

, constraints 

<math display="inline" id="Semidefinite_programming:24">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{ij}=0
  </annotation>
 </semantics>
</math>

 can be added for all 

<math display="inline" id="Semidefinite_programming:25">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>≠</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>j</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\neq i
  </annotation>
 </semantics>
</math>

. As another example, note that for any positive semidefinite matrix 

<math display="inline" id="Semidefinite_programming:26">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, there exists a set of vectors 

<math display="inline" id="Semidefinite_programming:27">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v_{i}\}
  </annotation>
 </semantics>
</math>

 such that the 

<math display="inline" id="Semidefinite_programming:28">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Semidefinite_programming:29">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 entry of 

<math display="inline" id="Semidefinite_programming:30">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Semidefinite_programming:31">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{ij}=(v_{i},v_{j})
  </annotation>
 </semantics>
</math>

 the <a href="dot_product" title="wikilink">scalar product</a> of 

<math display="inline" id="Semidefinite_programming:32">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Semidefinite_programming:33">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{j}
  </annotation>
 </semantics>
</math>

. Therefore, SDPs are often formulated in terms of linear expressions on scalar products of vectors. Given the solution to the SDP in the standard form, the vectors 

<math display="inline" id="Semidefinite_programming:34">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v_{i}\}
  </annotation>
 </semantics>
</math>

 can be recovered in 

<math display="inline" id="Semidefinite_programming:35">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 time (e.g., by using an incomplete <a href="Cholesky_decomposition" title="wikilink">Cholesky decomposition</a> of X).</p>
<h2 id="duality-theory">Duality theory</h2>
<h3 id="definitions">Definitions</h3>

<p>Analogously to linear programming, given a general SDP of the form</p>

<p>

<math display="block" id="Semidefinite_programming:36">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>X</mi>
       <mo>∈</mo>
       <msup>
        <mi>𝕊</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>C</mi>
       <mo>,</mo>
       <mi>X</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msup>
       <mi>𝕊</mi>
       <mi>n</mi>
      </msup>
     </msub>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <msub>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <msub>
          <mi>A</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <mi>X</mi>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <msup>
         <mi>𝕊</mi>
         <mi>n</mi>
        </msup>
       </msub>
       <mo>=</mo>
       <msub>
        <mi>b</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo rspace="12.5pt">,</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mn>1</mn>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mi>m</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>X</mi>
      <mo>⪰</mo>
      <mn>0</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝕊</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <ci>C</ci>
       <ci>X</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝕊</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>i</ci>
         </apply>
         <ci>X</ci>
        </list>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝕊</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <list>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>m</ci>
       </list>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">succeeds-or-equals</csymbol>
      <ci>X</ci>
      <cn type="integer">0</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rl}{\displaystyle\min_{X\in\mathbb{S}^{n}}}&\langle C,X\rangle%
_{\mathbb{S}^{n}}\\
\text{subject to}&\langle A_{i},X\rangle_{\mathbb{S}^{n}}=b_{i},\quad i=1,%
\ldots,m\\
&X\succeq 0\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>(the primal problem or P-SDP), we define the <em><a href="dual_problem" title="wikilink">dual</a></em> semidefinite program (D-SDP) as</p>

<p>

<math display="block" id="Semidefinite_programming:37">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <munder>
      <mi>max</mi>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mi>m</mi>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>b</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msup>
       <mi>ℝ</mi>
       <mi>m</mi>
      </msup>
     </msub>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>m</mi>
       </munderover>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <msub>
         <mi>A</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>⪯</mo>
      <mi>C</mi>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <in></in>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <ci>b</ci>
       <ci>y</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <csymbol cd="latexml">precedes-or-equals</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <ci>C</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rl}{\displaystyle\max_{y\in\mathbb{R}^{m}}}&\langle b,y\rangle%
_{\mathbb{R}^{m}}\\
\text{subject to}&{\displaystyle\sum_{i=1}^{m}}y_{i}A_{i}\preceq C\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>where for any two matrices 

<math display="inline" id="Semidefinite_programming:38">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Semidefinite_programming:39">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Semidefinite_programming:40">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>⪰</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">succeeds-or-equals</csymbol>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\succeq Q
  </annotation>
 </semantics>
</math>

 means 

<math display="inline" id="Semidefinite_programming:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>-</mo>
    <mi>Q</mi>
   </mrow>
   <mo>⪰</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">succeeds-or-equals</csymbol>
    <apply>
     <minus></minus>
     <ci>P</ci>
     <ci>Q</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P-Q\succeq 0
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="weak-duality">Weak duality</h3>

<p>The <a href="weak_duality" title="wikilink">weak duality</a> theorem states that the value of the primal SDP is at least the value of the dual SDP. Therefore, any feasible solution to the dual SDP lower-bounds the primal SDP value, and conversely, any feasible solution to the primal SDP upper-bounds the dual SDP value. This is because</p>

<p>

<math display="block" id="Semidefinite_programming:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>C</mi>
      <mo>,</mo>
      <mi>X</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>b</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>C</mi>
      <mo>,</mo>
      <mi>X</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>b</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>C</mi>
      <mo>,</mo>
      <mi>X</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <msub>
         <mi>A</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <mi>X</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>C</mi>
      <mo>-</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>m</mi>
       </munderover>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <msub>
         <mi>A</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <list>
       <ci>C</ci>
       <ci>X</ci>
      </list>
      <list>
       <ci>b</ci>
       <ci>y</ci>
      </list>
     </apply>
     <apply>
      <minus></minus>
      <list>
       <ci>C</ci>
       <ci>X</ci>
      </list>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <list>
       <ci>C</ci>
       <ci>X</ci>
      </list>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>i</ci>
         </apply>
         <ci>X</ci>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <minus></minus>
       <ci>C</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>X</ci>
     </list>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle C,X\rangle-\langle b,y\rangle=\langle C,X\rangle-\sum_{i=1}^{m}y_{i}b_%
{i}=\langle C,X\rangle-\sum_{i=1}^{m}y_{i}\langle A_{i},X\rangle=\langle C-%
\sum_{i=1}^{m}y_{i}A_{i},X\rangle\geq 0,
  </annotation>
 </semantics>
</math>

 where the last inequality is because both matrices are positive semidefinite, and the result of this function is sometimes referred to as duality gap.</p>
<h3 id="strong-duality">Strong duality</h3>

<p>Under a condition known as Slater's condition, the value of the primal and dual SDPs are equal. This is known as <a href="strong_duality" title="wikilink">strong duality</a>. Unlike for <a href="Linear_programming" title="wikilink">linear programs</a>, however, not every SDP satisfies strong duality; in general, the value of the dual SDP may lie strictly below the value of the primal.</p>

<p>(i) Suppose the primal problem (P-SDP) is bounded below and strictly feasible (i.e., there exists 

<math display="inline" id="Semidefinite_programming:43">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>0</mn>
    </msub>
    <mo>∈</mo>
    <msup>
     <mi>𝕊</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>0</mn>
    </msub>
    <mo>≻</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝕊</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">succeeds</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}\in\mathbb{S}^{n},X_{0}\succ 0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Semidefinite_programming:44">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>A</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>X</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <msup>
     <mi>𝕊</mi>
     <mi>n</mi>
    </msup>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>b</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">0</cn>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝕊</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A_{i},X_{0}\rangle_{\mathbb{S}^{n}}=b_{i}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Semidefinite_programming:45">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>m</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\ldots,m
  </annotation>
 </semantics>
</math>

). Then there is an optimal solution 

<math display="inline" id="Semidefinite_programming:46">
 <semantics>
  <msup>
   <mi>y</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{*}
  </annotation>
 </semantics>
</math>

 to (D-SDP) and</p>

<p>

<math display="block" id="Semidefinite_programming:47">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>C</mi>
      <mo>,</mo>
      <msup>
       <mi>X</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <msup>
      <mi>𝕊</mi>
      <mi>n</mi>
     </msup>
    </msub>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>b</mi>
      <mo>,</mo>
      <msup>
       <mi>y</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <msup>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\R</mtext>
      </merror>
      <mi>m</mi>
     </msup>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <times></times>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝕊</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <times></times>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>\R</mtext>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle C,X^{*}\rangle_{\mathbb{S}^{n}}=\langle b,y^{*}\rangle_{\R^{m}}.
  </annotation>
 </semantics>
</math>

</p>

<p>(ii) Suppose the dual problem (D-SDP) is bounded above and strictly feasible (i.e., 

<math display="inline" id="Semidefinite_programming:48">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>A</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>≺</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">precedes</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{m}(y_{0})_{i}A_{i}\prec C
  </annotation>
 </semantics>
</math>


 for some 

<math display="inline" id="Semidefinite_programming:49">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>m</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0}\in\R^{m}
  </annotation>
 </semantics>
</math>

). Then there is an optimal solution 

<math display="inline" id="Semidefinite_programming:50">
 <semantics>
  <msup>
   <mi>X</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{*}
  </annotation>
 </semantics>
</math>

 to (P-SDP) and the equality from (i) holds.</p>
<h2 id="examples">Examples</h2>
<h3 id="example-1">Example 1</h3>

<p>Consider three random variables 

<math display="inline" id="Semidefinite_programming:51">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Semidefinite_programming:52">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Semidefinite_programming:53">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>


. By definition, their <a href="Correlation" title="wikilink">correlation coefficients</a> 

<math display="inline" id="Semidefinite_programming:54">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>A</mi>
     <mi>C</mi>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>B</mi>
     <mi>C</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB},\ \rho_{AC},\rho_{BC}
  </annotation>
 </semantics>
</math>

 are valid if and only if</p>

<p>

<math display="block" id="Semidefinite_programming:55">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>ρ</mi>
        <mrow>
         <mi>A</mi>
         <mi>B</mi>
        </mrow>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>ρ</mi>
        <mrow>
         <mi>A</mi>
         <mi>C</mi>
        </mrow>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>ρ</mi>
        <mrow>
         <mi>A</mi>
         <mi>B</mi>
        </mrow>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>ρ</mi>
        <mrow>
         <mi>B</mi>
         <mi>C</mi>
        </mrow>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>ρ</mi>
        <mrow>
         <mi>A</mi>
         <mi>C</mi>
        </mrow>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>ρ</mi>
        <mrow>
         <mi>B</mi>
         <mi>C</mi>
        </mrow>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>⪰</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">succeeds-or-equals</csymbol>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>C</ci>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>C</ci>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>C</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>C</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}1&\rho_{AB}&\rho_{AC}\\
\rho_{AB}&1&\rho_{BC}\\
\rho_{AC}&\rho_{BC}&1\end{pmatrix}\succeq 0
  </annotation>
 </semantics>
</math>

</p>

<p>Suppose that we know from some prior knowledge (empirical results of an experiment, for example) that 

<math display="inline" id="Semidefinite_programming:56">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mn>0.2</mn>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
   </msub>
   <mo>≤</mo>
   <mrow>
    <mo>-</mo>
    <mn>0.1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <cn type="float">0.2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="float">0.1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -0.2\leq\rho_{AB}\leq-0.1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Semidefinite_programming:57">
 <semantics>
  <mrow>
   <mn>0.4</mn>
   <mo>≤</mo>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>B</mi>
     <mi>C</mi>
    </mrow>
   </msub>
   <mo>≤</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="float">0.4</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0.4\leq\rho_{BC}\leq 0.5
  </annotation>
 </semantics>
</math>

. The problem of determining the smallest and largest values that 

<math display="inline" id="Semidefinite_programming:58">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>C</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AC}
  </annotation>
 </semantics>
</math>

 can take is given by:</p>
<dl>
<dd>minimize/maximize 

<math display="inline" id="Semidefinite_programming:59">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>13</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">13</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{13}
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to
</dd>
<dd>

<math display="inline" id="Semidefinite_programming:60">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mn>0.2</mn>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mn>12</mn>
   </msub>
   <mo>≤</mo>
   <mrow>
    <mo>-</mo>
    <mn>0.1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <cn type="float">0.2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">12</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="float">0.1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -0.2\leq x_{12}\leq-0.1
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Semidefinite_programming:61">
 <semantics>
  <mrow>
   <mn>0.4</mn>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mn>23</mn>
   </msub>
   <mo>≤</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="float">0.4</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">23</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0.4\leq x_{23}\leq 0.5
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Semidefinite_programming:62">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>11</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>22</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>33</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">11</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">22</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">33</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{11}=x_{22}=x_{33}=1
  </annotation>
 </semantics>
</math>


</dd>
<dd><math>\begin{pmatrix}
</math></dd>
</dl>

<p><code> 1 &amp; x_{12} &amp; x_{13} \\</code><br/>
<code> x_{12} &amp; 1 &amp; x_{23} \\</code><br/>
<code> x_{13} &amp; x_{23} &amp; 1</code></p>

<p>\end{pmatrix} \succeq 0</p>

<p>we set 

<math display="inline" id="Semidefinite_programming:63">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ρ</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mn>12</mn>
    </msub>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>ρ</mi>
      <mrow>
       <mi>A</mi>
       <mi>C</mi>
      </mrow>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mn>13</mn>
     </msub>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <msub>
      <mi>ρ</mi>
      <mrow>
       <mi>B</mi>
       <mi>C</mi>
      </mrow>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mn>23</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">12</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>C</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">13</cn>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>C</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">23</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AB}=x_{12},\ \rho_{AC}=x_{13},\ \rho_{BC}=x_{23}
  </annotation>
 </semantics>
</math>

 to obtain the answer. This can be formulated by an SDP. We handle the inequality constraints by augmenting the variable matrix and introducing <a href="slack_variable" title="wikilink">slack variables</a>, for example</p>

<p>

<math display="inline" id="Semidefinite_programming:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>tr</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mtable>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
      <mo>⋅</mo>
      <mrow>
       <mo>(</mo>
       <mtable>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>12</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>13</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>12</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>23</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>13</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>x</mi>
           <mn>23</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>s</mi>
           <mn>1</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>s</mi>
           <mn>2</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>s</mi>
           <mn>3</mn>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>12</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>0.1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>tr</ci>
      <apply>
       <ci>normal-⋅</ci>
       <matrix>
        <matrixrow>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
       </matrix>
       <matrix>
        <matrixrow>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">12</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">13</cn>
         </apply>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">12</cn>
         </apply>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">23</cn>
         </apply>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">13</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">23</cn>
         </apply>
         <cn type="integer">1</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">0</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <cn type="integer">3</cn>
         </apply>
        </matrixrow>
       </matrix>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">12</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="float">0.1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{tr}\left(\left(\begin{array}[]{cccccc}0&1&0&0&0&0\\
0&0&0&0&0&0\\
0&0&0&0&0&0\\
0&0&0&1&0&0\\
0&0&0&0&0&0\\
0&0&0&0&0&0\end{array}\right)\cdot\left(\begin{array}[]{cccccc}1&x_{12}&x_{13}%
&0&0&0\\
x_{12}&1&x_{23}&0&0&0\\
x_{13}&x_{23}&1&0&0&0\\
0&0&0&s_{1}&0&0\\
0&0&0&0&s_{2}&0\\
0&0&0&0&0&s_{3}\end{array}\right)\right)=x_{12}+s_{1}=-0.1
  </annotation>
 </semantics>
</math>

</p>

<p>Solving this SDP gives the minimum and maximum values of 

<math display="inline" id="Semidefinite_programming:65">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mrow>
     <mi>A</mi>
     <mi>C</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>13</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">13</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{AC}=x_{13}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Semidefinite_programming:66">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>0.978</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="float">0.978</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -0.978
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Semidefinite_programming:67">
 <semantics>
  <mn>0.872</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="float">0.872</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0.872
  </annotation>
 </semantics>
</math>

 respectively.</p>
<h3 id="example-2">Example 2</h3>

<p>Consider the problem</p>
<dl>
<dd>minimize 

<math display="inline" id="Semidefinite_programming:68">
 <semantics>
  <mfrac>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>c</mi>
       <mi>T</mi>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mrow>
    <msup>
     <mi>d</mi>
     <mi>T</mi>
    </msup>
    <mi>x</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>T</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <ci>T</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{(c^{T}x)^{2}}{d^{T}x}
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to 

<math display="inline" id="Semidefinite_programming:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax+b\geq 0
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>where we assume that 

<math display="inline" id="Semidefinite_programming:70">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>d</mi>
     <mi>T</mi>
    </msup>
    <mi>x</mi>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <ci>T</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{T}x>0
  </annotation>
 </semantics>
</math>

 whenever 

<math display="inline" id="Semidefinite_programming:71">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax+b\geq 0
  </annotation>
 </semantics>
</math>

.</p>

<p>Introducing an auxiliary variable 

<math display="inline" id="Semidefinite_programming:72">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 the problem can be reformulated:</p>
<dl>
<dd>minimize 

<math display="inline" id="Semidefinite_programming:73">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to 

<math display="inline" id="Semidefinite_programming:74">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi>b</mi>
    </mrow>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>c</mi>
         <mi>T</mi>
        </msup>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <msup>
       <mi>d</mi>
       <mi>T</mi>
      </msup>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo>≤</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>c</ci>
         <ci>T</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>d</ci>
        <ci>T</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax+b\geq 0,\,\frac{(c^{T}x)^{2}}{d^{T}x}\leq t
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>In this formulation, the objective is a linear function of the variables 

<math display="inline" id="Semidefinite_programming:75">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>t</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,t
  </annotation>
 </semantics>
</math>

.</p>

<p>The first restriction can be written as</p>

<p>

<math display="block" id="Semidefinite_programming:76">
 <semantics>
  <mrow>
   <mrow>
    <mtext>𝐝𝐢𝐚𝐠</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <mtext>diag</mtext>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{diag}(Ax+b)\geq 0
  </annotation>
 </semantics>
</math>

</p>

<p>where the matrix 

<math display="inline" id="Semidefinite_programming:77">
 <semantics>
  <mrow>
   <mtext>𝐝𝐢𝐚𝐠</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>diag</mtext>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{diag}(Ax+b)
  </annotation>
 </semantics>
</math>

 is the square matrix with values in the diagonal equal to the elements of the vector 

<math display="inline" id="Semidefinite_programming:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>x</mi>
   </mrow>
   <mo>+</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax+b
  </annotation>
 </semantics>
</math>

.</p>

<p>The second restriction can be written as</p>

<p>

<math display="block" id="Semidefinite_programming:79">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>t</mi>
     <msup>
      <mi>d</mi>
      <mi>T</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>c</mi>
        <mi>T</mi>
       </msup>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <ci>T</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>c</ci>
        <ci>T</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   td^{T}x-(c^{T}x)^{2}\geq 0
  </annotation>
 </semantics>
</math>

</p>

<p>Defining 

<math display="inline" id="Semidefinite_programming:80">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 as follows</p>

<p>

<math display="block" id="Semidefinite_programming:81">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi>t</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <msup>
         <mo>;</mo>
         <mi>T</mi>
        </msup>
        <mi>x</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msup>
         <mi>c</mi>
         <mi>T</mi>
        </msup>
        <mi>x</mi>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>d</mi>
        <msup>
         <mo>;</mo>
         <mi>T</mi>
        </msup>
        <mi>x</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <matrix>
      <matrixrow>
       <ci>t</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">c</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-;</ci>
         <ci>T</ci>
        </apply>
        <csymbol cd="unknown">x</csymbol>
       </cerror>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>c</ci>
         <ci>T</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">d</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-;</ci>
         <ci>T</ci>
        </apply>
        <csymbol cd="unknown">x</csymbol>
       </cerror>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\left[\begin{array}[]{cc}t&c;^{T}x\\
c^{T}x&d;^{T}x\end{array}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>We can use the theory of Schur Complements to see that</p>

<p>

<math display="block" id="Semidefinite_programming:82">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>⪰</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">succeeds-or-equals</csymbol>
    <ci>D</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\succeq 0
  </annotation>
 </semantics>
</math>

 (Boyd and Vandenberghe, 1996)</p>

<p>The semidefinite program associated with this problem is</p>
<dl>
<dd>minimize 

<math display="inline" id="Semidefinite_programming:83">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to 

<math display="inline" id="Semidefinite_programming:84">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mtext>𝐝𝐢𝐚𝐠</mtext>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>A</mi>
           <mi>x</mi>
          </mrow>
          <mo>+</mo>
          <mi>b</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>t</mi>
        <mo>;</mo>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <msup>
         <mo>;</mo>
         <mi>T</mi>
        </msup>
        <mi>x</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>c</mi>
        <msup>
         <mo>;</mo>
         <mi>T</mi>
        </msup>
        <mi>x</mi>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>d</mi>
        <msup>
         <mo>;</mo>
         <mi>T</mi>
        </msup>
        <mi>x</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>⪰</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">succeeds-or-equals</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <mtext>diag</mtext>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>A</ci>
          <ci>x</ci>
         </apply>
         <ci>b</ci>
        </apply>
       </apply>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <ci>t</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">c</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-;</ci>
         <ci>T</ci>
        </apply>
        <csymbol cd="unknown">x</csymbol>
       </cerror>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">c</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-;</ci>
         <ci>T</ci>
        </apply>
        <csymbol cd="unknown">x</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">d</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-;</ci>
         <ci>T</ci>
        </apply>
        <csymbol cd="unknown">x</csymbol>
       </cerror>
      </matrixrow>
     </matrix>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\begin{array}[]{ccc}\textbf{diag}(Ax+b)&0&0\\
0&t;&c;^{T}x\\
0&c;^{T}x&d;^{T}x\end{array}\right]\succeq 0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<h3 id="example-3-goemans-williamson-max-cut-approximation-algorithm">Example 3 (Goemans-Williamson MAX CUT approximation algorithm)</h3>

<p>Semidefinite programs are important tools for developing approximation algorithms for NP-hard maximization problems. The first approximation algorithm based on an SDP is due to <a href="Michel_Goemans" title="wikilink">Michel Goemans</a> and <a href="David_P._Williamson" title="wikilink">David P. Williamson</a> (JACM, 1995). They studied the MAX CUT problem: Given a <a href="Graph_(mathematics)" title="wikilink">graph</a> <em>G</em> = (<em>V</em>, <em>E</em>), output a <a href="Partition_of_a_set" title="wikilink">partition</a> of the vertices <em>V</em> so as to maximize the number of edges crossing from one side to the other. This problem can be expressed as an <a href="Quadratic_programming" title="wikilink"> integer quadratic program</a>:</p>
<dl>
<dd>Maximize 

<math display="inline" id="Semidefinite_programming:85">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </msub>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>v</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>v</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
      <ci>E</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{(i,j)\in E}\frac{1-v_{i}v_{j}}{2},
  </annotation>
 </semantics>
</math>

 such that each 

<math display="inline" id="Semidefinite_programming:86">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <set>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\in\{1,-1\}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>Unless <a href="P_=_NP" title="wikilink">P = NP</a>, we cannot solve this maximization problem efficiently. However, Goemans and Williamson observed a general three-step procedure for attacking this sort of problem:</p>
<ol>
<li><em>Relax</em> the integer quadratic program into an SDP.</li>
<li>Solve the SDP (to within an arbitrarily small additive error 

<math display="inline" id="Semidefinite_programming:87">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

).</li>
<li><em>Round</em> the SDP solution to obtain an approximate solution to the original integer quadratic program.</li>
</ol>

<p>For MAX CUT, the most natural relaxation is</p>

<p>

<math display="block" id="Semidefinite_programming:88">
 <semantics>
  <mrow>
   <mrow>
    <mi>max</mi>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mi>E</mi>
      </mrow>
     </munder>
     <mfrac>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <msub>
         <mi>v</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>v</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <max></max>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>i</ci>
        <ci>j</ci>
       </interval>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>j</ci>
        </apply>
       </list>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\sum_{(i,j)\in E}\frac{1-\langle v_{i},v_{j}\rangle}{2},
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Semidefinite_programming:89">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo fence="true">∥</mo>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <mo fence="true">∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lVert v_{i}\rVert^{2}=1
  </annotation>
 </semantics>
</math>

, where the maximization is over vectors 

<math display="inline" id="Semidefinite_programming:90">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v_{i}\}
  </annotation>
 </semantics>
</math>

 instead of integer scalars.</p>

<p>This is an SDP because the objective function and constraints are all linear functions of vector inner products. Solving the SDP gives a set of unit vectors in 

<math display="inline" id="Semidefinite_programming:91">
 <semantics>
  <msup>
   <mi>𝐑</mi>
   <mi>𝐧</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐑</ci>
    <ci>𝐧</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R^{n}}
  </annotation>
 </semantics>
</math>

; since the vectors are not required to be collinear, the value of this relaxed program can only be higher than the value of the original quadratic integer program. Finally, a rounding procedure is needed to obtain a partition. Goemans and Williamson simply choose a uniformly random hyperplane through the origin and divide the vertices according to which side of the hyperplane the corresponding vectors lie. Straightforward analysis shows that this procedure achieves an expected <em>approximation ratio</em> (performance guarantee) of 0.87856 - ε. (The expected value of the cut is the sum over edges of the probability that the edge is cut, which is proportional to the angle 

<math display="inline" id="Semidefinite_programming:92">
 <semantics>
  <mrow>
   <msup>
    <mi>cos</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cos></cos>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos^{-1}\langle v_{i},v_{j}\rangle
  </annotation>
 </semantics>
</math>

 between the vectors at the endpoints of the edge over 

<math display="inline" id="Semidefinite_programming:93">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

. Comparing this probability to 

<math display="inline" id="Semidefinite_programming:94">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>v</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
     </list>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1-\langle v_{i},v_{j}\rangle)/{2}
  </annotation>
 </semantics>
</math>

, in expectation the ratio is always at least 0.87856.) Assuming the <a href="Unique_games_conjecture" title="wikilink">Unique Games Conjecture</a>, it can be shown that this approximation ratio is essentially optimal.</p>

<p>Since the original paper of Goemans and Williamson, SDPs have been applied to develop numerous approximation algorithms. Recently, Prasad Raghavendra has developed a general framework for constraint satisfaction problems based on the <a href="Unique_games_conjecture" title="wikilink">Unique Games Conjecture</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="algorithms">Algorithms</h2>

<p>There are several types of algorithms for solving SDPs. These algorithms output the value of the SDP up to an additive error 

<math display="inline" id="Semidefinite_programming:95">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 in time that is polynomial in the program description size and 

<math display="inline" id="Semidefinite_programming:96">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>ϵ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(1/\epsilon)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="interior-point-methods">Interior point methods</h3>

<p>Most codes are based on <a href="interior_point_methods" title="wikilink">interior point methods</a> (CSDP, SeDuMi, SDPT3, DSDP, SDPA). Robust and efficient for general linear SDP problems. Restricted by the fact that the algorithms are second-order methods and need to store and factorize a large (and often dense) matrix.</p>
<h3 id="bundle-method">Bundle method</h3>

<p>The code ConicBundle formulates the SDP problem as a <a href="nonsmooth_optimization" title="wikilink">nonsmooth optimization</a> problem and solves it by the Spectral Bundle method of nonsmooth optimization. This approach is very efficient for a special class of linear SDP problems.</p>
<h3 id="other">Other</h3>

<p>Algorithms based on <a href="augmented_Lagrangian" title="wikilink">augmented Lagrangian</a> method (PENSDP) are similar in behavior to the interior point methods and can be specialized to some very large scale problems. Other algorithms use low-rank information and reformulation of the SDP as a <a href="nonlinear_programming" title="wikilink">nonlinear programming</a> problem (SPDLR).</p>
<h2 id="software">Software</h2>

<p>The following codes are available for SDP:</p>
<ul>
<li><a href="http://sdpa.sourceforge.net/index.html">SDPA</a>, C++</li>
<li><a href="https://projects.coin-or.org/Csdp/">CSDP</a>, C</li>
<li><a href="http://www.math.nus.edu.sg/~mattohkc/sdpt3.html">SDPT3</a>, Matlab. Free.</li>
<li><a href="http://sedumi.ie.lehigh.edu/">SeDuMi</a>, Matlab. Free.</li>
<li>DSDP</li>
<li><a href="http://www.penopt.com/pensdp.html">PENSDP</a>, C, Fortran, Matlab. Commercial.</li>
<li><a href="http://dollar.biz.uiowa.edu/~sburer/pmwiki/pmwiki.php%3Fn=Main.SDPLR%3Faction=logout.html">SDPLR</a>, C, Matlab</li>
<li><a href="http://www-user.tu-chemnitz.de/~helmberg/ConicBundle/">ConicBundle</a>, C/C++</li>
<li><a href="http://cvxopt.org/">CVXOPT</a>, python. Free.</li>
</ul>

<p>SeDuMi runs on MATLAB and uses the Self-Dual method for solving general convex optimization problems.</p>
<h2 id="applications">Applications</h2>

<p>Semidefinite programming has been applied to find approximate solutions to combinatorial optimization problems, such as the solution of the <a href="max_cut" title="wikilink">max cut</a> problem with an <a href="approximation_ratio" title="wikilink">approximation ratio</a> of 0.87856. SDPs are also used in geometry to determine tensegrity graphs, and arise in control theory as <a href="Linear_matrix_inequality" title="wikilink">LMIs</a>.</p>
<h2 id="references">References</h2>
<ul>
<li>Lieven Vandenberghe, Stephen Boyd, "Semidefinite Programming", SIAM Review 38, March 1996, pp. 49–95. <a href="http://stanford.edu/~boyd/papers/pdf/semidef_prog.pdf">pdf</a></li>
</ul>
<ul>
<li>Monique Laurent, Franz Rendl, "Semidefinite Programming and Integer Programming", Report PNA-R0210, CWI, Amsterdam, April 2002. <a href="http://www.optimization-online.org/DB_HTML/2002/12/585.html">optimization-online</a></li>
</ul>
<ul>
<li>E. de Klerk, "Aspects of Semidefinite Programming: Interior Point Algorithms and Selected Applications", Kluwer Academic Publishers, March 2002, ISBN 1-4020-0547-4.</li>
</ul>
<ul>
<li>Robert M. Freund, "Introduction to Semidefinite Programming (SDP), <a href="http://ocw.mit.edu/courses/sloan-school-of-management/15-094j-systems-optimization-models-and-computation-sma-5223-spring-2004/lecture-notes/sdp094_digest.pdf">SDP-Introduction</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www-user.tu-chemnitz.de/~helmberg/semidef.html">Links to introductions and events in the field</a></li>
<li><a href="http://www.cs.elte.hu/~lovasz/semidef.ps">Lecture notes from László Lovász</a> on Semidefinite Programming</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:P-complete_problems" title="wikilink">Category:P-complete problems</a> <a href="Category:Real_algebraic_geometry" title="wikilink">Category:Real algebraic geometry</a> <a href="Category:Linear_programming" title="wikilink">Category:Linear programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Raghavendra, P. 2008. <a href="http://doi.acm.org/10.1145/1374376.1374414">Optimal algorithms and inapproximability results for every CSP?</a>. In Proceedings of the 40th Annual ACM Symposium on theory of Computing (Victoria, British Columbia, Canada, May 17–20, 2008). STOC '08. ACM, New York, NY, 245-254.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
