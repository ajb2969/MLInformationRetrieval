<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1619">Set intersection oracle</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Set intersection oracle</h1>
<hr/>

<p>A <strong>set intersection oracle (SIO)</strong> is a <a href="data_structure" title="wikilink">data structure</a> which represents a collection of sets and can quickly answer queries about whether the <a href="set_intersection" title="wikilink">set intersection</a> of two given sets is non-empty.</p>

<p>The input to the problem is <em>n</em> finite sets. The sum of the sizes of all sets is <em>N</em> (which also means that there are at most <em>N</em> distinct elements). The SIO should quickly answer any query of the form:</p>
<dl>
<dd>"Does the set <em>S</em><sub><em>i</em></sub> intersect the set <em>S</em><sub><em>k</em></sub>"?
</dd>
</dl>
<h2 id="minimum-memory-maximum-query-time">Minimum memory, maximum query time</h2>

<p>Without any pre-processing, a query can be answered by inserting the elements of <em>S</em><sub><em>i</em></sub> into a temporary <a href="hash_table" title="wikilink">hash table</a> and then checking for each element of <em>S</em><sub><em>k</em></sub> whether it is in the hash table. The query time is 

<math display="inline" id="Set_intersection_oracle:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>S</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>S</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <plus></plus>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|S_{i}|+|S_{j}|)=O(N)
  </annotation>
 </semantics>
</math>

 in average.</p>
<h2 id="maximum-memory-minimum-query-time">Maximum memory, minimum query time</h2>

<p>Alternatively, we can pre-process the sets and create an <em>n</em>-by-<em>n</em> table where the intersection information is already entered. Then the query time is 

<math display="inline" id="Set_intersection_oracle:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

, but the memory required is 

<math display="inline" id="Set_intersection_oracle:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="a-compromise">A compromise</h2>

<p>Define a "large set" as a set with at least 

<math display="inline" id="Set_intersection_oracle:3">
 <semantics>
  <msqrt>
   <mi>N</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{N}
  </annotation>
 </semantics>
</math>

 elements. Obviously there are at most 

<math display="inline" id="Set_intersection_oracle:4">
 <semantics>
  <msqrt>
   <mi>N</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{N}
  </annotation>
 </semantics>
</math>

 such sets. Create a table of intersection data between every large set to every other large set. This requires 

<math display="inline" id="Set_intersection_oracle:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N)
  </annotation>
 </semantics>
</math>

 memory. Additionally, for each large set, keep a hash table of all its elements. This requires additional 

<math display="inline" id="Set_intersection_oracle:6">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mrow>
      <mn>3</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N^{3/2})
  </annotation>
 </semantics>
</math>

 memory.</p>

<p>Given two sets, there are three possible cases:</p>
<ol>
<li>Both sets are large. Then just read the answer to the intersection query from the table, in time 

<math display="inline" id="Set_intersection_oracle:7">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

.</li>
<li>Both sets are small. Then insert the elements of one of them into a hash table and check the elements of the other one; because the sets are small, the required time is 

<math display="inline" id="Set_intersection_oracle:8">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>N</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{N})
  </annotation>
 </semantics>
</math>

.</li>
<li>One set is large and one set is small. Loop over all elements in the small set and check them against the hash table of the large set. The required time is again 

<math display="inline" id="Set_intersection_oracle:9">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>N</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{N})
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>In general, if we define a "large set" as a set with at least 

<math display="inline" id="Set_intersection_oracle:10">
 <semantics>
  <msup>
   <mi>N</mi>
   <mi>c</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{c}
  </annotation>
 </semantics>
</math>

 elements, then the number of large set is at most 

<math display="inline" id="Set_intersection_oracle:11">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>c</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{1-c}
  </annotation>
 </semantics>
</math>

 so the memory required is 

<math display="inline" id="Set_intersection_oracle:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <mi>c</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N^{2-c})
  </annotation>
 </semantics>
</math>

, and the query time is 

<math display="inline" id="Set_intersection_oracle:13">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mi>c</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N^{c})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="reduction-to-approximate-distance-oracle">Reduction to approximate distance oracle</h2>

<p>The SIO problem can be reduced to the approximate <a href="distance_oracle" title="wikilink">distance oracle</a> (DO) problem, in the following way.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>Build an undirected bipartite graph where one part contains a node for each of the <em>n</em> sets, and the other part contains a node for each of the (at most) <em>N</em> elements contained in the sets.</li>
<li>There is an edge between a set and an element, iff the set contains the element.</li>
</ul>

<p>This graph has the following properties:</p>
<ul>
<li>If two sets intersect, the distance between them is 2 (from one set, to an element in the intersection, to the other set).</li>
<li>If two sets do not intersect, the distance between them is at least 4.</li>
</ul>

<p>So, with a DO whose approximation factor of less than 2, we can solve the SIO problem.</p>

<p>It is believed that the SIO problem does not have a non-trivial solution. I.e., it requires 

<math display="inline" id="Set_intersection_oracle:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n^{2})
  </annotation>
 </semantics>
</math>

 space to answer queries in time 

<math display="inline" id="Set_intersection_oracle:15">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

. If this conjecture is true, this implies that there is no DO with an approximation factor of less than 2 and a constant query time.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Data_structures" title="wikilink">Category:Data structures</a> <a href="Category:Set_theory" title="wikilink">Category:Set theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
</ol>
</section>
</body>
</html>
