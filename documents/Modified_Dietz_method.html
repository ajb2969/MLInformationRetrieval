<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="138">Modified Dietz method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Modified Dietz method</h1>
<hr/>

<p>The <strong>modified Dietz method</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is a measure of the historical performance of an <a href="investment_portfolio" title="wikilink">investment portfolio</a> in the presence of external flows. (External flows are movements of value such as transfers of cash, securities or other instruments in or out of the portfolio, with no equal simultaneous movement of value in the opposite direction, and which are not income from the investments in the portfolio, such as interest, coupons or dividends.) To calculate the modified Dietz return, divide the gain or loss in value, net of external flows, by the average capital over the period of measurement. The result of the calculation is expressed as a percentage <a href="rate_of_return" title="wikilink">rate of return</a> for the time period. The average capital weights individual cash flows by the amount of time from when those cash flows occur until the end of the period.</p>

<p>This method has the practical advantage over <a href="Internal_Rate_of_Return" title="wikilink">Internal Rate of Return</a> (IRR) that it does not require repeated trial and error to get a result.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Like IRR, the modified Dietz method is a money weighted return methodology rather than a <a href="time_weighted_return" title="wikilink">time weighted return</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>This method for return calculation is used in modern portfolio management. It is one of the methodologies of calculating returns recommended by the Investment Performance Council (IPC) as part of their Global Investment Performance Standards (GIPS). The GIPS standard is intended to standardize the way portfolio returns are calculated internationally.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The method is named after Peter O. Dietz.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="formula">Formula</h2>

<p>The formula for the modified Dietz method is as follows:</p>

<p>

<math display="block" id="Modified_Dietz_method:0">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>M</mi>
     <mi>D</mi>
     <mi>i</mi>
     <mi>e</mi>
     <mi>t</mi>
     <mi>z</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>G</mi>
     <mi>a</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
    <mrow>
     <mi>A</mi>
     <mi>v</mi>
     <mi>e</mi>
     <mi>r</mi>
     <mi>a</mi>
     <mi>g</mi>
     <mi>e</mi>
     <mi>C</mi>
     <mi>a</mi>
     <mi>p</mi>
     <mi>i</mi>
     <mi>t</mi>
     <mi>a</mi>
     <mi>l</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>E</mi>
      <mi>M</mi>
      <mi>V</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>B</mi>
      <mi>M</mi>
      <mi>V</mi>
     </mrow>
     <mo>-</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mrow>
      <mi>B</mi>
      <mi>M</mi>
      <mi>V</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>W</mi>
        <mi>i</mi>
       </msub>
       <mo>×</mo>
       <msub>
        <mi>F</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>D</ci>
       <ci>i</ci>
       <ci>e</ci>
       <ci>t</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">continued-fraction</csymbol>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>a</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>v</ci>
       <ci>e</ci>
       <ci>r</ci>
       <ci>a</ci>
       <ci>g</ci>
       <ci>e</ci>
       <ci>C</ci>
       <ci>a</ci>
       <ci>p</ci>
       <ci>i</ci>
       <ci>t</ci>
       <ci>a</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">continued-fraction</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>E</ci>
        <ci>M</ci>
        <ci>V</ci>
       </apply>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>M</ci>
        <ci>V</ci>
       </apply>
       <ci>F</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>M</ci>
        <ci>V</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>W</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{MDietz}=\cfrac{Gain}{AverageCapital}=\cfrac{EMV-BMV-F}{BMV+\sum_{i=1}^{n}W_%
{i}\times F_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Modified_Dietz_method:1">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>M</mi>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>M</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   EMV
  </annotation>
 </semantics>
</math>

 is the ending market value</p>

<p>

<math display="block" id="Modified_Dietz_method:2">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>M</mi>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>M</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BMV
  </annotation>
 </semantics>
</math>

 is the beginning market value</p>

<p>

<math display="block" id="Modified_Dietz_method:3">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is the net external inflow for the period (contributions to a portfolio are entered as positive flows while withdrawals are entered as negative flows)</p>

<p>and</p>

<p>

<math display="block" id="Modified_Dietz_method:4">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>W</mi>
      <mi>i</mi>
     </msub>
     <mo>×</mo>
     <msub>
      <mi>F</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}W_{i}\times{F_{i}}=
  </annotation>
 </semantics>
</math>

 the sum of each flow 

<math display="inline" id="Modified_Dietz_method:5">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i}
  </annotation>
 </semantics>
</math>

 multiplied by its weight 

<math display="inline" id="Modified_Dietz_method:6">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>The weight 

<math display="inline" id="Modified_Dietz_method:7">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i}
  </annotation>
 </semantics>
</math>

 is the proportion of the time period between the point in time when the flow 

<math display="inline" id="Modified_Dietz_method:8">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i}
  </annotation>
 </semantics>
</math>


 occurs and the end of the period. 

<math display="inline" id="Modified_Dietz_method:9">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i}
  </annotation>
 </semantics>
</math>

 can be calculated as</p>

<p>

<math display="block" id="Modified_Dietz_method:10">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>C</mi>
      <mi>D</mi>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>D</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mrow>
     <mi>C</mi>
     <mi>D</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>D</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i}=\frac{CD-D_{i}}{CD}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Modified_Dietz_method:11">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CD
  </annotation>
 </semantics>
</math>

 is the number of calendar days during the return period being calculated, which equals end date minus start date plus 1<br/>


<math display="block" id="Modified_Dietz_method:12">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{i}
  </annotation>
 </semantics>
</math>

 is the number of days from the start of the return period until the day on which the flow 

<math display="inline" id="Modified_Dietz_method:13">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i}
  </annotation>
 </semantics>
</math>


 occurred. This assumes that the flow happens at the end of the day. If the flow happens at the beginning of the day, use the following formula for calculating weight

<math display="block" id="Modified_Dietz_method:14">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mrow>
       <mi>C</mi>
       <mi>D</mi>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>D</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>C</mi>
     <mi>D</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>C</ci>
        <ci>D</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i}=\frac{CD-D_{i}+1}{CD}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="fees">Fees</h2>

<p>To measure returns net of fees, allow the value of the portfolio to be reduced by the amount of the fees. To calculate returns gross of fees, compensate for them by treating them as an external flow, and exclude accrued fees from valuations.</p>
<h2 id="comparison-with-time-weighted-return-and-internal-rate-of-return">Comparison with Time-Weighted Return and Internal Rate of Return</h2>

<p>The Modified Dietz method has the practical advantage over the <a href="true_time-weighted_rate_of_return" title="wikilink">true time-weighted rate of return</a> method, in that the calculation of a Modified Dietz return does not require portfolio valuations at each point in time whenever an external flow occurs. The <a href="internal_rate_of_return" title="wikilink">internal rate of return</a> method shares this practical advantage with the Modified Dietz method.</p>

<p>The Modified Dietz method has the practical advantage over the <a href="internal_rate_of_return" title="wikilink">internal rate of return</a> method, in that there is a formula for the Modified Dietz return, whereas iterative numerical methods are usually required to estimate the internal rate of return.</p>

<p>The Modified Dietz method is based upon a simple rate of interest principle. It approximates the <a href="internal_rate_of_return" title="wikilink">internal rate of return</a> method, which applies a compounding principle, but if the flows and rates of return are large enough, the results of the Modified Dietz method will significantly diverge from the internal rate of return.</p>

<p>The Modified Dietz return is the solution 

<math display="inline" id="Modified_Dietz_method:15">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 to the equation:</p>

<p>

<math display="block" id="Modified_Dietz_method:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mi>M</mi>
    <mi>V</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>B</mi>
      <mi>M</mi>
      <mi>V</mi>
     </mrow>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>F</mi>
       <mi>i</mi>
      </msub>
      <mo>×</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mi>R</mi>
         <mo>×</mo>
         <mfrac>
          <mrow>
           <mi>T</mi>
           <mo>-</mo>
           <msub>
            <mi>t</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mi>T</mi>
         </mfrac>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>M</ci>
     <ci>V</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>M</ci>
       <ci>V</ci>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>R</ci>
         <apply>
          <divide></divide>
          <apply>
           <minus></minus>
           <ci>T</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>t</ci>
            <ci>i</ci>
           </apply>
          </apply>
          <ci>T</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   EMV=BMV\times(1+R)+\sum_{i=1}^{n}F_{i}\times(1+R\times\frac{T-t_{i}}{T})
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Modified_Dietz_method:17">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>M</mi>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>M</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   EMV
  </annotation>
 </semantics>
</math>

 is the ending market value</p>

<p>

<math display="block" id="Modified_Dietz_method:18">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>M</mi>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>M</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BMV
  </annotation>
 </semantics>
</math>

 is the beginning market value</p>

<p>

<math display="block" id="Modified_Dietz_method:19">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is the total length of time period</p>

<p>and</p>

<p>

<math display="block" id="Modified_Dietz_method:20">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{i}
  </annotation>
 </semantics>
</math>

 is the time between the start of the period and flow 

<math display="inline" id="Modified_Dietz_method:21">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

</p>

<p>Compare this with the <a href="internal_rate_of_return" title="wikilink">internal rate of return</a> (IRR). The IRR (or more strictly speaking, an un-annualized holding period return version of the IRR) is a solution 

<math display="inline" id="Modified_Dietz_method:22">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 to the equation:</p>

<p>

<math display="block" id="Modified_Dietz_method:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mi>M</mi>
    <mi>V</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>B</mi>
      <mi>M</mi>
      <mi>V</mi>
     </mrow>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>F</mi>
       <mi>i</mi>
      </msub>
      <mo>×</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mi>R</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mfrac>
        <mrow>
         <mi>T</mi>
         <mo>-</mo>
         <msub>
          <mi>t</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mi>T</mi>
       </mfrac>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>M</ci>
     <ci>V</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>M</ci>
       <ci>V</ci>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <ci>R</ci>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <ci>T</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   EMV=BMV\times(1+R)+\sum_{i=1}^{n}F_{i}\times(1+R)^{\frac{T-t_{i}}{T}}
  </annotation>
 </semantics>
</math>

</p>

<p>For example, suppose the value of a portfolio is 100 USD at the beginning of the first year, and 300 USD at the end of the second year, and there is an inflow of 50 USD at the end of the first year/beginning of the second year. (Suppose further that neither year is a leap year, so the two years are of equal length.)</p>

<p>To calculate the gain or loss over the two-year period,</p>

<p>

<math display="block" id="Modified_Dietz_method:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mi>a</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mi>O</mi>
    <mi>r</mi>
    <mi>L</mi>
    <mi>o</mi>
    <mi>s</mi>
    <mi>s</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mi>M</mi>
     <mi>V</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>B</mi>
     <mi>M</mi>
     <mi>V</mi>
    </mrow>
    <mo>-</mo>
    <mi>F</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>300</mn>
    <mo>-</mo>
    <mn>100</mn>
    <mo>-</mo>
    <mn>50</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>150</mn>
    <mi>U</mi>
    <mi>S</mi>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>a</ci>
      <ci>i</ci>
      <ci>n</ci>
      <ci>O</ci>
      <ci>r</ci>
      <ci>L</ci>
      <ci>o</ci>
      <ci>s</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>M</ci>
       <ci>V</ci>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>M</ci>
       <ci>V</ci>
      </apply>
      <ci>F</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">300</cn>
      <cn type="integer">100</cn>
      <cn type="integer">50</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">150</cn>
      <ci>U</ci>
      <ci>S</ci>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GainOrLoss=EMV-BMV-F=300-100-50=150USD
  </annotation>
 </semantics>
</math>

</p>

<p>To calculate the average capital over the two-year period,</p>

<p>

<math display="block" id="Modified_Dietz_method:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>v</mi>
    <mi>e</mi>
    <mi>r</mi>
    <mi>a</mi>
    <mi>g</mi>
    <mi>e</mi>
    <mi>C</mi>
    <mi>a</mi>
    <mi>p</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>l</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mi>M</mi>
     <mi>V</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>W</mi>
        <mi>e</mi>
        <mi>i</mi>
        <mi>g</mi>
        <mi>h</mi>
        <mi>t</mi>
       </mrow>
       <mo>×</mo>
       <mi>F</mi>
      </mrow>
      <mi>l</mi>
      <mi>o</mi>
      <mi>w</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>100</mn>
    <mo>+</mo>
    <mrow>
     <mn>0.5</mn>
     <mo>×</mo>
     <mn>50</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>125</mn>
    <mi>U</mi>
    <mi>S</mi>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>v</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>a</ci>
      <ci>g</ci>
      <ci>e</ci>
      <ci>C</ci>
      <ci>a</ci>
      <ci>p</ci>
      <ci>i</ci>
      <ci>t</ci>
      <ci>a</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>M</ci>
       <ci>V</ci>
      </apply>
      <apply>
       <sum></sum>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <apply>
          <times></times>
          <ci>W</ci>
          <ci>e</ci>
          <ci>i</ci>
          <ci>g</ci>
          <ci>h</ci>
          <ci>t</ci>
         </apply>
         <ci>F</ci>
        </apply>
        <ci>l</ci>
        <ci>o</ci>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">100</cn>
      <apply>
       <times></times>
       <cn type="float">0.5</cn>
       <cn type="integer">50</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">125</cn>
      <ci>U</ci>
      <ci>S</ci>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AverageCapital=BMV+\sum Weight\times Flow=100+0.5\times 50=125USD
  </annotation>
 </semantics>
</math>

</p>

<p>so the Modified Dietz return is:</p>

<p>

<math display="block" id="Modified_Dietz_method:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>G</mi>
      <mi>a</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mi>O</mi>
      <mi>r</mi>
      <mi>L</mi>
      <mi>o</mi>
      <mi>s</mi>
      <mi>s</mi>
     </mrow>
     <mo>/</mo>
     <mi>A</mi>
    </mrow>
    <mi>v</mi>
    <mi>e</mi>
    <mi>r</mi>
    <mi>a</mi>
    <mi>g</mi>
    <mi>e</mi>
    <mi>C</mi>
    <mi>a</mi>
    <mi>p</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>l</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>150</mn>
    <mo>/</mo>
    <mn>125</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>120</mn>
    <mo lspace="0pt" rspace="3.5pt">%</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>a</ci>
        <ci>i</ci>
        <ci>n</ci>
        <ci>O</ci>
        <ci>r</ci>
        <ci>L</ci>
        <ci>o</ci>
        <ci>s</ci>
        <ci>s</ci>
       </apply>
       <ci>A</ci>
      </apply>
      <ci>v</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>a</ci>
      <ci>g</ci>
      <ci>e</ci>
      <ci>C</ci>
      <ci>a</ci>
      <ci>p</ci>
      <ci>i</ci>
      <ci>t</ci>
      <ci>a</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">150</cn>
      <cn type="integer">125</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">percent</csymbol>
      <cn type="integer">120</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GainOrLoss/AverageCapital=150/125=120\%
  </annotation>
 </semantics>
</math>

</p>

<p>The internal rate of return in this example is 125%:</p>

<p>

<math display="block" id="Modified_Dietz_method:27">
 <semantics>
  <mrow>
   <mn>300</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>100</mn>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mn>125</mn>
        <mo lspace="0pt" rspace="3.5pt">%</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>50</mn>
     <mo>×</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mn>125</mn>
         <mo lspace="0pt" rspace="3.5pt">%</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mrow>
        <mn>2</mn>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mn>2</mn>
      </mfrac>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>225</mn>
    <mo>+</mo>
    <mrow>
     <mn>50</mn>
     <mo>×</mo>
     <mrow>
      <mn>150</mn>
      <mo lspace="0pt" rspace="3.5pt">%</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>225</mn>
    <mo>+</mo>
    <mn>75</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <cn type="integer">300</cn>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">100</cn>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="latexml">percent</csymbol>
         <cn type="integer">125</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">50</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="latexml">percent</csymbol>
          <cn type="integer">125</cn>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">225</cn>
      <apply>
       <times></times>
       <cn type="integer">50</cn>
       <apply>
        <csymbol cd="latexml">percent</csymbol>
        <cn type="integer">150</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">225</cn>
      <cn type="integer">75</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   300=100\times(1+125\%)+50\times(1+125\%)^{\frac{2-1}{2}}=225+50\times 150\%=22%
5+75
  </annotation>
 </semantics>
</math>

</p>

<p>so in this case, the Modified Dietz return is noticeably less than the IRR. This divergence between the Modified Dietz return and the internal rate of return is due to a significant flow within the period, and the fact that the returns are large.</p>
<h2 id="annual-rate-of-return">Annual Rate of Return</h2>

<p>Note that the Modified Dietz return is not an annual rate of return, unless the period happens to be one year. Annualisation, which is conversion of the return to an annual rate of return, is a separate process.</p>
<h2 id="the-simple-dietz-method">The Simple Dietz Method</h2>

<p>Note also that the <a href="simple_Dietz_method" title="wikilink">simple Dietz method</a> is a special case of the Modified Dietz method, in which external flows are assumed to occur at the midpoint of the period, or equivalently, spread evenly throughout the period, whereas no such assumption is made when using the Modified Dietz method, and the timing of any external flows is taken into account.</p>
<h2 id="money-weighted-return">Money-Weighted Return</h2>

<p>The Modified Dietz method is an example of a money (or dollar) weighted methodology. In particular, if the Modified Dietz return on two portfolios are 

<math display="inline" id="Modified_Dietz_method:28">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Modified_Dietz_method:29">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{2}
  </annotation>
 </semantics>
</math>

, measured over a common matching time interval, then the Modified Dietz return on the two portfolios put together over the same time interval is the weighted average of the two returns:</p>

<p>

<math display="block" id="Modified_Dietz_method:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>W</mi>
     <mn>1</mn>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>W</mi>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>R</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{1}\times R_{1}+W_{2}\times R_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>where the weights of the portfolios depend on the Average Capital over the time interval:</p>

<p>

<math display="block" id="Modified_Dietz_method:31">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <mi>v</mi>
     <mi>e</mi>
     <mi>r</mi>
     <mi>a</mi>
     <mi>g</mi>
     <mi>e</mi>
     <mi>C</mi>
     <mi>a</mi>
     <mi>p</mi>
     <mi>i</mi>
     <mi>t</mi>
     <mi>a</mi>
     <msub>
      <mi>l</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mi>v</mi>
      <mi>e</mi>
      <mi>r</mi>
      <mi>a</mi>
      <mi>g</mi>
      <mi>e</mi>
      <mi>C</mi>
      <mi>a</mi>
      <mi>p</mi>
      <mi>i</mi>
      <mi>t</mi>
      <mi>a</mi>
      <msub>
       <mi>l</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>A</mi>
      <mi>v</mi>
      <mi>e</mi>
      <mi>r</mi>
      <mi>a</mi>
      <mi>g</mi>
      <mi>e</mi>
      <mi>C</mi>
      <mi>a</mi>
      <mi>p</mi>
      <mi>i</mi>
      <mi>t</mi>
      <mi>a</mi>
      <msub>
       <mi>l</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>v</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>a</ci>
      <ci>g</ci>
      <ci>e</ci>
      <ci>C</ci>
      <ci>a</ci>
      <ci>p</ci>
      <ci>i</ci>
      <ci>t</ci>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>v</ci>
       <ci>e</ci>
       <ci>r</ci>
       <ci>a</ci>
       <ci>g</ci>
       <ci>e</ci>
       <ci>C</ci>
       <ci>a</ci>
       <ci>p</ci>
       <ci>i</ci>
       <ci>t</ci>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>l</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>v</ci>
       <ci>e</ci>
       <ci>r</ci>
       <ci>a</ci>
       <ci>g</ci>
       <ci>e</ci>
       <ci>C</ci>
       <ci>a</ci>
       <ci>p</ci>
       <ci>i</ci>
       <ci>t</ci>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>l</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i}=\frac{AverageCapital_{i}}{AverageCapital_{1}+AverageCapital_{2}}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="linked-return-versus-true-time-weighted-return">Linked Return versus True Time-Weighted Return</h2>

<p>An alternative to the Modified Dietz method is to link geometrically the Modified Dietz returns for shorter periods. This method is classed as a time-weighted method, but does not produce the same results as the <a href="True_Time-Weighted_Rate_of_Return" title="wikilink">true time weighted</a> method, which requires valuations at the time of each cash flow.</p>
<h2 id="issues">Issues</h2>

<p>There are sometimes difficulties when calculating or decomposing portfolio returns, if all transactions are treated as occurring at a single point during the day. Whatever method is applied to calculate returns, an assumption that all transactions take place simultaneously at a single point in time each day can lead to errors.</p>

<p>For example, consider a scenario where a portfolio is empty at the start of a day, so that BMV = 0. There is then an external inflow during a day of F = $100. By the close of the day, market prices have moved, and EMV = $99.</p>

<p>If all transactions are treated as occurring at the end of the day, then there is zero start value BMV, and zero value for Average Capital, so no Modified Dietz return can be calculated.</p>

<p>Some such problems are resolved if the Modified Dietz method is further adjusted so as to put purchases at the open and sales at the close, but more sophisticated exception-handling produces better results.</p>

<p>There are sometimes other difficulties when decomposing portfolio returns, if all transactions are treated as occurring at a single point during the day.</p>

<p>For example, consider a fund opening with just $100 of a single stock that is sold for $110 during the day. During the same day, another stock is purchased for $110, closing with a value of $120. The returns on each stock are 10% and 120/110 - 1 = 9.0909% (4 d.p.) and the portfolio return is 20%. The asset weights <em>w<sub>i</sub></em> (as opposed to the time weights <em>W<sub>i</sub></em>) required to get the returns for these two assets to roll up to the portfolio return are 1200% for the first stock and a negative 1100% for the second:</p>
<dl>
<dd>w*10/100 + (1-w)*10/110 = 20/100 → w = 12.
</dd>
</dl>

<p>Such weights are absurd, because the second stock is not held short.</p>
<h2 id="excel-vba-function-for-modified-dietz-return">Excel VBA function for modified Dietz return</h2>
<pre><code>Public Function MDIETZ(dStartValue As Double, dEndValue As Double, iPeriod As Integer, rCash As Range, rDays As Range) As Double

    'Jelle-Jeroen Lamkamp 10 Jan 2008
    Dim i As Integer: Dim Cash() As Double: Dim Days() As Integer
    Dim Cell As Range: Dim SumCash As Double: Dim TempSum As Double

    'Some error trapping
    If rCash.Cells.Count &lt;&gt; rDays.Cells.Count Then MDIETZ = CVErr(xlErrValue): Exit Function
    If Application.WorksheetFunction.Max(rDays) &gt; iPeriod Then MDIETZ = CVErr(xlErrValue): Exit Function

    ReDim Cash(rCash.Cells.Count - 1)
    ReDim Days(rDays.Cells.Count - 1)

    i = 0
    For Each Cell In rCash
        Cash(i) = Cell.Value: i = i + 1
    Next Cell

    i = 0
    For Each Cell In rDays
        Days(i) = Cell.Value: i = i + 1
    Next Cell

    SumCash = Application.WorksheetFunction.Sum(rCash)

    TempSum = 0
    For i = 0 To (rCash.Cells.Count - 1)
            TempSum = TempSum + (((iPeriod - Days(i)) / iPeriod) * Cash(i))
    Next i

    MDIETZ = (dEndValue - dStartValue - SumCash) / (dStartValue + TempSum)

End Function</code></pre>

<p>The above VBA program is designed to use with Excel. Here is a Java program written for general purposes.</p>
<h2 id="java-method-for-modified-dietz-return">Java Method for Modified Dietz Return</h2>
<pre><code>private static double modifiedDietz (double emv, double bmv, double cashFlow[], int numCD, int numD[]) {

    /* emv:        Ending Market Value
     * bmv:        Beginning Market Value
     * cashFlow[]: Cash Flow
     * numCD:      actual number of days in the period
     * numD[]:     number of days between beginning of the period and date of cashFlow[]
     */

    double md = -99999; // initialize modified dietz with a debugging number

    try {

        double[] weight = new double[cashFlow.length];

        if (numCD &lt;= 0) {
            throw new ArithmeticException ("numCD &lt;= 0");
        }

        for (int i=0; i</code></pre>

<p></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
