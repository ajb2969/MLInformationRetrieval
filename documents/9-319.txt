


Operational transformation




Operational transformation

Operational transformation (OT) is a technology for supporting a range of collaboration functionalities in advanced collaborative software systems. OT was originally invented for consistency maintenance and concurrency control in collaborative editing of plain text documents. Two decades of research has extended its capabilities and expanded its applications to include group undo, locking, conflict resolution, operation notification and compression, group-awareness, HTML/XML and tree-structured document editing, collaborative office productivity tools, application-sharing, and collaborative computer-aided media design tools (see OTFAQ). In 2009 OT was adopted as a core technique behind the collaboration features in Apache Wave and Google Docs.
History
Operational Transformation was pioneered by C. Ellis and S. Gibbs1 in the GROVE (GRoup Outline Viewing Edit) system in 1989. Several years later, some correctness issues were identified and several approaches2 3 4 5 were independently proposed to solve these issues, which was followed by another decade of continuous efforts of extending and improving OT by a community of dedicated researchers. In 1998, a Special Interest Group on Collaborative Editing (SIGCE) was set up to promote communication and collaboration among CE and OT researchers. Since then, SIGCE holds annual CE workshops in conjunction with major CSCW (Computer Supported Cooperative Work) conferences, such as ACM CSCW, GROUP and ECSCW.
System architecture
Collaborative systems using OT typically adopt a replicated architecture for the storage of shared documents to ensure good responsiveness in high latency environments, such as the Internet. The shared documents are replicated at the local storage of each collaborating site, so editing operations can be performed at local sites immediately and then propagated to remote sites. Remote editing operations arriving at a local site are typically transformed and then executed. The transformation ensures that application-dependent consistency criteria are achieved across all sites. The lock-free, nonblocking property of OT makes the local response time not sensitive to networking latencies. As a result, OT is particularly suitable for implementing collaboration features such as group editing in the Web/Internet context.
Basics
 The basic idea of OT can be illustrated by using a simple text editing scenario as follows. Given a text document with a string "abc" replicated at two collaborating sites; and two concurrent operations:

O1 = Insert[0, "x"] (to insert character "x" at position "0")
O2 = Delete[2, "c"] (to delete the character "c" at position "2")

generated by two users at collaborating sites 1 and 2, respectively. Suppose the two operations are executed in the order of O1 and O2 (at site 1). After executing O1, the document becomes "xabc". To execute O2 after O1, O2 must be transformed against O1 to become: O2' = Delete[3, "c"], whose positional parameter is incremented by one due to the insertion of one character "x" by O1. Executing O2' on "xabc" deletes the correct character "c" and the document becomes "xab". However, if O2 is executed without transformation, it incorrectly deletes character "b" rather than "c". The basic idea of OT is to transform (or adjust) the parameters of an editing operation according to the effects of previously executed concurrent operations so that the transformed operation can achieve the correct effect and maintain document consistency.
Consistency models
One functionality of OT is to support consistency maintenance in collaborative editing systems. A number of consistency models have been proposed in the research community, some generally for collaborative editing systems, and some specifically for OT algorithms.
The CC model
In Ellis and Gibbs 1989 paper "Concurrency control in groupware systems",6 two consistency properties are required for collaborative editing systems:

Precedence (Causality) property: ensures the execution order of causally dependent operations be the same as their natural cause-effect order during the process of collaboration. The causal relationship between two operations is defined formally by Lamport's "happened-before" relation. When two operations are not causally dependent, they are concurrent. Two concurrent operations can be executed in different order on two different document copies.
Convergence: ensures the replicated copies of the shared document be identical at all sites at quiescence (i.e., all generated operations have been executed at all sites).

Since concurrent operations may be executed in different orders and editing operations are not commutative in general, copies of the document at different sites may diverge (inconsistent). The first OT algorithm was proposed in Ellis and Gibbs's paper7 to achieve convergence in a group text editor; the state-vector (or vector clock in classic distributed computing) was used to preserve the precedence property.
The CCI model
The CCI model was proposed as a genonsistency management in collaborative editing systems.89 Under the CCI model, three consistency properties are grouped together:

Causality Preservation : the same as the precedence property in the CC Model.
Convergence: the same as the convergence property in the CC Model.
Intention Preservation: ensures that the effect of executing an operation on any document state be the same as the intention of the operation. The intention of an operation O is defined as the execution effect which can be achieved by applying O on the document state from which O was generated.

The CCI model extends the CC model with a new criterion: Intention Preservation. The essential difference between convergence and intention preservation is that the former can always be achieved by a serialization protocol, but the latter may not be achieved by any serialization protocol if operations were always executed in their original forms. Achieving the nonserialisable intention preservation property has been a major technical challenge. OT has been found particularly suitable for achieving convergence and intention preservation in collaborative editing systems.
The CCI model is independent of document types or data models, operation types, or supporting techniques (OT, multi-versioning, serialization, undo/redo). It was not intended for correctness verification for techniques (e.g. OT) that are designed for specific data and operation models and for specific applications. In,10 the notion of intention preservation was defined and refined at three levels: First, it was defined as a generic consistency requirement for collaborative editing systems; Second, it was defined as operation context-based pre- and post- transformation conditions for generic OT functions; Third, it was defined as specific operation verification criteria to guide the design of OT functions for two primitive operations: string-wise insert and delete, in collaborative plain text editors.
The CSM model
The condition of intention preservation was not formally specified in the CCI model for purposes of formal proofs. The SDT11 and LBT12 approaches try to formalize an alternative conditions that can be proved. The consistency model proposed in these two approaches consist of the following formal conditions:

Causality: the same definition as in CC Model


Single-operation effects: the effect of executing any operation in any execution state achieves the same effect as in its generation state


Multi-operation effects: the effects relation of any two operations is maintained after they are both executed in any states

The CA model
The above CSM model requires that a total order of all objects in the system be specified. Effectively, the specification is reduced to new objects introduced by insert operations. However, specification of the total order entails application-specific policies such as those to break insertion ties (i.e., new objects inserted by two current operations at the same position). Consequently, the total order becomes application specific. Moreover, in the algorithm, the total order must be maintained in the transformation functions and control procedure, which increases time/space complexities of the algorithm.
Alternatively, the CA model is based on the Admissibility Theory.13 The CA model includes two aspects:

Causality: the same definition as in CC Model
Admissibility: The invocation of every operation is admissible in its execution state, i.e., every invocation must not violate any effects relation (object ordering) that has been established by earlier invocations.

These two conditions imply convergence. All cooperating sites converge in a state in which there is a same set of objects that are in the same order. Moreover, the ordering is effectively determined by the effects of the operations when they are generated. Since the two conditions also impose additional constraints on object ordering, they are actually stronger than convergence. The CA model and the design/prove approach are elaborated in the 2005 paper.14 It no longer requires that a total order of objects be specified in the consistency model and maintained in the algorithm, which hence results in reduced time/space complexities in the algorithm.
OT system structure
OT is a system of multiple components. One established strategy of designing OT systems151617181920 is to separate the high-level Transformation Control (or Integration) Algorithms from the low-level Transformation Functions. The transformation control algorithm is concerned with determining:

Which operation should be transformed against a causally ready new operation
The order of the transformations

The control algorithm invokes a corresponding set of transformation functions, which determine how to transform one operation against another according to the operation types, positions, and other parameters. The correctness responsibilities of these two layers are formally specified by a set of transformation properties and conditions. Different OT systems with different control algorithms, functions, and communication topologies require maintaining different sets of transformation properties. The separation of an OT system into these two layers allows for the design of generic control algorithms that are applicable to different kinds of application with different data and operation models.
The other alternative approach was proposed in.21 In their approach, an OT algorithm is correct if it satisfies two formalized correctness criteria:

Causality preservation
Admissibility preservation

As long as these two criteria are satisfied, the data replicas converge (with additional constraints) after all operations are executed at all sites. There is no need to enforce a total order of execution for the sake of achieving convergence. Their approach is generally to first identify and prove sufficient conditions for a few transformation functions, and then design a control procedure to ensure those sufficient conditions. This way the control procedure and transformation functions work synergistically to achieve correctness, i.e., causality and admissibility preservation. In their approach, there is no need to satisfy transformation properties such as TP2 because it does not require that the (inclusive) transformation functions work in all possible cases.
OT data and operation models
There exist two underlying models in each OT system: the data model that defines the way data objects in a document are addressed by operations, and the operation model that defines the set of operations that can be directly transformed by OT functions. Different OT systems may have different data and operation models. For example, the data model of the first OT system22 is a single linear address space; and its operation model consists of two primitive operations: character-wise insert and delete. The basic operation model has been extended to include a third primitive operation update to support collaborative Word document processing23 and 3D model editing.24 The basic OT data model has been extended into a hierarchy of multiple linear addressing domains,2526 which is capable of modeling a broad range of documents. A data adaption process is often required to map application-specific data models to an OT-compliant data model.2728
There exist two approaches to supporting application level operations in an OT system:

Generic operation model approach: which is to devise transformation functions for three primitive operations: insert, delete, and update.29 This approach needs an operation adaptation process to map application operations to these primitive operations. In this approach, the OT operation model is generic, so transformation functions can be reused for different applications.
Application-specific operation model approach: which is to devise transformation functions for each pair of application operations.3031 For an application with m different operations, m x m transformation functions are needed for supporting this application. In this approach, transformation functions are application-specific and cannot be reused in different applications.

OT functions
Various OT functions have been designed for OT systems with different capabilities and used for different applications. OT functions used in different OT systems may be named differently, but they can be classified into two categories:

one is Inclusion Transformation (or Forward Transformation): IT(Oa, Ob) or 
 
 
 
 , which transforms operation Oa against another operation Ob in such a way that the impact of Ob is effectively included; and
the other is Exclusion Transformation (or Backward Transformation): ET (Oa, Ob) or 
 
 
 
 , which transforms operation Oa against another operation Ob in such a way that the impact of Ob is effectively excluded.

For example, suppose a type String with an operation ins(p, c,sid) where p is the position of insertion, c the character to insert and sid the identifier of the site that has generated the operation. We can write the following transformation function:
T(ins(

),ins(

)) :-
  if (

) return ins(

)
  else if (

 and 

) return ins(

)
  else return ins(

)


(ins(

),ins(

)) :-
  if (

) return ins(

)
  else if (

 and 

) return ins(

)
  else return ins(

)
Some OT systems use both IT and ET functions, and some use only IT functions. The complexity of OT function design is determined by various factors:

the functionality of the OT system: whether the OT system supports do (consistency maintenance), undo, locking,32 awareness, application sharing,33

3435 etc.;

the correctness responsibility in the OT system: what transformation properties (CP1/TP1, CP2/TP2, IP2, IP3, RP) to meet; whether ET is used;
the operation model of the OT system: whether the OT operation model is generic (e.g. primitive insert, delete, update), or application-specific (all operations of the target application); and
the data model of the OT system: whether the data in each operation is character-wise (an individual object), string-wise (a sequence of objects), hierarchical, or other structures.

Transformation properties
Various transformation properties for ensuring OT system correctness have been identified. These properties can be maintained by either the transformation control algorithm363738394041 or by the transformation functions.42 Different OT system designs have different division of responsibilities among these components. The specifications of these properties and preconditions of requiring them are given below.
Convergence properties
  The following two properties are related to achieving convergence.

CP1/TP1: For every pair of concurrent operations 
 
 
 
  and 
 
 
 
  defined on the same state, the transformation function T satisfies CP1/TP1 property if and only if
 
 
 
  where 
 
 
 
  denotes the sequence of operations containing 
 
 
 
  followed by 
 
 
 
 ;and where 
 
 
 
  denotes equivalence of the two sequences of operations. CP1/TP1 Precondition: CP1/TP1 is required only if the OT system allows any two operations to be executed in different orders.
CP2/TP2: For every three concurrent operations 
 
 
 
  and 
 
 
 
  defined on the same document state, the transformation function T satisfies CP2/TP2 property if and only if
 
 
 
 . CP2/TP2 stipulates equality between two operations transformed with regard to two equivalent sequences of operations: the transformation of 
 
 
 
  against the sequence of operation 
 
 
 
  followed by 
 
 
 
  must give the same operation as the transformation of 
 
 
 
  against the sequence formed by 
 
 
 
  and 
 
 
 
 . CP2/TP2 Precondition: CP2/TP2 is required only if the OT systems allows two operations 
 
 
 
  and 
 
 
 
  be IT-transformed in two different document states (or contexts).

Inverse properties
The following three properties are related to achieving the desired group undo effect. They are:

IP1: Given any document state S and the sequence 
 
 
 
 , we have 
 
 
 
 , which means the sequence 
 
 
 
  is equivalent to a single identity operation I with respect to the effect on the document state. This property is required in an OT system for achieving the correct undo effect, but is not related to IT functions.
IP2: The property IP2 expresses that the sequence 
 
 
 
  has no effect on the transformation of other operations. The transformation functions satisfy IP2 if and only if
 
 
 
 , which means that the outcome of transforming 
 
 
 
  against the sequence 
 
 
 
  is equivalent to the outcome of transforming 
 
 
 
  against the identity operation I. IP2-Precondition: IP2 is required only if the OT systems allows an operation 
 
 
 
  to be transformed against a pair of do and undo operations 
 
 
 
 , one-by-one.
IP3: Given two concurrent operations 
 
 
 
  and 
 
 
 
  defined on the same document state (or context), if 
 
 
 
  and 
 
 
 
 . The transformation functions satisfy the property IP3 if and only if 
 
 
 
 , which means that the transformed inverse operation 
 
 
 
  is equal to the inverse of the transformed operation 
 
 
 
 . IP3-Precondition: IP3 is required only if the OT system allows an inverse operation 
 
 
 
  to be transformed against an operation 
 
 
 
  that is concurrent and defined on the same document state as (or context-equivalent to) 
 
 
 
 .

OT control (integration) algorithms
Various OT control algorithms have been designed for OT systems with different capabilities and for different applications. The complexity of OT control algorithm design is determined by multiple factors. A key differentiating factor is whether an algorithm is capable of supporting concurrency control (do) and/or group undo.4344454647 In addition, different OT control algorithm designs make different tradeoffs in:

assigning correctness responsibilities among the control algorithm and transformation functions, and
time-space complexity of the OT system.

Most existing OT control algorithms for concurrency control adopts the theory of causality/concurrency as the theoretical basis: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution. However, it was well known that concurrency condition alone cannot capture all OT transformation conditions.4849505152 In a recent work, the theory of operation context has been proposed to explicitly represent the notion of a document state, which can be used to formally express OT transformation conditions for supporting the design and verification of OT control algorithms.53
The following table gives an overview of some existing OT control/integration algorithms




OT Control/Integration Algorithms(Systems)

Required Transformation Function Types

Support OT-based Do?

Support OT-based Undo?

Transformation Properties Supported By Control Algorithm

Transformation Properties Supported By Transformation Functions

Transformation Ordering and Propagation Constraints

Timestamp





dOPT54 (GROVE)

T (IT)

Yes

No

None

CP1/TP1, CP2/TP2

Causal order

State vector



selective-undo{{cite journal

author = Prakash, Atul and Knister, Michael J.

title = A framework for undoing actions in collaborative systems

journal = ACM Trans. Comput.-Hum. Interact.

volume = 1

year = 1994

pages = 295–330

doi = 10.1145/198425.198427



adOPTed55{{cite conference

author = M. Ressel and R. Gunzenhauser

title = Reducing the Problems of Group Undo

booktitle = Proc. of the ACM Conf. on Supporting Group Work

pages = 131–139

year = 1999 }} (JOINT EMACS)

LTransformation (IT)

Yes



Jupiter56

xform (IT)

Yes

No

CP2/TP2

CP1/TP1

Causal order + Central transformation server

Scalar



Google Wave OT57

transform and composition(IT)

Yes

??

CP2/TP2

CP1/TP1

Causal order + Central transformation server + stop'n'wait propagation protocol

Scalar



GOT58 (REDUCE)

IT and ET

Yes

No

CP1/TP1, CP2/TP2

None

Causal order + Discontinuous total order

State vector



GOTO59 (REDUCE, CoWord, CoPPT, CoMaya)

IT and ET

Yes

No

None

CP1/TP1, CP2/TP2

Causal order

State vector



AnyUndo60 (REDUCE, CoWord, CoPPT, CoMaya)

IT and ET

No

Undo any operation

IP2, IP3, RP

IP1, CP1/TP1, CP2/TP2

Causal order

State vector



SCOP {{cite conference

author = Shen, Haifeng and Sun, Chengzheng

title = Flexible notification for collaborative systems

booktitle = CSCW '02: Proceedings of the 2002 ACM conference on Computer supported cooperative work

year = 2002

pages = 77-86

doi = 10.1145/587078.587090 }} (NICE)

IT



COT {{cite journal

author = D. Sun and C. Sun

title = Context-based Operational Transformation for Distributed Collaborative Editing Systems

journal = IEEE Trans. on Parallel and Distributed Systems

year = 2009

url = http://ieeexplore.ieee.org/xpl/freepre_abs_all.jsp?isnumber=4359390&arnumber;;=4668339 }}  (REDUCE, CoWord, CoPPT, CoMaya)

IT

Yes



TIBOT {{cite conference

author = R. Li, D. Li and C. Sun

title = A Time Interval Based Consistency Control Algorithm for Interactive Groupware Applications

booktitle = ICPADS '04: Proceedings of the Parallel and Distributed Systems, Tenth International Conference

year = 2004

pages = 429

doi = 10.1109/ICPADS.2004.12 }}

IT



SOCT4{{cite conference

author = Vidot, N. |author2=Cart, M. |author3=Ferrie, J. |author4=Suleiman, M.

year = 2000

title = Copies convergence in a distributed real-time collaborative environment

conference =

booktitle = Proceedings of the 2000 ACM conference on Computer supported cooperative work

pages = 171–180

publisher = ACM Press New York, NY, USA



SOCT2{{cite conference

author = Suleiman, M. |author2=Cart, M. |author3=Ferrié, J.

year = 1998

title = Concurrent Operations in a Distributed and Mobile Collaborative Environment

conference =

booktitle = Proceedings of the Fourteenth International Conference on Data Engineering, February

pages = 23–27

publisher =



MOT2{{cite conference

author = M. Cart, Jean Ferrié,

year = 2007

title = Synchronizer Based on Operational Transformation for P2P Environments

booktitle = Proceedings of the 3rd International Conference on Collaborative Computing: Networking, Applications and Worksharing

url = http://hal.archives-ouvertes.fr/docs/00/08/60/98/PDF/cart_document_RR_LIRMM.pdf

pages = 127–138

accessdate = 2007-07-26
}}




A continuous total order is a strict total order where it possible to detect a missing element i.e. 1,2,3,4,... is a continuous total order, 1,2,3,5,... is not a continuous total order.

The transformation-based algorithms proposed in 6162 are based on the alternative consistency models "CSM" and "CA" as described above. Their approaches differ from those listed in the table. They use vector timestamps for causality preservation. The other correctness conditions are "single-"/"multi-" operation effects relation preservation or "admissibility" preservation. Those conditions are ensured by the control procedure and transformation functions synergistically. There is no need to discuss TP1/TP2 in their work. Hence they are not listed in the above table.
There exist some other optimistic consistency control algorithms that seek alternative ways to design transformation algorithms, but do not fit well with the above taxonomy and characterization. For example, Mark and Retrace63
The correctness problems of OT led to introduction of transformationless post-OT schemes, such as WOOT,64 Logoot65 and Causal Trees (CT).66 "Post-OT" schemes decompose the document into atomic operations, but they workaround the need to transform operations by employing a combination of unique symbol identifiers, vector timestamps and/or tombstones.
Critique of OT
While the classic OT approach of defining operations through their offsets in the text seems to be simple and natural, real-world distributed systems raise serious issues. Namely, that operations propagate with finite speed, states of participants are often different, thus the resulting combinations of states and operations are extremely hard to foresee and understand. As Li and Li put it, Due to the need to consider complicated case coverage, formal proofs are very complicated and error-prone, even for OT algorithms that only treat two characterwise primitives (insert and delete).67
Similarly, Joseph Gentle who is an ex Google Wave engineer and an author of the Share.JS library wrote: Unfortunately, implementing OT sucks. There's a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly. ... Wave took 2 years to write and if we rewrote it today, it would take almost as long to write a second time.68
For OT to work, every single change to the data needs to be captured: "Obtaining a snapshot of the state is usually trivial, but capturing edits is a different matter altogether. [...] The richness of modern user interfaces can make this problematic, especially within a browser-based environment." A proposed alternative to OT is Differential Synchronization.69
See also

Optimistic Replication
Data synchronization
Collaborative Editing
Consistency models

References
External links

OTFAQ: Operational Transformation Frequently Asked Questions and Answers
SIGCE: Special Interest Group of Collaborative Editing
International Workshop on Collaborative Editing Systems
[http://dsonline.computer.org/portal/site/dsonline/menuitem.20d6846e1c7ed783f1a516106bbe36ec/index.jsp?&pName;=dso_level1_home&path;=dsonline/topics/collaborative&file;=index.xml&xsl;=generic.xsl& Distributed System Online - Collaborative editing]
Simple explanation of OT in Google Docs
Basics of OT in the Open Coweb Framework

Relevant online talks

Google Wave: Live collaborative editing
Google Tech Talk: Issues and Experiences in Designing Real-time Collaborative Editing Systems
Microsoft Research talk: Consistency maintenance in real-time collaborative editing systems

"
Category:Concurrency control Category:Collaboration Category:Distributed algorithms Category:Groupware



↩
↩
↩
↩
↩





↩
↩
↩









↩
↩
↩
↩

↩


↩
↩
↩
↩
↩






↩

↩


















↩
↩
↩
↩
↩
ShareJS – Live concurrent editing in your app.. Sharejs.org (2011-11-06). Retrieved on 2013-08-16.↩
↩




