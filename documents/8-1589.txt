   Computation history      Computation history   In computer science , a computation history is a sequence of steps taken by an abstract machine in the process of computing its result. Computation histories are frequently used in proofs about the capabilities of certain machines, and particularly about the undecidability of various formal languages .  Formally, a computation history is a (normally finite ) sequence of configurations of a formal automaton . Each configuration fully describes the status of the machine at a particular point. To be valid, certain conditions must hold:   the first configuration must be a valid initial configuration of the automaton and  each transition between adjacent configurations must be valid according to the transition rules of the automaton.   In addition, to be complete , a computation history must be finite and   the final configuration must be a valid terminal configuration of the automaton.   The definitions of "valid initial configuration", "valid transition", and "valid terminal configuration" vary for different kinds of formal machines.  A deterministic automaton has exactly one computation history for a given initial configuration, though the history may be infinite and therefore incomplete.  Finite State Machines  For a finite state machine    M   M   M   , a configuration is simply the current state of the machine, together with the remaining input. The first configuration must be the initial state of   M   M   M   and the complete input. A transition from a configuration    (  S  ,  I  )     S  I    (S,I)   to a configuration    (  T  ,  J  )     T  J    (T,J)   is allowed if    I  =   a  J       I    a  J     I=aJ   for some input symbol   a   a   a   and if   M   M   M   has a transition from   S   S   S   to   T   T   T   on input   a   a   a   . The final configuration must have the empty string   ϵ   ϵ   \epsilon   as its remaining input; whether   M   M   M   has accepted or rejected the input depends on whether the final state is an accepting state. 1  Turing Machines  Computation histories are more commonly used in reference to Turing machines . The configuration of a single-tape Turing machine consists of the contents of the tape, the position of the read/write head on the tape, and the current state of the associated state machine; this is usually written      …  0011010101  q  00110101010...      normal-…  0011010101  q  00110101010...    ...0011010101q00110101010...     where   q   q   q   is the current state of the machine, represented in some way that's distinguishable from the tape language, and where   q   q   q   is positioned immediately before the position of the read/write head.  Consider a Turing machine   M   M   M   on input   w   w   w   . The first configuration must be     q  0    w  0    w  1   …       subscript  q  0    subscript  w  0    subscript  w  1   normal-…    q_{0}w_{0}w_{1}...   , where    q  0     subscript  q  0    q_{0}   is the initial state of the Turing machine. The machine's state in the final configuration must be either    q  a     subscript  q  a    q_{a}   (the accept state) or    q  r     subscript  q  r    q_{r}   (the reject state). A configuration    c   i  +  1      subscript  c    i  1     c_{i+1}   is a valid successor to configuration    c  i     subscript  c  i    c_{i}   if there's a transition from the state in    c  i     subscript  c  i    c_{i}   to the state in    c   i  +  1      subscript  c    i  1     c_{i+1}   which manipulates the tape and moves the read/write head in a way that produces the result in    c   i  +  1      subscript  c    i  1     c_{i+1}   . 2  Decidability results  Computation histories can be used to show that certain problems for pushdown automata are undecidable . This is because the language of non-accepting computation histories of a Turing machine   M   M   M   on input   w   w   w   is a context-free language recognizable by a non-deterministic pushdown automaton.  We encode a Turing computation history     c  0   ,   c  1   ,  …  ,   c  n       subscript  c  0    subscript  c  1   normal-…   subscript  c  n     c_{0},c_{1},...,c_{n}   as the string     C  0   #   C  1  r   #   C  2   #   C  3  r   #  …  #   C  n        subscript  C  0   normal-#   subscript   superscript  C  r   1   normal-#   subscript  C  2   normal-#   subscript   superscript  C  r   3   normal-#  normal-…  normal-#   subscript  C  n     C_{0}\#C^{r}_{1}\#C_{2}\#C^{r}_{3}\#...\#C_{n}   , where    C  i     subscript  C  i    C_{i}   is the encoding of configuration    c  i     subscript  c  i    c_{i}   , as discussed above, and where every other configuration is written in reverse. Before reading a particular configuration, the pushdown automaton makes a non-deterministic choice to either ignore the configuration or read it completely onto the stack.   If the pushdown automaton decides to ignore the configuration, it simply reads and discards it completely and makes the same choice for the next one.  If it decides to process the configuration, it pushes it completely onto the stack, then verifies that the next configuration is a valid successor according to the rules of   M   M   M   . Since successive configurations are always written in opposite orders, this can be done by, for each tape symbol in the new configuration, popping off a symbol from the stack and checking if they're the same. Where they disagree, it must be accountable for by a valid transition of   M   M   M   . If, at any point, the automaton decides that the transition is invalid, it immediately enters a special accept state which ignores the rest of the input and accepts at the end.   In addition, the automaton verifies that the first configuration is the correct initial configuration (if not, it accepts) and that the state of the final configuration of the history is the accept state (if not, it accepts). Since a non-deterministic automaton accepts if there's any valid way for it to accept, the automaton described here will discover if the history is not a valid accepting history and will accept if so, and reject if not. 3  This same trick cannot be used to recognize accepting computation histories with an NPDA, since non-determinism could be used to skip past a test that would otherwise fail. A linear-bounded Turing machine is sufficient to recognize accepting computation histories.  This result allows us to prove that    A  L   L   P  D  A        A  L   subscript  L    P  D  A      ALL_{PDA}   , the language of pushdown automata which accept all input, is undecidable. Suppose we have a decider for it,   D   D   D   . For any Turing machine   M   M   M   and input   w   w   w   , we can form the pushdown automaton   P   P   P   which accepts non-accepting computation histories for that machine.    D   (  P  )       D  P    D(P)   will accept if and only if there are no accepting computation histories for   M   M   M   on   w   w   w   ; this would allow us to decide    A   T  M      subscript  A    T  M     A_{TM}   , which we know to be undecidable.  References  "  Category:Theory of computation     ↩  ↩  ↩     