   Œ†-calculus      Œ†-calculus   In theoretical computer science , the œÄ-calculus (or pi-calculus ) is a process calculus . The œÄ-calculus allows channel names to be communicated along the channels themselves, and in this way it is able to describe concurrent computations whose network configuration may change during the computation.  The œÄ-calculus is elegantly simple yet very expressive. Functional programs can be encoded into the œÄ-calculus, and the encoding emphasises the dialogue nature of computation, drawing connections with game semantics . Extensions of the œÄ-calculus, such as the spi calculus and applied œÄ, have been successful in reasoning about cryptographic protocols . Beside the original use in describing concurrent systems, the œÄ-calculus has also been used to reason about business processes and molecular biology .  Informal definition  The œÄ-calculus belongs to the family of process calculi , mathematical formalisms for describing and analyzing properties of concurrent computation. In fact, the œÄ-calculus, like the Œª-calculus , is so minimal that it does not contain primitives such as numbers, booleans, data structures, variables, functions, or even the usual control flow statements (such as if-then-else , while ).  Process constructs  Central to the œÄ-calculus is the notion of name . The simplicity of the calculus lies in the dual role that names play as communication channels and variables .  The process constructs available in the calculus are the following (a precise definition is given in the following section):   concurrency , written    P  ‚à£  Q     fragments  P  normal-‚à£  Q    P\mid Q   , where   P   P   P   and   Q   Q   Q   are two processes or threads executed concurrently.  communication , where  input prefixing      c   (  x  )    .  P     formulae-sequence    c  x   P    c\left(x\right).P   is a process waiting for a message that was sent on a communication channel named   c   c   c   before proceeding as binding the name received to the name Typically, this models either a process expecting a communication from the network or a label c usable only once by a goto c operation.  output prefixing       c  ¬Ø    ‚ü®  y  ‚ü©    .  P     formulae-sequence     normal-¬Ø  c    delimited-‚ü®‚ü©  y    P    \overline{c}\langle y\rangle.P   describes that the name   y   y   y   is emitted on channel   c   c   c   before proceeding as Typically, this models either sending a message on the network or a goto c operation.   replication , written    !  P     fragments   P    !\,P   , which may be seen as a process which can always create a new copy of Typically, this models either a network service or a label c waiting for any number of goto c operations.  creation of a new name , written     (   ŒΩ  x   )   P        ŒΩ  x   P    \left(\nu x\right)P   , which may be seen as a process allocating a new constant   x   x   x   within The constants of  are defined by their names only and are always communication channels. Creation of a new name in a process is also called restriction .  the nil process, written   0   0    , is a process whose execution is complete and has stopped.   Although the minimalism of the œÄ-calculus prevents us from writing programs in the normal sense, it is easy to extend the calculus. In particular, it is easy to define both control structures such as recursion, loops and sequential composition and datatypes such as first-order functions, truth values , lists and integers. Moreover, extensions of the  have been proposed which take into account distribution or public-key cryptography. The applied due to Abadi and Fournet 1 put these various extensions on a formal footing by extending the  with arbitrary datatypes.  A small example  Below is a tiny example of a process which consists of three parallel components. The channel name   x   x   x   is only known by the first two components.         (   ŒΩ  x   )      (   x  ¬Ø    ‚ü®  z  ‚ü©   .‚ÄÑ0         |  x   (  y  )   .   y  ¬Ø    ‚ü®  x  ‚ü©   .  x   (  y  )    .‚ÄÑ0   )           ŒΩ  x    fragments  normal-(   normal-¬Ø  x    fragments  normal-‚ü®  z  normal-‚ü©   .‚ÄÑ0      missing-subexpression    fragments  normal-|  x   fragments  normal-(  y  normal-)   normal-.   normal-¬Ø  y    fragments  normal-‚ü®  x  normal-‚ü©   normal-.  x   fragments  normal-(  y  normal-)   .‚ÄÑ0  normal-)      \displaystyle\begin{aligned}\displaystyle(\nu x)&\displaystyle(\;\overline{x}%
 \langle z\rangle.\;0\\
 &\displaystyle|\;x(y).\;\overline{y}\langle x\rangle.\;x(y).\;0\;)\end{aligned}     The first two components are able to communicate on the channel   x   x   x   , and the name   y   y   y   becomes bound to   z   z   z   . The next step in the process is therefore          (  ŒΩ  x  )   (     0      |      z  ¬Ø    ‚ü®  x  ‚ü©   .  x   (  y  )    .‚ÄÑ0   )          fragments   fragments  normal-(  ŒΩ  x  normal-)   normal-(   0    normal-|   fragments   normal-¬Ø  z    fragments  normal-‚ü®  x  normal-‚ü©   normal-.  x   fragments  normal-(  y  normal-)   .‚ÄÑ0  normal-)      \displaystyle\begin{aligned}\displaystyle(\nu x)\;(&\displaystyle 0\\
 \displaystyle|&\displaystyle\overline{z}\langle x\rangle.\;x(y).\;0\;)\end{%
 aligned}\par     Note that the remaining   y   y   y   is not affected because it is defined in an inner scope. The second and third parallel components can now communicate on the channel name   z   z   z   , and the name   v   v   v   becomes bound to   x   x   x   . The next step in the process is now       (  ŒΩ  x  )   (     fragments   fragments  normal-(  ŒΩ  x  normal-)   normal-(    \displaystyle\par
 (\nu x)(     Note that since the local name   x   x   x   has been output, the scope of   x   x   x   is extended to cover the third component as well. Finally, the channel   x   x   x   can be used for sending the name   x   x   x   . After that all concurrently executing processes have stopped       (  ŒΩ  x  )   (     fragments   fragments  normal-(  ŒΩ  x  normal-)   normal-(    \displaystyle\par
 (\nu x)(     Formal definition  Syntax  Let Œß be a set of objects called names . The abstract syntax for the œÄ-calculus is built from the following BNF grammar (where x and y are any names from Œß): 1       P  ,  Q  ,  R   :  :=     normal-:   P  Q  R   assign    \displaystyle P,Q,R::=     In the concrete syntax below, the prefixes bind more tightly than the parallel composition (|), and parentheses are used to disambiguate.  Names are bound by the restriction and input prefix constructs. Formally, the sets of free and bound names of a process in œÄ‚Äìcalculus are defined inductively as follows.      Construct   Free names   Bound names          0   0       None   None           a  ¬Ø    ‚ü®  x  ‚ü©    .  P     formulae-sequence     normal-¬Ø  a    delimited-‚ü®‚ü©  x    P    \overline{a}\langle x\rangle.P      a ; x ; all free names of P   All bound names of P          a   (  x  )    .  P     formulae-sequence    a  x   P    a(x).P      a ; free names of P except for x   x ; all bound names of P         P  |  Q     fragments  P  normal-|  Q    P|Q      All free names of P and Q   All bound names of P and Q          (   ŒΩ  x   )   .  P     formulae-sequence    ŒΩ  x   P    (\nu x).P      Free names of P except for x   x ; all bound names of P         !  P     fragments   P    !P      All free names of P   All bound names of P     Structural congruence  Central to both the reduction semantics and the labelled transition semantics is the notion of structural congruence . Two processes are structurally congruent, if they are identical up to structure. In particular, parallel composition is commutative and associative.  More precisely, structural congruence is defined as the least equivalence relation preserved by the process constructs and satisfying:  Alpha-conversion :  :*    P  ‚â°  Q      P  Q    P\equiv Q   if   Q   Q   Q   can be obtained from   P   P   P   by renaming one or more bound names in   P   P   P   .  Axioms for parallel composition :  :*    P  |  Q  ‚â°  Q  |  P     fragments  P  normal-|  Q   Q  normal-|  P    P|Q\equiv Q|P     :*     (  P  |  Q  )   |  R  ‚â°  P  |   (  Q  |  R  )      fragments   fragments  normal-(  P  normal-|  Q  normal-)   normal-|  R   P  normal-|   fragments  normal-(  Q  normal-|  R  normal-)     (P|Q)|R\equiv P|(Q|R)     :*    P  |  0  ‚â°  P     fragments  P  normal-|  0   P    P|0\equiv P     Axioms for restriction :  :*      (   ŒΩ  x   )    (   ŒΩ  y   )   P   ‚â°    (   ŒΩ  y   )    (   ŒΩ  x   )   P           ŒΩ  x     ŒΩ  y   P       ŒΩ  y     ŒΩ  x   P     (\nu x)(\nu y)P\equiv(\nu y)(\nu x)P     :*      (   ŒΩ  x   )   0   ‚â°  0          ŒΩ  x   0   0    (\nu x)0\equiv 0     Axiom for replication :  :*    !  P  ‚â°  P  |  !  P     fragments   P   P  normal-|   P    !P\equiv P|!P     Axiom relating restriction and parallel :  :*     (  ŒΩ  x  )    (  P  |  Q  )   ‚â°   (  ŒΩ  x  )   P  |  Q     fragments   fragments  normal-(  ŒΩ  x  normal-)    fragments  normal-(  P  normal-|  Q  normal-)     fragments  normal-(  ŒΩ  x  normal-)   P  normal-|  Q    (\nu x)(P|Q)\equiv(\nu x)P|Q   if   x   x   x   is not a free name of   Q   Q   Q   .  This last axiom is known as the "scope extension" axiom. This axiom is central, since it describes how a bound name   x   x   x   may be extruded by an output action, causing the scope of   x   x   x   to be extended. In cases where   x   x   x   is a free name of   Q   Q   Q   , alpha-conversion may be used to allow extension to proceed.  Reduction semantics  We write    P  ‚Üí   P  ‚Ä≤      normal-‚Üí  P   superscript  P  normal-‚Ä≤     P\rightarrow P^{\prime}   if   P   P   P   can perform a computation step, following which it is now    P  ‚Ä≤     superscript  P  normal-‚Ä≤    P^{\prime}   . This reduction relation    ‚Üí   normal-‚Üí   \rightarrow   is defined as the least relation closed under a set of reduction rules.  The main reduction rule which captures the ability of processes to communicate through channels is the following:        x  ¬Ø    ‚ü®  z  ‚ü©   .  P  |  x   (  y  )   .  Q  ‚Üí  P  |  Q   [  z  /  y  ]      fragments   normal-¬Ø  x    fragments  normal-‚ü®  z  normal-‚ü©   normal-.  P  normal-|  x   fragments  normal-(  y  normal-)   normal-.  Q  normal-‚Üí  P  normal-|  Q   fragments  normal-[  z   y  normal-]     \overline{x}\langle z\rangle.P|x(y).Q\rightarrow P|Q[z/y]       where    Q   [   z  /  y   ]       Q   delimited-[]    z  y      Q[z/y]   denotes the process   Q   Q   Q   in which the free name   z   z   z   has been substituted for the free occurrences of   y   y   y   . If a free occurrence of   y   y   y   occurs in a location where   z   z   z   would not be free, alpha-conversion may be required.   There are three additional rules:   If    P  ‚Üí  Q     normal-‚Üí  P  Q    P\rightarrow Q   then also    P  |  R  ‚Üí  Q  |  R     fragments  P  normal-|  R  normal-‚Üí  Q  normal-|  R    P|R\rightarrow Q|R   .    This rule says that parallel composition does not inhibit computation.    If    P  ‚Üí  Q     normal-‚Üí  P  Q    P\rightarrow Q   , then also      (   ŒΩ  x   )   P   ‚Üí    (   ŒΩ  x   )   Q      normal-‚Üí      ŒΩ  x   P       ŒΩ  x   Q     (\nu x)P\rightarrow(\nu x)Q   .    This rule ensures that computation can proceed underneath a restriction.    If    P  ‚â°   P  ‚Ä≤       P   superscript  P  normal-‚Ä≤     P\equiv P^{\prime}   and     P  ‚Ä≤   ‚Üí   Q  ‚Ä≤      normal-‚Üí   superscript  P  normal-‚Ä≤    superscript  Q  normal-‚Ä≤     P^{\prime}\rightarrow Q^{\prime}   where     Q  ‚Ä≤   ‚â°  Q       superscript  Q  normal-‚Ä≤   Q    Q^{\prime}\equiv Q   , then also    P  ‚Üí  Q     normal-‚Üí  P  Q    P\rightarrow Q   .   The latter rule states that processes that are structurally congruent have the same reductions.  The example revisited  Consider again the process       (  ŒΩ  x  )    (   x  ¬Ø    ‚ü®  z  ‚ü©   .0  |  x   (  y  )   .   y  ¬Ø    ‚ü®  x  ‚ü©   .  x   (  y  )   .0  )   |  z   (  v  )   .   v  ¬Ø    ‚ü®  v  ‚ü©   .0     fragments   fragments  normal-(  ŒΩ  x  normal-)    fragments  normal-(   normal-¬Ø  x    fragments  normal-‚ü®  z  normal-‚ü©   .0  normal-|  x   fragments  normal-(  y  normal-)   normal-.   normal-¬Ø  y    fragments  normal-‚ü®  x  normal-‚ü©   normal-.  x   fragments  normal-(  y  normal-)   .0  normal-)   normal-|  z   fragments  normal-(  v  normal-)   normal-.   normal-¬Ø  v    fragments  normal-‚ü®  v  normal-‚ü©   .0    (\nu x)(\overline{x}\langle z\rangle.0|x(y).\overline{y}\langle x\rangle.x(y).%
 0)|z(v).\overline{v}\langle v\rangle.0     Applying the definition of the reduction semantics, we get the reduction       (  ŒΩ  x  )    (   x  ¬Ø    ‚ü®  z  ‚ü©   .0  |  x   (  y  )   .   y  ¬Ø    ‚ü®  x  ‚ü©   .  x   (  y  )   .0  )   |  z   (  v  )   .   v  ¬Ø    ‚ü®  v  ‚ü©   .0  ‚Üí   (  ŒΩ  x  )    (  0  |   z  ¬Ø    ‚ü®  x  ‚ü©   .  x   (  z  )   .0  )   |  z   (  v  )   .   v  ¬Ø    ‚ü®  v  ‚ü©   .0     fragments   fragments  normal-(  ŒΩ  x  normal-)    fragments  normal-(   normal-¬Ø  x    fragments  normal-‚ü®  z  normal-‚ü©   .0  normal-|  x   fragments  normal-(  y  normal-)   normal-.   normal-¬Ø  y    fragments  normal-‚ü®  x  normal-‚ü©   normal-.  x   fragments  normal-(  y  normal-)   .0  normal-)   normal-|  z   fragments  normal-(  v  normal-)   normal-.   normal-¬Ø  v    fragments  normal-‚ü®  v  normal-‚ü©   .0  normal-‚Üí   fragments  normal-(  ŒΩ  x  normal-)    fragments  normal-(  0  normal-|   normal-¬Ø  z    fragments  normal-‚ü®  x  normal-‚ü©   normal-.  x   fragments  normal-(  z  normal-)   .0  normal-)   normal-|  z   fragments  normal-(  v  normal-)   normal-.   normal-¬Ø  v    fragments  normal-‚ü®  v  normal-‚ü©   .0    (\nu x)(\overline{x}\langle z\rangle.0|x(y).\overline{y}\langle x\rangle.x(y).%
 0)|z(v).\overline{v}\langle v\rangle.0\rightarrow(\nu x)(0|\overline{z}\langle
 x%
 \rangle.x(z).0)|z(v).\overline{v}\langle v\rangle.0     Note how, applying the reduction substitution axiom, occurrences of   y   y   y   are now labeled as   z   z   z   .  Next, we get the reduction       (  ŒΩ  x  )    (  0  |   z  ¬Ø    ‚ü®  x  ‚ü©   .  x   (  z  )   .0  )   |  z   (  v  )   .   v  ¬Ø    ‚ü®  v  ‚ü©   .0  ‚Üí   (  ŒΩ  x  )    (  0  |  x   (  z  )   .0  |   x  ¬Ø    ‚ü®  x  ‚ü©   .0  )      fragments   fragments  normal-(  ŒΩ  x  normal-)    fragments  normal-(  0  normal-|   normal-¬Ø  z    fragments  normal-‚ü®  x  normal-‚ü©   normal-.  x   fragments  normal-(  z  normal-)   .0  normal-)   normal-|  z   fragments  normal-(  v  normal-)   normal-.   normal-¬Ø  v    fragments  normal-‚ü®  v  normal-‚ü©   .0  normal-‚Üí   fragments  normal-(  ŒΩ  x  normal-)    fragments  normal-(  0  normal-|  x   fragments  normal-(  z  normal-)   .0  normal-|   normal-¬Ø  x    fragments  normal-‚ü®  x  normal-‚ü©   .0  normal-)     (\nu x)(0|\overline{z}\langle x\rangle.x(z).0)|z(v).\overline{v}\langle v%
 \rangle.0\rightarrow(\nu x)(0|x(z).0|\overline{x}\langle x\rangle.0)     Note that since the local name   x   x   x   has been output, the scope of   x   x   x   is extended to cover the third component as well. This was captured using the scope extension axiom.  Labelled semantics  Alternatively, one may give the pi-calculus a labelled transition semantics (as has been done with the Calculus of Communicating Systems ). Transitions in this semantics are of the form:       P     ‚Üí  ùõº     P  ‚Ä≤       Œ±  normal-‚Üí   P   superscript  P  normal-‚Ä≤     P\,\xrightarrow{\alpha}\,P^{\prime}     This notation signifies that   P   P   P   after the action   Œ±   Œ±   \alpha   becomes    P  ‚Ä≤     superscript  P  normal-‚Ä≤    P^{\prime}   .   Œ±   Œ±   \alpha   can be an input action     a   (  x  )       a  x    a(x)   , an output action       a  ¬Ø    ‚ü®  x  ‚ü©        normal-¬Ø  a    delimited-‚ü®‚ü©  x     \overline{a}\langle x\rangle    , or a tau-action   œÑ   œÑ   \tau   corresponding to an internal communication.  A standard result about the labelled semantics is that it agrees with the reduction semantics in the sense that    P  ‚Üí   P  ‚Ä≤      normal-‚Üí  P   superscript  P  normal-‚Ä≤     P\rightarrow P^{\prime}   if and only if     P     ‚Üí  ùúè     P  ‚Ä≤       œÑ  normal-‚Üí   P   superscript  P  normal-‚Ä≤     P\,\xrightarrow{\tau}\,P^{\prime}   for some action   œÑ   œÑ   \tau   .  Extensions and variants  The syntax given above is a minimal one. However, the syntax may be modified in various ways.  A nondeterministic choice operator     P  +  Q      P  Q    P+Q   can be added to the syntax.  A test for name equality      [  x  =  y  ]   P     fragments   fragments  normal-[  x   y  normal-]   P    [x=y]P   can be added to the syntax. This match operator can proceed as   P   P   P   if and only if   x   x   x   and   y   y   y   are the same name. Similarly, one may add a mismatch operator for name inequality . Practical programs which can pass names (URLs or pointers) often use such functionality: for directly modelling such functionality inside the calculus, this and related extensions are often useful.  The asynchronous œÄ-calculus allows only outputs with no suffix, i.e. output atoms of the form     x  ¬Ø    ‚ü®  y  ‚ü©        normal-¬Ø  x    delimited-‚ü®‚ü©  y     \overline{x}\langle y\rangle   , yielding a smaller calculus. However, any process in the original calculus can be represented by the smaller asynchronous œÄ-calculus using an extra channel to simulate explicit acknowledgement from the receiving process. Since a continuation-free output can model a message-in-transit, this fragment shows that the original œÄ-calculus, which is intuitively based on synchronous communication, has an expressive asynchronous communication model inside its syntax. However, the nondeterministic choice operator defined above cannot be expressed in this way, as an unguarded choice would be converted into a guarded one; this fact has been used to demonstrate that the asynchronous calculus is strictly less expressive than the synchronous one (with the choice operator). 2  The polyadic œÄ-calculus allows communicating more than one name in a single action      x  ¬Ø    ‚ü®   z  1   ,   ‚Ä¶   z  n    ‚ü©    .  P     formulae-sequence     normal-¬Ø  x     subscript  z  1     normal-‚Ä¶   subscript  z  n      P    \overline{x}\langle z_{1},...z_{n}\rangle.P    (polyadic output) and    x   (   z  1   ,   ‚Ä¶   z  n    )       x    subscript  z  1     normal-‚Ä¶   subscript  z  n       x(z_{1},...z_{n})    (polyadic input) . This polyadic extension, which is useful especially when studying types for name passing processes, can be encoded in the monadic calculus by passing the name of a private channel through which the multiple arguments are then passed in sequence. The encoding is defined recursively by the clauses        x  ¬Ø    ‚ü®   y  1   ,  ‚ãØ  ,   y  n   ‚ü©    .  P     formulae-sequence     normal-¬Ø  x     subscript  y  1   normal-‚ãØ   subscript  y  n     P    \overline{x}\langle y_{1},\cdots,y_{n}\rangle.P   is encoded as      (   ŒΩ  w   )    x  ¬Ø    ‚ü®  w  ‚ü©    .    w  ¬Ø    ‚ü®   y  1   ‚ü©    .  ‚ãØ  .    w  ¬Ø    ‚ü®   y  n   ‚ü©    .   [  P  ]      formulae-sequence      ŒΩ  w    normal-¬Ø  x    delimited-‚ü®‚ü©  w       normal-¬Ø  w    delimited-‚ü®‚ü©   subscript  y  1     normal-‚ãØ     normal-¬Ø  w    delimited-‚ü®‚ü©   subscript  y  n      delimited-[]  P     (\nu w)\overline{x}\langle w\rangle.\overline{w}\langle y_{1}\rangle.\cdots.%
 \overline{w}\langle y_{n}\rangle.[P]        x   (   y  1   ,  ‚ãØ  ,   y  n   )    .  P     formulae-sequence    x    subscript  y  1   normal-‚ãØ   subscript  y  n     P    x(y_{1},\cdots,y_{n}).P   is encoded as     x   (  w  )    .   w   (   y  1   )    .  ‚ãØ  .   w   (   y  n   )    .   [  P  ]      formulae-sequence    x  w     w   subscript  y  1    normal-‚ãØ    w   subscript  y  n     delimited-[]  P     x(w).w(y_{1}).\cdots.w(y_{n}).[P]     All other process constructs are left unchanged by the encoding.  In the above,    [  P  ]     delimited-[]  P    [P]   denotes the encoding of all prefixes in the continuation   P   P   P   in the same way.  The full power of replication    !  P     fragments   P    !P   is not needed. Often, one only considers replicated input     !  x   (  y  )   .  P     fragments   x   fragments  normal-(  y  normal-)   normal-.  P    !x(y).P   , whose structural congruence axiom is    !  x   (  y  )   .  P  ‚â°  x   (  y  )   .  P  |  !  x   (  y  )   .  P     fragments   x   fragments  normal-(  y  normal-)   normal-.  P   x   fragments  normal-(  y  normal-)   normal-.  P  normal-|   x   fragments  normal-(  y  normal-)   normal-.  P    !x(y).P\equiv x(y).P|!x(y).P   .  Replicated input process such as    !  x   (  y  )   .  P     fragments   x   fragments  normal-(  y  normal-)   normal-.  P    !x(y).P   can be understood as servers, waiting on channel   x   x   x   to be invoked by clients. Invocation of a server spawns a new copy of the process    P   [   a  /  y   ]       P   delimited-[]    a  y      P[a/y]   , where a is the name passed by the client to the server, during the latter's invocation.  A higher order œÄ-calculus can be defined where not only names but processes are sent through channels. The key reduction rule for the higher order case is       x  ¬Ø    ‚ü®  R  ‚ü©   .  P  |  x   (  Y  )   .  Q  ‚Üí  P  |  Q   [  R  /  Y  ]      fragments   normal-¬Ø  x    fragments  normal-‚ü®  R  normal-‚ü©   normal-.  P  normal-|  x   fragments  normal-(  Y  normal-)   normal-.  Q  normal-‚Üí  P  normal-|  Q   fragments  normal-[  R   Y  normal-]     \overline{x}\langle R\rangle.P|x(Y).Q\rightarrow P|Q[R/Y]     Here,   Y   Y   Y   denotes a process variable which can be instantiated by a process term. Sangiorgi established that the ability to pass processes does not increase the expressivity of the œÄ-calculus: passing a process P can be simulated by just passing a name that points to P instead.  Properties  Turing completeness  The œÄ-calculus is a universal model of computation . This was first observed by Milner in his paper "Functions as Processes", 3 in which he presents two encodings of the lambda-calculus in the œÄ-calculus. One encoding simulates the eager (call-by-value) evaluation strategy , the other encoding simulates the normal-order (call-by-name) strategy. In both of these, the crucial insight is the modeling of environment bindings ‚Äì for instance, "   x   x   x   is bound to term   M   M   M   " ‚Äì as replicating agents that respond to requests for their bindings by sending back a connection to the term   M   M   M   .  The features of the œÄ-calculus that make these encodings possible are name-passing and replication (or, equivalently, recursively defined agents). In the absence of replication/recursion, the œÄ-calculus ceases to be Turing -powerful. This can be seen by the fact that bisimulation equivalence becomes decidable for the recursion-free calculus and even for the finite-control œÄ-calculus where the number of parallel components in any process is bounded by a constant. 4  Bisimulations in the œÄ-calculus  As for process calculi, the œÄ-calculus allows for a definition of bisimulation equivalence. In the œÄ-calculus, the definition of bisimulation equivalence (also known as bisimilarity) may be based on either the reduction semantics or on the labelled transition semantics.  There are (at least) three different ways of defining labelled bisimulation equivalence in the œÄ-calculus: Early, late and open bisimilarity. This stems from the fact that the œÄ-calculus is a value-passing process calculus.  In the remainder of this section, we let   p   p   p   and   q   q   q   denote processes and   R   R   R   denote binary relations over processes.  Early and late bisimilarity  Early and late bisimilarity were both formulated by Milner, Parrow and Walker in their original paper on the œÄ-calculus. 5  A binary relation   R   R   R   over processes is an early bisimulation if for every pair of processes     (  p  ,  q  )   ‚àà  R       p  q   R    (p,q)\in R   ,   whenever   p \,\xrightarrow{a(x)}\,p'  then for every name   y   y   y   there exists some    q  ‚Ä≤     superscript  q  normal-‚Ä≤    q^{\prime}   such that     q     ‚Üí   a   (  x  )       q  ‚Ä≤         a  x   normal-‚Üí   q   superscript  q  normal-‚Ä≤     q\,\xrightarrow{a(x)}\,q^{\prime}   and     (    p  ‚Ä≤    [   y  /  x   ]    ,    q  ‚Ä≤    [   y  /  x   ]    )   ‚àà  R          superscript  p  normal-‚Ä≤    delimited-[]    y  x        superscript  q  normal-‚Ä≤    delimited-[]    y  x      R    (p^{\prime}[y/x],q^{\prime}[y/x])\in R   ;   for any non-input action   Œ±   Œ±   \alpha   , if   p \xrightarrow\alpha p'   then¬†there¬†exists¬†some     q  ‚Ä≤     superscript  q  normal-‚Ä≤    q^{\prime}    such¬†that     q   ‚Üí  ùõº    q  ‚Ä≤       Œ±  normal-‚Üí   q   superscript  q  normal-‚Ä≤     q\xrightarrow{\alpha}q^{\prime}    and      (   p  ‚Ä≤   ,   q  ‚Ä≤   )   ‚àà  R        superscript  p  normal-‚Ä≤    superscript  q  normal-‚Ä≤    R    (p^{\prime},q^{\prime})\in R    ;   and symmetric requirements with   p   p   p   and   q   q   q   interchanged.   Processes   p   p   p   and   q   q   q   are said to be early bisimilar, written    p   ‚àº  e   q      subscript  similar-to  e   p  q    p\sim_{e}q   if the pair     (  p  ,  q  )   ‚àà  R       p  q   R    (p,q)\in R   for some early bisimulation   R   R   R   .  In late bisimilarity, the transition match must be independent of the name being transmitted. A binary relation   R   R   R   over processes is a late bisimulation if for every pair of processes     (  p  ,  q  )   ‚àà  R       p  q   R    (p,q)\in R   ,   whenever   p \xrightarrow{a(x)} p'  then for some    q  ‚Ä≤     superscript  q  normal-‚Ä≤    q^{\prime}   it holds that    q   ‚Üí   a   (  x  )      q  ‚Ä≤         a  x   normal-‚Üí   q   superscript  q  normal-‚Ä≤     q\xrightarrow{a(x)}q^{\prime}   and     (    p  ‚Ä≤    [   y  /  x   ]    ,    q  ‚Ä≤    [   y  /  x   ]    )   ‚àà  R          superscript  p  normal-‚Ä≤    delimited-[]    y  x        superscript  q  normal-‚Ä≤    delimited-[]    y  x      R    (p^{\prime}[y/x],q^{\prime}[y/x])\in R    for every name y ;   for any non-input action   Œ±   Œ±   \alpha   , if   p \xrightarrow\alpha p'   implies¬†that¬†there¬†exists¬†some     q  ‚Ä≤     superscript  q  normal-‚Ä≤    q^{\prime}    such¬†that     q   ‚Üí  ùõº    q  ‚Ä≤       Œ±  normal-‚Üí   q   superscript  q  normal-‚Ä≤     q\xrightarrow{\alpha}q^{\prime}    and      (   p  ‚Ä≤   ,   q  ‚Ä≤   )   ‚àà  R        superscript  p  normal-‚Ä≤    superscript  q  normal-‚Ä≤    R    (p^{\prime},q^{\prime})\in R    ;   and symmetric requirements with   p   p   p   and   q   q   q   interchanged.   Processes   p   p   p   and   q   q   q   are said to be late bisimilar, written    p   ‚àº  l   q      subscript  similar-to  l   p  q    p\sim_{l}q   if the pair     (  p  ,  q  )   ‚àà  R       p  q   R    (p,q)\in R   for some late bisimulation   R   R   R   .  Both    ‚àº  e     subscript  similar-to  e    \sim_{e}   and    ‚àº  l     subscript  similar-to  l    \sim_{l}   suffer from the problem that they are not congruence relations in the sense that they are not preserved by all process constructs. More precisely, there exist processes   p   p   p   and   q   q   q   such that    p   ‚àº  e   q      subscript  similar-to  e   p  q    p\sim_{e}q   but     a   (  x  )    .   p   ‚àºÃ∏  e    a   (  x  )     .  q     formulae-sequence    a  x     subscript  not-similar-to  e   p    a  x    q    a(x).p\not\sim_{e}a(x).q   . One may remedy this problem by considering the maximal congruence relations included in    ‚àº  e     subscript  similar-to  e    \sim_{e}   and    ‚àº  l     subscript  similar-to  l    \sim_{l}   , known as early congruence and late congruence , respectively.  Open bisimilarity  Fortunately, a third definition is possible, which avoids this problem, namely that of open bisimilarity , due to Sangiorgi. 6  A binary relation   R   R   R   over processes is an open bisimulation if for every pair of elements     (  p  ,  q  )   ‚àà  R       p  q   R    (p,q)\in R   and for every name substitution   œÉ   œÉ   \sigma   and every action   Œ±   Œ±   \alpha   , whenever     p  œÉ    ‚Üí  ùõº    p  ‚Ä≤       Œ±  normal-‚Üí     p  œÉ    superscript  p  normal-‚Ä≤     p\sigma\xrightarrow{\alpha}p^{\prime}   then there exists some    q  ‚Ä≤     superscript  q  normal-‚Ä≤    q^{\prime}   such that     q  œÉ    ‚Üí  ùõº    q  ‚Ä≤       Œ±  normal-‚Üí     q  œÉ    superscript  q  normal-‚Ä≤     q\sigma\xrightarrow{\alpha}q^{\prime}   and     (   p  ‚Ä≤   ,   q  ‚Ä≤   )   ‚àà  R        superscript  p  normal-‚Ä≤    superscript  q  normal-‚Ä≤    R    (p^{\prime},q^{\prime})\in R   .  Processes   p   p   p   and   q   q   q   are said to be open bisimilar, written    p   ‚àº  o   q      subscript  similar-to  o   p  q    p\sim_{o}q   if the pair     (  p  ,  q  )   ‚àà  R       p  q   R    (p,q)\in R   for some open bisimulation   R   R   R   .  Early, late and open bisimilarity are distinct  Early, late and open bisimilarity are distinct. The containments are proper, so     ‚àº  o   ‚ää   ‚àº  l   ‚ää   ‚àº  e       subscript  similar-to  o     subscript  similar-to  l     subscript  similar-to  e     \sim_{o}\subsetneq\sim_{l}\subsetneq\sim_{e}   .  In certain subcalculi such as the asynchronous pi-calculus, late, early and open bisimilarity are known to coincide. However, in this setting a more appropriate notion is that of asynchronous bisimilarity .  The reader should note that, in the literature, the term open bisimulation usually refers to a more sophisticated notion, where processes and relations are indexed by distinction relations; details are in Sangiorgi's paper cited above.  Barbed equivalence  Alternatively, one may define bisimulation equivalence directly from the reduction semantics. We write    p  ‚áì  a     normal-‚áì  p  a    p\Downarrow a   if process   p   p   p   immediately allows an input or an output on name   a   a   a   .  A binary relation   R   R   R   over processes is a barbed bisimulation if it is a symmetric relation which satisfies that for every pair of elements     (  p  ,  q  )   ‚àà  R       p  q   R    (p,q)\in R   we have that   (1)    p  ‚áì  a     normal-‚áì  p  a    p\Downarrow a   if and only if    q  ‚áì  a     normal-‚áì  q  a    q\Downarrow a   for every name   a   a   a      and   (2) for every reduction    p  ‚Üí   p  ‚Ä≤      normal-‚Üí  p   superscript  p  normal-‚Ä≤     p\rightarrow p^{\prime}   there exists a reduction    q  ‚Üí   q  ‚Ä≤      normal-‚Üí  q   superscript  q  normal-‚Ä≤     q\rightarrow q^{\prime}      such that     (   p  ‚Ä≤   ,   q  ‚Ä≤   )   ‚àà  R        superscript  p  normal-‚Ä≤    superscript  q  normal-‚Ä≤    R    (p^{\prime},q^{\prime})\in R   .  We say that   p   p   p   and   q   q   q   are barbed bisimilar if there exists a barbed bisimulation   R   R   R   where     (  p  ,  q  )   ‚àà  R       p  q   R    (p,q)\in R   .  Defining a context as a œÄ term with a hole [] we say that two processes P and Q are barbed congruent , written    P   ‚àº  b   Q      subscript  similar-to  b   P  Q    P\sim_{b}Q\,\!   , if for every context    C   [  ]       C     C[]   we have that    C   [  P  ]       C   delimited-[]  P     C[P]   and    C   [  Q  ]       C   delimited-[]  Q     C[Q]   are barbed bisimilar. It turns out that barbed congruence coincides with the congruence induced by early bisimilarity.  Applications  The œÄ-calculus has been used to describe many different kinds of concurrent systems. In fact, some of the most recent applications lie outside the realm of traditional computer science.  In 1997, Martin Abadi and Andrew Gordon proposed an extension of the œÄ-calculus, the Spi-calculus , as a formal notation for describing and reasoning about cryptographic protocols. The spi-calculus extends the œÄ-calculus with primitives for encryption and decryption. In 2001, Martin Abadi and Cedric Fournet generalised the handling of cryptographic protocols to produce the applied œÄ calculus. There is now a large body of work devoted to variants of the applied œÄ calculus, including a number of experimental verification tools. One example is the tool ProVerif  2 due to Bruno Blanchet , based on a translation of the applied œÄ-calculus into Blanchet's logic programming framework. Another example is Cryptyc 3 , due to Andrew Gordon and Alan Jeffrey, which uses Woo and Lam's method of correspondence assertions as the basis for type systems that can check for authentication properties of cryptographic protocols.  Around 2002, Howard Smith and Peter Fingar became interested in using the œÄ-calculus as a description tool for modelling business processes. As of July 2006, there is discussion in the community as to how useful this will be. Most recently, the œÄ-calculus has been used as the theoretical basis of Business Process Modeling Language (BPML), and of Microsoft's XLANG. 7  The œÄ-calculus has also attracted interest in molecular biology. In 1999, Aviv Regev and Ehud Shapiro showed that one can describe a cellular signaling pathway (the so-called RTK / MAPK cascade) and in particular the molecular "lego" which implements these tasks of communication in an extension of the œÄ-calculus. 8 Following this seminal paper, other authors described the whole metabolic network of a minimal cell. 9  History  The œÄ-calculus was originally developed by Robin Milner , Joachim Parrow and David Walker in 1992, based on ideas by Uffe Engberg and Mogens Nielsen. It can be seen as a continuation of Milner's work on the process calculus CCS ( Calculus of Communicating Systems ). In his Turing lecture, Milner describes the development of the œÄ-calculus as an attempt to capture the uniformity of values and processes in actors. 10  Implementations  The following programming languages are implementations either of the œÄ-calculus or of its variants:   Business Process Modeling Language (BPML)  occam-œÄ  Pict  JoCaml (based on the Join-calculus )   Notes  References       External links   PiCalculus on the C2 wiki  FAQ on œÄ-Calculus by Jeannette M. Wing   "  Category:Process calculi  Category:Theoretical computer science     A Calculus of Mobile Processes part 1 page 10, by R. Milner, J. Parrow and D. Walker published in Information and Computation 100(1) pp.1-40, Sept 1992 ‚Ü©  ‚Ü©  ‚Ü©  ‚Ü©  ‚Ü©  ‚Ü©  "BPML | BPEL4WS: A Convergence Path toward a Standard BPM Stack." BPMI.org Position Paper. August 15, 2002. 4 ‚Ü©  ‚Ü©  ‚Ü©  Robin Milner. 1993. Elements of interaction: Turing award lecture. Commun. ACM 36, 1 (January 1993), 78-89. DOI=10.1145/151233.151240 http://doi.acm.org/10.1145/151233.151240 ‚Ü©     