<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1835">Conformal welding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Conformal welding</h1>
<hr>In [[mathematics]], '''conformal welding''' ('''sewing''' or '''gluing''') is a process in [[geometric function theory]] for producing a [[Riemann surface]] by joining togeth
<p>er two Riemann surfaces, each with a disk removed, along their boundary circles. This problem can be reduced to that of finding univalent holomorphic maps <em>f</em>, <em>g</em> of the unit disk and its complement into the extended complex plane, both admitting continuous extensions to the closure of their domains, such that the images are complementary Jordan domains and such that on the unit circle they differ by a given <a href="quasisymmetric_map" title="wikilink">quasisymmetric homeomorphism</a>. Several proofs are known using a variety of techniques, including the <a href="Beltrami_equation" title="wikilink">Beltrami equation</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> the <a href="Singular_integral_operators_of_convolution_type#Hilbert_transform_on_the_circle" title="wikilink">Hilbert transform on the circle</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and elementary approximation techniques.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a>  describe the first two methods of conformal welding as well as providing numerical computations and applications to the analysis of shapes in the plane.</p>
<h2 id="welding-using-the-beltrami-equation">Welding using the Beltrami equation</h2>

<p>This method was first proposed by .</p>

<p>If <em>f</em> is a diffeomorphism of the circle, the <a href="Alexander_trick" title="wikilink">Alexander extension</a> gives a way of extending <em>f</em> to a diffeomorphism of the unit disk <em>D</em>:</p>

<p>

<math display="block" id="Conformal_welding:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo>,</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mi>ψ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>r</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>θ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>i</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mrow>
            <mi>ψ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>r</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>θ</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>r</ci>
      <ci>θ</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <apply>
      <exp></exp>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>ψ</ci>
        <ci>r</ci>
        <ci>g</ci>
        <ci>θ</ci>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>ψ</ci>
          <ci>r</ci>
         </apply>
        </apply>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{F(r,\theta)=r\exp[i\psi(r)g(\theta)+i(1-\psi(r))\theta],}
  </annotation>
 </semantics>
</math>

</p>

<p>where ψ is a smooth function with values in [0,1], equal to 0 near 0 and 1 near 1, and</p>

<p>

<math display="block" id="Conformal_welding:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>i</mi>
        <mi>θ</mi>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>i</mi>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>g</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{f(e^{i\theta})=e^{ig(\theta)},}
  </annotation>
 </semantics>
</math>

</p>

<p>with <em>g</em>(θ + 2π) = <em>g</em>(θ) + 2π.</p>

<p>The extension <em>F</em> can be continued to any larger disk |<em>z</em>|  1. Accordingly in the unit disc</p>

<p>

<math display="block" id="Conformal_welding:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mrow>
       <mo>∥</mo>
       <mi>μ</mi>
       <mo>∥</mo>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msub>
     <mo><</mo>
     <mn>1</mn>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <mrow>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>F</mi>
       <mover accent="true">
        <mi>z</mi>
        <mo>¯</mo>
       </mover>
      </msub>
      <mo>/</mo>
      <msub>
       <mi>F</mi>
       <mi>z</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>μ</ci>
      </apply>
      <infinity></infinity>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <ci>normal-¯</ci>
        <ci>z</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\|\mu\|_{\infty}<1,\,\,\,\mu(z)=F_{\overline{z}}/F_{z}.}
  </annotation>
 </semantics>
</math>

</p>

<p>Now extend μ to a Beltrami coefficient on the whole of <strong>C</strong> by setting it equal to 0 for |<em>z</em>| ≥ 1. Let <em>G</em> be the corresponding solution of the Beltrami equation:</p>

<p>

<math display="block" id="Conformal_welding:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mover accent="true">
      <mi>z</mi>
      <mo>¯</mo>
     </mover>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>μ</mi>
     <msub>
      <mi>G</mi>
      <mi>z</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>μ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{G_{\overline{z}}=\mu G_{z}.}
  </annotation>
 </semantics>
</math>

</p>

<p>Let <em>F</em><sub>1</sub>(<em>z</em>) = <em>G</em> ∘ <em>F</em><sup>−1</sup>(<em>z</em>) for |<em>z</em>| ≤ 1 and <em>F</em><sub>2</sub>(<em>z</em>) = <em>G</em> (<em>z</em>) for |<em>z</em>| ≥ 1. Thus <em>F</em><sub>1</sub> and <em>F</em><sub>2</sub> are univalent holomorphic maps of |<em>z</em>|  1 onto the inside and outside of a Jordan curve. They extend continuously to homeomorphisms <em>f</em><sub><em>i</em></sub> of the unit circle onto the Jordan curve on the boundary. By construction they satisfy the <strong>conformal welding</strong> condition:</p>

<p>

<math display="block" id="Conformal_welding:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>f</mi>
      <mn>1</mn>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mo>∘</mo>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{f=f_{1}^{-1}\circ f_{2}.}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="welding-using-the-hilbert-transform-on-the-circle">Welding using the Hilbert transform on the circle</h2>

<p>The use of the Hilbert transform to establish conformal welding was first suggested by the Georgian mathematicians D.G. Mandzhavidze and B.V. Khvedelidze in 1958. A detailed account was given at the same time by F.D. Gakhov and presented in his classic monograph ().</p>

<p>Let <em>e</em><sub><em>n</em></sub>(θ) = <em>e</em><sup><em>in</em>θ</sup> be the standard orthonormal basis of L<sup>2</sup>(<strong>T</strong>). Let H<sup>2</sup>(<strong>T</strong>) be <a href="Hardy_space" title="wikilink">Hardy space</a>, the closed subspace spanned by the <em>e</em><sub><em>n</em></sub> with <em>n</em> ≥ 0. Let <em>P</em> be the orthogonal projection onto Hardy space and set <em>T</em> = 2<em>P</em> - <em>I</em>. The operator <em>H</em> = <em>iT</em> is the <strong>Hilbert transform on the circle</strong> and can be written as a <a href="Singular_integral_operators_of_convolution_type#Hilbert_transform_on_the_circle" title="wikilink">singular integral operator</a>.</p>

<p>Given a diffeomorphism <em>f</em> of the unit circle, the task is to determine two univalent holomorphic functions</p>

<p>

<math display="block" id="Conformal_welding:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>f</mi>
       <mo>-</mo>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mi>z</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
       <msup>
        <mi>z</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
    </mrow>
    <mo rspace="11pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>f</mi>
       <mo>+</mo>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>z</mi>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>b</mi>
        <mn>1</mn>
       </msub>
       <msup>
        <mi>z</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>b</mi>
        <mn>2</mn>
       </msub>
       <msup>
        <mi>z</mi>
        <mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <minus></minus>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <plus></plus>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>z</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{f_{-}(z)=a_{0}+a_{1}z+a_{2}z^{2}+\cdots,\,\,\,\,\,f_{+}(z)=z+b_{%
1}z^{-1}+b_{2}z^{-2}+\cdots,}
  </annotation>
 </semantics>
</math>

</p>

<p>defined in |z|  1 and both extending smoothly to the unit circle, mapping onto a Jordan domain and its complement, such that</p>

<p>

<math display="block" id="Conformal_welding:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mo>-</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>i</mi>
        <mi>θ</mi>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mo>+</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>e</mi>
         <mrow>
          <mi>i</mi>
          <mi>θ</mi>
         </mrow>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <minus></minus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <plus></plus>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{f_{-}(e^{i\theta})=f_{+}(f(e^{i\theta})).}
  </annotation>
 </semantics>
</math>

</p>

<p>Let <em>F</em> be the restriction of <em>f</em><sub>+</sub> to the unit circle. Then</p>

<p>

<math display="block" id="Conformal_welding:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi>F</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mi>F</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>i</mi>
       <mi>θ</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>F</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>F</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{TF=-F+2e^{i\theta}}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Conformal_welding:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>T</mi>
      <mi>F</mi>
     </mrow>
     <mo>∘</mo>
     <mi>f</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>F</mi>
     <mo>∘</mo>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>F</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <compose></compose>
     <ci>F</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{TF\circ f=F\circ f.}
  </annotation>
 </semantics>
</math>

</p>

<p>Hence</p>

<p>

<math display="block" id="Conformal_welding:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>F</mi>
         <mo>∘</mo>
         <mi>f</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∘</mo>
      <msup>
       <mi>f</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>F</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>F</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>i</mi>
        <mi>θ</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <compose></compose>
        <ci>F</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>F</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>F</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{T(F\circ f)\circ f^{-1}-T(F)=2F-2e^{i\theta}.}
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>V</em>(<em>f</em>) denotes the bounded invertible operator on L<sup>2</sup> induced by the diffeomorphism <em>f</em>, then the operator</p>

<p>

<math display="block" id="Conformal_welding:10">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mi>V</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>-</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>f</ci>
      <ci>P</ci>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{K_{f}=V(f)PV(f)^{-1}-P}
  </annotation>
 </semantics>
</math>

</p>

<p>is compact, indeed it is given by an operator with smooth kernel because <em>P</em> and <em>T</em> are given by singular integral operators. The equation above then reduces to</p>

<p>

<math display="block" id="Conformal_welding:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>I</mi>
       <mo>-</mo>
       <msub>
        <mi>K</mi>
        <mi>f</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>F</mi>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>i</mi>
      <mi>θ</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <ci>F</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{(I-K_{f})F=e^{i\theta}.}
  </annotation>
 </semantics>
</math>

</p>

<p>The operator <em>I</em> − <em>K</em><sub><em>f</em></sub> is a <a href="Fredholm_operator" title="wikilink">Fredholm operator</a> of index zero. It has zero kernel and is therefore invertible. In fact an element in the kernel would consist of a pair of holomorphic functions on <em>D</em> and <em>D</em><sup><em>c</em></sup> which have smooth boundary values on the circle related by <em>f</em>. Since the holomorphic function on <em>D</em><sup><em>c</em></sup> vanishes at ∞, the positive powers of this pair also provide solutions, which are linearly independent, contradicting the fact that <em>I</em> − <em>K</em><sub><em>f</em></sub> is a Fredholm operator. The above equation therefore has a unique solution <em>F</em> which is smooth and from which <em>f</em><sub>±</sub> can be reconstructed by reversing the steps above. Indeed, by looking at the equation satisfied by the logarithm of the derivative of <em>F</em>, it follows that <em>F</em> has nowhere vanishing derivative on the unit circle. Moreover <em>F</em> is one-one on the circle since if it assumes the value <em>a</em> at different points <em>z</em><sub>1</sub> and <em>z</em><sub>2</sub> then the logarithm of <em>R</em>(<em>z</em>) = (<em>F</em>(<em>z</em>) − <em>a</em>)/(<em>z</em> - <em>z</em><sub>1</sub>)(<em>z</em> − <em>z</em>2 would satisfy an integral equation known to have no non--zero solutions. Given these properties on the unit circle, the required properties of <em>f</em><sub>±</sub> then follow from the <a href="argument_principle" title="wikilink">argument principle</a>.<ref>See:</ref></p>
<ul>
<li></li>
<li>

<p></p></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Theorems_in_analysis" title="wikilink">Category:Theorems in analysis</a> <a href="Category:Complex_analysis" title="wikilink">Category:Complex analysis</a> <a href="Category:Riemann_surfaces" title="wikilink">Category:Riemann surfaces</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</hr></body>
</html>
