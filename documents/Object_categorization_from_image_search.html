<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1825">Object categorization from image search</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Object categorization from image search</h1>
<hr/>

<p>In computer vision, the problem of <strong>object categorization from image search</strong> is the problem of training a <a href="Statistical_classification" title="wikilink">classifier</a> to recognize categories of objects, using only the images retrieved automatically with an Internet search engine. Ideally, automatic image collection would allow classifiers to be trained with nothing but the category names as input. This problem is closely related to that of content-based image retrieval (CBIR), where the goal is to return better image search results rather than training a classifier for image recognition.</p>

<p>Traditionally, classifiers are trained using sets of images that are labeled by hand. Collecting such a set of images is often a very time-consuming and laborious process. The use of Internet search engines to automate the process of acquiring large sets of labeled images has been described as a potential way of greatly facilitating computer vision research.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="challenges">Challenges</h2>
<h3 id="unrelated-images">Unrelated images</h3>

<p>One problem with using Internet image search results as a training set for a classifier is the high percentage of unrelated images within the results. It has been estimated that, when a search engine such as Google images is queried with the name of an object category (such as airplane?, up to 85% of the returned images are unrelated to the category.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="intra-class-variability">Intra-class variability</h3>

<p>Another challenge posed by using Internet image search results as training sets for classifiers is that there is a high amount of variability within object categories, when compared with categories found in hand-labeled datasets such as <a href="Caltech_101" title="wikilink">Caltech 101</a> and <a href="Pascal_(programming_language)" title="wikilink">Pascal</a>. Images of objects can vary widely in a number of important factors, such as scale, pose, lighting, number of objects, and amount of occlusion.</p>
<h2 id="plsa-approach">pLSA approach</h2>

<p>In a 2005 paper by Fergus et al.,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="uri" href="pLSA" title="wikilink">pLSA</a> (probabilistic latent semantic analysis) and extensions of this model were applied to the problem of object categorization from image search. pLSA was originally developed for <a href="document_classification" title="wikilink">document classification</a>, but has since been applied to <a href="computer_vision" title="wikilink">computer vision</a>. It makes the assumption that images are documents that fit the <a href="bag_of_words_model" title="wikilink">bag of words model</a>.</p>
<h3 id="model">Model</h3>

<p>Just as text documents are made up of words, each of which may be repeated within the document and across documents, images can be modeled as combinations of <em>visual words</em>. Just as the entire set of text words are defined by a dictionary, the entire set of visual words is defined in a <em>codeword dictionary</em>.</p>

<p>pLSA divides documents into <em>topics</em> as well. Just as knowing the topic(s) of an article allows you to make good guesses about the kinds of words that will appear in it, the distribution of words in an image is dependent on the underlying topics. The pLSA model tells us the probability of seeing each word 

<math display="inline" id="Object_categorization_from_image_search:0">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 given the category 

<math display="inline" id="Object_categorization_from_image_search:1">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle d
  </annotation>
 </semantics>
</math>

 in terms of topics 

<math display="inline" id="Object_categorization_from_image_search:2">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle z
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Object_categorization_from_image_search:3">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">|</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mstyle displaystyle="true">
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>z</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>Z</mi>
    </munderover>
   </mstyle>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">|</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">|</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>Z</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(w|d)=\sum_{z=1}^{Z}P(w|z)P(z|d)
  </annotation>
 </semantics>
</math>

</p>

<p>An important assumption made in this model is that 

<math display="inline" id="Object_categorization_from_image_search:4">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Object_categorization_from_image_search:5">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle d
  </annotation>
 </semantics>
</math>

 are conditionally independent given 

<math display="inline" id="Object_categorization_from_image_search:6">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle z
  </annotation>
 </semantics>
</math>

. Given a topic, the probability of a certain word appearing as part of that topic is independent of the rest of the image.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Training this model involves finding 

<math display="inline" id="Object_categorization_from_image_search:7">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">|</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(w|z)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Object_categorization_from_image_search:8">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">|</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(z|d)
  </annotation>
 </semantics>
</math>

 that maximizes the likelihood of the observed words in each document. To do this, the <a href="expectation_maximization" title="wikilink">expectation maximization</a> algorithm is used, with the following <a href="objective_function" title="wikilink">objective function</a>:</p>

<p>

<math display="inline" id="Object_categorization_from_image_search:9">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mstyle displaystyle="true">
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>d</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>D</mi>
    </munderover>
   </mstyle>
   <mstyle displaystyle="true">
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>w</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>W</mi>
    </munderover>
   </mstyle>
   <mi>P</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">|</mo>
     <mi>d</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">|</mo>
      <mi>d</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>d</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>D</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>W</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">d</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle L=\prod_{d=1}^{D}\prod_{w=1}^{W}P(w|d)^{n(w|d)}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="application">Application</h3>
<h4 id="abs-plsa">ABS-pLSA</h4>

<p>Absolute position pLSA (ABS-pLSA) attaches location information to each visual word by localizing it to one of X 揵ins?in the image. Here, 

<math display="inline" id="Object_categorization_from_image_search:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x
  </annotation>
 </semantics>
</math>

 represents which of the bins the visual word falls into. The new equation is:</p>

<p>

<math display="inline" id="Object_categorization_from_image_search:11">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">|</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mstyle displaystyle="true">
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>z</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>Z</mi>
    </munderover>
   </mstyle>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">|</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>Z</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(w|d)=\sum_{z=1}^{Z}P(w,x|z)P(z|d)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Object_categorization_from_image_search:12">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(w,x|z)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Object_categorization_from_image_search:13">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(d)
  </annotation>
 </semantics>
</math>

 can be solved for in a manner similar to the original pLSA problem, using the <a href="Expectation_Maximization" title="wikilink">EM algorithm</a></p>

<p>A problem with this model is that it is not translation or scale invariant. Since the positions of the visual words are absolute, changing the size of the object in the image or moving it would have a significant impact on the spatial distribution of the visual words into different bins.</p>
<h4 id="tsi-plsa">TSI-pLSA</h4>

<p>Translation and scale invariant pLSA (TSI-pLSA). This model extends pLSA by adding another latent variable, which describes the spatial location of the target object in an image. Now, the position 

<math display="inline" id="Object_categorization_from_image_search:14">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x
  </annotation>
 </semantics>
</math>

 of a visual word is given relative to this object location, rather than as an absolute position in the image. The new equation is:</p>

<p>

<math display="inline" id="Object_categorization_from_image_search:15">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mstyle displaystyle="true">
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>z</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>Z</mi>
    </munderover>
   </mstyle>
   <mstyle displaystyle="true">
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>c</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>C</mi>
    </munderover>
   </mstyle>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">|</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>Z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>C</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(w,x|d)=\sum_{z=1}^{Z}\sum_{c=1}^{C}P(w,x|c,z)P(c)P(z|d)
  </annotation>
 </semantics>
</math>

</p>

<p>Again, the parameters 

<math display="inline" id="Object_categorization_from_image_search:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(w,x|c,z)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Object_categorization_from_image_search:17">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(d)
  </annotation>
 </semantics>
</math>

 can be solved using the <a href="Expectation_Maximization" title="wikilink">EM algorithm</a>. 

<math display="inline" id="Object_categorization_from_image_search:18">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(c)
  </annotation>
 </semantics>
</math>

 can be assumed to be a uniform distribution.</p>
<h3 id="implementation">Implementation</h3>
<h4 id="selecting-words">Selecting words</h4>

<p>Words in an image were selected using 4 different feature detectors:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<ul>
<li><a href="Kadir-Brady_saliency_detector" title="wikilink">Kadir-Brady saliency detector</a></li>
<li><a href="Corner_detection" title="wikilink">Multi-scale Harris detector</a></li>
<li><a href="Difference_of_Gaussians" title="wikilink">Difference of Gaussians</a></li>
<li>Edge based operator, described in the study</li>
</ul>

<p>Using these 4 detectors, approximately 700 features were detected per image. These features were then encoded as <a href="Scale-invariant_feature_transform" title="wikilink">Scale-invariant feature transform</a> descriptors, and vector quantized to match one of 350 words contained in a codebook. The codebook was precomputed from features extracted from a large number of images spanning numerous object categories.</p>
<h4 id="possible-object-locations">Possible object locations</h4>

<p>One important question in the TSI-pLSA model is how to determine the values that the random variable 

<math display="inline" id="Object_categorization_from_image_search:19">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle C
  </annotation>
 </semantics>
</math>

 can take on. It is a 4-vector, whose components describe the object抯 centroid as well as x and y scales that define a bounding box around the object, so the space of possible values it can take on is enormous. To limit the number of possible object locations to a reasonable number, normal pLSA is first carried out on the set of images, and for each topic a <a href="Gaussian_mixture_model" title="wikilink">Gaussian mixture model</a> is fit over the visual words, weighted by 

<math display="inline" id="Object_categorization_from_image_search:20">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">|</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(w|z)
  </annotation>
 </semantics>
</math>

. Up to 

<math display="inline" id="Object_categorization_from_image_search:21">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle K
  </annotation>
 </semantics>
</math>

 Gaussians are tried (allowing for multiple instances of an object in a single image), where 

<math display="inline" id="Object_categorization_from_image_search:22">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle K
  </annotation>
 </semantics>
</math>

 is a constant.</p>
<h3 id="performance">Performance</h3>

<p>The authors of the Fergus et al. paper compared performance of the three pLSA algorithms (pLSA, ABS-pLSA, and TSI-pLSA) on handpicked datasets and images returned from Google searches. Performance was measured as the error rate when classifying images in a test set as either containing the image or containing only background.</p>

<p>As expected, training directly on Google data gives higher error rates than training on prepared data.?<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> In about half of the object categories tested do ABS-pLSA and TSI-pLSA perform significantly better than regular pLSA, and in only 2 categories out of 7 does TSI-pLSA perform better than the other two models.</p>
<h2 id="optimol">OPTIMOL</h2>

<p>OPTIMOL (automatic Online Picture collection via Incremental MOdel Learning) approaches the problem of learning object categories from online image searches by addressing model learning and searching simultaneously. OPTIMOL is an iterative model that updates its model of the target object category while concurrently retrieving more relevant images.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="general-framework">General framework</h3>

<p>OPTIMOL was presented as a general iterative framework that is independent of the specific model used for category learning. The algorithm is as follows:</p>
<ul>
<li><strong>Download</strong> a large set of images from the Internet by searching for a keyword</li>
<li><strong>Initialize</strong> the dataset with seed images</li>
<li><strong>While</strong> more images needed in the dataset:
<ul>
<li><strong>Learn</strong> the model with most recently added dataset images</li>
<li><strong>Classify</strong> downloaded images using the updated model</li>
<li><strong>Add</strong> accepted images to the dataset</li>
</ul></li>
</ul>

<p>Note that only the most recently added images are used in each round of learning. This allows the algorithm to run on an arbitrarily large number of input images.</p>
<h3 id="model-1">Model</h3>

<p>The two categories (target object and background) are modeled as Hierarchical Dirichlet processes (HDPs). As in the pLSA approach, it is assumed that the images can be described with the <a href="bag_of_words_model" title="wikilink">bag of words model</a>. HDP models the distributions of an unspecified number of topics across images in a category, and across categories. The distribution of topics among images in a single category is modeled as a <a href="Dirichlet_process" title="wikilink">Dirichlet process</a> (a type of <a href="Non-parametric_statistics" title="wikilink">non-parametric</a> <a href="probability_distribution" title="wikilink">probability distribution</a>). To allow the sharing of topics across classes, each of these Dirichlet processes is modeled as a sample from another 損arent?Dirichlet process. HDP was first described by Teh et al. in 2005.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="implementation-1">Implementation</h3>
<h4 id="initialization">Initialization</h4>

<p>The dataset must be initialized, or seeded with an original batch of images which serve as good exemplars of the object category to be learned. These can be gathered automatically, using the first page or so of images returned by the search engine (which tend to be better than the subsequent images). Alternatively, the initial images can be gathered by hand.</p>
<h4 id="model-learning">Model learning</h4>

<p>To learn the various parameters of the HDP in an incremental manner, <a href="Gibbs_sampling" title="wikilink">Gibbs sampling</a> is used over the latent variables. It is carried out after each new set of images is incorporated into the dataset. Gibbs sampling involves repeatedly sampling from a set of <a href="random_variables" title="wikilink">random variables</a> in order to approximate their distributions. Sampling involves generating a value for the random variable in question, based on the state of the other random variables on which it is dependent. Given sufficient samples, a reasonable approximation of the value can be achieved.</p>
<h4 id="classification">Classification</h4>

<p>At each iteration, 

<math display="inline" id="Object_categorization_from_image_search:23">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">|</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(z|c)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Object_categorization_from_image_search:24">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>z</mi>
    <mo>,</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(x|z,c)
  </annotation>
 </semantics>
</math>

 can be obtained from model learned after the previous round of Gibbs sampling, where 

<math display="inline" id="Object_categorization_from_image_search:25">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle z
  </annotation>
 </semantics>
</math>

 is a topic, 

<math display="inline" id="Object_categorization_from_image_search:26">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle c
  </annotation>
 </semantics>
</math>

 is a category, and 

<math display="inline" id="Object_categorization_from_image_search:27">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x
  </annotation>
 </semantics>
</math>

 is a single visual word. The likelihood of an image being in a certain class, then, is:</p>

<p>

<math display="inline" id="Object_categorization_from_image_search:28">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">|</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mstyle displaystyle="true">
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mi>i</mi>
    </munder>
   </mstyle>
   <mstyle displaystyle="true">
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>j</mi>
    </munder>
   </mstyle>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>z</mi>
     <mi>j</mi>
    </msub>
    <mo>,</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>z</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>j</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(I|c)=\prod_{i}\sum_{j}P(x_{i}|z_{j},c)P(z_{j}|c)
  </annotation>
 </semantics>
</math>

</p>

<p>This is computed for each new candidate image per iteration. The image is classified as belonging to the category with the highest likelihood.</p>
<h4 id="addition-to-the-dataset-and-cache-set">Addition to the dataset and "cache set"</h4>

<p>In order to qualify for incorporation into the dataset, however, an image must satisfy a stronger condition:</p>

<p>

<math display="inline" id="Object_categorization_from_image_search:29">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>I</mi>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>c</mi>
        <mi>f</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>I</mi>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>c</mi>
        <mi>b</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mo>></mo>
   <mrow>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mrow>
         <mi>A</mi>
         <msub>
          <mi>c</mi>
          <mi>b</mi>
         </msub>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>λ</mi>
        <mrow>
         <mi>R</mi>
         <msub>
          <mi>c</mi>
          <mi>b</mi>
         </msub>
        </mrow>
       </msub>
      </mrow>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mrow>
         <mi>R</mi>
         <msub>
          <mi>c</mi>
          <mi>f</mi>
         </msub>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>λ</mi>
        <mrow>
         <mi>A</mi>
         <msub>
          <mi>c</mi>
          <mi>f</mi>
         </msub>
        </mrow>
       </msub>
      </mrow>
     </mfrac>
    </mstyle>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>c</mi>
         <mi>b</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>c</mi>
         <mi>f</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mstyle>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">I</csymbol>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>f</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">I</csymbol>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>b</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>b</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <apply>
         <times></times>
         <ci>R</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>b</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <apply>
         <times></times>
         <ci>R</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>f</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>f</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\frac{P(I|c_{f})}{P(I|c_{b})}>\frac{\lambda_{Ac_{b}}-\lambda_{Rc_%
{b}}}{\lambda_{Rc_{f}}-\lambda_{Ac_{f}}}\frac{P(c_{b})}{P(c_{f})}
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Object_categorization_from_image_search:30">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle c_{f}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Object_categorization_from_image_search:31">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>b</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle c_{b}
  </annotation>
 </semantics>
</math>

 are foreground (object) and background categories, respectively, and the ratio of constants describes the risk of accepting false positives and false negatives. They are adjusted automatically at every iteration, with the cost of a false positive set higher than that of a false negative. This ensures that a better dataset is collected.</p>

<p>Once an image is accepted by meeting the above criterion and incorporated into the dataset, however, it needs to meet another criterion before it is incorporated into the 揷ache set敆the set of images to be used for training. This set is intended to be a diverse subset of the set of accepted images. If the model were trained on all accepted images, it might become more and more highly specialized, only accepting images very similar to previous ones.</p>
<h3 id="performance-1">Performance</h3>

<p>Performance of the OPTIMOL method is defined by three factors:</p>
<ul>
<li><em>Ability to collect images</em>: OPTIMOL, it is found, can automatically collect large numbers of good images from the web. The size of the OPTIMOL-retrieved image sets surpass that of large human-labeled image sets for the same categories, such as those found in <a href="Caltech_101" title="wikilink">Caltech 101</a>.</li>
</ul>
<ul>
<li><em>Classification accuracy</em>: Classification accuracy was compared to the accuracy displayed by the classifier yielded by the pLSA methods discussed earlier. It was discovered that OPTIMOL achieved slightly higher accuracy, obtaining 74.8% accuracy on 7 object categories, as compared to 72.0%.</li>
</ul>
<ul>
<li><em>Comparison with batch learning</em>: An important question to address is whether OPTIMOL's incremental learning gives it an advantage over traditional batch learning methods, when everything else about the model is held constant. When the classifier learns incrementally, by selecting the next images based on what it learned from the previous ones, three important results are observed:
<ul>
<li>Incremental learning allows OPTIMOL to collect a better dataset</li>
<li>Incremental learning allows OPTIMOL to learn faster (by discarding irrelevant images)</li>
<li>Incremental learning does not negatively affect the <a href="ROC_curve" title="wikilink">ROC curve</a> of the classifier; in fact, incremental learning yielded an improvement</li>
</ul></li>
</ul>
<h2 id="object-categorization-in-content-based-image-retrieval">Object categorization in content-based image retrieval</h2>

<p>Typically, image searches only make use of text associated with images. The problem of <a href="content-based_image_retrieval" title="wikilink">content-based image retrieval</a> is that of improving search results by taking into account visual information contained in the images themselves. Several CBIR methods make use of classifiers trained on image search results, to refine the search. In other words, object categorization from image search is one component of the system. OPTIMOL, for example, uses a classifier trained on images collected during previous iterations to select additional images for the returned dataset.</p>

<p>Examples of CBIR methods that model object categories from image search are:</p>
<ul>
<li>Fergus et al., 2004 <ref></ref></li>
</ul>

<p></p>
<ul>
<li>Berg and Forsyth, 2006 <ref></ref></li>
</ul>

<p></p>
<ul>
<li>Yanai and Barnard, 2006 <ref></ref></li>
</ul>

<p></p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Probabilistic_latent_semantic_analysis" title="wikilink">Probabilistic latent semantic analysis</a></li>
<li><a href="Latent_Dirichlet_allocation" title="wikilink">Latent Dirichlet allocation</a></li>
<li><a href="Machine_learning" title="wikilink">Machine learning</a></li>
<li><a href="Bag_of_words_model" title="wikilink">Bag of words model</a></li>
<li><a href="Content-based_image_retrieval" title="wikilink">Content-based image retrieval</a></li>
</ul>

<p>"</p>

<p><a href="Category:Object_recognition_and_categorization" title="wikilink">Category:Object recognition and categorization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
