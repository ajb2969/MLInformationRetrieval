   Programming Computable Functions      Programming Computable Functions   In computer science , Programming Computable Functions , 1 or PCF , is a typed  functional language introduced in an unpublished 1969 manuscript by Dana Scott . It can be considered to be an extended version of the typed lambda calculus or a simplified version of modern typed functional languages such as ML .  A fully abstract model for PCF was first given by Milner (1977). However, since Milner's model was essentially based on the syntax of PCF it was considered less than satisfactory (Ong, 1995). The first two fully abstract models not employing syntax were formulated during the 1990s. These models are based on game semantics (Hyland and Ong, 2000; Abramsky, Jagadeesan, and Malacaria, 2000) and Kripke logical relations (O'Hearn and Riecke, 1995). For a time it was felt that neither of these models was completely satisfactory, since they were not effectively presentable. However, Ralph Loader demonstrated that no effectively presentable fully abstract model could exist, since the question of program equivalence in the finitary fragment of PCF is not decidable.  Syntax  The types of PCF are inductively defined as   nat is a type  For types Ïƒ and Ï„ , there is a type Ïƒ â†’ Ï„   A context is a list of pairs x : Ïƒ , where x is a variable name and Ïƒ is a type, such that no variable name is duplicated. One then defines typing judgments of terms-in-context in the usual way for the following syntactical constructs:   Variables (if x : Ïƒ is part of a context Î“ , then Î“ âŠ¢ x : Ïƒ )  Application (of a term of type Ïƒ â†’ Ï„ to a term of type Ïƒ )  Î»-abstraction  The Y fixed point combinator (making terms of type Ïƒ out of terms of type Ïƒ â†’ Ïƒ )  The successor ( succ ) and predecessor ( pred ) operations on nat and the constant 0  The conditional if with the typing rule:         Î“   âŠ¢   t   :   ğ§ğšğ­  ,   Î“    âŠ¢    s  0    :   Ïƒ  ,   Î“    âŠ¢    s  1    :  Ïƒ     Î“   âŠ¢   ğ¢ğŸ   (  t  ,   s  0   ,   s  1   )    :  Ïƒ          proves  normal-Î“  t    normal-:     nat  normal-Î“     proves     subscript  s  0     normal-:     Ïƒ  normal-Î“     proves     subscript  s  1     normal-:    Ïƒ       proves  normal-Î“    if   t   subscript  s  0    subscript  s  1       normal-:    Ïƒ      \frac{\Gamma\;\vdash\;t\;:\textbf{nat},\quad\quad\Gamma\;\vdash\;s_{0}\;:%
 \sigma,\quad\quad\Gamma\;\vdash\;s_{1}\;:\sigma}{\Gamma\;\vdash\;\textbf{if}(t%
 ,s_{0},s_{1})\;:\sigma}      ( nat s will be interpreted as booleans here with a convention like zero denoting truth, and any other number denoting falsity)   Semantics  Denotational semantics  A relatively straightforward semantics for the language is the Scott model . In this model,   Types are interpreted as certain domains .       [   [  ğ§ğšğ­  ]   ]   :=   â„•  âŠ¥      assign   delimited-[]   delimited-[]  nat     subscript  â„•  bottom     [\![\textbf{nat}]\!]:=\mathbb{N}_{\bot}   (the natural numbers with a bottom element adjoined, with the flat ordering)      [   [  Ïƒ  â†’   Ï„   ]   ]     fragments  normal-[   fragments  normal-[  Ïƒ  normal-â†’  Ï„  normal-]   normal-]    [\![\sigma\to\tau\,]\!]   is interpreted as the domain of Scott-continuous functions from    [   [  Ïƒ  ]   ]     delimited-[]   delimited-[]  Ïƒ     [\![\sigma]\!]\,   to    [   [  Ï„  ]   ]     delimited-[]   delimited-[]  Ï„     [\![\tau]\!]\,        A context     x  1   :    Ïƒ  1   ,  â€¦  ,   x  n    :   Ïƒ  n        normal-:   subscript  x  1     subscript  Ïƒ  1   normal-â€¦   subscript  x  n      normal-:     subscript  Ïƒ  n      x_{1}:\sigma_{1},\;\dots,\;x_{n}:\sigma_{n}   is interpreted as the product     [   [   Ïƒ  1   ]   ]   Ã—   â€¦   Ã—   [   [   Ïƒ  n   ]   ]        delimited-[]   delimited-[]   subscript  Ïƒ  1     normal-â€¦   delimited-[]   delimited-[]   subscript  Ïƒ  n       [\![\sigma_{1}]\!]\times\;\dots\;\times[\![\sigma_{n}]\!]     Terms in context     Î“   âŠ¢   x   :  Ïƒ       proves  normal-Î“  x    normal-:    Ïƒ     \Gamma\;\vdash\;x\;:\;\sigma   are interpreted as continuous functions     [   [  Î“  ]   ]   â†’   [   [  Ïƒ  ]   ]      normal-â†’   delimited-[]   delimited-[]  normal-Î“     delimited-[]   delimited-[]  Ïƒ      [\![\Gamma]\!]\;\to\;[\![\sigma]\!]     Variable terms are interpreted as projections  Lambda abstraction and application are interpreted by making use of the cartesian closed structure of the category of domains and continuous functions  Y is interpreted by taking the least fixed point of the argument    This model is not fully abstract for PCF; but it is fully abstract for the language obtained by adding a parallel or operator to PCF (p.Â 293 in the Hyland and Ong 2000 reference below).  Notes    References   {{ cite journal   |Â firstÂ =Â DanaÂ S.  |Â lastÂ =Â Scott  |Â authorlinkÂ =Â DanaÂ Scott  |Â titleÂ =Â AÂ type-theoreticÂ alternativeÂ toÂ CUCH,Â ISWIM,Â OWHY  |Â journalÂ = Unpublished  manuscript  |Â urlÂ = http://www.cs.cmu.edu/~kw/scans/scott93tcs.pdf  |Â yearÂ =Â 1969  |Â refÂ =Â harv}}Â RepublishedÂ in   {{ cite journal   |Â firstÂ =Â GordonÂ D.  |Â lastÂ =Â Plotkin  |Â authorlinkÂ =Â GordonÂ Plotkin  |Â titleÂ =Â LCFÂ consideredÂ toÂ beÂ aÂ programmingÂ language  |Â journalÂ =Â TheoreticalÂ ComputerÂ Science  |Â yearÂ =Â 1977  |Â pagesÂ =Â 223â€“255  |Â volumeÂ =Â 5  |Â doiÂ =Â 10.1016/0304-3975(77)90044-5  |Â urlÂ = http://homepages.inf.ed.ac.uk/gdp/publications/LCF.pdf  |Â refÂ =Â harv}}    {{ cite journal   |Â authorÂ =Â Abramsky,Â S.,Â Jagadeesan,Â R.,Â andÂ Malacaria,Â P.  |Â titleÂ =Â FullÂ AbstractionÂ forÂ PCF  |Â journalÂ =Â InformationÂ andÂ Computation  |Â year=Â 2000  |Â pagesÂ =Â 409â€“470  |Â volumeÂ =Â 163  |Â issueÂ =Â 2  |Â doiÂ =Â 10.1006/inco.2000.2930}}   {{ cite journal   |Â authorÂ =Â Hyland,Â J.Â M.Â E.Â andÂ Ong,Â C.-H.Â L.  |Â titleÂ =Â OnÂ FullÂ AbstractionÂ forÂ PCF  |Â journalÂ =Â InformationÂ andÂ Computation  |Â year=Â 2000  |Â pagesÂ =Â 285â€“408  |Â volumeÂ =Â 163  |Â issueÂ =Â 2  |Â doiÂ =Â 10.1006/inco.2000.2917}}   {{ cite journal   |Â authorÂ =Â O'Hearn,Â P.Â W.Â andÂ Riecke,Â J.Â G  |Â titleÂ =Â KripkeÂ LogicalÂ RelationsÂ andÂ PCF  |Â journalÂ =Â InformationÂ andÂ Computation  |Â yearÂ =Â 1995  |Â pagesÂ =Â 107â€“116  |Â volumeÂ =Â 120  |Â issueÂ =Â 1  |Â doiÂ =Â 10.1006/inco.1995.1103}}   {{ cite journal   |Â authorÂ =Â Loader,Â R.  |Â titleÂ =Â FinitaryÂ PCFÂ isÂ notÂ decidable  |Â journalÂ =Â TheoreticalÂ ComputerÂ Science  |Â year=Â 2001  |Â pagesÂ =Â 341â€“364  |Â volumeÂ =Â 266  |Â issueÂ =Â 1-2  |Â doiÂ =Â 10.1016/S0304-3975(00)00194-8}}     External links   Introduction to RealPCF  Lexer and Parser for PCF written in SML   "  Category:1977 in computer science  Category:Academic programming languages  Category:Educational programming languages  Category:Functional languages  Category:Programming language theory     "PCF is a programming language for computable functions, based on LCF, Scottâ€™s logic of computable functions" . Programming Computable Functions is used by . It is also referred to as Programming with Computable Functions or Programming language for Computable Functions . â†©     