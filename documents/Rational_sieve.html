<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="956">Rational sieve</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Rational sieve</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>rational sieve</strong> is a general <a class="uri" href="algorithm" title="wikilink">algorithm</a> for <a href="integer_factorization" title="wikilink">factoring integers into prime factors</a>. It is essentially a special case of the <a href="general_number_field_sieve" title="wikilink">general number field sieve</a>, and while it is far less <a href="algorithmic_efficiency" title="wikilink">efficient</a> than the general algorithm, it is conceptually far simpler. So while it is rather useless as a practical factoring algorithm, it is a helpful first step for those trying to understand how the general number field sieve works.</p>
<h2 id="method">Method</h2>

<p>Suppose we are trying to factor the <a href="composite_number" title="wikilink">composite number</a> <em>n</em>. We choose a bound <em>B</em>, and identify the <em><a href="factor_base" title="wikilink">factor base</a></em> (which we will call <em>P</em>), the set of all primes less than or equal to <em>B</em>. Next, we search for positive integers <em>z</em> such that both <em>z</em> and <em>z+n</em> are <em>B</em>-<a href="smooth_number" title="wikilink">smooth</a> — i.e. all of their prime factors are in <em>P</em>. We can therefore write, for suitable exponents 

<math display="inline" id="Rational_sieve:0">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="inline" id="Rational_sieve:1">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mo>∈</mo>
      <mi>P</mi>
     </mrow>
    </msub>
    <msubsup>
     <mi>p</mi>
     <mi>i</mi>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <ci>P</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=\prod_{p_{i}\in P}p_{i}^{a_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>and likewise, for suitable 

<math display="inline" id="Rational_sieve:2">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{k}
  </annotation>
 </semantics>
</math>

, we have</p>

<p>

<math display="inline" id="Rational_sieve:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mo>+</mo>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mo>∈</mo>
      <mi>P</mi>
     </mrow>
    </msub>
    <msubsup>
     <mi>p</mi>
     <mi>i</mi>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>z</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <ci>P</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z+n=\prod_{p_{i}\in P}p_{i}^{b_{i}}
  </annotation>
 </semantics>
</math>

.</p>

<p>But 

<math display="inline" id="Rational_sieve:4">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rational_sieve:5">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>+</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>z</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z+n
  </annotation>
 </semantics>
</math>

 are congruent modulo 

<math display="inline" id="Rational_sieve:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, and so each such integer <em>z</em> that we find yields a multiplicative relation <a href="Modular_arithmetic" title="wikilink">(mod <em>n</em>)</a> among the elements of <em>P</em>, i.e.</p>

<p>

<math display="block" id="Rational_sieve:7">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mo>∈</mo>
      <mi>P</mi>
     </mrow>
    </munder>
    <msubsup>
     <mi>p</mi>
     <mi>i</mi>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
    </msubsup>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mo>∈</mo>
      <mi>P</mi>
     </mrow>
    </munder>
    <mrow>
     <mpadded width="+2.8pt">
      <msubsup>
       <mi>p</mi>
       <mi>i</mi>
       <msub>
        <mi>b</mi>
        <mi>i</mi>
       </msub>
      </msubsup>
     </mpadded>
     <mrow>
      <mpadded width="+2.8pt">
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>mod</mi>
       </mrow>
      </mpadded>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <ci>P</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <ci>P</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">mod</csymbol>
       </cerror>
       <ci>n</ci>
      </apply>
      <ci>normal-)</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{p_{i}\in P}p_{i}^{a_{i}}\equiv\prod_{p_{i}\in P}p_{i}^{b_{i}}\;%
\operatorname{(mod}\;n\operatorname{)}
  </annotation>
 </semantics>
</math>

</p>

<p>(where the <em>a<sub>i</sub></em> and <em>b<sub>i</sub></em> are nonnegative integers.)</p>

<p>When we have generated enough of these relations (it's generally sufficient that the number of relations be a few more than the size of <em>P</em>), we can use the methods of <a href="linear_algebra" title="wikilink">linear algebra</a> to multiply together these various relations in such a way that the exponents of the primes are all even. This will give us a <a href="congruence_of_squares" title="wikilink">congruence of squares</a> of the form a<sup>2</sup>≡b<sup>2</sup> (mod <em>n</em>), which can be turned into a factorization of <em>n</em>, <em>n</em> = <a href="Greatest_common_divisor" title="wikilink">gcd</a>(<em>a</em>-<em>b</em>,<em>n</em>)×gcd(<em>a</em>+<em>b</em>,<em>n</em>). This factorization might turn out to be trivial (i.e. <em>n</em>=<em>n</em>×1), in which case we have to try again with a different combination of relations; but with luck we will get a nontrivial pair of factors of <em>n</em>, and the algorithm will terminate.</p>
<h2 id="example">Example</h2>

<p>We will factor the integer <em>n</em> = 187 using the rational sieve. We'll arbitrarily try the value <em>B</em>=7, giving the factor base <em>P</em> = {2,3,5,7}. The first step is to test <em>n</em> for divisibility by each of the members of <em>P</em>; clearly if <em>n</em> is divisible by one of these primes, then we are finished already. However, 187 is not divisible by 2, 3, 5, or 7. Next, we search for suitable values of <em>z</em>; the first few are 2, 5, 9, and 56. The four suitable values of <em>z</em> give four multiplicative relations (mod 187):</p>
<ul>
<li>2<sup>1</sup>3<sup>0</sup>5<sup>0</sup>7<sup>0</sup> = 2 ≡ 189 = 2<sup>0</sup>3<sup>3</sup>5<sup>0</sup>7<sup>1</sup>.............(1)</li>
</ul>
<ul>
<li>2<sup>0</sup>3<sup>0</sup>5<sup>1</sup>7<sup>0</sup> = 5 ≡ 192 = 2<sup>6</sup>3<sup>1</sup>5<sup>0</sup>7<sup>0</sup>.............(2)</li>
</ul>
<ul>
<li>2<sup>0</sup>3<sup>2</sup>5<sup>0</sup>7<sup>0</sup> = 9 ≡ 196 = 2<sup>2</sup>3<sup>0</sup>5<sup>0</sup>7<sup>2</sup>.............(3)</li>
</ul>
<ul>
<li>2<sup>3</sup>3<sup>0</sup>5<sup>0</sup>7<sup>1</sup> = 56 ≡ 243 = 2<sup>0</sup>3<sup>5</sup>5<sup>0</sup>7<sup>0</sup>.............(4)</li>
</ul>

<p>There are now several essentially different ways to combine these and end up with even exponents. For example,</p>
<ul>
<li>(1)×(4): After multiplying these and canceling out the common factor of 7 (which we can do since 7, being a member of <em>P</em>, has already been determined to be coprime with <em>n</em><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>), this reduces to 2<sup>4</sup> ≡ 3<sup>8</sup>, or 4<sup>2</sup> ≡ 81<sup>2</sup>. The resulting factorization is 187 = gcd(81-4,187) × gcd(81+4,187) = 11×17.</li>
</ul>

<p>Alternatively, equation (3) is in the proper form already:</p>
<ul>
<li>(3): This says 3<sup>2</sup> ≡ 14<sup>2</sup> (mod <em>n</em>), which gives the factorization 187 = gcd(14-3,187) × gcd(14+3,187) = 11×17.</li>
</ul>
<h2 id="limitations-of-the-algorithm">Limitations of the algorithm</h2>

<p>The rational sieve, like the general number field sieve, cannot factor numbers of the form <em>p<sup>m</sup></em>, where <em>p</em> is a prime and <em>m</em> is an integer. This is not a huge problem, though—such numbers are statistically rare, and moreover there is a simple and fast process to check whether a given number is of this form. Probably the most elegant method is to check whether 

<math display="inline" id="Rational_sieve:8">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">⌊</mo>
     <msup>
      <mi>n</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mi>b</mi>
      </mrow>
     </msup>
     <mo stretchy="false">⌋</mo>
    </mrow>
    <mi>b</mi>
   </msup>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <floor></floor>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor n^{1/b}\rfloor^{b}=n
  </annotation>
 </semantics>
</math>

 holds for any 1 R. Crandall and J. Papadopoulos, <em>On the implementation of AKS-class primality tests,</em> available at <a href="http://www.apple.com/acg/pdf/aks3.pdf">1</a></p>

<p>The biggest problem is finding a sufficient number of <em>z</em> such that both <em>z</em> and <em>z</em>+<em>n</em> are <em>B</em>-smooth. For any given <em>B</em>, the proportion of numbers that are <em>B</em>-smooth decreases rapidly with the size of the number. So if <em>n</em> is large (say, a hundred digits), it will be difficult or impossible to find enough <em>z</em> for the algorithm to work. The advantage of the general number field sieve is that one need only search for smooth numbers of order <em>n</em><sup>1/<em>d</em></sup> for some positive integer <em>d</em> (typically 3 or 5), rather than of order <em>n</em> as required here.</p>
<h2 id="references">References</h2>
<ul>
<li>A. K. Lenstra, H. W. Lenstra, Jr., M. S. Manasse, and J. M. Pollard, <em>The Factorization of the Ninth Fermat Number,</em> Math. Comp. <strong>61</strong> (1993), 319-349. A draft is available at <a href="http://www.std.org/~msm/common/f9paper.ps">www.std.org/~msm/common/f9paper.ps</a>.</li>
</ul>
<ul>
<li>A. K. Lenstra, H. W. Lenstra, Jr. (eds.) <em>The Development of the Number Field Sieve,</em> Lecture Notes in Mathematics 1554, Springer-Verlag, New York, 1993.</li>
</ul>
<h2 id="footnotes">Footnotes</h2>

<p>"</p>

<p><a href="Category:Integer_factorization_algorithms" title="wikilink">Category:Integer factorization algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Note that common factors cannot <em>in general</em> be canceled in a congruence, but they can <em>in this case</em>, since the primes of the factor base are all required to be <a class="uri" href="coprime" title="wikilink">coprime</a> to <em>n</em>, as mentioned above. See <a href="modular_multiplicative_inverse" title="wikilink">modular multiplicative inverse</a>.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
