<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1901">Graver basis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Graver basis</h1>
<hr>In [[applied mathematics]], '''Graver bases''' enable iterative solutions of linear and various nonlinear [[integer programming]] problems in [[polynomial time]].  They were introduced by [[Jack E. Graver]].<ref name="Gra">Jack E. Graver: On the foundations of linear and linear integer programming,
<p><code>Mathematical Programming 9:207–226, 1975 Their connection to the theory of </code><a href="Gröbner_basis" title="wikilink"><code>Gröbner</code> <code>bases</code></a><code> was discussed by </code><a href="Bernd_Sturmfels" title="wikilink"><code>Bernd</code> <code>Sturmfels</code></a><code>.</code><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><code> The algorithmic theory of Graver bases and its application to integer programming is described by </code><a href="Shmuel_Onn" title="wikilink"><code>Shmuel</code> <code>Onn</code></a><code>.</code><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="formal-definition">Formal definition</h2>

<p>The <strong>Graver basis</strong> of an <em>m</em> × <em>n</em> integer matrix 

<math display="inline" id="Graver_basis:0">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is the finite set 

<math display="inline" id="Graver_basis:1">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(A)
  </annotation>
 </semantics>
</math>

 of minimal elements in the set</p>

<p>

<math display="block" id="Graver_basis:2">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℤ</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mi>x</mi>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mi>x</mi>
     <mo>≠</mo>
     <mn>0</mn>
    </mrow>
   </mrow>
   <mo rspace="4.2pt" stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <neq></neq>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\in\mathbb{Z}^{n}:Ax=0,\ x\neq 0\}\,
  </annotation>
 </semantics>
</math>

</p>

<p>under a well partial order on 

<math display="inline" id="Graver_basis:3">
 <semantics>
  <msup>
   <mi>ℤ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℤ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}^{n}
  </annotation>
 </semantics>
</math>

 defined by 

<math display="inline" id="Graver_basis:4">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>⊑</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">square-image-of-or-equals</csymbol>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\sqsubseteq y
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Graver_basis:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}y_{i}\geq 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Graver_basis:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x_{i}|\leq|y_{i}|
  </annotation>
 </semantics>
</math>

 for all i. For example, the Graver basis of 

<math display="inline" id="Graver_basis:7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>121</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <cn type="integer">121</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=(121)
  </annotation>
 </semantics>
</math>

 consists of the vectors (2,−1,0), (0,−1,2), (1,0,−1), (1,−1,1) and their negations.</p>
<h2 id="solving-integer-programming-using-graver-bases">Solving integer programming using Graver bases</h2>

<p><a href="Integer_programming" title="wikilink">Integer programming</a> is the problem of optimizing a linear or nonlinear objective function over the set of integer points satisfying a system of linear inequalities. Formally, it can be written in standard form as follows:</p>

<p>

<math display="block" id="Graver_basis:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo rspace="7.5pt">:</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <msup>
         <mi>ℤ</mi>
         <mi>n</mi>
        </msup>
       </mrow>
       <mo rspace="7.5pt">,</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>A</mi>
          <mi>x</mi>
         </mrow>
         <mo>=</mo>
         <mi>b</mi>
        </mrow>
        <mo rspace="7.5pt">,</mo>
        <mrow>
         <mi>l</mi>
         <mo>≤</mo>
         <mi>x</mi>
         <mo>≤</mo>
         <mi>u</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℤ</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
        <ci>b</ci>
       </apply>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <ci>l</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\{f(x)\ :\ x\in\mathbb{Z}^{n},\ Ax=b,\ l\leq x\leq u\}\ .
  </annotation>
 </semantics>
</math>

</p>

<p>It is one of the most fundamental discrete optimization problems and has a very broad modeling power and numerous applications in a variety of areas, but is typically very hard computationally as noted below. However, given the Graver basis 

<math display="inline" id="Graver_basis:9">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(A)
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Graver_basis:10">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, the problem with linear and various nonlinear objective functions can be solved in polynomial time as explained next.</p>
<h3 id="linear-integer-programming">Linear integer programming</h3>

<p>The most studied case, treated thoroughly in,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> is that of <a href="integer_programming" title="wikilink">linear integer programming</a>,</p>

<p>

<math display="block" id="Graver_basis:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mi>w</mi>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
      </mrow>
      <mo rspace="7.5pt">:</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <msup>
         <mi>ℤ</mi>
         <mi>n</mi>
        </msup>
       </mrow>
       <mo rspace="7.5pt">,</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>A</mi>
          <mi>x</mi>
         </mrow>
         <mo>=</mo>
         <mi>b</mi>
        </mrow>
        <mo rspace="7.5pt">,</mo>
        <mrow>
         <mi>l</mi>
         <mo>≤</mo>
         <mi>x</mi>
         <mo>≤</mo>
         <mi>u</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℤ</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
        <ci>b</ci>
       </apply>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <ci>l</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\{wx\ :\ x\in\mathbb{Z}^{n},\ Ax=b,\ l\leq x\leq u\}\ .
  </annotation>
 </semantics>
</math>

</p>

<p>It may be assumed that all variables are bounded from below and above: such bounds either appear naturally in the application at hand, or can be enforced without losing any optimal solutions. But, even with linear objective functions the problem is NP-hard and hence presumably cannot be solved in polynomial time.</p>

<p>However, given the Graver basis 

<math display="inline" id="Graver_basis:12">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(A)
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Graver_basis:13">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 it <em>can</em> be solved in polynomial time using the following simple iterative algorithm.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Assume first that some initial feasible point <em>x</em> is given. While possible, repeat the following iteration: find positive integer <em>q</em> and element <em>g</em> in 

<math display="inline" id="Graver_basis:14">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(A)
  </annotation>
 </semantics>
</math>

 such that <em>x</em> + <em>qg</em> does not violate the bounds and gives best possible improvement; update <em>x</em> := <em>x</em> + <em>qg</em> and proceed to the next iteration. The last point <em>x</em> is optimal and the number of iterations is polynomial. To find an initial feasible point, a suitable auxiliary program can be set up and solved in a similar fashion.</p>
<h3 id="nonlinear-integer-programming">Nonlinear integer programming</h3>

<p>Turning to the case of general objective functions <em>f</em>, if the variables are unbounded then the problem may in fact be uncomputable: it follows from the solution of <a href="Hilbert's_10th_problem" title="wikilink">Hilbert's 10th problem</a> (see <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>), that there exists no algorithm which, given an integer polynomial <em>f</em> of degree 8 in 58 variables, decides if the minimum value of f over all 58-dimensional integer vectors is 0. However, when the variables are bounded, the problem</p>

<p>

<math display="block" id="Graver_basis:15">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="7.5pt">:</mo>
     <mrow>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <msup>
        <mi>ℤ</mi>
        <mi>n</mi>
       </msup>
      </mrow>
      <mo rspace="7.5pt">,</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mi>x</mi>
        </mrow>
        <mo>=</mo>
        <mi>b</mi>
       </mrow>
       <mo rspace="7.5pt">,</mo>
       <mrow>
        <mi>l</mi>
        <mo>≤</mo>
        <mi>x</mi>
        <mo>≤</mo>
        <mi>u</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℤ</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
        <ci>b</ci>
       </apply>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <ci>l</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\{f(x)\ :\ x\in\mathbb{Z}^{n},\ Ax=b,\ l\leq x\leq u\}
  </annotation>
 </semantics>
</math>

</p>

<p>can be solved using the Graver basis 

<math display="inline" id="Graver_basis:16">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(A)
  </annotation>
 </semantics>
</math>

 in polynomial time for several nonlinear objective functions including:</p>
<ul>
<li><strong>Separable-convex</strong> functions of the form 

<math display="inline" id="Graver_basis:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\sum_{i=1}^{n}f_{i}(x_{i})
  </annotation>
 </semantics>
</math>

;</li>
<li>In particular the <strong>p-norm</strong> 

<math display="inline" id="Graver_basis:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo>∥</mo>
     <mi>x</mi>
     <mo>∥</mo>
    </mrow>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\|x\|_{p}
  </annotation>
 </semantics>
</math>

 for every positive integer <em>p</em>;</li>
<li><strong>Composite-concave</strong> functions <em>f</em>(<em>x</em>) = <em>g</em>(<em>Wx</em>), where <em>W</em> is a <em>d</em> × <em>n</em> integer matrix with <em>d</em> fixed, and where <em>g</em> is a <em>d</em>-variate concave function;</li>
<li>Certain <strong>(in)-definite quadratic</strong> and <strong>higher degree polynomial</strong> functions.</li>
</ul>
<h2 id="some-applications">Some applications</h2>
<h3 id="multi-dimensional-tables">Multi-dimensional tables</h3>

<p>Consider the following optimization problem over three-dimensional tables with prescribed line sums,</p>

<p>

<math display="block" id="Graver_basis:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mi>w</mi>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
      </mrow>
      <mo rspace="7.5pt">:</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <mpadded width="+1.7pt">
         <msubsup>
          <mi>ℤ</mi>
          <mo>+</mo>
          <mrow>
           <mi>l</mi>
           <mo>×</mo>
           <mi>m</mi>
           <mo>×</mo>
           <mi>n</mi>
          </mrow>
         </msubsup>
        </mpadded>
       </mrow>
       <mo rspace="7.5pt">,</mo>
       <mrow>
        <mrow>
         <mrow>
          <munder>
           <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
           <mi>i</mi>
          </munder>
          <msub>
           <mi>x</mi>
           <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
            <mo>,</mo>
            <mi>k</mi>
           </mrow>
          </msub>
         </mrow>
         <mo>=</mo>
         <mpadded width="+1.7pt">
          <msub>
           <mi>a</mi>
           <mrow>
            <mi>j</mi>
            <mo>,</mo>
            <mi>k</mi>
           </mrow>
          </msub>
         </mpadded>
        </mrow>
        <mo rspace="7.5pt">,</mo>
        <mrow>
         <mrow>
          <mrow>
           <munder>
            <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
            <mi>j</mi>
           </munder>
           <msub>
            <mi>x</mi>
            <mrow>
             <mi>i</mi>
             <mo>,</mo>
             <mi>j</mi>
             <mo>,</mo>
             <mi>k</mi>
            </mrow>
           </msub>
          </mrow>
          <mo>=</mo>
          <mpadded width="+1.7pt">
           <msub>
            <mi>b</mi>
            <mrow>
             <mi>i</mi>
             <mo>,</mo>
             <mi>k</mi>
            </mrow>
           </msub>
          </mpadded>
         </mrow>
         <mo rspace="7.5pt">,</mo>
         <mrow>
          <mrow>
           <munder>
            <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
            <mi>k</mi>
           </munder>
           <msub>
            <mi>x</mi>
            <mrow>
             <mi>i</mi>
             <mo>,</mo>
             <mi>j</mi>
             <mo>,</mo>
             <mi>k</mi>
            </mrow>
           </msub>
          </mrow>
          <mo>=</mo>
          <msub>
           <mi>c</mi>
           <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
           </mrow>
          </msub>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ℤ</ci>
         <plus></plus>
        </apply>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>m</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <list>
           <ci>i</ci>
           <ci>j</ci>
           <ci>k</ci>
          </list>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <list>
          <ci>j</ci>
          <ci>k</ci>
         </list>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <eq></eq>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <ci>j</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <list>
            <ci>i</ci>
            <ci>j</ci>
            <ci>k</ci>
           </list>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <list>
           <ci>i</ci>
           <ci>k</ci>
          </list>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <ci>k</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <list>
            <ci>i</ci>
            <ci>j</ci>
            <ci>k</ci>
           </list>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <list>
           <ci>i</ci>
           <ci>j</ci>
          </list>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\{wx\ :\ x\in{\mathbb{Z}}_{+}^{l\times m\times n}\,,\ \sum_{i}x_{i,j,k}=a_%
{j,k}\,,\ \sum_{j}x_{i,j,k}=b_{i,k}\,,\ \sum_{k}x_{i,j,k}=c_{i,j}\}\ ,
  </annotation>
 </semantics>
</math>

</p>

<p>with 

<math display="inline" id="Graver_basis:20">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>j</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <list>
     <ci>j</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{j,k}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Graver_basis:21">
 <semantics>
  <msub>
   <mi>b</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <list>
     <ci>i</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i,k}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Graver_basis:22">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <list>
     <ci>i</ci>
     <ci>j</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i,j}
  </annotation>
 </semantics>
</math>

 nonnegative integers (whose maximum value implicitly bounds all variables from above). Denote by 

<math display="inline" id="Graver_basis:23">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 the (<em>lm</em> + <em>ln</em> + <em>mn</em>) × (<em>lmn</em>) defining matrix of this system. Note that this matrix is generally <em>not</em> <a href="totally_unimodular" title="wikilink">totally unimodular</a>. Nonetheless, it was shown in <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> that for every fixed <em>l</em> and <em>m</em>, its Graver basis 

<math display="inline" id="Graver_basis:24">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(A)
  </annotation>
 </semantics>
</math>

 can be computed in time which is polynomial in <em>n</em>. The results mentioned above allow then to solve this problem in polynomial time for fixed <em>l</em> and <em>m</em> and variable <em>n</em>. Note that if only one side <em>l</em> of the table is fixed (even with <em>l</em> = 3) while both <em>m</em> and <em>n</em> are variable, then the problem is NP hard, as shown in.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> More generally, similar positive results hold for higher-dimensional table problems (introduced in <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a>): for every fixed <em>d</em> and 

<math display="inline" id="Graver_basis:25">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mi>d</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>d</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1},\dots,m_{d}
  </annotation>
 </semantics>
</math>

, (non)-linear optimization over 

<math display="inline" id="Graver_basis:26">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo>×</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>×</mo>
   <msub>
    <mi>m</mi>
    <mi>d</mi>
   </msub>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>d</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}\times\cdots\times m_{d}\times n
  </annotation>
 </semantics>
</math>

 tables with variable n and prescribed margins can be done in polynomial time. This has further applications to entry security problems and privacy in statistical databases.</p>
<h3 id="multi-commodity-flows">Multi-commodity flows</h3>

<p>Consider the <em>integer</em> <a href="multi-commodity_flow_problem" title="wikilink">multi-commodity flow problem</a> of routing <em>k</em> types of integer commodities from <em>m</em> suppliers to <em>n</em> consumers subject to supply, consumption, and capacity constraints, so as to minimize the sum of linear or congestion-dependent convex costs on the arcs. Then for every fixed <em>k</em> and <em>m</em>, the Graver basis of the defining system can be computed and the resulting separable-convex objective function minimized in time which is polynomial in the variable number <em>n</em> of consumers and in the rest of the data.</p>
<h3 id="other-applications">Other applications</h3>

<p>The many applications of the algorithmic theory of Graver bases also include stochastic integer programming,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> <em>N</em>-fold integer programming, <em>N</em>-fold 4-block decomposable integer programming,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> clustering, and disclosure control in statistical databases. In some of these applications the relevant Graver basis <em>cannot</em> be computed in polynomial time, but can be accessed in an indirect way that allows to use it in polynomial time.</p>
<h2 id="universality-and-parametrization">Universality and parametrization</h2>

<p>It was shown in <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> that every (bounded) integer programming problem is precisely equivalent to the 3 × <em>m</em> × <em>n</em> table problem discussed above for some <em>m</em> and <em>n</em> and some line sums. Thus, such 3 × <em>m</em> × <em>n</em> table problems are <strong>universal</strong> for integer programming. Moreover, for each fixed <em>m</em>, the resulting class of integer programs can be solved in polynomial time by the iterative Graver basis method described above. So the table width <em>m</em> provides a <strong>parametrization</strong> of all integer programming problems.</p>
<h2 id="hierarchy-of-approximations-for-integer-programming">Hierarchy of approximations for integer programming</h2>

<p>Denote by 

<math display="inline" id="Graver_basis:27">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(m,n)
  </annotation>
 </semantics>
</math>

 the Graver basis of the matrix 

<math display="inline" id="Graver_basis:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 defining the universal 3 × <em>m</em> × <em>n</em> table problem discussed above. The elements of 

<math display="inline" id="Graver_basis:29">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(m,n)
  </annotation>
 </semantics>
</math>

 are 3 × <em>m</em> × <em>n</em> tables with all line sums equal to 0. The <em>type</em> of such a table is the number of its nonzero 3 × <em>m</em> <em>layers</em>. It turns out that there is a finite <em>Graver complexity function</em> <em>g</em>(<em>m</em>) such that for any <em>n</em>, the type of any element of the Graver basis 

<math display="inline" id="Graver_basis:30">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(m,n)
  </annotation>
 </semantics>
</math>

 is at most <em>g</em>(<em>m</em>). It follows that the Graver basis 

<math display="inline" id="Graver_basis:31">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(m,n)
  </annotation>
 </semantics>
</math>

 is the union of the 

<math display="inline" id="Graver_basis:32">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n\choose g(m)}
  </annotation>
 </semantics>
</math>

 suitably embedded copies of the Graver basis 

<math display="inline" id="Graver_basis:33">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>m</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(m,g(m))
  </annotation>
 </semantics>
</math>

. To approximately solve in practice an arbitrary integer programming problem, proceed as follows. First embed it in a suitable 3 × <em>m</em> × <em>n</em> table problem as enabled by the universality noted above. Now apply the following hierarchy of approximations of 

<math display="inline" id="Graver_basis:34">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(m,n)
  </annotation>
 </semantics>
</math>

. At level <em>k</em> of this hierarchy, let 

<math display="inline" id="Graver_basis:35">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>k</ci>
    </apply>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{k}(m,n)
  </annotation>
 </semantics>
</math>

 be the subset of 

<math display="inline" id="Graver_basis:36">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(m,n)
  </annotation>
 </semantics>
</math>

 consisting only of those elements of type at most <em>k</em>; use this approximation 

<math display="inline" id="Graver_basis:37">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>k</ci>
    </apply>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{k}(m,n)
  </annotation>
 </semantics>
</math>

 in the iterative algorithm as long as possible to obtain as good as possible feasible point for the integer programming problem embedded in the 3 × <em>m</em> × <em>n</em> table problem; if the objective function value of this point is satisfactory (say, as compared to the value of the <a href="linear_programming_relaxation" title="wikilink">linear programming relaxation</a>), then use this point; otherwise increment <em>k</em> and proceed to the next level of the hierarchy. It can be shown <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> that for any fixed level <em>k</em>, the approximation 

<math display="inline" id="Graver_basis:38">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>k</ci>
    </apply>
    <interval closure="open">
     <ci>m</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{k}(m,n)
  </annotation>
 </semantics>
</math>

 of the Graver basis has polynomial cardinality 

<math display="inline" id="Graver_basis:39">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msup>
      <mi>m</mi>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <msup>
      <mi>n</mi>
      <mi>k</mi>
     </msup>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(m^{g(k)}n^{k}\right)
  </annotation>
 </semantics>
</math>

 and can be computed in that much time.</p>
<h2 id="fixed-parameter-tractability-from-polynomial-to-cubic-time-complexity">Fixed parameter tractability: from polynomial to cubic time complexity</h2>

<p>The time complexity of solving some of the applications discussed above, such as multi-dimensional table problems, multicommodity flow problems, and <em>N</em>-fold integer programming problems, is dominated by the cardinality of the relevant Graver basis, which is a polynomial 

<math display="inline" id="Graver_basis:40">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>n</mi>
     <mi>g</mi>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(n^{g}\right)
  </annotation>
 </semantics>
</math>

 with typically large degree <em>g</em> which is a suitable Graver complexity of the system. In <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> a much faster algorithm is presented, which finds at each iteration the best improvement <em>x</em> + <em>qg</em> with <em>q</em> positive integer and <em>g</em> element in 

<math display="inline" id="Graver_basis:41">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(A)
  </annotation>
 </semantics>
</math>

 <em>without explicitly constructing the Graver basis</em>, in cubic time 

<math display="inline" id="Graver_basis:42">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(n^{3}\right)
  </annotation>
 </semantics>
</math>

 regardless of the system. In the terminology of <a href="parameterized_complexity" title="wikilink">parameterized complexity</a>, this implies that all these problems suitably parameterized, and in particular <em>l</em> × <em>m</em> × <em>n</em> table problems parametrized by <em>l</em> and <em>m</em>, are <strong>fixed parameter tractable</strong>.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Linear_programming" title="wikilink">Category:Linear programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Bernd_Sturmfels" title="wikilink"><code>Bernd</code> <code>Sturmfels</code></a><code>,</code> <em><code>Gröbner</code> <code>Bases</code> <code>and</code> <code>Convex</code> <code>Polytopes</code></em><code>,</code> <a href="American_Mathematical_Society" title="wikilink"><code>American</code> <code>Mathematical</code> <code>Society</code></a><code>,</code> <code>xii+162</code> <code>pp.,</code> <code>1996</code><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://ie.technion.ac.il/~onn"><code>Shmuel</code> <code>onn</code></a><code>:</code> <code>[</code><a href="http://books.google.co.il/books?id=yXvfDzHo-WsC&amp;printsec"><code>http://books.google.co.il/books?id=yXvfDzHo-WsC&amp;printsec;</code></a><code>;=frontcover&amp;dq;=inauthor:%22Shmuel+Onn%22&amp;hl;=en&amp;ei;=ccjLToGAPMXLhAep-ZznDQ&amp;sa;=X&amp;oi;=book_result&amp;ct;=result&amp;redir;_esc=y#v=onepage&amp;q;=inauthor%3A%22Shmuel%20Onn%22&amp;f;=false</code> <em><code>Nonlinear</code> <code>Discrete</code> <code>Optimization</code></em><code>],</code> <a href="European_Mathematical_Society" title="wikilink"><code>European</code> <code>Mathematical</code> <code>Society</code></a><code>,</code> <code>x+137</code> <code>pp.,</code> <code>2010</code><a href="#fnref2">↩</a></li>
<li id="fn3"><code>Shmuel</code> <code>Onn:</code> <a href="http://www.msri.org/web/msri/online-videos/-/video/showSpeaker/200002593"><code>Linear</code> <code>and</code> <code>nonlinear</code> <code>integer</code> <code>optimization</code></a><code>,</code> <code>Online</code> <code>Video</code> <code>Lecture</code> <code>Series,</code> <a href="Mathematical_Sciences_Research_Institute" title="wikilink"><code>Mathematical</code> <code>Sciences</code> <code>Research</code> <code>Institute</code></a><code>,</code> <code>Berkeley,</code> <code>2010</code><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="Alexander_Schrijver" title="wikilink">Alexander Schrijver</a>: <em>Theory of Linear and Integer Programming</em>, Wiley, xii+471 pp., 1986<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Raymond Hemmecke, Shmuel Onn, Robert Weismantel: A polynomial oracle-time algorithm for convex integer minimization, Mathematical Programming 126:97–117, 2011<a href="#fnref6">↩</a></li>
<li id="fn7">Yuri V. Matiyasevich: <em>Hilbert's Tenth Problem</em>, MIT Press, xxiv+264 pp., 1993<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="Jesús_A._De_Loera" title="wikilink">Jesús A. De Loera</a>, Raymond Hemmecke, Shmuel Onn, Robert Weismantel: <em>N</em>-fold integer programming, Discrete Optimization, 5:231–241, 2008<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="Jesús_A._De_Loera" title="wikilink">Jesús A. De Loera</a>, Shmuel Onn: The complexity of three-way statistical tables, SIAM Journal on Computing, 33:819–836, 2004<a href="#fnref9">↩</a></li>
<li id="fn10">Theodore S. Motzkin: The multi-index transportation problem, Bulletin of the American Mathematical Society 58:494, 1952<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12">Raymond Hemmecke, Matthias Köppe, Robert Weismantel: A polynomial-time algorithm for optimizing over <em>N</em>-fold 4-block decomposable integer programs, IPCO 14, 2010<a href="#fnref12">↩</a></li>
<li id="fn13">Jesus A. De Loera, Shmuel Onn: All linear and integer programs are slim 3-way transportation programs, SIAM Journal on Optimization, 17:806–821, 2006<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">Raymond Hemmecke, Shmuel Onn, Lyubov Romanchuk: <em>N</em>-fold integer programming in cubic time, Mathematical Programming, 137:325–341, 2013<a href="#fnref15">↩</a></li>
</ol>
</section>
</ref></hr></body>
</html>
