   Automatic basis function construction      Automatic basis function construction   Automatic basis function construction (or basis discovery ) is the method of looking for a set of task-independent basis functions that map the state space to a lower-dimensional embedding, while still representing the value function accurately. Automatic basis construction is independent of prior knowledge of the domain, which allows it to perform well where expert-constructed basis functions are difficult or impossible to create.  Motivation  In reinforcement learning (RL), most real-world Markov Decision Process (MDP) problems have large or continuous state spaces, which typically require some sort of approximation to be represented efficiently.  Linear function approximators 1 (LFAs) are widely adopted for their low theoretical complexity. Two subproblems needs to be solved for better approximation: weight optimization and basis construction. To solve the second problem, one way is to design special basis functions. Those basis functions work well in specific tasks but are significantly restricted to domains. Thus constructing basis construction functions automatically is preferred for broader applications.  Problem definition  A Markov decision process with finite state space and fixed policy is defined with a 4-tuple    s  ,  p  ,  γ  ,  r     s  p  γ  r    {s,p,\gamma,r}   , which includes the finite state space    S  =   1  ,  2  ,  …  ,  s       S   1  2  normal-…  s     S={{1,2,\ldots,s}}   , the reward function   r   r   r   , discount factor    γ  ∈   [  0  ,  1  )       γ   0  1     \gamma\in[0,1)   , and the transition model   P   P   P   .  Bellman equation is defined as:       v  =   r  +   γ  P  v     .      v    r    γ  P  v      v=r+\gamma Pv.\,     When the number of elements in   S   S   S   is small,   v   v   v   is usually maintained as tabular form. While   S   S   S   grows too large for this kind of representation.   v   v   v   is commonly being approximated via a linear combination of basis function    Φ  =    ϕ  1   ,   ϕ  2   ,  …  ,   ϕ  n        normal-Φ    subscript  ϕ  1    subscript  ϕ  2   normal-…   subscript  ϕ  n      \Phi={\phi_{1},\phi_{2},\ldots,\phi_{n}}   , 2 so that we have:      v  ≈   v  ^   =    ∑   i  =  1   n     θ  n    ϕ  n           v   normal-^  v          superscript   subscript     i  1    n      subscript  θ  n    subscript  ϕ  n        v\approx\hat{v}=\sum_{i=1}^{n}\theta_{n}\phi_{n}     Here   Φ   normal-Φ   \Phi   is a     |  S  |   ×  n        S   n    |S|\times n   matrix in which every row contains a feature vector for corresponding row,   θ   θ   \theta   is a weight vector with n parameters and usually    n  ≪   |  s  |      much-less-than  n    s     n\ll|s|   .  Basis construction looks for ways to automatically construct better basis function   Φ   normal-Φ   \Phi   which can represent the value function well. A good construction method should have the following characteristics:   Small error bounds between the estimate and real value function  Form orthogonal basis in the value function space  Converge to stationary value function fast   Popular methods  Proto-value basis  In this approach, Mahadevan analyzes the connectivity graph between states to determine a set of basis functions. 3  The normalized graph Laplacian is defined as:      L  =   I  -    D   -   1  2     W   D   -   1  2           L    I     superscript  D      1  2     W   superscript  D      1  2         L=I-D^{-\frac{1}{2}}WD^{-\frac{1}{2}}     Here W is an adjacency matrix which represents the states of fixed policy MDP which forms an undirected graph (N,E). D is a diagonal matrix related to nodes' degrees.  In discrete state space, the adjacency matrix   W   W   W   could be constructed by simply checking whether two states are connected, and D could be calculated by summing up every row of W. In continuous state space, we could take random walk Laplacian of W.  This spectral framework can be used for value function approximation(VFA). Given the fixed policy, the edge weights are determined by corresponding states' transition probability. To get smooth value approximation, diffusion wavelets are used. 4  Krylov basis  Krylov basis construction uses the actual transition matrix instead of random walk Laplacian. The assumption of this method is that transition model P and reward r are available.  The vectors in Neumann series are denoted as     y  i   =    P  i   r        subscript  y  i      superscript  P  i   r     y_{i}=P^{i}r   for all    i  ∈   [  0  ,   i  n  f  t  y   )       i   0    i  n  f  t  y      i\in[0,infty)   . It shows that Krylov space spanned by     y  0   ,   y  1   ,  …  ,   y   m  -  1        subscript  y  0    subscript  y  1   normal-…   subscript  y    m  1      y_{0},y_{1},\ldots,y_{m-1}   is enough to represent any value function, 5 and m is the degree of minimal polynomial of    (   I  -   γ  P    )      I    γ  P     (I-\gamma P)   .  Suppose the minimal polynomial is     p   (  A  )    =    1   α  0      ∑   i  =  0    m  -  1      α   i  +  1     A  i            p  A       1   subscript  α  0      superscript   subscript     i  0      m  1       subscript  α    i  1     superscript  A  i        p(A)=\frac{1}{\alpha_{0}}\sum_{i=0}^{m-1}\alpha_{i+1}A^{i}   , and we have     B  A   =  I        B  A   I    BA=I   , the value function can be written as:       v  =   B  r   =    1   α  0      ∑   i  =  0    m  -  1      α   i  +  1      (   I  -   γ  P    )   i   r     =    ∑   i  =  0    m  -  1      α   i  +  1     β  i    y  i      .        v    B  r            1   subscript  α  0      superscript   subscript     i  0      m  1       subscript  α    i  1     superscript    I    γ  P    i   r            superscript   subscript     i  0      m  1       subscript  α    i  1     subscript  β  i    subscript  y  i        v=Br=\frac{1}{\alpha_{0}}\sum_{i=0}^{m-1}\alpha_{i+1}(I-\gamma P)^{i}r=\sum_{i%
 =0}^{m-1}\alpha_{i+1}\beta_{i}y_{i}.    6   Algorithm Augmented Krylov Method 7        z  1   ,   z  2   ,  …  ,   z  k       subscript  z  1    subscript  z  2   normal-…   subscript  z  k     z_{1},z_{2},\ldots,z_{k}   are top real eigenvectors of P       z   k  +  1    :=  r     assign   subscript  z    k  1    r    z_{k+1}:=r     for      i  :=  1   :   (   l  +  k   )      normal-:   assign  i  1     l  k     i:=1:(l+k)    do   if     i  >   k  +  1       i    k  1     i>k+1    then       z  i   :=   P   z   i  -  1        assign   subscript  z  i     P   subscript  z    i  1       z_{i}:=Pz_{i-1}   ;   end if   for      j  :=  1   :   (   i  -  1   )      normal-:   assign  j  1     i  1     j:=1:(i-1)    do       ∥   z  i   ∥   ≈  0       norm   subscript  z  i    0    \parallel z_{i}\parallel\approx 0      end for   if     ε  =    r  +   γ  P   v  ^     -   v  ^    =    r  +   γ  P  Φ  θ    -   Φ  θ          ε      r    γ  P   normal-^  v      normal-^  v             r    γ  P  normal-Φ  θ      normal-Φ  θ       \varepsilon=r+\gamma P\hat{v}-\hat{v}=r+\gamma P\Phi\theta-\Phi\theta    then   break ;    end if     end for   k: number of eigenvectors in basis  l: total number of vectors     Bellman error basis  Bellman error(or BEBFs) is defined as     ϕ  1   =  r       subscript  ϕ  1   r    \phi_{1}=r   .  Loosely speaking, Bellman error points towards the optimal value function. 8 The sequence of BEBF form a basis space which is orthogonal to the real value function space; thus with sufficient number of BEBFs, any value function can be represented exactly.   Algorithm BEBF  stage stage i=1,    i  ∈   [  2  ,  N  ]       i   2  N     i\in[2,N]   ;  stage    θ  i     subscript  θ  i    \theta_{i}     compute the weight vector    Φ  i     subscript  normal-Φ  i    \Phi_{i}   according to current basis function    ε  =    r  +   γ  P   Φ  i    θ  i     -    Φ  i    θ  i         ε      r    γ  P   subscript  normal-Φ  i    subscript  θ  i        subscript  normal-Φ  i    subscript  θ  i       \varepsilon=r+\gamma P\Phi_{i}\theta_{i}-\Phi_{i}\theta_{i}   ;  compute new bellman error by     Φ   i  +  1    =   [   Φ  i   :  ε  ]      fragments   subscript  normal-Φ    i  1      fragments  normal-[   subscript  normal-Φ  i   normal-:  ε  normal-]     \Phi_{i+1}=[\Phi_{i}:\varepsilon]   ;  add bellman error to form new basis function    P  -   P  *       P   superscript  P      P-P^{*}   ;    N represents the number of iterations till convergence.  ":" means juxtaposing matrices or vectors.     Bellman average reward bases  Bellman Average Reward Bases(or BARBs) 9 is similar to Krylov Bases, but the reward function is being dilated by the average adjusted transition matrix    P  *     superscript  P     P^{*}   . Here   γ   γ   \gamma   can be calculated by many methods in. 10  BARBs converges faster than BEBFs and Krylov when     P  *   r       superscript  P    r    P^{*}r   is close to 1.   Algorithm BARBs  stage stage i=1,    i  ∈   [  2  ,  N  ]       i   2  N     i\in[2,N]   ;  stage    θ  i     subscript  θ  i    \theta_{i}     compute the weight vector    Φ  i     subscript  normal-Φ  i    \Phi_{i}   according to current basis function     :    ϕ   i  +  1    =     r  -    P  *   r    +   P   Φ  i    θ  i     -    Φ  i    θ  i         normal-:  absent     subscript  ϕ    i  1          r     superscript  P    r      P   subscript  normal-Φ  i    subscript  θ  i        subscript  normal-Φ  i    subscript  θ  i        :\phi_{i+1}=r-P^{*}r+P\Phi_{i}\theta_{i}-\Phi_{i}\theta_{i}   ;  compute new basis     Φ   i  +  1    =   [   Φ  i   :   ϕ   i  +  1    ]      fragments   subscript  normal-Φ    i  1      fragments  normal-[   subscript  normal-Φ  i   normal-:   subscript  ϕ    i  1    normal-]     \Phi_{i+1}=[\Phi_{i}:\phi_{i+1}]   , and add it to form new bases matrix   γ   γ   \gamma   ;    N represents the number of iterations till convergence.  ":" means juxtaposing matrices or vectors.     Discussion and analysis  There are two principal types of basis construction methods.  The first type of methods are reward-sensitive, like Krylov and BEBFs, they dilate the reward function geometrically through transition matrix. However, when discount factor   γ   γ   \gamma   approaches to 1, Krylov and BEBFs converge slowly. This is because the error Krylov based methods are restricted by Chebyshev polynomial bound. 11 To solve this problem, some methods, like BARBs are proposed. BARBs is an incremental variant of Drazin bases, and converges faster than Krylov and BEBFs when $\gamma$ becomes large.  Another one  is reward-insensitive proto value basis function derived from graph Lapalacian. This method uses graph information, but the construction of adjacency matrix makes this method hard to analyze. 12  See also   Dynamic programming  Bellman equation  Optimal control   References  External links   1 UMASS ALL lab   "  Category:Optimal decisions  Category:Dynamic programming  Category:Stochastic control     Keller,Philipp;Mannor,Shie;Precup,Doina. (2006) Automatic Basis Function Construction for Approximate Dynamic Programming and Reinforcement Learning. Proceedings of the 23rd International Conference on Machine Learning, Pittsburgh, PA. ↩  Richard S. Sutton and Andrew G. Barto. Reinforcement Learning: An Introduction.(1998) MIT Press, Cambridge, MA, chapter 8 ↩   Mahadevan,Sridhar;Maggioni,Mauro. (2005) Value function approximation with diffusion wavelets and Laplacian eigenfuctions. Proceedings of Advances in Neural Information Processing Systems. ↩  Ilse C. F. Ipsen and Carl D. Meyer. The idea behind Krylov methods. American Mathematical Monthly, 105(10):889–899, 1998. ↩   M. Petrik. An analysis of Laplacian methods for value function approximation in MDPs. In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), pages 2574–2579, 2007 ↩  R. Parr, C. Painter-Wakefield, L.-H. Li, and M. Littman. Analyzing feature generation for value-function approximation. In ICML’07, 2007. ↩  S. Mahadevan and B. Liu. Basis construction from power series expansions of value functions. In NIPS’10, 2010 ↩  William J. Stewart. Numerical methods for computing stationary distributions of finite irreducible markov chains. In Advances in Computational Probability. Kluwer Academic Publishers, 1997. ↩  M. Petrik. An analysis of Laplacian methods for value function approximation in MDPs.In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), pages 2574–2579, 2007. ↩      