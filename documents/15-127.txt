   Fuzzy extractor      Fuzzy extractor   Fuzzy extractors convert biometric data into random strings, which makes it possible to apply cryptographic techniques for biometric security. They are used to encrypt and authenticate users records, with biometric inputs as a key. Historically, the first biometric system of this kind was designed by Juels and Wattenberg and was called "Fuzzy commitment", where the cryptographic key is decommitted using biometric data. "Fuzzy", in that context, implies that the value close to the original one can extract the committed value. Later, Juels and Sudan came up with Fuzzy vault schemes which are order invariant for the fuzzy commitment scheme but uses a Reedâ€“Solomon  code . Codeword is evaluated by polynomial and the secret message is inserted as the coefficients of the polynomial. The polynomial is evaluated for different values of a set of features of the biometric data. So Fuzzy commitment and Fuzzy Vault were per-cursor to Fuzzy extractors. Fuzzy extractor is a biometric tool to authenticate a user using its own biometric template as a key. They extract uniform and random string   R   R   R   from its input   w   w   w   that has tolerance for noise. If the input changes to    w  â€²     superscript  w  normal-â€²    w^{\prime}   but is still close to   w   w   w   , the string   R   R   R   can still be re-constructed. When   R   R   R   is used first time to re-construct, it outputs a helper string   P   P   P   which can be made public without compromising the security of   R   R   R   (used for encryption and authentication key) and   P   P   P   (helper string) is stored to recover   R   R   R   . They remain secure even when the adversary modifies   P   P   P   (key agreement between a user and a server based only on a biometric input). This article is based on the papers "Fuzzy Extractors: A Brief Survey of Results from 2004 to 2006" and "Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data" by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith  Motivation  As fuzzy extractors deal with how to generate strong keys from Biometrics and other Noisy Data, it applies cryptography paradigms to biometric data and that means (1) Make little assumptions about the biometric data (these data comes from variety of sources and don't want adversary to exploit that so it is best to assume the input is unpredictable) (2) Apply cryptographic application techniques to the input. (for that fuzzy extractor converts biometric data into secret, uniformly random and reliably reproducible random string). According to "Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data" paper by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith â€“ these techniques also have other broader applications (when noisy inputs are used) such as human memory , images used as passwords, keys from quantum channel. Based on the Differential Privacy paper by Cynthia Dwork (ICALP 2006) â€“ fuzzy extractors have application in the proof of impossibility of strong notions of privacy for statistical databases.  Basic definitions  Predictability  Predictability indicates probability that adversary can guess a secret key. Mathematically speaking, the predictability of a random variable   A   A   A   is     max  a   P   [  A  =  a  ]      fragments   subscript   normal-a   P   fragments  normal-[  A   a  normal-]     \max_{\mathrm{a}}P[A=a]   . For example, if pair of random variable   A   A   A   and   B   B   B   , if the adversary knows   b   b   b   of   B   B   B   , then predictability of   A   A   A   will be     max  a   P   [  A  =  a  |  B  =  b  ]      fragments   subscript   normal-a   P   fragments  normal-[  A   a  normal-|  B   b  normal-]     \max_{\mathrm{a}}P[A=a|B=b]   . So, Adversary can predict   A   A   A   with     E   b  â†  B     [   max  a   P   [  A  =  a  |  B  =  b  ]   ]      fragments   subscript  E   normal-â†  b  B     fragments  normal-[   subscript   normal-a   P   fragments  normal-[  A   a  normal-|  B   b  normal-]   normal-]     E_{b\leftarrow B}[\max_{\mathrm{a}}P[A=a|B=b]]   . Taking average over   B   B   B   as it is not under adversary control, but since knowing   b   b   b   makes   A   A   A   prediction adversarial, taking the worst case over   A   A   A   .  Min-entropy  Min-entropy indicates worst-case entropy. Mathematically speaking, it is defined as     H  âˆž    (  A  )   =  -  log   (   max  a   P   [  A  =  a  ]   )      fragments   subscript  H     fragments  normal-(  A  normal-)       fragments  normal-(   subscript   normal-a   P   fragments  normal-[  A   a  normal-]   normal-)     H_{\infty}(A)=-\log(\max_{\mathrm{a}}P[A=a])   . Random variables with min-entropy at least   m   m   m   is called   m   m   m   -source.  Statistical distance  Statistical distance is measure of distinguishability. Mathematically speaking, it is between two probability distributions   A   A   A   and   B   B   B   is,    S  D   [  A  ,  B  ]       S  D   A  B     SD[A,B]   =     1  2    âˆ‘  v   |  P   [  A  =  v  ]   -  P   [  B  =  v  ]   |     fragments    1  2    subscript   normal-v   normal-|  P   fragments  normal-[  A   v  normal-]    P   fragments  normal-[  B   v  normal-]   normal-|    \frac{1}{2}\sum_{\mathrm{v}}|P[A=v]-P[B=v]|   . In any system if   A   A   A   is replaced by   B   B   B   , it will behave as original system with probability at least    1  -   S  D   [  A  ,  B  ]        1    S  D   A  B      1-SD[A,B]   .  Definition 1 (strong extractor)  Set   M   M   M   is strong randomness extractor . Randomized function Ext    M  â†’    {  0  ,  1  }   l      normal-â†’  M   superscript   0  1   l     M\rightarrow\{0,1\}^{l}   with randomness of length   r   r   r   is an    (  m  ,  l  ,  Ïµ  )     m  l  Ïµ    (m,l,\epsilon)   -strong extractor if for all   m   m   m   -sources (Random variables with min-entropy at least   m   m   m   is called   m   m   m   -source)   W   W   W   on      M   (   E  x  t   (  W  ;  I  )    ,  I  )     â‰ˆ  Ïµ    (   U  l   ,   U  r   )    ,      subscript   Ïµ     M     E  x  t   W  I    I      subscript  U  l    subscript  U  r      M(Ext(W;I),I)\approx_{\epsilon}(U_{l},U_{r}),   where    I  =   U  r       I   subscript  U  r     I=U_{r}   is independent of   W   W   W   . Output of the extractor is a key generated from    w  â†  W     normal-â†  w  W    w\leftarrow W   with the seed    i  â†  I     normal-â†  i  I    i\leftarrow I   . It behaves independent of other parts of the system with the probability of    1  -  Ïµ      1  Ïµ    1-\epsilon   . Strong extractors can extract at most    l  =    m  -   2  l  o  g   1  Ïµ     +   O   (  1  )         l      m    2  l  o  g    1  Ïµ       O  1      l=m-2log\frac{1}{\epsilon}+O(1)   bits from arbitrary   m   m   m   -source.  Secure sketch  Secure sketch makes it possible to reconstruct noisy input, so if the input is   w   w   w   and sketch is   s   s   s   , given   s   s   s   and value    w  â€²     superscript  w  normal-â€²    w^{\prime}   close to   w   w   w   , it is possible to recover   w   w   w   . But sketch   s   s   s   doesn't give much information about   w   w   w   , so it is secure. If   ð•„   ð•„   \mathbb{M}   is a metric space with distance function dis. Secure sketch recovers string    w  âˆˆ  ð•„      w  ð•„    w\in\mathbb{M}   from any close string     w  â€²   âˆˆ  ð•„       superscript  w  normal-â€²   ð•„    w^{\prime}\in\mathbb{M}   without disclosing   w   w   w   .  Definition 2 (secure sketch)  An    (  m  ,   m  ~   ,  t  )     m   normal-~  m   t    (m,\tilde{m},t)   secure sketch is a pair of efficient randomized procedures (SS â€“ Sketch, Rec â€“ Recover) such that â€“ (1) The sketching procedure SS on input    w  âˆˆ  ð•„      w  ð•„    w\in\mathbb{M}   returns a string    s  âˆˆ    {  0  ,  1  }   *       s   superscript   0  1       s\in{\{0,1\}^{*}}   . The recovery procedure Rec takes an element     w  â€²   âˆˆ  ð•„       superscript  w  normal-â€²   ð•„    w^{\prime}\in\mathbb{M}   and    s  âˆˆ    {  0  ,  1  }   *       s   superscript   0  1       s\in{\{0,1\}^{*}}   . (2) Correctness: If     d  i  s   (  w  ,   w  â€²   )    â‰¤  t        d  i  s   w   superscript  w  normal-â€²     t    dis(w,w^{\prime})\leq t   then     R  e  c   (   w  â€²   ,   S  S   (  w  )    )    =  w        R  e  c    superscript  w  normal-â€²     S  S  w     w    Rec(w^{\prime},SS(w))=w   . (3) Security: For any   m   m   m   -source over   M   M   M   , the min-entropy of   W   W   W   given   s   s   s   is high: for any    (  W  ,  E  )     W  E    (W,E)   , if      H  ~   âˆž    (  W  |  E  )   â‰¥  m     fragments   subscript   normal-~  H      fragments  normal-(  W  normal-|  E  normal-)    m    \tilde{H}_{\mathrm{\infty}}(W|E)\geq m   , then      H  ~   âˆž    (  W  |  S  S   (  W  )   ,  E  )   â‰¥   m  ~      fragments   subscript   normal-~  H      fragments  normal-(  W  normal-|  S  S   fragments  normal-(  W  normal-)   normal-,  E  normal-)     normal-~  m     \tilde{H}_{\mathrm{\infty}}(W|SS(W),E)\geq\tilde{m}   .  Fuzzy extractor  Fuzzy extractors do not recover the original input but generate string   R   R   R   (which is close to uniform) from   w   w   w   and its subsequent reproduction (using helper string   P   P   P   ) given any    w  â€²     superscript  w  normal-â€²    w^{\prime}   close to   w   w   w   . Strong extractors are a special case of fuzzy extractors when   t   t   t   = 0 and    P  =  I      P  I    P=I   .  Definition 3 (fuzzy extractor)  An    (  m  ,  l  ,  t  ,  Ïµ  )     m  l  t  Ïµ    (m,l,t,\epsilon)   fuzzy extractor is a pair of efficient randomized procedures (Gen â€“ Generate and Rep â€“ Reproduce) such that: (1) Gen, given    w  âˆˆ  ð•„      w  ð•„    w\in\mathbb{M}   , outputs an extracted string    R  âˆˆ    {  0  ,  1  }   l       R   superscript   0  1   l     R\in{\mathbb{\{}0,1\}^{l}}   and a helper string    P  âˆˆ    {  0  ,  1  }   *       P   superscript   0  1       P\in{\mathbb{\{}0,1\}^{*}}   . (2) Correctness: If     d  i  s   (  w  ,   w  â€²   )    â‰¤  t        d  i  s   w   superscript  w  normal-â€²     t    dis(w,w^{\prime})\leq t   and     (  R  ,  P  )   â†   G  e  n   (  w  )       normal-â†   R  P     G  e  n  w     (R,P)\leftarrow Gen(w)   , then     R  e  p   (   w  â€²   ,  P  )    =  R        R  e  p    superscript  w  normal-â€²   P    R    Rep(w^{\prime},P)=R   . (3) Security: For all m-sources   W   W   W   over   M   M   M   , the string   R   R   R   is nearly uniform even given   P   P   P   , So      H  ~   âˆž    (  W  |  E  )   â‰¥  m     fragments   subscript   normal-~  H      fragments  normal-(  W  normal-|  E  normal-)    m    \tilde{H}_{\mathrm{\infty}}(W|E)\geq m   , then     (  R  ,  P  ,  E  )   â‰ˆ   (   U  l   ,  P  ,  E  )        R  P  E     subscript  U  normal-l   P  E     (R,P,E)\approx(U_{\mathrm{l}},P,E)   .  So Fuzzy extractors output almost uniform random bits which is prerequisite for using cryptographic applications (in terms of secret keys). Since output bits are slightly non-uniform, it can decrease security, but not more than the distance   Ïµ   Ïµ   \epsilon   from the uniform and as long as that distance is sufficiently small â€“ security still remains robust.  Secure sketches and fuzzy extractors  Secure sketches can be used to construct fuzzy extractors. Like applying SS to   w   w   w   to obtain   s   s   s   and strong extractor Ext with randomness   x   x   x   to   w   w   w   to get   R   R   R   .    (  s  ,  x  )     s  x    (s,x)   can be stored as helper string   P   P   P   .   R   R   R   can be reproduced by    w  â€²     superscript  w  normal-â€²    w^{\prime}   and    P  =   (  s  ,  x  )       P   s  x     P=(s,x)   .    R  e  c   (   w  â€²   ,  s  )       R  e  c    superscript  w  normal-â€²   s     Rec(w^{\prime},s)   can recover   w   w   w   and    E  x  t   (  w  ,  x  )       E  x  t   w  x     Ext(w,x)   can reproduce   R   R   R   . Following Lemma formalize this.  Lemma 1 (fuzzy extractors from sketches)  Assume (SS,Rec) is an    (  M  ,  m  ,   m  ~   ,  t  )     M  m   normal-~  m   t    (M,m,\tilde{m},t)   secure sketch and let Ext be an average-case    (  n  ,   m  ~   ,  l  ,  Ïµ  )     n   normal-~  m   l  Ïµ    (n,\tilde{m},l,\epsilon)   strong extractor. Then the following (Gen, Rep) is an    (  M  ,  m  ,  l  ,  t  ,  Ïµ  )     M  m  l  t  Ïµ    (M,m,l,t,\epsilon)   fuzzy extractor: (1) Gen      (  w  ,  r  ,  x  )   :     s  e  t  P   =   (   S  S   (  w  ;  r  )    ,  x  )    ,   R  =   E  x  t   (  w  ;  x  )       ,     normal-:   w  r  x    formulae-sequence      s  e  t  P      S  S   w  r    x      R    E  x  t   w  x        (w,r,x):setP=(SS(w;r),x),R=Ext(w;x),   and output    (  R  ,  P  )     R  P    (R,P)   . (2) Rep    (   w  â€²   ,   (  s  ,  x  )   )      superscript  w  normal-â€²    s  x     (w^{\prime},(s,x))   : recover    w  =   R  e  c   (   w  â€²   ,  s  )        w    R  e  c    superscript  w  normal-â€²   s      w=Rec(w^{\prime},s)   and output    R  =   E  x  t   (  w  ;  x  )        R    E  x  t   w  x      R=Ext(w;x)   .  Proof: From the definition of secure sketch (Definition 2),     H  âˆž    (  W  |  S  S   (  W  )   )   â‰¥   m  ~      fragments   subscript  H     fragments  normal-(  W  normal-|  S  S   fragments  normal-(  W  normal-)   normal-)     normal-~  m     H_{\infty}(W|SS(W))\geq\tilde{m}   . And since Ext is an average-case    (  n  ,  m  ,  l  ,  Ïµ  )     n  m  l  Ïµ    (n,m,l,\epsilon)   -strong extractor.      S  D   (   (   E  x  t   (  W  ;  X  )    ,   S  S   (  W  )    ,  X  )   ,   (   U  l   ,   S  S   (  W  )    ,  X  )   )    =   S  D   (   (  R  ,  P  )   ,   (   U  l   ,  P  )   )    â‰¤  Ïµ   .          S  D      E  x  t   W  X      S  S  W   X     subscript  U  l     S  S  W   X       S  D    R  P     subscript  U  l   P          Ïµ     SD((Ext(W;X),SS(W),X),(U_{l},SS(W),X))=SD((R,P),(U_{l},P))\leq\epsilon.     Corollary 1  If (SS,Rec) is an    (  M  ,  m  ,   m  ~   ,  t  )     M  m   normal-~  m   t    (M,m,\tilde{m},t)   â€“ secure sketch and Ext is an    (  n  ,    m  ~   -   l  o  g   (   1  Î´   )     ,  l  ,  Ïµ  )     n     normal-~  m     l  o  g    1  Î´     l  Ïµ    (n,\tilde{m}-log(\frac{1}{\delta}),l,\epsilon)   â€“ strong extractor, then the above construction (Gen,Rep) is a    (  M  ,  m  ,  l  ,  t  ,   Ïµ  +  Î´   )     M  m  l  t    Ïµ  Î´     (M,m,l,t,\epsilon+\delta)   fuzzy extractor.  Reference paper "Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data" by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith (2008) includes many generic combinatorial bounds on secure sketches and fuzzy extractors  Basic constructions  Due to their error tolerant properties, a secure sketches can be treated, analyzed, and constructed like a     (  n  ,  k  ,  d  )   â„±     subscript   n  k  d   â„±    (n,k,d)_{\mathcal{F}}   general error correcting code or     [  n  ,  k  ,  d  ]   â„±     subscript   n  k  d   â„±    [n,k,d]_{\mathcal{F}}   for linear codes, where   n   n   n   is the length of codewords,   k   k   k   is the length of the message to be codded,   d   d   d   is the distance between codewords, and   â„±   â„±   \mathcal{F}   is the alphabet. If    â„±  n     superscript  â„±  n    \mathcal{F}^{n}   is the universe of possible words then it may be possible to find an error correcting code    C  âˆˆ   â„±  n       C   superscript  â„±  n     C\in\mathcal{F}^{n}   that has a unique codeword    c  âˆˆ  C      c  C    c\in C   for every    w  âˆˆ   â„±  n       w   superscript  â„±  n     w\in\mathcal{F}^{n}   and have a Hamming distance of     d  i   s   H  a  m     (  c  ,  w  )    â‰¤    (   d  -  1   )   /  2         d  i   subscript  s    H  a  m     c  w        d  1   2     dis_{Ham}(c,w)\leq(d-1)/2   . The first step for constructing a secure sketch is determining the type of errors that will likely occur and then choosing a distance to measure.  (Figure)  Red is the code-offset construction, blue is the syndrome construction, green represents edit distance and other complex constructions.   Hamming distance constructions  When there is no chance of data being deleted and only being corrupted than the best measurement to use for error correction is Hamming distance. There are two common constructions for correcting Hamming errors depending on whether the code is linear or not. Both constructions start with an error correcting code that has a distance of     2  t   +  1        2  t   1    2t+1   where   t   t   {t}   is the number of tolerated errors.  Code-offset construction  When using a     (  n  ,  k  ,    2  t   +  1   )   â„±     subscript   n  k      2  t   1    â„±    (n,k,2t+1)_{\mathcal{F}}   general code, assign a uniformly random codeword    c  âˆˆ  C      c  C    c\in C   to each   w   w   w   , then let     S  S   (  w  )    =  s  =   w  -  c           S  S  w   s         w  c      SS(w)=s=w-c   which is the shift needed to change   c   c   c   into   w   w   w   . To fix errors in    w  â€²     superscript  w  normal-â€²    w^{\prime}   subtract   s   s   s   from    w  â€²     superscript  w  normal-â€²    w^{\prime}   then correct the errors in the resulting incorrect codeword to get   c   c   c   and finally add   s   s   s   to   c   c   c   to get   w   w   w   . This means     R  e  c   (   w  â€²   ,  s  )    =   s  +   d  e  c   (    w  â€²   -  s   )     =  w          R  e  c    superscript  w  normal-â€²   s      s    d  e  c     superscript  w  normal-â€²   s          w     Rec(w^{\prime},s)=s+dec(w^{\prime}-s)=w   . This construction can achieve the best possible tradeoff between error tolerance and entropy loss when    â„±  â‰¥  n      â„±  n    \mathcal{F}\geq n   and a Reedâ€“Solomon code is used resulting in an entropy loss of    2  t   log   (  â„±  )        2  t    â„±     2t\log(\mathcal{F})   , and the only way to improve upon this is to find a code better than Reedâ€“Solomon.  Syndrome construction  When using a     [  n  ,  k  ,    2  t   +  1   ]   â„±     subscript   n  k      2  t   1    â„±    [n,k,2t+1]_{\mathcal{F}}   linear code let the     S  S   (  w  )    =  s        S  S  w   s    SS(w)=s   be the syndrome of   w   w   w   . To correct    w  â€²     superscript  w  normal-â€²    w^{\prime}   find a vector   e   e   e   such that     s  y  n   (  e  )    =    s  y  n   (   w  â€²   )    -  s         s  y  n  e       s  y  n   superscript  w  normal-â€²    s     syn(e)=syn(w^{\prime})-s   , then    w  =    w  â€²   -  e       w     superscript  w  normal-â€²   e     w=w^{\prime}-e   .  Set difference constructions  When working with a very large alphabet or very long strings resulting in a very large universe   ð’°   ð’°   \mathcal{U}   , it may be more efficient to treat   w   w   w   and    w  â€²     superscript  w  normal-â€²    w^{\prime}   as sets and look at set differences to correct errors. To work with a large set   w   w   w   it is useful to look at its characteristic vector    x  w     subscript  x  w    x_{w}   , which is a binary vector of length   n   n   n   that has a value of 1 when an element    a  âˆˆ  ð’°      a  ð’°    a\in\mathcal{U}   and    a  âˆˆ  w      a  w    a\in w   , or 0 when    a  âˆ‰  w      a  w    a\notin w   . The best way to decrease the size of a secure sketch when   n   n   n   is large is make   k   k   k   large since the size is determined by    n  -  k      n  k    n-k   . A good code to base this construction on is a     [  n  ,   n  -   t  Î±    ,    2  t   +  1   ]   2     subscript   n    n    t  Î±        2  t   1    2    [n,n-t\alpha,2t+1]_{2}    BCH code where    n  =    2  Î±   -  1       n     superscript  2  Î±   1     n=2^{\alpha}-1   and    t  â‰ª  n     much-less-than  t  n    t\ll n   so    k  â‰¤   n  -   l  o  g   (      n      t      )         k    n    l  o  g   binomial  n  t       k\leq n-log{n\choose{t}}   , it is also useful that BCH codes can be decode in sub-linear time.  Pin sketch construction  Let     S  S   (  w  )    =  s  =   s  y  n   (   x  w   )            S  S  w   s         s  y  n   subscript  x  w       SS(w)=s=syn(x_{w})   . To correct    w  â€²     superscript  w  normal-â€²    w^{\prime}   first find     S  S   (   w  â€²   )    =   s  â€²   =   s  y  n   (   x  w  â€²   )            S  S   superscript  w  normal-â€²     superscript  s  normal-â€²          s  y  n   superscript   subscript  x  w   normal-â€²       SS(w^{\prime})=s^{\prime}=syn(x_{w}^{\prime})   , then find a set v where     s  y  n   (   x  v   )    =    s  â€²   -  s         s  y  n   subscript  x  v       superscript  s  normal-â€²   s     syn(x_{v})=s^{\prime}-s   , finally compute the symmetric difference to get     R  e  c   (   w  â€²   ,  s  )    =    w  â€²   â–³  v   =  w          R  e  c    superscript  w  normal-â€²   s       superscript  w  normal-â€²   normal-â–³  v        w     Rec(w^{\prime},s)=w^{\prime}\triangle v=w   . While this is not the only construction to use set difference it is the easiest one to use.  Edit distance constructions  When data can be corrupted or deleted the best measurement to use is edit distance . To make a construction based on edit distance it is easiest to start with a construction for set difference or hamming distance as an intermediate correction step and then build the edit distance construction around that.  Other distance measure constructions  There are many other types of errors and distances that can be measured which can be used to model other situations. Most of these other possible constructions are like edit distance constructions where they build upon simpler constructions.  Improving error-tolerance via relaxed notions of correctness  It is possible to show that the error-tolerance of a secure sketch can be improved by applying a probabilistic method to error correction and only needing errors to be correctable with a high probability. This will show that it is possible to exceed the Plotkin bound which is limited to correcting    n  /  4      n  4    n/4   errors, and approach Shannonâ€™s bound allowing for nearly    n  /  2      n  2    n/2   corrections. To achieve this better error correction a less restrictive error distribution model must be used.  Random errors  For this most restrictive model use a BSC      p     p    {}_{p}   to create a    w  â€²     superscript  w  normal-â€²    w^{\prime}   that a probability   p   p   p   at each position in    w  â€²     superscript  w  normal-â€²    w^{\prime}   that the bit received is wrong. This model can show that entropy loss is limited to     n  H   (  p  )    -   o   (  n  )          n  H  p     o  n     nH(p)-o(n)   , where   H   H   H   is the binary entropy function , and if min-entropy    m  â‰¥    n   (   H   (    1  2   -  Î³   )    )    +  Îµ       m      n    H      1  2   Î³     Îµ     m\geq n(H(\frac{1}{2}-\gamma))+\varepsilon   then    n   (    1  2   -  Î³   )       n      1  2   Î³     n(\frac{1}{2}-\gamma)   errors can be tolerated, for some constant    Î³  >  0      Î³  0    \gamma>0   .  Input-dependent errors  For this model errors do not have a known distribution and can be from an adversary, the only constraints are     d  i   s  err    â‰¤  t        d  i   subscript  s  err    t    dis_{\text{err}}\leq t   and that a corrupted word depends only on the input   w   w   w   and not on the secure sketch. It can be shown for this error model that there will never be more than   t   t   t   errors since this model can account for all complex noise processes, meaning that Shannonâ€™s bound can be reached, to do this a random permutation is prepended to the secure sketch that will reduce entropy loss.  Computationally bounded errors  This differs from the input dependent model by having errors that depend on both the input   w   w   w   and the secure sketch, and an adversary is limited to polynomial time algorithms for introducing errors. Since algorithms that can run in better than polynomial time are not currently feasible in the real world, then a positive result using this error model would guarantee that any errors can be fixed. This is the least restrictive model the only known way to approach Shannonâ€™s bound is to use list-decodable codes although this may not always be useful in practice since returning a list instead of a single codeword may not always be acceptable.  Privacy guarantees  In general a secure system attempts to leak as little information as possible to an adversary . In the case of biometrics if information about the biometric reading is leaked the adversary may be able to learn personal information about a user. For example an adversary notices that there is a certain pattern in the helper strings that implies the ethnicity of the user. We can consider this additional information a function    f   (  W  )       f  W    f(W)   . If an adversary were to learn a helper string, it must be ensured that, from this data he can not infer any data about the person from which the biometric reading was taken.  Correlation between helper string and biometric input  Ideally the helper string   P   P   P   would reveal no information about the biometric input   w   w   w   . This is only possible when every subsequent biometric reading    w  â€²     superscript  w  normal-â€²    w^{\prime}   is identical to the original   w   w   w   . In this case there is actually no need for the helper string, so it is easy to generate a string that is in no way correlated to   w   w   w   .  Since it is desirable to accept biometric input    w  â€²     superscript  w  normal-â€²    w^{\prime}   similar to   w   w   w   the helper string   P   P   P   must be somehow correlated. The more different   w   w   w   and    w  â€²     superscript  w  normal-â€²    w^{\prime}   are allowed to be, the more correlation there will be between   P   P   P   and   w   w   w   , the more correlated they are the more information   P   P   P   reveals about   w   w   w   . We can consider this information to be a function    f   (  W  )       f  W    f(W)   . The best possible solution is to make sure the adversary can't learn anything useful from the helper string.  Gen( W ) as a probabilistic map  A probabilistic map    Y   (  )       Y     Y()   hides the results of functions with a small amount of leakage   Ïµ   Ïµ   \epsilon   . The leakage is the difference in probability two adversaries have of guessing some function when one knows the probabilistic map and one does not. Formally:      |  P  r   [   A  1    (  Y   (  W  )   )   =  f   (  W  )   ]   -  P  r   [   A  2    (  )   =  f   (  W  )   ]   |  â‰¤  Ïµ     fragments  normal-|  P  r   fragments  normal-[   subscript  A  1    fragments  normal-(  Y   fragments  normal-(  W  normal-)   normal-)    f   fragments  normal-(  W  normal-)   normal-]    P  r   fragments  normal-[   subscript  A  2    fragments  normal-(  normal-)    f   fragments  normal-(  W  normal-)   normal-]   normal-|   Ïµ    |Pr[A_{1}(Y(W))=f(W)]-Pr[A_{2}()=f(W)]|\leq\epsilon     If the function    G  e  n   (  W  )       G  e  n  W    Gen(W)   is a probabilistic map, then even if an adversary knows both the helper string   P   P   P   and the secret string   R   R   R   they are only negligibly more likely figure something out about the subject as if they knew nothing. The string   R   R   R   is supposed to kept secret, so even if it is leaked (which should be very unlikely) the adversary can still figure out nothing useful about the subject, as long as   Ïµ   Ïµ   \epsilon   is small. We can consider    f   (  W  )       f  W    f(W)   to be any correlation between the biometric input and some physical characteristic of the person. Setting     Y  =   G  e  n   (  W  )    =  R   ,  P     formulae-sequence      Y    G  e  n  W        R    P    Y=Gen(W)=R,P   in the above equation changes it to:       |    Pr   [     A  1    (  R  ,  P  )    =   f   (  W  )     ]    -   Pr   [     A  2    (  )    =   f   (  W  )     ]     |   â‰¤  Ïµ           Pr       subscript  A  1    R  P      f  W      Pr       subscript  A  2       f  W       Ïµ    |\Pr[A_{1}(R,P)=f(W)]-\Pr[A_{2}()=f(W)]|\leq\epsilon     This means that if one adversary    A  1     subscript  A  1    A_{1}   has    (  R  ,  P  )     R  P    (R,P)   and a second adversary    A  2     subscript  A  2    A_{2}   knows nothing, their best guesses at    f   (  W  )       f  W    f(W)   are only   Ïµ   Ïµ   \epsilon   apart.  Uniform fuzzy extractors  Uniform fuzzy extractors are a special case of fuzzy extractors, where the output    (  R  ,  P  )     R  P    (R,P)   of    G  e  n   (  W  )       G  e  n  W    Gen(W)   are negligibly different from strings picked from the uniform distribution, i.e.     (  R  ,  P  )    â‰ˆ  Ïµ    (   U  â„“   ,   U   |  P  |    )       subscript   Ïµ    R  P     subscript  U  normal-â„“    subscript  U    P       (R,P)\approx_{\epsilon}(U_{\ell},U_{|P|})     Uniform secure sketches  Since secure sketches imply fuzzy extractors, constructing a uniform secure sketch allows for the easy construction of a uniform fuzzy extractor. In a uniform secure sketch the sketch procedure    S  S   (  w  )       S  S  w    SS(w)   is a randomness extractor     E  x  t   (  w  ;  i  )       E  x  t   w  i     Ext(w;i)   . Where   w   w   w   is the biometric input and   i   i   i   is the random seed . Since randomness extractors output a string that appears to be from a uniform distribution they hide all the information about their input.  Applications  Extractor sketches can be used to construct    (  m  ,  t  ,  Ïµ  )     m  t  Ïµ    (m,t,\epsilon)   -fuzzy perfectly one-way hash functions. When used as a hash function the input   w   w   w   is the object you want to hash. The    P  ,  R     P  R    P,R   that    G  e  n   (  w  )       G  e  n  w    Gen(w)   outputs is the hash value. If one wanted to verify that a    w  â€²     superscript  w  normal-â€²    w^{\prime}   within   t   t   t   from the original   w   w   w   , they would verify that     R  e  p   (   w  â€²   ,  P  )    =  R        R  e  p    superscript  w  normal-â€²   P    R    Rep(w^{\prime},P)=R   .    (  m  ,  t  ,  Ïµ  )     m  t  Ïµ    (m,t,\epsilon)   -fuzzy perfectly one-way hash functions are special hash functions where they accept any input with at most   t   t   t   errors, compared to traditional hash functions which only accept when the input matches the original exactly. Traditional cryptographic hash functions attempt to guarantee that is it is computationally infeasible to find two different inputs that hash to the same value. Fuzzy perfectly one-way hash functions make an analogous claim. They make it computationally infeasible two find two inputs, that are more than   t   t   t    Hamming distance apart and hash to the same value.  Protection against active attacks  An active attack could be one where the adversary can modify the helper string   P   P   P   . If the adversary is able to change   P   P   P   to another string that is also acceptable to the reproduce function    R  e  p   (  W  ,  P  )       R  e  p   W  P     Rep(W,P)   , it cause    R  e  p   (  W  ,  P  )       R  e  p   W  P     Rep(W,P)   to output an incorrect secret string    R  ~     normal-~  R    \tilde{R}   . Robust fuzzy extractors solve this problem by allowing the reproduce function to fail, if a modified helper string is provided as input.  Robust fuzzy extractors  One method of constructing robust fuzzy extractors is to use hash functions . This construction requires two hash functions    H  1     subscript  H  1    H_{1}   and    H  2     subscript  H  2    H_{2}   . The    G  e  n   (  W  )       G  e  n  W    Gen(W)   functions produces the helper string   P   P   P   by appending the output of a secure sketch    s  =   S  S   (  w  )        s    S  S  w     s=SS(w)   to the hash of both the reading   w   w   w   and secure sketch   s   s   s   . It generates the secret string   R   R   R   by applying the second hash function to   w   w   w   and   s   s   s   . Formally:     G  e  n   (  w  )    :   s  =    S  S   (  w  )    ,   r  e  t  u  r  n     :    P  =   (  s  ,    H  1    (  w  ,  s  )    )    ,   R  =    H  2    (  w  ,  s  )           normal-:    G  e  n  w     s     S  S  w     r  e  t  u  r  n       normal-:     formulae-sequence    P   s     subscript  H  1    w  s        R     subscript  H  2    w  s         Gen(w):s=SS(w),return:P=(s,H_{1}(w,s)),R=H_{2}(w,s)   The reproduce function    R  e  p   (  W  ,  P  )       R  e  p   W  P     Rep(W,P)   also makes use of the hash functions    H  1     subscript  H  1    H_{1}   and    H  2     subscript  H  2    H_{2}   . In addition to verifying the biometric input is similar enough to the one recovered using the    R  e  c   (  W  ,  S  )       R  e  c   W  S     Rec(W,S)   function, it also verifies that hash in the second part of   P   P   P   was actually derived from   w   w   w   and   s   s   s   . If both of those conditions are met it returns   R   R   R   which is itself the second hash function applied to   w   w   w   and   s   s   s   . Formally:       R  e  p   (   w  â€²   ,   P  ~   )    :      normal-:    R  e  p    superscript  w  normal-â€²    normal-~  P     absent    Rep(w^{\prime},\tilde{P}):   Get    s  ~     normal-~  s    \tilde{s}   and    h  ~     normal-~  h    \tilde{h}   from       P  ~   ;   w  ~    =   R  e  c   (   w  â€²   ,   s  ~   )     .        normal-~  P    normal-~  w      R  e  c    superscript  w  normal-â€²    normal-~  s       \tilde{P};\tilde{w}=Rec(w^{\prime},\tilde{s}).   If     Î”   (   w  ~   ,   w  â€²   )    â‰¤  t        normal-Î”    normal-~  w    superscript  w  normal-â€²     t    \Delta(\tilde{w},w^{\prime})\leq t   and     h  ~   =    H  1    (   w  ~   ,   s  ~   )         normal-~  h      subscript  H  1     normal-~  w    normal-~  s       \tilde{h}=H_{1}(\tilde{w},\tilde{s})   then     r  e  t  u  r  n   :    H  2    (   w  ~   ,   s  ~   )       normal-:    r  e  t  u  r  n      subscript  H  2     normal-~  w    normal-~  s       return:H_{2}(\tilde{w},\tilde{s})   else     r  e  t  u  r  n   :   f  a  i  l      normal-:    r  e  t  u  r  n     f  a  i  l     return:fail     If   P   P   P   has been tampered with it will be obvious because,    R  e  p      R  e  p    Rep   will output fail with very high probability. To cause the algorithm accept a different   P   P   P   an adversary would have to find a    w  ~     normal-~  w    \tilde{w}   such that      H  1    (  w  ,  s  )    =    H  1    (   w  ~   ,   s  ~   )           subscript  H  1    w  s       subscript  H  1     normal-~  w    normal-~  s       H_{1}(w,s)=H_{1}(\tilde{w},\tilde{s})   . Since hash function are believed to be one way functions , it is computationally infeasible to find such a    w  ~     normal-~  w    \tilde{w}   . Seeing   P   P   P   would provide the adversary with no useful information. Since, again, hash function are one way functions, it is computationally infeasible for the adversary to reverse the hash function and figure out   w   w   w   . Part of   P   P   P   is the secure sketch, but by definition the sketch reveals negligible information about its input. Similarly seeing   R   R   R   (even though it should never see it) would provide the adversary with no useful information as the adversary wouldn't be able to reverse the hash function and see the biometric input.  References   Fuzzy Extractors: A Brief Survey of Results from 2004 to 2006  Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data  Biometric Fuzzy Extractor Scheme for Iris Templates  A Fuzzy Vault Scheme   "  Category:Biometrics  Category:Coding theory  Category:Cryptographic algorithms   