   Elliptic curve point multiplication      Elliptic curve point multiplication   Elliptic curve point multiplication is the operation of successively adding a point along an elliptic curve to itself repeatedly. It is used in elliptic curve cryptography (ECC) as a means of producing a trapdoor function . The literature presents this operation as scalar multiplication , thus the most common name is "elliptic curve scalar multiplication", as written in Hessian form of an elliptic curve .  Basics  Given a curve, E , defined along some equation in a finite field (such as E : y 2 = x 3 + ax + b ), point multiplication is defined as the repeated addition of a point along that curve. Denote as nP = P + P + P + … + P for some scalar (integer) n and a point P = ( x , y ) that lies on the curve, E . This type of curve is known as a Weierstrass curve.  The security of modern ECC depends on the intractability of determining n from     Q   =   n  P       Q    n  P     \scriptstyle Q~{}=~{}nP   given known values of Q and P . It is known as the elliptic curve discrete logarithm problem.  Point addition  With 2 distinct points, P and Q , addition is defined as the negation of the point resulting from the intersection of the curve, E , and the straight line defined by the points P and Q , giving the point, R .      P  +  Q      P  Q    \displaystyle P+Q   .  Assuming, the elliptic curve, E , is given by y 2 = x 3 + ax + b , this can be calculated as:      x  r     subscript  x  r    \displaystyle x_{r}     Point doubling  Where the points, P and Q , are coincident, addition is similar, except that there is no well-defined straight line through P and Q , so the limiting case, the tangent to the curve, E , at P and Q is used instead.  This is calculated as above, except with:      λ  =     3   x  p  2    +  a    2   y  p         λ        3   superscript   subscript  x  p   2    a     2   subscript  y  p       \lambda=\frac{3x_{p}^{2}+a}{2y_{p}}     where a is from the defining equation of the curve, E , above.  Point multiplication  The straightforward way of computing a point multiplication is through repeated addition. However, this is a fully exponential approach to computing the multiplication.  Double-and-add  The simplest method is the double-and-add method, similar to multiply-and-square in modular exponentiation. The algorithm works as follows:  To compute dP , start with the binary representation for d     d  =    d  0   +   2   d  1    +    2  2    d  2    +  ⋯  +    2  m    d  m         d     subscript  d  0     2   subscript  d  1       superscript  2  2    subscript  d  2    normal-⋯     superscript  2  m    subscript  d  m       d=d_{0}+2d_{1}+2^{2}d_{2}+\cdots+2^{m}d_{m}   , where [     d  0   .  .   d  m      fragments   subscript  d  0   normal-.  normal-.   subscript  d  m     d_{0}..d_{m}   ] ∈ {0,1}  * Q := 0  * for i from 0 to m do  * if d i = 1 then Q := Q + P (using point addition)  * P := 2 P (using point doubling)  * Return Q  An alternative way of writing the above as a recursive function is  f(P, n) is
    if n = 0 then return 0           # computation complete
    if n = 1 then return P
    else if n mod 2 = 1 then
       return P + f(P, n-1)                 # addition when n is odd
    else
       return f(2P, n/2)                    # doubling when n is even  where f is the function for doubling, P is the coordinate to double, n is the number of times to double the coordinate. Example: 100P can be written as 2(2(P+2(2(2(P+2P))))) and thus requires six doublings and two additions. 100P would be equal to f(P,100).  This algorithm requires log 2 ( n ) iterations of point doubling and addition to compute the full-point multiplication. There are many variations of this algorithm such as using a window, sliding window, NAF, NAF-w, vector chains, and Montgomery ladder.  Windowed method  In the windowed version of this algorithm, one selects a window size w and computes all    2  w     superscript  2  w    2^{w}   values of    d  P      d  P    dP   for    d  =   0  ,  1  ,  2  ,  …  ,    2  w   -  1        d   0  1  2  normal-…     superscript  2  w   1      d=0,1,2,\dots,2^{w}-1   . The algorithm now uses the representation    d  =    d  0   +    2  w    d  1    +    2   2  w     d  2    +  ⋯  +    2   m  w     d  m         d     subscript  d  0      superscript  2  w    subscript  d  1       superscript  2    2  w     subscript  d  2    normal-⋯     superscript  2    m  w     subscript  d  m       d=d_{0}+2^{w}d_{1}+2^{2w}d_{2}+\cdots+2^{mw}d_{m}   and becomes  * Q = 0  * for i from m to 0 do  * Q := 2 w Q (using repeated point doubling)  * if d i > 0 then Q := Q + d i P (using a single point addition with the pre-computed value of d i P)  * Return Q  This algorithm has the same complexity as the double-and-add approach with the benefit of using fewer point additions (which in practice are slower than doubling). Typically, the value of w is chosen to be fairly small making the pre-computation stage a trivial component of the algorithm. For the NIST recommended curves,    w  =  4      w  4    w=4   is usually the best selection. The entire complexity for a n -bit number is measured as    n  +  1      n  1    n+1   point doubles and      2  w   -  2   +   n  w          superscript  2  w   2     n  w     2^{w}-2+{n\over w}   point additions.  Sliding-window method  In the sliding-window version, we look to trade off point additions for point doubles. We compute a similar table as in the windowed version except we only compute the points    d  P      d  P    dP   for    d  =    2   w  -  1    ,    2   w  -  1    +  1   ,  …  ,    2  w   -  1        d    superscript  2    w  1       superscript  2    w  1    1   normal-…     superscript  2  w   1      d=2^{w-1},2^{w-1}+1,\dots,2^{w}-1   . Effectively, we are only computing the values for which the most significant bit of the window is set. The algorithm then uses the original double-and-add representation of    d  =    d  0   +   2   d  1    +    2  2    d  2    +  ⋯  +    2  m    d  m         d     subscript  d  0     2   subscript  d  1       superscript  2  2    subscript  d  2    normal-⋯     superscript  2  m    subscript  d  m       d=d_{0}+2d_{1}+2^{2}d_{2}+\cdots+2^{m}d_{m}   .  * Q = 0  * for i from m downto 0 do  * if d i = 0 then  * Q := 2Q (point double)  * else  * Grab up to w - 1 additional bits from d to store into (including d i ) t and decrement i suitably  * If fewer than w bits were grabbed  * Perform double-and-add using t   * Return Q  * else  * Q := 2 w Q (repeated point double)  * Q := Q + tP (point addition)  * Return Q  This algorithm has the benefit that the pre-computation stage is roughly half as complex as the normal windowed method while also trading slower point additions for point doublings. In effect, there is little reason to use the windowed method over this approach. The algorithm requires     w  -  1   +  n        w  1   n    w-1+n   point doubles and at most      2   w  -  1    -  1   +   n  w          superscript  2    w  1    1     n  w     2^{w-1}-1+{n\over w}   point additions.  wNAF method  In the Non-Adjacent Form we aim to make use of the fact that point subtraction is just as easy as point addition to perform fewer (of either) as compared to a sliding-window method. The NAF of the multiplicand   d   d   d   must be computed first with the following algorithm  * i = 0  * While ( d > 0) do  * if ( d mod 2) == 1 then  * d i = d mods 2 w  * d = d - d i  * else  * d i = 0  * d = d /2  * i = i + 1  * return ( d i-1 , d i-2 , ..., d 0 )  Where the mods function is defined as  * if ( d mod 2 w ) >= 2 w-1  * return ( d mod 2 w ) - 2 w  * else  * return d mod 2 w  This produces the NAF needed to now perform the multiplication. This algorithm requires the pre-computation of the points     {  1  ,  3  ,  5  ,  …  ,    2   w  -  1    -  1   }   P       1  3  5  normal-…     superscript  2    w  1    1    P    \{1,3,5,\dots,2^{w-1}-1\}P   and their negatives, where   P   P   P   is the point to be multiplied. On typical Weierstrass curves, if    P  =   {  x  ,  y  }       P   x  y     P=\{x,y\}   then     -  P   =   {  x  ,   -  y   }         P    x    y      -P=\{x,-y\}   . So in essence the negatives are cheap to compute. Next, the following algorithm computes the multiplication    d  P      d  P    dP   :  * Q = 0  * for j = i -1 downto 0 do  * Q = 2Q  * if ( d j != 0)  * Q = Q + d j G  * return Q  The wNAF guarantees that on average there will be a density of    1   w  +  1       1    w  1     1\over{w+1}   point additions (slightly better than the unsigned window). It requires 1 point doubling and     2   w  -  2    -  1       superscript  2    w  2    1    2^{w-2}-1   point additions for precomputation. The algorithm then requires   n   n   n   point doublings and    n   w  +  1       n    w  1     n\over{w+1}   point additions for the rest of the multiplication.  One property of the NAF is that we are guaranteed that every non-zero element    d  i     subscript  d  i    d_{i}   is followed by at least    w  -  1      w  1    w-1   additional zeroes. This is because the algorithm clears out the lower   w   w   w   bits of   d   d   d   with every subtraction of the output of the mods function. This observation can be used for several purposes. After every non-zero element the additional zeroes can be implied and do not need to be stored. Secondly, the multiple serial divisions by 2 can be replaced by a division by    2  w     superscript  2  w    2^{w}   after every non-zero    d  i     subscript  d  i    d_{i}   element and divide by 2 after every zero.  Montgomery ladder  The Montgomery ladder approach computes the point multiplication in a fixed amount of time. This can be beneficial when timing or power consumption measurements are exposed to an attacker performing a side-channel attack . The algorithm uses the same representation as from double-and-add.  * R 0 := 0  * R 1 := P  * for i from m downto 0 do  * if d i = 0 then  * R 1 := R 0 + R 1  * R 0 := 2 R 0  * else  * R 0 := R 0 + R 1  * R 1 := 2 R 1  * Return R 0  This algorithm has in effect the same speed as the double-and-add approach except that it computes the same number of point additions and doubles regardless of the value of the multiplicand d . This means that at this level the algorithm does not leak any information through timing or power. However, it was shown by Yuval Yarom and Naomi Benger that through application of FLUSH+RELOAD side-channel attack the full private key can be revealed in only one multiplication operation.  References   Yuval Yarom and Naomi Benger. Recovering OpenSSL ECDSA Nonces Using the FLUSH+RELOAD Cache Side-channel Attack.   Cryptology ePrint Archive, Report 2014/140, 2014. http://eprint.iacr.org/2014/140.pdf  "  Category:Elliptic curves   