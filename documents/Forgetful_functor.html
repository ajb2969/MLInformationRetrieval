<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="802">Forgetful functor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Forgetful functor</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, in the area of <a href="category_theory" title="wikilink">category theory</a>, a <strong>forgetful <a class="uri" href="functor" title="wikilink">functor</a></strong> (also known as a <strong>stripping functor</strong>) 'forgets' or drops some or all of the input's structure or properties 'before' mapping to the output. For an <a href="algebraic_structure" title="wikilink">algebraic</a> <a href="structure_(mathematical_logic)" title="wikilink">structure</a> of a given <a href="signature_(logic)" title="wikilink">signature</a>, this may be expressed by curtailing the signature: the new signature is an edited form of the old one. If the signature is left as an <a href="empty_list" title="wikilink">empty list</a>, the functor is simply to take the <strong>underlying set</strong> of a structure. Because many structures in mathematics consist of a set with an additional added structure, a forgetful functor that maps to the underlying set is the most common case.</p>
<h2 id="introduction">Introduction</h2>

<p>As examples, there are several forgetful functors from the <a href="category_of_commutative_rings" title="wikilink">category of commutative rings</a>. A (<a href="unital_algebra" title="wikilink">unital</a>) <a href="Ring_(mathematics)" title="wikilink">ring</a>, described in the language of <a href="universal_algebra" title="wikilink">universal algebra</a>, is an ordered tuple (<em>R</em>,+,*,<em>a</em>,0,1) satisfying certain axioms, where "+" and "*" are binary functions on the set <em>R</em>, <em>a</em> is a unary operation corresponding to additive inverse, and 0 and 1 are nullary operations giving the identities of the two binary operations. Deleting the 1 gives a forgetful functor to the category of rings without unit; it simply "forgets" the unit. Deleting "*" and 1 yields a functor to the category of <a href="abelian_group" title="wikilink">abelian groups</a>, which assigns to each ring <em>R</em> the underlying additive abelian group of <em>R</em>. To each <a class="uri" href="morphism" title="wikilink">morphism</a> of rings is assigned the same <a href="function_(mathematics)" title="wikilink">function</a> considered merely as a morphism of addition between the underlying groups. Deleting all the operations gives the functor to the underlying set <em>R</em>.</p>

<p>It is beneficial to distinguish between forgetful functors that "forget structure" versus those that "forget properties". For example, in the above example of commutative rings, in addition to those functors that delete some of the operations, there are functors that forget some of the axioms. There is a functor from the category <strong>CRing</strong> to <strong>Ring</strong> that forgets the axiom of commutativity, but keeps all the operations. Occasionally the object may include extra sets not defined strictly in terms of the underlying set (in this case, which part to consider the underlying set is a matter of taste, though this is rarely ambiguous in practice). For these objects, there are forgetful functors that forget the extra sets that are more general.</p>

<p>Most common objects studied in mathematics are constructed as underlying sets along with extra sets of structure on those sets (operations on the underlying set, privileged subsets of the underlying set, etc.) which may satisfy some axioms. For these objects, a commonly considered forgetful functor is as follows. Let 

<math display="inline" id="Forgetful_functor:0">
<semantics>
<mi class="ltx_font_mathcaligraphic">𝒞</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝒞</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
</semantics>
</math>

 be any category based on <a href="Set_(mathematics)" title="wikilink">sets</a>, e.g. <a href="group_(mathematics)" title="wikilink">groups</a> - sets of elements - or <a href="topological_space" title="wikilink">topological spaces</a> - sets of 'points'. As usual, write 

<math display="inline" id="Forgetful_functor:1">
<semantics>
<mrow>
<mo>Ob</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi class="ltx_font_mathcaligraphic">𝒞</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>Ob</ci>
<ci>𝒞</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Ob}(\mathcal{C})
  </annotation>
</semantics>
</math>

 for the <a href="Category_theory#Categories.2C_objects.2C_and_morphisms" title="wikilink">objects</a> of 

<math display="inline" id="Forgetful_functor:2">
<semantics>
<mi class="ltx_font_mathcaligraphic">𝒞</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝒞</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
</semantics>
</math>

 and write 

<math display="inline" id="Forgetful_functor:3">
<semantics>
<mrow>
<mo>Fl</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi class="ltx_font_mathcaligraphic">𝒞</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>Fl</ci>
<ci>𝒞</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Fl}(\mathcal{C})
  </annotation>
</semantics>
</math>


 for the morphisms of the same. Consider the rule:</p>

<p>
<math display="block" id="Forgetful_functor:4">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 in 

<math display="inline" id="Forgetful_functor:5">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>Ob</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi class="ltx_font_mathcaligraphic">𝒞</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo rspace="12.5pt">,</mo>
<mi>A</mi>
</mrow>
<mo>↦</mo>
<mrow>
<mo stretchy="false">|</mo>
<mi>A</mi>
<mo stretchy="false">|</mo>
</mrow>
<mo>=</mo>
<mi></mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<csymbol cd="latexml">maps-to</csymbol>
<list>
<apply>
<ci>Ob</ci>
<ci>𝒞</ci>
</apply>
<ci>A</ci>
</list>
<apply>
<abs></abs>
<ci>A</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<csymbol cd="latexml">absent</csymbol>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Ob}(\mathcal{C}),\quad A\mapsto|A|=
  </annotation>
</semantics>
</math>

 the underlying set of 

<math display="inline" id="Forgetful_functor:6">
<semantics>
<mrow>
<mi>A</mi>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A,
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Forgetful_functor:7">
<semantics>
<mi>u</mi>
<annotation-xml encoding="MathML-Content">
<ci>u</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   u
  </annotation>
</semantics>
</math>

 in 

<math display="inline" id="Forgetful_functor:8">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>Fl</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi class="ltx_font_mathcaligraphic">𝒞</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo rspace="12.5pt">,</mo>
<mi>u</mi>
</mrow>
<mo>↦</mo>
<mrow>
<mo stretchy="false">|</mo>
<mi>u</mi>
<mo stretchy="false">|</mo>
</mrow>
<mo>=</mo>
<mi></mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<csymbol cd="latexml">maps-to</csymbol>
<list>
<apply>
<ci>Fl</ci>
<ci>𝒞</ci>
</apply>
<ci>u</ci>
</list>
<apply>
<abs></abs>
<ci>u</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<csymbol cd="latexml">absent</csymbol>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Fl}(\mathcal{C}),\quad u\mapsto|u|=
  </annotation>
</semantics>
</math>


 the morphism, 

<math display="inline" id="Forgetful_functor:9">
<semantics>
<mi>u</mi>
<annotation-xml encoding="MathML-Content">
<ci>u</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   u
  </annotation>
</semantics>
</math>

, as a map of sets. The functor 

<math display="inline" id="Forgetful_functor:10">
<semantics>
<mrow>
<mo stretchy="false">|</mo>
<mo>⋅</mo>
<mo stretchy="false">|</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-|</ci>
<ci>normal-⋅</ci>
<ci>normal-|</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\cdot|
  </annotation>
</semantics>
</math>

 is then the forgetful functor from 

<math display="inline" id="Forgetful_functor:11">
<semantics>
<mi class="ltx_font_mathcaligraphic">𝒞</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝒞</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
</semantics>
</math>

 to 

<math display="inline" id="Forgetful_functor:12">
<semantics>
<mi>𝐒𝐞𝐭</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝐒𝐞𝐭</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{Set}
  </annotation>
</semantics>
</math>

, the <a href="category_of_sets" title="wikilink">category of sets</a>.</p>

<p>Forgetful functors are almost always <a href="faithful_functor" title="wikilink">faithful</a>. <a href="Concrete_category" title="wikilink">Concrete categories</a> have forgetful functors to the category of sets—indeed they may be <em>defined</em> as those categories that admit a faithful functor to that category.</p>

<p>Forgetful functors that only forget axioms are always fully faithful; every morphism that respects the structure between objects that satisfy the axioms automatically also respects the axioms. Forgetful functors that forget structures need not be full; some morphisms don't respect the structure. These functors are still faithful though; distinct morphisms that do respect the structure are still distinct when the structure is forgotten. Functors that forget the extra sets need not be faithful; distinct morphisms respecting the structure of those extra sets may be indistinguishable on the underlying set.</p>

<p>In the language of formal logic, a functor of the first kind removes axioms. The second kind removes predicates. The third kind remove types.</p>

<p>An example of the first kind is the forgetful functor <strong>Ab</strong> → <strong>Grp</strong>. One of the second kind is the forgetful functor <strong>Ab</strong> → <strong>Set</strong>. A functor of the third kind is the functor <strong>Mod</strong> → <strong>Ab</strong>, where <strong>Mod</strong> is the <a href="fibred_category" title="wikilink">fibred category</a> of all modules over arbitrary rings. To see this, just choose a ring homomorphism between the underlying rings that does not change the ring action. Under the forgetful functor, this morphism yields the identity. Note that an object in <strong>Mod</strong> is a tuple, which includes a ring and an abelian group, so which to forget is a matter of taste.</p>
<h2 id="left-adjoint-free">Left Adjoint: Free</h2>

<p>Forgetful functors tend to have <a href="left_adjoint" title="wikilink">left adjoints</a>, which are '<a href="free_object" title="wikilink">free</a>' constructions. For example:</p>
<ul>
<li><a href="free_module" title="wikilink">free module</a>: the forgetful functor from 

<math display="inline" id="Forgetful_functor:13">
<semantics>
<mrow>
<mi>𝐌𝐨𝐝</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>R</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>𝐌𝐨𝐝</ci>
<ci>R</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{Mod}(R)
  </annotation>
</semantics>
</math>


 (the category of 

<math display="inline" id="Forgetful_functor:14">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

-<a href="module_(mathematics)" title="wikilink">module</a>) to 

<math display="inline" id="Forgetful_functor:15">
<semantics>
<mi>𝐒𝐞𝐭</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝐒𝐞𝐭</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbf{Set}
  </annotation>
</semantics>
</math>

 has left adjoint 

<math display="inline" id="Forgetful_functor:16">
<semantics>
<msub>
<mo>Free</mo>
<mi>R</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Free</ci>
<ci>R</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Free}_{R}
  </annotation>
</semantics>
</math>

, with 

<math display="inline" id="Forgetful_functor:17">
<semantics>
<mrow>
<mi>X</mi>
<mo>↦</mo>
<mrow>
<msub>
<mo>Free</mo>
<mi>R</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">maps-to</csymbol>
<ci>X</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Free</ci>
<ci>R</ci>
</apply>
<ci>X</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X\mapsto\operatorname{Free}_{R}(X)
  </annotation>
</semantics>
</math>

, the free 

<math display="inline" id="Forgetful_functor:18">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>


-module with <a href="Basis_(linear_algebra)" title="wikilink">basis</a>
<math display="inline" id="Forgetful_functor:19">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>

.</li>
<li><a href="free_group" title="wikilink">free group</a></li>
<li><a href="free_lattice" title="wikilink">free lattice</a></li>
<li><a href="tensor_algebra" title="wikilink">tensor algebra</a></li>
<li><a href="free_category" title="wikilink">free category</a>, adjoint to the forgetful functor from categories to <a href="quiver_(mathematics)" title="wikilink">quivers</a></li>
</ul>

<p>For a more extensive list, see (Mac Lane 1997).</p>

<p>As this is a fundamental example of adjoints, we spell it out: adjointness means that given a set <em>X</em> and an object (say, an <em>R</em>-module) <em>M</em>, maps <em>of sets</em>
<math display="inline" id="Forgetful_functor:20">
<semantics>
<mrow>
<mi>X</mi>
<mo>→</mo>
<mi>M</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>X</ci>
<ci>M</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X\to M
  </annotation>
</semantics>
</math>

 correspond to maps of modules 

<math display="inline" id="Forgetful_functor:21">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Free</mo>
<mi>R</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mi>M</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Free</ci>
<ci>R</ci>
</apply>
<ci>X</ci>
</apply>
<ci>M</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Free}_{R}(X)\to M
  </annotation>
</semantics>
</math>

: every map of sets yields a map of modules, and every map of modules comes from a map of sets.</p>

<p>In the case of vector spaces, this is summarized as: "A map between vector spaces is determined by where it sends a basis, and a basis can be mapped to anything."</p>

<p>Symbolically:</p>

<p>
<math display="block" id="Forgetful_functor:22">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Hom</mo>
<msub>
<mi>𝐌𝐨𝐝</mi>
<mi>R</mi>
</msub>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mo>Free</mo>
<mi>R</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>,</mo>
<mi>M</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mo>Hom</mo>
<mi>𝐒𝐞𝐭</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>,</mo>
<mrow>
<mo>Forget</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>M</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Hom</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝐌𝐨𝐝</ci>
<ci>R</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Free</ci>
<ci>R</ci>
</apply>
<ci>X</ci>
</apply>
<ci>M</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Hom</ci>
<ci>𝐒𝐞𝐭</ci>
</apply>
<ci>X</ci>
<apply>
<ci>Forget</ci>
<ci>M</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Hom}_{\mathbf{Mod}_{R}}(\operatorname{Free}_{R}(X),M)=%
\operatorname{Hom}_{\mathbf{Set}}(X,\operatorname{Forget}(M)).
  </annotation>
</semantics>
</math>
</p>

<p>The <a href="Free_object#Free_functor" title="wikilink">unit of the free-forget adjunction</a> is the "inclusion of a basis"

<math display="block" id="Forgetful_functor:23">
<semantics>
<mrow>
<mi>X</mi>
<mo>→</mo>
<mrow>
<msub>
<mo>Free</mo>
<mi>R</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>X</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Free</ci>
<ci>R</ci>
</apply>
<ci>X</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X\to\operatorname{Free}_{R}(X)
  </annotation>
</semantics>
</math>

.</p>

<p><strong>Fld</strong>, the category of fields, furnishes an example of a forgetful functor with no adjoint. There is no field satisfying a free universal property for a given set.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="Saunders_Mac_Lane" title="wikilink">Mac Lane, Saunders</a>. <em>Categories for the Working Mathematician</em>, Graduate Texts in Mathematics 5, Springer-Verlag, Berlin, Heidelberg, New York, 1997. ISBN 0-387-98403-8</li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Functors" title="wikilink">Category:Functors</a></p>
</body>
</html>
