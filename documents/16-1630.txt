


Module:Buffer/doc




Module:Buffer/doc

This was originally developed to optimize string concatenation as a helper method within Module:Asbox, but has been generalized for all modules.
The interface for Module:Buffer objects is similar to that of  objects in that you may build complex strings with independent child nodes. In most cases, you may use Buffer objects like a normal string, including using  operator (though  has the same role, but potentially over 10 times faster than ). See also: #String, mw.ustring, and mw.text libraries
Additionally, there are several specialized forms and extended objects, described further in their respective sections:












_G (callable)






Last but not least, this module has an ordered __pairs which can be more thorough than  and . (Even reads nil keys!) The logical uniqueness of this iterator may be reason enough to  Module:Buffer.
Usage
require'Module:Buffer'
Creates a new Module:Buffer object when the module returned by  is called as a function{{--}}i.e., there is no 'main'.
Because  are a pet peeve of this developer, this forwards arguments to ; if that op is not desired, you may chain a Buffer object function directly to the module and the self-action will be redirected to a new Buffer object{{--}} i.e  is equivalent to .1
The global variable  is "magic" when passed as the first arg. Such enables the global functions and, if followed by a name string, will declare the new Buffer with that name in the global scope. If the argument following ''name'' is a table with no metatable, 
 it and any other {{luaref|varargs|y}} are forwarded to {{luaself|:_all}}; otherwise, as long as the first vararg is not nil or false, this passes them to {{luaself|:_}}.
 Passing arguments after ''name'' is primary used when {{luaself|:_in}} is indirectly called by {{luaself|:_all}} or {{luaself|pre=Element-|:_add}}. For example:
 {{code|1=require'Module:Buffer'(_G,'arg'):_all({'arg',arg and {' was saved:' ,_in={_G, 't', ' awesome'}{{))}}, true):_(t and {t(), t..'r', t..'st'})|lang=lua}}
 produces: {{code|arg was saved: awesome awesomer awesomest|lang=lua}} The _G passed may also gain a __call {{luaref|Metatables|metamethod|y}} (details at [[#G object|_G object]]).
 
 {{anchor|recycling}}
 As a final note, if you {{luaref|require|plain=y}} text from a module which returns a Buffer object, it may be more efficient to create a new Buffer via chaining {{luaself|Buffer|:_in|:_in|args=()}} 
 after a require statement for the other module and use {{luaself|:_parent|args=()}} at the point where you would append the required text. (Best add {{code|lang=lua|1=--:_in == indirect require Module:Buffer}} 
 so future editors won't hunt for {{code|lang=lua|function ...:_in}} at the other module)
 
 ===Basic functions===
 {{anchor|Buffer}}
 ====Buffer object====
 
 {{luaself|\|args=sep, i, j}}
 :''See also {{luaself|:_str|plain=y}} for advanced string conversion.
 
 Get a Buffer as a {{luaref|string|y}} via a function call on the Buffer ''object'' (as opposed to [[#require'Module:Buffer'|a call on the ''module'']]). 
 This is basically shorthand for {{luaref|table.concat|args=Buffer, sep, i, j}}, or, with no args, {{luaref|tostring|args=Buffer}}. 
 However, if this Buffer is in [[#raw|raw mode]]  or contains at least one {{luaref|sequence|non-sequential|y}} index,
 this reconstructs the Buffer by creating a new table, coercing it contents to strings and appending them sequentially to the temporary "buffer" via 
 new-{{luaself|:_all|plain=yes|args=Buffer}} (or a similar process).
Unconventionally, any -type position passed as i or j are treated as ''relative to length''; 
 that is, {{luaself|\|args='-', -1, '-3'}} is equivalent to {{luaself|\|args='-', -1, #Buffer - 3}} (which obviates the need to {{luaref|Local variable declarations|declare a local|y}} ''Buffer''
 just to use the {{luaref|Length operator|length operator|y}}). Moreover, unlike table.concat, this automatically adjusts numerical
 Later sections may describe values as being ''numerical'' or ''numeric''. Though perfect synonyms in normal usage, these adjectives are not interchangeable here.
 For the purposes of documenting Module:Buffer, ''numerical'' includes both actual number values and string values which {{luaref|tonumber|args=value}} does not return nil 
 (and often involves Buffer-style length relativity); ''numeric'' describes values of number type only. positions to be within the range of the lowest and greatest indicies.
 
 Note you may append a Buffer object without tostring coercion to an {{luaref|HTML library|mw.html|y}} object via {{luaref|mw.html:node}} (though not mw.html:wikitext because of type checking).
 
 =====Buffer.last_concat=====
 
 When strung without a ([[#valid|valid]]) sep, the result is cached at Buffer.last_concat. Until purged, future calls to return that Buffer as a string will return this index instead.2
This should clear automatically whenever a Buffer object function changes the contents of a Buffer. You may manually purge the cache by setting this key to nil, as well as by passing nothing to .
Buffer:_

''See also  for a faster, simpler version of this op.
 

Appends a value to the Buffer. In rough terms,  is the same as . (It may help to imagine  as a  that has stood up and is now casting a shadow.) 
If passed an invalid  listed below, this is a no-op:



empty , or any table such that  returns an empty string (or nil/false)

without a __tostring metamethod and which  is nil or false

A table with no __tostring will pass through  before insertion. An  may be thrown if the table would cause table.concat to error. (Use  instead for such tables.)
When passed  of type , the argument is identical to pos for . In fact, assuming a valid value,  is exactly the same as .
Just like with the position arguments of Buffer(), any pos of type  would be treated as relative to length. 
Set  to true to force append a value without tostring coercion, including invalid values.3 If given only two (non-self) arguments with the second being a boolean, then the second is read as raw instead.
Buffer:_nil
Removes the value buffered at . As with , a string pos string is treated as .
If a non-boolean  is provided, then it will replace the value indexed at pos. Passing a boolean as the second argument is a no-op.
When replacement is nil, the op is basically . As with the positional arguments of other Buffer methods, any numerical string pos is added to length, such that  removes the last item. Note the only type check on replacement is a direct comparison to both booleans (nil is implied). Any other type, including strings, sets the Buffer to raw mode.
A pos that is omitted, nil, or false has the same effect as though '0' (or ) were passed. Given only one non-numerical argument which evaluates true but  would return it as nil, this treats it as though it were passed as the second. If passed a non-numerical pos with any other argument, including nil, this is effectively a no op (though may still purge the cache).
Buffer:_all
Takes a table , iterates through all number keys , appending each valid value to the end of the Buffer. In contrast to , this starts at the most negative key (down to ) and ends at the most positive index, continuing through any nil keys and includes non-integer number keys. (Note: despite more thorough iteration, the runtime of Module:Buffer.__pairs is almost statisically indistinguishable from that of ipairs in most cases. Details at Performance and require'Module:Buffer'.__pairs.)
A table value that has no metatable will have its contents iterated by this function before moving on to the next value. All other data types are processed by . 
By default, this ignores non-number keys unless  evaluates true. If so, non-number keys are processed after number keys. Keep in mind such keys are iterated in  order, though an order may be imposed by wrapping each pair in a table indexed at a number key.
If given a ''value'' = ''pos'' pair, defined as a number or number string indexed at a non-number key, then they will be passed as the  and  arguments for . Thus,


,true)}}


produces the same result as:






{{#tag:syntaxhighlight|Buffer:_(1):_(2):_(3) if variable then
   Buffer:_(4)
else
   Buffer:_'four':_('zero',1)--vs :_all{four='1',zero=1}; less redundant would be
end -- :_all{'four',zero=1}, but that doesn't demo string numbers Buffer:_'... done' --returns "1234... done" if variable evaluates true or "zero123four... done" if false|lang=lua}}





If a non-number key points to a value that cannot be coerced into a  then the pair may be treated as ''functionName'' = ''args'', when functionName matches a Buffer object function and args is not boolean. If args is such that  evaluates true, then this will pass the return of  to the named function; otherwise, the value is passed as is. 4
Buffer:_in
Passes any arguments to Module:Buffer to create a new Buffer object, sets an external reference to the parent Buffer and returns the child.5
This does not append the child to the parent. (See )
Also, be aware that Buffer parent references are . Thus, if you were to (re-)set a local variable that is currently set to the parent, such could trigger immediate garbage collection on the parent.
Buffer:_out
Joins a Buffer with  and appends result to its parent, which is returned. If no parent is found, this is a no-op and returns the same Buffer.
When given two or more arguments, this reads the first as {{--}}the number of :_out() operations to perform.6 This applies the first sep in  for the current Buffer, the second for its parent, the third for its grandparent, and so on.
If the last item is a , then any nil in sep-list default to ''table''[1]; any false mean "no-sep".7 The table may be the second arg (i.e. sep-list may be omitted). If it has other keys, then table[n] would apply instead of table[1], making these synonymous:
  and .
The number  is "magic" when passed as the first arg (even by itself), joining and appending to the same Buffer after it has been . This is the only method by which a Buffer in raw mode may lose that status. Parent references are preserved.
Buffer:_str
Joins a Buffer with  and returns the string.
This uses the same helper method as  to handle multiple arguments, with which, if provided, this creates a new temporary Buffer to which this appends the results of the number of generations specified by ops, with each ancestor in front of its descendants. This then performs one additional concat op using the sep at  and returns the result. If a parent-less Buffer is reached before ops, then the sep that follows its op number will separate the generations.
When no valid sep is given, this returns a string identical to what would append to the next ancestor, if those arguments were passed to Buffer:_out instead and one additional :_out() op performed.
However, because this does not actually append child Buffers to their parent, the result may differ where this would insert the sep at ops + 1 and Buffer:_out would place the parent's sep between it and its child instead.
Buffer:_cc
Nils all keys of the table referenced by  and unsets its metatable. If clear evaluates false, this simply purges the cache at .
If given a table to , this will duplicate all key-value pairs of copy into clear, cloning any table value recursively via . This returns the Buffer unless passed the number  as clear, which causes this to create a new table and return that instead. Passing  as copy is equivalent to passing the Buffer itself. If copy is not a table, then it will be set as the first item in clear as long as it is not false.
While this may resemble , there are several differences, namely that this:

Gives clear the same metatable as copy (or sets meta, if given) as opposed to a "clone" of the metatable.
Conserves  attribute (though empty strings may replace some nil keys

For example, given  as copy,  makes  equal 2, whereas  equals 0 (as of March 2015). This replicates length by filling clear halfway to the length of copy (the minimum needed to 'trick' Lua) and then setting nil every key that would not trigger recalculation. As a result, keys that would resize clear when set nil are left as empty strings. Such should be fairly rare; given tables representing every possible way to position a single nil key for all lengths between 2 and 32 (inclusive), only 8.39 percent of such tables would have its nil copied as an empty string instead. Also note that tables returned from  have length declared on creation instead, and thus won't have extra strings attached. The odds can be estimated using 
 
 
 
 , where 
 
 
 
  is the upper limit that an arbitrary nil key from copy of length ranging from 1 to 
 
 
 
 
  is imaged as an empty string.)


s values and iterates without invoking any __pairs .
Includes Buffer parent and raw attributes (stored externally)

To obtain the key-value pairs left as empty strings in the previous copy op in a table, simply call this again such with value such that rawequal(clear, copy) is true; call :getParent() on this table returns clear (useful after leeaving the local scope which referenced clear).
Buffer:_parent

''To skip generations without breaking the Buffer chain, see #global functions.
 

Resembling the reverse of , this calls  on the Buffer's parent with the arguments given and appends the strung ancestor(s) to the current Buffer, which is returned.
The parent is unaffected by this operation and may still be retrieved via  or re-appended again with this function.
Buffer:getParent

''Note that there is no 'getChild' method8


Returns parent Buffer, or, if none exists, creates a new Buffer and returns it as the adopted parent. As with , this does not automatically append the adoptive child to the new parent.
Pass a non-false value and this performs an op on the parent object.
If passed anything other than value (including nil), this requires that value names a function available to the parent object, which this calls and forwards the additional .
Pass only a table value which has no metatable and this forwards value to the parent which calls .
Given only a string starting with  and naming a parent function, this calls it on the parent without arguments. Any other valid singular argument appends to the end of the parent Buffer.9
Buffer:killParent
Unsets Buffer parent reference.
If passed any args, they are forwarded to the current parent, if one exists, via Buffer:getParent as a "parting gift". In either case, returns the current Buffer.
This is not necessary for  since Buffer parent references are weak. Rather, use this when it is desirable to assign a new parent via Buffer:getParent or, for example, to prevent the inclusion of an ancestor when passing  as ops for functions such as  (more useful when recycling Module:Buffer from another Module).
Stream mode
Buffer:stream
Switches a Buffer to stream mode. While streaming, the __call metamethod will append values to the end of the Buffer instead of the usual op.
Aside from that, there is only one other function: . Any args passed to Buffer:stream are forwarded to that function for a reason that should be evident when you finish reading this very short section.
No special action is needed to exit this mode. The normal call to string op is restored upon the use of any regular Buffer function or any operation which coerces the Buffer into a string (e.g. the .. operator).
Stream-Buffer object
Stream-Buffer objects accept only one argument which they append if valid. That is, the op is a streamlined version of  sans the pos and raw args, improving performance by about 50 percent (or, in one test versus .., over 2000 percent).
This also exploits  to append a series of string literals (and tables) with nothing between them (or only  if desired).
For example, both A and B will produce identical strings:






{{#tag:syntaxhighlight|local A = require'Module:Buffer':stream'A string of text may flow''with nothing between each string' 'or perhaps only a space'
   'or even tab and line-break charactersand continue to append individuallyfor use with a joiner'
local B = require'Module:Buffer':_'A string of text may flow':_'with nothing between each string' :_ 'or perhaps only a space'
   :_'or even tab and line-break characters':_'and continue to append individually':_'for use with a joiner'
mw.log(A==B, A:_str' ') true A string of text may flow with nothing between each string or perhaps only a space or even tab and line-break characters and continue to append individually for use with a joiner

lang=lua}}





Stream-Buffer:each
Appends an undetermined number of valid values to the Buffer object.10
If the above line gives you Déjà vu, that is because it is drawn from . However, unlike mw.html:wikitext, this does not stop at the first nil value.11
Also, despite a more nuanced handling of non-string objects, this is over twice as fast as its mw.html analog and should be preferred for appending multiple strings to (Stream-)Element-Buffers.
HTML library extension
Upon the first call to , Module:Buffer clones the , adding Module:Buffer's __eq and __concat metamethods along with a few additional functions.
Objects with this modified metatable are referred to as Buffer-HTML objects. Yet, though dressed in bells and whistles, they are only named with Buffer as an adverb since they lack most Buffer object functions.
In contrast, the Element-Buffer (returned by the function call on a Buffer-HTML object) is a true Buffer object with specialized "tricks" allowing complex structures to be built via both mw.html and Buffer object methods as well as through a builder that perhaps marries the best of both worlds.
Buffer functions for HTML
Buffer:_inHTML
Accepts the same parameters as  to create and return a modified mw.html object. As with , this does not append the child object to the parent Buffer and instead sets a Buffer-style parent reference.
An exception to the above is when chaining this to an Element-Buffer and such produces a selfClosing tag; when both conditions are met, this appends the tag and returns to the same Buffer.12
Unlike mw.html.create, if  has keys other than args.parent and args.selfClosing, it will pass for further processing through  (a cousin of  that handles mw.html functions). Moreover, if passed a table where mw.html.create expects tagName, this treats it as args instead.
Finally, this does not automatically set the mw.html.parent reference, making this an alternative to mw.html:tag
Buffer:getHTML
Available only after  is used the first time. 
Accepts the same arguments as , however this instead return the last Buffer-HTML object ("lastHTML") created, or, if available, the lastHTML passed to any of the following functions:




(except when passed )

Buffer:_html
Available only after  is used the first time.
This (re-)appends the last Buffer-HTML object to the current Buffer object. The raw and pos args are generally the same as those in .
When called with no arguments on an Element-Buffer, this appends lastHTML without string coercion. Be warned however that if the Element-Buffer belongs to lastHTML or one of its tags, such will cause an infinite loop, which can be avoided by passing an explicit nil to append lastHTML as a string.13
HTML object functions
Buffer-HTML objects may be used like any mw.html object. (In fact, merely replacing  with  in an existing Module should produce the same output.)
Most mw.html functions are unchanged, except , , and  are embedded in a wrapper function that checks whether they return a normal mw.html object. If so, switches the metatable to convert it to a Buffer-HTML object and sets a parent reference. 14
As a side bonus, the  may be used on Buffer-mw.html objects directly (no  needed).
Buffer-HTML object
Call this object as a function to return its  index15, which this converts to an  object, granting it the same metatable as regular Module:Buffer objects (as well as several additional "tricks") and assigning the Buffer-HTML as its parent Buffer.16
This takes one argument which is forwarded to its Element-Buffer. Tables pass to the specialized HTML builder . All other #valid values are appended to its Element-Buffer via .







You cannot chain call regular Buffer functions on a Buffer-HTML object; however, since mw.html functions cannot read Buffer-style parent references, modified versions of methods that return the parent Buffer are available to Buffer-HTML without having to call into the Element-Buffer. For convenience,  is called automatically prior to the op, though after the lastHTML reference has been set for .17


















{{note label|html-0-out

|{{note label|html-0-str|0

 if passed  as the first argument, these do not redirect the self-action via :allDone(), however, these always return a Buffer-HTML object (think {{luaself|pre=Element-|:done|args=(0)|plain=y}}). {{note label|html-0-out-perm

|For :_out only, the "magic" number zero permanently consolidates Buffer-HTML.nodes (whether or not converted)}} just like :_out(0) on a normal Buffer except it would not unset raw mode on an Element-Buffer.}}}}  






In addition to the above, global functions may be available to Buffer-HTML if enabled; these functions are the same for all Module:Buffer objects{{--}}i.e. the self action is never redirected.
Element-Buffer functions
Element-Buffer object
Sharing the same metatable as with regular Buffer objects, Element-Buffers concatenate the same way when called to produce a string analogous to the JavaScript DOM "innerHTML" property. In other words, when strung, it is generally the contents of the Buffer-HTML object without the "outerHTML" or tag.
There are exceptions to this "innerHTML" behavior. For instance, as appended to another object via , an Element-Buffer and its Buffer-HTML are interchangeable (though appending the former via  only includes the inner result).
Also, using the concatenation operator  on an Element-Buffer includes its tag in a manner depending on if it is selfClosing:

For most tags, the conjoined string is placed inside the tag, e.g.  returns .
For selfClosers, the  op redirects to its Buffer-HTML, e.g. insert  in the above example before  to produce .





You may use most Buffer object functions normally, however if there is a Buffer-HTML version, it instead behaves as though chained on the outer HTML object.18 You may also chain any mw.html object function. Unless otherwise indicated, such returns a wrapper method that merely redirects the self-action to the outside Buffer-HTML.19
As a final note, Element-Buffers are in permanent raw mode since it is expected that some mw.html method (e.g. :tag and :node) may or will append non-string elements.20
Element-Buffer:done
When passed nothing, this should behave just like  as called the "outer" HTML object{{--}}returning Buffer-HTML.parent, if available, or Buffer-HTML if not.
However, this has been re-designed to accept , the number of :done() operations to perform. Thus,  is equivalent to .
Pass  (zero) as dones to return to the Element-Buffer's direct HTML container.
Finally, keep in mind that Buffer-HTML objects use the original mw.html:done (albeit in a light wrapper).
Element-Buffer:tag
This uses the same helper method as  to handle arguments and produce new Buffer-HTML objects, selectively passing args to  when it contains keys not used by .
As may be expected, this differs from Buffer:_inHTML in that this actually appends the tag and will set a mw.html-style parent reference. This also lacks the other function's "auto-done" feature for selfClosing tags.
As with the other Element-Buffer remake of an mw.html method, the features described here do not apply to the version used by Buffer-HTML objects.
Element-Buffer:_add
Takes a table as its only argument. This then thoroughly iterates all number keys from lowest† to highest using this module's custom __pairs method. Most values append as wikitext if valid. If a table is indexed at a number key, this recursively iterates the table before moving on to the next key.
After processing all number key-value pairs, this then iterates the other (non-number) keys. For those naming a core Buffer object function, this selectively unpacks  in a manner described at  when that function is passed the nanKey parameter (excepting that this does not read numbers as pos, i.e. treats them the same way as strings).
This also accepts keys naming HTML and global functions as well as mw.html arguments. Thus,  appends a BR tag after the text and  appends the BR before the text. Note however that how this handles args for such keys depends on the particular function or argument named:





args.argName

 The effect of passing args with keys such as args.selfClosing and args.parent is the same as though args were passed to . This also takes one additional arg, i.e. args.tagName, which value replaces the original tagName of the HTML object (or, if false, removes the tag). Note that these are the only keys for which a boolean arg would result in an op. (For Buffer object functions that do not no-op when passed only a boolean, place the boolean in an args table for unpacking.)
args.cssName

 A non-number key and value pair may default as the cssName and cssValue parameters for  when the key matches none of the three argName keys nor the name of any available function for Buffer and mw.html objects. This sends non-boolean cssValue though  prior to forwarding it to mw.html:css. Because this is the default, any typoed key goes to mw.html:css as cssName. Names of functions not yet loaded also end up there. For convenience, any _ character in the key string is automatically substituted with the - character; thus  is equivalent to . The form  also works if sacrificing performance to reduce ambiguity is your thing (or to clear a previously set value; see example at args.htmlFunction for more details). 
args.tag†


 Set the key args.tag to a string and this calls  with it as the tagName argument. This then raw inserts the returned mw.html object ("tag"), emulating the effect of  minus parent references, which are unnecessary. Pair the args.tag key with a table value and this calls mw.html.create with  as tagName (or nil if #invalid), appending it as described above for string values, but also pointing tag.parent to the Element-Buffer's parent as well as temporarily setting the tag as the parent Buffer of tag.nodes. This then treats tag.nodes as a pseudo-Element-Buffer, recursing tag.nodes as "self" and the table as args, though only iterating keys not equal to  (or less).[*] Note this appends normal mw.html objects. That said, most Buffer functions named in args-list should still work as though the tag and tag.nodes were Buffer objects.21 Upon completing a recursive iteration for args.tag, this checks if the tag is selfClosing, in which case, this saves memory (which can improve performance) by setting tag.nodes to nil. Likewise, if its tagName property evaluates false, this nils tag.styles and tag.attributes. Such presumes those properties will not be modified afterwards, so use mw.html:tag outside of Element-Buffer:_add if such is not the case. 
args.done†


 Similar to args.tag, this treats the first index of the table as the ops argument of . After calling that function, this then iterates all subsequent keys in a recursive call on the Element-Buffer of the Buffer-HTML object returned.
args.allDone


 Similar to the previous two, except that the first index is not used as an argument; thus, the entire table is iterated. 
args.globalFunction‡



 If the global functions have been loaded and a key matches one, this calls the function with the first two arguments ed from the paired args-list table. This then recursively iterates the list, excluding keys less than or equal to , with whatever object is returned as self. However, if the returned object has a metatable and object.nodes exists, the self will be object.nodes instead. Because  takes only one argument, args._B only unpacks the first index and starts the iteration after that key. If neither of the first two keys evaluate true, this assumes the paired value is a string for use as the name argument for the function matching its key.22 In that case, the current call stack's self (an Element-Buffer or tag.nodes if this was called indirectly) is ''self' for the global function.
args.htmlFunction


 If args.key matches an  that does not have its own args section, this checks if the associated object is table. If not a table, or if object.nodes evaluates true, this calls the mw.html function with the object as the only argument. For table objects without an object.nodes, this iterates the table (non-recursively), repeatedly calling the named mw.html function with one or two arguments depending on key's type in each loop. Non-number key-value pairs are both passed as arguments. For numeric indices, only the value is passed. Boolean values are a no-op. Unlike with most implementions of Module:Buffer's __pairs, this first loops through non-number keys, followed by number keys (still ordered from lowest to highest). Thus, something like  is equivalent to , setting then unsetting the width attribute and returning the Element-Buffer for a net no-op (though the practical purpose of such is a mystery for this developer). For args.css only, this auto-replaces underscores with hypens for string keys{{--}}i.e., you may save four keystrokes/pair by typing css_property = instead of ["css-property"] =. This does not apply to strings indexed at number keys.


{{note label|skip1|†

 Unlike with tables passed directly, recursive iterations for functions marked with † start at the smallest number greater than  instead of negative infinity. Such was decided for performance and coding simplicity on the reasoning that any practical purpose for indexing at a key less than one may be accomplished by instead indexing it at any of the trillion or so floating point values between one and two{{--}}e.g. .}} 






Loadable convenience extensions
The methods here are loaded on demand or depend on subroutines which need initialization.
Whereas most Module:Buffer methods are built for performance, these methods perform tasks which generally require less CPU usage if handled outside of Module:Buffer (i.e. via local variable declarations). That said, they can greatly simplify the structure of the modules which employ them by doing, in a fluent manner, many tasks which may otherwise force an awkward interruption in Buffer call chains.
Global functions
Methods such as  and  traverse a node tree in only one direction. While fine for returning to an ancestor, they do not provide navigation to a non-ancestor (often necessary for templates with co-dependent parameters). Yet, repeated breaks in call chains to set local variables for several nodes of the same branch can look choppy if not confusing for nodes many generations removed from its declaration statement.23
Templates with several conditionally-appended nodes with similar, but not identical, parts may present another conundrum for coders who must decide between having awkward call chain interruptions to store potentially repeated components as local variables or constructing a somewhat redundant module that is more susceptible to maintenance errors by future editors who may patch one code segment but miss the sibling buried within a convoluted nesting of .
This module's global functions and added syntactic sugar for the _G object were formulated to simplify such node trees with multi-conditional or repeating structures by providing concise in-chain variable declaration. The extension is enabled by passing your global table to the module{{--}}either in the initial call to require'Module:Buffer' (more instructions in that section) or to  which forwards arguments to Module:Buffer. Global function are not enabled by default for various reasons:

Most templates are one-dimensional (i.e. contain few if any nested conditional statements) and thus would not benefit from these methods.
Loading them to the Module:Buffer meta index means more items that must be sifted through each time a specific function has to be retrieved.
Lua checks the global scope last; thus retrieving values from that scope takes longer than it would if they were stored in the local scope.
Excess use may clutter the global scope enough to slow access to basic Lua functions (e.g.  or ) even after Buffer methods are no longer used.

It should be mentioned however that variable retrieval even even in a relatively cluttered global scope is fairly trivial. In fact, early versions of Module:Buffer used globals extensively (and actually had no locals declared before the final return, or rather the entire module was just one long return statement). In contrast, the current version nests many  blocks to limit scope size. Yet, , a core function which has changed little, is only a modest 10 percent faster than itself in the last unscoped version (not published); then again, perhaps the benefit of scope dieting has been masked by much greater total number of variables required by new features?
Buffer:_G
Pass name and save to assign the object passed as save to a global variable via .24
Pass only name and this substitutes self for save to assign the Buffer object to _G[name] instead. Give an explicit nil as save to unset a global. This returns the Buffer object as well as any argument given after name.
This is a no-op when name is nil or a boolean, or, when save (eventually) evaluates true and  also returns true. 
If the named global already exists, this "backs up" the old value by moving it to the meta __index of the global table, setting a new metatable if none exists.25 Retrieving the old value requires unsetting the new one via  (more details in that section). If overwritten a third time, the first value is discarded and the second takes its place in the back up.
If a metaglobal variable exists but the global is nil, this sets the global without unsetting the metaglobal (i.e. does not back up a nil global). An exception is when this is given an explicit nil as save and only the metaglobal exists; thus, passing nil twice for the same name, unsets the key in both the global table and its metaindex.
Buffer:_R
This  with the global table as the first argument and name and save as the second and third, respectively, returning the Buffer object for call chaining. The following demonstates how, by combining Buffer:_R and Buffer:_G, the global variable v can be declared, backed-up and replaced, replaced without back-up, restored from back-up, and removed completely:






{{#tag:syntaxhighlight|require'Module:Buffer'
  (_G,'v')           -- call module with global functions enabled and declare new buffer as v
  :_'A'              -- append 'A' to the returned buffer
  :_G('v', 1):_(v)   -- _G.v = 1, shift old value (the buffer) to metaglobal.__index
  :_R('v', 2):_(v)   -- _G.v = 2, discard old value (1) without back-up
  :_R'v':_(v)        -- unset _G.v, which now defaults to metaglobal.__index.v (the buffer)
  :_G('v', nil)", "  -- remove back-up and join the buffer with a separator
..' and '..tostring(v)-- returns 'A, 1, 2, A12 and nil'|lang=lua}}





 This is a no-op if name is nil or a boolean. 
Note that Buffer methods use a local variable new_G as a proxy for the global table _G; though not a global index, the string  is a "magic word" that changes the destination for future save for this and Buffer:_G.
Pass a table as var (same place as save) to set as the new new_G. Any table such that  is treated as a (former) new_G object. This  of former proxies and  with the  __call method on non-new_G tables. Then, this, if third parameter metaindex equals:

nil {{--}} backs up the current proxy as the metaindex of the next (though this no-ops if var equals new_G to avoid cyclical indexing).
false {{--}} leaves the metaindex intact (replacing the current proxy without back-up)
true {{--}} unsets the metaindex of the next proxy
any other value {{--}} sets that value as the metaindex of the next proxy. (Note new_G._G is not set until it is returned by )

To omit or to pass nil/false as var has the same effect as . Pass true instead and this treats it as though passed as metaindex, creating a new proxy without backing up the incumbent.
Buffer:_2
This returns the value indexed at key name in the global table. If it does not exist, this forwards both arguments to  and returns the saved value (which may be itself).
In other words,  is roughly equivalent to .
The string  will return the Module:Buffer local variable [[#new_G|new_G]], used as a proxy for the global variable _G. Given more than one argument, this forwards arguments to  to assign another proxy global before returning the (newly-deposed) proxy. This then sets new_G._G to the original _G object for call chaining. (See § chain call in _G object).
Buffer:_B
Takes only one argument and returns that argument.
Assuming the only X declared is  and new_G equals _G, then  and  are equivalent.26
When passed a variable that does not exist, this returns the Buffer nil object:
Buffer-nil object


The Buffer-nil object is unique. Calling this as a function returns nothing (in contrast, calling an empty Buffer object returns an empty string). This does however have the Module:Buffer __concat metamethod, which treats this the same way as any invalid object (i.e. ignores it).
Appending this via  or  has the same effect as appending nil. Passing this to  returns nil instead of the string 'nil'.
The only real Buffer method in its meta __index is , however, any non-numerical key string retrieves a function that only returns the Buffer nil object for call chaining. In a sense, you can think of  as an  block around the following chain that ends in the next :_B().
If , the clone will be a normal Buffer object.
_G object
The first _G variable passed to this module is given a __call metamethod that self-s and returns in a manner that depends on whether it was called directly or from a chain.Saving a new_G object globally via a chain call can prevent conflict. The follow example has a hypothetical "Module:X" that may overwrite globals declared by your module or unwittingly discard your new_G when it passes _G to Module:Buffer (passing _G to this module resets new_G to the global table even when the global functions are already enabled):






{{#tag:syntaxhighlight| return require'Module:Buffer'(_G)--Return before require to show intent to return a Buffer object; chain cannot be broken
   :_R(frame.args.title and     --store values outside global scope if invoked with title parameter
       'new_G')
   :_G'myBuff'                  --save current Buffer in new_G
       :_2'new_G'               --retrieve new_G
           :_G'my_G'            --save new_G as global my_G
           :_G('t',             --save title object as my_G.t for later re-use
               mw.title.new(frame.args.title or frame.args.page)
           ).myBuff             --go to my_G.myBuff (my_G lacks the Buffer:_2 method, but doesn't need it)
   :stream(my_G.t.exists        --just arbitrary code to show how in-line storage may be used without breaking the chain
           or warning(my_G.t),  --local function warning() declared before return
       require'Module:X'.main(my_G.t),
       my_G.t.isSubpage and subpage(my_G.t),
       ... )
   :_R('new_G', my_G)           --set my_G as new_G again and have the new_G from Module:X as its metaindex
   :_(frame.args.detail and 
       my_G.info
           :_(frame.args.detail)--append Buffer object from Module:X's new_G.info if args.details and it exists; append detail param to result
       or my_G.summary)         --just append summary from Module:X if not invoked with detail param.
   :_B(t and                    --use global t as a shorthand for "if not frame.args.title then" (t only declared a global in line 2 if no title given)
       myBuff
           :stream(frame.args.page,
               frame.args.details2,
               mw.html.create'br',
               require'Module:Y'.main(frame))
       or my_G.myBuff           --place results in a table if invoked with title param (alternative chain call branches within Buffer:_B)
           :_inHTML'table'(_addArgs)
           :_parent()
   )

lang=lua}}





 This module conserves any pre-existing metatable and alters no metamethod other than __call.





direct call
_G( k, v )
_G'string' When called, the _G object self-sets any string passed as k with whatever is passed as v. This returns v, or nil if omitted (unlike with rawset, an explicit nil is not necessary to unset a variable with direct calls). Note that k must be a string to declare or unset a global in this op. Tables passed as the first argument are treated as though this were executed via a call chain (discussed shortly). Passing k which is not one of those two types will throw an error.
chain call
chained-object:_G( k, v )
chained-object:_G'string'  When used in a call chain, this rawsets the key-value pair in the chained object and returns that object. The _G object may chain itself when returning _G is desired for another op instead of v. In contrast to the direct op, the in-chain op will index non-string k values. Moreover, this only unsets object[k] when passed an explicitly nil v. If v is omitted in-chain, this uses the chained object as the missing argument; thus, (chained) object:_G'string' has identical effect and return to _G('string', object).





The same __call method is given to new_G objects created by Buffer:_R, however the direct call only works if its metaindex is the _G object. Any table such that table._G points to the _G object may chain save to itself regardless of metaindex.
Though the behavior of the chain op when v is omitted may be a dead ringer to that of Buffer:_G when save is omitted and new_G is the chained object, mind that the Buffer object function sets keys in new_G variable rather than the chained (Buffer) object; in other words, this is unaffected by Buffer:_R reassigning new_G to another table. Also, this does not have the back up behavior of Buffer:_G.
Buffer-variable object
Buffer:_var
Raw appends a Buffer-variable object, which may appear as a different value each time the object (or its container) is converted to a string. The following contrived example demonstrates most features of :






{{#tag:syntaxhighlight|local H, sep = require'Module:Buffer':_inHTML('div',{'Heading ',_var={nil,'odd','even'},color='blue',['text-decoration']='underline'})
   :_out():_html(true):_html(true):_html(true)
sep = H:_in'This is ':_var():_' - ':_var'A':_var(3,-1):_'\n' return H:_in(H(sep)):_(sep)
   :_'math:':_var():_'+ 5 =':_var(true,5):_';':_var():_out(0,' '):_var(false):_' - 1 = ':_var()
--produces: Heading oddThis is odd - A3 Heading evenThis is even - B2 Heading oddThis is odd - C1 Heading even This is even - D0 math: 0 + 5 = 5 ; 5 - 1 = 4 --|lang=lua}}






Initialize a Buffer-variable object by passing as var a:

number - which, when strung the first time, appears as that number and reappears as var + change the next time it is strung.
string - that transforms into the next ASCII character via .
table - to return the first (non-nil) item, then the second, and so on as determined by , looping back to the first item after reaching the last. (Note the change argument does not apply to table-based Buffer-variables.)
custom function - to be set as the _build and __tostring method of a variable-object, though instructions for coding such functions are beyond the scope of this manual.

Re-append the same variable object by passing  as the only argument. For non-table-based variables, you may specify change to append a sister object which transforms the value at the rate specified. Changes are cumulative. Thus, if the original is re-strung after a sister, its value will differ from that of its last appearance by the sum of the original and sister rates and vice versa.
Apply a change without appending a new variable object to the Buffer by passing . The shift is effective immediately and may affect previously appended variable objects not yet finalized. Pass only false (i.e., omit change) to produce the same effect as stringing the original once. Note that the false-change is the only change table-based Buffer variables will honor.27
Pass nothing to append a version which simply repeats the result of the last stringing. While generally identical in effect to the object generated by :_var(true, 0), the Buffer-variable will return nothing if strung before any of its sisters.
 
 If passed an explicit nil as the first argument, this is no-op. If passed a boolean before any Buffer-variable has been initialized, 
 this is also a no-op. Note that any op disables future caching at {{luaself|.last_concat|plain=y}} for all Buffer objects 
 in your module (and in any module which may require it).
 
 {{anchor|library}}
 ===String, mw.ustring, and mw.text libraries===
 
 ====Basic usage====
 
 {{code|lang=lua|Buffer:functionName( ... )}}
 
 You may directly chain any function from the following libraries on Buffer objects:
 
 {|
 |{{collist|3|colstyle=width:49em|
 * {{luaref|String library|string|y}}
 * {{luaref|Text library|mw.text|y}}
 * {{luaref|Ustring library|mw.ustring|y}} }}
 |}
 
 
 Functions from these libraries added to the Module:Buffer metatable on-demand and placed within a wrapper method 
 that strings the Buffer object for the first argument and then forwards the remaining arguments.
 
 Thus, the following are equivalent: {{code|lang=lua|Buffer:nowiki( ... )}} and {{luaref|mw.text.nowiki|args=tostring(Buffer), ...}}
 
 If a name exists in both the string and mw.ustring libraries, the string version takes precedence. 
 You may [[prefix]] the letter ''u'' on any mw.ustring function{{--}}e.g. Buffer:ulen returns the number of unicode characters
 and Buffer:len returns the number of bytes.
 
 Buffer:gsub and Buffer:ugsub have a slightly different wrapper which substitutes the repl argument of  and  when it evaluates false or is omitted with an empty string (otherwise the originals would throw an error). This saves a few keystrokes when removing characters via  as opposed to . All other arguments are handled the same as with the other on-demand methods.
Library functions which take a non-string as the first argument are not supported.
Empty Buffer interface
To obtain the first return value as a Buffer object (as opposed to whatever type the original normally returns), simply chain the imported method immediately after creating the new Buffer via Buffer:_in. Only empty Buffer objects which have a parent object will append the result of their parent in this manner.
This syntactic sugar allows two things:

For appending additional objects after the op via Buffer object methods.
For chaining multiple  methods not chainable to strings{{--}}e.g., this: 


vs. the following which has the same order of operations albeit harder to see: 
 






Special case: Element-Buffer

  The 'empty' behavior is different when chained to empty Element-Buffer or an empty child Buffer of an Element-Buffer. Library methods chained to an empty Buffer which parent is an Element-Buffer object will instead string the grandparent Buffer-HTML object for use as the first argument before appending the result to the new Buffer. This interface is provided because Buffer-HTML objects, which are not true Buffer objects, are unable to load these functions, making this the only chainable option for Scribunto methods that includes the outer tag of non-empty Element-Buffers. Chained on an empty Element-Buffer, these methods will string the Buffer object which created its HTML tree via 28 and append the result to the Element-Buffer.Compare the comment and source:






{{#tag:syntaxhighlight|----= Result: ===> This is just a quick example to demonstrate a neat concept: Notice how the same object is strung which allows you to recycle boilerplate text. 
 3 is 1 added to 2. Though this is not really realistic to be fair... Edit: not realistic at all I hope such is much to your liking. ----= Source: ===> require'Module:Buffer'
   '%s is %s to %s.'--A
   :_inHTML'div'():format('Notice how the same object', 'strung which allows you', 'recycle boilerplate text')
       :tag'p'():format(3, '1 added', 2)
       :done()
       :tag'span'():format('Though this', 'not really realistic', 'be fair..')
           :_in():sub(21, 29)
               :_('\nEdit:', 1)
               :_'istic at all'
           :_out()
       :done()
       :_parent()--B
   :_out'\n'
   :format('This', 'just a quick example', 'demonstrate a neat trick',--A
       'I hope such', 'much', 'your liking')--B
   :gsub('trick.', 'concept:\n')|lang=lua}}










Modified  operator
All "true" Buffer objects{{--}}e.g., the regular, stream, and element varieties{{--}}share the same . Some Buffer-like classes, namely s and the , also have this same metamethod.
The extended  operator does not append to Buffer objects. In other words, Buffers generally remain the same as before the op excepting those effects that apply whenever Buffers are strung (See , , and ).
with non-tables


Any non-table value may be joined a Buffer object with the concatenation operator  without error.
With the exception of Element-Buffers (which are a special case), the op passes each object, ordered left-to-right, to  which inserts validated items in a new table, which this returns through .
Concatenating an invalid value and a Buffer has generally the same effect as  unless such involves:

the Buffer-nil object {{--}} which produces an empty string (instead of nil)
Element-Buffer objects {{--}} which returns the string of the parent Buffer-HTML

with tables


The same general operation applies for tables as with non-tables{{--}}i.e., validated values are inserted left-to-right into a new table to be joined by table.concat. In fact, tables which have a metatable (including Buffer objects which are not an Element-Buffer) are forwarded to Buffer:_ and processed the same way as non-tables.
Given a table for which  returns nil or false, this instead forwards the table to , which iterates every value indexed at a number key in sequential order, inserting those which are valid in the new table.
As a reminder, Buffer:_ validates tables with metatables that lack a __tostring method through table.concat, which throws an error on sequences containing one or more value that is neither a string nor a number. Such accounts for nearly all cases of breaking errors involving this op.
Note that the valKey parameter of Buffer:_all is not triggered.
for Element-Buffers



To recap and expand upon § Element-Buffer-object, the behavior of this op depends on whether its parent Buffer-HTML is  or if the other value is also an Element-Buffer. Also, the final result always includes the outer HTML object (i.e., the tag) in some manner.
For Element-Buffers of "open" tags, this op creates a table with a metaindex that references the parent of the Element-Buffer. The table is then effectively a "mirror" of the parent Buffer-HTML object except that it contains an empty table at table.nodes{{--}} the index of the Element-Buffer within its parent. This then populates the mirror's inner table with the string of the Element-Buffer and the other value, validated left-to-right, in a manner not unlike what this does with the temporary table it creates when concatenating non-element Buffers to another value. This then returns the mirror table through the __tostring metamethod of the mw.html library, yielding a string which resembles that of the parent tag but with value inserted in front of or behind the original inner text depending on whether value was to the left or right of the .. operator, respectively.
When the selfClosing property of the parent evaluates true, this operates on the parent instead of the Element-Buffer{{--}}i.e., the resulting string will have value on the outside as opposed to within the tag (placing it inside would be pointless since selfClosing tags do not show inner contents).
If both operated objects are Element-Buffers, this mirrors the parent of the first. The inner table of the mirror is then populated by inserting the string of the first Element-Buffer followed by the string the parent Buffer-HMTL of the second. The resulting string would be as though the parent of the second were the last node of the first parent. Note that this Element-to-Element rule does not apply when the first Buffer belongs to a selfClosing tag (in which case, this behaves as though the selfClosing parent were to the left of the operator, returning a string with the selfClosing tag inside the tag of the second Element-Buffer in front the latter's inner contents.)
Finally, this combines an Element-Buffer and a table value which has no metatable by passing the table as args for  with the mirror of the Element-Buffer as the "self". This avoids permanently changing the parent Buffer-HTML by setting a new table at table.attributes or table.styles in the mirror the first time methods such as , , , etc. attempt to access those tables, copying the original's via the recursive form of . Note however that permanent changes may be made to other objects whenever methods such as via  or  are keyed to navigate beyond the mirror or "sandbox".
require'Module:Buffer'.__pairs

Returns two values: an iterator function and the table. This is intended for use in the  for.
One distinctive feature of this pairs method is that it splits keys into two groups: s and non-numbers. This indexes each group of keys in its own "map" object, traversed by its own iterator function{{--}}i.e, iterating both sets of keys requires two separate for loops. Numeric keys are served in an orderly fashion as with  except that those which are negative, non-consecutive, and non-integer may be included. Moreover, this can find some keys paired with explicitly nil values. Take a moment to look at the following tables X and Y:






{{#tag:syntaxhighlight|local X = { [5] = 5 } local Y = { nil, nil, nil, nil, 5 }

lang=lua}}





These tables are indistinguishable to  and  (ipairs iterates nothing and pairs yields only one key-value pair for either table).
While this module's __pairs method also gives only one pair for table X, it loops all five explicitly declared indicies for table Y, as shown in the console input below with Module:Buffer as p:






{{#tag:syntaxhighlight|for k, v in p.__pairs{ [5] $=$ 5 } do mw.log(k, v) end 5 5 for k, v in p.__pairs{ nil, nil, nil, nil, 5 } do mw.log(k, v) end 1 nil 2 nil 3 nil 4 nil 5 5|lang=lua}}





Detecting nil values is actually a side effect of trying to improve performance by avoiding type checking on some keys when sorting them (see stage one of § Mapping process), but, if pressed for a practical use, let's just say this can be a means to force the inclusion of keys from the table's meta __index or to allow keys to be unset without excluding them from the iteration.
The flag argument selects the iterator method returned for that loop. When flag is an explicit nil or omitted, this returns an iterator for number keys. If given any non-nil flag (i.e., false or any value that evaluates true), this returns a method for looping non-numeric keys. Because both sets are mapped at the same time, you may avoid a redundant mapping op in a subsequent loop by passing an explicit nil or false as flag{{--}}i.e., omitting flag or passing true indicate that re-mapping is desired.
This automatically selects certain tables for "mapless" iteration. Typically, mapless differs from mapped only in that it uses fewer server resources, though, as explained in the next section on mapping, it may "miss" keys in some cases.
Mapping behavior may be modified or extended by ext. To disable mapless iteration for the table, you may pass false as ext. If not nil or false, ext must be a pairs method that takes the table as its only argument and returns a function that may iterate its keys for mapping purposes. Note that re-mapping avoidance via flag does not apply if ext is explicitly given, though a nil ext does not disqualify a table from mapless iteration. 
Mapping process
Tables are mapped in two stages.
The initial stage is a  which inserts integers between  and  in the number key map. Because nothing is checked in this step, this may map keys which the numeric map iterator would pair with nil values or with values from the table's .
The second stage explores the table's keys with an  and  as the default expression-list, or, if ext evaluates true, the expression returned by . This ignores keys already mapped in the first stage and checks if any unmapped key is a number before indexing it in the appropriate map group. Upon completion, if any new number key were found in the second stage, this runs the numeric map through . No order is imposed on the non-numeric map.
Alternatively, a table may qualify for "mapless" iteration if  is not nil, and  returns nil. If either flag or ext are not nil, or if the table was previously mapped, such permanently disqualifies a table for mapless processing.29
As a side note, if mapless numeric iteration occurs, this returns . In other words, you may use  to confirm that the table qualifies for mapless iteration when it has a third explicit return (for debugging).
Iterators
One of four functions may be provided in the  returned by this pairs method, depending on which group of keys (numeric or non-numeric) and which iteration process (map-based or mapless) is indicated.
When key is nil or unspecified, map iterators will return the key object referenced by the first index of the relevant map along with the value it indexes. If passed the first mapped key, these iterators then return the second index mapped, which if passed in turn may retrieve the third and so on until the last mapped key has been served.
For numeric iteration, the mapless method returns  when key is unspecified. If a key is given, it returns  unless key is greater or equal to the length of the table, upon which it returns nil. For non-numeric keys, the mapless "iterator" is actually a no-op (empty) function which takes nothing, does nothing, and returns nothing{{--}}provided only to prevent an error when the for loop expects a function.
As mentioned (using different words), key-value pairs are served independently of whether or not  exists and retrieved without using .
For example, take a look at table x as declared in the following statement: . Table x has a length equal to 8. With ipairs, the for loop stops after the first pair. In contrast, this module's __pairs method will loop all 8 keys declared{{--}}i.e., (1, 1), (2, nil), ... (7, nil), (8, 8). That said, this only iterates two keys if table x were declared as  instead even though such is indistinguishable to Finally, the loop would continue to include any keys set to nil after the mapping process.
You may assign these iterators to a local variable to use them directly. If an unmapped table is given to a map iterator, it will forward the table to this pairs method for immediate mapping. Though no map table is produced for the mapless iteration, the pairs method does cache the length of the table at a map reference, which the iterator compares against key to determine when to stop. Unlike the map methods, the mapless iterator does not call the pairs method when such has been bypassed and instead compares key to the value returned by the , which may be unstable if the loop includes code that sets or unsets indicies within the table. Also, the mapless method will throw an error if given a table that has been mapped (when it attempts to compare key to a map object).
Appendix
Tips and style recommendations

If joining Buffer with a string immediately after :_'text', place a space between 'string' and the separator and use double/single quote marks to . (i.e. :_'text' " " instead of :_'text'{{`}} ' or :_'text'(' '))
Saving Module:Buffer locally, e.g. local Buffer = {{luaref|require|args='Module:Buffer'|plain=y}}, though fine, is often unnecessary since all Buffer objects can create new buffers via .

For 

Treat  as though it were a  op. Wrapping strings with unnecessary  is akin to .
Most uses of  can be avoided through careful planning with the  argument. That said, the performance decrease from raw is unlikely to be significant for modules transcluded on less 100,000 pages. In short, reduction in server load from avoiding raw may not be worth it if such makes the code harder to maintain.
To insert an empty string as a placeholder for a separator without setting , pass a table containing only an empty string, like so: .
Raw appending a non-table is pointless since no other Scribunto type can tostring differently afterwards. However, this developer believes you are smart enough that  is a waste of server resources. (Such checks are why  takes twice as much time to append a list of strings as  despite their near-identical roles in an Element-Stream-Buffer).

For  and 

Something like  will use variable A as the parent's separator, or B instead if A is nil, or C if both A and B are nil.

For 

Appending values in multiple locations is one of the primary reasons why the nanKeys argument exists. While passing a boolean directly will cause an error, you can do something like...



this:}, true)|lang=lua}}
 
versus: .
 



For 

If the table reference passed as  was appended raw in multiple positions, this is akin to performing  at all positions simultaneously. (May be easier than trying to come up with a  pattern)
Inserting a named empty table is raw as a placeholder to be populated later via this function may be easier than calculating pos argument of .

'''For  '''

When appending simple HTML structures, something like  is roughly 6 times more efficient than {{luaself|:_inHTML|plain=y}}'br':_out(), at least in terms of server CPU usage. (Though  is 25 and 4 times more efficient than both examples, respectively.)


Buffer:_inHTML is slower on the first run due to initialization. After the first run, the efficiency of Buffer:_inHTML improves by a factor of 4 (though not quite as fast as the other two).
 

Performance
Examples
Notes
Non-literal interpretations of the source code (that is, more opinion than fact) are provided here to offer additional clarity. Overly technical details may be found here as well when including such caveats appears more likely to confuse than help those advanced-but-not-quite-fluent in Lua.
Though commentary was deemed unnecessary for the , Scribunto methods are "safe" for beginners and offer extensive in-code help in the form of  messages. In contrast, Module:Buffer methods, intended for intermediate-advanced coders, are built with "safeties off"{{--}}i.e., minimal type filtering and custom error warnings{{--}}to maximize performance (though the rare  may be found in methods which seldom need to be used more than once and where the default error message seemed exceptionally vague or difficult to trace).
See also

Module:Escape, a lightweight metamodule for customized string character escaping

{{#ifeq:|sandbox | |
}}"
Category:Lua metamodules



For your convience, the self operator  and  are interchangeable when used on the Module directly, though the self-op is required for nearly all other interactions with objects created by the Module.↩
Using  prevents future caching on all Buffers, though Buffers which already unmodified Buffers will continue to return their cached version↩
Appending a value "raw"{{--}}i.e. without string type coercion{{--}} sets "raw mode", which incurs a performance penalty because future tostring ops would have to re-validate every value in the Buffer via  to insert them in a new table before passing that to table.concat (vs. passing itself directly). That said, re-stringing a raw Buffer is still usually several times faster than using the  op to join an equivalent number of strings. (See #Tips for ways to avoid using raw)↩
In other words, if args is a string or a table without [1] set, it will be passed as the only argument. Further note it is not possible to pass a ''functionName'' = ''args'' pair where args is numerical since such would be read as ''value'' = ''pos''. Finally, passing a function type as args will throw an error message.↩
There is no 'getChild' method. If a child needed after returning to the parent, set it  or use  prior to returning or it may become irretrievable. (No,  did not get lazy. Rather, this allows  on children with no further purpose.)↩
For #performance, the first arg is not type checked but read as ops only when multiple args are present (or if it is the number 0); i.e., Buffer:_out(2) uses 2 as a separator. To append to the Nth ancestor with no separator, use Buffer:_outs(''N'', nil).↩
Empty strings would produce the same output as false, however, Lua string literals create objects that take up memory until garbage collected.↩

In other words,  is shorthand for , however,  simply appends "match" to the parent. Note that you may still call  on a parent via .↩
This is no different than calling the Stream-Buffer object directly with each item in the ; however, after noting how numbers and variables (too shy to skinny dip without parenthesis) could look rather odd swimming fully clothed in a stream of naked strings, this was made for those whose aesthetics prefer  over . As a side note, it is best practice to pass number strings instead of number literals (i.e.  instead of ) as such improves performance and is perhaps more aesthetically pleasing in this mode.↩
If you want something like  such that varName is shorthand for an  statement that appends varName and 'string2' when the former is not nil, use  instead.↩
That is, Element-Buffer may be shorthand for  when planning to continue using Buffer object functions. This "auto-done and back" for selfClosing tags does not apply to non-element Buffers in order not to encourage the use of Buffer:_inHTML for simple tags as per #Tips and style recommendations.↩
 serves a similar role, but appends Buffer objects rather than HTML objects. Also Buffer-HTML:_parent only appends the string form of its ancestor object(s).↩
Buffer(-HTML) objects reference their parent differently from mw.html objects. Passing a normal mw.html object to Buffer:_inHTML as  and then calling  the object created, followed by  on the adopted parent, may return the "child." This is a feature rather than a bug.↩
{{--}}the internal table which holds elements appended via , , and ↩
Passing arguments for  via the args parameter of  and  during the creation of a new Buffer-HTML object is the only way to use most Buffer object functions on the new HTML object without converting its .nodes into an Element-Buffer.↩
That is, Buffer:getHTML may be used to return to the child node, though the trade off is that you may still need to call mw.html:allDone before using these methods in order to append the full HTML tree via Buffer:_html.↩
While Buffer-HTML objects may use #global functions, there is no separate Buffer-HTML version. In other words, the self-action of a global function on an Element-Buffer is not redirected.↩
 is doubly wrapped for Element-Buffers, with the other wrapper setting a Buffer parent reference as described at . Furthermore,  and  do not call their mw.html namesakes at all, as detailed in their respective sections.↩
However, since the mw.html __tostring method never calls the Element-Buffer as a function, raw mode is not expected to reduce performance when appending the Buffer-HTML (or Element-Buffer via mw.html:node) to another object.↩
However, some Buffer methods may not work properly after appending objects via mw.html functions to the pseudo-Buffer.
 For example,  could produce a div with each foo as bulleted item. But, if foo1 were , then  may fail when appending  with the non-string/number element. A workaround is to add the pair  to set raw mode on the div's tag.nodes; another is to replace foo1 with , which appends in string form.↩
A caveat of this unconventional type checking is that pairing an args.globalFunction with a number value will throw an error (which shouldn't be a problem since numbers make poor names for global variables).↩
i.e., does x, in the following, reference the TD or some other node hidden within an ellipsis?: ↩
Actually, the first argument to rawset is a local variable [[#new_G|new_G]] which generally equals _G but not always, to be detailed in a later section.↩
If the meta global has an __index which is a function (as is the case after requiring Module:No globals), the back-up op aborts without throwing an error.↩
Dubbing this a "global function" is bit of a misnomer since this never retrieves anything from the global table. While designed for in-chain navigation to Buffer objects that were self-declared as globals, this returns any local reference or literal passed as well (allowing  to execute Buffer methods on non-Buffer objects [[#args.globalFunction|args._B]]).↩
False cycles tables based on  instead of , which may diverge or error if the table contains nil items.↩
Though this strings the same object returned by , that function is not used to avoid setting a "lastHTML" reference.↩
Mapless iteration is intended to improve performance for tables which were constructed sequentially and which have only numeric indicies (e.g., any Buffer-object built without using the pos argument of methods such as ; note that  may be temporarily uset when the Buffer is strung in a way that would involve this method to avoid disqualification from mapless iteration due to non-sequential indexing). Though "trick" tables have been made to qualify for but yet contain keys not covered by mapless iteration, such involved both intent and an exceptional understanding of lua table, making it difficult to imagine that mis-qualified tables may arrise accidentally.↩




