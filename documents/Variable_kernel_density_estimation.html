<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1915">Variable kernel density estimation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Variable kernel density estimation</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, <strong>adaptive</strong> or <strong>"variable-bandwidth" kernel density estimation</strong> is a form of <a href="kernel_density_estimation" title="wikilink">kernel density estimation</a> in which the size of the kernels used in the estimate are varied depending upon either the location of the samples or the location of the test point. It is a particularly effective technique when the sample space is multi-dimensional. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="rationale">Rationale</h2>

<p>Given a set of samples, 

<math display="inline" id="Variable_kernel_density_estimation:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\vec{x}_{i}\}
  </annotation>
 </semantics>
</math>

, we wish to estimate the density, 

<math display="inline" id="Variable_kernel_density_estimation:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\vec{x})
  </annotation>
 </semantics>
</math>

, at a test point, 

<math display="inline" id="Variable_kernel_density_estimation:2">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <mi>W</mi>
    <mrow>
     <mi>n</mi>
     <msup>
      <mi>h</mi>
      <mi>D</mi>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>W</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\vec{x})\approx\frac{W}{nh^{D}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:4">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>W</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W=\sum_{i=1}^{n}w_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:5">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo>-</mo>
       <msub>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mi>i</mi>
       </msub>
      </mrow>
      <mi>h</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-→</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-→</ci>
         <ci>x</ci>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}=K\left(\frac{\vec{x}-\vec{x}_{i}}{h}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>n</em> is the number of samples, <em>K</em> is the <a href="Kernel_(statistics)" title="wikilink">"kernel"</a>, <em>h</em> is its width and <em>D</em> is the number of dimensions in 

<math display="inline" id="Variable_kernel_density_estimation:6">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}
  </annotation>
 </semantics>
</math>

. The kernel can be thought of as a simple, <a href="linear_filter" title="wikilink">linear filter</a>.</p>

<p>Using a fixed filter width may mean that in regions of low density, all samples will fall in the tails of the filter with very low weighting, while regions of high density will find an excessive number of samples in the central region with weighting close to unity. To fix this problem, we vary the width of the kernel in different regions of the sample space. There are two methods of doing this: balloon and pointwise estimation. In a balloon estimator, the kernel width is varied depending on the location of the test point. In a pointwise estimator, the kernel width is varied depending on the location of the sample.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>For multivariate estimators, the parameter, <em>h</em>, can be generalized to vary not just the size, but also the shape of the kernel. This more complicated approach will not be covered here.</p>
<h2 id="balloon-estimators">Balloon estimators</h2>

<p>A common method of varying the kernel width is to make it inversely proportional to the density at the test point:</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:7">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mfrac>
    <mi>k</mi>
    <msup>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mi>n</mi>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>D</mi>
     </mrow>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <divide></divide>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>P</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=\frac{k}{\left[nP(\vec{x})\right]^{1/D}}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>k</em> is a constant. If we back-substitute the estimated PDF, we can show that <em>W</em> is a constant:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Variable_kernel_density_estimation:8">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>k</mi>
     <mi>D</mi>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>D</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>W</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <ci>D</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>D</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W=k^{D}(2\pi)^{D/2}
  </annotation>
 </semantics>
</math>

</p>

<p>This produces a generalization of the <a href="k-nearest_neighbour_algorithm" title="wikilink">k-nearest neighbour algorithm</a>. That is, a uniform <a href="Kernel_(statistics)" title="wikilink">kernel function</a> will return the KNN technique.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>There are two components to the error: a variance term and a bias term. The variance term is given as:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="block" id="Variable_kernel_density_estimation:9">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo largeop="true" symmetric="true">∫</mo>
      <msup>
       <mi>K</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mrow>
     <mi>n</mi>
     <msup>
      <mi>h</mi>
      <mi>D</mi>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>K</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}=\frac{P\int K^{2}}{nh^{D}}
  </annotation>
 </semantics>
</math>

.</p>

<p>The bias term is found by evaluating the approximated function in the limit as the kernel width becomes much larger than the sample spacing. By using a Taylor expansion for the real function, the bias term drops out:</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:10">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <msup>
      <mi>h</mi>
      <mn>2</mn>
     </msup>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <msup>
      <mo>∇</mo>
      <mn>2</mn>
     </msup>
     <mi>P</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-∇</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}=\frac{h^{2}}{n}\nabla^{2}P
  </annotation>
 </semantics>
</math>

</p>

<p>An optimal kernel width that minimizes the error of each estimate can thus be derived.</p>
<h2 id="use-for-statistical-classification">Use for statistical classification</h2>

<p>The method is particularly effective when applied to <a href="statistical_classification" title="wikilink">statistical classification</a>. There are two ways we can proceed: the first is to compute the PDFs of each class separately, using different bandwidth parameters, and then compare them as in Taylor.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Alternatively, we can divide up the sum based on the class of each sample:</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo>,</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>c</mi>
         <mi>i</mi>
        </msub>
        <mo>=</mo>
        <mi>j</mi>
       </mrow>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <ci>j</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <ci>i</ci>
          </apply>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(j,\vec{x})\approx\frac{1}{n}\sum_{i=1,c_{i}=j}^{n}w_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>c<sub>i</sub></em> is the class of the <em>i</em>th sample. The class of the test point may be estimated through <a href="maximum_likelihood" title="wikilink">maximum likelihood</a>.</p>

<p>Many kernels, Gaussian for instance, are smooth. Consequently, estimates of joint or conditional probabilities are both continuous and differentiable. This makes it easy to search for a border between two classes by zeroing the difference between the conditional probabilities:</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:12">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo>,</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo>,</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo>,</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo>,</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>P</ci>
       <interval closure="open">
        <cn type="integer">2</cn>
        <apply>
         <ci>normal-→</ci>
         <ci>x</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <interval closure="open">
        <cn type="integer">1</cn>
        <apply>
         <ci>normal-→</ci>
         <ci>x</ci>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>P</ci>
       <interval closure="open">
        <cn type="integer">1</cn>
        <apply>
         <ci>normal-→</ci>
         <ci>x</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <interval closure="open">
        <cn type="integer">2</cn>
        <apply>
         <ci>normal-→</ci>
         <ci>x</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\vec{x})=P(2|\vec{x})-P(1|\vec{x})=\frac{P(2,\vec{x})-P(1,\vec{x})}{P(1,\vec%
{x})+P(2,\vec{x})}
  </annotation>
 </semantics>
</math>

</p>

<p>For example, we can use a one-dimensional <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a> to zero <em>R</em> along a line between two samples that straddle the class border. The border can be thus sampled as many times as necessary. The border samples along with estimates of the gradients of <em>R</em> determine the class of a test point through a dot-product:</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:13">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mi>arg</mi>
    <mrow>
     <munder accentunder="true">
      <mi>min</mi>
      <mo>𝑖</mo>
     </munder>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mover accent="true">
        <msub>
         <mi>b</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">→</mo>
       </mover>
       <mo>-</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">→</mo>
       </mover>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <apply>
     <arg></arg>
     <apply>
      <times></times>
      <apply>
       <ci>i</ci>
       <min></min>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-→</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <ci>normal-→</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=\arg\underset{i}{\min}|\vec{b_{i}}-\vec{x}|\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:14">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <msub>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo>-</mo>
        <mover accent="true">
         <msub>
          <mi>b</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">→</mo>
        </mover>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⋅</mo>
      <mrow>
       <msub>
        <mo>∇</mo>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">→</mo>
        </mover>
       </msub>
       <mi>R</mi>
      </mrow>
     </mrow>
     <mo fence="true">|</mo>
    </mrow>
    <mrow>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>=</mo>
     <mover accent="true">
      <msub>
       <mi>b</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">→</mo>
     </mover>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-→</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=(\vec{x}-\vec{b_{j}})\cdot\nabla_{\vec{x}}R|_{\vec{x}=\vec{b_{j}}}\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:15">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>3</mn>
      <mo>+</mo>
      <mrow>
       <mi>p</mi>
       <mo>/</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>p</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mpadded width="+1.7pt">
     <mn>2</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <cn type="integer">3</cn>
      <apply>
       <divide></divide>
       <ci>p</ci>
       <apply>
        <abs></abs>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=(3+p/|p|)/2\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Variable_kernel_density_estimation:16">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mover accent="true">
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\vec{b_{i}}\}
  </annotation>
 </semantics>
</math>

 sample the class border and <em>c</em> is the estimated class. The value of <em>R</em>, which determines the conditional probabilities, may be extrapolated to the test point:</p>

<p>

<math display="block" id="Variable_kernel_density_estimation:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mi>tanh</mi>
    <mpadded width="+1.7pt">
     <mi>p</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <tanh></tanh>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\vec{x})\approx\tanh p\,
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Two-class classifications are easy to generalize to multiple classes.</p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://libagf.sf.net">libAGF</a> - A library for multivariate, adaptive kernel density estimation.</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Classification_algorithms" title="wikilink">*</a> <a href="Category:Statistical_classification" title="wikilink">Category:Statistical classification</a> <a href="Category:Estimation_of_densities" title="wikilink">Category:Estimation of densities</a> <a href="Category:Non-parametric_statistics" title="wikilink">Category:Non-parametric statistics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
</ol>
</section>
</body>
</html>
