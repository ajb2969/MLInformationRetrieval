<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="414">Planted motif search</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Planted motif search</h1>
<hr/>

<p>In the field of <a href="computational_biology" title="wikilink">computational biology</a>, a <strong>planted motif search</strong> (PMS) also known as a <strong>(<em>l, d</em>)-motif search</strong> (LDMS) is a method for identifying conserved <a href="sequence_motif" title="wikilink">motifs</a> within a set of <a href="nucleic_acid_sequence" title="wikilink">nucleic acid</a> or <a href="peptide_sequence" title="wikilink">peptide sequences</a>.</p>

<p>PMS is known to be <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>. The <a href="Time_complexity" title="wikilink">time complexities</a> of most of the planted motif search algorithms depend exponentially on the alphabet size and <em>l</em>. The PMS problem was first introduced by Keich and Pevzner.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The problem of identifying meaningful patterns (e.g., motifs) from <a href="biological_data" title="wikilink">biological data</a> has been studied extensively since they play a vital role in understanding <a href="functional_genomics" title="wikilink">gene function</a>, <a href="disease" title="wikilink">human disease</a>, and may serve as <a href="drug_discovery" title="wikilink">therapeutic drug targets</a>.</p>
<h2 id="description">Description</h2>

<p>The search problem may be summarized as follows:</p>

<p><em>Input are n strings (s<sub>1</sub>, s<sub>2</sub>, … , s<sub>n</sub>) of length m each from an alphabet Σ and two integers l and d. Find all strings x such that |x| = l and every input string contains at least one variant of x at a <a href="Hamming_distance" title="wikilink">Hamming distance</a> of at most d. Each such x is referred to as an (l, d) motif.</em></p>

<p>For example, if the input strings are GCGCGAT, CACGTGA, and CGGTGCC; <em>l</em> = 3 and <em>d</em> = 1, then GGT is a motif of interest. Note that the first input string has GAT as a <a class="uri" href="substring" title="wikilink">substring</a>, the second input string has CGT as a substring, and the third input string has GGT as a substring. GAT is a variant of GGT that is within a Hamming distance of 1 from GGT, etc. Call the variants of a motif that occur in the input strings as instances of the motif. For example, GAT is an instance of the motif GGT that occurs in the first input string.</p>

<p>Zero or more (<em>l</em>, <em>d</em>) motifs are contained in any given set of input strings. Many of the known algorithms for PMS consider <a href="DNA_sequence" title="wikilink">DNA strings</a> for which Σ ={G, C, T, A}. There exist <a class="uri" href="algorithms" title="wikilink">algorithms</a> that deal with protein strings as well. The PMS problem is also known as the (<em>l</em>, <em>d</em>)-motif search (LDMS) problem.</p>
<h2 id="notation">Notation</h2>

<p>The following <a href="mathematical_notation" title="wikilink">mathematical notation</a> is often used to describe PMS algorithms.</p>

<p>Assume that S = {<em>s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>, …, s<sub>n</sub></em>} is the given set of input strings from an alphabet Σ. An <em>l</em>-mer of any string is nothing but a substring of the string of length <em>l</em>. Let <em>d<sub>H</sub>(a, b)</em> stand for the <a href="Hamming_distance" title="wikilink">Hamming distance</a> between any two <em>l</em>-mers <em>a</em> and <em>b</em>. Let <em>a</em> be an <em>l</em>-mer and <em>s</em> be an input string. Then, let <em>d<sub>H</sub>(a, s)</em> stand for the minimum Hamming distance between <em>a</em> and any <em>l</em>-mer <em>b</em> of <em>s</em>. If <em>a</em> is any <em>l</em>-mer and <em>S</em> is a set of input strings then let <em>d<sub>H</sub>(a, S)</em> stand for max<sub>sєS</sub><em>d<sub>H</sub>(a, s)</em>. Let <em>u</em> be any <em>l</em>-mer. Then, the <em>d</em>-neighborhood of <em>u</em>, (denoted as <em>B<sub>d</sub>(u)</em>), is nothing but the set of all the <em>l</em>-mers <em>v</em> such that <em>d<sub>H</sub>(u, v)</em> ≤ <em>d</em>. In other words, <em>B<sub>d</sub>(u)={v: d<sub>H</sub>(u, v)≤d}</em>. Refer to any such <em>l</em>-mer <em>v</em> as a <em>d</em>-neighbor of <em>u</em>. <em>B<sub>d</sub>(x, y)</em> is used to denote the common <em>d</em>-neighborhood of <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are two <em>l</em>-mers. <em>B<sub>d</sub>(x, y)</em> is nothing but the set of all <em>l</em>-mers that are within a distance of <em>d</em> from both <em>x</em> and <em>y</em>. Similarly, <em>B<sub>d</sub>(x, y, z)</em>, etc. can be defined.</p>
<h2 id="algorithms">Algorithms</h2>

<p>The scientific literature describes numerous algorithms for solving the PMS problem. These algorithms can be classified into two major types. Those algorithms that may not return the optimal answer(s) are referred to as <a href="approximation_algorithms" title="wikilink">approximation algorithms</a> (or <a class="uri" href="heuristic" title="wikilink">heuristic</a> algorithms) and those that always return the optimal answer(s) are called exact algorithms.</p>
<h3 id="approximate">Approximate</h3>

<p>Examples of <a href="Approximation_algorithms" title="wikilink">approximation (or heuristic) algorithms</a> include Random Projection,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> PatternBranching,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> MULTIPROFILER,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> CONSENSUS,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and ProfileBranching.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> These algorithms have been experimentally demonstrated to perform well.</p>
<h4 id="random-projection">Random projection</h4>

<p>The algorithm<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> is based on random projections. Let the motif <em>M</em> of interest be an <em>l</em>-mer and <em>C</em> be the collection of all the <em>l</em>-mers from all the <em>n</em> input strings. The algorithm projects these <em>l</em>-mers along <em>k</em> randomly chosen positions (for some appropriate value of <em>k</em>). The projection of each <em>l</em>-mer may be thought of as an integer. The projected values (which are <em>k</em>-mers) are grouped according to their integer values. In other words, hash all the <em>l</em>-mers using the <em>k</em>-mer of any <em>l</em>-mer as its hash value. All the <em>l</em>-mers that have the same hash value fall into the same hash bucket. Since the instances of any (<em>l</em>, <em>d</em>) motif are similar to each other, many of these instances will fall into the same bucket. Note that the <a href="Hamming_distance" title="wikilink">Hamming distance</a> between any two instances of an (<em>l</em>, <em>d</em>) motif is no more than 2<em>d</em>. The key idea of this algorithm is to examine those buckets that have a large number of <em>l</em>-mers in them. For each such bucket, an <a href="Expectation_maximization" title="wikilink">expectation maximization (EM) algorithm</a> is used to check if an (<em>l</em>, <em>d</em>) motif can be found using the <em>l</em>-mers in the bucket.</p>
<h4 id="pattern-branching">Pattern branching</h4>

<p>This algorithm<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> is a <a href="Local_search_(optimization)" title="wikilink">local searching algorithm</a>. If <em>u</em> is any <em>l</em>-mer, then there are 

<math display="inline" id="Planted_motif_search:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>l</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>d</mi>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <msup>
    <mn>3</mn>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>l</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3</cn>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textstyle\left({{l}\atop{d}}\right)}3^{d}
  </annotation>
 </semantics>
</math>

 <em>l</em>-mers that are <em>d</em>-neighbors of <em>u</em>, for DNA strings. This algorithm starts from each <em>l</em>-mer <em>u</em> in the input, searches the neighbors of <em>u</em>, scores them appropriately and outputs the best scoring neighbor.</p>
<h3 id="exact">Exact</h3>

<p>Many exact algorithms are known for solving the PMS problem as well. Examples include the ones in (Martinez 1983),<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> (Brazma, et al. 1998),<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> (Galas, et al. 1985),<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> (Sinha, et al. 2000),<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> (Staden 1989),<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> (Tompa 1999),<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> (Helden, et al. 1998)<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> (Rajasekaran, et al.),<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> (Davila and Rajasekaran 2006),<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> (Davila, Balla, and Rajasekaran 2006),<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Voting<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> and RISOTTO.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h4 id="winnower-and-sp-star">WINNOWER and SP-STAR</h4>

<p>The WINNOWER algorithm<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> is a <a href="heuristic_algorithm" title="wikilink">heuristic algorithm</a> and it works as follows. If <em>A</em> and <em>B</em> are two instances of the same motif in two different input strings, then the Hamming distance between <em>A</em> and <em>B</em> is at most 2<em>d</em>. It can be shown that the expected Hamming distance between <em>A</em> and <em>B</em> is 

<math display="inline" id="Planted_motif_search:1">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>d</mi>
   </mrow>
   <mo>-</mo>
   <mfrac>
    <mrow>
     <mn>4</mn>
     <msup>
      <mi>d</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mrow>
     <mn>3</mn>
     <mi>l</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>d</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2d-\tfrac{4d^{2}}{3l}
  </annotation>
 </semantics>
</math>

. WINNOWER constructs a collection <em>C</em> of all possible <em>l</em>-mers in the input. A graph <em>G(V,E)</em> is constructed in which each <em>l</em>-mer of <em>C</em> will be a node. Two nodes <em>u</em> and <em>v</em> in <em>G</em> are connected by an edge if and only if the Hamming distance between <em>u</em> and <em>v</em> is at most 2<em>d</em> and they come from two different input strings.</p>

<p>If <em>M</em> is an (<em>l</em>, <em>d</em>) motif and if <em>M<sub>1</sub></em>, <em>M<sub>2</sub></em>, …, and <em>M<sub>n</sub></em> are instances of <em>M</em> in the input strings, then, clearly, these instances will form a <a href="Clique_(graph_theory)" title="wikilink">clique</a> in <em>G</em>. The WINNOWER algorithm has two phases. In the first phase, it identifies large cliques in <em>G</em>. In the second phase each such clique is examined to see if a motif can be extracted from this clique. Since the <a href="Clique_(graph_theory)" title="wikilink">CLIQUE</a> problem is <a href="Intractability_(complexity)" title="wikilink">intractable</a>, WINNOWER uses a heuristic to solve CLIQUE. It iteratively constructs cliques of larger and larger sizes. If <em>N</em> = <em>mn</em>, then the run time of the algorithm is 

<math display="inline" id="Planted_motif_search:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>d</mi>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>d</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N^{2d+1})
  </annotation>
 </semantics>
</math>

.This algorithm runs in a reasonable amount of time in practice especially for small values of <em>d</em>. Another algorithm called SP-STAR,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> is faster than WINNOWER and uses less memory. WINNOWER algorithm treats all the edges of <em>G</em> equally without distinguishing between edges based on similarities. SP-STAR scores the <em>l</em>-mers of <em>C</em> as well as the edges of <em>G</em> appropriately and hence eliminates more edges than WINNOWER per iteration.</p>

<p>(Bailey and Elkan, 1994)<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> employs expectation maximization algorithms while Gibbs sampling is used by (Lawrence et al., 1993).<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> MULTIPROFILER<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> MEME,<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> are also known PMS algorithms.</p>
<h4 id="pms-series">PMS series</h4>

<p>In the last decade a series of algorithms with PMS as a prefix has been developed in the lab of <a href="http://www.engr.uconn.edu/~rajasek/">Rajasekaran</a>. Some of these algorithms are described below.</p>
<h5 id="pms0">PMS0</h5>

<p>PMSo<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> works as follows. Let <em>s<sub>1</sub></em>, <em>s<sub>2</sub></em>, …, <em>s<sub>n</sub></em> be a given set of input strings each of length <em>m</em>. Let <em>C</em> be the collection of <em>l</em>-mers in <em>s<sub>1</sub></em>. Let C' = ∪<sub><em>u∈C</em></sub><em>B</em><sub><em>d</em></sub>(<em>u</em>). For each element <em>v</em> of <em>C</em>' check if it is a valid (<em>l</em>, <em>d</em>)-motif or not. Given an <em>l</em>-mer <em>v</em>, a check if it is a valid (<em>l</em>, <em>d</em>)-motif or not can be made in O(<em>mnl</em>) time. Thus the run time of PMS0, assuming an alphabet of size 4, is 

<math display="inline" id="Planted_motif_search:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>m</mi>
      <mn>2</mn>
     </msup>
     <mi>n</mi>
     <mi>l</mi>
     <mrow>
      <mo>(</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mi>l</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mi>d</mi>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
      <mo>)</mo>
     </mrow>
     <msup>
      <mn>3</mn>
      <mi>d</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
     <ci>l</ci>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>l</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">3</cn>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(m^{2}nl{\textstyle\left({{l}\atop{d}}\right)}3^{d})
  </annotation>
 </semantics>
</math>

.</p>
<h5 id="pms1">PMS1</h5>

<p>This algorithm<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> is based on <a href="radix_sorting" title="wikilink">radix sorting</a> and has the following steps.</p>
<ol>
<li>Generate the set of all <em>l</em>-mers in each input string. Let <em>C<sub>i</sub></em> correspond to the <em>l</em>-mers of <em>s<sub>i</sub></em>, for 1≤<em>i</em>≤<em>n</em>.</li>
<li>For each <em>l</em>-mer u in <em>C<sub>i</sub></em> (1 d<em>(</em>u''). Let <em>L<sub>i</sub></em> be a collection of all of these neighbors (corresponding to all the <em>l</em>-mers of <em>s<sub>i</sub></em>).</li>
<li>Sort <em>L<sub>i</sub></em> (using radix sort) and eliminate any duplicates.</li>
<li>Compute 

<math display="block" id="Planted_motif_search:4">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋂</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <msub>
     <mi>L</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <intersect></intersect>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigcap_{i=1}^{n}L_{i}.
  </annotation>
 </semantics>
</math>

. This can be done by merging the lists <em>L<sub>1</sub></em>, <em>L<sub>2</sub></em>, …, <em>L<sub>n</sub></em>. All the <em>l</em>-mers in this intersection are valid (<em>l</em>, <em>d</em>) motifs.</li>
</ol>
<h5 id="pms2">PMS2</h5>

<p>Let the motif <em>M</em> of interest be of length <em>l</em>. If <em>M</em> occurs in every input string then any <a class="uri" href="substring" title="wikilink">substring</a> of <em>M</em> also occurs in every input string. Here occurrence means occurrence within a Hamming distance of <em>d</em>. It follows that there are at least <em>l</em>-<em>k</em>+1 strings each of length <em>k</em> (for <em>k</em> ≤ <em>l</em>) such that each of these occurs in every input string.</p>

<p>Let <em>Q</em> be a collection of <em>k</em>-mers in <em>M</em>. Note that, in every input string <em>s<sub>i</sub></em>, there will be at least one position <em>i<sub>j</sub></em> such that a <em>k</em>-mer of <em>Q</em> occurs starting from <em>i<sub>j</sub></em>. Another <em>k</em>-mer of <em>Q</em> occurs starting from <em>i<sub>j</sub></em> +1 and so on, with the last <em>k</em>-mer occurring at <em>i<sub>j</sub></em> + l – <em>k</em>. An <em>l</em>-mer can be obtained by combining these <em>k</em>-mers that occur starting from each such <em>i<sub>j</sub></em>.</p>

<p>PMS2<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> works as follows. In the first phase find all the (<em>k</em>, <em>d</em>) motifs present in all the input strings (for some appropriate value of <em>k</em> enables one to handle large values of <em>d</em>. Let <em>d</em>’=<em>d</em>/2. Let <em>M</em> be the motif to be found with |<em>M</em>|=<em>l</em>=2<em>l</em>’ for some integer <em>l</em>’. Let <em>M<sub>1</sub></em> refer to the first half of <em>M</em> and <em>M<sub>2</sub></em> be the next half. Let <em>s</em>= <em>a<sub>1</sub>a<sub>2</sub>…a<sub>m</sub></em> be one of the input strings. <em>M</em> occurs in every input string. Let the occurrence of <em>M</em> (within a Hamming distance of <em>d</em>) in <em>s</em> start at position <em>i</em>. Let <em>s</em>’=<em>a<sub>i</sub>a<sub>i+1</sub>…a<sub>i+l’-1</sub></em> and <em>s</em>’’ =<em>a<sub>i+l</sub>’…a<sub>i+l-1</sub></em>. It is clear that either the Hamming distance between <em>M<sub>1</sub></em> and <em>s</em>’ is at most <em>d</em>’ or the Hamming distance between <em>M<sub>2</sub></em> and <em>s</em>’’ is at most <em>d</em>’. Either <em>M</em><sub>1</sub> or <em>M</em><sub>2</sub> occurs in every input string at a Hamming distance of at most <em>d</em>’. As a result, in at least <em>n</em>’ strings (where <em>n</em>’ = <em>n</em>/2) either <em>M</em><sub>1</sub> or <em>M</em><sub>2</sub> occurs with a Hamming distance of at most <em>d</em>. The algorithm first obtains all the (<em>l</em>’, <em>d</em>’)-motifs that occur in at least <em>n</em>/2 of the input strings. It then uses these motifs and the above observations to identify all the (<em>l</em>, <em>d</em>)-motifs present in the input strings.</p>
<h5 id="pmsprune">PMSPrune</h5>

<p>This algorithm introduces a <a href="Tree_(data_structure)" title="wikilink">tree structure</a> for the motif candidates and uses a <a href="branch-and-bound_algorithm" title="wikilink">branch-and-bound algorithm</a> to reduce the search space.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> Let <em>S</em> = {<em>s<sub>1</sub>, s<sub>2</sub>, …, s<sub>n</sub></em>} be a given set of input strings. PMSprune follows the same strategy as PMS0: For every <em>l</em>-mer <em>y</em> in <em>s<sub>1</sub></em>, it generates the set of neighbors of <em>y</em> and, for each of them, checks whether this is a motif or not. Some key steps in the algorithm are:</p>
<ol>
<li>It generates the <em>d</em>-neighborhood of every <em>l</em>-mer <em>y</em> in <em>s<sub>1</sub></em> using a tree of height <em>d</em>. The root of this tree will have <em>y</em>. Every <em>l</em>-mer that is at a distance of 1 from <em>y</em> will be a node in the tree that is at a distance of 1 from the root; every <em>l</em>-mer that is at a distance of 2 from <em>y</em> will be a node in the tree that is at a distance of 2 from the root; and so on. When a node in this tree is visited, check if the corresponding <em>l</em>-mer is an (<em>l</em>, <em>d</em>)-motif. I.e., if the <em>l</em>-mer is <em>x</em>, check if <em>d<sub>H</sub>(x, S)</em>≤<em>d</em>. If so, output this <em>l</em>-mer. In any case move to the next node in the tree. This tree is explored in a <a href="Depth-first_search" title="wikilink">depth first</a> manner.</li>
<li>If each node in the tree is visited for each <em>l</em>-mer <em>y</em> in <em>s<sub>1</sub></em>, then the run time of PMSPrune will be at least as much as that of PMS0. PMSPrune uses some pruning conditions to prune subtrees that cannot possibly have any motifs in them.</li>
<li>For an <em>l</em>-mer <em>x</em>, which corresponds to a node in a subtree of height <em>h</em>, the algorithm uses the value of <em>d<sub>H</sub>(x, S)</em> and <em>h</em> to prune the descendants of <em>x</em>.</li>
<li>PMSPrune calculates the value of <em>d<sub>H</sub>(x, S)</em> for the nodes (<em>x</em>) in the tree in an incremental way, taking into account the way in which the neighborhood is generated.</li>
</ol>
<h5 id="pms4">PMS4</h5>

<p>PMS4<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> is a technique that can be used to speedup any algorithm for the PMS problem. In many of the above algorithms there are two phases. In the first phase we come up with a set of candidate motifs and in the second phase check, for each candidate motif, if it is a valid (<em>l</em>, <em>d</em>)-motif. For each candidate motif it takes O(<em>mnl</em>) time to check if it is a valid motif or not. PMS4 employs a similar two phase strategy. These phases are explained below. Let A be any PMS algorithm.</p>
<ol>
<li>Run the algorithm A on <em>k</em> input strings (where <em>k</em> &lt; <em>n</em>). An optimal value of <em>k</em> can be determined empirically. The <em>k</em> strings may be picked in a number of ways. For example, they could be the first <em>k</em> strings, random <em>k</em> strings, and so on. Let <em>C</em> be the collection of (<em>l</em>, <em>d</em>)-motifs found in these <em>k</em> strings. Clearly, <em>C</em> is a superset of the (<em>l</em>, <em>d</em>)-motifs present in the <em>n</em> given input strings.</li>
<li>for each <em>l</em>-mer <em>v</em> in <em>C</em> do</li>
</ol>
<dl>
<dd><dl>
<dd>Check if <em>v</em> is a valid motif in O(<em>mnl</em>) time. If so, output <em>v</em>.
</dd>
</dl>
</dd>
</dl>
<h5 id="pms5-and-pms6">PMS5 and PMS6</h5>

<p>PMS5<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> is an extension of PMS0. If <em>S</em> = {<em>s<sub>1</sub></em>, <em>s<sub>2</sub></em>, …, <em>s<sub>n</sub></em>} is a set of strings (not necessarily of the same length), let 

<math display="inline" id="Planted_motif_search:5">
 <semantics>
  <mrow>
   <msubsup>
    <mi>M</mi>
    <mi>l</mi>
    <mi>d</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>l</ci>
     </apply>
     <ci>d</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{l}^{d}(S)
  </annotation>
 </semantics>
</math>

 denote the (<em>l</em>, <em>d</em>)-motifs present in <em>S</em>. Let <em>S</em>’ = {<em>s<sub>2</sub>, s<sub>3</sub>, …, s<sub>n</sub></em>}. PMS5 computes the (<em>l</em>, <em>d</em>)-motifs of <em>S</em> as 

<math display="inline" id="Planted_motif_search:6">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
    <mrow>
     <mi>L</mi>
     <mo>∈</mo>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </msub>
   <mrow>
    <msubsup>
     <mi>M</mi>
     <mi>l</mi>
     <mi>d</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo>,</mo>
     <msup>
      <mi>S</mi>
      <msup>
       <mi></mi>
       <mo>′</mo>
      </msup>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <union></union>
     <apply>
      <in></in>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>l</ci>
      </apply>
      <ci>d</ci>
     </apply>
     <interval closure="open">
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigcup_{L\in s_{1}}M_{l}^{d}(L,S^{^{\prime}})
  </annotation>
 </semantics>
</math>

. Here <em>L</em> refers to an <em>l</em>-mer.</p>

<p>One of the key steps in the algorithm is a <a class="uri" href="subroutine" title="wikilink">subroutine</a> to compute the common <em>d</em>-neighborhood of three <em>l</em>-mers. Let <em>x</em>, <em>y</em>, <em>z</em> be any three <em>l</em>-mers. To compute <em>B<sub>d</sub>(x, y, z)</em>, PMS5 represents <em>B<sub>d</sub>(x)</em> as a tree <em>T<sub>d</sub>(x)</em>. Each node in this tree represents an <em>l</em>-mer in <em>B<sub>d</sub>(x)</em>. The root of <em>T<sub>d</sub>(x)</em> stands for the <em>l</em>-mer x. <em>T<sub>d</sub>(x)</em> has a depth of <sub>d</sub>. Nodes of <em>T<sub>d</sub>(x)</em> are traversed in a <a href="Depth-first_search" title="wikilink">depth-first</a> manner. The node and the <em>l</em>-mer it represents may be used interchangeably. While the tree is <a href="tree_traversal" title="wikilink">traversed</a>, any node <em>t</em> will be output if <em>t</em> is in 

<math display="inline" id="Planted_motif_search:7">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>d</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>d</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>d</ci>
    </apply>
    <ci>y</ci>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>d</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{d}(y)\bigcap B_{d}(z)
  </annotation>
 </semantics>
</math>

. When any node <em>t</em> is visited, check if there is a descendent <em>t’</em> of <em>t</em> such that <em>t’</em> is in 

<math display="inline" id="Planted_motif_search:8">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>d</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>d</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>d</ci>
    </apply>
    <ci>y</ci>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>d</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{d}(y)\bigcap B_{d}(z)
  </annotation>
 </semantics>
</math>

. Prune the <a class="uri" href="subtree" title="wikilink">subtree</a> rooted at <em>t</em> if there is no such descendent. In PMS5, the problem of checking if <em>t</em> has any descendent that is in 

<math display="inline" id="Planted_motif_search:9">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>d</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>d</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>d</ci>
    </apply>
    <ci>y</ci>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>d</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{d}(y)\bigcap B_{d}(z)
  </annotation>
 </semantics>
</math>

 is formulated as an <a href="Integer_linear_program" title="wikilink">integer linear program (ILP)</a> on ten variables. This ILP is solved in O(1) time. Solving the ILP instances is done as a preprocessing step and the results are stored in a lookup table.</p>

<p>Algorithm PMS6<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> is an extension of PMS5 that improves the <a class="uri" href="preprocessing" title="wikilink">preprocessing</a> step and also it uses efficient <a href="Hash_table" title="wikilink">hashing</a> techniques to store the lookup tables. As a result, it is typically faster than PMS5.</p>

<p>Shibdas Bandyopadhyay, Sartaj Sahni, Sanguthevar Rajasekaran, "PMS6: A fast algorithm for motif discovery," iccabs, pp.1-6, 2012 IEEE 2nd International Conference on Computational Advances in Bio and medical Sciences, 2012</p>
<h5 id="qpmsprune-and-qpms7">qPMSPrune and qPMS7</h5>

<p>Given a set <em>S</em>={<em>s<sub>1</sub>, s<sub>2</sub>, …, s<sub>n</sub></em>} of strings, and integers <em>l</em>, <em>d</em>, and <em>q</em>, an (<em>l, d, q</em>)-motif is defined to be a string <em>M</em> of length <em>l</em> that occurs in at least <em>q</em> of the <em>n</em> input strings within a Hamming distance of <em>d</em>. The qPMS (<em>Quorum Planted Motif Search</em>) problem is to find all the (<em>l, d, q</em>)-motifs present in the input strings. The qPMS problem captures the nature of motifs more precisely than the PMS problem does because, in practice, some motifs may not have motif instances in all of the input strings. Any algorithm for solving the qPMS problem (when <em>q</em> ≠ <em>n</em>) is typically named with a prefix of `<em>q</em>'. qPMSPrune is one of the first algorithms to address this version of the PMS problem.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> qPMSPrune exploits the following fact: If <em>M</em> is any (<em>l, d, q</em>)-motif of the input strings <em>s<sub>1</sub>, s<sub>2</sub>, …, s<sub>n</sub></em>, then there exists an <em>i</em> (with 1 ≤ <em>i</em> ≤ <em>n</em> – <em>q</em> + 1) and an <em>l</em>-mer 

<math display="inline" id="Planted_motif_search:10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x\in s_{i}}
  </annotation>
 </semantics>
</math>

 such that <em>M</em> is in <em>B<sub>d</sub>(x)</em> and <em>M</em> is an (<em>l, d, q</em>-1)-motif of the input strings excluding <em>s<sub>i</sub></em>. The algorithm processes every <em>s<sub>i</sub></em>, 1≤ <em>i</em> ≤ <em>n</em>. While processing <em>s<sub>i</sub></em>, it considers every <em>l</em>-mer <em>x</em> of <em>s<sub>i</sub></em>. When considering <em>x</em>, it constructs <em>B<sub>d</sub>(x)</em> and identifies elements of <em>B<sub>d</sub>(x)</em> that are (<em>l, d, q</em>-1) motifs (with respect to input strings other than <em>s<sub>i</sub></em>). <em>B<sub>d</sub>(x)</em> is represented as a tree with <em>x</em> as the root. This tree will be traversed in a <a href="Depth-first_search" title="wikilink">depth first</a> manner. The algorithm does not traverse the entire tree. Some of the subtrees are pruned using effective pruning conditions. In particular, a subtree is pruned if it can be inferred that none of the nodes in this subtree carries a motif of interest.</p>

<p>Algorithm qPMS7<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> is an extension of qPMSPrune. Specifically, it is based on the following observation: If <em>M</em> is any (<em>l, d, q</em>)-motif of the input strings <em>s<sub>1</sub>, s<sub>2</sub>, …, s<sub>n</sub></em>, then there exist 1 ≤ <em>i</em> ≠ <em>j</em> ≤ <em>n</em> and <em>l</em>-mer 

<math display="inline" id="Planted_motif_search:11">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in s_{i}
  </annotation>
 </semantics>
</math>

 and <em>l</em>-mer 

<math display="inline" id="Planted_motif_search:12">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msub>
    <mi>s</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in s_{j}
  </annotation>
 </semantics>
</math>

 such that <em>M</em> is in 

<math display="inline" id="Planted_motif_search:13">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>d</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>d</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>d</ci>
    </apply>
    <ci>x</ci>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>d</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{d}(x)\bigcap B_{d}(y)
  </annotation>
 </semantics>
</math>

 and <em>M</em> is an (<em>l, d, q</em>-2)-motif of the input strings excluding <em>s<sub>i</sub></em> and <em>s<sub>j</sub></em>. The algorithm considers every possible pair (<em>i, j</em>), 1≤ <em>i, j</em> ≤ <em>n</em> and <em>i</em> ≠ <em>j</em>. For any pair (<em>i</em>, <em>j</em>), every possible pair of <em>l</em>-mers (<em>x, y</em>) is considered (where <em>x</em> is from <em>s<sub>i</sub></em> and <em>y</em> is from <em>s<sub>j</sub></em>). While considering any <em>x</em> and <em>y</em>, the algorithm identifies all the elements of 

<math display="inline" id="Planted_motif_search:14">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>d</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>d</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>d</ci>
    </apply>
    <ci>x</ci>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>d</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{d}(x)\bigcap B_{d}(y)
  </annotation>
 </semantics>
</math>

 that are (<em>l, d, q</em>-2) motifs (with respect to input strings other than <em>s<sub>i</sub></em> and <em>s<sub>j</sub></em>). An <a href="Directed_acyclic_graph" title="wikilink">acyclic graph</a> is used to represent and explore 

<math display="inline" id="Planted_motif_search:15">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>d</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mi>d</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>d</ci>
    </apply>
    <ci>x</ci>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>d</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{d}(x)\bigcap B_{d}(y)
  </annotation>
 </semantics>
</math>

. Call this graph <em>G<sub>d</sub>(x, y)</em>. <em>G<sub>d</sub>(x, y)</em> is traversed in a depth first manner. Like in qPMSPrune, qPMS7 also employs some pruning conditions to prune subgraphs of <em>G<sub>d</sub>(x, y)</em>.</p>
<h4 id="risotto">RISOTTO</h4>

<p>RISOTTO<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> employs a <a href="suffix_tree" title="wikilink">suffix tree</a> to identify the (<em>l, d</em>)-motifs. It is somewhat similar to PMS0. For every <em>l</em>-mer in <em>s<sub>1</sub></em>, it generates the <em>d</em>-neighborhood and for every <em>l</em>-mer in this neighborhood it walks through a suffix tree to check if this <em>l</em>-mer is an (<em>l, d</em>)-motif. Voting<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> is similar to PMS1. Instead of using radix sorting, it uses hashing to compute <em>L<sub>i</sub></em>’s and their <a href="Intersection_(set_theory)" title="wikilink">intersections</a>.</p>
<h3 id="relative-performance">Relative performance</h3>

<p>PMS algorithms are typically tested on random benchmark data generated as follows: Twenty strings each of length 600 are generated randomly from the alphabet of interest. The motif <em>M</em> is also generated randomly and planted in each of the input strings within a Hamming distance of <em>d</em>. The motif instances are also generated randomly. Certain instances of the (<em>l, d</em>)-motif problem have been identified to be <em>challenging</em>. For a given value of <em>l</em>, the instance (<em>l, d</em>) is called challenging if <em>d</em> is the smallest integer for which the expected number of (<em>l, d</em>)-motifs that occur by random chance (in addition to the planted one) is one or more. For example, the following instances are challenging: (9, 2), (11, 3), (13, 4), (15, 5), (17, 6), (19, 7), etc. The performance of PMS algorithms is customarily shown only for challenging instances. Following is a table of time comparison of different PMS algorithms on the challenging instances of DNA sequences for the special case. This table is taken from the paper qPMS7.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> In this table several algorithms have been compared: qPMSPrune,<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> qPMSPruneI,<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> Pampa,<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> Voting,<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> RISOTTO,<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> PMS5,<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> PMS6,<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> qPMS7.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>

<p>In the following table, the alphabet ∑={<em>A</em>,<em>C</em>,<em>G</em>,<em>T</em>}, <em>n</em>=20, <em>m</em>=600, and <em>q</em>=<em>n</em>=20.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>TIME COMPARISON OF DIFFERENT PMS ALGORITHMS</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Algorithm</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>qPMS7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>PMS6</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>PMS5</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>qPMSPruneI</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Pampa</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>qPMSPrune</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Voting</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>RISOTTO</p></td>
</tr>
</tbody>
</table>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Bioinformatics" title="wikilink">Category:Bioinformatics</a> <a href="Category:Computational_biology" title="wikilink">Category:Computational biology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46"></li>
</ol>
</section>
</body>
</html>
