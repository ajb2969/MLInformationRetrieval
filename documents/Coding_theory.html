<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="41">Coding theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Coding theory</h1>
<hr/>

<p> <strong>Coding theory</strong> is the study of the properties of codes and their fitness for a specific application. Codes are used for <a href="data_compression" title="wikilink">data compression</a>, <a class="uri" href="cryptography" title="wikilink">cryptography</a>, <a class="uri" href="error-correction" title="wikilink">error-correction</a> and more recently also for <a href="network_coding" title="wikilink">network coding</a>. Codes are studied by various scientific disciplines‚Äîsuch as <a href="information_theory" title="wikilink">information theory</a>, <a href="electrical_engineering" title="wikilink">electrical engineering</a>, <a class="uri" href="mathematics" title="wikilink">mathematics</a>, and <a href="computer_science" title="wikilink">computer science</a>‚Äîfor the purpose of designing efficient and reliable <a href="data_transmission" title="wikilink">data transmission</a> methods. This typically involves the removal of redundancy and the correction (or detection) of errors in the transmitted data.</p>

<p>There are four types of coding:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ol>
<li><a href="Data_compression" title="wikilink">Data compression</a> (or, <em>source coding</em>)</li>
<li><a href="Error-correction_code" title="wikilink">Error correction</a> (or <em><a href="channel_coding" title="wikilink">channel coding</a></em>)</li>
<li><a href="Cryptography" title="wikilink">Cryptographic coding</a></li>
<li><a href="Line_coding" title="wikilink">Line coding</a></li>
</ol>

<p>Data compression and error correction may be <a href="Joint_source_and_channel_coding" title="wikilink">studied in combination</a>.</p>

<p>Source encoding attempts to compress the data from a source in order to transmit it more efficiently. This practice is found every day on the Internet where the common <a href="Zip_(file_format)" title="wikilink">Zip data compression</a> is used to reduce the network load and make files smaller.</p>

<p>The second, channel encoding, adds extra data bits to make the transmission of data more robust to disturbances present on the transmission channel. The ordinary user may not be aware of many applications using channel coding. A typical music CD uses the <a href="Reed-Solomon_error_correction#Data_storage" title="wikilink">Reed-Solomon</a> code to correct for scratches and dust. In this application the transmission channel is the CD itself. Cell phones also use coding techniques to correct for the fading and noise of high frequency radio transmission. Data modems, telephone transmissions, and <a class="uri" href="NASA" title="wikilink">NASA</a> all employ channel coding techniques to get the bits through, for example the <a href="turbo_code" title="wikilink">turbo code</a> and <a href="LDPC_code" title="wikilink">LDPC codes</a>.</p>
<h2 id="history-of-coding-theory">History of coding theory</h2>

<p>In 1948, <a href="Claude_Shannon" title="wikilink">Claude Shannon</a> published "<a href="A_Mathematical_Theory_of_Communication" title="wikilink">A Mathematical Theory of Communication</a>", an article in two parts in the July and October issues of the <em>Bell System Technical Journal</em>. This work focuses on the problem of how best to encode the <a class="uri" href="information" title="wikilink">information</a> a sender wants to transmit. In this fundamental work he used tools in probability theory, developed by <a href="Norbert_Wiener" title="wikilink">Norbert Wiener</a>, which were in their nascent stages of being applied to communication theory at that time. Shannon developed <a href="information_entropy" title="wikilink">information entropy</a> as a measure for the uncertainty in a message while essentially inventing the field of <a href="information_theory" title="wikilink">information theory</a>.</p>

<p>The <a href="binary_Golay_code" title="wikilink">binary Golay code</a> was developed in 1949. More specifically, it is an error-correcting code capable of correcting up to three errors in each 24-bit word, and detecting a fourth.</p>

<p> <a href="Richard_Hamming" title="wikilink">Richard Hamming</a> won the <a href="Turing_Award" title="wikilink">Turing Award</a> in 1968 for his work at <a href="Bell_Labs" title="wikilink">Bell Labs</a> in numerical methods, automatic coding systems, and error-detecting and error-correcting codes. He invented the concepts known as <a href="Hamming_code" title="wikilink">Hamming codes</a>, <a href="Hamming_window" title="wikilink">Hamming windows</a>, <a href="Hamming_numbers" title="wikilink">Hamming numbers</a>, and <a href="Hamming_distance" title="wikilink">Hamming distance</a>.</p>
<h2 id="source-coding">Source coding</h2>

<p>The aim of source coding is to take the source data and make it smaller.</p>
<h3 id="definition">Definition</h3>

<p>Data can be seen as a <a href="random_variable" title="wikilink">random variable</a> 

<math display="inline" id="Coding_theory:0">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">Œ©</mi>
    <mo>‚Üí</mo>
    <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>X</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>normal-Œ©</ci>
     <ci>ùí≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X:\Omega\rightarrow\mathcal{X}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Coding_theory:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>‚àà</mo>
   <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>ùí≥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathcal{X}
  </annotation>
 </semantics>
</math>

 appears with probability 

<math display="inline" id="Coding_theory:2">
 <semantics>
  <mrow>
   <mi>‚Ñô</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{P}[X=x]
  </annotation>
 </semantics>
</math>

.</p>

<p>Data are encoded by strings (words) over an <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> 

<math display="inline" id="Coding_theory:3">
 <semantics>
  <mi mathvariant="normal">Œ£</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ£</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

.</p>

<p>A code is a function</p>

<p>

<math display="inline" id="Coding_theory:4">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
    <mo>‚Üí</mo>
    <msup>
     <mi mathvariant="normal">Œ£</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>ùí≥</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œ£</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:\mathcal{X}\rightarrow\Sigma^{*}
  </annotation>
 </semantics>
</math>

 (or 

<math display="inline" id="Coding_theory:5">
 <semantics>
  <msup>
   <mi mathvariant="normal">Œ£</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Œ£</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{+}
  </annotation>
 </semantics>
</math>

 if the empty string is not part of the alphabet).</p>

<p>

<math display="inline" id="Coding_theory:6">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x)
  </annotation>
 </semantics>
</math>

 is the code word associated with 

<math display="inline" id="Coding_theory:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

.</p>

<p>Length of the code word is written as</p>

<p>

<math display="inline" id="Coding_theory:8">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(C(x))
  </annotation>
 </semantics>
</math>

.</p>

<p>Expected length of a code is</p>

<p>

<math display="inline" id="Coding_theory:9">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">‚àë</mo>
    <mrow>
     <mi>x</mi>
     <mo>‚àà</mo>
     <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
    </mrow>
   </msub>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>‚Ñô</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>ùí≥</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(C)=\sum_{x\in\mathcal{X}}l(C(x))\mathbb{P}[X=x]
  </annotation>
 </semantics>
</math>

</p>

<p>The concatenation of code words 

<math display="inline" id="Coding_theory:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x_{1},...,x_{k})=C(x_{1})C(x_{2})...C(x_{k})
  </annotation>
 </semantics>
</math>

.</p>

<p>The code word of the empty string is the empty string itself:</p>

<p>

<math display="inline" id="Coding_theory:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>œµ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>œµ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>œµ</ci>
    </apply>
    <ci>œµ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\epsilon)=\epsilon
  </annotation>
 </semantics>
</math>

</p>
<h3 id="properties">Properties</h3>
<ol>
<li>

<math display="inline" id="Coding_theory:12">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
    <mo>‚Üí</mo>
    <msup>
     <mi mathvariant="normal">Œ£</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>ùí≥</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œ£</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:\mathcal{X}\rightarrow\Sigma^{*}
  </annotation>
 </semantics>
</math>

 is <a href="Variable-length_code#Non-singular_codes" title="wikilink">non-singular</a> if <a href="Injective_function" title="wikilink">injective</a>.</li>
<li>

<math display="inline" id="Coding_theory:13">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
     <mo>*</mo>
    </msup>
    <mo>‚Üí</mo>
    <msup>
     <mi mathvariant="normal">Œ£</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùí≥</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œ£</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:\mathcal{X}^{*}\rightarrow\Sigma^{*}
  </annotation>
 </semantics>
</math>

 is <a href="Uniquely_decodable_code#Uniquely_decodable_codes" title="wikilink">uniquely decodable</a> if injective.</li>
<li>

<math display="inline" id="Coding_theory:14">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
    <mo>‚Üí</mo>
    <msup>
     <mi mathvariant="normal">Œ£</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>ùí≥</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œ£</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:\mathcal{X}\rightarrow\Sigma^{*}
  </annotation>
 </semantics>
</math>

 is <a href="Variable-length_code#Prefix_codes" title="wikilink">instantaneous</a> if 

<math display="inline" id="Coding_theory:15">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x_{1})
  </annotation>
 </semantics>
</math>

 is not a prefix of 

<math display="inline" id="Coding_theory:16">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x_{2})
  </annotation>
 </semantics>
</math>

 (and vice versa).</li>
</ol>
<h3 id="principle">Principle</h3>

<p><a href="Entropy_(information_theory)" title="wikilink">Entropy</a> of a source is the measure of information. Basically, source codes try to reduce the redundancy present in the source, and represent the source with fewer bits that carry more information.</p>

<p>Data compression which explicitly tries to minimize the average length of messages according to a particular assumed probability model is called <a href="entropy_encoding" title="wikilink">entropy encoding</a>.</p>

<p>Various techniques used by source coding schemes try to achieve the limit of Entropy of the source. <em>C</em>(<em>x</em>) ‚â• <em>H</em>(<em>x</em>), where <em>H</em>(<em>x</em>) is entropy of source (bitrate), and <em>C</em>(<em>x</em>) is the bitrate after compression. In particular, no source coding scheme can be better than the entropy of the source.</p>
<h3 id="example">Example</h3>

<p><a href="FAX" title="wikilink">Facsimile</a> transmission uses a simple <a href="Run-length_encoding" title="wikilink">run length code</a>. Source coding removes all data superfluous to the need of the transmitter, decreasing the bandwidth required for transmission.</p>
<h2 id="channel-coding">Channel coding</h2>

<p>The purpose of channel coding theory is to find codes which transmit quickly, contain many valid <a href="code_word" title="wikilink">code words</a> and can correct or at least <a href="error_detection" title="wikilink">detect</a> many errors. While not mutually exclusive, performance in these areas is a trade off. So, different codes are optimal for different applications. The needed properties of this code mainly depend on the probability of errors happening during transmission. In a typical CD, the impairment is mainly dust or scratches. Thus codes are used in an interleaved manner. The data is spread out over the disk.</p>

<p>Although not a very good code, a simple repeat code can serve as an understandable example. Suppose we take a block of data bits (representing sound) and send it three times. At the receiver we will examine the three repetitions bit by bit and take a majority vote. The twist on this is that we don't merely send the bits in order. We interleave them. The block of data bits is first divided into 4 smaller blocks. Then we cycle through the block and send one bit from the first, then the second, etc. This is done three times to spread the data out over the surface of the disk. In the context of the simple repeat code, this may not appear effective. However, there are more powerful codes known which are very effective at correcting the "burst" error of a scratch or a dust spot when this interleaving technique is used.</p>

<p>Other codes are more appropriate for different applications. Deep space communications are limited by the <a href="thermal_noise" title="wikilink">thermal noise</a> of the receiver which is more of a continuous nature than a bursty nature. Likewise, narrowband modems are limited by the noise, present in the telephone network and also modeled better as a continuous disturbance. Cell phones are subject to rapid fading. The high frequencies used can cause rapid fading of the signal even if the receiver is moved a few inches. Again there are a class of channel codes that are designed to combat fading.</p>
<h3 id="linear-codes">Linear codes</h3>

<p>The term <strong>algebraic coding theory</strong> denotes the sub-field of coding theory where the properties of codes are expressed in algebraic terms and then further researched.</p>

<p>Algebraic coding theory is basically divided into two major types of codes:</p>
<ol>
<li>Linear block codes</li>
<li>Convolutional codes.</li>
</ol>

<p>It analyzes the following three properties of a code ‚Äì mainly:</p>
<ul>
<li>code word length</li>
<li>total number of valid code words</li>
<li>the minimum <a class="uri" href="distance" title="wikilink">distance</a> between two valid code words, using mainly the <a href="Hamming_distance" title="wikilink">Hamming distance</a>, sometimes also other distances like the <a href="Lee_distance" title="wikilink">Lee distance</a>.</li>
</ul>
<h4 id="linear-block-codes">Linear block codes</h4>

<p>Linear block codes have the property of <a class="uri" href="linearity" title="wikilink">linearity</a>, i.e. the sum of any two codewords is also a code word, and they are applied to the source bits in blocks, hence the name linear block codes. There are block codes that are not linear, but it is difficult to prove that a code is a good one without this property.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Linear block codes are summarized by their symbol alphabets (e.g., binary or ternary) and parameters (<em>n</em>,<em>m</em>,<em>d<sub>min</sub></em>)<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> where</p>
<ol>
<li>n is the length of the codeword, in symbols,</li>
<li>m is the number of source symbols that will be used for encoding at once,</li>
<li><em>d<sub>min</sub></em> is the minimum hamming distance for the code.</li>
</ol>

<p>There are many types of linear block codes, such as</p>
<ol>
<li><a href="Cyclic_code" title="wikilink">Cyclic codes</a> (e.g., <a href="Hamming_code" title="wikilink">Hamming codes</a>)</li>
<li><a href="Repetition_code" title="wikilink">Repetition codes</a></li>
<li><a href="Parity_bit" title="wikilink">Parity codes</a></li>
<li><a href="Polynomial_code" title="wikilink">Polynomial codes</a> (e.g., <a href="BCH_code" title="wikilink">BCH codes</a>)</li>
<li><a href="Reed-Solomon_error_correction" title="wikilink">Reed‚ÄìSolomon codes</a></li>
<li><a href="Algebraic_geometric_code" title="wikilink">Algebraic geometric codes</a></li>
<li><a href="Reed‚ÄìMuller_code" title="wikilink">Reed‚ÄìMuller codes</a></li>
<li><a href="Hamming_bound" title="wikilink">Perfect codes</a>.</li>
</ol>

<p>Block codes are tied to the <a href="sphere_packing" title="wikilink">sphere packing</a> problem, which has received some attention over the years. In two dimensions, it is easy to visualize. Take a bunch of pennies flat on the table and push them together. The result is a hexagon pattern like a bee's nest. But block codes rely on more dimensions which cannot easily be visualized. The powerful (24,12) <a href="Binary_Golay_code" title="wikilink">Golay code</a> used in deep space communications uses 24 dimensions. If used as a binary code (which it usually is) the dimensions refer to the length of the codeword as defined above.</p>

<p>The theory of coding uses the <em>N</em>-dimensional sphere model. For example, how many pennies can be packed into a circle on a tabletop, or in 3 dimensions, how many marbles can be packed into a globe. Other considerations enter the choice of a code. For example, hexagon packing into the constraint of a rectangular box will leave empty space at the corners. As the dimensions get larger, the percentage of empty space grows smaller. But at certain dimensions, the packing uses all the space and these codes are the so-called "perfect" codes. The only nontrivial and useful perfect codes are the distance-3 Hamming codes with parameters satisfying (2<sup><em>r</em></sup> ‚Äì 1, 2<sup><em>r</em></sup> ‚Äì 1 ‚Äì <em>r</em>, 3), and the [23,12,7] binary and [11,6,5] ternary Golay codes.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Another code property is the number of neighbors that a single codeword may have.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Again, consider pennies as an example. First we pack the pennies in a rectangular grid. Each penny will have 4 near neighbors (and 4 at the corners which are farther away). In a hexagon, each penny will have 6 near neighbors. When we increase the dimensions, the number of near neighbors increases very rapidly. The result is the number of ways for noise to make the receiver choose a neighbor (hence an error) grows as well. This is a fundamental limitation of block codes, and indeed all codes. It may be harder to cause an error to a single neighbor, but the number of neighbors can be large enough so the total error probability actually suffers.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Properties of linear block codes are used in many applications. For example, the syndrome-coset uniqueness property of linear block codes is used in trellis shaping,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> one of the best known <a href="shaping_codes" title="wikilink">shaping codes</a>. This same property is used in sensor networks for distributed source coding</p>
<h4 id="convolutional-codes">Convolutional codes</h4>

<p>The idea behind a convolutional code is to make every codeword symbol be the weighted sum of the various input message symbols. This is like <a class="uri" href="convolution" title="wikilink">convolution</a> used in <a href="linear_time_invariant" title="wikilink">LTI</a> systems to find the output of a system, when you know the input and impulse response.</p>

<p>So we generally find the output of the system convolutional encoder, which is the convolution of the input bit, against the states of the convolution encoder, registers.</p>

<p>Fundamentally, convolutional codes do not offer more protection against noise than an equivalent block code. In many cases, they generally offer greater simplicity of implementation over a block code of equal power. The encoder is usually a simple circuit which has state memory and some feedback logic, normally XOR gates. The <a href="Decoding_methods" title="wikilink">decoder</a> can be implemented in software or firmware.</p>

<p>The <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a> is the optimum algorithm used to decode convolutional codes. There are simplifications to reduce the computational load. They rely on searching only the most likely paths. Although not optimum, they have generally been found to give good results in the lower noise environments.</p>

<p>Convolutional codes are used in voiceband modems (V.32, V.17, V.34) and in GSM mobile phones, as well as satellite and military communication devices.</p>
<h2 id="cryptographical-coding">Cryptographical coding</h2>

<p><a class="uri" href="Cryptography" title="wikilink">Cryptography</a> or cryptographic coding is the practice and study of techniques for <a href="secure_communication" title="wikilink">secure communication</a> in the presence of third parties (called <a href="adversary_(cryptography)" title="wikilink">adversaries</a>).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> More generally, it is about constructing and analyzing <a href="communications_protocol" title="wikilink">protocols</a> that block adversaries;<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> various aspects in <a href="information_security" title="wikilink">information security</a> such as data <a class="uri" href="confidentiality" title="wikilink">confidentiality</a>, <a href="data_integrity" title="wikilink">data integrity</a>, <a class="uri" href="authentication" title="wikilink">authentication</a>, and <a class="uri" href="non-repudiation" title="wikilink">non-repudiation</a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> are central to modern cryptography. Modern cryptography exists at the intersection of the disciplines of <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <a href="computer_science" title="wikilink">computer science</a>, and <a href="electrical_engineering" title="wikilink">electrical engineering</a>. Applications of cryptography include <a href="automated_teller_machine" title="wikilink">ATM cards</a>, <a href="password" title="wikilink">computer passwords</a>, and <a href="electronic_commerce" title="wikilink">electronic commerce</a>.</p>

<p>Cryptography prior to the modern age was effectively synonymous with <em><a class="uri" href="encryption" title="wikilink">encryption</a></em>, the conversion of information from a readable state to apparent <a class="uri" href="nonsense" title="wikilink">nonsense</a>. The originator of an encrypted message shared the decoding technique needed to recover the original information only with intended recipients, thereby precluding unwanted persons from doing the same. Since <a href="World_War_I" title="wikilink">World War I</a> and the advent of the <a class="uri" href="computer" title="wikilink">computer</a>, the methods used to carry out cryptology have become increasingly complex and its application more widespread.</p>

<p>Modern cryptography is heavily based on mathematical theory and computer science practice; cryptographic algorithms are designed around <a href="computational_hardness_assumption" title="wikilink">computational hardness assumptions</a>, making such algorithms hard to break in practice by any adversary. It is theoretically possible to break such a system, but it is infeasible to do so by any known practical means. These schemes are therefore termed computationally secure; theoretical advances, e.g., improvements in <a href="integer_factorization" title="wikilink">integer factorization</a> algorithms, and faster computing technology require these solutions to be continually adapted. There exist <a href="Information_theoretic_security" title="wikilink">information-theoretically secure</a> schemes that  cannot be broken even with unlimited computing power‚Äîan example is the <a href="one-time_pad" title="wikilink">one-time pad</a>‚Äîbut these schemes are more difficult to implement than the best theoretically breakable but computationally secure mechanisms.</p>
<h2 id="line-coding">Line coding</h2>

<p>A <a href="line_code" title="wikilink">line code</a> (also called digital baseband modulation or digital baseband transmission method) is a <a class="uri" href="code" title="wikilink">code</a> chosen for use within a <a href="communications_system" title="wikilink">communications system</a> for <a class="uri" href="baseband" title="wikilink">baseband</a> <a href="transmission_(telecommunications)" title="wikilink">transmission</a> purposes. Line coding is often used for digital data transport.</p>

<p>Line coding consists of representing the <a href="digital_signal" title="wikilink">digital signal</a> to be transported by an amplitude- and time-discrete signal that is optimally tuned for the specific properties of the physical channel (and of the receiving equipment). The <a class="uri" href="waveform" title="wikilink">waveform</a> pattern of voltage or current used to represent the 1s and 0s of a digital data on a transmission link is called <em>line encoding</em>. The common types of line encoding are <a href="Unipolar_encoding" title="wikilink">unipolar</a>, <a href="Polar_encoding" title="wikilink">polar</a>, <a href="Bipolar_encoding" title="wikilink">bipolar</a>, and <a href="Manchester_encoding" title="wikilink">Manchester encoding</a>.</p>
<h2 id="other-applications-of-coding-theory">Other applications of coding theory</h2>

<p>Another concern of coding theory is designing codes that help <a class="uri" href="synchronization" title="wikilink">synchronization</a>. A code may be designed so that a <a href="Phase_(waves)" title="wikilink">phase shift</a> can be easily detected and corrected and that multiple signals can be sent on the same channel.</p>

<p>Another application of codes, used in some mobile phone systems, is <a href="code-division_multiple_access" title="wikilink">code-division multiple access</a> (CDMA). Each phone is assigned a code sequence that is approximately uncorrelated with the codes of other phones. When transmitting, the code word is used to modulate the data bits representing the voice message. At the receiver, a demodulation process is performed to recover the data. The properties of this class of codes allow many users (with different codes) to use the same radio channel at the same time. To the receiver, the signals of other users will appear to the demodulator only as a low-level noise.</p>

<p>Another general class of codes are the <a href="automatic_repeat-request" title="wikilink">automatic repeat-request</a> (ARQ) codes. In these codes the sender adds redundancy to each message for error checking, usually by adding check bits. If the check bits are not consistent with the rest of the message when it arrives, the receiver will ask the sender to retransmit the message. All but the simplest <a href="wide_area_network" title="wikilink">wide area network</a> protocols use ARQ. Common protocols include <a href="Synchronous_Data_Link_Control" title="wikilink">SDLC</a> (IBM), <a href="Transmission_Control_Protocol" title="wikilink">TCP</a> (Internet), <a class="uri" href="X.25" title="wikilink">X.25</a> (International) and many others. There is an extensive field of research on this topic because of the problem of matching a rejected packet against a new packet. Is it a new one or is it a retransmission? Typically numbering schemes are used, as in TCP.</p>
<h3 id="group-testing">Group testing</h3>

<p><a href="Group_testing" title="wikilink">Group testing</a> uses codes in a different way. Consider a large group of items in which a very few are different in a particular way (e.g., defective products or infected test subjects). The idea of group testing is to determine which items are "different" by using as few tests as possible. The origin of the problem has its roots in the <a href="Second_World_War" title="wikilink">Second World War</a> when the <a href="United_States_Army_Air_Forces" title="wikilink">United States Army Air Forces</a> needed to test its soldiers for <a class="uri" href="syphilis" title="wikilink">syphilis</a>. It originated from a ground-breaking paper by <a href="Robert_Dorfman" title="wikilink">Robert Dorfman</a>.</p>
<h3 id="analog-coding">Analog coding</h3>

<p>Information is encoded analogously in the <a href="neural_network" title="wikilink">neural networks</a> of <a href="brain" title="wikilink">brains</a>, in <a href="analog_signal_processing" title="wikilink">analog signal processing</a>, and <a href="analog_electronics" title="wikilink">analog electronics</a>. Aspects of [<a class="uri" href="http://scholar.google.com/scholar">http://scholar.google.com/scholar</a>?&amp;q;=%22analog+code%22+OR+%22analogue+code%22+OR+%22analogue+coding%22+OR+%22analog+coding%22 analog coding] include <a href="http://scholar.google.com/scholar?q=%22analog+error+correction%22">analog error correction</a>,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a href="http://scholar.google.com/scholar?q=%22analog+data+compression%22">analog data compression</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> [<a class="uri" href="http://scholar.google.com/scholar?hl=en&amp;q">http://scholar.google.com/scholar?hl=en&amp;q;</a>;=%22analog+encryption%22 analog encryption]<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="neural-coding">Neural coding</h2>

<p><a href="Neural_coding" title="wikilink">Neural coding</a> is a <a class="uri" href="neuroscience" title="wikilink">neuroscience</a>-related field concerned with how sensory and other information is represented in the <a class="uri" href="brain" title="wikilink">brain</a> by <a href="neural_network" title="wikilink">networks</a> of <a class="uri" href="neurons" title="wikilink">neurons</a>. The main goal of studying neural coding is to characterize the relationship between the <a href="Stimulus_(physiology)" title="wikilink">stimulus</a> and the individual or ensemble neuronal responses and the relationship among electrical activity of the neurons in the ensemble.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> It is thought that neurons can encode both <a href="Digital_data" title="wikilink">digital</a> and <a href="analog_signal" title="wikilink">analog</a> information,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> and that neurons follow the principles of information theory and compress information,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> and detect and correct<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> errors in the signals that are sent throughout the brain and wider nervous system.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Coding_gain" title="wikilink">Coding gain</a></li>
<li><a href="Covering_code" title="wikilink">Covering code</a></li>
<li><a href="Error-correcting_code" title="wikilink">Error-correcting code</a></li>
<li><a href="Group_testing" title="wikilink">Group testing</a></li>
<li><a href="Hamming_distance" title="wikilink">Hamming distance</a>, <a href="Hamming_weight" title="wikilink">Hamming weight</a></li>
<li><a href="Information_theory" title="wikilink">Information theory</a></li>
<li><a href="Lee_distance" title="wikilink">Lee distance</a></li>
<li>Spatial coding and <a class="uri" href="MIMO" title="wikilink">MIMO</a> in <a href="multiple_antenna_research" title="wikilink">multiple antenna research</a>
<ul>
<li><a href="Space‚Äìtime_code" title="wikilink">Spatial diversity coding</a> is spatial coding that transmits replicas of the information signal along different spatial paths, so as to increase the reliability of the data transmission.</li>
<li><a href="Dirty_paper_coding_(DPC)" title="wikilink">Spatial interference cancellation coding</a></li>
<li><a href="Spatial_multiplexing" title="wikilink">Spatial multiplex coding</a></li>
</ul></li>
<li><a href="Timeline_of_information_theory" title="wikilink">Timeline of information theory, data compression, and error correcting codes</a></li>
<li><a href="List_of_algebraic_coding_theory_topics" title="wikilink">List of algebraic coding theory topics</a></li>
<li><a href="Folded_Reed‚ÄìSolomon_codes" title="wikilink">Folded Reed‚ÄìSolomon codes</a></li>
<li><a href="ABNNR_and_AEL_codes" title="wikilink">ABNNR and AEL codes</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Vera_Pless" title="wikilink">Vera Pless</a> (1982), <em>Introduction to the Theory of Error-Correcting Codes</em>, John Wiley &amp; Sons, Inc., ISBN 0-471-08684-3.</li>
<li><a href="Elwyn_R._Berlekamp" title="wikilink">Elwyn R. Berlekamp</a> (1984), <em>Algebraic Coding Theory</em>, Aegean Park Press (revised edition), ISBN 0-89412-063-8, ISBN 978-0-89412-063-3.</li>
<li>Randy Yates, <em><a href="http://www.digitalsignallabs.com/tutorial.pdf">A Coding Theory Tutorial</a></em>.</li>
</ul>

<p>"</p>

<p><a href="Category:Coding_theory" title="wikilink"> </a> <a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">James Irvine, David Harle. <a href="http://books.google.com/books?id=ZigejECe4r0C">"Data Communications and Networks"</a>. 2002. p. 18. section "2.4.4 Types of Coding". quote: "There are four types of coding"<a href="#fnref1">‚Ü©</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13"><a href="#fnref13">‚Ü©</a></li>
<li id="fn14"><a href="#fnref14">‚Ü©</a></li>
<li id="fn15"><a href="#fnref15">‚Ü©</a></li>
<li id="fn16"><a href="#fnref16">‚Ü©</a></li>
<li id="fn17"><a href="#fnref17">‚Ü©</a></li>
<li id="fn18"><a href="#fnref18">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
