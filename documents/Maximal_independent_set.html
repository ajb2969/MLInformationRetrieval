<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1466">Maximal independent set</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Maximal independent set</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The <a href="hypercube_graph" title="wikilink">graph of the cube</a> has six different maximal independent sets, shown as the red vertices.</figcaption>
</figure>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>maximal independent set</strong> (MIS) or <strong>maximal stable set</strong> is an <a href="Independent_set_(graph_theory)" title="wikilink">independent set</a> that is not a subset of any other independent set. That is, it is a set <em>S</em> such that every edge of the graph has at least one endpoint not in <em>S</em> and every vertex not in <em>S</em> has at least one neighbor in <em>S</em>.</p>

<p>A MIS is also a <a href="dominating_set" title="wikilink">dominating set</a> in the graph, and every dominating set that is independent must be maximal independent, so MISs are also called <strong>independent dominating sets</strong>.</p>

<p>A graph may have many MISs of widely varying sizes;<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>a largest MISs is called a <a href="maximum_independent_set" title="wikilink">maximum independent set</a>.</p>

<p>For example, in the graph P<sub>3</sub>, a path with three vertices <em>a</em>, <em>b</em>, and <em>c</em>, and two edges <em>ab</em> and <em>bc</em>, the sets {<em>b</em>} and {<em>a</em>,<em>c</em>} are both maximally independent. The set {<em>a</em>} is independent, but is not maximal independent, because it is a subset of the larger independent set {<em>a</em>,<em>c</em>}. In this same graph, the maximal cliques are the sets {<em>a</em>,<em>b</em>} and {<em>b</em>,<em>c</em>}.</p>

<p>The phrase "maximal independent set" is also used to describe maximal subsets of independent elements in mathematical structures other than graphs, and in particular in <a href="vector_space" title="wikilink">vector spaces</a> and <a href="matroid" title="wikilink">matroids</a>.</p>

<p>Two <a href="algorithmic_problem" title="wikilink">algorithmic problems</a> are associated with MISs: <a href="#Finding_a_single_maximal_independent_set" title="wikilink">finding a <em>single</em> MIS in a given graph</a> and <a href="#Listing_all_maximal_independent_sets" title="wikilink">listing <em>all</em> MISs in a given graph</a>.</p>
<h2 id="related-vertex-sets">Related vertex sets</h2>

<p>If <em>S</em> is a maximal independent set in some graph, it is a <strong>maximal clique</strong> or <strong>maximal complete subgraph</strong> in the <a href="complement_graph" title="wikilink">complementary graph</a>. A maximal clique is a set of vertices that <a href="induced_subgraph" title="wikilink">induces</a> a <a href="complete_graph" title="wikilink">complete subgraph</a>, and that is not a subset of the vertices of any larger complete subgraph. That is, it is a set <em>S</em> such that every pair of vertices in <em>S</em> is connected by an edge and every vertex not in <em>S</em> is missing an edge to at least one vertex in <em>S</em>. A graph may have many maximal cliques, of varying sizes; finding the largest of these is the <a href="Clique_problem" title="wikilink">maximum clique problem</a>.</p>

<p>Some authors include maximality as part of the definition of a clique, and refer to maximal cliques simply as cliques.</p>

<p>The <a href="complement_(set_theory)" title="wikilink">complement</a> of a maximal independent set, that is, the set of vertices not belonging to the independent set, forms a <strong>minimal vertex cover</strong>. That is, the complement is a <a href="vertex_cover" title="wikilink">vertex cover</a>, a set of vertices that includes at least one endpoint of each edge, and is minimal in the sense that none of its vertices can be removed while preserving the property that it is a cover. Minimal vertex covers have been studied in <a href="statistical_mechanics" title="wikilink">statistical mechanics</a> in connection with the <a href="Hard_spheres" title="wikilink">hard-sphere lattice gas</a> model, a mathematical abstraction of fluid-solid state transitions.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Every maximal independent set is a <a href="dominating_set" title="wikilink">dominating set</a>, a set of vertices such that every vertex in the graph either belongs to the set or is adjacent to the set. A set of vertices is a maximal independent set if and only if it is an independent dominating set.</p>
<h2 id="graph-family-characterizations">Graph family characterizations</h2>

<p>Certain graph families have also been characterized in terms of their maximal cliques or maximal independent sets. Examples include the maximal-clique irreducible and hereditary maximal-clique irreducible graphs. A graph is said to be <em>maximal-clique irreducible</em> if every maximal clique has an edge that belongs to no other maximal clique, and <em>hereditary maximal-clique irreducible</em> if the same property is true for every induced subgraph.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Hereditary maximal-clique irreducible graphs include <a href="triangle-free_graph" title="wikilink">triangle-free graphs</a>, <a href="bipartite_graph" title="wikilink">bipartite graphs</a>, and <a href="interval_graph" title="wikilink">interval graphs</a>.</p>

<p><a href="Cograph" title="wikilink">Cographs</a> can be characterized as graphs in which every maximal clique intersects every maximal independent set, and in which the same property is true in all induced subgraphs.</p>
<h2 id="bounding-the-number-of-sets">Bounding the number of sets</h2>

<p>showed that any graph with <em>n</em> vertices has at most 3<sup><em>n</em>/3</sup> maximal cliques. Complementarily, any graph with <em>n</em> vertices also has at most 3<sup><em>n</em>/3</sup> maximal independent sets. A graph with exactly 3<sup><em>n</em>/3</sup> maximal independent sets is easy to construct: simply take the disjoint union of <em>n</em>/3 <a href="cycle_graph" title="wikilink">triangle graphs</a>. Any maximal independent set in this graph is formed by choosing one vertex from each triangle. The complementary graph, with exactly 3<sup><em>n</em>/3</sup> maximal cliques, is a special type of <a href="Turán_graph" title="wikilink">Turán graph</a>; because of their connection with Moon and Moser's bound, these graphs are also sometimes called Moon-Moser graphs. Tighter bounds are possible if one limits the size of the maximal independent sets: the number of maximal independent sets of size <em>k</em> in any <em>n</em>-vertex graph is at most</p>

<p>

<math display="block" id="Maximal_independent_set:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">⌊</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mi>k</mi>
      </mrow>
      <mo stretchy="false">⌋</mo>
     </mrow>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">⌊</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mi>k</mi>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">⌋</mo>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
      <mi>k</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <floor></floor>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <floor></floor>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor n/k\rfloor^{k-(n\bmod k)}\lfloor n/k+1\rfloor^{n\bmod k}.
  </annotation>
 </semantics>
</math>

 The graphs achieving this bound are again Turán graphs.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Certain families of graphs may, however, have much more restrictive bounds on the numbers of maximal independent sets or maximal cliques. If all <em>n</em>-vertex graphs in a family of graphs have O(<em>n</em>) edges, and if every subgraph of a graph in the family also belongs to the family, then each graph in the family can have at most O(<em>n</em>) maximal cliques, all of which have size O(1).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> For instance, these conditions are true for the <a href="planar_graph" title="wikilink">planar graphs</a>: every <em>n</em>-vertex planar graph has at most 3<em>n</em> − 6 edges, and a subgraph of a planar graph is always planar, from which it follows that each planar graph has O(<em>n</em>) maximal cliques (of size at most four). <a href="Interval_graph" title="wikilink">Interval graphs</a> and <a href="chordal_graph" title="wikilink">chordal graphs</a> also have at most <em>n</em> maximal cliques, even though they are not always <a href="sparse_graph" title="wikilink">sparse graphs</a>.</p>

<p>The number of maximal independent sets in <em>n</em>-vertex <a href="cycle_graph" title="wikilink">cycle graphs</a> is given by the <a href="Perrin_number" title="wikilink">Perrin numbers</a>, and the number of maximal independent sets in <em>n</em>-vertex <a href="path_(graph_theory)" title="wikilink">path graphs</a> is given by the <a href="Padovan_sequence" title="wikilink">Padovan sequence</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Therefore, both numbers are proportional to powers of 1.324718, the <a href="plastic_number" title="wikilink">plastic number</a>.</p>
<h2 id="finding-a-single-maximal-independent-set">Finding a single maximal independent set</h2>
<h3 id="sequential-algorithm">Sequential algorithm</h3>

<p>Given a graph G(V,E), it is easy to find a single MIS using the following algorithm:</p>
<ol>
<li>Initialize I to an empty set.</li>
<li>While V is not empty:
<ul>
<li>Choose a node v∈V;</li>
<li>Add v to the set I;</li>
<li>Remove from V the node v and all its neighbours.</li>
</ul></li>
<li>Return I.</li>
</ol>

<p>The runtime is O(<em>n</em>) since in the worst case we have to check all nodes.</p>

<p>O(n) is obviously the best possible runtime for a serial algorithm. But a parallel algorithm can solve the problem much faster.</p>
<h3 id="random-selection-parallel-algorithm">Random-selection parallel algorithm</h3>

<p>The following algorithm finds a MIS in time O(log <em>n</em>).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<ol>
<li>Initialize I to an empty set.</li>
<li>While V is not empty:
<ul>
<li>Choose a random set of vertices S ⊆ V, by selecting each vertex v independently with probability 1/(2d(v)), where d is the degree of v (the number of neighbours of v).</li>
<li>For every edge in E, if both its endpoints are in the random set S, then remove from S the endpoint whose degree is lower (i.e. has fewer neighbours). Break ties arbitrarily, e.g. using a lexicographic order on the vertex names.</li>
<li>Add the set S to I.</li>
<li>Remove from V the set S and all the neighbours of nodes in S.</li>
</ul></li>
<li>Return I.</li>
</ol>

<p><strong>ANALYSIS</strong>: For each node v, divide its neighbours to <em>lower neighbours</em> (whose degree is lower than the degree of v) and <em>higher neighbours</em> (whose degree is higher than the degree of v), breaking ties as in the algorithm.</p>

<p>Call a node v <em>bad</em> if more than 2/3 of its neighbors are higher neighbours. Call an edge <em>bad</em> if both its endpoints are bad; otherwise the edge is <em>good</em>.</p>
<ul>
<li>At least 1/2 of all edges are always good. PROOF: Build a directed version of G by directing each edge to the node with the higher degree (breaking ties arbitrarily). So for every bad node, the number of out-going edges is more than 2 times the number of in-coming edges. So every bad edge, that enters a node v, can be matched to a distinct set of two edges that exit the node v. Hence the total number of edges is at least 2 times the number of bad edges.</li>
<li>For every good node u, the probability that a neighbour of u is selected to S is at least a certain positive constant. PROOF: the probability that NO neighbour of u is selected to S is at most the probability that none of u's <em>lower neighbours</em> is selected. For each lower-neighbour v, the probability that it is not selected is (1-1/2d(v)), which is at most (1-1/2d(u)) (since d(u)≤d(v)). The number of such neighours is at least d(u)/3, since u is good. Hence the probability that no lower-neighbour is selected is at most 1-exp(-1/6).</li>
<li>For every node u that is selected to S, the probability that u will be removed from S is at most 1/2. PROOF: This probability is at most the probability that a higher-neighbour of u is selected to S. For each higher-neighbour v, the probability that it is selected is at most 1/2d(v), which is at most 1/2d(u) (since d(v)≤d(u)). By union bound, the probability that no higher-neighbour is selected is at most d(u)/2d(u) = 1/2.</li>
<li>Hence, for every good node u, the probability that a neighbour of u is selected to S and remains in S is a certain positive constant. Hence, the probability that u is removed, in each step, is at least a positive constant.</li>
<li>Hence, for every good edge e, the probability that e is removed, in each step, is at least a positive constant. So the number of good edges drops by at least a constant factor each step.</li>
<li>Since at least half the edges are good, the total number of edges also drops by a constant factor each step.</li>
<li>Hence, the number of steps is O(log <em>m</em>), where <em>m</em> is the number of edges. This is bounded by 

<math display="inline" id="Maximal_independent_set:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(n))
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>A worst-case graph, in which the average number of steps is 

<math display="inline" id="Maximal_independent_set:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(\log(n))
  </annotation>
 </semantics>
</math>

, is a graph made of <em>n</em>/2 connected components, each with 2 nodes. The degree of all nodes is 1, so each node is selected with probability 1/2, and with probability 1/4 both nodes in a component are not chosen. Hence, the number of nodes drops by a factor of 4 each step, and the expected number of steps is 

<math display="inline" id="Maximal_independent_set:3">
 <semantics>
  <mrow>
   <msub>
    <mi>log</mi>
    <mn>4</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <cn type="integer">4</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{4}(n)
  </annotation>
 </semantics>
</math>


.</p>
<h3 id="random-priority-parallel-algorithm">Random-priority parallel algorithm</h3>

<p>The following algorithm is better than the previous one in that at least one new node is always added in each connected component:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<ol>
<li>Initialize I to an empty set.</li>
<li>While V is not empty, each node v does the following:
<ul>
<li>Selects a random number r(v) in [0,1] and sends it to its neighbours;</li>
<li>If r(v) is smaller than the numbers of all neighbours of v, then v inserts itself into I, removes itself from V and tells its neighbours about this;</li>
<li>If v heard that one of its neighbours got into I, then v removes itself from V.</li>
</ul></li>
<li>Return I.</li>
</ol>

<p>Note that in every step, the node with the smallest number in each connected component always enters I, so there is always some progress. In particular, in the worst-case of the previous algorithm (<em>n</em>/2 connected components with 2 nodes each), a MIS will be found in a single step.</p>

<p><strong>ANALYSIS</strong>:</p>
<ul>
<li>In each step, in expectation, half the edges are removed. PROOF: For every ordered pair of nodes (v,w), define the following event: r(v)<r(w), (once="" (w,v),="" *="" 1="" <math="" [d(v)+d(w)]="1." [d(v)+d(w)].="" [d(w)+d(v)]="" [d(w)+d(v)].="" a="" algorithm="" all="" also="" an="" and="" are="" at="" but="" counted="" d(v)="" d(w)="" direction).="" due="" each="" edge="" edges="" event="" every="" expected="" for="" gives="" happens="" having="" hence="" hence,="" i.e.="" if="" is="" least="" neighbour="" neighbours="" nodes="" number="" of="" one="" over="" pair="" per="" probability="" r(v)<r="" removed="" reverse="" run="" same="" small="" step="" summing="" the="" then="" these="" this="" time="" to="" true="" twice="" undirected="" value="" w="" w-v="" x="">3 \log_{4/3}(m)+1</r(w),></li></ul></body></html>

<p>which is 

<math display="inline" id="Maximal_independent_set:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(n))
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<h3 id="random-permutation-parallel-algorithm">Random-permutation parallel algorithm</h3>

<p>Instead of randomizing in each step, it is possible to randomize once, at the beginning of the algorithm, by fixing a random ordering on the nodes. Given this fixed ordering, the following parallel algorithm achieves exactly the same MIS as the <a href="#Sequential_algorithm" title="wikilink">#Sequential algorithm</a> (i.e. the result is deterministic):<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<ol>
<li>Initialize I to an empty set.</li>
<li>While V is not empty:
<ul>
<li>Let W be the set of vertices in V with no earlier neighbours (based on the fixed ordering);</li>
<li>Add W to I;</li>
<li>Remove from V the nodes in the set W and all their neighbours.</li>
</ul></li>
<li>Return I.</li>
</ol>

<p>Between the totally sequential and the totally parallel algorithms, there is a continuum of algorithms that are partly sequential and partly parallel. Given a fixed ordering on the nodes and a factor δ∈(0,1], the following algorithm returns the same MIS:</p>
<ol>
<li>Initialize I to an empty set.</li>
<li>While V is not empty:
<ul>
<li>Select a factor δ∈(0,1].</li>
<li>Let P be the set of δ<em>n</em> nodes that are first in the fixed ordering.</li>
<li>Let W be a MIS on P using the totally parallel algorithm.</li>
<li>Add W to I;</li>
<li>Remove from V all the nodes in the prefix P, and all the neighbours of nodes in the set W.</li>
</ul></li>
<li>Return I.</li>
</ol>

<p>Setting δ=1/<em>n</em> gives the totally sequential algorithm; setting δ=1 gives the totally parallel algorithm.</p>

<p><strong>ANALYSIS</strong>: With a proper selection of the parameter δ in the partially parallel algorithm, it is possible to guarantee that the it finishes after at most log(n) calls to the fully parallel algorithm, and the number of steps in each call is at most log(n). Hence the total run-time of the partially parallel algorithm is 

<math display="inline" id="Maximal_independent_set:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{2}(n))
  </annotation>
 </semantics>
</math>

. Hence the run-time of the fully parallel algorithm is also at most 

<math display="inline" id="Maximal_independent_set:6">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{2}(n))
  </annotation>
 </semantics>
</math>

. The main proof steps are:</p>
<ul>
<li>If, in step <em>i</em>, we select 

<math display="inline" id="Maximal_independent_set:7">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>i</mi>
     </msup>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>δ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>i</ci>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta=2^{i}\log{(n)}/D
  </annotation>
 </semantics>
</math>

, where <em>D</em> is the maximum degree of a node in the graph, then <a href="with_high_probability" title="wikilink">WHP</a> all nodes remaining after step <em>i</em> have degree at most 

<math display="inline" id="Maximal_independent_set:8">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>/</mo>
   <msup>
    <mn>2</mn>
    <mi>i</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>D</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D/2^{i}
  </annotation>
 </semantics>
</math>


. Thus, after log(<em>D</em>) steps, all remaining nodes have degree 0 (since <em>D</em>&lt;<em>n</em>), and can be removed in a single step.</li>
<li>If, in any step, the degree of each node is at most <em>d</em>, and we select 

<math display="inline" id="Maximal_independent_set:9">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>d</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>δ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>C</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta=C\log{(n)}/d
  </annotation>
 </semantics>
</math>

 (for any constant <em>C</em>), then <a href="with_high_probability" title="wikilink">WHP</a> the longest path in the directed graph determined by the fixed ordering has length 

<math display="inline" id="Maximal_independent_set:10">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(n))
  </annotation>
 </semantics>
</math>

. Hence the fully parallel algorithm takes at most 

<math display="inline" id="Maximal_independent_set:11">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(n))
  </annotation>
 </semantics>
</math>

 steps (since the longest path is a worst-case bound on the number of steps in that algorithm).</li>
<li>Combining these two facts gives that, if we select 

<math display="inline" id="Maximal_independent_set:12">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>i</mi>
     </msup>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>δ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>i</ci>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta=2^{i}\log{(n)}/D
  </annotation>
 </semantics>
</math>

, then WHP the run-time of the partially parallel algorithm is 

<math display="inline" id="Maximal_independent_set:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>D</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>log</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <apply>
       <log></log>
       <ci>D</ci>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(D)\log(n))=O(\log^{2}(n))
  </annotation>
 </semantics>
</math>


.</li>
</ul>
<h2 id="listing-all-maximal-independent-sets">Listing all maximal independent sets</h2>

<p>An algorithm for listing all maximal independent sets or maximal cliques in a graph can be used as a subroutine for solving many NP-complete graph problems. Most obviously, the solutions to the maximum independent set problem, the maximum clique problem, and the minimum independent dominating problem must all be maximal independent sets or maximal cliques, and can be found by an algorithm that lists all maximal independent sets or maximal cliques and retains the ones with the largest or smallest size. Similarly, the <a href="Vertex_cover_problem" title="wikilink">minimum vertex cover</a> can be found as the complement of one of the maximal independent sets.  observed that listing maximal independent sets can also be used to find 3-colorings of graphs: a graph can be 3-colored if and only if the <a href="complement_(graph_theory)" title="wikilink">complement</a> of one of its maximal independent sets is <a href="bipartite_graph" title="wikilink">bipartite</a>. He used this approach not only for 3-coloring but as part of a more general graph coloring algorithm, and similar approaches to graph coloring have been refined by other authors since.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Other more complex problems can also be modeled as finding a clique or independent set of a specific type. This motivates the algorithmic problem of listing all maximal independent sets (or equivalently, all maximal cliques) efficiently.</p>

<p>It is straightforward to turn a proof of Moon and Moser's 3<sup><em>n</em>/3</sup> bound on the number of maximal independent sets into an algorithm that lists all such sets in time O(3<sup><em>n</em>/3</sup>).<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> For graphs that have the largest possible number of maximal independent sets, this algorithm takes constant time per output set. However, an algorithm with this time bound can be highly inefficient for graphs with more limited numbers of independent sets. For this reason, many researchers have studied algorithms that list all maximal independent sets in polynomial time per output set.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The time per maximal independent set is proportional to that for <a href="matrix_multiplication" title="wikilink">matrix multiplication</a> in dense graphs, or faster in various classes of sparse graphs.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p><a href="de:Glossar_Graphentheorie#Stabile_Menge" title="wikilink">de:Glossar Graphentheorie#Stabile Menge</a>"</p>

<p><a href="Category:Graph_theory_objects" title="wikilink">Category:Graph theory objects</a> <a href="Category:Computational_problems_in_graph_theory" title="wikilink">Category:Computational problems in graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"> shows that the number of different sizes of MISs in an <em>n</em>-vertex graph may be as large as <em>n</em> - log <em>n</em> - O(log log <em>n</em>) and is never larger than <em>n</em> - log <em>n</em>.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">Information System on Graph Class Inclusions: <a href="http://wwwteo.informatik.uni-rostock.de/isgci/classes/gc_749.html">maximal clique irreducible graphs</a> and <a href="http://wwwteo.informatik.uni-rostock.de/isgci/classes/gc_750.html">hereditary maximal clique irreducible graphs</a>.<a href="#fnref3">↩</a></li>
<li id="fn4">. For related earlier results see  and .<a href="#fnref4">↩</a></li>
<li id="fn5">. Chiba and Nishizeki express the condition of having O(<em>n</em>) edges equivalently, in terms of the <a class="uri" href="arboricity" title="wikilink">arboricity</a> of the graphs in the family being constant.<a href="#fnref5">↩</a></li>
<li id="fn6">; ; .<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://www.cc.gatech.edu/~vigoda/RandAlgs/MIS.pdf">Luby’s Algorithm, in: Lecture Notes for Randomized Algorithms, Last Updated by Eric Vigoda on February 2, 2006</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14">; .<a href="#fnref14">↩</a></li>
<li id="fn15">. For a matching bound for the widely used <a href="Bron–Kerbosch_algorithm" title="wikilink">Bron–Kerbosch algorithm</a>, see .<a href="#fnref15">↩</a></li>
<li id="fn16">; ; ; ; ; ; ; ; ; ; .<a href="#fnref16">↩</a></li>
<li id="fn17">; .<a href="#fnref17">↩</a></li>
</ol>
</section>


