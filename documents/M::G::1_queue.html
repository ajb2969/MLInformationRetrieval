<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1509">M/G/1 queue</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>M/G/1 queue</h1>
<hr/>

<p>In <a href="queueing_theory" title="wikilink">queueing theory</a>, a discipline within the mathematical <a href="probability_theory" title="wikilink">theory of probability</a>, an <strong>M/G/1 queue</strong> is a queue model where arrivals are <strong>M</strong>arkovian (modulated by a <a href="Poisson_process" title="wikilink">Poisson process</a>), service times have a <strong>G</strong>eneral <a href="probability_distribution" title="wikilink">distribution</a> and there is a single server.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The model name is written in <a href="Kendall's_notation" title="wikilink">Kendall's notation</a>, and is an extension of the <a href="M/M/1_queue" title="wikilink">M/M/1 queue</a>, where service times must be <a href="exponential_distribution" title="wikilink">exponentially distributed</a>. The classic application of the M/G/1 queue is to model performance of a fixed head <a href="hard_disk" title="wikilink">hard disk</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="model-definition">Model definition</h2>

<p>A queue represented by a M/G/1 queue is a stochastic process whose <a href="state_space" title="wikilink">state space</a> is the set {0,1,2,3...}, where the value corresponds to the number of customers in the queue, including any being served. Transitions from state <em>i</em> to <em>i</em> + 1 represent the arrival of a new customer: the times between such arrivals have an <a href="exponential_distribution" title="wikilink">exponential distribution</a> with parameter λ. Transitions from state <em>i</em> to <em>i</em> − 1 represent a customer who has been served, finishing being served and departing: the length of time required for serving an individual customer has a general distribution function. The lengths of times between arrivals and of service periods are <a href="random_variable" title="wikilink">random variables</a> which are assumed to be <a href="statistically_independent" title="wikilink">statistically independent</a>.</p>
<h3 id="scheduling-policies">Scheduling policies</h3>

<p>Customers are typically served on a <a href="first-come,_first-served" title="wikilink">first-come, first-served</a> basis, other popular scheduling policies include</p>
<ul>
<li><a href="processor_sharing" title="wikilink">processor sharing</a> where all jobs in the queue share the service capacity between them equally</li>
<li><a href="last-come,_first_served" title="wikilink">last-come, first served</a> without preemption where a job in service cannot be interrupted</li>
<li>last-come, first served with preemption where a job in service is interrupted by later arrivals, but work is conserved<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li>generalized foreground-background (FB) scheduling also known as least-attained-service where the jobs which have received least processing time so far are served first and jobs which have received equal service time share service capacity using processor sharing<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
<li><a href="shortest_job_first" title="wikilink">shortest job first</a> without preemption (SJF) where the job with the smallest size receives service and cannot be interrupted until service completes</li>
<li>preemptive shortest job first where at any moment in time the job with the smallest original size is served<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li><a href="shortest_remaining_processing_time" title="wikilink">shortest remaining processing time</a> (SRPT) where the next job to serve is that with the smallest remaining processing requirement<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul>

<p>Service policies are often evaluated by comparing the <a href="mean_sojourn_time" title="wikilink">mean sojourn time</a> in the queue. If service times that jobs require are known on arrival then the optimal scheduling policy is SRPT.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Policies can also be evaluated using a measure of fairness.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="queue-length">Queue length</h2>
<h3 id="pollaczekkhinchine-method">Pollaczek–Khinchine method</h3>

<p>The <a href="probability_generating_function" title="wikilink">probability generating function</a> of the <a href="stationary_process" title="wikilink">stationary</a> queue length distribution is given by the <a href="Pollaczek–Khinchine_transform_equation" title="wikilink">Pollaczek–Khinchine transform equation</a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>

<math display="block" id="M::G::1_queue:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>z</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>ρ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>z</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>λ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>z</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mi>z</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>π</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>z</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ρ</ci>
      </apply>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>g</ci>
       <apply>
        <times></times>
        <ci>λ</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <ci>z</ci>
        </apply>
       </apply>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(z)=\frac{(1-z)(1-\rho)g(\lambda(1-z))}{g(\lambda(1-z))-z}
  </annotation>
 </semantics>
</math>

 where g(<em>s</em>) is the Laplace transform of the service time probability density function.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> In the case of an <a href="M/M/1_queue" title="wikilink">M/M/1 queue</a> where service times are exponentially distributed with parameter <em>μ</em>, g(<em>s</em>) = <em>μ</em>/(<em>μ</em> + <em>s</em>).</p>

<p>This can be solved for individual state probabilities either using by direct computation or using the <a href="method_of_supplementary_variables" title="wikilink">method of supplementary variables</a>. The <a href="Pollaczek–Khinchine_formula" title="wikilink">Pollaczek–Khinchine formula</a> gives the mean queue length and mean waiting time in the system.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="matrix-analytic-method">Matrix analytic method</h3>

<p>Consider the <a href="embedded_Markov_chain" title="wikilink">embedded Markov chain</a> of the M/G/1 queue, where the time points selected are immediately after the moment of departure. The customer being served (if there is one) has received zero seconds of service. Between departures, there can be 0, 1, 2, 3,… arrivals. So from state <em>i</em> the chain can move to state <em>i</em> – 1, <em>i</em>, <em>i</em> + 1, <em>i</em> + 2, ….<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The embedded <a href="Markov_chain" title="wikilink">Markov chain</a> has <a href="transition_matrix" title="wikilink">transition matrix</a></p>

<p>

<math display="block" id="M::G::1_queue:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>3</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>4</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>3</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>4</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>3</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋱</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>normal-⋯</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>normal-⋯</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-⋯</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-⋯</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋱</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\begin{pmatrix}a_{0}&a_{1}&a_{2}&a_{3}&a_{4}&\cdots\\
a_{0}&a_{1}&a_{2}&a_{3}&a_{4}&\cdots\\
0&a_{0}&a_{1}&a_{2}&a_{3}&\cdots\\
0&0&a_{0}&a_{1}&a_{2}&\cdots\\
0&0&0&a_{0}&a_{1}&\cdots\\
\vdots&\vdots&\vdots&\vdots&\vdots&\ddots\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="M::G::1_queue:2">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>v</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>λ</mi>
        <mi>u</mi>
       </mrow>
      </mrow>
     </msup>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>λ</mi>
         <mi>u</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>v</mi>
      </msup>
      <mrow>
       <mi>v</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
     <mtext>d</mtext>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo rspace="5.8pt" stretchy="false">)</mo>
     </mrow>
     <mtext>for</mtext>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>λ</ci>
          <ci>u</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <times></times>
          <ci>λ</ci>
          <ci>u</ci>
         </apply>
         <ci>v</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <ci>v</ci>
        </apply>
       </apply>
       <mtext>d</mtext>
       <ci>F</ci>
       <ci>u</ci>
       <mtext>for</mtext>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{v}=\int_{0}^{\infty}e^{-\lambda u}\frac{(\lambda u)^{v}}{v!}\text{d}F(u)~{}%
\text{ for }v\geq 0
  </annotation>
 </semantics>
</math>

</p>

<p>and <em>F</em>(<em>u</em>) is the service time distribution and λ the Poisson arrival rate of jobs to the queue.</p>

<p>Markov chains with generator matrices or block matrices of this form are called M/G/1 type Markov chains,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> a term coined by M. F. Neuts.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The stationary distribution of an M/G/1 type Markov model can be computed using the <a href="matrix_analytic_method" title="wikilink">matrix analytic method</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="busy-period">Busy period</h2>

<p>The busy period is the time spent in states 1, 2, 3,… between visits to the state 0. The <a href="expected_value" title="wikilink">expected</a> length of a busy period is 1/(μ−λ) where 1/μ is the <a href="expected_value" title="wikilink">expected</a> length of service time and λ the rate of the Poisson process governing arrivals.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> The busy period <a href="probability_density_function" title="wikilink">probability density function</a> 

<math display="inline" id="M::G::1_queue:3">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(s)
  </annotation>
 </semantics>
</math>

 can be shown to obey the Kendall functional equation<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="M::G::1_queue:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mi>s</mi>
       <mo>+</mo>
       <mi>λ</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>λ</mi>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>s</ci>
        <ci>λ</ci>
       </apply>
       <apply>
        <times></times>
        <ci>λ</ci>
        <ci>ϕ</ci>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(s)=g[s+\lambda-\lambda\phi(s)]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where as above g is the <a href="Laplace–Stieltjes_transform" title="wikilink">Laplace–Stieltjes transform</a> of the service time distribution function. This relationship can only be solved exactly in special cases (such as the <a href="M/M/1_queue" title="wikilink">M/M/1 queue</a>), but for any <em>s</em> the value of ϕ(<em>s</em>) can be calculated and by iteration with upper and lower bounds the distribution function numerically computed.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="waitingresponse-time">Waiting/response time</h2>

<p>Writing W<sup>*</sup>(<em>s</em>) for the <a href="Laplace–Stieltjes_transform" title="wikilink">Laplace–Stieltjes transform</a> transform of the waiting time distribution,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> is given by the Pollaczek–Khinchine transform as</p>

<p>

<math display="block" id="M::G::1_queue:5">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>W</mi>
     <mo>∗</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>ρ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>s</mi>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>s</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>normal-∗</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ρ</ci>
      </apply>
      <ci>s</ci>
      <ci>g</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>g</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\ast}(s)=\frac{(1-\rho)sg(s)}{s-\lambda(1-g(s))}
  </annotation>
 </semantics>
</math>

 where g(<em>s</em>) is the Laplace–Stieltjes transform of service time probability density function.</p>
<h2 id="arrival-theorem">Arrival theorem</h2>

<p>As the arrivals are determined by a Poisson process, the <a href="arrival_theorem" title="wikilink">arrival theorem</a> holds.</p>
<h2 id="multiple-servers">Multiple servers</h2>

<p>Many metrics for the <a href="M/G/k_queue" title="wikilink">M/G/k queue</a> with <em>k</em> servers remain an open problem, though some approximations and bounds are known.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Single_queueing_nodes" title="wikilink">Category:Single queueing nodes</a> <a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
</ol>
</section>
</body>
</html>
