<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="161">Autocorrelator</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Autocorrelator</h1>
<hr/>

<p>A real time <a href="interferometry" title="wikilink">interferometric</a> <strong>autocorrelator</strong> is an electronic tool used to examine the <a class="uri" href="autocorrelation" title="wikilink">autocorrelation</a> of, among other things, optical beam intensity and spectral components through examination of variable beam path differences. <em>See <a href="Optical_autocorrelation" title="wikilink">Optical autocorrelation</a>.</em></p>
<h2 id="description">Description</h2>

<p>In an <a href="interferometry" title="wikilink">interferometric</a> autocorrelator, the input beam is split into a fixed path beam and a variable path beam using a standard beamsplitter. The fixed path beam travels a known and constant distance, whereas the variable path beam has its path length changed via rotating mirrors or other path changing mechanisms. At the end of the two paths, the beams are ideally parallel, but slightly separated, and using a correctly positioned lens, the two beams are crossed inside a <a href="Second_harmonic_generation" title="wikilink">second harmonic generating (SHG)</a> crystal. The autocorrelation term of the output is then passed into a <a href="photomultiplier" title="wikilink">photomultiplying tube (PMT)</a> and measured.</p>
<h3 id="details">Details</h3>

<p>Considering the input beam as a single pulse with envelope 

<math display="inline" id="Autocorrelator:0">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left(t\right)
  </annotation>
 </semantics>
</math>

, the constant fixed path distance as 

<math display="inline" id="Autocorrelator:1">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>F</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{F}
  </annotation>
 </semantics>
</math>

, and the variable path distance as a function of time 

<math display="inline" id="Autocorrelator:2">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>V</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>V</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{V}\left(t\right)
  </annotation>
 </semantics>
</math>

, the input to the SHG can be viewed as</p>

<p>

<math display="block" id="Autocorrelator:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>D</mi>
        <mi>F</mi>
       </msub>
       <mo>/</mo>
       <mi>c</mi>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>D</mi>
         <mi>V</mi>
        </msub>
        <mrow>
         <mo>(</mo>
         <mi>t</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <mi>c</mi>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>F</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>D</ci>
         <ci>V</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left(t-D_{F}/c\right)+E\left(t-D_{V}\left(t\right)/c\right)
  </annotation>
 </semantics>
</math>

 This comes from 

<math display="inline" id="Autocorrelator:4">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 being the speed of light and 

<math display="inline" id="Autocorrelator:5">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>/</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>D</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D/c
  </annotation>
 </semantics>
</math>

 being the time for the beam to travel the given path. In general, SHG produces output proportional to the square of the input, which in this case is</p>

<p>

<math display="block" id="Autocorrelator:6">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>E</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>D</mi>
        <mi>F</mi>
       </msub>
       <mo>/</mo>
       <mi>c</mi>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi>E</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>D</mi>
         <mi>V</mi>
        </msub>
        <mrow>
         <mo>(</mo>
         <mi>t</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <mi>c</mi>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <mi>E</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>D</mi>
        <mi>F</mi>
       </msub>
       <mo>/</mo>
       <mi>c</mi>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi>E</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>D</mi>
         <mi>V</mi>
        </msub>
        <mrow>
         <mo>(</mo>
         <mi>t</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <mi>c</mi>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>F</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>D</ci>
         <ci>V</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>E</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>F</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
     <ci>E</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>D</ci>
         <ci>V</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{2}\left(t-D_{F}/c\right)+E^{2}\left(t-D_{V}\left(t\right)/c\right)+2E\left(%
t-D_{F}/c\right)E\left(t-D_{V}\left(t\right)/c\right)
  </annotation>
 </semantics>
</math>

 The first two terms are based only on the fixed and variable paths respectively, but the third term is based on the difference between them, as is evident in</p>

<p>

<math display="block" id="Autocorrelator:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>E</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo>(</mo>
      <msup>
       <mi>t</mi>
       <msup>
        <mi></mi>
        <mo>′</mo>
       </msup>
      </msup>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>E</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>t</mi>
        <msup>
         <mi></mi>
         <mo>′</mo>
        </msup>
       </msup>
       <mo>-</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo>(</mo>
         <mi>t</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>E</mi>
     <mrow>
      <mo>(</mo>
      <msup>
       <mi>t</mi>
       <msup>
        <mi></mi>
        <mo>′</mo>
       </msup>
      </msup>
      <mo>)</mo>
     </mrow>
     <mi>E</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>t</mi>
        <msup>
         <mi></mi>
         <mo>′</mo>
        </msup>
       </msup>
       <mo>-</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo>(</mo>
         <mi>t</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="4.2pt">)</mo>
     </mrow>
     <mpadded width="+1.7pt">
      <mtext>where</mtext>
     </mpadded>
     <mi>A</mi>
     <mrow>
      <mo>(</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>D</mi>
         <mi>V</mi>
        </msub>
        <mrow>
         <mo>(</mo>
         <mi>t</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <msub>
        <mi>D</mi>
        <mi>F</mi>
       </msub>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>/</mo>
     <mpadded width="+1.7pt">
      <mi>c</mi>
     </mpadded>
    </mrow>
    <mpadded width="+1.7pt">
     <mtext>and</mtext>
    </mpadded>
    <msup>
     <mi>t</mi>
     <msup>
      <mi></mi>
      <mo>′</mo>
     </msup>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>D</mi>
      <mi>F</mi>
     </msub>
     <mo>/</mo>
     <mi>c</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>E</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>E</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <apply>
          <ci>normal-′</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <ci>E</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <apply>
          <ci>normal-′</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <mtext>where</mtext>
       <ci>A</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>D</ci>
          <ci>V</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>D</ci>
         <ci>F</ci>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
      <mtext>and</mtext>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>F</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{2}\left(t^{{}^{\prime}}\right)+E^{2}\left(t^{{}^{\prime}}-A\left(t\right)%
\right)+2E\left(t^{{}^{\prime}}\right)E\left(t^{{}^{\prime}}-A\left(t\right)%
\right)\,\mbox{ where }\,A\left(t\right)=\left(D_{V}\left(t\right)-D_{F}\right%
)/c\,\mbox{ and }\,t^{{}^{\prime}}=t-D_{F}/c
  </annotation>
 </semantics>
</math>

 The PMT used is assumed to be much slower than the envelope function 

<math display="inline" id="Autocorrelator:8">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left(t\right)
  </annotation>
 </semantics>
</math>


, so it effectively integrates the incoming signal</p>

<p>

<math display="block" id="Autocorrelator:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <msup>
       <mi>E</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo>(</mo>
       <msup>
        <mi>t</mi>
        <msup>
         <mi></mi>
         <mo>′</mo>
        </msup>
       </msup>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>E</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>t</mi>
        <msup>
         <mi></mi>
         <mo>′</mo>
        </msup>
       </msup>
       <mo>-</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo>(</mo>
         <mi>t</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>E</mi>
     <mrow>
      <mo>(</mo>
      <msup>
       <mi>t</mi>
       <msup>
        <mi></mi>
        <mo>′</mo>
       </msup>
      </msup>
      <mo>)</mo>
     </mrow>
     <mi>E</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>t</mi>
        <msup>
         <mi></mi>
         <mo>′</mo>
        </msup>
       </msup>
       <mo>-</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo>(</mo>
         <mi>t</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="4.2pt">)</mo>
     </mrow>
     <mi>d</mi>
     <msup>
      <mi>t</mi>
      <msup>
       <mi></mi>
       <mo>′</mo>
      </msup>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>E</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <ci>E</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\left(t\right)=\int E^{2}\left(t^{{}^{\prime}}\right)+E^{2}\left(t^{{}^{%
\prime}}-A\left(t\right)\right)+2E\left(t^{{}^{\prime}}\right)E\left(t^{{}^{%
\prime}}-A\left(t\right)\right)\,dt^{{}^{\prime}}
  </annotation>
 </semantics>
</math>

 Since both the fixed path and variable path terms are not dependent on each other, they would constitute a background "noise" in examination of the autocorrelation term and would ideally be removed first. This can be accomplished by examining the momentum vectors</p>

<p>

<math display="block" id="Autocorrelator:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>k</mi>
     <mi>F</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>k</mi>
     <mi>V</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>k</mi>
    <mrow>
     <mi>S</mi>
     <mi>H</mi>
     <mi>G</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>F</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>V</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>H</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{F}+k_{V}=k_{SHG}
  </annotation>
 </semantics>
</math>

 If the fixed and variable momentum vectors are assumed to be of approximately equal magnitude, the second harmonic momentum vector will fall geometrically between them. Assuming enough space is given in the component setup, the PMT could be fitted with a slit to decrease the effect the divergent fixed and variable beams have on the autocorrelation measurement, without losing much of the autocorrelation term. 

<math display="inline" id="Autocorrelator:11">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\left(t\right)
  </annotation>
 </semantics>
</math>

 can then be assumed to be nearly equal to</p>

<p>

<math display="block" id="Autocorrelator:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>(</mo>
      <msup>
       <mi>t</mi>
       <msup>
        <mi></mi>
        <mo>′</mo>
       </msup>
      </msup>
      <mo>)</mo>
     </mrow>
     <mi>E</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>t</mi>
        <msup>
         <mi></mi>
         <mo>′</mo>
        </msup>
       </msup>
       <mo>-</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo>(</mo>
         <mi>t</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="4.2pt">)</mo>
     </mrow>
     <mi>d</mi>
     <msup>
      <mi>t</mi>
      <msup>
       <mi></mi>
       <mo>′</mo>
      </msup>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <ci>E</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\left(t\right)=\int E\left(t^{{}^{\prime}}\right)E\left(t^{{}^{\prime}}-A%
\left(t\right)\right)\,dt^{{}^{\prime}}
  </annotation>
 </semantics>
</math>

 which gives the autocorrelation as a function of 

<math display="inline" id="Autocorrelator:13">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\left(t\right)
  </annotation>
 </semantics>
</math>


, the difference in path lengths.</p>
<h2 id="technical-specifications">Technical specifications</h2>
<ul>
<li><em>Calibration Factor</em> -- the factor to convert real-time to pulse delay time when viewing the output of the autocorrelator. One example of this would be 30 ps/ms in the Coherent Model FR-103 scanning autocorrelator, which suggests that a 30 ps pulse autocorrelation width would produce a 1 ms FWHM trace when viewed on an oscilloscope.</li>
<li><em>Time Resolution</em> -- related to the time constant of the PMT, an estimate can be made by multiplying the time constant with the calibration factor.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Autocorrelation_technique" title="wikilink">Autocorrelation technique</a></li>
<li><a href=":Category:Nonlinear_optics" title="wikilink">:Category:Nonlinear optics</a></li>
<li><a href=":Category:Nonlinear_optical_materials" title="wikilink">:Category:Nonlinear optical materials</a></li>
<li><a href="Optical_autocorrelation" title="wikilink">Optical autocorrelation</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><em>Coherent Mira Model 900 Laser Operator's Manual</em></li>
<li><em>Principles of Communications: Systems Modulation and Noise 5ed</em>, Rodger E. Ziemer and William H. Tranter</li>
<li><em>Elements of Optoelectronics and Fiber Optics</em>, Chin-Lin Chen</li>
</ul>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a class="uri" href="Category:Interferometry" title="wikilink">Category:Interferometry</a></p>
</body>
</html>
