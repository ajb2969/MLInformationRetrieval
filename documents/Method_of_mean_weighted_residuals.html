<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1887">Method of mean weighted residuals</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Method of mean weighted residuals</h1>
<hr/>

<p>In applied mathematics, <strong>methods of mean weighted residuals (MWR)</strong> are methods for solving <a href="differential_equation" title="wikilink">differential equations</a>. The solutions of these differential equations are assumed to be well approximated by a finite sum of test functions 

<math display="inline" id="Method_of_mean_weighted_residuals:0">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{i}
  </annotation>
 </semantics>
</math>

. In such cases, any one of a theoretically infinite set of methods of weighted residuals (depending on the choice of 

<math display="inline" id="Method_of_mean_weighted_residuals:1">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{i}
  </annotation>
 </semantics>
</math>

) are applied in an attempt to find which precise value each of the coefficient weight of the corresponding test functions. These coefficients are made to minimize the error between the sum of the test functions and actual solution in a chosen norm.</p>
<h2 id="notation-of-this-page">Notation of this page</h2>

<p>It is often very important to firstly sort out notation used before presenting how this method is executed in order to avoid confusion.</p>
<ul>
<li>

<math display="inline" id="Method_of_mean_weighted_residuals:2">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x)
  </annotation>
 </semantics>
</math>

 shall be used to denote the solution to the differential equation that the MWR method is being applied to.</li>
<li>Solving the differential equation mentioned shall be set to equate to setting some function 

<math display="inline" id="Method_of_mean_weighted_residuals:3">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>d</mi>
       <mi>n</mi>
      </msup>
      <mi>u</mi>
     </mrow>
     <mrow>
      <mi>d</mi>
      <msup>
       <mi>x</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <vector>
     <ci>x</ci>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>d</ci>
        <ci>n</ci>
       </apply>
       <ci>u</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\left(x,u,u_{x},\ldots,\frac{d^{n}u}{dx^{n}}\right)
  </annotation>
 </semantics>
</math>

 called the "residue function" to zero.</li>
<li>Every method of mean weighted residuals involves some "test functions" that shall be denoted by 

<math display="inline" id="Method_of_mean_weighted_residuals:4">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

.</li>
<li>The degrees of freedom shall be denoted by 

<math display="inline" id="Method_of_mean_weighted_residuals:5">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

.</li>
<li>If the assumed form of the solution to the differential equation 

<math display="inline" id="Method_of_mean_weighted_residuals:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mi>x</mi>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mfrac>
      <mrow>
       <msup>
        <mi>d</mi>
        <mi>n</mi>
       </msup>
       <mi>u</mi>
      </mrow>
      <mrow>
       <mi>d</mi>
       <msup>
        <mi>x</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <vector>
      <ci>x</ci>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>d</ci>
         <ci>n</ci>
        </apply>
        <ci>u</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\left(x,u,u_{x},\ldots,\frac{d^{n}u}{dx^{n}}\right)=0
  </annotation>
 </semantics>
</math>

 is linear (in the degrees of freedom) then the basis functions used in said form shall be denoted by 

<math display="inline" id="Method_of_mean_weighted_residuals:7">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{i}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="mathematical-statement-of-method">Mathematical statement of method</h2>

<p>The method of mean weighted residuals solves 

<math display="inline" id="Method_of_mean_weighted_residuals:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mi>x</mi>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mfrac>
      <mrow>
       <msup>
        <mi>d</mi>
        <mi>n</mi>
       </msup>
       <mi>u</mi>
      </mrow>
      <mrow>
       <mi>d</mi>
       <msup>
        <mi>x</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <vector>
      <ci>x</ci>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>d</ci>
         <ci>n</ci>
        </apply>
        <ci>u</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\left(x,u,u_{x},\ldots,\frac{d^{n}u}{dx^{n}}\right)=0
  </annotation>
 </semantics>
</math>

 by imposing that the degrees of freedom 

<math display="inline" id="Method_of_mean_weighted_residuals:9">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 are such that:</p>

<p>

<math display="block" id="Method_of_mean_weighted_residuals:10">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo>(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo>,</mo>
      <msub>
       <mi>u</mi>
       <mi>x</mi>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mfrac>
       <mrow>
        <msup>
         <mi>d</mi>
         <mi>n</mi>
        </msup>
        <mi>u</mi>
       </mrow>
       <mrow>
        <mi>d</mi>
        <msup>
         <mi>x</mi>
         <mi>n</mi>
        </msup>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>R</ci>
      <vector>
       <ci>x</ci>
       <ci>u</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>x</ci>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>d</ci>
          <ci>n</ci>
         </apply>
         <ci>u</ci>
        </apply>
        <apply>
         <times></times>
         <ci>d</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </vector>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </interval>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(R\left(x,u,u_{x},\ldots,\frac{d^{n}u}{dx^{n}}\right),w_{i}\right)=0
  </annotation>
 </semantics>
</math>

</p>

<p>is satisfied. Where the inner product 

<math display="inline" id="Method_of_mean_weighted_residuals:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>f</mi>
   <mo>,</mo>
   <mi>g</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>f</ci>
    <ci>g</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f,g)
  </annotation>
 </semantics>
</math>

 is the standard function inner product with respect to some weighting function 

<math display="inline" id="Method_of_mean_weighted_residuals:12">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)
  </annotation>
 </semantics>
</math>

 which is determined usually by the basis function set or arbitrarily according to whichever weighting function is most convenient. For instance when the basis set is just the <a href="Chebyshev_polynomials" title="wikilink">Chebyshev polynomials</a> of the first kind typically the weighting function is 

<math display="inline" id="Method_of_mean_weighted_residuals:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)=\frac{1}{\sqrt{1-x^{2}}}
  </annotation>
 </semantics>
</math>

 because that's the most convenient because that way inner products can be more easily computed by use of a fast <a href="discrete_Chebyshev_transform" title="wikilink">Chebyshev transform</a>.</p>

<p>Additionally, all these methods have in common that they enforce boundary conditions by either enforcing that the basis functions (in the case of a linear combination) individual enforce the boundary conditions on the original BVP (This only works if the boundary conditions are homogeneous however it is possible to apply it to problems with inhomogeneous boundary conditions by letting 

<math display="inline" id="Method_of_mean_weighted_residuals:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x)=v(x)+L(x)
  </annotation>
 </semantics>
</math>

 and substituting this expression into the original differential equation and imposing homogeneous boundary conditions to the new solution being sought to find u(x) that is v(x) where L(x) is a function that satisfies the boundary conditions imposed on u that is known.), or by explicitly imposing the boundary by removing n rows to the matrix representing the discretised problem where n refers to the order of the differential equation and substituting them with ones that represent the boundary conditions.</p>
<h3 id="choice-of-test-functions">Choice of test functions</h3>

<p>The choice of test function, as mentioned earlier, depends on the specific method used (under the general heading of mean weighted residual methods). Here is a list of commonly used specific MWR methods and their corresponding test functions roughly according to their popularity:</p>
<ul>
<li>The <a href="Galerkin_method" title="wikilink">Galerkin method</a>, which uses the basis functions themselves as test functions or in the more general case of a nonlinear assumed form (where the nonlinearity is in the degrees of freedom) of the solution the Galerkin method uses the test functions

<math display="block" id="Method_of_mean_weighted_residuals:15">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>u</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>u</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}=\frac{\partial u}{\partial a_{i}}
  </annotation>
 </semantics>
</math>

</li>
<li>The <a href="pseudospectral_method" title="wikilink">pseudospectral method</a> which uses the <a href="Dirac_delta_functions" title="wikilink">Dirac delta functions</a> centered at a set of discrete x points 

<math display="inline" id="Method_of_mean_weighted_residuals:16">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 and equates to just setting the residue function to zero at those x points.</li>
<li>The least-squares method uses the test functions

<math display="block" id="Method_of_mean_weighted_residuals:17">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>R</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>R</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}=\frac{\partial R}{\partial a_{i}}
  </annotation>
 </semantics>
</math>

. This method has the effect of minimising the square of the <a href="Lp_space#Special_cases" title="wikilink">L2-norm</a> of the residue function (that is 

<math display="inline" id="Method_of_mean_weighted_residuals:18">
 <semantics>
  <msup>
   <mrow>
    <mo>∥</mo>
    <mi>R</mi>
    <mo>∥</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>R</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|{R}\|^{2}
  </annotation>
 </semantics>
</math>

) with respect to the degrees of freedom 

<math display="inline" id="Method_of_mean_weighted_residuals:19">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

.</li>
<li>The method of moments uses the simple set of test functions 

<math display="inline" id="Method_of_mean_weighted_residuals:20">
 <semantics>
  <msup>
   <mi>x</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{i}
  </annotation>
 </semantics>
</math>

 and is rarely ever implemented when high degrees of accuracy are required because of computational issues associated with inverting the <a href="Hilbert_matrix" title="wikilink">Hilbert matrix</a>.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Introduction to Applied Mathematics, Wellesley-Cambridge Press (1986).</li>
</ul>

<p>"</p>

<p><a href="Category:Differential_equations" title="wikilink">Category:Differential equations</a></p>
</body>
</html>
