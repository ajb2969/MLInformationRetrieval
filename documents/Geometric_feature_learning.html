<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1880">Geometric feature learning</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Geometric feature learning</h1>
<hr/>

<p><strong>Geometric feature learning</strong> is a technique combining <a href="machine_learning" title="wikilink">machine learning</a> and <a href="computer_vision" title="wikilink">computer vision</a> to solve visual tasks. The main goal of this method is to find a set of representative features of geometric form to represent an object by collecting geometric features from images and learning them using efficient <a href="machine_learning" title="wikilink">machine learning</a> methods. Humans solve visual tasks and can give fast response to the environment by extracting perceptual information from what they see. Researchers simulate humans' ability of recognizing objects to solve computer vision problems. For example, M. Mata et al.(2002) <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> applied feature learning techniques to the <a href="mobile_robot_navigation" title="wikilink">mobile robot navigation</a> tasks in order to avoid obstacles. They used <a href="genetic_algorithms" title="wikilink">genetic algorithms</a> for learning features and recognizing objects (figures). Geometric feature learning methods can not only solve recognition problems but also predict subsequent actions by analyzing a set of sequential input sensory images, usually some extracting features of images. Through learning, some hypothesis of the next action are given and according the probability of each hypothesis give a most probable action. This technique is widely used in the area of <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>.</p>
<h2 id="introduction">Introduction</h2>

<p>Geometric feature learning methods extract distinctive geometric features from images. Geometric features are features of objects constructed by a set of geometric elements like points, lines, curves or surfaces. These features can be corner features, edge features, Blobs, Ridges, salient points image texture and so on, which can be detected by <a href="feature_detection" title="wikilink">feature detection</a> methods.</p>
<h3 id="geometric-features">Geometric features</h3>
<dl>
<dt>Primitive features</dt>
</dl>
<ul>
<li>Corners: Corners is a very simple but significant feature of objects. Especially, Complexe objects usually have different corner features with each other. Corners of an object can be extracted by using the technique, calling <a href="Corner_detection" title="wikilink">Corner detection</a>. Cho and Dunn <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> used a different way to define a corner by the distance and angle between two straight line segments. This is a new way by defining features as a parameterized composition of several components.</li>
<li>Edges: Edges are one-dimensional structure features of an image. They represent the boundary of different image regions. The outline of an object can be easily detected by finding the edge using the technique of <a href="edge_detection" title="wikilink">edge detection</a>.</li>
<li>Blobs: Blobs represent regions of images, which can be detected using <a href="blob_detection" title="wikilink">blob detection</a> method.</li>
<li>Ridges: From a practical viewpoint, a ridge can be thought of as a one-dimensional curve that represents an axis of symmetry. Ridges detection method-see <a href="ridge_detection" title="wikilink">ridge detection</a></li>
<li>salient points-see <a href="Kadir–Brady_saliency_detector" title="wikilink">Kadir–Brady saliency detector</a></li>
<li><a href="image_texture" title="wikilink">image texture</a></li>
</ul>
<dl>
<dt>Compound features<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></dt>
</dl>
<ul>
<li>Geometric composition</li>
</ul>

<p>Geometric component feature is a combination of several primitive features and it always consists more than 2 primitive features like edges, corners or blobs. Extracting geometric feature vector at location x can be computed according to the reference point, which is shown below:</p>

<p>

<math display="block" id="Geometric_feature_learning:0">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>d</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mi>cos</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>θ</mi>
             <mrow>
              <mi>i</mi>
              <mo>-</mo>
              <mn>1</mn>
             </mrow>
            </msub>
            <mo>+</mo>
            <msub>
             <mi>ϕ</mi>
             <mi>i</mi>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mi>sin</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>θ</mi>
             <mrow>
              <mi>i</mi>
              <mo>-</mo>
              <mn>1</mn>
             </mrow>
            </msub>
            <mo>+</mo>
            <msub>
             <mi>ϕ</mi>
             <mi>i</mi>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>i</ci>
      </apply>
      <matrix>
       <matrixrow>
        <apply>
         <cos></cos>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>θ</ci>
           <apply>
            <minus></minus>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ϕ</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <sin></sin>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>θ</ci>
           <apply>
            <minus></minus>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ϕ</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ x_{i}=x_{i-1}+\sigma_{i-1}d_{i}\begin{bmatrix}\cos(\theta_{i-1}+%
\phi_{i})\\
\sin(\theta_{i-1}+\phi_{i})\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Geometric_feature_learning:1">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>θ</mi>
    </mpadded>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>θ</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>θ</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ \theta_{i}=\theta_{i-1}+\Delta\theta_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Geometric_feature_learning:2">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>σ</mi>
    </mpadded>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mi mathvariant="normal">Δ</mi>
    <msub>
     <mi>σ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ \sigma_{i}=\sigma_{i-1}\Delta\sigma_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>x means the location of the location of features, 

<math display="inline" id="Geometric_feature_learning:3">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\theta
  </annotation>
 </semantics>
</math>

 means the orientation, 

<math display="inline" id="Geometric_feature_learning:4">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\sigma
  </annotation>
 </semantics>
</math>

 means the intrinsic scale.</p>
<ul>
<li>Boolean Composition</li>
</ul>

<p>Boolean compound feature consists of two sub-features which can be primitive features or compound features. There are two type of boolean features: conjunctive feature whose value is the product of two sub-features and disjunctive features whose value is the maximum of the two sub-features.</p>
<h3 id="feature-space">Feature space</h3>

<p>Feature space was firstly considered in computer vision area by Segen.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> He used multilevel graph to represent the geometric relations of local features.</p>
<h3 id="learning-algorithms">Learning algorithms</h3>

<p>There are many learning algorithms which can be applied to learn to find <a href="distinctive_features" title="wikilink">distinctive features</a> of objects in an image. Learning can be incremental, meaning that the object classes can be added at any time.</p>
<h3 id="geometric-feature-extraction-methods">Geometric feature extraction methods</h3>
<ul>
<li><a href="Corner_detection" title="wikilink">Corner detection</a></li>
<li><a href="Curve_fitting" title="wikilink">Curve fitting</a></li>
<li><a href="Edge_detection" title="wikilink">Edge detection</a></li>
<li>Global structure extraction</li>
<li>Feature histograms</li>
<li><a href="Line_detection" title="wikilink">Line detection</a></li>
<li><a href="Connected-component_labeling" title="wikilink">Connected-component labeling</a></li>
<li><a href="Image_texture" title="wikilink">Image texture</a></li>
<li><a href="Motion_estimation" title="wikilink">Motion estimation</a></li>
</ul>
<h2 id="feature-learning-algorithm">Feature learning algorithm</h2>

<p>1.Acquire a new training image "I".</p>

<p>2.According to the recognition algorithm, evaluate the result. If the result is true, new object classes are recognised.</p>
<ul>
<li>recognition algorithm</li>
</ul>

<p>The key point of recognition algorithm is to find the most distinctive features among all features of all classes. So using below equation to maximise the feature 

<math display="inline" id="Geometric_feature_learning:5">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ f_{max}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Geometric_feature_learning:6">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>I</mi>
    </mpadded>
    <mrow>
     <mi>m</mi>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mrow>
      <mi>m</mi>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>𝑓</mo>
    </munder>
    <munder accentunder="true">
     <mrow>
      <mi>m</mi>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>𝐶</mo>
    </munder>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>,</mo>
     <msub>
      <mi>F</mi>
      <mi>f</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>I</ci>
     <interval closure="open">
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>f</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ I_{max}=\underset{f}{max}\underset{C}{max}I(C,F_{f})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Geometric_feature_learning:7">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>I</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>,</mo>
     <msub>
      <mi>F</mi>
      <mi>f</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <munder accentunder="true">
      <mstyle displaystyle="false">
       <mo largeop="true" symmetric="true">∑</mo>
      </mstyle>
      <mo>𝐶</mo>
     </munder>
     <munder accentunder="true">
      <mstyle displaystyle="false">
       <mo largeop="true" symmetric="true">∑</mo>
      </mstyle>
      <msub>
       <mi>F</mi>
       <mi>f</mi>
      </msub>
     </munder>
     <mi>B</mi>
     <mi>E</mi>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>F</mi>
       <mi>f</mi>
      </msub>
      <mo>,</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mstyle displaystyle="false">
       <mfrac>
        <mrow>
         <mi>B</mi>
         <mi>E</mi>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>C</mi>
          <mo>,</mo>
          <msub>
           <mi>F</mi>
           <mi>f</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>B</mi>
         <mi>E</mi>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>F</mi>
           <mi>f</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>B</mi>
         <mi>E</mi>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>C</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
      </mstyle>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <interval closure="open">
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>f</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>C</ci>
       <sum></sum>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>f</ci>
       </apply>
       <sum></sum>
      </apply>
      <ci>B</ci>
      <ci>E</ci>
      <ci>L</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>f</ci>
       </apply>
       <ci>C</ci>
      </interval>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>E</ci>
         <ci>L</ci>
         <interval closure="open">
          <ci>C</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>F</ci>
           <ci>f</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>E</ci>
         <ci>L</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>f</ci>
         </apply>
         <ci>B</ci>
         <ci>E</ci>
         <ci>L</ci>
         <ci>C</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ I(C,F_{f})=-\underset{C}{\sum}\underset{F_{f}}{\sum}BEL(F_{f},C)%
\log\frac{BEL(C,F_{f})}{BEL(F_{f})BEL(C)}
  </annotation>
 </semantics>
</math>

 Measure the value of a feature in images, 

<math display="inline" id="Geometric_feature_learning:8">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ f_{max}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Geometric_feature_learning:9">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>f</mi>
   </mpadded>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>m</mi>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ f_{f_{max}}
  </annotation>
 </semantics>
</math>

, and localise a feature:</p>

<p>

<math display="block" id="Geometric_feature_learning:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="5pt" width="+5pt">
      <mi>f</mi>
     </mpadded>
     <msub>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mrow>
      <mi>m</mi>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mi>I</mi>
     </mrow>
    </munder>
    <msub>
     <mi>f</mi>
     <msub>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>I</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>I</ci>
      </apply>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\ f_{f_{(p)}}(I)=\underset{x\in I}{max}f_{f_{(p)}}(x)
  </annotation>
 </semantics>
</math>

 Where 

<math display="inline" id="Geometric_feature_learning:11">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <msub>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f_{f_{(p)}}(x)
  </annotation>
 </semantics>
</math>

 is defined as 

<math display="inline" id="Geometric_feature_learning:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <msub>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
    <mrow>
     <mo>{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>p</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>T</mi>
       </msup>
       <mo stretchy="false">)</mo>
       <mi>f</mi>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mrow>
        <mo>∥</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>p</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>∥</mo>
       </mrow>
       <mrow>
        <mo>∥</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>∥</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>I</ci>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
     <set>
      <cn type="integer">0</cn>
      <apply>
       <divide></divide>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">f</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">p</csymbol>
          <ci>normal-)</ci>
         </cerror>
         <ci>T</ci>
        </apply>
        <ci>normal-)</ci>
        <csymbol cd="unknown">f</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>p</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f_{f_{(p)}}(I)=max\left\{0,\frac{f(p)^{T})f(x)}{\left\|f(p)\right\|%
\left\|f(x)\right\|}\right\}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>evaluation</li>
</ul>

<p>After recognise the features, the results should be evaluated to determine whether the classes can be recognised, There are five evaluation categories of recognition results: correct, wrong, ambiguous, confused and ignorant. When the evaluation is correct, add a new training image and train it. If the recognition failed, the feature nodes should be maximise their distinctive power which is defined by the Kolmogorov-Smirno distance (KSD).</p>

<p>

<math display="block" id="Geometric_feature_learning:13">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mi>S</mi>
   <msub>
    <mi>D</mi>
    <mrow>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder accentunder="true">
    <mrow>
     <mi>m</mi>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>𝛼</mo>
   </munder>
   <mo>|</mo>
   <mi>c</mi>
   <mi>d</mi>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">|</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mi>c</mi>
   <mi>d</mi>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">|</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">K</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <list>
      <ci>a</ci>
      <ci>b</ci>
     </list>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <ci>α</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle KSD_{a,b}(X)=\underset{\alpha}{max}\left|cdf(\alpha|a)-cdf(\alpha|b%
)\right|
  </annotation>
 </semantics>
</math>

 3.Feature learning algorithm After a feature is recognised, it should be applied to <a href="Bayesian_network" title="wikilink">Bayesian network</a> to recognise the image, using the feature learning algorithm to test.</p>
<ul>
<li>The main purpose of feature learning algorithm is to find a new feature from sample image to test whether the classes are recognised or not. Two cases should be consider: Searching for new feature of true class and wrong class from sample image respectively. If new feature of true class is detected and the of wrong class is not recognised, then the class is recognised and the algorithm should terminate. If feature of true class is not detected and of false class is detected in the sample image, false class should be prevented from being recognised and the feature should be removed from Bayesian network.</li>
<li>Using Bayesian network to realise the test process</li>
</ul>
<h2 id="pac-model-based-feature-learning-algorithm">PAC model based feature learning algorithm</h2>
<h3 id="learning-framework">Learning framework</h3>

<p>probably approximately correct (PAC) model was applied by D. Roth (2002) to solve computer vision problem by developing a distribution-free learning theory based on this model.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This theory heavily relied on the development of feature-effient learning approach. The goal of this algorithm is to learn an object represented by some geometric features in an image. The input is a <a href="feature_vector" title="wikilink">feature vector</a> and the output is 1 which means successfully detect the object or 0 otherwise. The main point of this learning approach is collecting representative elements which can represent the object through a function and testing by recognising an object from image to find the representation with high probability. The learning algorithm aims to predict whether the learned target concept 

<math display="inline" id="Geometric_feature_learning:14">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>T</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f_{T}(X)
  </annotation>
 </semantics>
</math>

 is belongs to a class, where X is the instance space consists with parameters and then test whether the prediction is correct.</p>
<h3 id="evaluation-framework">Evaluation framework</h3>

<p>After learning features, there should be some evaluation algorithms to evaluate the learning algorithms. D. Roth applied two learning algorithms:</p>
<dl>
<dt>1.Sparse Network of Winnows(SNoW) system</dt>
</dl>
<ul>
<li>SNoW-Train
<ul>
<li>Initial step: initial the set of features 

<math display="inline" id="Geometric_feature_learning:15">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>t</ci>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle F_{t}=\phi
  </annotation>
 </semantics>
</math>

 which linked to target t for all 

<math display="inline" id="Geometric_feature_learning:16">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle t\in T
  </annotation>
 </semantics>
</math>

. T is a set of object targets whose elements are 

<math display="inline" id="Geometric_feature_learning:17">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle t_{1}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Geometric_feature_learning:18">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle t_{k}
  </annotation>
 </semantics>
</math>

</li>
<li>If each target object in set T belongs to a list of active features, link feature to target and set initial weight at the same time.</li>
<li>Evaluate the targets : compare targets 

<math display="inline" id="Geometric_feature_learning:19">
 <semantics>
  <mrow>
   <munder accentunder="true">
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>e</mi>
    </mrow>
   </munder>
   <msubsup>
    <mi>w</mi>
    <mi>i</mi>
    <mi>t</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>e</ci>
     </apply>
     <sum></sum>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\underset{i\in e}{\sum}w_{i}^{t}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Geometric_feature_learning:20">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\theta_{t}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Geometric_feature_learning:21">
 <semantics>
  <msubsup>
   <mi>w</mi>
   <mi>i</mi>
   <mi>t</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle w_{i}^{t}
  </annotation>
 </semantics>
</math>

 is the weight on one position connecting the features i to target t. \theta_{t} is the threshold for the target not t.</li>
<li>Update weight according to the result of evaluation. There are two cases: predicted positive on negative example (

<math display="inline" id="Geometric_feature_learning:22">
 <semantics>
  <mrow>
   <mrow>
    <munder accentunder="true">
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>e</mi>
     </mrow>
    </munder>
    <msubsup>
     <mi>w</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
   </mrow>
   <mo>></mo>
   <msub>
    <mi>θ</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>e</ci>
      </apply>
      <sum></sum>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\underset{i\in e}{\sum}w_{i}^{t}>\theta_{t}
  </annotation>
 </semantics>
</math>

 and targets are not in the list of active features) and predicted negative on positive example(

<math display="inline" id="Geometric_feature_learning:23">
 <semantics>
  <mrow>
   <mrow>
    <munder accentunder="true">
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>e</mi>
     </mrow>
    </munder>
    <msubsup>
     <mi>w</mi>
     <mi>i</mi>
     <mi>t</mi>
    </msubsup>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>θ</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>e</ci>
      </apply>
      <sum></sum>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\underset{i\in e}{\sum}w_{i}^{t}\leq\theta_{t}
  </annotation>
 </semantics>
</math>

 and targets are in the list of active features).</li>
</ul></li>
<li>SNoW-Evaluation
<ul>
<li>Evaluate the each target using same function as introduced above</li>
<li>Prediction: Make a decision to select the dominant active target node.</li>
</ul></li>
</ul>
<dl>
<dt>2. <a href="support_vector_machines" title="wikilink">support vector machines</a></dt>
</dl>

<p>The main purpose of SVM is to find a <a class="uri" href="hyperplane" title="wikilink">hyperplane</a> to separate the set of samples 

<math display="inline" id="Geometric_feature_learning:24">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(x_{i},y_{i})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Geometric_feature_learning:25">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x_{i}
  </annotation>
 </semantics>
</math>

 is an input vector which is a selection of features 

<math display="inline" id="Geometric_feature_learning:26">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x\in R^{N}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Geometric_feature_learning:27">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle y_{i}
  </annotation>
 </semantics>
</math>

 is the label of 

<math display="inline" id="Geometric_feature_learning:28">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x_{i}
  </annotation>
 </semantics>
</math>

. The hyperplane has the following form: 

<math display="inline" id="Geometric_feature_learning:29">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
   <mi>g</mi>
   <mi>n</mi>
   <mrow>
    <mo>(</mo>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>l</mi>
    </msubsup>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo>⋅</mo>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mn>1</mn>
        <mo>,</mo>
        <mrow>
         <mi>p</mi>
         <mi>o</mi>
         <mi>s</mi>
         <mi>i</mi>
         <mi>t</mi>
         <mi>i</mi>
         <mi>v</mi>
         <mpadded width="+2.8pt">
          <mi>e</mi>
         </mpadded>
         <mi>i</mi>
         <mi>n</mi>
         <mi>p</mi>
         <mi>u</mi>
         <mi>t</mi>
         <mi>s</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>n</mi>
         <mi>e</mi>
         <mi>g</mi>
         <mi>a</mi>
         <mi>t</mi>
         <mi>i</mi>
         <mi>v</mi>
         <mpadded width="+2.8pt">
          <mi>e</mi>
         </mpadded>
         <mi>i</mi>
         <mi>n</mi>
         <mi>p</mi>
         <mi>u</mi>
         <mi>t</mi>
         <mi>s</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-⋅</ci>
     <csymbol cd="unknown">k</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <matrix>
      <matrixrow>
       <list>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>o</ci>
         <ci>s</ci>
         <ci>i</ci>
         <ci>t</ci>
         <ci>i</ci>
         <ci>v</ci>
         <ci>e</ci>
         <ci>i</ci>
         <ci>n</ci>
         <ci>p</ci>
         <ci>u</ci>
         <ci>t</ci>
         <ci>s</ci>
        </apply>
       </list>
      </matrixrow>
      <matrixrow>
       <list>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>e</ci>
         <ci>g</ci>
         <ci>a</ci>
         <ci>t</ci>
         <ci>i</ci>
         <ci>v</ci>
         <ci>e</ci>
         <ci>i</ci>
         <ci>n</ci>
         <ci>p</ci>
         <ci>u</ci>
         <ci>t</ci>
         <ci>s</ci>
        </apply>
       </list>
      </matrixrow>
     </matrix>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f(x)=sgn\left(\sum_{i=1}^{l}y_{i}\alpha_{i}\cdot k(x,x_{i})+b\right%
)=\left\{\begin{matrix}1,positive\;inputs\\
-1,negative\;inputs\end{matrix}\right.
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Geometric_feature_learning:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>ϕ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
      <ci>ϕ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle k(x,x_{i})=\phi(x)\cdot\phi(x_{i})
  </annotation>
 </semantics>
</math>

 is a kernel function</p>

<p>Both algorithms separate training data by finding a linear function.</p>
<h2 id="applications">Applications</h2>
<ul>
<li>Landmarks learning for topological navigation<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>Simulation of detecting object process of human vision behaviour<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li>Learning self-generated action <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
<li>Vehicle tracking<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Feature_detection_(computer_vision)" title="wikilink">Category:Feature detection (computer vision)</a> <a href="Category:Applications_of_computer_vision" title="wikilink">Category:Applications of computer vision</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. Mata and J. M. Armingol and A. De La Escalera and M. A. Salichs, "Learning visual landmarks for mobile robot navigation", In Proceedings of the 15th World congress of the International Federation of Automatic Control, 2002<a href="#fnref1">↩</a></li>
<li id="fn2">Cho, K., and Dunn, S.M "Learning shape classes". IEEE Transformations on Pattern Analysis and Machine Intelligence 16,9(1994), 882-888<a href="#fnref2">↩</a></li>
<li id="fn3">Justus H Piater, "Visual feature learning" (January 1, 2001). Electronic Doctoral Dissertations for UMass Amherst. Paper AAI3000331.<a href="#fnref3">↩</a></li>
<li id="fn4">Segen, J., Learning graph models of shape. In Proceeding of the 5th International Conference on Machine Learning(Ann Arbor, June 12–14, 1988), J. Larid, Ed., Morgan Kaufmann<a href="#fnref4">↩</a></li>
<li id="fn5">D. Roth, M-H. Yang, and N. Ahuja. Learning to recognise three-demensional objects. Neural Computation, 14(5): 1071–1104, 2002.<a href="#fnref5">↩</a></li>
<li id="fn6">M. Mata, J. M. Armingol, Learning Visual Landmarks for Mobile Robot Navigation, Division of Systems Engineering and Automation, Madrid, Spain, 2002<a href="#fnref6">↩</a></li>
<li id="fn7">I. A. Rybak, BMV: Behavioral Model of Visual Perception and Recognition, Human Vision, Visual Processing, and Digital Display IV<a href="#fnref7">↩</a></li>
<li id="fn8">P. Fitzpatrick, G. Metta, L. Natale, S. Rao, and G. Sandini, “Learning About Objects Through Action - Initial Steps Towards Artificial Cognition,” in IEEE Int. Conf on Robotics and Automation, 2003, pp. 3140–3145.<a href="#fnref8">↩</a></li>
<li id="fn9">J.M.Ferryman,A.D.Worrall,andS.J.Maybank.Learning enhanced 3d models for vehicle tracking. In Proc. of the British Machine Vision Conference, 1998<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
