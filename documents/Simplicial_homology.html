<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1538">Simplicial homology</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Simplicial homology</h1>
<hr/>

<p>In <a href="algebraic_topology" title="wikilink">algebraic topology</a>, <strong>simplicial homology</strong> formalizes the idea of the number of holes of a given dimension in a <a href="simplicial_complex" title="wikilink">simplicial complex</a>. This generalizes the number of <a href="connected_component_(topology)" title="wikilink">connected components</a> (the case of dimension 0).</p>

<p>Simplicial homology arose as a way to study <a href="topological_spaces" title="wikilink">topological spaces</a> whose building blocks are <em>n</em>-<a class="uri" href="simplices" title="wikilink">simplices</a>, the <em>n</em>-dimensional analogs of triangles. This includes a point (0-dimensional simplex), a line segment (1-dimensional simplex), a triangle (2-dimensional simplex) and a tetrahedron (3-dimensional simplex). By definition, such a space is <a class="uri" href="homeomorphic" title="wikilink">homeomorphic</a> to a <a href="simplicial_complex" title="wikilink">simplicial complex</a> (more precisely, the <a href="geometric_realization" title="wikilink">geometric realization</a> of an <a href="abstract_simplicial_complex" title="wikilink">abstract simplicial complex</a>). Such a homeomorphism is referred to as a <em><a href="Triangulation_(topology)" title="wikilink">triangulation</a></em> of the given space. Many topological spaces of interest can be triangulated, including every smooth <a class="uri" href="manifold" title="wikilink">manifold</a>, by Cairns and <a href="J.H.C._Whitehead" title="wikilink">Whitehead</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Simplicial homology is defined by a simple recipe for any abstract simplicial complex. It is a remarkable fact that simplicial homology only depends on the associated topological space.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> As a result, it gives a computable way to distinguish one space from another.</p>

<p><a href="Singular_homology" title="wikilink">Singular homology</a> is a related theory which is more commonly used by mathematicians today. Singular homology is defined for all topological spaces, and it agrees with simplicial homology for spaces which can be triangulated.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Nonetheless, because it is possible to compute the simplicial homology of a simplicial complex automatically and efficiently, simplicial homology has become important for application to real-life situations, such as <a href="image_analysis" title="wikilink">image analysis</a>, <a href="medical_imaging" title="wikilink">medical imaging</a>, and <a href="data_analysis" title="wikilink">data analysis</a> in general.</p>
<h2 id="definition">Definition</h2>
<figure><b>(Figure)</b>
<figcaption>The boundary of a boundary of a 2-simplex (left) and the boundary of a 1-chain (right) are taken. Both are 0, being sums in which both the positive and negative of a 0-simplex occur once. The boundary of a boundary is always 0. A nontrivial cycle is something that closes up like the boundary of a simplex, in that its boundary sums to 0, but which isn't actually the boundary of a simplex or chain. Because trivial 1-cycles are equivalent to 0 in 

<math display="inline" id="Simplicial_homology:0">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}
  </annotation>
 </semantics>
</math>

, the 1-cycle at right-middle is homologous to its sum with the boundary of the 2-simplex at left.</figcaption>
</figure>

<p>A key concept in defining simplicial homology is the notion of an <a href="orientability" title="wikilink">orientation</a> of a simplex. By definition, an orientation of a <em>k</em>-simplex is given by an ordering of the vertices, written as (<em>v</em><sub>0</sub>,...,<em>v</em><sub><em>k</em></sub>), with the rule that two orderings define the same orientation if and only if they differ by an <a href="even_permutation" title="wikilink">even permutation</a>. Thus every simplex has exactly two orientations, and switching the order of two vertices changes an orientation to the opposite orientation. For example, choosing an orientation of a 1-simplex amounts to choosing one of the two possible directions, and choosing an orientation of a 2-simplex amounts to choosing what "counterclockwise" should mean.</p>

<p>Let <em>S</em> be a simplicial complex. A <a href="Chain_(algebraic_topology)" title="wikilink">simplicial <em>k</em>-chain</a> is a finite <a href="free_abelian_group#formal_sum" title="wikilink">formal sum</a></p>

<p>

<math display="block" id="Simplicial_homology:1">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mpadded width="+1.7pt">
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{N}c_{i}\sigma_{i}\,
  </annotation>
 </semantics>
</math>

, where each <em>c</em><sub><em>i</em></sub> is an integer and σ<sub><em>i</em></sub> is an oriented <em>k</em>-simplex. In this definition, we declare that each oriented simplex is equal to the negative of the simplex with the opposite orientation. For example,</p>

<p>

<math display="block" id="Simplicial_homology:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>v</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <apply>
     <minus></minus>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{0},v_{1})=-(v_{1},v_{0}).
  </annotation>
 </semantics>
</math>

</p>

<p>The group of <em>k</em>-chains on <em>S</em> is written <em>C<sub>k</sub></em>. This is a <a href="free_abelian_group" title="wikilink">free abelian group</a> which has a basis in one-to-one correspondence with the set of <em>k</em>-simplices in <em>S</em>. To define a basis explicitly, one has to choose an orientation of each simplex. One standard way to do this is to choose an ordering of all the vertices and give each simplex the orientation corresponding to the induced ordering of its vertices.</p>

<p>Let σ = (<em>v</em><sub>0</sub>,...,<em>v</em><sub><em>k</em></sub>) be an oriented <em>k</em>-simplex, viewed as a basis element of <em>C<sub>k</sub></em>. The <strong>boundary operator</strong></p>

<p>

<math display="block" id="Simplicial_homology:3">
 <semantics>
  <mrow>
   <msub>
    <mo>∂</mo>
    <mi>k</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>k</mi>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{k}:C_{k}\rightarrow C_{k-1}
  </annotation>
 </semantics>
</math>

</p>

<p>is the <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> defined by:</p>

<p>

<math display="block" id="Simplicial_homology:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∂</mo>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>k</mi>
     </munderover>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>i</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>v</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mover accent="true">
        <msub>
         <mi>v</mi>
         <mi>i</mi>
        </msub>
        <mo>^</mo>
       </mover>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>v</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>k</ci>
     </apply>
     <ci>σ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>i</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <ci>normal-^</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>k</ci>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{k}(\sigma)=\sum_{i=0}^{k}(-1)^{i}(v_{0},\dots,\widehat{v_{i}},\dots,%
v_{k}),
  </annotation>
 </semantics>
</math>

</p>

<p>where the oriented simplex</p>

<p>

<math display="block" id="Simplicial_homology:5">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>v</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mover accent="true">
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo>^</mo>
   </mover>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <ci>normal-^</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>k</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{0},\dots,\widehat{v_{i}},\dots,v_{k})
  </annotation>
 </semantics>
</math>

</p>

<p>is the <em>i</em><sup>th</sup> face of <em>σ</em>, obtained by deleting its <em>i</em><sup>th</sup> vertex.</p>

<p>In <em>C<sub>k</sub></em>, elements of the subgroup</p>

<p>

<math display="block" id="Simplicial_homology:6">
 <semantics>
  <mrow>
   <msub>
    <mi>Z</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>ker</mi>
    <msub>
     <mo>∂</mo>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <csymbol cd="latexml">kernel</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{k}=\ker\partial_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>are referred to as <strong>cycles</strong>, and the subgroup</p>

<p>

<math display="block" id="Simplicial_homology:7">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>im</mo>
    <msub>
     <mo>∂</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>im</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}=\operatorname{im}\partial_{k+1}
  </annotation>
 </semantics>
</math>

</p>

<p>is said to consist of <strong>boundaries</strong>.</p>

<p>A direct computation shows that ∂<sup>2</sup> = 0. In geometric terms, this says that the boundary of anything has no boundary. Equivalently, the abelian groups</p>

<p>

<math display="block" id="Simplicial_homology:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>C</mi>
    <mi>k</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mo>∂</mo>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>k</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (C_{k},\partial_{k})
  </annotation>
 </semantics>
</math>

</p>

<p>form a <a href="chain_complex" title="wikilink">chain complex</a>. Another equivalent statement is that <em>B<sub>k</sub></em> is contained in <em>Z<sub>k</sub></em>.</p>
<figure><b>(Figure)</b>
<figcaption>100 px| A simplicial complex with 2 1-holes</figcaption>
</figure>

<p>The <em>k</em><sup>th</sup> homology group <em>H<sub>k</sub></em> of <em>S</em> is defined to be the <a href="quotient_group" title="wikilink">quotient</a> abelian group</p>

<p>

<math display="block" id="Simplicial_homology:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mi>k</mi>
     </msub>
     <mo>/</mo>
     <mpadded width="+1.7pt">
      <msub>
       <mi>B</mi>
       <mi>k</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}(S)=Z_{k}/B_{k}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>It follows that the homology group <em>H<sub>k</sub></em>(<em>S</em>) is nonzero exactly when there are <em>k</em>-cycles on <em>S</em> which are not boundaries. In a sense, this means that there are <em>k</em>-dimensional holes in the complex. For example, consider the complex <em>S</em> obtained by gluing two triangles (with no interior) along one edge, shown in the image. The edges of each triangle can be oriented so as to form a cycle. These two cycles are by construction not boundaries (since every 2-chain is zero). One can compute that the homology group <em>H</em><sub>1</sub>(<em>S</em>) is isomorphic to <strong>Z</strong><sup>2</sup>, with a basis given by the two cycles mentioned. This makes precise the informal idea that <em>S</em> has two "1-dimensional holes".</p>

<p>Holes can be of different dimensions. The <a href="rank_of_an_abelian_group" title="wikilink">rank</a> of the <em>k</em>th homology group, the number</p>

<p>

<math display="block" id="Simplicial_homology:10">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>rank</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>H</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>rank</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>k</ci>
      </apply>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}={\rm rank}(H_{k}(S))\,
  </annotation>
 </semantics>
</math>

</p>

<p>is called the <em>k</em>th <a href="Betti_number" title="wikilink">Betti number</a> of <em>S</em>. It gives a measure of the number of <em>k</em>-dimensional holes in <em>S</em>.</p>
<h2 id="example">Example</h2>

<p>Let <em>S</em> be the triangle (without its interior), viewed as a simplicial complex. Thus <em>S</em> has three vertices, which we call <em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, and three 1-dimensional simplices. To compute the homology groups of <em>S</em>, we start by describing the chain groups <em>C</em><sub><em>k</em></sub>. Namely, <em>C</em><sub>0</sub> is isomorphic to <strong>Z</strong><sup>3</sup> with basis (<em>v</em><sub>0</sub>), (<em>v</em><sub>1</sub>), (<em>v</em><sub>2</sub>), and <em>C</em><sub>1</sub> is isomorphic to <strong>Z</strong><sup>3</sup> with a basis given by the oriented 1-simplices (<em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>), (<em>v</em><sub>0</sub>, <em>v</em><sub>2</sub>), and (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>). The chain groups in other dimensions are zero.</p>

<p>The boundary homomorphism ∂: <em>C</em><sub>1</sub> → <em>C</em><sub>0</sub> is given by:</p>

<p>

<math display="block" id="Simplicial_homology:11">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial(v_{0},v_{1})=(v_{1})-(v_{0})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Simplicial_homology:12">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial(v_{0},v_{2})=(v_{2})-(v_{0})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Simplicial_homology:13">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial(v_{1},v_{2})=(v_{2})-(v_{1})
  </annotation>
 </semantics>
</math>

 Since <em>C</em><sub>−1</sub> = 0, every 0-chain is a cycle, and the 0-boundaries are generated by the three elements on the right of these equations. So the 0th homology group <em>H</em><sub>0</sub>(<em>S</em>) = <em>Z</em><sub>0</sub>/<em>B</em><sub>0</sub> is isomorphic to <strong>Z</strong>, with a basis given (for example) by the image of the 0-cycle (<em>v</em><sub>0</sub>). (Indeed, all three vertices become equal in the quotient group; this expresses the fact that <em>S</em> is <a href="connected_space" title="wikilink">connected</a>.)</p>

<p>Next, the group of 1-cycles is the kernel of the homomorphism ∂ above, which is isomorphic to <strong>Z</strong>, with a basis given (for example) by (<em>v</em><sub>0</sub>,<em>v</em><sub>1</sub>) − (<em>v</em><sub>0</sub>,<em>v</em><sub>2</sub>) + (<em>v</em><sub>1</sub>,<em>v</em><sub>2</sub>). (A picture reveals that this 1-cycle goes around the triangle in one of the two possible directions.) Since <em>C</em><sub>2</sub> = 0, the group of 1-boundaries is zero, and so the homology group <em>H</em><sub>1</sub>(<em>S</em>) is isomorphic to <strong>Z</strong>/0 ≅ <strong>Z</strong>. This makes precise the idea that the triangle has one 1-dimensional hole. The homology group <em>H</em><sub><em>i</em></sub>(<em>S</em>) is zero for <em>i</em> not equal to 0 or 1.</p>
<h2 id="simplicial-maps">Simplicial maps</h2>

<p>Let <em>S</em> and <em>T</em> be simplicial complexes. A <strong>simplicial map</strong> <em>f</em> from <em>S</em> to <em>T</em> is a function from the vertex set of <em>S</em> to the vertex set of <em>T</em> such that the image of each simplex in <em>S</em> (viewed as a set of vertices) is a simplex in <em>T</em>. A simplicial map <em>f</em>: <em>S</em> → <em>T</em> determines a homomorphism of homology groups <em>H</em><sub><em>k</em></sub>(<em>S</em>) → <em>H</em><sub><em>k</em></sub>(<em>T</em>) for each integer <em>k</em>. This is the homomorphism associated to a <a href="chain_map" title="wikilink">chain map</a> from the chain complex of <em>S</em> to the chain complex of <em>T</em>. Explicitly, this chain map is given on <em>k</em>-chains by</p>

<p>

<math display="block" id="Simplicial_homology:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>v</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>v</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>v</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <vector>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f((v_{0},\ldots,v_{k}))=(f(v_{0}),...,f(v_{k}))
  </annotation>
 </semantics>
</math>

 if <em>f</em>(<em>v</em><sub>0</sub>), ..., <em>f</em>(<em>v</em><sub>k</sub>) are all distinct, and otherwise <em>f</em>((<em>v</em><sub>0</sub>, ..., <em>v</em><sub>k</sub>)) = 0.</p>

<p>This construction makes simplicial homology a <a class="uri" href="functor" title="wikilink">functor</a> from simplicial complexes to abelian groups. This is essential to applications of the theory, including the <a href="Brouwer_fixed_point_theorem" title="wikilink">Brouwer fixed point theorem</a> and the topological invariance of simplicial homology.</p>
<h2 id="applications">Applications</h2>

<p>A standard scenario in many computer applications is a collection of points (measurements, dark pixels in a bit map, etc.) in which one wishes to find a topological feature. Homology can serve as a qualitative tool to search for such a feature, since it is readily computable from combinatorial data such as a simplicial complex. However, the data points have to first be <a href="Triangulation_(topology)" title="wikilink">triangulated</a>, meaning one replaces the data with a simplicial complex approximation. Computation of <a href="persistent_homology" title="wikilink">persistent homology</a> (<a href="http://graphics.stanford.edu/projects/lgl/paper.php?id=elz-tps-02">Edelsbrunner et al.2002</a><a href="http://at.yorku.ca/b/a/a/k/28.htm">Robins, 1999</a>) involves analysis of homology at different resolutions, registering homology classes (holes) that persist as the resolution is changed. Such features can be used to detect structures of molecules, tumors in X-rays, and cluster structures in complex data. A <a class="uri" href="MATLAB" title="wikilink">MATLAB</a> toolbox for computing persistent homology, Plex (<a href="Vin_de_Silva" title="wikilink">Vin de Silva</a>, <a href="Gunnar_Carlsson" title="wikilink">Gunnar Carlsson</a>), is available at <a href="http://math.stanford.edu/comptop/programs/">this site.</a> Stand-alone implementations in <a class="uri" href="C++" title="wikilink">C++</a> are available as part of the <a href="http://www.sas.upenn.edu/~vnanda/perseus/index.html">Perseus</a> and <a href="http://www.mrzv.org/software/dionysus/">Dionysus</a> software projects. More generally, simplicial homology plays a central role in <a href="topological_data_analysis" title="wikilink">topological data analysis</a>, a technique in the field of <a href="data_mining" title="wikilink">data mining</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Homology_theory" title="wikilink">Homology theory</a></li>
<li><a href="Singular_homology" title="wikilink">Singular homology</a></li>
<li><a href="Cellular_homology" title="wikilink">Cellular homology</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://math.stanford.edu/comptop/">Topological methods in scientific computing</a></li>
<li><a href="http://www.math.gatech.edu/~chomp/">Computational homology (also cubical homology)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Homology_theory" title="wikilink">Category:Homology theory</a> <a href="Category:Algebraic_topology" title="wikilink">Category:Algebraic topology</a> <a href="Category:Computational_topology" title="wikilink">Category:Computational topology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">V. V. Prasolov. Elements of combinatorial and differential topology. Section 5.3.2<a href="#fnref1">↩</a></li>
<li id="fn2">M. A. Armstrong. Basic topology. Section 8.6.<a href="#fnref2">↩</a></li>
<li id="fn3">A. Hatcher. Algebraic topology. Theorem 2.27<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
