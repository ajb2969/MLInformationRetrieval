<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="347">XOR swap algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>XOR swap algorithm</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><a href="Image:XOR_Swap.svg" title="wikilink">thumb|upright=2|alt=With three XOR operations the binary values 1010 and 0011 are exchanged between variables.|Using the XOR swap algorithm to exchange </a><a href="nibble" title="wikilink">nibbles</a> between variables without the use of temporary storage</p>

<p>In <a href="computer_programming" title="wikilink">computer programming</a>, the <strong>XOR swap</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> that uses the <a href="exclusive_disjunction" title="wikilink">XOR</a> <a href="bitwise_operation" title="wikilink">bitwise operation</a> to <a href="swap_(computer_science)" title="wikilink">swap</a> values of distinct <a href="variable_(programming)" title="wikilink">variables</a> having the same <a href="data_type" title="wikilink">data type</a> without using a temporary variable. "Distinct" means that the variables are stored at different memory addresses; the actual values of the variables do not have to be different.</p>
<h2 id="the-algorithm">The algorithm</h2>

<p>Conventional swapping requires the use of a temporary storage variable. Using the XOR swap algorithm, however, no temporary storage is needed. The algorithm is as follows:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal">X := X <span class="kw">XOR</span> Y
Y := X <span class="kw">XOR</span> Y
X := X <span class="kw">XOR</span> Y</code></pre></div>

<p>The algorithm typically corresponds to three <a href="machine_code" title="wikilink">machine code</a> instructions. Since XOR is a <a href="commutative_operation" title="wikilink">commutative operation</a>, X XOR Y can be replaced with Y XOR X in any of the lines. When coded in assembly language, this commutativity is often exercised in the second line:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Pseudocode</p></th>
<th style="text-align: left;">
<p>IBM <a class="uri" href="System/370" title="wikilink">System/370</a> assembly</p></th>
<th style="text-align: left;">
<p>x86 assembly</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>In the above System/370 assembly code sample, R1 and R2 are distinct <a href="processor_register" title="wikilink">registers</a>, and each XR operation leaves its result in the register named in the first argument. Using x86 assembly, values X and Y are in registers eax and ebx (respectively), and  places the result of the operation in the first register.</p>

<p>However, the algorithm fails if <em>x</em> and <em>y</em> use the same storage location, since the value stored in that location will be zeroed out by the first XOR instruction, and then remain zero; it will not be "swapped with itself". Note that this is <em>not</em> the same as if <em>x</em> and <em>y</em> have the same values. The trouble only comes when <em>x</em> and <em>y</em> use the same storage location, in which case their values must already be equal. That is, if <em>x</em> and <em>y</em> use the same storage location, then the line:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal">X := X <span class="kw">XOR</span> Y</code></pre></div>

<p>sets <em>x</em> to zero (because <em>x</em> = <em>y</em> so X XOR Y is zero) <em>and</em> sets <em>y</em> to zero (since it uses the same storage location), causing <em>x</em> and <em>y</em> to lose their original values.</p>
<h2 id="proof-of-correctness">Proof of correctness</h2>

<p>The <a href="binary_operation" title="wikilink">binary operation</a> XOR over bit strings of length 

<math display="inline" id="XOR_swap_algorithm:0">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 exhibits the following properties (where 

<math display="inline" id="XOR_swap_algorithm:1">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 denotes XOR):</p>
<ul>
<li><strong>L1.</strong> <a href="Commutative_operation" title="wikilink">Commutativity</a>

<math display="block" id="XOR_swap_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mi>B</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mo>⊕</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>B</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\oplus B=B\oplus A
  </annotation>
 </semantics>
</math>

</li>
<li><strong>L2.</strong> <a class="uri" href="Associativity" title="wikilink">Associativity</a>

<math display="block" id="XOR_swap_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⊕</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊕</mo>
    <mi>C</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊕</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>C</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>B</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\oplus B)\oplus C=A\oplus(B\oplus C)
  </annotation>
 </semantics>
</math>

</li>
<li><strong>L3.</strong> <a href="Identity_element" title="wikilink">Identity exists</a>: there is a bit string, 0, (of length <em>N</em>) such that 

<math display="inline" id="XOR_swap_algorithm:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mn>0</mn>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>A</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\oplus 0=A
  </annotation>
 </semantics>
</math>

 for any 

<math display="inline" id="XOR_swap_algorithm:5">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

</li>
<li><strong>L4.</strong> Each element is its own <a href="inverse_element" title="wikilink">inverse</a>: for each 

<math display="inline" id="XOR_swap_algorithm:6">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="XOR_swap_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mi>A</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>A</ci>
     <ci>A</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\oplus A=0
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Suppose that we have two distinct registers <code>R1</code> and <code>R2</code> as in the table below, with initial values <em>A</em> and <em>B</em> respectively. We perform the operations below in sequence, and reduce our results using the properties listed above.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Step</p></th>
<th style="text-align: left;">
<p>Operation</p></th>
<th style="text-align: left;">
<p>Register 1</p></th>
<th style="text-align: left;">
<p>Register 2</p></th>
<th style="text-align: left;">
<p>Reduction</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>Initial value</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="XOR_swap_algorithm:8">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="XOR_swap_algorithm:9">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>—</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p><code>R1 := R1 XOR R2</code></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="XOR_swap_algorithm:10">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊕</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\oplus B
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="XOR_swap_algorithm:11">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>B</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ B
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>—</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p><code>R2 := R1 XOR R2</code></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="XOR_swap_algorithm:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊕</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\oplus B
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="XOR_swap_algorithm:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⊕</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊕</mo>
    <mi>B</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊕</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\oplus B)\oplus B=A\oplus(B\oplus B)
  </annotation>
 </semantics>
</math>


<br/>


<math display="inline" id="XOR_swap_algorithm:14">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>A</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =A\oplus 0
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="XOR_swap_algorithm:15">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>L2<br/>
 L4<br/>
 L3</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p><code>R1 := R1 XOR R2</code></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="XOR_swap_algorithm:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⊕</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊕</mo>
    <mi>A</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⊕</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\oplus B)\oplus A=A\oplus(A\oplus B)
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="XOR_swap_algorithm:17">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⊕</mo>
      <mi>A</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊕</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>A</ci>
      <ci>A</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(A\oplus A)\oplus B
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="XOR_swap_algorithm:18">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>⊕</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =0\oplus B
  </annotation>
 </semantics>
</math>


<br/>


<math display="inline" id="XOR_swap_algorithm:19">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mo>⊕</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>B</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =B\oplus 0
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="XOR_swap_algorithm:20">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =B
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="XOR_swap_algorithm:21">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>L1<br/>
 L2<br/>
 L4<br/>
 L1<br/>
 L3</strong></p></td>
</tr>
</tbody>
</table>
<h3 id="linear-algebra-interpretation">Linear algebra interpretation</h3>

<p>As XOR can be interpreted as binary addition and a pair of values can be interpreted as a point in two-dimensional space, the steps in the algorithm can be interpreted as 2×2 matrices with binary values. For simplicity, assume initially that <em>x</em> and <em>y</em> are each single bits, not bit vectors.</p>

<p>For example, the step:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal">X := X <span class="kw">XOR</span> Y</code></pre></div>

<p>which also has the implicit:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal">Y := Y</code></pre></div>

<p>corresponds to the matrix 

<math display="inline" id="XOR_swap_algorithm:22">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">1</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">1</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}1&1\\
0&1\end{smallmatrix}\right)
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="XOR_swap_algorithm:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>x</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>y</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>x</mi>
         <mo>+</mo>
         <mi>y</mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>y</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <ci>x</ci>
      </matrixrow>
      <matrixrow>
       <ci>y</ci>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>y</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}1&1\\
0&1\end{pmatrix}\begin{pmatrix}x\\
y\end{pmatrix}=\begin{pmatrix}x+y\\
y\end{pmatrix}.
  </annotation>
 </semantics>
</math>

 The sequence of operations is then expressed as:</p>

<p>

<math display="block" id="XOR_swap_algorithm:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}1&1\\
0&1\end{pmatrix}\begin{pmatrix}1&0\\
1&1\end{pmatrix}\begin{pmatrix}1&1\\
0&1\end{pmatrix}=\begin{pmatrix}0&1\\
1&0\end{pmatrix}
  </annotation>
 </semantics>
</math>

 (working with binary values, so 

<math display="inline" id="XOR_swap_algorithm:25">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+1=0
  </annotation>
 </semantics>
</math>

), which expresses the <a href="elementary_matrix" title="wikilink">elementary matrix</a> of switching two rows (or columns) in terms of the <a href="Shear_mapping" title="wikilink">transvections</a> (shears) of adding one element to the other.</p>

<p>To generalize to where X and Y are not single bits, but instead bit vectors of length <em>n</em>, these 2×2 matrices are replaced by 2<em>n</em>×2<em>n</em> <a href="block_matrices" title="wikilink">block matrices</a> such as 

<math display="inline" id="XOR_swap_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi mathsize="70%" stretchy="false">I</mi>
        <mi mathsize="70%" stretchy="false">n</mi>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi mathsize="70%" stretchy="false">I</mi>
        <mi mathsize="70%" stretchy="false">n</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">0</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi mathsize="70%" stretchy="false">I</mi>
        <mi mathsize="70%" stretchy="false">n</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>n</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>n</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}I_{n}&I_{n}\\
0&I_{n}\end{smallmatrix}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>Note that these matrices are operating on <em>values,</em> not on <em>variables</em> (with storage locations), hence this interpretation abstracts away from issues of storage location and the problem of both variables sharing the same storage location.</p>
<h2 id="code-example">Code example</h2>

<p>A <a href="C_(programming_language)" title="wikilink">C</a> function that implements the XOR swap algorithm:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"> <span class="dt">void</span> xorSwap (<span class="dt">int</span> *x, <span class="dt">int</span> *y) {
     <span class="kw">if</span> (x != y) {
         *x ^= *y;
         *y ^= *x;
         *x ^= *y;
     }
 }</code></pre></div>

<p>Note that the code does not swap the integers passed immediately, but first checks if their addresses are distinct. This is because, if the addresses are equal, the algorithm will fold to a triple *x ^= *x resulting in zero.</p>

<p>It can be done more easily, without checking if the addresses are equal, using this method:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"> <span class="dt">void</span> xorSwap (<span class="dt">int</span> *x, <span class="dt">int</span> *y) {
     *x=*x^*y^(*y=*x);
 }</code></pre></div>

<p>The XOR swap algorithm can also be defined with a macro:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define XORSWAP(a, b)   ((a)^=(b),(b)^=(a),(a)^=(b))</span></code></pre></div>
<h2 id="reasons-for-use-in-practice">Reasons for use in practice</h2>

<p>In most practical scenarios, the trivial swap algorithm using a temporary register is more efficient. Limited situations in which XOR swapping may be practical include:</p>
<ul>
<li>on a processor where the instruction set encoding permits the XOR swap to be encoded in a smaller number of bytes</li>
<li>in a region with high <a href="register_pressure" title="wikilink">register pressure</a>, it may allow the <a href="register_allocator" title="wikilink">register allocator</a> to avoid spilling a register</li>
<li>in <a class="uri" href="microcontrollers" title="wikilink">microcontrollers</a> where available RAM is very limited.</li>
</ul>

<p>Because these situations are rare, most optimizing compilers do not generate XOR swap code.</p>
<h2 id="reasons-for-avoidance-in-practice">Reasons for avoidance in practice</h2>

<p>Most modern compilers can optimize away the temporary variable in the native swap, in which case the native swap uses the same amount of memory and the same number of registers as the XOR swap and is at least as fast, and often faster. The XOR swap is also much less readable and completely opaque to anyone unfamiliar with the technique.</p>

<p>On modern <a href="CPU_architecture" title="wikilink">CPU architectures</a>, the XOR technique can be slower than using a temporary variable to do swapping. One reason is that modern CPUs strive to execute instructions in parallel via <a href="instruction_pipeline" title="wikilink">instruction pipelines</a>. In the XOR technique, the inputs to each operation depend on the results of the previous operation, so they must be executed in strictly sequential order, negating any benefits of <a href="instruction-level_parallelism" title="wikilink">instruction-level parallelism</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="aliasing">Aliasing</h3>

<p>The XOR swap is also complicated in practice by <a href="aliasing_(computing)" title="wikilink">aliasing</a>. As noted above, if an attempt is made to XOR-swap the contents of some location with itself, the result is that the location is zeroed out and its value lost. Therefore, XOR swapping must not be used blindly in a high-level language if aliasing is possible.</p>

<p>Similar problems occur with <a href="call_by_name" title="wikilink">call by name</a>, as in <a href="Jensen's_Device" title="wikilink">Jensen's Device</a>, where swapping <code>i</code> and <code>A[i]</code> via a temporary variable yields incorrect results due to the arguments being related: swapping via <code>temp = i; i = A[i]; A[i] = temp</code> changes the value for <code>i</code> in the second statement, which then results in the incorrect lvalue for <code>A[i]</code> in the third statement.</p>
<h2 id="variations">Variations</h2>

<p>The underlying principle of the XOR swap algorithm can be applied to any operation meeting criteria L1 through L4 above. Replacing XOR by addition and subtraction gives a slightly different, but largely equivalent, formulation:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"> <span class="dt">void</span> addSwap (<span class="dt">unsigned</span> <span class="dt">int</span> *x, <span class="dt">unsigned</span> <span class="dt">int</span> *y)
 {
     <span class="kw">if</span> (x != y) {
         *x = *x + *y;
         *y = *x - *y;
         *x = *x - *y;
     }
 }</code></pre></div>

<p>Unlike the XOR swap, this variation requires that the underlying processor or programming language uses a method such as <a href="modular_arithmetic" title="wikilink">modular arithmetic</a> or <a href="bignum" title="wikilink">bignums</a> to guarantee that the computation of <code>X + Y</code> cannot cause an error due to <a href="integer_overflow" title="wikilink">integer overflow</a>. Therefore, it is seen even more rarely in practice than the XOR swap.</p>

<p>Note, however, that the implementation of <code>addSwap</code> above in the C programming language always works even in case of integer overflow, since, according to the C standard, addition and subtraction of unsigned integers follow the rules of <a href="modular_arithmetic" title="wikilink">modular arithmetic</a>, i. e. are done in the <a href="cyclic_group" title="wikilink">cyclic group</a> 

<math display="inline" id="XOR_swap_algorithm:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <msup>
     <mn>2</mn>
     <mi>s</mi>
    </msup>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>s</ci>
     </apply>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/2^{s}\mathbb{Z}
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="XOR_swap_algorithm:28">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is the number of bits of <code>unsigned int</code>. Indeed, the correctness of the algorithm follows from the fact that the formulas 

<math display="inline" id="XOR_swap_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x+y)-y=x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="XOR_swap_algorithm:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x+y)-((x+y)-y)=y
  </annotation>
 </semantics>
</math>

 hold in any <a href="abelian_group" title="wikilink">abelian group</a>. This is actually a generalization of the proof for the XOR swap algorithm: XOR is both the addition and subtraction in the abelian group 

<math display="inline" id="XOR_swap_algorithm:31">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>ℤ</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{Z}/2\mathbb{Z})^{s}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Symmetric_difference" title="wikilink">Symmetric difference</a></li>
<li><a href="XOR_linked_list" title="wikilink">XOR linked list</a></li>
<li><a href="Feistel_cipher" title="wikilink">Feistel cipher</a> (the XOR swap algorithm is a degenerate form of a Feistel cypher)</li>
<li><a href="Amiga_CD32" title="wikilink">Amiga CD32</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>

<p><a href="pl:Zamiana_wartości_zmiennych" title="wikilink">pl:Zamiana wartości zmiennych</a> <a href="fr:Échange_(informatique)#En_utilisant_l.27op.C3.A9ration_XOR" title="wikilink">fr:Échange (informatique)#En_utilisant_l.27op.C3.A9ration_XOR</a>"</p>

<p><a class="uri" href="Category:Algorithms" title="wikilink">Category:Algorithms</a> <a href="Category:Articles_with_example_C_code" title="wikilink">Category:Articles with example C code</a> <a href="Category:Binary_arithmetic" title="wikilink">Category:Binary arithmetic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>

