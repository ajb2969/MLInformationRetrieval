<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1292">Analytic combinatorics</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Analytic combinatorics</h1>
<hr/>

<p>In mathematics, <strong>analytic combinatorics</strong> is one of the many techniques of <a href="enumerative_combinatorics" title="wikilink">counting combinatorial objects</a>. It uses the internal structure of the objects to derive formulas for their <a href="generating_function" title="wikilink">generating functions</a> and then complex analysis techniques to get asymptotics. This particular theory was mostly developed by <a href="Philippe_Flajolet" title="wikilink">Philippe Flajolet</a>, and is detailed in his book with <a href="Robert_Sedgewick_(computer_scientist)" title="wikilink">Robert Sedgewick</a>, <em>Analytic Combinatorics</em>. Earlier contributors to the key ideas and techniques include <a href="Leonhard_Euler" title="wikilink">Leonhard Euler</a>, <a href="Arthur_Cayley" title="wikilink">Arthur Cayley</a>, <a href="Srinivasa_Ramanujan" title="wikilink">Srinivasa Ramanujan</a>, <a href="George_Pólya" title="wikilink">George Pólya</a>, and <a href="Donald_Knuth" title="wikilink">Donald Knuth</a>.</p>
<h2 id="classes-of-combinatorial-structures">Classes of combinatorial structures</h2>

<p>Consider the problem of distributing objects given by a generating function into a set of <em>n</em> slots, where a permutation group <em>G</em> of degree <em>n</em> acts on the slots to create an equivalence relation of filled slot configurations, and asking about the generating function of the configurations by weight of the configurations with respect to this equivalence relation, where the weight of a configuration is the sum of the weights of the objects in the slots. We will first explain how to solve this problem in the labelled and the unlabelled case and use the solution to motivate the creation of <a href="combinatorial_class" title="wikilink">classes of combinatorial structures</a>.</p>

<p>The <a href="Pólya_enumeration_theorem" title="wikilink">Pólya enumeration theorem</a> solves this problem in the unlabelled case. Let <em>f</em>(<em>z</em>) be the <a href="ordinary_generating_function" title="wikilink">ordinary generating function</a> (OGF) of the objects, then the OGF of the configurations is given by the substituted <a href="cycle_index" title="wikilink">cycle index</a></p>

<p>

<math display="block" id="Analytic_combinatorics:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>z</mi>
        <mn>2</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>z</mi>
        <mi>n</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Z</ci>
    <ci>G</ci>
    <vector>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(G)(f(z),f(z^{2}),\ldots,f(z^{n})).\,
  </annotation>
 </semantics>
</math>

</p>

<p>In the labelled case we use an <a href="exponential_generating_function" title="wikilink">exponential generating function</a> (EGF) <em>g</em>(<em>z</em>) of the objects and apply the <a href="Labelled_enumeration_theorem" title="wikilink">Labelled enumeration theorem</a>, which says that the EGF of the configurations is given by</p>

<p>

<math display="block" id="Analytic_combinatorics:1">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>g</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>G</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{g(z)^{n}}{|G|}.
  </annotation>
 </semantics>
</math>

</p>

<p>We are able to enumerate filled slot configurations using either PET in the unlabelled case or the labelled enumeration theorem in the labelled case. We now ask about the generating function of configurations obtained when there is more than one set of slots, with a permutation group acting on each. Clearly the orbits do not intersect and we may add the respective generating functions. Suppose, for example, that we want to enumerate unlabelled sequences of length two or three of some objects contained in a set <em>X</em>. There are two sets of slots, the first one containing two slots, and the second one, three slots. The group acting on the first set is 

<math display="inline" id="Analytic_combinatorics:2">
 <semantics>
  <msub>
   <mi>E</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{2}
  </annotation>
 </semantics>
</math>

, and on the second slot, 

<math display="inline" id="Analytic_combinatorics:3">
 <semantics>
  <msub>
   <mi>E</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{3}
  </annotation>
 </semantics>
</math>

. We represent this by the following formal power series in <em>X</em>:</p>

<p>

<math display="block" id="Analytic_combinatorics:4">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>X</mi>
     <mn>2</mn>
    </msup>
    <mo>/</mo>
    <mpadded width="+2.8pt">
     <msub>
      <mi>E</mi>
      <mn>2</mn>
     </msub>
    </mpadded>
   </mrow>
   <mo rspace="5.3pt">+</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mn>3</mn>
    </msup>
    <mo>/</mo>
    <msub>
     <mi>E</mi>
     <mn>3</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{2}/E_{2}\;+\;X^{3}/E_{3}
  </annotation>
 </semantics>
</math>

</p>

<p>where the term 

<math display="inline" id="Analytic_combinatorics:5">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mi>n</mi>
   </msup>
   <mo>/</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{n}/G
  </annotation>
 </semantics>
</math>

 is used to denote the set of orbits under <em>G</em> and 

<math display="inline" id="Analytic_combinatorics:6">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>X</mi>
    <mo>×</mo>
    <mi mathvariant="normal">…</mi>
    <mo>×</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>normal-…</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{n}=X\times\ldots\times X
  </annotation>
 </semantics>
</math>

, which denotes in the obvious way the process of distributing the objects from <em>X</em> with repetition into the <em>n</em> slots. Similarly, consider the labelled problem of creating cycles of arbitrary length from a set of labelled objects <em>X</em>. This yields the following series of actions of cyclic groups:</p>

<p>

<math display="block" id="Analytic_combinatorics:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>/</mo>
     <mpadded width="+2.8pt">
      <msub>
       <mi>C</mi>
       <mn>1</mn>
      </msub>
     </mpadded>
    </mrow>
    <mo rspace="5.3pt">+</mo>
    <mrow>
     <msup>
      <mi>X</mi>
      <mn>2</mn>
     </msup>
     <mo>/</mo>
     <mpadded width="+2.8pt">
      <msub>
       <mi>C</mi>
       <mn>2</mn>
      </msub>
     </mpadded>
    </mrow>
    <mo rspace="5.3pt">+</mo>
    <mrow>
     <msup>
      <mi>X</mi>
      <mn>3</mn>
     </msup>
     <mo>/</mo>
     <mpadded width="+2.8pt">
      <msub>
       <mi>C</mi>
       <mn>3</mn>
      </msub>
     </mpadded>
    </mrow>
    <mo rspace="5.3pt">+</mo>
    <mrow>
     <msup>
      <mi>X</mi>
      <mn>4</mn>
     </msup>
     <mo>/</mo>
     <mpadded width="+2.8pt">
      <msub>
       <mi>C</mi>
       <mn>4</mn>
      </msub>
     </mpadded>
    </mrow>
    <mo rspace="5.3pt">+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X/C_{1}\;+\;X^{2}/C_{2}\;+\;X^{3}/C_{3}\;+\;X^{4}/C_{4}\;+\cdots.
  </annotation>
 </semantics>
</math>

</p>

<p>Clearly we can assign meaning to any such power series of quotients (orbits) with respect to permutation groups, where we restrict the groups of degree <em>n</em> to the conjugacy classes 

<math display="inline" id="Analytic_combinatorics:8">
 <semantics>
  <mrow>
   <mo>Cl</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Cl</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Cl}(S_{n})
  </annotation>
 </semantics>
</math>

 of the symmetric group 

<math display="inline" id="Analytic_combinatorics:9">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{n}
  </annotation>
 </semantics>
</math>

, which form a unique factorization domain. (The orbits with respect to two groups from the same conjugacy class are isomorphic.) This motivates the following definition.</p>

<p>A class 

<math display="inline" id="Analytic_combinatorics:10">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>∈</mo>
   <mrow>
    <mi>ℕ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>𝔄</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝒞</ci>
    <apply>
     <times></times>
     <ci>ℕ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝔄</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}\in\mathbb{N}[\mathfrak{A}]
  </annotation>
 </semantics>
</math>

 of combinatorial structures is a formal series</p>

<p>

<math display="block" id="Analytic_combinatorics:11">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>≥</mo>
      <mn>1</mn>
     </mrow>
    </munder>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>G</mi>
       <mo>∈</mo>
       <mrow>
        <mo>Cl</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>S</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>G</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>X</mi>
         <mi>n</mi>
        </msup>
        <mo>/</mo>
        <mi>G</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒞</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>G</ci>
        <apply>
         <ci>Cl</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>G</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>X</ci>
         <ci>n</ci>
        </apply>
        <ci>G</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}=\sum_{n\geq 1}\sum_{G\in\operatorname{Cl}(S_{n})}c_{G}(X^{n}/G)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Analytic_combinatorics:12">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

 (the "A" is for "atoms") is the set of primes of the UFD 

<math display="inline" id="Analytic_combinatorics:13">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>Cl</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>S</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <ci>Cl</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </set>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\operatorname{Cl}(S_{n})\}_{n\geq 1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>G</mi>
    </msub>
    <mo>∈</mo>
    <mi>ℕ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>G</ci>
    </apply>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{G}\in\mathbb{N}.
  </annotation>
 </semantics>
</math>

</p>

<p>In the following we will simplify our notation a bit and write e.g.</p>

<p>

<math display="block" id="Analytic_combinatorics:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>E</mi>
      <mn>3</mn>
     </msub>
     <mtext>and</mtext>
     <msub>
      <mi>C</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>C</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>C</mi>
     <mn>3</mn>
    </msub>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">3</cn>
     </apply>
     <mtext>and</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{2}+E_{3}\mbox{ and }C_{1}+C_{2}+C_{3}+\cdots.
  </annotation>
 </semantics>
</math>

</p>

<p>for the classes mentioned above.</p>
<h2 id="the-flajoletsedgewick-fundamental-theorem">The Flajolet–Sedgewick fundamental theorem</h2>

<p>A theorem in the Flajolet–Sedgewick theory of symbolic combinatorics treats the enumeration problem of labelled and unlabelled combinatorial classes by means of the creation of symbolic operators that make it possible to translate equations involving combinatorial structures directly (and automatically) into equations in the generating functions of these structures.</p>

<p>Let 

<math display="inline" id="Analytic_combinatorics:16">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>∈</mo>
   <mrow>
    <mi>ℕ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>𝔄</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝒞</ci>
    <apply>
     <times></times>
     <ci>ℕ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝔄</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}\in\mathbb{N}[\mathfrak{A}]
  </annotation>
 </semantics>
</math>

 be a class of combinatorial structures. The OGF 

<math display="inline" id="Analytic_combinatorics:17">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(z)
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Analytic_combinatorics:18">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒞</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}(X)
  </annotation>
 </semantics>
</math>

 where <em>X</em> has OGF 

<math display="inline" id="Analytic_combinatorics:19">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)
  </annotation>
 </semantics>
</math>

 and the EGF 

<math display="inline" id="Analytic_combinatorics:20">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Analytic_combinatorics:21">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒞</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}(X)
  </annotation>
 </semantics>
</math>

 where <em>X</em> is labelled with EGF 

<math display="inline" id="Analytic_combinatorics:22">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(z)
  </annotation>
 </semantics>
</math>

 are given by</p>

<p>

<math display="block" id="Analytic_combinatorics:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>≥</mo>
      <mn>1</mn>
     </mrow>
    </munder>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>G</mi>
       <mo>∈</mo>
       <mrow>
        <mo>Cl</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>S</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>G</mi>
      </msub>
      <mi>Z</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>G</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>z</mi>
          <mn>2</mn>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>z</mi>
          <mi>n</mi>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>G</ci>
        <apply>
         <ci>Cl</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>G</ci>
       </apply>
       <ci>Z</ci>
       <ci>G</ci>
       <vector>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(z)=\sum_{n\geq 1}\sum_{G\in\operatorname{Cl}(S_{n})}c_{G}Z(G)(f(z),f(z^{2}),%
\ldots,f(z^{n}))
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Analytic_combinatorics:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
     </munder>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>G</mi>
          <mo>∈</mo>
          <mrow>
           <mo>Cl</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>S</mi>
             <mi>n</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </munder>
        <mfrac>
         <msub>
          <mi>c</mi>
          <mi>G</mi>
         </msub>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>G</mi>
          <mo stretchy="false">|</mo>
         </mrow>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mi>g</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>G</ci>
         <apply>
          <ci>Cl</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>S</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <ci>G</ci>
        </apply>
        <apply>
         <abs></abs>
         <ci>G</ci>
        </apply>
       </apply>
      </apply>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)=\sum_{n\geq 1}\left(\sum_{G\in\operatorname{Cl}(S_{n})}\frac{c_{G}}{|G|}%
\right)g(z)^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>In the labelled case we have the additional requirement that <em>X</em> not contain elements of size zero. It will sometimes prove convenient to add one to 

<math display="inline" id="Analytic_combinatorics:25">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)
  </annotation>
 </semantics>
</math>

 to indicate the presence of one copy of the empty set. It is possible to assign meaning to both 

<math display="inline" id="Analytic_combinatorics:26">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>∈</mo>
   <mrow>
    <mi>ℤ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>𝔄</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝒞</ci>
    <apply>
     <times></times>
     <ci>ℤ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝔄</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}\in\mathbb{Z}[\mathfrak{A}]
  </annotation>
 </semantics>
</math>

 (the most common example is the case of unlabelled sets) and 

<math display="inline" id="Analytic_combinatorics:27">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
    <mo>∈</mo>
    <mrow>
     <mi>ℚ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>𝔄</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝒞</ci>
    <apply>
     <times></times>
     <ci>ℚ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>𝔄</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}\in\mathbb{Q}[\mathfrak{A}].
  </annotation>
 </semantics>
</math>

 To prove the theorem simply apply PET (Pólya enumeration theorem) and the labelled enumeration theorem.</p>

<p>The power of this theorem lies in the fact that it makes it possible to construct operators on generating functions that represent combinatorial classes. A structural equation between combinatorial classes thus translates directly into an equation in the corresponding generating functions. Moreover in the labelled case it is evident from the formula that we may replace 

<math display="inline" id="Analytic_combinatorics:28">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(z)
  </annotation>
 </semantics>
</math>

 by the atom <em>z</em> and compute the resulting operator, which may then be applied to EGFs. We now proceed to construct the most important operators. The reader may wish to compare with the data on the <a href="cycle_index" title="wikilink">cycle index</a> page.</p>
<h3 id="the-sequence-operator-mathfraks">The sequence operator 

<math display="inline" id="Analytic_combinatorics:29">
 <semantics>
  <mi>𝔖</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔖</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{S}
  </annotation>
 </semantics>
</math>

</h3>

<p>This operator corresponds to the class</p>

<p>

<math display="block" id="Analytic_combinatorics:30">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <msub>
    <mi>E</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>E</mi>
    <mn>2</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>E</mi>
    <mn>3</mn>
   </msub>
   <mo>+</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">⋯</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+E_{1}+E_{2}+E_{3}+\cdots\,
  </annotation>
 </semantics>
</math>

</p>

<p>and represents sequences, i.e. the slots are not being permuted and there is exactly one empty sequence. We have</p>

<p>

<math display="block" id="Analytic_combinatorics:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
     </munder>
     <mrow>
      <mi>Z</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>E</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>z</mi>
          <mn>2</mn>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>z</mi>
          <mi>n</mi>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
     </munder>
     <mrow>
      <mi>f</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <geq></geq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>Z</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>n</ci>
        </apply>
        <vector>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>z</ci>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>z</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>z</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <geq></geq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(z)=1+\sum_{n\geq 1}Z(E_{n})(f(z),f(z^{2}),\ldots,f(z^{n}))=1+\sum_{n\geq 1}f%
(z)^{n}=\frac{1}{1-f(z)}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Analytic_combinatorics:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>n</mi>
        <mo>≥</mo>
        <mn>1</mn>
       </mrow>
      </munder>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mn>1</mn>
         <mrow>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>E</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">|</mo>
         </mrow>
        </mfrac>
        <mo>)</mo>
       </mrow>
       <mi>g</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>n</mi>
       </msup>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <geq></geq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <abs></abs>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>E</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <ci>g</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)=1+\sum_{n\geq 1}\left(\frac{1}{|E_{n}|}\right)g(z)^{n}=\frac{1}{1-g(z)}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="the-cycle-operator-mathfrakc">The cycle operator 

<math display="inline" id="Analytic_combinatorics:33">
 <semantics>
  <mi>ℭ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℭ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{C}
  </annotation>
 </semantics>
</math>

</h3>

<p>This operator corresponds to the class</p>

<p>

<math display="block" id="Analytic_combinatorics:34">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>C</mi>
    <mn>3</mn>
   </msub>
   <mo>+</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">⋯</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}+C_{2}+C_{3}+\cdots\,
  </annotation>
 </semantics>
</math>

</p>

<p>i.e., cycles containing at least one object. We have</p>

<p>

<math display="block" id="Analytic_combinatorics:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>≥</mo>
      <mn>1</mn>
     </mrow>
    </munder>
    <mrow>
     <mi>Z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>C</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>z</mi>
         <mn>2</mn>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>z</mi>
         <mi>n</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>≥</mo>
      <mn>1</mn>
     </mrow>
    </munder>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>d</mi>
        <mo stretchy="false">|</mo>
        <mi>n</mi>
       </mrow>
      </munder>
      <mrow>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>d</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>f</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>z</mi>
          <mi>d</mi>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>n</mi>
         <mo>/</mo>
         <mi>d</mi>
        </mrow>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>Z</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>n</ci>
       </apply>
       <vector>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <csymbol cd="unknown">d</csymbol>
          <ci>normal-|</ci>
          <csymbol cd="unknown">n</csymbol>
         </cerror>
        </apply>
        <apply>
         <times></times>
         <ci>φ</ci>
         <ci>d</ci>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>z</ci>
           <ci>d</ci>
          </apply>
          <apply>
           <divide></divide>
           <ci>n</ci>
           <ci>d</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(z)=\sum_{n\geq 1}Z(C_{n})(f(z),f(z^{2}),\ldots,f(z^{n}))=\sum_{n\geq 1}\frac%
{1}{n}\sum_{d|n}\varphi(d)f(z^{d})^{n/d}
  </annotation>
 </semantics>
</math>

</p>

<p>or</p>

<p>

<math display="block" id="Analytic_combinatorics:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>≥</mo>
      <mn>1</mn>
     </mrow>
    </munder>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>m</mi>
        <mo>≥</mo>
        <mn>1</mn>
       </mrow>
      </munder>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mi>k</mi>
         <mi>m</mi>
        </mrow>
       </mfrac>
       <mi>f</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>z</mi>
          <mi>k</mi>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>m</mi>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>≥</mo>
      <mn>1</mn>
     </mrow>
    </munder>
    <mrow>
     <mfrac>
      <mrow>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>k</mi>
     </mfrac>
     <mrow>
      <mi>log</mi>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>z</mi>
           <mi>k</mi>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>φ</ci>
       <ci>k</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <geq></geq>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>m</ci>
          </apply>
         </apply>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>z</ci>
           <ci>k</ci>
          </apply>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>φ</ci>
         <ci>k</ci>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <log></log>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>z</ci>
            <ci>k</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(z)=\sum_{k\geq 1}\varphi(k)\sum_{m\geq 1}\frac{1}{km}f(z^{k})^{m}=\sum_{k%
\geq 1}\frac{\varphi(k)}{k}\log\frac{1}{1-f(z^{k})}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Analytic_combinatorics:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
     </munder>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mo stretchy="false">|</mo>
         <msub>
          <mi>C</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">|</mo>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mi>g</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>log</mi>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <abs></abs>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>C</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>g</ci>
         <ci>z</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)=\sum_{n\geq 1}\left(\frac{1}{|C_{n}|}\right)g(z)^{n}=\log\frac{1}{1-g(z)}.
  </annotation>
 </semantics>
</math>

</p>

<p>This operator, together with the set operator 

<math display="inline" id="Analytic_combinatorics:38">
 <semantics>
  <mi>𝔓</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔓</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{P}
  </annotation>
 </semantics>
</math>

, and their restrictions to specific degrees are used to compute <a href="random_permutation_statistics" title="wikilink">random permutation statistics</a>. There are two useful restrictions of this operator, namely to even and odd cycles.</p>

<p>The labelled even cycle operator 

<math display="inline" id="Analytic_combinatorics:39">
 <semantics>
  <msub>
   <mi>ℭ</mi>
   <mo>even</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℭ</ci>
    <ci>even</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{C}_{\operatorname{even}}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Analytic_combinatorics:40">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>C</mi>
    <mn>4</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>C</mi>
    <mn>6</mn>
   </msub>
   <mo>+</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">⋯</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">6</cn>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}+C_{4}+C_{6}+\cdots\,
  </annotation>
 </semantics>
</math>

</p>

<p>which yields</p>

<p>

<math display="block" id="Analytic_combinatorics:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
     </munder>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mo stretchy="false">|</mo>
         <msub>
          <mi>C</mi>
          <mrow>
           <mn>2</mn>
           <mi>n</mi>
          </mrow>
         </msub>
         <mo stretchy="false">|</mo>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mi>g</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mi>log</mi>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>g</mi>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>z</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <abs></abs>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>C</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>g</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>z</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)=\sum_{n\geq 1}\left(\frac{1}{|C_{2n}|}\right)g(z)^{2n}=\frac{1}{2}\log%
\frac{1}{1-g(z)^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>This implies that the labelled odd cycle operator 

<math display="inline" id="Analytic_combinatorics:42">
 <semantics>
  <msub>
   <mi>ℭ</mi>
   <mo>odd</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℭ</ci>
    <ci>odd</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{C}_{\operatorname{odd}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Analytic_combinatorics:43">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>C</mi>
    <mn>3</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>C</mi>
    <mn>5</mn>
   </msub>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">5</cn>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}+C_{3}+C_{5}+\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>is given by</p>

<p>

<math display="block" id="Analytic_combinatorics:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>log</mi>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mrow>
       <mi>log</mi>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mi>g</mi>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>z</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
       </mfrac>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mi>log</mi>
      <mfrac>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>g</ci>
          <ci>z</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <log></log>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <ci>g</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>z</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>g</ci>
          <ci>z</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>g</ci>
          <ci>z</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)=\log\frac{1}{1-g(z)}-\frac{1}{2}\log\frac{1}{1-g(z)^{2}}=\frac{1}{2}\log%
\frac{1+g(z)}{1-g(z)}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="the-multisetset-operator-mathfrakmmathfrakp">The multiset/set operator 

<math display="inline" id="Analytic_combinatorics:45">
 <semantics>
  <mrow>
   <mi>𝔐</mi>
   <mo>/</mo>
   <mi>𝔓</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>𝔐</ci>
    <ci>𝔓</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{M}/\mathfrak{P}
  </annotation>
 </semantics>
</math>

</h3>

<p>The series is</p>

<p>

<math display="block" id="Analytic_combinatorics:46">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <msub>
    <mi>S</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>S</mi>
    <mn>2</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>S</mi>
    <mn>3</mn>
   </msub>
   <mo>+</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">⋯</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+S_{1}+S_{2}+S_{3}+\cdots\,
  </annotation>
 </semantics>
</math>

</p>

<p>i.e., the symmetric group is applied to the slots. This creates multisets in the unlabelled case and sets in the labelled case (there are no multisets in the labelled case because the labels distinguish multiple instances of the same object from the set being put into different slots). We include the empty set in both the labelled and the unlabelled case.</p>

<p>The unlabelled case is done using the function</p>

<p>

<math display="block" id="Analytic_combinatorics:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <mrow>
     <msup>
      <mi>y</mi>
      <mi>n</mi>
     </msup>
     <mi>Z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>S</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>z</mi>
         <mn>2</mn>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>z</mi>
         <mi>n</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>z</ci>
      </apply>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
      <ci>Z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>n</ci>
      </apply>
      <vector>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(f(z),y)=\sum_{n\geq 0}y^{n}Z(S_{n})(f(z),f(z^{2}),\ldots,f(z^{n}))
  </annotation>
 </semantics>
</math>

</p>

<p>so that</p>

<p>

<math display="block" id="Analytic_combinatorics:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝔐</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>M</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝔐</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>z</ci>
      </apply>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{M}(f(z))=M(f(z),1).\,
  </annotation>
 </semantics>
</math>

</p>

<p>Evaluating 

<math display="inline" id="Analytic_combinatorics:49">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>z</ci>
     </apply>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(f(z),1)
  </annotation>
 </semantics>
</math>

 we obtain</p>

<p>

<math display="block" id="Analytic_combinatorics:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>l</mi>
         <mo>≥</mo>
         <mn>1</mn>
        </mrow>
       </munder>
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>z</mi>
           <mi>l</mi>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mi>l</mi>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>l</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>l</ci>
        </apply>
       </apply>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(z)=\exp\left(\sum_{l\geq 1}\frac{f(z^{l})}{l}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>For the labelled case we have</p>

<p>

<math display="block" id="Analytic_combinatorics:51">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>n</mi>
        <mo>≥</mo>
        <mn>1</mn>
       </mrow>
      </munder>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mn>1</mn>
         <mrow>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>S</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">|</mo>
         </mrow>
        </mfrac>
        <mo>)</mo>
       </mrow>
       <mi>g</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>n</mi>
       </msup>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <mfrac>
      <mrow>
       <mi>g</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>n</mi>
       </msup>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>exp</mi>
      <mi>g</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <geq></geq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <abs></abs>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>S</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <ci>g</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>g</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <exp></exp>
       <ci>g</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)=1+\sum_{n\geq 1}\left(\frac{1}{|S_{n}|}\right)g(z)^{n}=\sum_{n\geq 0}%
\frac{g(z)^{n}}{n!}=\exp g(z).
  </annotation>
 </semantics>
</math>

</p>

<p>In the labelled case we denote the operator by 

<math display="inline" id="Analytic_combinatorics:52">
 <semantics>
  <mi>𝔓</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔓</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{P}
  </annotation>
 </semantics>
</math>

, and in the unlabelled case, by 

<math display="inline" id="Analytic_combinatorics:53">
 <semantics>
  <mi>𝔐</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔐</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{M}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="procedure">Procedure</h2>

<p>Typically, one starts with the <em>neutral class</em> 

<math display="inline" id="Analytic_combinatorics:54">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℰ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℰ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

, containing a single object of size 0 (the <em>neutral object</em>, often denoted by 

<math display="inline" id="Analytic_combinatorics:55">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

), and one or more <em>atomic classes</em> 

<math display="inline" id="Analytic_combinatorics:56">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒵</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒵</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{Z}
  </annotation>
 </semantics>
</math>

, each containing a single object of size 1. Next, <a href="Set_theory" title="wikilink">set-theoretic</a> relations involving various simple operations, such as <a href="disjoint_union" title="wikilink">disjoint unions</a>, <a href="Cartesian_product" title="wikilink">products</a>, <a href="Set_(mathematics)" title="wikilink">sets</a>, <a href="sequence" title="wikilink">sequences</a>, and <a href="multiset" title="wikilink">multisets</a> define more complex classes in terms of the already defined classes. These relations may be <a href="recursion" title="wikilink">recursive</a>. The elegance of symbolic combinatorics lies in that the set theoretic, or <em>symbolic</em>, relations translate directly into <em><a href="algebra" title="wikilink">algebraic</a></em> relations involving the generating functions.</p>

<p>In this article, we will follow the convention of using script uppercase letters to denote combinatorial classes and the corresponding plain letters for the generating functions (so the class 

<math display="inline" id="Analytic_combinatorics:57">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 has generating function 

<math display="inline" id="Analytic_combinatorics:58">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)
  </annotation>
 </semantics>
</math>

).</p>

<p>There are two types of generating functions commonly used in symbolic combinatorics—<a href="ordinary_generating_function" title="wikilink">ordinary generating functions</a>, used for combinatorial classes of unlabelled objects, and <a href="exponential_generating_function" title="wikilink">exponential generating functions</a>, used for classes of labelled objects.</p>

<p>It is trivial to show that the generating functions (either ordinary or exponential) for 

<math display="inline" id="Analytic_combinatorics:59">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℰ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℰ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:60">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒵</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒵</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{Z}
  </annotation>
 </semantics>
</math>

 are 

<math display="inline" id="Analytic_combinatorics:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>z</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(z)=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>z</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(z)=z
  </annotation>
 </semantics>
</math>

, respectively. The disjoint union is also simple — for disjoint sets 

<math display="inline" id="Analytic_combinatorics:63">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:64">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Analytic_combinatorics:65">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo>∪</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <union></union>
     <ci>ℬ</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathcal{B}\cup\mathcal{C}
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Analytic_combinatorics:66">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)=B(z)+C(z)
  </annotation>
 </semantics>
</math>

. The relations corresponding to other operations depend on whether we are talking about labelled or unlabelled structures (and ordinary or exponential generating functions).</p>
<h2 id="combinatorial-sum">Combinatorial sum</h2>

<p>The restriction of <a href="Union_(set_theory)" title="wikilink">unions</a> to disjoint unions is an important one; however, in the formal specification of symbolic combinatorics, it is too much trouble to keep track of which sets are disjoint. Instead, we make use of a construction that guarantees there is no intersection (<em>be careful, however; this affects the semantics of the operation as well</em>). In defining the <em>combinatorial sum</em> of two sets 

<math display="inline" id="Analytic_combinatorics:67">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:68">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

, we mark members of each set with a distinct marker, for example 

<math display="inline" id="Analytic_combinatorics:69">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 for members of 

<math display="inline" id="Analytic_combinatorics:70">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:71">
 <semantics>
  <mo>∙</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∙</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bullet
  </annotation>
 </semantics>
</math>

 for members of 

<math display="inline" id="Analytic_combinatorics:72">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

. The combinatorial sum is then:</p>

<p>

<math display="block" id="Analytic_combinatorics:73">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>+</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">𝒜</mi>
      <mo>×</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mo>∘</mo>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      <mo>×</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mo>∙</mo>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>𝒜</ci>
     <ci>ℬ</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <times></times>
      <ci>𝒜</ci>
      <set>
       <compose></compose>
      </set>
     </apply>
     <apply>
      <times></times>
      <ci>ℬ</ci>
      <set>
       <ci>normal-∙</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}+\mathcal{B}=(\mathcal{A}\times\{\circ\})\cup(\mathcal{B}\times\{%
\bullet\})
  </annotation>
 </semantics>
</math>

</p>

<p>This is the operation that formally corresponds to addition.</p>
<h2 id="unlabelled-structures">Unlabelled structures</h2>

<p>With unlabelled structures, an <a href="ordinary_generating_function" title="wikilink">ordinary generating function</a> (OGF) is used. The OGF of a sequence 

<math display="inline" id="Analytic_combinatorics:74">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{n}
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Analytic_combinatorics:75">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x)=\sum_{n=0}^{\infty}A_{n}x^{n}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="product">Product</h3>

<p>The <a href="Cartesian_product" title="wikilink">product</a> of two combinatorial classes 

<math display="inline" id="Analytic_combinatorics:76">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:77">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 is specified by defining the size of an ordered pair as the sum of the sizes of the elements in the pair. Thus we have for 

<math display="inline" id="Analytic_combinatorics:78">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in\mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:79">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>b</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\in\mathcal{B}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Analytic_combinatorics:80">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>a</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>b</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <abs></abs>
      <ci>a</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |(a,b)|=|a|+|b|
  </annotation>
 </semantics>
</math>

. This should be a fairly intuitive definition. We now note that the number of elements in 

<math display="inline" id="Analytic_combinatorics:81">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>×</mo>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒜</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\times\mathcal{B}
  </annotation>
 </semantics>
</math>

 of size <var>n</var> is</p>

<p>

<math display="block" id="Analytic_combinatorics:82">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>A</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>B</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{n}A_{k}B_{n-k}.
  </annotation>
 </semantics>
</math>

</p>

<p>Using the definition of the OGF and some elementary algebra, we can show that</p>

<p>

<math display="block" id="Analytic_combinatorics:83">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo>×</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>ℬ</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathcal{B}\times\mathcal{C}
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Analytic_combinatorics:84">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mi>C</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>z</ci>
      </apply>
      <ci>C</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)=B(z)\cdot C(z).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="sequence">Sequence</h3>

<p>The <em>sequence construction</em>, denoted by 

<math display="inline" id="Analytic_combinatorics:85">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝔊</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>𝔊</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathfrak{G}\{\mathcal{B}\}
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Analytic_combinatorics:86">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝔊</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ℰ</mi>
     <mo>+</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ℬ</mi>
       <mo>×</mo>
       <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ℬ</mi>
       <mo>×</mo>
       <mi class="ltx_font_mathcaligraphic">ℬ</mi>
       <mo>×</mo>
       <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝔊</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
    <apply>
     <plus></plus>
     <ci>ℰ</ci>
     <ci>ℬ</ci>
     <apply>
      <times></times>
      <ci>ℬ</ci>
      <ci>ℬ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ℬ</ci>
      <ci>ℬ</ci>
      <ci>ℬ</ci>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{G}\{\mathcal{B}\}=\mathcal{E}+\mathcal{B}+(\mathcal{B}\times\mathcal%
{B})+(\mathcal{B}\times\mathcal{B}\times\mathcal{B})+\cdots.
  </annotation>
 </semantics>
</math>

</p>

<p>In other words, a sequence is the neutral element, or an element of 

<math display="inline" id="Analytic_combinatorics:87">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

, or an ordered pair, ordered triple, etc. This leads to the relation</p>

<p>

<math display="block" id="Analytic_combinatorics:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>B</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>B</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>3</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)=1+B(z)+B(z)^{2}+B(z)^{3}+\cdots=\frac{1}{1-B(z)}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="set">Set</h3>

<p>The <em>set</em> (or <em>powerset</em>) <em>construction</em>, denoted by 

<math display="inline" id="Analytic_combinatorics:89">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝔓</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>𝔓</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathfrak{P}\{\mathcal{B}\}
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Analytic_combinatorics:90">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝔓</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>β</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ℰ</mi>
       <mo>+</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mi>β</mi>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝔓</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <ci>β</ci>
       <ci>ℬ</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>ℰ</ci>
      <set>
       <ci>β</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{P}\{\mathcal{B}\}=\prod_{\beta\in\mathcal{B}}(\mathcal{E}+\{\beta\}),
  </annotation>
 </semantics>
</math>

</p>

<p>which leads to the relation</p>

<p>

<math display="inline" id="Analytic_combinatorics:91">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A(z)
  </annotation>
 </semantics>
</math>


</p>

<p>where the expansion</p>

<p>

<math display="block" id="Analytic_combinatorics:92">
 <semantics>
  <mrow>
   <mrow>
    <mi>ln</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mfrac>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mi>u</mi>
       <mi>k</mi>
      </msup>
     </mrow>
     <mi>k</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ln></ln>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ln(1+u)=\sum_{k=1}^{\infty}\frac{(-1)^{k-1}u^{k}}{k}
  </annotation>
 </semantics>
</math>

</p>

<p>was used to go from line 4 to line 5.</p>
<h3 id="multiset">Multiset</h3>

<p>The <em>multiset construction</em>, denoted 

<math display="inline" id="Analytic_combinatorics:93">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝔐</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>𝔐</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathfrak{M}\{\mathcal{B}\}
  </annotation>
 </semantics>
</math>

 is a generalization of the set construction. In the set construction, each element can occur zero or one times. In a multiset, each element can appear an arbitrary number of times. Therefore,</p>

<p>

<math display="block" id="Analytic_combinatorics:94">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝔐</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>β</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>𝔊</mi>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>β</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝔐</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <ci>β</ci>
       <ci>ℬ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>𝔊</ci>
      <set>
       <ci>β</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{M}\{\mathcal{B}\}=\prod_{\beta\in\mathcal{B}}\mathfrak{G}\{\beta\}.
  </annotation>
 </semantics>
</math>

</p>

<p>This leads to the relation</p>

<p>

<math display="inline" id="Analytic_combinatorics:95">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A(z)
  </annotation>
 </semantics>
</math>


</p>

<p>where, similar to the above set construction, we expand 

<math display="inline" id="Analytic_combinatorics:96">
 <semantics>
  <mrow>
   <mi>ln</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msup>
      <mi>z</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ln></ln>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ln(1-z^{n})
  </annotation>
 </semantics>
</math>

, swap the sums, and substitute for the OGF of 

<math display="inline" id="Analytic_combinatorics:97">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="other-elementary-constructions">Other elementary constructions</h3>

<p>Other important elementary constructions are:</p>
<ul>
<li>the <em>cycle construction</em> (

<math display="inline" id="Analytic_combinatorics:98">
 <semantics>
  <mrow>
   <mi>ℭ</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℭ</ci>
    <set>
     <ci>ℬ</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{C}\{\mathcal{B}\}
  </annotation>
 </semantics>
</math>

), like sequences except that cyclic rotations are not considered distinct</li>
<li><em>pointing</em> (

<math display="inline" id="Analytic_combinatorics:99">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta\mathcal{B}
  </annotation>
 </semantics>
</math>

), in which each member of 

<math display="inline" id="Analytic_combinatorics:100">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 is augmented by a neutral (zero size) pointer to one of its atoms</li>
<li><em>substitution</em> (

<math display="inline" id="Analytic_combinatorics:101">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   <mo>∘</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>ℬ</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}\circ\mathcal{C}
  </annotation>
 </semantics>
</math>

), in which each atom in a member of 

<math display="inline" id="Analytic_combinatorics:102">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 is replaced by a member of 

<math display="inline" id="Analytic_combinatorics:103">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The derivations for these constructions are too complicated to show here. Here are the results:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Construction</p></th>
<th style="text-align: left;">
<p>Generating function</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Analytic_combinatorics:104">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi>ℭ</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>ℭ</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathfrak{C}\{\mathcal{B}\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Analytic_combinatorics:105">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mfrac>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>k</mi>
     </mfrac>
     <mrow>
      <mi>ln</mi>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>B</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>z</mi>
           <mi>k</mi>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <ci>k</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <ln></ln>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>B</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>z</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)=\sum_{k=1}^{\infty}\frac{\phi(k)}{k}\ln\frac{1}{1-B(z^{k})}
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Analytic_combinatorics:106">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(k)\,
  </annotation>
 </semantics>
</math>

 is the <a href="Euler_totient_function" title="wikilink">Euler totient function</a>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Analytic_combinatorics:107">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>normal-Θ</ci>
     <ci>ℬ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\Theta\mathcal{B}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Analytic_combinatorics:108">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>z</mi>
    <mfrac>
     <mi>d</mi>
     <mrow>
      <mi>d</mi>
      <mi>z</mi>
     </mrow>
    </mfrac>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>z</ci>
     <apply>
      <divide></divide>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <ci>B</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)=z\frac{d}{dz}B(z)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Analytic_combinatorics:109">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo>∘</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <compose></compose>
     <ci>ℬ</ci>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathcal{B}\circ\mathcal{C}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Analytic_combinatorics:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)=B(C(z))\,
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h3 id="examples">Examples</h3>

<p>Many combinatorial classes can be built using these elementary constructions. For example, the class of plane <a href="tree_(graph)" title="wikilink">trees</a> (that is, trees <a href="embedding" title="wikilink">embedded</a> in the plane, so that the order of the subtrees matters) is specified by the <a href="recursion" title="wikilink">recursive</a> relation</p>

<p>

<math display="block" id="Analytic_combinatorics:111">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒢</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">𝒵</mi>
      <mo>×</mo>
      <mi>𝔊</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi class="ltx_font_mathcaligraphic">𝒢</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒢</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>𝒵</ci>
      <ci>𝔊</ci>
     </apply>
     <set>
      <ci>𝒢</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}=\mathcal{Z}\times\mathfrak{G}\{\mathcal{G}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>In other words, a tree is a root node of size 1 and a sequence of subtrees. This gives</p>

<p>

<math display="block" id="Analytic_combinatorics:112">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mi>z</mi>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>G</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>z</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)=\frac{z}{1-G(z)}
  </annotation>
 </semantics>
</math>

</p>

<p>we solve for G(z) by multiplying 

<math display="inline" id="Analytic_combinatorics:113">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-G(z)
  </annotation>
 </semantics>
</math>

 to get</p>

<p>

<math display="inline" id="Analytic_combinatorics:114">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>G</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>G</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)-G(z)^{2}=z
  </annotation>
 </semantics>
</math>

</p>

<p>subtracting z and solving for G(z) using the quadratic formula gives</p>

<p>

<math display="block" id="Analytic_combinatorics:115">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msqrt>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mn>4</mn>
         <mi>z</mi>
        </mrow>
       </mrow>
      </msqrt>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">4</cn>
         <ci>z</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(z)=\frac{1-\sqrt{1-4z}}{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Another example (and a classic combinatorics problem) is <a href="integer_partition" title="wikilink">integer partitions</a>. First, define the class of positive integers 

<math display="inline" id="Analytic_combinatorics:116">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

, where the size of each integer is its value:</p>

<p>

<math display="block" id="Analytic_combinatorics:117">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℐ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒵</mi>
     <mo>×</mo>
     <mi>𝔊</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi class="ltx_font_mathcaligraphic">𝒵</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℐ</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>𝒵</ci>
      <ci>𝔊</ci>
     </apply>
     <set>
      <ci>𝒵</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}=\mathcal{Z}\times\mathfrak{G}\{\mathcal{Z}\}
  </annotation>
 </semantics>
</math>

</p>

<p>The OGF of 

<math display="inline" id="Analytic_combinatorics:118">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 is then</p>

<p>

<math display="block" id="Analytic_combinatorics:119">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mi>z</mi>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>z</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>z</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(z)=\frac{z}{1-z}.
  </annotation>
 </semantics>
</math>

</p>

<p>Now, define the set of partitions 

<math display="inline" id="Analytic_combinatorics:120">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Analytic_combinatorics:121">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒫</mi>
    <mo>=</mo>
    <mrow>
     <mi>𝔐</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi class="ltx_font_mathcaligraphic">ℐ</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒫</ci>
    <apply>
     <times></times>
     <ci>𝔐</ci>
     <set>
      <ci>ℐ</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}=\mathfrak{M}\{\mathcal{I}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>The OGF of 

<math display="inline" id="Analytic_combinatorics:122">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Analytic_combinatorics:123">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>z</mi>
          <mn>2</mn>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mn>3</mn>
        </mfrac>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>z</mi>
          <mn>3</mn>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>I</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">3</cn>
       </apply>
       <ci>I</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(z)=\exp\left(I(z)+\frac{1}{2}I(z^{2})+\frac{1}{3}I(z^{3})+\cdots\right).
  </annotation>
 </semantics>
</math>

</p>

<p>Unfortunately, there is no closed form for 

<math display="inline" id="Analytic_combinatorics:124">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(z)
  </annotation>
 </semantics>
</math>

; however, the OGF can be used to derive a <a href="recurrence_relation" title="wikilink">recurrence relation</a>, or, using more advanced methods of analytic combinatorics, calculate the <a href="Generating_function#Asymptotic_growth_of_a_sequence" title="wikilink">asymptotic behavior</a> of the counting sequence.</p>
<h2 id="labelled-structures">Labelled structures</h2>

<p>An object is <em>weakly labelled</em> if each of its atoms has a nonnegative integer label, and each of these labels is distinct. An object is (<em>strongly</em> or <em>well</em>) <em>labelled</em>, if furthermore, these labels comprise the consecutive integers 

<math display="inline" id="Analytic_combinatorics:125">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">…</mi>
    <mi>n</mi>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [1\ldots n]
  </annotation>
 </semantics>
</math>

. <em>Note: some combinatorial classes are best specified as labelled structures or unlabelled structures, but some readily admit both specifications.</em> A good example of labelled structures is the class of <a href="Graph_(mathematics)" title="wikilink">labelled graphs</a>.</p>

<p>With labelled structures, an <a href="exponential_generating_function" title="wikilink">exponential generating function</a> (EGF) is used. The EGF of a sequence 

<math display="inline" id="Analytic_combinatorics:126">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{n}
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Analytic_combinatorics:127">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
      <mfrac>
       <msup>
        <mi>x</mi>
        <mi>n</mi>
       </msup>
       <mrow>
        <mi>n</mi>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x)=\sum_{n=0}^{\infty}A_{n}\frac{x^{n}}{n!}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="product-1">Product</h3>

<p>For labelled structures, we must use a different definition for product than for unlabelled structures. In fact, if we simply used the cartesian product, the resulting structures would not even be well labelled. Instead, we use the so-called <em>labelled product</em>, denoted 

<math display="inline" id="Analytic_combinatorics:128">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>⋆</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋆</ci>
    <ci>𝒜</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\star\mathcal{B}.
  </annotation>
 </semantics>
</math>

</p>

<p>For a pair 

<math display="inline" id="Analytic_combinatorics:129">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>β</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\in\mathcal{B}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:130">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>γ</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in\mathcal{C}
  </annotation>
 </semantics>
</math>

, we wish to combine the two structures into a single structure. In order for the result to be well labelled, this requires some relabelling of the atoms in 

<math display="inline" id="Analytic_combinatorics:131">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:132">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

. We will restrict our attention to relabellings that are consistent with the order of the original labels. Note that there are still multiple ways to do the relabelling; thus, each pair of members determines not a single member in the product, but a set of new members. The details of this construction are found on the page of the <a href="Labelled_enumeration_theorem" title="wikilink">Labelled enumeration theorem</a>.</p>

<p>To aid this development, let us define a function, 

<math display="inline" id="Analytic_combinatorics:133">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

, that takes as its argument a (possibly weakly) labelled object 

<math display="inline" id="Analytic_combinatorics:134">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 and relabels its atoms in an order-consistent way so that 

<math display="inline" id="Analytic_combinatorics:135">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(\alpha)
  </annotation>
 </semantics>
</math>

 is well labelled. We then define the labelled product for two objects 

<math display="inline" id="Analytic_combinatorics:136">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:137">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Analytic_combinatorics:138">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>⋆</mo>
     <mi>β</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>α</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <msup>
       <mi>β</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>α</mi>
          <mo>′</mo>
         </msup>
         <mo>,</mo>
         <msup>
          <mi>β</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mtext>is well-labelled,</mtext>
        <mi>ρ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>α</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mi>α</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mi>ρ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>β</mi>
          <mo>′</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mi>β</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋆</ci>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <ci>normal-′</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>β</ci>
          <ci>normal-′</ci>
         </apply>
        </interval>
        <mtext>is well-labelled,</mtext>
        <ci>ρ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>α</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <ci>α</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>ρ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>β</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <ci>β</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\star\beta=\{(\alpha^{\prime},\beta^{\prime}):(\alpha^{\prime},\beta^{%
\prime})\mbox{ is well-labelled, }\rho(\alpha^{\prime})=\alpha,\rho(\beta^{%
\prime})=\beta\}.
  </annotation>
 </semantics>
</math>

</p>

<p>Finally, the labelled product of two classes 

<math display="inline" id="Analytic_combinatorics:139">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:140">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Analytic_combinatorics:141">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
     <mo>⋆</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
      <mrow>
       <mrow>
        <mi>α</mi>
        <mo>∈</mo>
        <mi class="ltx_font_mathcaligraphic">𝒜</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>β</mi>
        <mo>∈</mo>
        <mi class="ltx_font_mathcaligraphic">ℬ</mi>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>α</mi>
       <mo>⋆</mo>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋆</ci>
     <ci>𝒜</ci>
     <ci>ℬ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>α</ci>
        <ci>𝒜</ci>
       </apply>
       <apply>
        <in></in>
        <ci>β</ci>
        <ci>ℬ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋆</ci>
      <ci>α</ci>
      <ci>β</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\star\mathcal{B}=\bigcup_{\alpha\in\mathcal{A},\beta\in\mathcal{B}}%
(\alpha\star\beta).
  </annotation>
 </semantics>
</math>

</p>

<p>The EGF can be derived by noting that for objects of size 

<math display="inline" id="Analytic_combinatorics:142">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_combinatorics:143">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

, there are 

<math display="inline" id="Analytic_combinatorics:144">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mi>k</mi>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n\choose k}
  </annotation>
 </semantics>
</math>

 ways to do the relabelling. Therefore, the total number of objects of size 

<math display="inline" id="Analytic_combinatorics:145">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Analytic_combinatorics:146">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mi>n</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mi>k</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <msub>
      <mi>A</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>B</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{n}{n\choose k}A_{k}B_{n-k}.
  </annotation>
 </semantics>
</math>

</p>

<p>This <em>binomial convolution</em> relation for the terms is equivalent to multiplying the EGFs,</p>

<p>

<math display="block" id="Analytic_combinatorics:147">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>B</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>z</ci>
     </apply>
     <ci>B</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)\cdot B(z).\,
  </annotation>
 </semantics>
</math>

</p>
<h3 id="sequence-1">Sequence</h3>

<p>The <em>sequence construction</em> 

<math display="inline" id="Analytic_combinatorics:148">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝔊</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>𝔊</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathfrak{G}\{\mathcal{B}\}
  </annotation>
 </semantics>
</math>

 is defined similarly to the unlabelled case:</p>

<p>

<math display="block" id="Analytic_combinatorics:149">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔊</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mo>+</mo>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      <mo>⋆</mo>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      <mo>⋆</mo>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      <mo>⋆</mo>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝔊</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
    <apply>
     <plus></plus>
     <ci>ℰ</ci>
     <ci>ℬ</ci>
     <apply>
      <ci>normal-⋆</ci>
      <ci>ℬ</ci>
      <ci>ℬ</ci>
     </apply>
     <apply>
      <ci>normal-⋆</ci>
      <ci>ℬ</ci>
      <ci>ℬ</ci>
      <ci>ℬ</ci>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{G}\{\mathcal{B}\}=\mathcal{E}+\mathcal{B}+(\mathcal{B}\star\mathcal{%
B})+(\mathcal{B}\star\mathcal{B}\star\mathcal{B})+\cdots
  </annotation>
 </semantics>
</math>

 and again, as above,</p>

<p>

<math display="block" id="Analytic_combinatorics:150">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)=\frac{1}{1-B(z)}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="set-1">Set</h3>

<p>In labelled structures, a set of 

<math display="inline" id="Analytic_combinatorics:151">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 elements corresponds to exactly 

<math display="inline" id="Analytic_combinatorics:152">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <factorial></factorial>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k!
  </annotation>
 </semantics>
</math>

 sequences. This is different from the unlabelled case, where some of the permutations may coincide. Thus for 

<math display="inline" id="Analytic_combinatorics:153">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝔓</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>𝔓</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathfrak{P}\{\mathcal{B}\}
  </annotation>
 </semantics>
</math>

, we have</p>

<p>

<math display="block" id="Analytic_combinatorics:154">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mfrac>
     <mrow>
      <mi>B</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>k</mi>
      </msup>
     </mrow>
     <mrow>
      <mi>k</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>B</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <exp></exp>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)=\sum_{k=0}^{\infty}\frac{B(z)^{k}}{k!}=\exp(B(z))
  </annotation>
 </semantics>
</math>

</p>
<h3 id="cycle">Cycle</h3>

<p>Cycles are also easier than in the unlabelled case. A cycle of length 

<math display="inline" id="Analytic_combinatorics:155">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 corresponds to 

<math display="inline" id="Analytic_combinatorics:156">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 distinct sequences. Thus for 

<math display="inline" id="Analytic_combinatorics:157">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mi>ℭ</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>ℭ</ci>
     <set>
      <ci>ℬ</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\mathfrak{C}\{\mathcal{B}\}
  </annotation>
 </semantics>
</math>

, we have</p>

<p>

<math display="block" id="Analytic_combinatorics:158">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mfrac>
      <mrow>
       <mi>B</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>k</mi>
       </msup>
      </mrow>
      <mi>k</mi>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>B</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>B</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ln></ln>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>z</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(z)=\sum_{k=0}^{\infty}\frac{B(z)^{k}}{k}=\ln\left(\frac{1}{1-B(z)}\right).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="boxed-product">Boxed product</h3>

<p>In labelled structures, the min-boxed product 

<math display="inline" id="Analytic_combinatorics:159">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mrow>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mi mathvariant="normal">□</mi>
    </msup>
    <mo>⋆</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒜</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋆</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℬ</ci>
      <ci>normal-□</ci>
     </apply>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}_{min}=\mathcal{B}^{\square}\star\mathcal{C}
  </annotation>
 </semantics>
</math>

 is a variation of the original product which requires the element of 

<math display="inline" id="Analytic_combinatorics:160">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 in the product with the minimal label. Similarly, we can also define a max-boxed product, denoted by 

<math display="inline" id="Analytic_combinatorics:161">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mrow>
     <mi>m</mi>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mi mathvariant="normal">■</mi>
    </msup>
    <mo>⋆</mo>
    <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒜</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋆</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℬ</ci>
      <ci>normal-■</ci>
     </apply>
     <ci>𝒞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}_{max}=\mathcal{B}^{\blacksquare}\star\mathcal{C}
  </annotation>
 </semantics>
</math>

, by the same manner. Then we have,</p>

<p>

<math display="block" id="Analytic_combinatorics:162">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>m</mi>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mi>z</mi>
     </msubsup>
     <mrow>
      <msup>
       <mi>B</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <int></int>
        <ci>z</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>t</ci>
       <ci>C</ci>
       <ci>t</ci>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{min}(z)=A_{max}(z)=\int^{z}_{0}B^{\prime}(t)C(t)dt.
  </annotation>
 </semantics>
</math>

 or equivalently,</p>

<p>

<math display="block" id="Analytic_combinatorics:163">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>A</mi>
      <mrow>
       <mi>m</mi>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
      <mo>′</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>A</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
      <mo>′</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>B</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
      <ci>C</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{min}^{\prime}(t)=A_{max}^{\prime}(t)=B^{\prime}(t)C(t).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="example">Example</h3>

<p>An increasing Cayley tree is a labelled non-plane and rooted tree whose labels along any branch stemming from the root form an increasing sequence. Then, let 

<math display="inline" id="Analytic_combinatorics:164">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℒ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℒ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}
  </annotation>
 </semantics>
</math>

 be the class of such trees. The recursive specification is now 

<math display="inline" id="Analytic_combinatorics:165">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi class="ltx_font_mathcaligraphic">𝒵</mi>
       <mi mathvariant="normal">□</mi>
      </msup>
      <mo>⋆</mo>
      <mi>S</mi>
     </mrow>
     <mi>E</mi>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi class="ltx_font_mathcaligraphic">ℒ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℒ</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋆</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝒵</ci>
       <ci>normal-□</ci>
      </apply>
      <ci>S</ci>
     </apply>
     <ci>E</ci>
     <ci>T</ci>
     <ci>ℒ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}=\mathcal{Z}^{\square}\star SET(\mathcal{L}).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="other-elementary-constructions-1">Other elementary constructions</h3>

<p>The operators</p>

<p>

<math display="block" id="Analytic_combinatorics:166">
 <semantics>
  <mrow>
   <msub>
    <mi>ℭ</mi>
    <mo>even</mo>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>ℭ</mi>
    <mo>odd</mo>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝔓</mi>
    <mo>even</mo>
   </msub>
   <mo>,</mo>
   <mrow>
    <mtext>and</mtext>
    <msub>
     <mi>𝔓</mi>
     <mo>odd</mo>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℭ</ci>
     <ci>even</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℭ</ci>
     <ci>odd</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔓</ci>
     <ci>even</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>and</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔓</ci>
      <ci>odd</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{C}_{\operatorname{even}},\mathfrak{C}_{\operatorname{odd}},\mathfrak%
{P}_{\operatorname{even}},\mbox{ and }\mathfrak{P}_{\operatorname{odd}}
  </annotation>
 </semantics>
</math>

</p>

<p>represent cycles of even and odd length, and sets of even and odd cardinality.</p>
<h3 id="example-1">Example</h3>

<p><a href="Stirling_numbers_of_the_second_kind" title="wikilink">Stirling numbers of the second kind</a> may be derived and analyzed using the structural decomposition</p>

<p>

<math display="block" id="Analytic_combinatorics:167">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔓</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>𝔓</mi>
       <mrow>
        <mi></mi>
        <mo>≥</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi class="ltx_font_mathcaligraphic">𝒵</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔓</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔓</ci>
      <apply>
       <geq></geq>
       <csymbol cd="latexml">absent</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>𝒵</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{P}(\mathfrak{P}_{\geq 1}(\mathcal{Z})).
  </annotation>
 </semantics>
</math>

</p>

<p>The decomposition</p>

<p>

<math display="block" id="Analytic_combinatorics:168">
 <semantics>
  <mrow>
   <mi>𝔓</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ℭ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi class="ltx_font_mathcaligraphic">𝒵</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔓</ci>
    <apply>
     <times></times>
     <ci>ℭ</ci>
     <ci>𝒵</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{P}(\mathfrak{C}(\mathcal{Z}))
  </annotation>
 </semantics>
</math>

</p>

<p>is used to study unsigned <a href="Stirling_numbers_of_the_first_kind" title="wikilink">Stirling numbers of the first kind</a>, and in the derivation of the <a href="Random_permutation_statistics" title="wikilink">statistics of random permutations</a>. A detailed examination of the <a href="exponential_generating_function" title="wikilink">exponential generating functions</a> associated to Stirling numbers within symbolic combinatorics may be found on the page on <a href="Stirling_numbers_and_exponential_generating_functions_in_symbolic_combinatorics" title="wikilink">Stirling numbers and exponential generating functions in symbolic combinatorics</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Combinatorial_species" title="wikilink">Combinatorial species</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>François Bergeron, Gilbert Labelle, Pierre Leroux, <em>Théorie des espèces et combinatoire des structures arborescentes</em>, LaCIM, Montréal (1994). English version: <em>Combinatorial Species and Tree-like Structures</em>, Cambridge University Press (1998).</li>
<li>Philippe Flajolet and Robert Sedgewick, <em>Analytic Combinatorics</em>, Cambridge University Press (2009). (available online: <a class="uri" href="http://algo.inria.fr/flajolet/Publications/book.pdf">http://algo.inria.fr/flajolet/Publications/book.pdf</a>)</li>
<li>Micha Hofri, <em>Analysis of Algorithms: Computational Methods and Mathematical Tools</em>, Oxford University Press (1995).</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a></p>
</body>
</html>
