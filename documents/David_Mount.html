<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1331">David Mount</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>David Mount</h1>
<hr/>

<p><strong>David Mount</strong> is a <a class="uri" href="professor" title="wikilink">professor</a> at <a href="The_University_of_Maryland" title="wikilink">The University of Maryland</a> (College Park Campus) whose research is in <a href="Computational_Geometry" title="wikilink">Computational Geometry</a>.</p>
<h2 id="biography">Biography</h2>

<p>Mount received a B.S. in Computer Science at <a href="Purdue_University" title="wikilink">Purdue University</a> in 1977 and received his Ph.D. in Computer Science at Purdue University in 1983 under the advisement of Christoph Hoffmann.</p>

<p>He began teaching at the <a href="University_of_Maryland" title="wikilink">University of Maryland</a> in 1984 and is <a class="uri" href="Professor" title="wikilink">Professor</a> in the department of Computer Science there.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>As a teacher, he has won the University of Maryland, College of Computer Mathematical and Physical Sciences Dean's Award for Excellence in Teaching in 2005 and 1997 as well as other teaching awards including the Hong Kong Science and Technology, School of Engineering Award for Teaching Excellence Appreciation in 2001.</p>
<h2 id="research">Research</h2>

<p>Mounts's main area of research is <a href="Computational_Geometry" title="wikilink">Computational Geometry</a>, which is the branch of <a class="uri" href="algorithms" title="wikilink">algorithms</a> devoted to solving problems of a geometric nature. This field includes problems from classic <a class="uri" href="geometry" title="wikilink">geometry</a>, like the <a href="closest_pair_of_points_problem" title="wikilink">closest pair of points problem</a>, as well as more recent applied problems, such as computer representation and modeling of curves and surfaces. In particular, Mount has worked on the <a href="k-means_clustering" title="wikilink">k-means clustering</a> problem, <a href="nearest_neighbor_search" title="wikilink">nearest neighbor search</a>, and <a href="point_location" title="wikilink">point location</a>.</p>

<p>Mount has worked on developing practical algorithms for k-means clustering, a problem known to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>. The most common algorithm used is <a href="Lloyd's_algorithm" title="wikilink">Lloyd's algorithm</a>, which is heuristic in nature but performs well in practice. He and others later showed <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> how <a href="kd-tree" title="wikilink">kd-trees</a> could be used to speed up Lloyd's algorithm. They have implemented this algorithm, along with some additional improvements, in the software library <em>Kmeans</em>.</p>

<p>Mount has worked on the nearest neighbor and approximate nearest neighbor search problems. By allowing the algorithm to return an approximate solution to the nearest neighbor query, a significant speedup in space and time complexity can be obtained. One class of approximate algorithms takes as input the error distance, 

<math display="inline" id="David_Mount:0">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

, and forms a data structure that can be stored efficiently (low space complexity) and that returns the 

<math display="inline" id="David_Mount:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1+\epsilon)
  </annotation>
 </semantics>
</math>

-approximate nearest neighbor quickly (low time complexity). In co-authored work with Arya, <a href="Nathan_Netanyahu" title="wikilink">Netanyahu</a>, Silverman, and Wu,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Mount showed that the approximate nearest neighbor problem could be solved efficiently in spaces of low dimension. The data structure described in that paper formed the basis of the ANN library, which is a popular open-source library for approximate nearest neighbor searching.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In subsequent work, he investigated the <a href="Analysis_of_algorithms" title="wikilink">computational complexity</a> of approximate nearest neighbor searching. Together with co-authors Arya and Malamatos, he provided efficient <a href="space-time_tradeoff" title="wikilink">space-time tradeoffs</a> for approximate nearest neighbor searching,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> based on a data structure called the <a href="Approximate_Voronoi_Diagram" title="wikilink">AVD</a> (or approximate <a href="Voronoi_diagram" title="wikilink">Voronoi diagram</a>).</p>

<p>Mount has also worked on point location, which involves preprocessing a <a href="planar_subdivision" title="wikilink">planar polygonal subdivision</a> S of size 

<math display="inline" id="David_Mount:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 to determine the cell of a subdivision that a query point is in. In,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> the paper gives an 

<math display="inline" id="David_Mount:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

 time to construct a data structure of 

<math display="inline" id="David_Mount:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 space that when asked what cell a query point lies in, takes expected time 

<math display="inline" id="David_Mount:5">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msqrt>
       <mi>H</mi>
      </msqrt>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>H</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <plus></plus>
      <apply>
       <root></root>
       <ci>H</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H+O(\sqrt{H}+1)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="David_Mount:6">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="entropy" title="wikilink">entropy</a> of the probability distribution of which cells the query points lie in.</p>

<p>In addition to the design and <a href="analysis_of_algorithms" title="wikilink">analysis of algorithms</a> in computational geometry, Mount has worked on the implementation of efficient algorithms in software libraries such as:</p>
<ul>
<li>ANN - approximate nearest neighbor searching</li>
<li>ISODATA - efficient implementation of a popular clustering algorithm</li>
<li>KMeans - k-means clustering</li>
</ul>
<h2 id="most-cited-works">Most cited works</h2>

<p>As of December 8, 2009, here is a list of his most cited works (according to <a href="Google_Scholar" title="wikilink">Google Scholar</a>) and their main contributions, listed in decreasing order of citations:</p>
<ol>
<li><em>An Optimal Algorithm for Approximate Nearest Neighbor Searching in Fixed Dimensions</em><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> - In this paper they give a n 

<math display="inline" id="David_Mount:7">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>d</mi>
       <mo>,</mo>
       <mi>ϵ</mi>
      </mrow>
     </msub>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <list>
       <ci>d</ci>
       <ci>ϵ</ci>
      </list>
     </apply>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(c_{d,\epsilon}log(n))
  </annotation>
 </semantics>
</math>

 algorithm (where 

<math display="inline" id="David_Mount:8">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>d</mi>
    <mo>,</mo>
    <mi>ϵ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <list>
     <ci>d</ci>
     <ci>ϵ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{d,\epsilon}
  </annotation>
 </semantics>
</math>

 depends on both the number of dimensions 

<math display="inline" id="David_Mount:9">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 and the approximate error 

<math display="inline" id="David_Mount:10">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

) to find a neighbor that is at most a factor 

<math display="inline" id="David_Mount:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1+\epsilon)
  </annotation>
 </semantics>
</math>

 distance from the nearest neighbor.</li>
<li><em>An Efficient k-Means Clustering Algorithm: Analysis and Implementation</em><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> - In this paper they provide a simpler and more efficient implementation of <a href="Lloyd's_Algorithm" title="wikilink">Lloyd's Algorithm</a>, which is used in <a class="uri" href="k-means" title="wikilink">k-means</a> clustering, The algorithm is called the filtering algorithm.</li>
<li><em>The Discrete Geodesic Problem</em><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> - In this paper they compute the shortest path from a source to a destination constrained to having to travel on the surface of a given (possibly <a class="uri" href="nonconvex" title="wikilink">nonconvex</a>) <a class="uri" href="polyhedron" title="wikilink">polyhedron</a>. Their algorithm takes 

<math display="inline" id="David_Mount:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2}log(n))
  </annotation>
 </semantics>
</math>

 time to find the first shortest path to the first destination and the shortest path to any additional destination (from the same source) can be computed in 

<math display="inline" id="David_Mount:13">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(logn)
  </annotation>
 </semantics>
</math>

 time. Here, 

<math display="inline" id="David_Mount:14">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of vertices.</li>
</ol>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://cpp.datastructures.net/">Data Structures and Algorithms in C++</a></li>
</ul>

<p>"</p>

<p><a href="Category:Year_of_birth_missing_(living_people)" title="wikilink">Category:Year of birth missing (living people)</a> <a href="Category:Living_people" title="wikilink">Category:Living people</a> <a href="Category:American_computer_scientists" title="wikilink">Category:American computer scientists</a> <a href="Category:Researchers_in_geometric_algorithms" title="wikilink">Category:Researchers in geometric algorithms</a> <a href="Category:Purdue_University_alumni" title="wikilink">Category:Purdue University alumni</a> <a href="Category:University_of_Maryland,_College_Park_faculty" title="wikilink">Category:University of Maryland, College Park faculty</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">D. Mount. <a href="http://www.cs.umd.edu/~mount/Vita/CSvita.pdf"><em>Curriculum Vitae</em></a><a href="#fnref1">↩</a></li>
<li id="fn2">T. Kanungo, D. M. Mount, <a href="Nathan_Netanyahu" title="wikilink">N. S. Netanyahu</a>, C. D. Piatko, R. Silverman and A. Y. Wu. <a href="http://www.cs.umd.edu/~mount/Papers/pami02.pdf"><em>An Efficient k-Means Clustering Algorithm: Analysis and Implementation</em></a>. IEEE Trans. Pattern Analysis and Machine Intelligence 24(7):881-892, 2002.<a href="#fnref2">↩</a></li>
<li id="fn3">S. Arya, D. M. Mount, <a href="Nathan_Netanyahu" title="wikilink">N. S. Netanyahu</a>, R. Silverman and A. Wu, <a href="http://www.cs.umd.edu/~mount/Papers/dist.pdf">'"n Optimal Algorithm for Approximate Nearest Neighbor Searching in Fixed Dimensions"</a>, <em>Journal of the ACM</em>, 45(6):891-923, 1998.<a href="#fnref3">↩</a></li>
<li id="fn4">D. M. Mount and S. Arya, <a href="http://www.cs.umd.edu/~mount/ANN"><em>ANN: A Library for Approximate Nearest Neighbor Searching</em></a><a href="#fnref4">↩</a></li>
<li id="fn5">S. Arya, S., T. Malamatos, and D. M. Mount. <em>Space-time Tradeoffs for Approximate Nearest Neighbor Searching.</em> Journal of the ACM, 57(1): 1-54, 2009<a href="#fnref5">↩</a></li>
<li id="fn6">S. Arya, T. Malamatos, D. M. Mount and K. C. Wong. <a href="http://www.cs.umd.edu/~mount/Papers/ptloc-opt.pdf">Optimal Expected-Case Planar Point Location</a>. Siam Journal on Computing, 37(2):584-610, 2007.<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9">J. S. B. Mitchell, D. M. Mount and C. H. Papadimitriou. <a href="http://www.cs.umd.edu/~mount/Papers/mmp-sicomp-87.pdf">The Discrete Geodesic Problem</a>. Siam Journal of Computing, 16(4):647-668, 1987<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
