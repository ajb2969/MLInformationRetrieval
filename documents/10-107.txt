   Pollard's kangaroo algorithm      Pollard's kangaroo algorithm   In computational number theory and computational algebra , Pollard's kangaroo algorithm (aka Pollard's lambda algorithm , see Naming below) is an algorithm for solving the discrete logarithm problem. The algorithm was introduced in 1978 by the number theorist J. M. Pollard , in the same paper 1 as his better-known ρ algorithm for solving the same problem. Although Pollard described the application of his algorithm to the discrete logarithm problem in the multiplicative group of units modulo a prime p , it is in fact a generic discrete logarithm algorithm—it will work in any finite cyclic group.  The algorithm  Suppose   G   G   G   is a finite cyclic group of order   n   n   n   which is generated by the element   α   α   \alpha   , and we seek to find the discrete logarithm   x   x   x   of the element   β   β   \beta   to the base   α   α   \alpha   . In other words, we seek    x  ∈   Z  n       x   subscript  Z  n     x\in Z_{n}   such that     α  x   =  β       superscript  α  x   β    \alpha^{x}=\beta   . The lambda algorithm allows us to search for   x   x   x   in some subset     {  a  ,  …  ,  b  }   ⊂   Z  n        a  normal-…  b    subscript  Z  n     \{a,\ldots,b\}\subset Z_{n}   . We may search the entire range of possible logarithms by setting    a  =  0      a  0    a=0   and    b  =   n  -  1       b    n  1     b=n-1   , although in this case Pollard's rho algorithm is more efficient. We proceed as follows:  1. Choose a set   S   S   S   of integers and define a pseudorandom map    f  :   G  →  S      normal-:  f   normal-→  G  S     f:G\rightarrow S   .  2. Choose an integer   N   N   N   and compute a sequence of group elements    {   x  0   ,   x  1   ,  …  ,   x  N   }      subscript  x  0    subscript  x  1   normal-…   subscript  x  N     \{x_{0},x_{1},\ldots,x_{N}\}   according to:        x  0   =    α  b         subscript  x  0    superscript  α  b     x_{0}=\alpha^{b}\,           x   i  +  1    =    x  i    α   f   (   x  i   )     for  i   =  0   ,   1  ,  …  ,   N  -  1       formulae-sequence       subscript  x    i  1       subscript  x  i    superscript  α    f   subscript  x  i     for  i        0     1  normal-…    N  1      x_{i+1}=x_{i}\alpha^{f(x_{i})}\mbox{ for }i=0,1,\ldots,N-1      3. Compute      d  =    ∑   i  =  0    N  -  1     f   (   x  i   )         d    superscript   subscript     i  0      N  1      f   subscript  x  i       d=\sum_{i=0}^{N-1}f(x_{i})   . Observe that:        x  N   =    x  0    α  d    =    α   b  +  d      .         subscript  x  N      subscript  x  0    superscript  α  d          superscript  α    b  d       x_{N}=x_{0}\alpha^{d}=\alpha^{b+d}\,.   4. Begin computing a second sequence of group elements    {   y  0   ,   y  1   ,  …  }      subscript  y  0    subscript  y  1   normal-…    \{y_{0},y_{1},\ldots\}   according to:        y  0   =   β        subscript  y  0   β    y_{0}=\beta\,           y   i  +  1    =    y  i    α   f   (   y  i   )     for  i   =  0   ,   1  ,  …  ,   N  -  1       formulae-sequence       subscript  y    i  1       subscript  y  i    superscript  α    f   subscript  y  i     for  i        0     1  normal-…    N  1      y_{i+1}=y_{i}\alpha^{f(y_{i})}\mbox{ for }i=0,1,\ldots,N-1      and a corresponding sequence of integers    {   d  0   ,   d  1   ,  …  }      subscript  d  0    subscript  d  1   normal-…    \{d_{0},d_{1},\ldots\}   according to:       d  n   =    ∑   i  =  0    n  -  1     f   (   y  i   )          subscript  d  n     superscript   subscript     i  0      n  1      f   subscript  y  i       d_{n}=\sum_{i=0}^{n-1}f(y_{i})   . Observe that:        y  i   =    y  0    α   d  i     =   β   α   d  i    for  i   =  0   ,   1  ,  …  ,   N  -  1       formulae-sequence       subscript  y  i      subscript  y  0    superscript  α   subscript  d  i            β   superscript  α   subscript  d  i    for  i        0     1  normal-…    N  1      y_{i}=y_{0}\alpha^{d_{i}}=\beta\alpha^{d_{i}}\mbox{ for }i=0,1,\ldots,N-1   5. Stop computing terms of    {   y  i   }      subscript  y  i     \{y_{i}\}   and    {   d  i   }      subscript  d  i     \{d_{i}\}   when either of the following conditions are met:   A)     y  j   =   x  N        subscript  y  j    subscript  x  N     y_{j}=x_{N}   for some   j   j   j   . If the sequences    {   x  i   }      subscript  x  i     \{x_{i}\}   and    {   y  j   }      subscript  y  j     \{y_{j}\}   "collide" in this manner, then we have: : x_N = y_j \Rightarrow \alpha^{b+d} = \beta\alpha^{d_j} \Rightarrow \beta = \alpha^{b+d-d_j} \pmod{n} \Rightarrow    x \equiv b+d-d_j \pmod{n}   and so we are done.    B)     d  i   >    b  -  a   +  d        subscript  d  i       b  a   d     d_{i}>b-a+d   . If this occurs, then the algorithm has failed to find   x   x   x   . Subsequent attempts can be made by changing the choice of   S   S   S   and/or   f   f   f   .   Complexity  Pollard gives the time complexity of the algorithm as    O   (    b  -  a    )       O      b  a      {\scriptstyle O(\sqrt{b-a})}   , based on a probabilistic argument which follows from the assumption that f acts pseudorandomly. Note that when the size of the set { a , …, b } to be searched is measured in bits , as is normal in complexity theory , the set has size log( b − a ), and so the algorithm's complexity is     O   (    b  -  a    )    =   O   (   2     1  2     log   (   b  -  a   )      )          O      b  a       O   superscript  2      1  2       b  a         {\scriptstyle O(\sqrt{b-a})=O(2^{\frac{1}{2}\log(b-a)})}   , which is exponential in the problem size. For this reason, Pollard's lambda algorithm is considered an exponential time algorithm. For an example of a subexponential time discrete logarithm algorithm, see the index calculus algorithm .  Naming  The algorithm is well known by two names.  The first is "Pollard's kangaroo algorithm". This name is a reference to an analogy used in the paper presenting the algorithm, where the algorithm is explained in terms of using a tame  kangaroo to trap a wild kangaroo. Pollard has explained 2 that this analogy was inspired by a "fascinating" article published in the same issue of Scientific American as an exposition of the RSA  public key cryptosystem . The article 3 described an experiment in which a kangaroo's "energetic cost of locomotion, measured in terms of oxygen consumption at various speeds, was determined by placing kangaroos on a treadmill ".  The second is "Pollard's lambda algorithm". Much like the name of another of Pollard's discrete logarithm algorithms, Pollard's rho algorithm , this name refers to the similarity between a visualisation of the algorithm and the Greek letter  lambda (   λ   λ   \lambda   ). The shorter stroke of the letter lambda corresponds to the sequence    {   x  i   }      subscript  x  i     \{x_{i}\}   , since it starts from the position b to the right of x. Accordingly, the longer stroke corresponds to the sequence    {   y  i   }      subscript  y  i     \{y_{i}\}   , which "collides with" the first sequence (just like the strokes of a lambda intersect) and then follows it subsequently.  Pollard has expressed a preference for the name "kangaroo algorithm", 4 as this avoids confusion with some parallel versions of his rho algorithm, which have also been called "lambda algorithms".  See also   Rainbow table   References    "  Category:Number theoretic algorithms  Category:Computer algebra  Category:Logarithms     J. Pollard, Monte Carlo methods for index computation mod p , Mathematics of Computation, Volume 32, 1978 ↩  J. M. Pollard, Kangaroos, Monopoly and Discrete Logarithms , Journal of Cryptology, Volume 13, pp 437-447, 2000 ↩  T. J. Dawson, Kangaroos , Scientific American, August 1977, pp. 78-89 ↩  http://sites.google.com/site/jmptidcott2/ ↩     