   Total least squares      Total least squares  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     (Figure)  200xp| The bivariate (Deming regression) case of Total Least Squares. The red lines show the error in both x and y . This is different from the traditional least squares method which measures error parallel to the y axis. The case shown, with deviations measured perpendicularly, arises when x and y have equal variances.   Total least squares also known as (in a special case) orthogonal regression , is a type of errors-in-variables regression , a least squares data modeling technique in which observational errors on both dependent and independent variables are taken into account. It is a generalization of Deming regression , and can be applied to both linear and non-linear models.  The total least squares approximation of the data is generically equivalent to the best, in the Frobenius norm , low-rank approximation of the data matrix. 1  Linear model  Background  In the least squares method of data modeling, the objective function , S ,       S  =    ğ«  ğ“   ğ–ğ«    ,      S     superscript  ğ«  ğ“   ğ–ğ«     S=\mathbf{r^{T}Wr},   is minimized, where r is the vector of residuals and W is a weighting matrix. In linear least squares the model contains equations which are linear in the parameters appearing in the parameter vector   ğœ·   ğœ·   \boldsymbol{\beta}   , so the residuals are given by       ğ«  =   ğ²  -   ğ—  ğœ·     .      ğ«    ğ²    ğ—  ğœ·      \mathbf{r=y-X\boldsymbol{\beta}}.   There are m observations in y and n parameters in Î² with m > n . X is a m Ã— n matrix whose elements are either constants or functions of the independent variables, x . The weight matrix W is, ideally, the inverse of the variance-covariance matrix     ğŒ  y     subscript  ğŒ  y    \mathbf{M}_{y}   of the observations y . The independent variables are assumed to be error-free. The parameter estimates are found by setting the gradient equations to zero, which results in the normal equations 2        ğ—  ğ“   ğ–ğ—  ğœ·   =    ğ—  ğ“   ğ–ğ²          superscript  ğ—  ğ“   ğ–ğ—  ğœ·      superscript  ğ—  ğ“   ğ–ğ²     \mathbf{X^{T}WX\boldsymbol{\beta}=X^{T}Wy}     Allowing observation errors in all variables  Now, suppose that both x and y are observed subject to error, with variance-covariance matrices    ğŒ  x     subscript  ğŒ  x    \mathbf{M}_{x}   and    ğŒ  y     subscript  ğŒ  y    \mathbf{M}_{y}   respectively. In this case the objective function can be written as      S  =     ğ«  ğ±  ğ“    ğŒ  ğ±   -  ğŸ     ğ«  ğ±    +    ğ«  ğ²  ğ“    ğŒ  ğ²   -  ğŸ     ğ«  ğ²         S       superscript   subscript  ğ«  ğ±   ğ“    superscript   subscript  ğŒ  ğ±     1     subscript  ğ«  ğ±       superscript   subscript  ğ«  ğ²   ğ“    superscript   subscript  ğŒ  ğ²     1     subscript  ğ«  ğ²       S=\mathbf{r_{x}^{T}M_{x}^{-1}r_{x}+r_{y}^{T}M_{y}^{-1}r_{y}}   where     ğ«  x      subscript  ğ«  x    \mathbf{r}_{x}\,   and     ğ«  y      subscript  ğ«  y    \mathbf{r}_{y}\,   are the residuals in x and y respectively. Clearly these residuals cannot be independent of each other, but they must be constrained by some kind of relationship. Writing the model function as    ğŸ   (   ğ«  ğ±   ,   ğ«  ğ²   ,  ğœ·  )       ğŸ    subscript  ğ«  ğ±    subscript  ğ«  ğ²   ğœ·     \mathbf{f(r_{x},r_{y},\boldsymbol{\beta})}   , the constraints are expressed by m  condition equations . 3      ğ…  =    ğš«  ğ²   -     âˆ‚  ğŸ    âˆ‚   ğ«  ğ±      ğ«  ğ±    -     âˆ‚  ğŸ    âˆ‚   ğ«  ğ²      ğ«  ğ²    -   ğ—  ğš«  ğœ·    =  ğŸ        ğ…      ğš«  ğ²         ğŸ      subscript  ğ«  ğ±      subscript  ğ«  ğ±          ğŸ      subscript  ğ«  ğ²      subscript  ğ«  ğ²      ğ—  ğš«  ğœ·         0     \mathbf{F=\Delta y-\frac{\partial f}{\partial r_{x}}r_{x}-\frac{\partial f}{%
 \partial r_{y}}r_{y}-X\Delta\boldsymbol{\beta}=0}   Thus, the problem is to minimize the objective function subject to the m constraints. It is solved by the use of Lagrange multipliers . After some algebraic manipulations, 4 the result is obtained.        ğ—  ğ“    ğŒ   -  ğŸ    ğ—  ğš«  ğœ·   =    ğ—  ğ“    ğŒ   -  ğŸ    ğš«  ğ²          superscript  ğ—  ğ“    superscript  ğŒ    1    ğ—  ğš«  ğœ·      superscript  ğ—  ğ“    superscript  ğŒ    1    ğš«  ğ²     \mathbf{X^{T}M^{-1}X\Delta\boldsymbol{\beta}=X^{T}M^{-1}\Delta y}   , or alternatively      ğ—  ğ“    ğŒ   -  ğŸ    ğ—  ğœ·   =    ğ—  ğ“    ğŒ   -  ğŸ    ğ²          superscript  ğ—  ğ“    superscript  ğŒ    1    ğ—  ğœ·      superscript  ğ—  ğ“    superscript  ğŒ    1    ğ²     \mathbf{X^{T}M^{-1}X\boldsymbol{\beta}=X^{T}M^{-1}y}   Where M is the variance-covariance matrix relative to both independent and dependent variables.       ğŒ  =     ğŠ  ğ±    ğŒ  ğ±    ğŠ  ğ±  ğ“    +    ğŠ  ğ²    ğŒ  ğ²    ğŠ  ğ²  ğ“      ;     ğŠ  ğ±   =   -    âˆ‚  ğŸ    âˆ‚   ğ«  ğ±       ,    ğŠ  ğ²   =   -    âˆ‚  ğŸ    âˆ‚   ğ«  ğ²           formulae-sequence    ğŒ       subscript  ğŠ  ğ±    subscript  ğŒ  ğ±    superscript   subscript  ğŠ  ğ±   ğ“       subscript  ğŠ  ğ²    subscript  ğŒ  ğ²    superscript   subscript  ğŠ  ğ²   ğ“       formulae-sequence     subscript  ğŠ  ğ±         ğŸ      subscript  ğ«  ğ±          subscript  ğŠ  ğ²         ğŸ      subscript  ğ«  ğ²          \mathbf{M=K_{x}M_{x}K_{x}^{T}+K_{y}M_{y}K_{y}^{T};\ K_{x}=-\frac{\partial f}{%
 \partial r_{x}},\ K_{y}=-\frac{\partial f}{\partial r_{y}}}     Example  In practice these equations are easy to use. When the data errors are uncorrelated, all matrices M and W are diagonal. Then, take the example of straight line fitting.       f   (   x  i   ,  Î²  )    =   Î±  +   Î²    x  i            f    subscript  x  i   Î²      Î±    Î²   subscript  x  i       f(x_{i},\beta)=\alpha+\beta x_{i}\!   It is easy to show that, in this case       M   i  i    =    Ïƒ   y  ,  i   2   +    Î²  2    Ïƒ   x  ,  i   2          subscript  M    i  i       subscript   superscript  Ïƒ  2    y  i       superscript  Î²  2    subscript   superscript  Ïƒ  2    x  i        M_{ii}=\sigma^{2}_{y,i}+\beta^{2}\sigma^{2}_{x,i}   showing how the variance at the i th point is determined by the variances of both independent and dependent variables and by the model being used to fit the data. The expression may be generalized by noting that the parameter   Î²   Î²   \beta   is the slope of the line.       M   i  i    =    Ïƒ   y  ,  i   2   +     (    d  y    d  x    )   i  2    Ïƒ   x  ,  i   2          subscript  M    i  i       subscript   superscript  Ïƒ  2    y  i       subscript   superscript      d  y     d  x    2   i    subscript   superscript  Ïƒ  2    x  i        M_{ii}=\sigma^{2}_{y,i}+\left(\frac{dy}{dx}\right)^{2}_{i}\sigma^{2}_{x,i}     An expression of this type is used in fitting pH titration data where a small error on x translates to a large error on y when the slope is large.  Algebraic point of view  First of all it is necessary to note that the TLS problem does not have a solution in general, which was already shown in 1980. 5 The following considers the simple case where a unique solution exists without making any particular assumptions.  The computation of the TLS using singular value decomposition is described in standard texts. 6 We can solve the equation       X  B   â‰ˆ  Y        X  B   Y    XB\approx Y   for B where X is m -by- n and Y is m -by- k . 7  That is, we seek to find B that minimizes error matrices E and F for X and Y respectively. That is,         argmin   E  ,  F      âˆ¥   [    E   F   ]   âˆ¥   F    ,    (   X  +  E   )   B    =   Y  +  F           subscript  argmin   E  F     subscript   norm   delimited-[]    E  F     F        X  E   B      Y  F     \mathrm{argmin}_{E,F}\|[E\;F]\|_{F},\qquad(X+E)B=Y+F   where    [    E   F   ]     delimited-[]    E  F     [E\;F]   is the augmented matrix with E and F side by side and    âˆ¥  â‹…   âˆ¥  F      fragments  parallel-to  normal-â‹…   subscript  parallel-to  F     \|\cdot\|_{F}   is the Frobenius norm , the square root of the sum of the squares of all entries in a matrix and so equivalently the square root of the sum of squares of the lengths of the rows or columns of the matrix.  This can be rewritten as        [    (   X  +  E   )    (   Y  +  F   )    ]    [     B       -   I  k       ]    =  0         delimited-[]      X  E     Y  F       B       subscript  I  k       0    [(X+E)\;(Y+F)]\begin{bmatrix}B\\
 -I_{k}\end{bmatrix}=0   . where    I  k     subscript  I  k    I_{k}   is the    k  Ã—  k      k  k    k\times k   identity matrix. The goal is then to find    [    E   F   ]     delimited-[]    E  F     [E\;F]   that reduces the rank of    [    X   Y   ]     delimited-[]    X  Y     [X\;Y]   by k . Define     [  U  ]    [  Î£  ]    [  V  ]   *     fragments   fragments  normal-[  U  normal-]    fragments  normal-[  Î£  normal-]    fragments  normal-[  V  normal-]      [U][\Sigma][V]*   to be the singular value decomposition of the augmented matrix    [    X   Y   ]     delimited-[]    X  Y     [X\;Y]   .       [    X   Y   ]   =    [     U  X     U  Y    ]    [      Î£  X     0      0     Î£  Y      ]     [      V   X  X       V   X  Y         V   Y  X       V   Y  Y       ]   *    =    [     U  X     U  Y    ]    [      Î£  X     0      0     Î£  Y      ]    [      V   X  X   *      V   Y  X   *        V   X  Y   *      V   Y  Y   *      ]           delimited-[]    X  Y       delimited-[]     subscript  U  X    subscript  U  Y        subscript  normal-Î£  X   0    0   subscript  normal-Î£  Y      superscript     subscript  V    X  X     subscript  V    X  Y       subscript  V    Y  X     subscript  V    Y  Y                 delimited-[]     subscript  U  X    subscript  U  Y        subscript  normal-Î£  X   0    0   subscript  normal-Î£  Y        superscript   subscript  V    X  X       superscript   subscript  V    Y  X         superscript   subscript  V    X  Y       superscript   subscript  V    Y  Y            [X\;Y]=[U_{X}\;U_{Y}]\begin{bmatrix}\Sigma_{X}&0\\
 0&\Sigma_{Y}\end{bmatrix}\begin{bmatrix}V_{XX}&V_{XY}\\
 V_{YX}&V_{YY}\end{bmatrix}^{*}=[U_{X}\;U_{Y}]\begin{bmatrix}\Sigma_{X}&0\\
 0&\Sigma_{Y}\end{bmatrix}\begin{bmatrix}V_{XX}^{*}&V_{YX}^{*}\\
 V_{XY}^{*}&V_{YY}^{*}\end{bmatrix}   where V is partitioned into blocks corresponding to the shape of X and Y .  Using the Eckart-Young theorem, the approximation minimising the norm of the error is such that matrices   U   U   U   and   V   V   V   are unchanged, while the   k   k   k   -smallest singular values are replaced with zeroes. That is, we want       [    (   X  +  E   )    (   Y  +  F   )    ]   =    [     U  X     U  Y    ]    [      Î£  X     0      0     0   k  Ã—  k       ]     [      V   X  X       V   X  Y         V   Y  X       V   Y  Y       ]   *         delimited-[]      X  E     Y  F        delimited-[]     subscript  U  X    subscript  U  Y        subscript  normal-Î£  X   0    0   subscript  0    k  k       superscript     subscript  V    X  X     subscript  V    X  Y       subscript  V    Y  X     subscript  V    Y  Y           [(X+E)\;(Y+F)]=[U_{X}\;U_{Y}]\begin{bmatrix}\Sigma_{X}&0\\
 0&0_{k\times k}\end{bmatrix}\begin{bmatrix}V_{XX}&V_{XY}\\
 V_{YX}&V_{YY}\end{bmatrix}^{*}   so by linearity,       [    E   F   ]   =   -    [     U  X     U  Y    ]    [      0   n  Ã—  n      0      0     Î£  Y      ]     [      V   X  X       V   X  Y         V   Y  X       V   Y  Y       ]   *          delimited-[]    E  F         delimited-[]     subscript  U  X    subscript  U  Y        subscript  0    n  n    0    0   subscript  normal-Î£  Y      superscript     subscript  V    X  X     subscript  V    X  Y       subscript  V    Y  X     subscript  V    Y  Y            [E\;F]=-[U_{X}\;U_{Y}]\begin{bmatrix}0_{n\times n}&0\\
 0&\Sigma_{Y}\end{bmatrix}\begin{bmatrix}V_{XX}&V_{XY}\\
 V_{YX}&V_{YY}\end{bmatrix}^{*}   . We can then remove blocks from the U and Î£ matrices, simplifying to       [    E   F   ]   =   -    U  Y    Î£  Y     [      V   X  Y         V   Y  Y       ]   *     =   -    [    X   Y   ]    [      V   X  Y         V   Y  Y       ]     [      V   X  Y         V   Y  Y       ]   *            delimited-[]    E  F         subscript  U  Y    subscript  normal-Î£  Y    superscript     subscript  V    X  Y       subscript  V    Y  Y                    delimited-[]    X  Y       subscript  V    X  Y       subscript  V    Y  Y       superscript     subscript  V    X  Y       subscript  V    Y  Y             [E\;F]=-U_{Y}\Sigma_{Y}\begin{bmatrix}V_{XY}\\
 V_{YY}\end{bmatrix}^{*}=-[X\;Y]\begin{bmatrix}V_{XY}\\
 V_{YY}\end{bmatrix}\begin{bmatrix}V_{XY}\\
 V_{YY}\end{bmatrix}^{*}   . This provides E and F so that        [    (   X  +  E   )    (   Y  +  F   )    ]    [      V   X  Y         V   Y  Y       ]    =  0         delimited-[]      X  E     Y  F        subscript  V    X  Y       subscript  V    Y  Y       0    [(X+E)\;(Y+F)]\begin{bmatrix}V_{XY}\\
 V_{YY}\end{bmatrix}=0   . Now if    V   Y  Y      subscript  V    Y  Y     V_{YY}   is nonsingular, which is not always the case (note that the behavior of TLS when    V   Y  Y      subscript  V    Y  Y     V_{YY}   is singular is not well understood yet), we can then right multiply both sides by    -   V   Y  Y    -  1         superscript   subscript  V    Y  Y      1      -V_{YY}^{-1}   to bring the bottom block of the right matrix to the negative identity, giving 8         [    (   X  +  E   )    (   Y  +  F   )    ]    [      -    V   X  Y     V   Y  Y    -  1           -    V   Y  Y     V   Y  Y    -  1         ]    =    [    (   X  +  E   )    (   Y  +  F   )    ]    [     B       -   I  k       ]    =  0   ,           delimited-[]      X  E     Y  F            subscript  V    X  Y     superscript   subscript  V    Y  Y      1             subscript  V    Y  Y     superscript   subscript  V    Y  Y      1            delimited-[]      X  E     Y  F       B       subscript  I  k            0     [(X+E)\;(Y+F)]\begin{bmatrix}-V_{XY}V_{YY}^{-1}\\
 -V_{YY}V_{YY}^{-1}\end{bmatrix}=[(X+E)\;(Y+F)]\begin{bmatrix}B\\
 -I_{k}\end{bmatrix}=0,   and so       B  =   -    V   X  Y     V   Y  Y    -  1       .      B       subscript  V    X  Y     superscript   subscript  V    Y  Y      1        B=-V_{XY}V_{YY}^{-1}.     A naive GNU Octave implementation of this is:  function B = tls(xdata,ydata)
 
 m       = length(ydata); %number of x,y data pairs X       = [xdata];
 Y       = ydata;
 n       = size(X, 2 ); % n is the width of X (X is m by n) Z       = [X Y]; % Z is X augmented with Y. [U S V] = svd(Z, 0 ); % find the SVD of Z. VXY     = V( 1 :n, 1 +n:end); % Take the block of V consisting of the first n rows and the n+1 to last column VYY     = V( 1 +n:end, 1 +n:end); % Take the bottom-right block of V. B       = -VXY/VYY;
 end  The way described above of solving the problem, which requires that the matrix    V   Y  Y      subscript  V    Y  Y     V_{YY}   is nonsingular, can be slightly extended by the so-called classical TLS algorithm . 9  Computation  The standard implementation of classical TLS algorithm is available through Netlib , see also. 10 11 All modern implementations based, for example, on solving a sequence of ordinary least squares problems, approximate the matrix   B   B   B   (denoted   X   X   X   in the literature), as introduced by Van Huffel and Vandewalle. It is worth noting, that this   B   B   B   is, however, not the TLS solution in many cases. 12 13  Non-linear model  For non-linear systems similar reasoning shows that the normal equations for an iteration cycle can be written as         ğ‰  ğ“    ğŒ   -  ğŸ    ğ‰  ğš«  ğœ·   =    ğ‰  ğ“    ğŒ   -  ğŸ    ğš«  ğ²    .         superscript  ğ‰  ğ“    superscript  ğŒ    1    ğ‰  ğš«  ğœ·      superscript  ğ‰  ğ“    superscript  ğŒ    1    ğš«  ğ²     \mathbf{J^{T}M^{-1}J\Delta\boldsymbol{\beta}=J^{T}M^{-1}\Delta y}.     Geometrical interpretation  When the independent variable is error-free a residual represents the "vertical" distance between the observed data point and the fitted curve (or surface). In total least squares a residual represents the distance between a data point and the fitted curve measured along some direction. In fact, if both variables are measured in the same units and the errors on both variables are the same, then the residual represents the shortest distance between the data point and the fitted curve , that is, the residual vector is perpendicular to the tangent of the curve. For this reason, this type of regression is sometimes called two dimensional Euclidean regression (Stein, 1983) 14 or orthogonal regression .  Scale invariant methods  A serious difficulty arises if the variables are not measured in the same units. First consider measuring distance between a data point and the curve - what are the measurement units for this distance? If we consider measuring distance based on Pythagoras' Theorem then it is clear that we shall be adding quantities measured in different units, and so this leads to meaningless results. Secondly, if we rescale one of the variables e.g., measure in grams rather than kilograms, then we shall end up with different results (a different curve). To avoid this problem of incommensurability it is sometimes suggested that we convert to dimensionless variablesâ€”this may be called normalization or standardization. However there are various ways of doing this, and these lead to fitted models which are not equivalent to each other. One approach is to normalize by known (or estimated) measurement precision thereby minimizing the Mahalanobis distance from the points to the line, providing a maximum-likelihood solution; the unknown precisions could be found via analysis of variance .  In short, total least squares does not have the property of units-invarianceâ€”i.e. it is not scale invariant . For a meaningful model we require this property to hold. A way forward is to realise that residuals (distances) measured in different units can be combined if multiplication is used instead of addition. Consider fitting a line: for each data point the product of the vertical and horizontal residuals equals twice the area of the triangle formed by the residual lines and the fitted line. We choose the line which minimizes the sum of these areas. Nobel laureate Paul Samuelson proved in 1942 that, in two dimensions, it is the only line expressible solely in terms of the ratios of standard deviations and the correlation coefficient which (1) fits the correct equation when the observations fall on a straight line; (2) exhibits scale invariance, and (3) exhibits invariance under interchange of variables. 15 This line has been rediscovered in different disciplines and is variously known as standardised major axis (Ricker 1975, Warton et al., 2006), 16 17 the reduced major axis, the geometric mean functional relationship (Draper and Smith, 1998), 18 least products regression, diagonal regression, line of organic correlation, and the least areas line. Tofallis (2002) 19 has extended this approach to deal with multiple variables.  See also   Deming regression , a special case with two predictors and independent errors  Errors-in-variables model  Linear regression  Least squares   Notes  References  Others   I. HnÄ›tynkovÃ¡, M. PleÅ¡inger, D. M. Sima, Z. StrakoÅ¡, and S. Van Huffel, The total least squares problem in AX â‰ˆ B. A new classification with the relationship to the classical works. SIMAX vol. 32 issue 3 (2011), pp.Â 748â€“770. Available as a preprint .  M. PleÅ¡inger, The Total Least Squares Problem and Reduction of Data in AX â‰ˆ B. Doctoral Thesis, TU of Liberec and Institute of Computer Science, AS CR Prague, 2008. Ph.D. Thesis  C. C. Paige, Z. StrakoÅ¡, Core problems in linear algebraic systems. SIAM J. Matrix Anal. Appl. 27, 2006, pp.Â 861â€“875.  S. Van Huffel and P. Lemmerling, Total Least Squares and Errors-in-Variables Modeling: Analysis, Algorithms and Applications . Dordrecht, The Netherlands: Kluwer Academic Publishers, 2002.  S. Jo and S. W. Kim, Consistent normalized least mean square filtering with noisy data matrix. IEEE Trans. Signal Processing, vol. 53, no. 6, pp.Â 2112â€“2123, Jun. 2005.  R. D. DeGroat and E. M. Dowling, The data least squares problem and channel equalization. IEEE Trans. Signal Processing, vol. 41, no. 1, pp.Â 407â€“411, Jan. 1993.  S. Van Huffel and J. Vandewalle, The Total Least Squares Problems: Computational Aspects and Analysis. SIAM Publications, Philadelphia PA, 1991.  T. Abatzoglou and J. Mendel, Constrained total least squares , in Proc. IEEE Int. Conf. Acoust., Speech, Signal Process. (ICASSPâ€™87), Apr. 1987, vol. 12, pp.Â 1485â€“1488.  P. de Groen An introduction to total least squares , in Nieuw Archief voor Wiskunde, Vierde serie, deel 14, 1996, pp.Â 237â€“253 arxiv.org .  G. H. Golub and C. F. Van Loan, An analysis of the total least squares problem. SIAM J. on Numer. Anal., 17, 1980, pp.Â 883â€“893.  Perpendicular Regression Of A Line at MathPages  A. R. Amiri-Simkooei and S. Jazaeri Weighted total least squares formulated by standard least squares theory ,in Journal of Geodetic Science, 2 (2): 113-124, 2012 1 .   "  Category:Applied mathematics  Category:Statistical models  Category:Regression analysis  Category:Least squares  Category:Multivariate statistics     I. Markovsky and S. Van Huffel, Overview of total least squares methods. Signal Processing, vol. 87, pp. 2283-2302, 2007. preprint â†©  An alternative form is      ğ—  ğ“   ğ–ğ—  ğš«  ğœ·   =    ğ—  ğ“   ğ–  ğš«  ğ²          superscript  ğ—  ğ“   ğ–ğ—  ğš«  ğœ·      superscript  ğ—  ğ“   ğ–  ğš«  ğ²     \mathbf{X^{T}WX\boldsymbol{\Delta}\boldsymbol{\beta}=X^{T}W\boldsymbol{\Delta}y}   , where    ğš«  ğœ·      ğš«  ğœ·    \boldsymbol{\Delta}\boldsymbol{\beta}   is the parameter shift from some starting estimate of   ğœ·   ğœ·   \boldsymbol{\beta}   and    ğš«  ğ²      ğš«  ğ²    \boldsymbol{\Delta}\mathbf{y}   is the difference between y and the value calculated using the starting value of   ğœ·   ğœ·   \boldsymbol{\beta}    â†©  W.E. Deming, Statistical Adjustment of Data, Wiley, 1943 â†©  â†©  G. H. Golub and C. F. Van Loan, An analysis of the total least squares problem. Numer. Anal., 17, 1980, pp. 883-893. â†©  pp 596. â†©  The notation XB â‰ˆ Y is used here to reflect the notation used in the earlier part of the article. In the computational literature the problem has been more commonly presented as AX â‰ˆ B , i.e. with the letter X used for the n -by- k matrix of unknown regression coefficients. â†©  BjÃµrck, Ake (1996) Numerical Methods for Least Squares Problems , Society for Industrial and Applied Mathematics. ISBN 978-0898713602 â†©  S. Van Huffel and J. Vandewalle (1991) The Total Least Squares Problems: Computational Aspects and Analysis . SIAM Publications, Philadelphia PA. â†©  S. Van Huffel, Documented Fortran 77 programs of the extended classical total least squares algorithm, the partial singular value decomposition algorithm and the partial total least squares algorithm, Internal Report ESAT-KUL 88/1, ESAT Lab., Dept. of Electrical Engineering, Katholieke Universiteit Leuven, 1988. â†©  S. Van Huffel, The extended classical total least squares algorithm, J. Comput. Appl. Math., 25, pp. 111-119, 1989. â†©  M. PleÅ¡inger, The Total Least Squares Problem and Reduction of Data in AX â‰ˆ B. Doctoral Thesis, TU of Liberec and Institute of Computer Science, AS CR Prague, 2008. Ph.D. Thesis â†©  I. HnÄ›tynkovÃ¡, M. PleÅ¡inger, D. M. Sima, Z. StrakoÅ¡, and S. Van Huffel, The total least squares problem in AX â‰ˆ B. A new classification with the relationship to the classical works. SIMAX vol. 32 issue 3 (2011), pp. 748â€“770. â†©  â†©  â†©  â†©  â†©  Draper, NR and Smith, H. Applied Regression Analysis , 3rd edition,pp.92-96. 1998 â†©  â†©    