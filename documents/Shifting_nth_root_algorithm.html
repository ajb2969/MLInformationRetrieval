<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="158">Shifting nth root algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Shifting nth root algorithm</h1>
<hr/>

<p>The <strong>shifting <em>n</em>th root algorithm</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> for extracting the <a href="nth_root" title="wikilink"><em>n</em>th root</a> of a positive <a href="real_number" title="wikilink">real number</a> which proceeds iteratively by shifting in <em>n</em> <a href="numerical_digit" title="wikilink">digits</a> of the radicand, starting with the most significant, and produces one digit of the root on each iteration, in a manner similar to <a href="long_division" title="wikilink">long division</a>.</p>
<h2 id="algorithm">Algorithm</h2>
<h3 id="notation">Notation</h3>

<p>Let <em>B</em> be the <a href="radix" title="wikilink">base</a> of the number system you are using, and <em>n</em> be the degree of the root to be extracted. Let <em>x</em> be the radicand processed thus far, <em>y</em> be the root extracted thus far, and <em>r</em> be the remainder. Let α be the next <em>n</em> digits of the radicand, and β be the next digit of the root. Let <em>x</em>' be the new value of <em>x</em> for the next iteration, <em>y</em>' be the new value of <em>y</em> for the next iteration, and <em>r</em>' be the new value of <em>r</em> for the next iteration. These are all <a href="integer" title="wikilink">integers</a>.</p>
<h3 id="invariants">Invariants</h3>

<p>At each iteration, the <a href="Invariant_(computer_science)" title="wikilink">invariant</a> 

<math display="inline" id="Shifting_nth_root_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>n</mi>
    </msup>
    <mo>+</mo>
    <mi>r</mi>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <ci>r</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{n}+r=x
  </annotation>
 </semantics>
</math>

 will hold. The invariant 

<math display="inline" id="Shifting_nth_root_algorithm:1">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>></mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y+1)^{n}>x
  </annotation>
 </semantics>
</math>

 will hold. Thus <em>y</em> is the largest integer less than or equal to the <em>n</em>th root of <em>x</em>, and <em>r</em> is the remainder.</p>
<h3 id="initialization">Initialization</h3>

<p>The initial values of <em>x</em>, <em>y</em>, and <em>r</em> should be 0. The value of α for the first iteration should be the most significant aligned block of <em>n</em> digits of the radicand. An aligned block of <em>n</em> digits means a block of digits aligned so that the decimal point falls between blocks. For example, in 123.4 the most significant aligned block of 2 digits is 01, the next most significant is 23, and the third most significant is 40.</p>
<h3 id="main-loop">Main loop</h3>

<p>On each iteration we shift in <em>n</em> digits of the radicand, so we have 

<math display="inline" id="Shifting_nth_root_algorithm:2">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}=B^{n}x+\alpha
  </annotation>
 </semantics>
</math>

 and we produce 1 digit of the root, so we have 

<math display="inline" id="Shifting_nth_root_algorithm:3">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>y</ci>
     </apply>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=By+\beta
  </annotation>
 </semantics>
</math>

. We want to choose β and <em>r</em>' so that the invariants described above hold. It turns out that there is always exactly one such choice, as will be proved below.</p>

<p>The first invariant says that:</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:4">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>y</mi>
     <mrow>
      <mi mathvariant="normal">′</mi>
      <mi>n</mi>
     </mrow>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>r</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <list>
       <ci>normal-′</ci>
       <ci>n</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}=y^{\prime n}+r^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>or</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>B</mi>
       <mi>n</mi>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi>α</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>B</mi>
         <mi>y</mi>
        </mrow>
        <mo>+</mo>
        <mi>β</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <mo>+</mo>
     <msup>
      <mi>r</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>y</ci>
       </apply>
       <ci>β</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}x+\alpha=(By+\beta)^{n}+r^{\prime}.
  </annotation>
 </semantics>
</math>

</p>

<p>So, pick the largest integer β such that</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:6">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mi>y</mi>
      </mrow>
      <mo>+</mo>
      <mi>β</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>y</ci>
      </apply>
      <ci>β</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta)^{n}\leq B^{n}x+\alpha
  </annotation>
 </semantics>
</math>

</p>

<p>and let</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>r</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>B</mi>
        <mi>n</mi>
       </msup>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mi>α</mi>
     </mrow>
     <mo>-</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>B</mi>
         <mi>y</mi>
        </mrow>
        <mo>+</mo>
        <mi>β</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>y</ci>
       </apply>
       <ci>β</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime}=B^{n}x+\alpha-(By+\beta)^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>Such a β always exists, since if 

<math display="inline" id="Shifting_nth_root_algorithm:8">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=0
  </annotation>
 </semantics>
</math>

 then the condition is 

<math display="inline" id="Shifting_nth_root_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>B</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>y</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}y^{n}\leq B^{n}x+\alpha
  </annotation>
 </semantics>
</math>

, but 

<math display="inline" id="Shifting_nth_root_algorithm:10">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mi>n</mi>
   </msup>
   <mo>≤</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{n}\leq x
  </annotation>
 </semantics>
</math>

, so this is always true. Also, β must be less than <em>B</em>, since if 

<math display="inline" id="Shifting_nth_root_algorithm:11">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=B
  </annotation>
 </semantics>
</math>

 then we would have</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:12">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>y</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>α</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>B</ci>
      <apply>
       <plus></plus>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B(y+1))^{n}\leq B^{n}x+\alpha\,
  </annotation>
 </semantics>
</math>

</p>

<p>but the second invariant implies that</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:13">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>B</mi>
     <mi>n</mi>
    </msup>
    <mi>x</mi>
   </mrow>
   <mo><</mo>
   <mrow>
    <msup>
     <mi>B</mi>
     <mi>n</mi>
    </msup>
    <mpadded width="+1.7pt">
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>y</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}x<B^{n}(y+1)^{n}\,
  </annotation>
 </semantics>
</math>

</p>

<p>and since 

<math display="inline" id="Shifting_nth_root_algorithm:14">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mi>n</mi>
   </msup>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shifting_nth_root_algorithm:15">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mi>n</mi>
   </msup>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}(y+1)^{n}
  </annotation>
 </semantics>
</math>

 are both multiples of 

<math display="inline" id="Shifting_nth_root_algorithm:16">
 <semantics>
  <msup>
   <mi>B</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}
  </annotation>
 </semantics>
</math>

 the difference between them must be at least 

<math display="inline" id="Shifting_nth_root_algorithm:17">
 <semantics>
  <msup>
   <mi>B</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}
  </annotation>
 </semantics>
</math>

, and then we have</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <msup>
     <mi>B</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msup>
     <mi>B</mi>
     <mi>n</mi>
    </msup>
    <mpadded width="+1.7pt">
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>y</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}x+B^{n}\leq B^{n}(y+1)^{n}\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <msup>
     <mi>B</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>α</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}x+B^{n}\leq B^{n}x+\alpha\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:20">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mi>n</mi>
   </msup>
   <mo>≤</mo>
   <mpadded width="+1.7pt">
    <mi>α</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}\leq\alpha\,
  </annotation>
 </semantics>
</math>

</p>

<p>but 

<math display="inline" id="Shifting_nth_root_algorithm:21">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>α</mi>
   <mo><</mo>
   <msup>
    <mi>B</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>α</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\alpha<B^{n}
  </annotation>
 </semantics>
</math>

 by definition of α, so this can't be true, and 

<math display="inline" id="Shifting_nth_root_algorithm:22">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>B</mi>
      <mi>y</mi>
     </mrow>
     <mo>+</mo>
     <mi>β</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>y</ci>
     </apply>
     <ci>β</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta)^{n}
  </annotation>
 </semantics>
</math>

 is a monotonically increasing function of β, so it can't be true for larger β either, so we conclude that there exists an integer γ with 

<math display="inline" id="Shifting_nth_root_algorithm:23">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>β</mi>
   <mo>≤</mo>
   <mi>γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>β</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\beta\leq\gamma
  </annotation>
 </semantics>
</math>

 exists such that the first invariant holds if and only if 

<math display="block" id="Shifting_nth_root_algorithm:24">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>></mo>
   <mpadded width="+1.7pt">
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y^{\prime}+1)^{n}>x^{\prime}\,
  </annotation>
 </semantics>
</math>

.</p>

<p>Now consider the second invariant. It says:</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:25">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mi>y</mi>
      </mrow>
      <mo>+</mo>
      <mi>β</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>></mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>α</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>y</ci>
      </apply>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta+1)^{n}>B^{n}x+\alpha\,
  </annotation>
 </semantics>
</math>

</p>

<p>or</p>

<p>

<math display="inline" id="Shifting_nth_root_algorithm:26">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>β</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta+1
  </annotation>
 </semantics>
</math>

</p>

<p>Now, if β is not the largest admissible β for the first invariant as described above, then 

<math display="block" id="Shifting_nth_root_algorithm:27">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mi>y</mi>
      </mrow>
      <mo>+</mo>
      <mi>β</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>α</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>y</ci>
      </apply>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta+1)^{n}\leq B^{n}x+\alpha\,
  </annotation>
 </semantics>
</math>

 is also admissible, and we have</p>

<p>

<math display="inline" id="Shifting_nth_root_algorithm:28">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}=B^{n}x+\alpha
  </annotation>
 </semantics>
</math>

</p>

<p>This violates the second invariant, so to satisfy both invariants we must pick the largest β allowed by the first invariant. Thus we have proven the existence and uniqueness of β and <em>r</em>'.</p>

<p>To summarize, on each iteration:</p>
<ol>
<li>Let α be the next aligned block of digits from the radicand</li>
<li>Let 

<math display="inline" id="Shifting_nth_root_algorithm:29">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mi>y</mi>
      </mrow>
      <mo>+</mo>
      <mi>β</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>y</ci>
      </apply>
      <ci>β</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta)^{n}\leq B^{n}x+\alpha
  </annotation>
 </semantics>
</math>

</li>
<li>Let β be the largest β such that 

<math display="inline" id="Shifting_nth_root_algorithm:30">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>y</ci>
     </apply>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=By+\beta
  </annotation>
 </semantics>
</math>

</li>
<li>Let 

<math display="inline" id="Shifting_nth_root_algorithm:31">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>-</mo>
    <msup>
     <mi>y</mi>
     <mrow>
      <mi mathvariant="normal">′</mi>
      <mi>n</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <list>
       <ci>normal-′</ci>
       <ci>n</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime}=x^{\prime}-y^{\prime n}
  </annotation>
 </semantics>
</math>

</li>
<li>Let 

<math display="inline" id="Shifting_nth_root_algorithm:32">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>n</mi>
    </msup>
    <mo>+</mo>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y^{n}+r
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>Now, note that 

<math display="block" id="Shifting_nth_root_algorithm:33">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mi>y</mi>
      </mrow>
      <mo>+</mo>
      <mi>β</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>y</ci>
      </apply>
      <ci>β</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta)^{n}\leq B^{n}x+\alpha
  </annotation>
 </semantics>
</math>

, so the condition</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:34">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>B</mi>
        <mi>y</mi>
       </mrow>
       <mo>+</mo>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>y</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mi>r</mi>
    </mrow>
    <mo>+</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>y</ci>
       </apply>
       <ci>β</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>r</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta)^{n}-B^{n}y^{n}\leq B^{n}r+\alpha
  </annotation>
 </semantics>
</math>

</p>

<p>is equivalent to</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:35">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>-</mo>
    <msup>
     <mi>y</mi>
     <mrow>
      <mi mathvariant="normal">′</mi>
      <mi>n</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>B</mi>
       <mi>n</mi>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi>α</mi>
    </mrow>
    <mo>-</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>B</mi>
        <mi>y</mi>
       </mrow>
       <mo>+</mo>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <list>
        <ci>normal-′</ci>
        <ci>n</ci>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>B</ci>
         <ci>n</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <ci>α</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>y</ci>
        </apply>
        <ci>β</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime}=x^{\prime}-y^{\prime n}=B^{n}x+\alpha-(By+\beta)^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Shifting_nth_root_algorithm:36">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>B</mi>
       <mi>n</mi>
      </msup>
      <mi>r</mi>
     </mrow>
     <mo>+</mo>
     <mi>α</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>B</mi>
          <mi>y</mi>
         </mrow>
         <mo>+</mo>
         <mi>β</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>B</mi>
        <mi>n</mi>
       </msup>
       <msup>
        <mi>y</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
       <ci>r</ci>
      </apply>
      <ci>α</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>y</ci>
        </apply>
        <ci>β</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime}=B^{n}r+\alpha-((By+\beta)^{n}-B^{n}y^{n})
  </annotation>
 </semantics>
</math>

</p>

<p>is equivalent to</p>

<p>

<math display="inline" id="Shifting_nth_root_algorithm:37">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, we don't actually need 

<math display="inline" id="Shifting_nth_root_algorithm:38">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <msup>
     <mi>y</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=x-y^{n}
  </annotation>
 </semantics>
</math>

, and since 

<math display="inline" id="Shifting_nth_root_algorithm:39">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo><</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x<(y+1)^{n}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shifting_nth_root_algorithm:40">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo><</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>y</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
    <mo>-</mo>
    <msup>
     <mi>y</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>r</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r<(y+1)^{n}-y^{n}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Shifting_nth_root_algorithm:41">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Shifting_nth_root_algorithm:42">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mi>n</mi>
   </msup>
   <msup>
    <mi>y</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{n}y^{n}
  </annotation>
 </semantics>
</math>

 instead of 

<math display="inline" id="Shifting_nth_root_algorithm:43">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>B</mi>
      <mi>y</mi>
     </mrow>
     <mo>+</mo>
     <mi>β</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>y</ci>
     </apply>
     <ci>β</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta)^{n}
  </annotation>
 </semantics>
</math>

 we save time and space by a factor of 1/<em>n</em>. Also, the 

<math display="inline" id="Shifting_nth_root_algorithm:44">
 <semantics>
  <msup>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{n-1}
  </annotation>
 </semantics>
</math>

 we subtract in the new test cancels the one in 

<math display="inline" id="Shifting_nth_root_algorithm:45">
 <semantics>
  <msup>
   <mi>y</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{n}
  </annotation>
 </semantics>
</math>

, so now the highest power of <em>y</em> we have to evaluate is 

<math display="inline" id="Shifting_nth_root_algorithm:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>B</mi>
         <mi>y</mi>
        </mrow>
        <mo>+</mo>
        <mi>β</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <mo>-</mo>
     <mrow>
      <msup>
       <mi>B</mi>
       <mi>n</mi>
      </msup>
      <msup>
       <mi>y</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>B</mi>
       <mi>n</mi>
      </msup>
      <mi>r</mi>
     </mrow>
     <mo>+</mo>
     <mi>α</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>y</ci>
       </apply>
       <ci>β</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
      <ci>r</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta)^{n}-B^{n}y^{n}\leq B^{n}r+\alpha.
  </annotation>
 </semantics>
</math>

 rather than 

<math display="inline" id="Shifting_nth_root_algorithm:47">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>y</ci>
     </apply>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=By+\beta
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="summary">Summary</h3>
<ol>
<li>Initialize <em>r</em> and <em>y</em> to 0.</li>
<li>Repeat until desired <a href="decimal_precision" title="wikilink">precision</a> is obtained:
<ol>
<li>Let α be the next aligned block of digits from the radicand.</li>
<li>Let β be the largest β such that 

<math display="inline" id="Shifting_nth_root_algorithm:48">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>r</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>B</mi>
        <mi>n</mi>
       </msup>
       <mi>r</mi>
      </mrow>
      <mo>+</mo>
      <mi>α</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>B</mi>
           <mi>y</mi>
          </mrow>
          <mo>+</mo>
          <mi>β</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>n</mi>
       </msup>
       <mo>-</mo>
       <mrow>
        <msup>
         <mi>B</mi>
         <mi>n</mi>
        </msup>
        <msup>
         <mi>y</mi>
         <mi>n</mi>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
       <ci>r</ci>
      </apply>
      <ci>α</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>y</ci>
        </apply>
        <ci>β</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime}=B^{n}r+\alpha-((By+\beta)^{n}-B^{n}y^{n}).
  </annotation>
 </semantics>
</math>

</li>
<li>Let 

<math display="inline" id="Shifting_nth_root_algorithm:49">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>←</mo>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\leftarrow y^{\prime}
  </annotation>
 </semantics>
</math>

.</li>
<li>Let 

<math display="inline" id="Shifting_nth_root_algorithm:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mo>←</mo>
    <msup>
     <mi>r</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\leftarrow r^{\prime}.
  </annotation>
 </semantics>
</math>

</li>
<li>Assign 

<math display="inline" id="Shifting_nth_root_algorithm:51">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shifting_nth_root_algorithm:52">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

</li>
</ol></li>
<li>

<math display="inline" id="Shifting_nth_root_algorithm:53">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mi>y</mi>
      </mrow>
      <mo>+</mo>
      <mi>β</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>-</mo>
   <mrow>
    <msup>
     <mi>B</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>y</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>y</ci>
      </apply>
      <ci>β</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta)^{n}-B^{n}y^{n}
  </annotation>
 </semantics>
</math>

 is the largest integer such that 

<math display="inline" id="Shifting_nth_root_algorithm:54">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>+</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>r</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r+\alpha
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Shifting_nth_root_algorithm:55">
 <semantics>
  <mrow>
   <mi>n</mi>
   <msup>
    <mi>B</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <msup>
    <mi>y</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nB^{n-1}y^{n-1}
  </annotation>
 </semantics>
</math>

 is the number of digits of the radicand after the decimal point that have been consumed (a negative number if the algorithm hasn't reached the decimal point yet).</li>
</ol>
<h2 id="paper-and-pencil-nth-roots">Paper-and-pencil <em>n</em>th roots</h2>

<p>As noted above, this algorithm is similar to long division, and it lends itself to the same notation:</p>

<p><code>     </code><code>.  </code><code> </code><code> </code><code> </code><code> </code><br/>
<code>    ——————————————————————</code><br/>
<code>_ </code><code>/ 3.</code><code> </code><code> </code><code> </code><code> </code><br/>
<code> \/  </code><code>                        = </code><code>(10×</code><code>)</code><sup><code>2</code></sup><code>×</code><code>     +</code><code>(10×</code><code>)×</code><sup><code>2</code></sup><code>     +</code><sup><code>3</code></sup><br/>
<code>     —</code><br/>
<code>     2 </code><br/>
<code>     1 744                    = </code><code>(10×</code><code>)</code><sup><code>2</code></sup><code>×</code><code>     +</code><code>(10×</code><code>)×</code><sup><code>2</code></sup><code>     +</code><sup><code>3</code></sup><br/>
<code>     —————</code><br/>
<code>       256 </code><br/>
<code>       241 984                = </code><code>(10×</code><code>)</code><sup><code>2</code></sup><code>×</code><code>    +</code><code>(10×</code><code>)×</code><sup><code>2</code></sup><code>    +</code><sup><code>3</code></sup><br/>
<code>       ———————</code><br/>
<code>        14 016 </code><br/>
<code>        12 458 888            = </code><code>(10×</code><sup><code>2</code></sup><code>)×</code><code>   +</code><code>(10×</code><code>)×</code><sup><code>2</code></sup><code>   +</code><sup><code>3</code></sup><br/>
<code>        ——————————</code><br/>
<code>         1 557 112 </code><br/>
<code>         1 247 791 448        = </code><code>(10×</code><sup><code>2</code></sup><code>)×</code><code>  +</code><code>(10×</code><code>)×</code><sup><code>2</code></sup><code>  +</code><sup><code>3</code></sup><br/>
<code>         —————————————</code><br/>
<code>           309 320 552 </code><br/>
<code>           249 599 823 424    = </code><code>(10×</code><sup><code>2</code></sup><code>)×</code><code> +</code><code>(10×</code><code>)×</code><sup><code>2</code></sup><code> +</code><sup><code>3</code></sup><br/>
<code>           ———————————————</code><br/>
<code>            59 720 728 576</code></p>

<p>Note that after the first iteration or two the leading term dominates the 

<math display="inline" id="Shifting_nth_root_algorithm:56">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(B))
  </annotation>
 </semantics>
</math>

, so we can get an often correct first guess at β by dividing 

<math display="inline" id="Shifting_nth_root_algorithm:57">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mi>y</mi>
      </mrow>
      <mo>+</mo>
      <mi>β</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
   <mo>-</mo>
   <mrow>
    <msup>
     <mi>B</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>y</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>y</ci>
      </apply>
      <ci>β</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (By+\beta)^{n}-B^{n}y^{n}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Shifting_nth_root_algorithm:58">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
   <mo>-</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n-4
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="performance">Performance</h2>

<p>On each iteration, the most time-consuming task is to select β. We know that there are <em>B</em> possible values, so we can find β using 

<math display="inline" id="Shifting_nth_root_algorithm:59">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(n-1)
  </annotation>
 </semantics>
</math>

 comparisons. Each comparison will require evaluating 

<math display="inline" id="Shifting_nth_root_algorithm:60">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-2
  </annotation>
 </semantics>
</math>

. In the <em>k</em>th iteration, y has <em>k</em> digits, and the polynomial can be evaluated with 

<math display="inline" id="Shifting_nth_root_algorithm:61">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(n-1)
  </annotation>
 </semantics>
</math>

 multiplications of up to 

<math display="inline" id="Shifting_nth_root_algorithm:62">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 digits and 

<math display="inline" id="Shifting_nth_root_algorithm:63">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-2
  </annotation>
 </semantics>
</math>

 additions of up to 

<math display="inline" id="Shifting_nth_root_algorithm:64">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(n-1)
  </annotation>
 </semantics>
</math>

 digits, once we know the powers of <em>y</em> and β up through 

<math display="inline" id="Shifting_nth_root_algorithm:65">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 for <em>y</em> and <em>n</em> for β. β has a restricted range, so we can get the powers of β in constant time. We can get the powers of <em>y</em> with 

<math display="inline" id="Shifting_nth_root_algorithm:66">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 multiplications of up to 

<math display="inline" id="Shifting_nth_root_algorithm:67">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>k</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2}n^{2})
  </annotation>
 </semantics>
</math>

 digits. Assuming <em>n</em>-digit multiplication takes time 

<math display="inline" id="Shifting_nth_root_algorithm:68">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>k</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2}n^{2}\log(B))
  </annotation>
 </semantics>
</math>

 and addition takes time 

<math display="inline" id="Shifting_nth_root_algorithm:69">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k)
  </annotation>
 </semantics>
</math>

, we take time 

<math display="inline" id="Shifting_nth_root_algorithm:70">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>k</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2}n^{2}\log(B))
  </annotation>
 </semantics>
</math>

 for each comparison, or time 

<math display="inline" id="Shifting_nth_root_algorithm:71">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>k</mi>
      <mn>3</mn>
     </msup>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{3}n^{2}\log(B))
  </annotation>
 </semantics>
</math>

 to pick β. The remainder of the algorithm is addition and subtraction that takes time 

<math display="inline" id="Shifting_nth_root_algorithm:72">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k)
  </annotation>
 </semantics>
</math>

, so each iteration takes 

<math display="inline" id="Shifting_nth_root_algorithm:73">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(B))
  </annotation>
 </semantics>
</math>

. For all <em>k</em> digits, we need time 

<math display="inline" id="Shifting_nth_root_algorithm:74">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{2}(B))
  </annotation>
 </semantics>
</math>

.</p>

<p>The only internal storage needed is <em>r</em>, which is <span class="LaTeX">$O(k)$</span> digits on the <em>k</em>th iteration. That this algorithm doesn't have bounded memory usage puts an upper bound on the number of digits which can be computed mentally, unlike the more elementary algorithms of arithmetic. Unfortunately, any bounded memory state machine with periodic inputs can only produce periodic outputs, so there are no such algorithms which can compute irrational numbers from rational ones, and thus no bounded memory root extraction algorithms.</p>

<p>Note that increasing the base increases the time needed to pick β by a factor of <span class="LaTeX">$O(\log(B))$</span>, but decreases the number of digits needed to achieve a given precision by the same factor, and since the algorithm is cubic time in the number of digits, increasing the base gives an overall speedup of <span class="LaTeX">$O(\log^2(B))$</span>. When the base is larger than the radicand, the algorithm degenerates to <a href="binary_search" title="wikilink">binary search</a>, so it follows that this algorithm is not useful for computing roots with a computer, as it is always outperformed by much simpler binary search, and has the same memory complexity.</p>
<h2 id="examples">Examples</h2>
<h3 id="square-root-of-2-in-binary">Square root of 2 in binary</h3>

<p><code>      1. 0  1  1  0  1</code><br/>
<code>    ------------------</code><br/>
<code>_  / 10.00 00 00 00 00     1</code><br/>
<code> \/   1                  + 1</code><br/>
<code>     -----               ----</code><br/>
<code>      1 00                100</code><br/>
<code>         0               +  0</code><br/>
<code>     --------            -----</code><br/>
<code>      1 00 00             1001</code><br/>
<code>        10 01            +   1</code><br/>
<code>     -----------         ------</code><br/>
<code>         1 11 00          10101</code><br/>
<code>         1 01 01         +    1</code><br/>
<code>         ----------      -------</code><br/>
<code>            1 11 00       101100</code><br/>
<code>                  0      +     0</code><br/>
<code>            ----------   --------</code><br/>
<code>            1 11 00 00    1011001</code><br/>
<code>            1 01 10 01          1</code><br/>
<code>            ----------</code><br/>
<code>               1 01 11 remainder</code></p>
<h3 id="square-root-of-3">Square root of 3</h3>

<p><code>     1. 7  3  2  0  5</code><br/>
<code>    ----------------------</code><br/>
<code>_  / 3.00 00 00 00 00</code><br/>
<code> \/  1 = 20×0×1+1^2</code><br/>
<code>     -</code><br/>
<code>     2 00</code><br/>
<code>     1 89 = 20×1×7+7^2</code><br/>
<code>     ----</code><br/>
<code>       11 00</code><br/>
<code>       10 29 = 20×17×3+3^2</code><br/>
<code>       -----</code><br/>
<code>          71 00</code><br/>
<code>          69 24 = 20×173×2+2^2</code><br/>
<code>          -----</code><br/>
<code>           1 76 00</code><br/>
<code>                 0 = 20×1732×0+0^2</code><br/>
<code>           -------</code><br/>
<code>           1 76 00 00</code><br/>
<code>           1 73 20 25 = 20×17320×5+5^2</code><br/>
<code>           ----------</code><br/>
<code>              2 79 75</code></p>
<h3 id="cube-root-of-5">Cube root of 5</h3>

<p><code>     1.  7   0   9   9   7</code><br/>
<code>    ----------------------</code><br/>
<code>_ 3/ 5. 000 000 000 000 000</code><br/>
<code> \/  1 = 300×(0^2)×1+30×0×(1^2)+1^3</code><br/>
<code>     -</code><br/>
<code>     4 000</code><br/>
<code>     3 913 = 300×(1^2)×7+30×1×(7^2)+7^3</code><br/>
<code>     -----</code><br/>
<code>        87 000</code><br/>
<code>             0 = 300×(17^2)*0+30×17×(0^2)+0^3</code><br/>
<code>       -------</code><br/>
<code>        87 000 000</code><br/>
<code>        78 443 829 = 300×(170^2)×9+30×170×(9^2)+9^3</code><br/>
<code>        ----------</code><br/>
<code>         8 556 171 000</code><br/>
<code>         7 889 992 299 = 300×(1709^2)×9+30×1709×(9^2)+9^3</code><br/>
<code>         -------------</code><br/>
<code>           666 178 701 000</code><br/>
<code>           614 014 317 973 = 300×(17099^2)×7+30×17099×(7^2)+7^3</code><br/>
<code>           ---------------</code><br/>
<code>            52 164 383 027</code><br/>
</p>
<h3 id="fourth-root-of-7">Fourth root of 7</h3>

<p><code>     1.   6    2    6    5    7</code><br/>
<code>    ---------------------------</code><br/>
<code>_ 4/ 7.0000 0000 0000 0000 0000</code><br/>
<code> \/  1 = 4000×(0^3)×1+400×(0^2)×(1^2)+40×0×(1^3)+1^4</code><br/>
<code>     -</code><br/>
<code>     6 0000</code><br/>
<code>     5 5536 = 4000×(1^3)×6+600×(1^2)×(6^2)+40×1×(6^3)+6^4</code><br/>
<code>     ------</code><br/>
<code>       4464 0000</code><br/>
<code>       3338 7536 = 4000×(16^3)×2+600*(16^2)×(2^2)+40×16×(2^3)+2^4</code><br/>
<code>       ---------</code><br/>
<code>       1125 2464 0000</code><br/>
<code>       1026 0494 3376 = 4000×(162^3)×6+600×(162^2)×(6^2)+40×162×(6^3)+6^4</code><br/>
<code>       --------------</code><br/>
<code>         99 1969 6624 0000</code><br/>
<code>         86 0185 1379 0625 = 4000×(1626^3)×5+600×(1626^2)×(5^2)+</code><br/>
<code>         -----------------   40×1626×(5^3)+5^4</code><br/>
<code>         13 1784 5244 9375 0000</code><br/>
<code>         12 0489 2414 6927 3201 = 4000×(16265^3)×7+600×(16265^2)×(7^2)+</code><br/>
<code>         ----------------------   40×16265×(7^3)+7^4</code><br/>
<code>          1 1295 2830 2447 6799</code></p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.homeschoolmath.net/teaching/sqr-algorithm-why-works.php">Why the square root algorithm works</a> "Home School Math". Also related pages giving examples of the long-division-like pencil and paper method for square roots.</li>
</ul>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a> <a href="Category:Computer_arithmetic_algorithms" title="wikilink">Category:Computer arithmetic algorithms</a></p>
</body>
</html>
