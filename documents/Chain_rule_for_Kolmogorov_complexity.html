<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="164">Chain rule for Kolmogorov complexity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Chain rule for Kolmogorov complexity</h1>
<hr/>

<p>The chain rule for <a href="Kolmogorov_complexity" title="wikilink">Kolmogorov complexity</a> is an analogue of the chain rule for <a href="information_entropy" title="wikilink">information entropy</a>, which states:</p>

<p>

<math display="block" id="Chain_rule_for_Kolmogorov_complexity:0">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X,Y)=H(X)+H(Y|X)
  </annotation>
 </semantics>
</math>

</p>

<p>That is, the combined <a class="uri" href="randomness" title="wikilink">randomness</a> of two sequences <em>X</em> and <em>Y</em> is the sum of the randomness of <em>X</em> plus whatever randomness is left in <em>Y</em> once we know <em>X</em>. This follows immediately from the definitions of <a href="conditional_entropy" title="wikilink">conditional</a> and <a href="joint_entropy" title="wikilink">joint entropy</a> fact from <a href="probability_theory" title="wikilink">probability theory</a> that the <a href="joint_probability" title="wikilink">joint probability</a> is the product of the <a href="marginal_probability" title="wikilink">marginal</a> and <a href="conditional_probability" title="wikilink">conditional probability</a>:</p>

<p>

<math display="block" id="Chain_rule_for_Kolmogorov_complexity:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X,Y)=P(X)P(Y|X)\,
  </annotation>
 </semantics>
</math>

</p>

<p>The equivalent statement for Kolmogorov complexity does not hold exactly; it is true only up to a <a href="logarithm" title="wikilink">logarithmic</a> term:</p>

<p>

<math display="block" id="Chain_rule_for_Kolmogorov_complexity:2">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">K</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">K</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">K</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">O</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <log></log>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=K(x)+K(y|x)+O(\log(K(x,y)))
  </annotation>
 </semantics>
</math>

</p>

<p>(An exact version, <em>KP</em>(<em>x</em>, <em>y</em>) = <em>KP</em>(<em>x</em>) + <em>KP</em>(<em>y</em>|<em>x</em>*) + O(1), holds for the prefix complexity <em>KP</em>, where <em>x*</em> is a shortest program for <em>x</em>.)</p>

<p>It states that the shortest program printing <em>X</em> and <em>Y</em> is obtained by concatenating a shortest program printing <em>X</em> with a program printing <em>Y</em> given <em>X</em>, plus <a href="Big-O_notation" title="wikilink">at most</a> a logarithmic factor. The results implies that <a href="Mutual_information#Absolute_mutual_information" title="wikilink">algorithmic mutual information</a>, an analogue of mutual information for Kolmogorov complexity is symmetric: <em>I(x:y) = I(y:x) + O(log K(x,y))</em> for all <em>x,y</em>.</p>
<h2 id="proof">Proof</h2>

<p>The ≤ direction is obvious: we can write a program to produce <em>x</em> and <em>y</em> by concatenating a program to produce <em>x</em>, a program to produce <em>y</em> given access to <em>x</em>, and (whence the log term) the length of one of the programs, so that we know where to separate the two programs for <em>x</em> and <em>y</em>|<em>x</em> (log(<em>K</em>(<em>x</em>, <em>y</em>)) upper-bounds this length).</p>

<p>For the ≥ direction, it suffices to show that for all k,l such that k+l = K(x,y) we have that either</p>

<p><code>     </code><em><code>K(x|k,l)</code> <code>≤</code> <code>k</code> <code>+</code> <code>O(1)</code></em><code>   or   </code><em><code>K(y|x,k,l)</code> <code>≤</code> <code>l</code> <code>+</code> <code>O(1)</code></em><code>.</code></p>

<p>Consider the list <em>(a<sub>1</sub>,b<sub>1</sub>), (a<sub>2</sub>,b<sub>2</sub>), ..., (a<sub>e</sub>,b<sub>e</sub>)</em> of all pairs <em>(a,b)</em> produced by programs of length exactly <em>K(x,y)</em> [hence K(a,b) ≤ K(x,y)]. Note that this list</p>
<ul>
<li>contains the pair <em>(x,y)</em>,</li>
<li>can be <a href="recursively_enumerable" title="wikilink">enumerated</a> given <em>k</em> and <em>l</em> (by running all programs of length <em>K(x,y)</em> in parallel),</li>
<li>has at most <em>2<sup>K(x,y)</sup></em> elements (because there are at most 2<sup>n</sup> programs of length n).</li>
</ul>

<p>First, suppose that <em>x</em> appears less than <em>2<sup>l</sup></em> times as first element. We can specify <em>y</em> given <em>x,k,l</em> by enumerating <em>(a<sub>1</sub>,b<sub>1</sub>), (a<sub>2</sub>,b<sub>2</sub>), ...</em> and then selecting <em>(x,y)</em> in the sub-list of pairs <em>(x,b)</em>. By assumption, the index of <em>(x,y)</em> in this sub-list is less than <em>2<sup>l</sup></em> and hence, there is a program for <em>y</em> given <em>x,k,l</em> of length <em>l + O(1)</em>. Now, suppose that <em>x</em> appears at least <em>2<sup>l</sup></em> times as first element. This can happen for at most <em>2<sup>K(x,y)-l</sup> = 2<sup>k</sup></em> different strings. These strings can be enumerated given <em>k,l</em> and hence <em>x</em> can be specified by its index in this enumeration. The corresponding program for <em>x</em> has size <em>k + O(1)</em>. Theorem proved.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Algorithmic_information_theory" title="wikilink">*</a> <a href="Category:Information_theory" title="wikilink">*</a> <a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
</body>
</html>
