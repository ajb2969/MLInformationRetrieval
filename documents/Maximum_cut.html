<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1318">Maximum cut</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Maximum cut</h1>
<hr/>

<p> For a <a href="graph_(mathematics)" title="wikilink">graph</a>, a <strong>maximum cut</strong> is a <a href="cut_(graph_theory)" title="wikilink">cut</a> whose size is at least the size of any other cut. The problem of finding a maximum cut in a graph is known as the <strong>Max-Cut Problem.</strong></p>

<p>The problem can be stated simply as follows. One wants a subset <em>S</em> of the vertex set such that the number of edges between <em>S</em> and the complementary subset is as large as possible.</p>

<p>There is a more advanced version of the problem called <strong>weighted Max-Cut</strong>. In this version each edge has a real number, its <strong>weight</strong>, and the objective is to maximize not the number of edges but the total weight of the edges between <em>S</em> and its complement. The weighted Max-Cut problem is often, but not always, restricted to non-negative weights, because negative weights can change the nature of the problem.</p>
<h2 id="computational-complexity">Computational complexity</h2>

<p>The following <a href="decision_problem" title="wikilink">decision problem</a> related to maximum cuts has been studied widely in <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>:</p>
<dl>
<dd>Given a graph <em>G</em> and an integer <em>k</em>, determine whether there is a cut of size at least <em>k</em> in <em>G</em>.
</dd>
</dl>

<p>This problem is known to be <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>. It is easy to see that the problem is in <a href="NP_(complexity)" title="wikilink">NP</a>: a <em>yes</em> answer is easy to prove by presenting a large enough cut. The NP-completeness of the problem can be shown, for example, by a transformation from <a href="maximum_2-satisfiability" title="wikilink">maximum 2-satisfiability</a> (a restriction of the <a href="maximum_satisfiability_problem" title="wikilink">maximum satisfiability problem</a>).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The weighted version of the decision problem was one of <a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a>;<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Karp showed the NP-completeness by a reduction from the <a href="partition_problem" title="wikilink">partition problem</a>.</p>

<p>The canonical <a href="optimization_problem" title="wikilink">optimization variant</a> of the above decision problem is usually known as the <em>Maximum-Cut Problem</em> or <em>Max-Cut</em> and is defined as:</p>
<dl>
<dd>Given a graph <em>G</em>, find a maximum cut.
</dd>
</dl>
<h2 id="polynomial-time-algorithms">Polynomial-time algorithms</h2>

<p>As the Max-Cut Problem is NP-hard, no polynomial-time algorithms for Max-Cut in general graphs are known.</p>

<p>However, in <a href="planar_graph" title="wikilink">planar graphs</a>, the Maximum-Cut Problem is dual to the <a href="route_inspection_problem" title="wikilink">route inspection problem</a> (the problem of finding a shortest tour that visits each edge of a graph at least once), in the sense that the edges that do not belong to a maximum cut of a graph <em>G</em> are the duals of the edges that are doubled in an optimal inspection tour of the <a href="dual_graph" title="wikilink">dual graph</a> of <em>G</em>. The optimal inspection tour forms a self-intersecting curve that separates the plane into two subsets, the subset of points for which the <a href="winding_number" title="wikilink">winding number</a> of the curve is even and the subset for which the winding number is odd; these two subsets form a cut that includes all of the edges whose duals appear an odd number of times in the tour. The route inspection problem may be solved in polynomial time, and this duality allows the maximum cut problem to also be solved in polynomial time for planar graphs.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The Maximum-Bisection problem is known however to be NP-hard.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="approximation-algorithms">Approximation algorithms</h2>

<p>The Max-Cut Problem is <a href="Constant-factor_approximation_algorithm" title="wikilink">APX-hard</a>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> meaning that there is no polynomial-time approximation scheme (PTAS), arbitrarily close to the optimal solution, for it, unless P = NP. Thus, every polynomial-time approximation algorithm achieves an <a href="approximation_ratio" title="wikilink">approximation ratio</a> strictly less than one.</p>

<p>There is a simple <a href="Randomized_algorithm" title="wikilink">randomized</a> 0.5-<a href="approximation_algorithm" title="wikilink">approximation algorithm</a>: for each vertex flip a coin to decide to which half of the partition to assign it.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> In expectation, half of the edges are cut edges. This algorithm can be <a href="derandomization" title="wikilink">derandomized</a> with the <a href="method_of_conditional_probabilities" title="wikilink">method of conditional probabilities</a>; therefore there is a simple deterministic polynomial-time 0.5-approximation algorithm as well.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> One such algorithm starts with an arbitrary partition of the vertices of the given graph 

<math display="inline" id="Maximum_cut:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 and repeatedly moves one vertex at a time from one side of the partition to the other, improving the solution at each step, until no more improvements of this type can be made. The number of iterations is at most 

<math display="inline" id="Maximum_cut:1">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>E</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E|
  </annotation>
 </semantics>
</math>

 because the algorithm improves the cut by at least one edge at each step. When the algorithm terminates, at least half of the edges incident to every vertex belong to the cut, for otherwise moving the vertex would improve the cut. Therefore the cut includes at least 

<math display="inline" id="Maximum_cut:2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>E</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <abs></abs>
     <ci>E</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E|/2
  </annotation>
 </semantics>
</math>

 edges.</p>

<p>The polynomial-time approximation algorithm for Max-Cut with the best known approximation ratio is a method by Goemans and Williamson using <a href="semidefinite_programming" title="wikilink">semidefinite programming</a> and <a href="randomized_rounding" title="wikilink">randomized rounding</a> that achieves an approximation ratio 

<math display="inline" id="Maximum_cut:3">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>≈</mo>
   <mn>0.878</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>α</ci>
    <cn type="float">0.878</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\approx 0.878
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Maximum_cut:4">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>2</mn>
     <mi>π</mi>
    </mfrac>
    <mrow>
     <msub>
      <mi>min</mi>
      <mrow>
       <mn>0</mn>
       <mo>≤</mo>
       <mi>θ</mi>
       <mo>≤</mo>
       <mi>π</mi>
      </mrow>
     </msub>
     <mfrac>
      <mi>θ</mi>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mi>cos</mi>
        <mi>θ</mi>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <cn type="integer">0</cn>
         <ci>θ</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>π</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>θ</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <cos></cos>
         <ci>θ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=\tfrac{2}{\pi}\min_{0\leq\theta\leq\pi}\tfrac{\theta}{1-\cos\theta}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> If the <a href="unique_games_conjecture" title="wikilink">unique games conjecture</a> is true, this is the best possible approximation ratio for maximum cut.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Without such unproven assumptions, it has been proven to be NP-hard to approximate the max-cut value with an approximation ratio better than 

<math display="inline" id="Maximum_cut:5">
 <semantics>
  <mrow>
   <mfrac>
    <mn>16</mn>
    <mn>17</mn>
   </mfrac>
   <mo>≈</mo>
   <mn>0.941</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <cn type="integer">16</cn>
     <cn type="integer">17</cn>
    </apply>
    <cn type="float">0.941</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{16}{17}\approx 0.941
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="maximum-bipartite-subgraph">Maximum bipartite subgraph</h2>

<p>A cut is a <a href="bipartite_graph" title="wikilink">bipartite graph</a>. The Max-Cut Problem is essentially the same as the problem of finding a bipartite <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraph</a> with the most edges.</p>

<p>Let 

<math display="inline" id="Maximum_cut:6">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 be a graph and let 

<math display="inline" id="Maximum_cut:7">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>X</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(V,X)
  </annotation>
 </semantics>
</math>

 be a bipartite subgraph of <em>G</em>. Then there is a partition (<em>S</em>, <em>T</em>) of <em>V</em> such that each edge in <em>X</em> has one endpoint in <em>S</em> and another endpoint in <em>T</em>. Put otherwise, there is a <a href="cut_(graph_theory)" title="wikilink">cut</a> in <em>H</em> such that the set of cut edges contains <em>X</em>. Therefore there is a cut in <em>G</em> such that the set of cut edges is a superset of <em>X</em>.</p>

<p>Conversely, let 

<math display="inline" id="Maximum_cut:8">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 be a graph and let <em>X</em> be a set of cut edges. Then 

<math display="inline" id="Maximum_cut:9">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>X</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(V,X)
  </annotation>
 </semantics>
</math>

 is a bipartite subgraph of <em>H</em>.</p>

<p>In summary, if there is a bipartite subgraph with <em>k</em> edges, there is a cut with at least <em>k</em> cut edges, and if there is a cut with <em>k</em> cut edges, there is a bipartite subgraph with <em>k</em> edges. Therefore the problem of finding a <strong>maximum bipartite subgraph</strong> is essentially the same as the problem of finding a maximum cut.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The same results on NP-hardness, inapproximability and approximability apply to both the maximum cut problem and the maximum bipartite subgraph problem.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Minimum_cut" title="wikilink">Minimum cut</a></li>
<li><a href="Minimum_k-cut" title="wikilink">Minimum k-cut</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
</ul>
<dl>
<dd><dl>
<dd>Maximum cut (optimisation version) is the problem ND14 in Appendix B (page 399).
</dd>
</dl>
</dd>
</dl>
<ul>
<li>

<p>.</p></li>
</ul>
<dl>
<dd><dl>
<dd>Maximum cut (decision version) is the problem ND16 in Appendix A2.2.
</dd>
<dd>Maximum bipartite subgraph (decision version) is the problem GT25 in Appendix A1.2.
</dd>
</dl>
</dd>
</dl>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Pierluigi Crescenzi, Viggo Kann, Magnús Halldórsson, Marek Karpinski, Gerhard Woeginger (2000), <a href="http://www.nada.kth.se/~viggo/wwwcompendium/node85.html">"Maximum Cut"</a>, in <a href="http://www.nada.kth.se/~viggo/wwwcompendium/">"A compendium of NP optimization problems"</a>.</li>
<li>Andrea Casini, Nicola Rebagliati (2012), <a href="http://code.google.com/p/maxcutpy/">"A Python library for solving Max Cut"</a></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_theory_objects" title="wikilink">Category:Graph theory objects</a> <a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a> <a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a> <a href="Category:Computational_problems_in_graph_theory" title="wikilink">Category:Computational problems in graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5"> prove <a class="uri" href="MaxSNP" title="wikilink">MaxSNP</a>-completeness.<a href="#fnref5">↩</a></li>
<li id="fn6">, Sect. 6.2.<a href="#fnref6">↩</a></li>
<li id="fn7">, Sect. 5.1.<a href="#fnref7">↩</a></li>
<li id="fn8">, Sect. 6.3.<a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">.<a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
