<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="868">CORDIC</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>CORDIC</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>CORDIC</strong> (for <strong>CO</strong>ordinate <strong>R</strong>otation <strong>DI</strong>gital <strong>C</strong>omputer), also known as the <strong>digit-by-digit method</strong> and <strong>Volder's algorithm</strong>, is a simple and efficient <a class="uri" href="algorithm" title="wikilink">algorithm</a> to calculate <a href="hyperbolic_function" title="wikilink">hyperbolic</a> and <a href="trigonometric_function" title="wikilink">trigonometric functions</a>. It is commonly used when no <a href="hardware_multiplier" title="wikilink">hardware multiplier</a> is available (e.g. in simple <a href="microcontroller" title="wikilink">microcontrollers</a> and <a href="FPGA" title="wikilink">FPGAs</a>) as the only operations it requires are addition, subtraction, <a class="uri" href="bitshift" title="wikilink">bitshift</a> and <a href="lookup_table" title="wikilink">table lookup</a>.</p>
<h2 id="origins">Origins</h2>

<p>The modern CORDIC algorithm was first described in 1959 by <a href="Jack_E._Volder" title="wikilink">Jack E. Volder</a>. It was developed at the aeroelectronics department of <a class="uri" href="Convair" title="wikilink">Convair</a> to replace the <a href="analog_electronics" title="wikilink">analog</a> <a href="resolver_(electrical)" title="wikilink">resolver</a> in the <a href="B-58_Hustler" title="wikilink">B-58</a> bomber's <a class="uri" href="navigation" title="wikilink">navigation</a> computer.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Although CORDIC is similar to mathematical techniques published by <a href="Henry_Briggs_(mathematician)" title="wikilink">Henry Briggs</a> as early as 1624, it is optimized for low complexity finite state CPUs.</p>

<p><a href="John_Stephen_Walther" title="wikilink">John Stephen Walther</a> at <a class="uri" href="Hewlett-Packard" title="wikilink">Hewlett-Packard</a> further generalized the algorithm, allowing it to calculate <a href="hyperbolic_function" title="wikilink">hyperbolic</a> and <a href="exponential_function" title="wikilink">exponential functions</a>, <a href="logarithm" title="wikilink">logarithms</a>, <a href="multiplication" title="wikilink">multiplications</a>, <a href="Division_(mathematics)" title="wikilink">divisions</a>, and <a href="square_root" title="wikilink">square roots</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The CORDIC <a class="uri" href="subroutines" title="wikilink">subroutines</a> for trigonometric and hyperbolic functions can share most of their code.</p>

<p>Originally, CORDIC was implemented using the <a href="binary_numeral_system" title="wikilink">binary numeral system</a>. In the 1970s, <a class="uri" href="decimal" title="wikilink">decimal</a> CORDIC became widely used in pocket <a href="calculator" title="wikilink">calculators</a>, most of which operate in <a href="binary-coded_decimal" title="wikilink">binary-coded decimal</a> (BCD) rather than binary. This change in the input and output format did not alter CORDIC's core calculation algorithms. CORDIC is particularly well-suited for handheld calculators, in which low cost – and thus low chip gate count – is much more important than speed.</p>

<p>CORDIC has been implemented in the cores of some <a class="uri" href="x86" title="wikilink">x86</a> CPUs for some kinds of <a href="floating_point" title="wikilink">floating point</a> instructions, mainly as a way to reduce the gate counts (and complexity) of the <a href="floating-point_unit" title="wikilink">FPU</a> subsystem. </p>
<h2 id="applications">Applications</h2>

<p>CORDIC uses simple shift-add operations for several computing tasks such as the calculation of trigonometric, hyperbolic and logarithmic functions, real and complex multiplications, division, square-root calculation, solution of linear systems, eigenvalue estimation, singular value decomposition, QR factorization and many others. As a consequence, CORDIC has been used for applications in diverse areas such as signal and image processing, communication systems, robotics and 3-D graphics apart from general scientific and technical computation.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="hardware">Hardware</h3>

<p>CORDIC is generally faster than other approaches when a hardware multiplier is not available (<em>e.g.</em>, a microcontroller), or when the number of gates required to implement the functions it supports should be minimized (<em>e.g.</em>, in an <a class="uri" href="FPGA" title="wikilink">FPGA</a>).</p>

<p>On the other hand, when a hardware multiplier is available (<em>e.g.</em>, in a DSP microprocessor), table-lookup methods and <a href="power_series" title="wikilink">power series</a> are generally faster than CORDIC. In recent years, the CORDIC algorithm has been used extensively for various biomedical applications, especially in <a class="uri" href="FPGA" title="wikilink">FPGA</a> implementations.</p>
<h3 id="software">Software</h3>

<p>Many older systems with integer-only CPUs have implemented CORDIC to varying extents as part of their IEEE Floating Point libraries. As most modern general-purpose CPUs have floating-point registers with common operations such as add, subtract, multiply, divide, sin, cos, square root, log10, natural log, the need to implement CORDIC in them with software is nearly non-existent. Only microcontroller or special safety and time-constrained software applications would need to consider using CORDIC.</p>
<h2 id="mode-of-operation-rotation-mode">Mode of operation: rotation mode</h2>

<p>CORDIC can be used to calculate a number of different functions. This explanation shows how to use CORDIC in <em>rotation mode</em> to calculate the sine and cosine of an angle, and assumes the desired angle is given in radians and represented in a <a href="Fixed-point_arithmetic" title="wikilink">fixed point</a> format. To determine the sine or cosine for an angle 

<math display="inline" id="CORDIC:0">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

, the <em>y</em> or <em>x</em> coordinate of a point on the <a href="unit_circle" title="wikilink">unit circle</a> corresponding to the desired angle must be found. Using CORDIC, we would start with the vector 

<math display="inline" id="CORDIC:1">
 <semantics>
  <msub>
   <mi>v</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{0}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="CORDIC:2">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">0</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{0}=\begin{bmatrix}1\\
0\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p> In the first iteration, this vector is rotated 45° counterclockwise to get the vector 

<math display="inline" id="CORDIC:3">
 <semantics>
  <msub>
   <mi>v</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1}
  </annotation>
 </semantics>
</math>


. Successive iterations rotate the vector in one or the other direction by size-decreasing steps, until the desired angle has been achieved. Step <em>i</em> size is arctan(1/(2<sup><em>i</em>−1</sup>)) for <em>i</em> = 1, 2, 3, ….</p>

<p>More formally, every iteration calculates a rotation, which is performed by multiplying the vector 

<math display="inline" id="CORDIC:4">
 <semantics>
  <msub>
   <mi>v</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i-1}
  </annotation>
 </semantics>
</math>

 with the <a href="rotation_matrix" title="wikilink">rotation matrix</a> 

<math display="inline" id="CORDIC:5">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="CORDIC:6">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>v</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}=R_{i}v_{i-1}
  </annotation>
 </semantics>
</math>

</p>

<p>The rotation matrix is given by:</p>

<p>

<math display="block" id="CORDIC:7">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>cos</mi>
        <msub>
         <mi>γ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>sin</mi>
         <msub>
          <mi>γ</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>sin</mi>
        <msub>
         <mi>γ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>cos</mi>
        <msub>
         <mi>γ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <cos></cos>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <sin></sin>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>γ</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <sin></sin>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <cos></cos>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}=\begin{bmatrix}\cos\gamma_{i}&-\sin\gamma_{i}\\
\sin\gamma_{i}&\cos\gamma_{i}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Using the following two <a href="List_of_trigonometric_identities#Trigonometric_conversions" title="wikilink">trigonometric identities</a>:</p>

<p>

<math display="inline" id="CORDIC:8">
 <semantics>
  <mrow>
   <mi>cos</mi>
   <msub>
    <mi>γ</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <cos></cos>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\cos\gamma_{i}
  </annotation>
 </semantics>
</math>


</p>

<p>the rotation matrix becomes:</p>

<p>

<math display="block" id="CORDIC:9">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <msup>
         <mi>tan</mi>
         <mn>2</mn>
        </msup>
        <msub>
         <mi>γ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </msqrt>
    </mfrac>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>tan</mi>
          <msub>
           <mi>γ</mi>
           <mi>i</mi>
          </msub>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>tan</mi>
         <msub>
          <mi>γ</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <tan></tan>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>γ</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <apply>
         <tan></tan>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>γ</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <tan></tan>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>γ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}={1\over\sqrt{1+\tan^{2}\gamma_{i}}}\begin{bmatrix}1&-\tan\gamma_{i}\\
\tan\gamma_{i}&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The expression for the rotated vector 

<math display="inline" id="CORDIC:10">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>v</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}=R_{i}v_{i-1}
  </annotation>
 </semantics>
</math>

 then becomes:</p>

<p>

<math display="block" id="CORDIC:11">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <msup>
         <mi>tan</mi>
         <mn>2</mn>
        </msup>
        <msub>
         <mi>γ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </msqrt>
    </mfrac>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>tan</mi>
          <msub>
           <mi>γ</mi>
           <mi>i</mi>
          </msub>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>tan</mi>
         <msub>
          <mi>γ</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>y</mi>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <tan></tan>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>γ</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <apply>
         <tan></tan>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>γ</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <tan></tan>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>γ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}={1\over\sqrt{1+\tan^{2}\gamma_{i}}}\begin{bmatrix}1&-\tan\gamma_{i}\\
\tan\gamma_{i}&1\end{bmatrix}\begin{bmatrix}x_{i-1}\\
y_{i-1}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="CORDIC:12">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CORDIC:13">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i-1}
  </annotation>
 </semantics>
</math>


 are the components of 

<math display="inline" id="CORDIC:14">
 <semantics>
  <msub>
   <mi>v</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i-1}
  </annotation>
 </semantics>
</math>

. Restricting the angles 

<math display="inline" id="CORDIC:15">
 <semantics>
  <msub>
   <mi>γ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{i}
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="CORDIC:16">
 <semantics>
  <mrow>
   <mi>tan</mi>
   <msub>
    <mi>γ</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <tan></tan>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tan\gamma_{i}
  </annotation>
 </semantics>
</math>

 takes on the values 

<math display="inline" id="CORDIC:17">
 <semantics>
  <mrow>
   <mo>±</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mi>i</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm 2^{-i}
  </annotation>
 </semantics>
</math>

, the multiplication with the tangent can be replaced by a division by a power of two, which is efficiently done in digital computer hardware using a <a href="bit_shift" title="wikilink">bit shift</a>. The expression then becomes:</p>

<p>

<math display="block" id="CORDIC:18">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>K</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>σ</mi>
           <mi>i</mi>
          </msub>
          <msup>
           <mn>2</mn>
           <mrow>
            <mo>-</mo>
            <mi>i</mi>
           </mrow>
          </msup>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <msub>
          <mi>σ</mi>
          <mi>i</mi>
         </msub>
         <msup>
          <mn>2</mn>
          <mrow>
           <mo>-</mo>
           <mi>i</mi>
          </mrow>
         </msup>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>y</mi>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>i</ci>
     </apply>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <apply>
           <minus></minus>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <apply>
          <minus></minus>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}=K_{i}\begin{bmatrix}1&-\sigma_{i}2^{-i}\\
\sigma_{i}2^{-i}&1\end{bmatrix}\begin{bmatrix}x_{i-1}\\
y_{i-1}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="CORDIC:19">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <mi>i</mi>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}={1\over\sqrt{1+2^{-2i}}}
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="CORDIC:20">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

 can have the values of −1 or 1, and is used to determine the direction of the rotation; if the angle 

<math display="inline" id="CORDIC:21">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}
  </annotation>
 </semantics>
</math>

 is positive then 

<math display="inline" id="CORDIC:22">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

 is +1, otherwise it is −1.</p>

<p>

<math display="inline" id="CORDIC:23">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}
  </annotation>
 </semantics>
</math>


 can be ignored in the iterative process and then applied afterward with a scaling factor:</p>

<p>

<math display="block" id="CORDIC:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <msub>
     <mi>K</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <msup>
        <mn>2</mn>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <mi>i</mi>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(n)=\prod_{i=0}^{n-1}K_{i}=\prod_{i=0}^{n-1}1/\sqrt{1+2^{-2i}}
  </annotation>
 </semantics>
</math>

</p>

<p>which is calculated in advance and stored in a table, or as a single constant if the number of iterations is fixed. This correction could also be made in advance, by scaling 

<math display="inline" id="CORDIC:25">
 <semantics>
  <msub>
   <mi>v</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{0}
  </annotation>
 </semantics>
</math>

 and hence saving a multiplication. Additionally it can be noted that:</p>

<p>

<math display="block" id="CORDIC:26">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mn>0.6072529350088812561694</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>K</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <limit></limit>
       <apply>
        <ci>normal-→</ci>
        <ci>n</ci>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>K</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <cn type="float">0.6072529350088812561694</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=\lim_{n\to\infty}K(n)\approx 0.6072529350088812561694
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>to allow further reduction of the algorithm's complexity.</p>

<p>After a sufficient number of iterations, the vector's angle will be close to the wanted angle 

<math display="inline" id="CORDIC:27">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

. For most ordinary purposes, 40 iterations (<em>n</em> = 40) is sufficient to obtain the correct result to the 10th decimal place.</p>

<p>The only task left is to determine if the rotation should be clockwise or counterclockwise at each iteration (choosing the value of 

<math display="inline" id="CORDIC:28">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>


). This is done by keeping track of how much the angle was rotated at each iteration and subtracting that from the wanted angle; then in order to get closer to the wanted angle 

<math display="inline" id="CORDIC:29">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="CORDIC:30">
 <semantics>
  <msub>
   <mi>β</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{n+1}
  </annotation>
 </semantics>
</math>

 is positive, the rotation is clockwise, otherwise it is negative and the rotation is counterclockwise.</p>

<p>

<math display="block" id="CORDIC:31">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>β</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>σ</mi>
    <mi>i</mi>
   </msub>
   <msub>
    <mi>γ</mi>
    <mi>i</mi>
   </msub>
   <mo>.</mo>
   <msub>
    <mi>γ</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mi>arctan</mi>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mi>i</mi>
    </mrow>
   </msup>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-.</ci>
    <ci></ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <arctan></arctan>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}=\beta_{i-1}-\sigma_{i}\gamma_{i}.\quad\gamma_{i}=\arctan 2^{-i},
  </annotation>
 </semantics>
</math>

</p>

<p>The values of 

<math display="inline" id="CORDIC:32">
 <semantics>
  <msub>
   <mi>γ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{n}
  </annotation>
 </semantics>
</math>

 must also be precomputed and stored. But for small angles, 

<math display="inline" id="CORDIC:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>arctan</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>γ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>γ</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <arctan></arctan>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arctan(\gamma_{n})=\gamma_{n}
  </annotation>
 </semantics>
</math>


 in fixed point representation, reducing table size.</p>

<p>As can be seen in the illustration above, the sine of the angle 

<math display="inline" id="CORDIC:34">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is the <em>y</em> coordinate of the final vector 

<math display="inline" id="CORDIC:35">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{n}
  </annotation>
 </semantics>
</math>

, while the <em>x</em> coordinate is the cosine value.</p>
<h2 id="mode-of-operation-vectoring-mode">Mode of operation: vectoring mode</h2>

<p>The rotation-mode algorithm described above can rotate any vector (not only a unit vector aligned along the x axis) by an angle between –90° and +90°. Decisions on the direction of the rotation depend on 

<math display="inline" id="CORDIC:36">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}
  </annotation>
 </semantics>
</math>

 being positive or negative.</p>

<p>The vectoring-mode of operation requires a slight modification of the algorithm. It starts with a vector the x coordinate of which is positive and the y coordinate is arbitrary. Successive rotations have the goal of rotating the vector to the x axis (and therefore reducing the y coordinate to zero). At each step, the value of <em>y</em> determines the direction of the rotation. The final value of 

<math display="inline" id="CORDIC:37">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}
  </annotation>
 </semantics>
</math>

 contains the total angle of rotation. The final value of <em>x</em> will be the magnitude of the original vector scaled by <em>K</em>. So, an obvious use of the vectoring mode is the transformation from rectangular to polar coordinates.</p>
<h2 id="software-implementation">Software implementation</h2>

<p>The following is a <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>/<a href="GNU_Octave" title="wikilink">GNU Octave</a> implementation of CORDIC that does not rely on any transcendental functions except in the precomputation of tables. If the number of iterations <em>n</em> is predetermined, then the second table can be replaced by a single constant. The two-by-two <a href="matrix_multiplication" title="wikilink">matrix multiplication</a> represents a pair of simple shifts and adds. With MATLAB's standard double-precision arithmetic and "format long" printout, the results increase in accuracy for <em>n</em> up to about 48.</p>
<div class="sourceCode"><pre class="sourceCode MATLAB"><code class="sourceCode matlab">function v = cordic(beta,n)
<span class="co">% This function computes v = [cos(beta), sin(beta)] (beta in radians)</span>
<span class="co">% using n iterations. Increasing n will increase the precision.</span>

if beta &lt; -pi/<span class="fl">2</span> || beta &gt; pi/<span class="fl">2</span>
    if beta &lt; <span class="fl">0</span>
        v = cordic(beta + pi, n);
    else
        v = cordic(beta - pi, n);
    end
    v = -v; <span class="co">% flip the sign for second or third quadrant</span>
    return
end

<span class="co">% Initialization of tables of constants used by CORDIC</span>
<span class="co">% need a table of arctangents of negative powers of two, in radians:</span>
<span class="co">% angles = atan(2.^-(0:27));</span>
angles =  [  ...
    <span class="fl">0.78539816339745</span>   <span class="fl">0.46364760900081</span>   <span class="fl">0.24497866312686</span>   <span class="fl">0.12435499454676</span> ...
    <span class="fl">0.06241880999596</span>   <span class="fl">0.03123983343027</span>   <span class="fl">0.01562372862048</span>   <span class="fl">0.00781234106010</span> ...
    <span class="fl">0.00390623013197</span>   <span class="fl">0.00195312251648</span>   <span class="fl">0.00097656218956</span>   <span class="fl">0.00048828121119</span> ...
    <span class="fl">0.00024414062015</span>   <span class="fl">0.00012207031189</span>   <span class="fl">0.00006103515617</span>   <span class="fl">0.00003051757812</span> ...
    <span class="fl">0.00001525878906</span>   <span class="fl">0.00000762939453</span>   <span class="fl">0.00000381469727</span>   <span class="fl">0.00000190734863</span> ...
    <span class="fl">0.00000095367432</span>   <span class="fl">0.00000047683716</span>   <span class="fl">0.00000023841858</span>   <span class="fl">0.00000011920929</span> ...
    <span class="fl">0.00000005960464</span>   <span class="fl">0.00000002980232</span>   <span class="fl">0.00000001490116</span>   <span class="fl">0.00000000745058</span> ];
<span class="co">% and a table of products of reciprocal lengths of vectors [1, 2^-2j]:</span>
<span class="co">% Kvalues = cumprod(1./abs(1 + 1j*2.^(-(0:23))))</span>
Kvalues = [ ...
    <span class="fl">0.70710678118655</span>   <span class="fl">0.63245553203368</span>   <span class="fl">0.61357199107790</span>   <span class="fl">0.60883391251775</span> ...
    <span class="fl">0.60764825625617</span>   <span class="fl">0.60735177014130</span>   <span class="fl">0.60727764409353</span>   <span class="fl">0.60725911229889</span> ...
    <span class="fl">0.60725447933256</span>   <span class="fl">0.60725332108988</span>   <span class="fl">0.60725303152913</span>   <span class="fl">0.60725295913894</span> ...
    <span class="fl">0.60725294104140</span>   <span class="fl">0.60725293651701</span>   <span class="fl">0.60725293538591</span>   <span class="fl">0.60725293510314</span> ...
    <span class="fl">0.60725293503245</span>   <span class="fl">0.60725293501477</span>   <span class="fl">0.60725293501035</span>   <span class="fl">0.60725293500925</span> ...
    <span class="fl">0.60725293500897</span>   <span class="fl">0.60725293500890</span>   <span class="fl">0.60725293500889</span>   <span class="fl">0.60725293500888</span> ];
Kn = Kvalues(min(n, length(Kvalues)));

<span class="co">% Initialize loop variables:</span>
v = [<span class="fl">1</span>;<span class="fl">0</span>]; <span class="co">% start with 2-vector cosine and sine of zero</span>
poweroftwo = <span class="fl">1</span>;
angle = angles(<span class="fl">1</span>);

<span class="co">% Iterations</span>
for j = <span class="fl">0</span>:n-<span class="fl">1</span>;
    if beta &lt; <span class="fl">0</span>
        sigma = -<span class="fl">1</span>;
    else
        sigma = <span class="fl">1</span>;
    end
    factor = sigma * poweroftwo;
    R = [<span class="fl">1</span>, -factor; factor, <span class="fl">1</span>];
    v = R * v; <span class="co">% 2-by-2 matrix multiply</span>
    beta = beta - sigma * angle; <span class="co">% update the remaining angle</span>
    poweroftwo = poweroftwo / <span class="fl">2</span>;
    <span class="co">% update the angle from table, or eventually by just dividing by two</span>
    if j+<span class="fl">2</span> &gt; length(angles)
        angle = angle / <span class="fl">2</span>;
    else
        angle = angles(j+<span class="fl">2</span>);
    end
end

<span class="co">% Adjust length of output vector to be [cos(beta), sin(beta)]:</span>
v = v * Kn;
return

endfunction</code></pre></div>
<h2 id="hardware-implementation">Hardware implementation</h2>

<p>The number of <a href="logic_gate" title="wikilink">logic gates</a> for the implementation of a CORDIC is roughly comparable to the number required for a multiplier as both require combinations of shifts and additions. The choice for a multiplier-based or CORDIC-based implementation will depend on the context. The multiplication of two <a href="complex_number" title="wikilink">complex numbers</a> represented by their real and imaginary components (rectangular coordinates), for example, requires 4 multiplications, but could be realized by a single CORDIC operating on complex numbers represented by their polar coordinates, especially if the magnitude of the numbers is not relevant (multiplying a complex vector with a vector on the unit circle actually amounts to a rotation). CORDICs are often used in circuits for telecommunications such as <a href="digital_down_converter" title="wikilink">digital down converters</a>.</p>
<h2 id="related-algorithms">Related algorithms</h2>

<p>CORDIC is part of the class of "shift-and-add" algorithms, as are the logarithm and exponential algorithms derived from Henry Briggs' work. Another shift-and-add algorithm which can be used for computing many elementary functions is the <a href="BKM_algorithm" title="wikilink">BKM algorithm</a>, which is a generalization of the logarithm and exponential algorithms to the complex plane. For instance, BKM can be used to compute the sine and cosine of a real angle 

<math display="inline" id="CORDIC:38">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 (in radians) by computing the exponential of 

<math display="inline" id="CORDIC:39">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">0</cn>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0+ix,
  </annotation>
 </semantics>
</math>

 which is 

<math display="inline" id="CORDIC:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>cos</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <mrow>
      <mi>sin</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <cos></cos>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <apply>
      <sin></sin>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos x+i\sin x.
  </annotation>
 </semantics>
</math>

 The BKM algorithm is slightly more complex than CORDIC, but has the advantage that it does not need a scaling factor (K).</p>
<h2 id="history">History</h2>

<p>Volder was inspired by the following formula in the 1946 edition of the <a href="CRC_Handbook_of_Chemistry_and_Physics" title="wikilink">CRC Handbook of Chemistry and Physics</a>:</p>

<p>

<math display="inline" id="CORDIC:41">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mi>n</mi>
   </msub>
   <mi>R</mi>
   <mrow>
    <mi>sin</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>θ</mi>
      <mo>±</mo>
      <mi>ϕ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>n</ci>
    </apply>
    <ci>R</ci>
    <apply>
     <sin></sin>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <ci>θ</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle K_{n}R\sin(\theta\pm\phi)
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="CORDIC:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>n</mi>
     </msub>
     <mo>=</mo>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <msup>
        <mn>2</mn>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <mi>n</mi>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </msqrt>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>tan</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ϕ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mi>n</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <tan></tan>
      <ci>ϕ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{n}=\sqrt{1+2^{-2n}},\tan(\phi)=2^{-n}.
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Some of the prominent early applications of CORDIC were in the Convair navigation computers CORDIC I to CORDIC III,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> the Hewlett-Packard <a class="uri" href="HP-9100" title="wikilink">HP-9100</a> and <a class="uri" href="HP-35" title="wikilink">HP-35</a> calculators,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> the <a class="uri" href="Intel" title="wikilink">Intel</a> <a class="uri" href="80x87" title="wikilink">80x87</a> coprocessor series until <a href="Intel_80486" title="wikilink">Intel 80486</a>, and <a href="Motorola_68881" title="wikilink">Motorola 68881</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Decimal CORDIC was first suggested by Hermann Schmid and Anthony Bogacki.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.jacques-laporte.org/Volder_CORDIC.pdf">Jack E. Volder, <em>The CORDIC Trigonometric Computing Technique, IRE Transactions on Electronic Computers</em>, pp. 330–334, September 1959</a></li>
<li>Daggett, D. H., <em>Decimal-Binary conversions in CORDIC</em>, IRE Transactions on Electronic Computers, Vol. EC-8 #5, pp. 335–339, IRE, September 1959</li>
<li><a href="http://www.jacques-laporte.org/Welther-Unified%20Algorithm.pdf">John S. Walther, <em>A Unified Algorithm for Elementary Functions</em>, Proc. of Spring Joint Computer Conference, pp. 379–385, May 1971</a></li>
<li><a href="http://www1.i2r.a-star.edu.sg/~pkmeher/papers/CORDIC-TUT-TACS-I.pdf">P. K. Meher, J. Valls, T-B Juang, K. Sridharan, and K. Maharatna, ‘50 Years of CORDIC: Algorithms, Architectures and Applications,’ IEEE Transactions on Circuits &amp; Systems-I: Regular Papers, vol.56, no.9, pp. 1893–1907, September 2009.</a></li>
<li><a href="http://www1.i2r.a-star.edu.sg/~pkmeher/papers/FRC-TCAS-I.pdf">P. K. Meher and S. Y. Park, ‘CORDIC Designs for Fixed Angle of Rotation,’ IEEE Transactions on VLSI Systems, vol.21, no.2, pp. 217–228, February 2013.</a></li>
<li><a href="http://www.jacques-laporte.org/Meggitt_62.pdf">J. E. Meggitt, <em>Pseudo Division and Pseudo Multiplication Processes</em>, IBM Journal, April 1962</a></li>
<li><a href="http://baykov.de/cordic1972.htm">Vladimir Baykov, <em>Problems of Elementary Functions Evaluation Based on Digit by Digit (CORDIC) Technique</em>, PhD thesis, Leningrad State Univ. of Electrical Eng., 1972</a></li>
<li>Schmid, Hermann, <em>Decimal computation.</em> New York, Wiley, 1974</li>
<li><a href="http://baykov.de/cordic1975.htm">V.D.Baykov,V.B.Smolov, <em>Hardware implementation of elementary functions in computers</em>, Leningrad State University, 1975, 96p.</a>*<a href="http://www.umup.narod.ru/1115.zip">Full Text</a></li>
<li>Senzig, Don, <em>Calculator Algorithms</em>, IEEE Compcon Reader Digest, IEEE Catalog No. 75 CH 0920-9C, pp. 139–141, IEEE, 1975.</li>
<li>V.D.Baykov,S.A.Seljutin, <em>Elementary functions evaluation in microcalculators</em>, Moscow, Radio &amp; svjaz,1982,64p.''</li>
<li><a href="http://baykov.de/cordic1985.htm">Vladimir D.Baykov, Vladimir B.Smolov, Special-purpose processors: iterative algorithms and structures, Moscow, Radio &amp; svjaz, 1985, 288 pages ''</a></li>
<li>M. E. Frerking, <em>Digital Signal Processing in Communication Systems, 1994</em></li>
<li>Vitit Kantabutra, <em>On hardware for computing <a href="exponential_function" title="wikilink">exponential</a> and <a href="trigonometric_function" title="wikilink">trigonometric functions</a></em>, IEEE Trans. Computers 45 (3), 328–339 (1996)</li>
<li><a href="http://www.andraka.com/files/crdcsrvy.pdf">Andraka, Ray, <em>A survey of CORDIC algorithms for FPGA based computers</em></a></li>
<li>Henry Briggs, <em>Arithmetica Logarithmica.</em> London, 1624, folio</li>
<li><a href="http://cordic-bibliography.blogspot.com/2011/07/cordic-bibliography-site-revive.html"><em>CORDIC Bibliography Site</em></a>, Shaoyun Wang, July 2011</li>
<li><a href="http://www.jacques-laporte.org/TheSecretOfTheAlgorithms.htm"><em>The secret of the algorithms</em></a>, Jacques Laporte, Paris 1981</li>
<li><a href="http://www.jacques-laporte.org/digit_by_digit.htm"><em>Digit by digit methods</em></a>, Jacques Laporte, Paris 2006</li>
<li>Ayan Banerjee, [<a class="uri" href="http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6V0X-4313PR1-1&amp;_user=10&amp;_rdoc=1&amp;_fmt">http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6V0X-4313PR1-1&amp;_user=10&amp;_rdoc=1&amp;_fmt</a>=&amp;_orig=search&amp;_sort=d&amp;_docanchor=&amp;view;=c&amp;_acct=C000050221&amp;_version=1&amp;_urlVersion=0&amp;_userid=10&amp;md5;=c85888a82db1f3b515b4a8d2a529624b FPGA realization of a CORDIC based FFT processor for biomedical signal processing], Kharagpur, 2001</li>
<li><a href="http://www.hindawi.com/journals/vlsi/2010/794891.html"><em>CORDIC Architectures: A Survey</em></a>, B. Lakshmi and A. S. Dhar, Journal: VLSI Design, January 2010</li>
<li><a href="http://cockrum.net/Cockrum_Fall_2008_Final_Paper.pdf"><em>Implementation of a CORDIC Algorithm in a Digital Down-Converter</em></a>, C. Cockrum, Fall 2008</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://cordic-bibliography.blogspot.com/2011/07/cordic-bibliography-site-revive.html">CORDIC Bibliography Site</a></li>
<li><a href="http://www.math.ucl.ac.be/~magnus/num1a/cordic.txt">Another USENET discussion</a></li>
<li><a href="http://www.emesystems.com/BS2mathC.htm">BASIC Stamp, CORDIC math implementation</a></li>
<li><a href="http://www.jacques-laporte.org/Trigonometry.htm">CORDIC as implemented in the ROM of the HP-35 – Jacques Laporte (step by step analysis, simulator running the real ROM with breakpoints and trace facility)</a></li>
<li><a href="http://srohit.googlepages.com">CORDIC implementation in verilog</a></li>
<li><a href="http://www.math.niu.edu/~rusin/known-math/94/cordic">CORDIC information</a></li>
<li><a href="http://portal.acm.org/citation.cfm?id=626526.627179">CORDIC Vectoring with Arbitrary Target Value</a></li>
<li><a href="http://www.picbasic.co.uk/forum/showthread.php?p=70269#post70269">PicBasic Pro, Pic18 CORDIC math implementation</a></li>
<li><a href="http://code.activestate.com/recipes/576792">Python CORDIC implementation</a></li>
<li><a href="http://www.dcs.gla.ac.uk/~jhw/cordic/">Simple C code for fixed-point CORDIC</a></li>
<li><a href="http://www.andraka.com/cordic.htm">The CORDIC Algorithm</a></li>
<li><a href="http://luminouslogic.com/dsp-simple-phase-estimation-approximation-cordic-matlab.htm">Tutorial and MATLAB Implementation – Using CORDIC to Estimate Phase of a Complex Number</a></li>
<li><a href="http://www.eecg.toronto.edu/~bach/HOME/CORDIC/net.refs">USENET discussion</a></li>
<li><a href="http://bibix.nl/index.php?menu1=arx_ip">Descriptions of hardware CORDICs in Arx with testbenches in C++ and VHDL</a></li>
<li>[<a class="uri" href="http://www.usenetmessages.com/view.php?c=computer&amp;g">http://www.usenetmessages.com/view.php?c=computer&amp;g;</a>;=2333&amp;id;=468984&amp;p;=0 Usenet discussion about CORDIC]</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a class="uri" href="Category:Trigonometry" title="wikilink">Category:Trigonometry</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://dx.doi.org/10.1023/A:1008110704586">J. E. Volder, "The Birth of CORDIC", J. VLSI Signal Processing <strong>25</strong>, 101 (2000).</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://dx.doi.org/10.1023/A:1008162721424">J. S. Walther, "The Story of Unified CORDIC", J. VLSI Signal Processing <strong>25</strong>, 107 (2000).</a><a href="#fnref2">↩</a></li>
<li id="fn3">P. K. Meher, J. Valls, T-B Juang, K. Sridharan, and K. Maharatna, ‘50 Years of CORDIC: Algorithms, Architectures and Applications,’ IEEE Transactions on Circuits &amp; Systems-I: RegularPapers, vol.56, no. 9, pp. 1893–1907, September 2009<a href="#fnref3">↩</a></li>
<li id="fn4">P. K. Meher and S. Y. Park, ‘CORDIC Designs for Fixed Angle of Rotation,’ IEEE Transactions on VLSI Systems, vol.21, no.2, pp. 217–228, February 2013.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://perso.ens-lyon.fr/jean-michel.muller/SecondEdition.html">J.-M. Muller, Elementary Functions: Algorithms and Implementation, 2nd Edition (Birkhäuser, Boston, 2006), p. 134.</a><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8">D. Cochran, "Algorithms and Accuracy in the HP 35", Hewlett Packard J. <strong>23</strong>, 10 (1972).<a href="#fnref8">↩</a></li>
<li id="fn9">R. Nave, "Implementation of Transcendental Functions on a Numerics Processor", Microprocessing and Microprogramming <strong>11</strong>, 221 (1983).<a href="#fnref9">↩</a></li>
<li id="fn10">H. Schmid and A. Bogacki, "Use Decimal CORDIC for Generation of Many Transcendental Functions", EDN Magazine, February 20, 1973, p. 64.<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>

