<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="368">Z-buffering</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Z-buffering</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Z-buffer data</figcaption>
</figure>

<p>In <a href="computer_graphics" title="wikilink">computer graphics</a>, <strong>z-buffering</strong>, also known as <strong>depth buffering</strong>, is the management of image depth coordinates in <a href="3D_computer_graphics" title="wikilink">3D graphics</a>, usually done in hardware, sometimes in <a class="uri" href="software" title="wikilink">software</a>. It is one solution to the <a href="visibility_problem" title="wikilink">visibility problem</a>, which is the problem of deciding which elements of a rendered scene are visible, and which are hidden. The <a href="painter's_algorithm" title="wikilink">painter's algorithm</a> is another common solution which, though less efficient, can also handle non-opaque scene elements.</p>

<p>When an object is rendered, the depth of a generated <a class="uri" href="pixel" title="wikilink">pixel</a> (z coordinate) is stored in a <a href="Buffer_(computer_science)" title="wikilink">buffer</a> (the <strong>z-buffer</strong> or <strong>depth buffer</strong>). This buffer is usually arranged as a two-dimensional array (x-y) with one element for each screen pixel. If another object of the scene must be rendered in the same pixel, the method compares the two depths and overrides the current pixel if the object is closer to the observer. The chosen depth is then saved to the z-buffer, replacing the old one. In the end, the z-buffer will allow the method to correctly reproduce the usual depth perception: a close object hides a farther one. This is called <strong>z-culling</strong>.</p>

<p>The granularity of a z-buffer has a great influence on the scene quality: a <a class="uri" href="16-bit" title="wikilink">16-bit</a> z-buffer can result in <a href="Artifact_(observational)" title="wikilink">artifacts</a> (called "<a class="uri" href="z-fighting" title="wikilink">z-fighting</a>") when two objects are very close to each other. A <a class="uri" href="24-bit" title="wikilink">24-bit</a> or <a class="uri" href="32-bit" title="wikilink">32-bit</a> z-buffer behaves much better, although the problem cannot be entirely eliminated without additional algorithms. An <a class="uri" href="8-bit" title="wikilink">8-bit</a> z-buffer is almost never used since it has too little precision.</p>
<h2 id="uses">Uses</h2>

<p>The Z-buffer is a technology used in almost all contemporary computers, laptops and mobile phones for performing 3D graphics, for example for computer games. The Z-buffer is implemented as hardware in the silicon ICs (integrated circuits) within these computers. The Z-buffer is also used (implemented as software as opposed to hardware) for producing computer-generated special effects for films.</p>

<p>Furthermore, Z-buffer data obtained from rendering a surface from a light's point-of-view permits the creation of shadows by the <a href="shadow_mapping" title="wikilink">shadow mapping</a> technique.</p>
<h2 id="developments">Developments</h2>

<p>Even with small enough granularity, quality problems may arise when <a href="accuracy_and_precision" title="wikilink">precision</a> in the z-buffer's distance values is not spread evenly over distance. Nearer values are much more precise (and hence can display closer objects better) than values which are farther away. Generally, this is desirable, but sometimes it will cause artifacts to appear as objects become more distant. A variation on z-buffering which results in more evenly distributed precision is called <strong>w-buffering</strong> (see <a href="#W-buffer" title="wikilink">below</a>).</p>

<p>At the start of a new scene, the z-buffer must be cleared to a defined value, usually 1.0, because this value is the upper limit (on a scale of 0 to 1) of depth, meaning that no object is present at this point through the <a href="viewing_frustum" title="wikilink">viewing frustum</a>.</p>

<p>The invention of the z-buffer concept is most often attributed to <a href="Edwin_Catmull" title="wikilink">Edwin Catmull</a>, although Wolfgang Straßer also described this idea in his 1974 Ph.D. thesis<sup><a href="#fn_1" title="wikilink">1</a></sup>.</p>

<p>On recent PC graphics cards (1999–2005), z-buffer management uses a significant chunk of the available <a href="computer_storage" title="wikilink">memory</a> <a href="Bandwidth_(computing)" title="wikilink">bandwidth</a>. Various methods have been employed to reduce the performance cost of z-buffering, such as <a href="lossless_compression" title="wikilink">lossless compression</a> (computer resources to compress/decompress are cheaper than bandwidth) and ultra fast hardware z-clear that makes obsolete the "one frame positive, one frame negative" trick (skipping inter-frame clear altogether using signed numbers to cleverly check depths).</p>
<h2 id="z-culling">Z-culling</h2>

<p>In <a href="rendering_(computer_graphics)" title="wikilink">rendering</a>, z-culling is early pixel elimination based on depth, a method that provides an increase in performance when rendering of hidden surfaces is costly. It is a direct consequence of z-buffering, where the depth of each pixel candidate is compared to the depth of existing geometry behind which it might be hidden.</p>

<p>When using a z-buffer, a pixel can be culled (discarded) as soon as its depth is known, which makes it possible to skip the entire process of lighting and <a href="Texture_mapping" title="wikilink">texturing</a> a pixel that would not be <a href="Visibility_(geometry)" title="wikilink">visible</a> anyway. Also, time-consuming <a href="pixel_shader" title="wikilink">pixel shaders</a> will generally not be executed for the culled pixels. This makes z-culling a good optimization candidate in situations where <a class="uri" href="fillrate" title="wikilink">fillrate</a>, lighting, texturing or pixel shaders are the main <a href="Bottleneck_(engineering)" title="wikilink">bottlenecks</a>.</p>

<p>While z-buffering allows the geometry to be unsorted, sorting <a href="polygon" title="wikilink">polygons</a> by increasing depth (thus using a reverse <a href="painter's_algorithm" title="wikilink">painter's algorithm</a>) allows each screen pixel to be rendered fewer times. This can increase performance in fillrate-limited scenes with large amounts of overdraw, but if not combined with z-buffering it suffers from severe problems such as:</p>
<ul>
<li>polygons might occlude one another in a cycle (e.g. : triangle A occludes B, B occludes C, C occludes A), and</li>
<li>there is no canonical "closest" point on a triangle (e.g.: no matter whether one sorts triangles by their <a class="uri" href="centroid" title="wikilink">centroid</a> or closest point or furthest point, one can always find two triangles A and B such that A is "closer" but in reality B should be drawn first).</li>
</ul>

<p>As such, a reverse painter's algorithm cannot be used as an alternative to Z-culling (without strenuous re-engineering), except as an optimization to Z-culling. For example, an optimization might be to keep polygons sorted according to x/y-location and z-depth to provide bounds, in an effort to quickly determine if two polygons might possibly have an occlusion interaction.</p>
<h2 id="mathematics">Mathematics</h2>

<p>The range of depth values in camera <a class="uri" href="space" title="wikilink">space</a> (see <a href="3D_projection" title="wikilink">3D projection</a>) to be rendered is often defined between a 

<math display="inline" id="Z-buffering:0">
 <semantics>
  <mi>𝑛𝑒𝑎𝑟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑛𝑒𝑎𝑟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{near}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Z-buffering:1">
 <semantics>
  <mi>𝑓𝑎𝑟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑓𝑎𝑟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{far}
  </annotation>
 </semantics>
</math>

 value of 

<math display="inline" id="Z-buffering:2">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>


. After a <a href="perspective_transform" title="wikilink">perspective transformation</a>, the new value of 

<math display="inline" id="Z-buffering:3">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Z-buffering:4">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

, is defined by:</p>

<p>

<math display="inline" id="Z-buffering:5">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>𝑓𝑎𝑟</mi>
      <mo>+</mo>
      <mi>𝑛𝑒𝑎𝑟</mi>
     </mrow>
     <mrow>
      <mi>𝑓𝑎𝑟</mi>
      <mo>-</mo>
      <mi>𝑛𝑒𝑎𝑟</mi>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>z</mi>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <mo>⋅</mo>
         <mi>𝑓𝑎𝑟</mi>
         <mo>⋅</mo>
         <mi>𝑛𝑒𝑎𝑟</mi>
        </mrow>
       </mrow>
       <mrow>
        <mi>𝑓𝑎𝑟</mi>
        <mo>-</mo>
        <mi>𝑛𝑒𝑎𝑟</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>𝑓𝑎𝑟</ci>
       <ci>𝑛𝑒𝑎𝑟</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>𝑓𝑎𝑟</ci>
       <ci>𝑛𝑒𝑎𝑟</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>z</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-⋅</ci>
         <cn type="integer">2</cn>
         <ci>𝑓𝑎𝑟</ci>
         <ci>𝑛𝑒𝑎𝑟</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>𝑓𝑎𝑟</ci>
        <ci>𝑛𝑒𝑎𝑟</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}=\frac{\mathit{far}+\mathit{near}}{\mathit{far}-\mathit{near}}+\frac%
{1}{z}\left(\frac{-2\cdot\mathit{far}\cdot\mathit{near}}{\mathit{far}-\mathit{%
near}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>After an <a href="orthographic_projection" title="wikilink">orthographic projection</a>, the new value of 

<math display="inline" id="Z-buffering:6">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Z-buffering:7">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

, is defined by:</p>

<p>

<math display="inline" id="Z-buffering:8">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <mfrac>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <mi>𝑛𝑒𝑎𝑟</mi>
      </mrow>
      <mrow>
       <mi>𝑓𝑎𝑟</mi>
       <mo>-</mo>
       <mi>𝑛𝑒𝑎𝑟</mi>
      </mrow>
     </mfrac>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">2</cn>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>z</ci>
        <ci>𝑛𝑒𝑎𝑟</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>𝑓𝑎𝑟</ci>
        <ci>𝑛𝑒𝑎𝑟</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}=2\cdot\frac{{z}-\mathit{near}}{\mathit{far}-\mathit{near}}-1
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Z-buffering:9">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 is the old value of 

<math display="inline" id="Z-buffering:10">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 in camera space, and is sometimes called 

<math display="inline" id="Z-buffering:11">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Z-buffering:12">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>The resulting values of 

<math display="inline" id="Z-buffering:13">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

 are normalized between the values of -1 and 1, where the 

<math display="inline" id="Z-buffering:14">
 <semantics>
  <mi>𝑛𝑒𝑎𝑟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑛𝑒𝑎𝑟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{near}
  </annotation>
 </semantics>
</math>

 <a href="plane_(mathematics)" title="wikilink">plane</a> is at -1 and the 

<math display="inline" id="Z-buffering:15">
 <semantics>
  <mi>𝑓𝑎𝑟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑓𝑎𝑟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{far}
  </annotation>
 </semantics>
</math>

 plane is at 1. Values outside of this range correspond to points which are not in the viewing <a class="uri" href="frustum" title="wikilink">frustum</a>, and shouldn't be rendered.</p>
<h3 id="fixed-point-representation">Fixed-point representation</h3>

<p>Typically, these values are stored in the z-buffer of the hardware graphics accelerator in <a href="Fixed-point_arithmetic" title="wikilink">fixed point</a> format. First they are normalized to a more common range which is [0,1] by substituting the appropriate conversion 

<math display="inline" id="Z-buffering:16">
 <semantics>
  <mrow>
   <msubsup>
    <mi>z</mi>
    <mn>2</mn>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msubsup>
       <mi>z</mi>
       <mn>1</mn>
       <mo>′</mo>
      </msubsup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>normal-′</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>normal-′</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}_{2}=\frac{\left(z^{\prime}_{1}+1\right)}{2}
  </annotation>
 </semantics>
</math>

 into the previous formula:</p>

<p>

<math display="inline" id="Z-buffering:17">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>𝑓𝑎𝑟</mi>
      <mo>+</mo>
      <mi>𝑛𝑒𝑎𝑟</mi>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mo>⋅</mo>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>𝑓𝑎𝑟</mi>
        <mo>-</mo>
        <mi>𝑛𝑒𝑎𝑟</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>z</mi>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>𝑓𝑎𝑟</mi>
         <mo>⋅</mo>
         <mi>𝑛𝑒𝑎𝑟</mi>
        </mrow>
       </mrow>
       <mrow>
        <mi>𝑓𝑎𝑟</mi>
        <mo>-</mo>
        <mi>𝑛𝑒𝑎𝑟</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>𝑓𝑎𝑟</ci>
       <ci>𝑛𝑒𝑎𝑟</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>𝑓𝑎𝑟</ci>
        <ci>𝑛𝑒𝑎𝑟</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>z</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-⋅</ci>
         <ci>𝑓𝑎𝑟</ci>
         <ci>𝑛𝑒𝑎𝑟</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>𝑓𝑎𝑟</ci>
        <ci>𝑛𝑒𝑎𝑟</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}=\frac{\mathit{far}+\mathit{near}}{2\cdot\left(\mathit{far}-\mathit{%
near}\right)}+\frac{1}{z}\left(\frac{-\mathit{far}\cdot\mathit{near}}{\mathit{%
far}-\mathit{near}}\right)+\frac{1}{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Second, the above formula is multiplied by 

<math display="inline" id="Z-buffering:18">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>d</mi>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>d</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=2^{d}-1
  </annotation>
 </semantics>
</math>

 where d is the depth of the z-buffer (usually 16, 24 or 32 bits) and rounding the result to an integer:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> 

<math display="inline" id="Z-buffering:19">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo>(</mo>
     <mi>z</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mn>2</mn>
        <mi>d</mi>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mfrac>
        <mrow>
         <mi>𝑓𝑎𝑟</mi>
         <mo>+</mo>
         <mi>𝑛𝑒𝑎𝑟</mi>
        </mrow>
        <mrow>
         <mn>2</mn>
         <mo>⋅</mo>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mi>𝑓𝑎𝑟</mi>
           <mo>-</mo>
           <mi>𝑛𝑒𝑎𝑟</mi>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mi>z</mi>
        </mfrac>
        <mrow>
         <mo>(</mo>
         <mfrac>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mi>𝑓𝑎𝑟</mi>
            <mo>⋅</mo>
            <mi>𝑛𝑒𝑎𝑟</mi>
           </mrow>
          </mrow>
          <mrow>
           <mi>𝑓𝑎𝑟</mi>
           <mo>-</mo>
           <mi>𝑛𝑒𝑎𝑟</mi>
          </mrow>
         </mfrac>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>⌋</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <floor></floor>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>d</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <divide></divide>
         <apply>
          <plus></plus>
          <ci>𝑓𝑎𝑟</ci>
          <ci>𝑛𝑒𝑎𝑟</ci>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <cn type="integer">2</cn>
          <apply>
           <minus></minus>
           <ci>𝑓𝑎𝑟</ci>
           <ci>𝑛𝑒𝑎𝑟</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <ci>z</ci>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <minus></minus>
           <apply>
            <ci>normal-⋅</ci>
            <ci>𝑓𝑎𝑟</ci>
            <ci>𝑛𝑒𝑎𝑟</ci>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>𝑓𝑎𝑟</ci>
           <ci>𝑛𝑒𝑎𝑟</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}=f\left(z\right)=\left\lfloor\left(2^{d}-1\right)\cdot\left(\frac{%
\mathit{far}+\mathit{near}}{2\cdot\left(\mathit{far}-\mathit{near}\right)}+%
\frac{1}{z}\left(\frac{-\mathit{far}\cdot\mathit{near}}{\mathit{far}-\mathit{%
near}}\right)+\frac{1}{2}\right)\right\rfloor
  </annotation>
 </semantics>
</math>

</p>

<p>This formula can be inverted and derived in order to calculate the z-buffer resolution (the 'granularity' mentioned earlier). The inverse of the above 

<math display="inline" id="Z-buffering:20">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo>(</mo>
    <mi>z</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\left(z\right)
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Z-buffering:21">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>𝑓𝑎𝑟</mi>
      <mo>⋅</mo>
      <mi>𝑛𝑒𝑎𝑟</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mfrac>
       <msup>
        <mi>z</mi>
        <mo>′</mo>
       </msup>
       <mi>S</mi>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>𝑓𝑎𝑟</mi>
        <mo>-</mo>
        <mi>𝑛𝑒𝑎𝑟</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mi>a</mi>
      <mi>r</mi>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>S</mi>
        <mo>⋅</mo>
        <mi>f</mi>
       </mrow>
       <mi>a</mi>
       <mi>r</mi>
      </mrow>
      <mo>⋅</mo>
      <mi>𝑛𝑒𝑎𝑟</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>z</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi>𝑓𝑎𝑟</mi>
        <mo>-</mo>
        <mi>𝑛𝑒𝑎𝑟</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mi>a</mi>
       <mi>r</mi>
      </mrow>
      <mo>⋅</mo>
      <mi>S</mi>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>z</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-⋅</ci>
        <ci>𝑓𝑎𝑟</ci>
        <ci>𝑛𝑒𝑎𝑟</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>S</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>𝑓𝑎𝑟</ci>
         <ci>𝑛𝑒𝑎𝑟</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>a</ci>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <apply>
          <ci>normal-⋅</ci>
          <ci>S</ci>
          <ci>f</ci>
         </apply>
         <ci>a</ci>
         <ci>r</ci>
        </apply>
        <ci>𝑛𝑒𝑎𝑟</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>𝑓𝑎𝑟</ci>
         <ci>𝑛𝑒𝑎𝑟</ci>
        </apply>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>a</ci>
         <ci>r</ci>
        </apply>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=\frac{-\mathit{far}\cdot\mathit{near}}{\frac{z^{\prime}}{S}\left(\mathit{far%
}-\mathit{near}\right)-{far}}=\frac{-\mathit{S}\cdot{far}\cdot\mathit{near}}{z%
^{\prime}\left(\mathit{far}-\mathit{near}\right)-{far}\cdot S}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Z-buffering:22">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>d</mi>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>d</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=2^{d}-1
  </annotation>
 </semantics>
</math>

</p>

<p>The z-buffer resolution in terms of camera space would be the incremental value resulted from the smallest change in the integer stored in the z-buffer, which is +1 or -1. Therefore this resolution can be calculated from the derivative of 

<math display="inline" id="Z-buffering:23">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 as a function of 

<math display="inline" id="Z-buffering:24">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Z-buffering:25">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mi>z</mi>
    </mrow>
    <mrow>
     <mi>d</mi>
     <msup>
      <mi>z</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
      <mo>⋅</mo>
      <mo>-</mo>
      <mn>1</mn>
      <mo>⋅</mo>
      <mi>S</mi>
      <mo>⋅</mo>
      <mi>f</mi>
      <mi>a</mi>
      <mi>r</mi>
      <mo>⋅</mo>
      <mi>𝑛𝑒𝑎𝑟</mi>
     </mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <msup>
          <mi>z</mi>
          <mo>′</mo>
         </msup>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mi>𝑓𝑎𝑟</mi>
           <mo>-</mo>
           <mi>𝑛𝑒𝑎𝑟</mi>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mrow>
          <mi>f</mi>
          <mi>a</mi>
          <mi>r</mi>
         </mrow>
         <mo>⋅</mo>
         <mi>S</mi>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mfrac>
    <mo>⋅</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>𝑓𝑎𝑟</mi>
      <mo>-</mo>
      <mi>𝑛𝑒𝑎𝑟</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>normal-⋅</ci>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>normal-⋅</ci>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-⋅</ci>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <csymbol cd="unknown">r</csymbol>
       <ci>normal-⋅</ci>
       <csymbol cd="unknown">near</csymbol>
      </cerror>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <ci>normal-′</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>𝑓𝑎𝑟</ci>
          <ci>𝑛𝑒𝑎𝑟</ci>
         </apply>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>a</ci>
          <ci>r</ci>
         </apply>
         <ci>S</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>𝑓𝑎𝑟</ci>
      <ci>𝑛𝑒𝑎𝑟</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{dz}{dz^{\prime}}=\frac{-1\cdot-1\cdot\mathit{S}\cdot{far}\cdot\mathit{%
near}}{\left(z^{\prime}\left(\mathit{far}-\mathit{near}\right)-{far}\cdot S%
\right)^{2}}\cdot\left(\mathit{far}-\mathit{near}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Expressing it back in camera space terms, by substituting 

<math display="inline" id="Z-buffering:26">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

 by the above 

<math display="inline" id="Z-buffering:27">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo>(</mo>
    <mi>z</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\left(z\right)
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Z-buffering:28">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mi>z</mi>
    </mrow>
    <mrow>
     <mi>d</mi>
     <msup>
      <mi>z</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
     <mo>⋅</mo>
     <mo>-</mo>
     <mn>1</mn>
     <mo>⋅</mo>
     <mi>S</mi>
     <mo>⋅</mo>
     <mi>f</mi>
     <mi>a</mi>
     <mi>r</mi>
     <mo>⋅</mo>
     <mi>𝑛𝑒𝑎𝑟</mi>
     <mo>⋅</mo>
     <mrow>
      <mo>(</mo>
      <mi>𝑓𝑎𝑟</mi>
      <mo>-</mo>
      <mi>𝑛𝑒𝑎𝑟</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>S</mi>
        <mo>⋅</mo>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mfrac>
           <mrow>
            <mo>-</mo>
            <mrow>
             <mi>𝑓𝑎𝑟</mi>
             <mo>⋅</mo>
             <mi>𝑛𝑒𝑎𝑟</mi>
            </mrow>
           </mrow>
           <mi>z</mi>
          </mfrac>
          <mo>+</mo>
          <mi>𝑓𝑎𝑟</mi>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mi>a</mi>
         <mi>r</mi>
        </mrow>
        <mo>⋅</mo>
        <mi>S</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mfrac>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>normal-⋅</ci>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>normal-⋅</ci>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-⋅</ci>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <csymbol cd="unknown">r</csymbol>
       <ci>normal-⋅</ci>
       <csymbol cd="unknown">near</csymbol>
       <ci>normal-⋅</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">far</csymbol>
        <minus></minus>
        <csymbol cd="unknown">near</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-⋅</ci>
         <ci>S</ci>
         <apply>
          <plus></plus>
          <apply>
           <divide></divide>
           <apply>
            <minus></minus>
            <apply>
             <ci>normal-⋅</ci>
             <ci>𝑓𝑎𝑟</ci>
             <ci>𝑛𝑒𝑎𝑟</ci>
            </apply>
           </apply>
           <ci>z</ci>
          </apply>
          <ci>𝑓𝑎𝑟</ci>
         </apply>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>a</ci>
          <ci>r</ci>
         </apply>
         <ci>S</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{dz}{dz^{\prime}}=\frac{-1\cdot-1\cdot\mathit{S}\cdot{far}\cdot\mathit{%
near}\cdot\left(\mathit{far}-\mathit{near}\right)}{\left(\mathit{S}\cdot\left(%
\frac{-\mathit{far}\cdot\mathit{near}}{z}+\mathit{far}\right)-{far}\cdot S%
\right)^{2}}=
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Z-buffering:29">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>𝑓𝑎𝑟</mi>
       <mo>-</mo>
       <mi>𝑛𝑒𝑎𝑟</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>⋅</mo>
     <msup>
      <mi>z</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mrow>
     <mi>S</mi>
     <mo>⋅</mo>
     <mi>𝑓𝑎𝑟</mi>
     <mo>⋅</mo>
     <mi>𝑛𝑒𝑎𝑟</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <ci>𝑓𝑎𝑟</ci>
       <ci>𝑛𝑒𝑎𝑟</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>S</ci>
      <ci>𝑓𝑎𝑟</ci>
      <ci>𝑛𝑒𝑎𝑟</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\left(\mathit{far}-\mathit{near}\right)\cdot z^{2}}{S\cdot\mathit{far}%
\cdot\mathit{near}}=
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Z-buffering:30">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <msup>
      <mi>z</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>S</mi>
      <mo>⋅</mo>
      <mi>𝑛𝑒𝑎𝑟</mi>
     </mrow>
    </mfrac>
    <mo>-</mo>
    <mfrac>
     <msup>
      <mi>z</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>S</mi>
      <mo>⋅</mo>
      <mi>𝑓𝑎𝑟</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>S</ci>
       <ci>𝑛𝑒𝑎𝑟</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>S</ci>
       <ci>𝑓𝑎𝑟</ci>
      </apply>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{z^{2}}{S\cdot\mathit{near}}-\frac{z^{2}}{S\cdot\mathit{far}}=
  </annotation>
 </semantics>
</math>

</p>

<p>~ 

<math display="inline" id="Z-buffering:31">
 <semantics>
  <mfrac>
   <msup>
    <mi>z</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mi>S</mi>
    <mo>⋅</mo>
    <mi>𝑛𝑒𝑎𝑟</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>S</ci>
     <ci>𝑛𝑒𝑎𝑟</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{z^{2}}{S\cdot\mathit{near}}
  </annotation>
 </semantics>
</math>

</p>

<p>This shows that the values of 

<math display="inline" id="Z-buffering:32">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

 are grouped much more densely near the 

<math display="inline" id="Z-buffering:33">
 <semantics>
  <mi>𝑛𝑒𝑎𝑟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑛𝑒𝑎𝑟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{near}
  </annotation>
 </semantics>
</math>

 plane, and much more sparsely farther away, resulting in better precision closer to the camera. The smaller the 

<math display="inline" id="Z-buffering:34">
 <semantics>
  <mrow>
   <mi>𝑛𝑒𝑎𝑟</mi>
   <mo>/</mo>
   <mi>𝑓𝑎𝑟</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>𝑛𝑒𝑎𝑟</ci>
    <ci>𝑓𝑎𝑟</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{near}/\mathit{far}
  </annotation>
 </semantics>
</math>

 ratio is, the less precision there is far away—having the 

<math display="inline" id="Z-buffering:35">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>e</mi>
   <mi>a</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>e</ci>
    <ci>a</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   near
  </annotation>
 </semantics>
</math>

 plane set too closely is a common cause of undesirable rendering artifacts in more distant objects.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>To implement a z-buffer, the values of 

<math display="inline" id="Z-buffering:36">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

 are <a href="Linear_interpolation" title="wikilink">linearly interpolated</a> across screen space between the <a href="vertex_(geometry)" title="wikilink">vertices</a> of the current <a class="uri" href="polygon" title="wikilink">polygon</a>, and these intermediate values are generally stored in the z-buffer in <a href="Fixed-point_arithmetic" title="wikilink">fixed point</a> format.</p>
<h3 id="w-buffer">W-buffer</h3>

<p>To implement a w-buffer, the old values of 

<math display="inline" id="Z-buffering:37">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 in camera space, or 

<math display="inline" id="Z-buffering:38">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, are stored in the buffer, generally in <a href="floating_point" title="wikilink">floating point</a> format. However, these values cannot be linearly interpolated across screen space from the vertices—they usually have to be <a href="Inversion" title="wikilink">inverted</a>, interpolated, and then inverted again. The resulting values of 

<math display="inline" id="Z-buffering:39">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, as opposed to 

<math display="inline" id="Z-buffering:40">
 <semantics>
  <msup>
   <mi>z</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}
  </annotation>
 </semantics>
</math>

, are spaced evenly between 

<math display="inline" id="Z-buffering:41">
 <semantics>
  <mi>𝑛𝑒𝑎𝑟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑛𝑒𝑎𝑟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{near}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Z-buffering:42">
 <semantics>
  <mi>𝑓𝑎𝑟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑓𝑎𝑟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{far}
  </annotation>
 </semantics>
</math>

. There are implementations of the w-buffer that avoid the inversions altogether.</p>

<p>Whether a z-buffer or w-buffer results in a better image depends on the application.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Edwin_Catmull" title="wikilink">Edwin Catmull</a></li>
<li><a href="3D_computer_graphics" title="wikilink">3D computer graphics</a></li>
<li><a href="3D_scanner" title="wikilink">3D scanner</a></li>
<li><a class="uri" href="Z-fighting" title="wikilink">Z-fighting</a></li>
<li><a href="Irregular_Z-buffer" title="wikilink">Irregular Z-buffer</a></li>
<li><a class="uri" href="Z-order" title="wikilink">Z-order</a></li>
<li><a class="uri" href="z-index" title="wikilink">z-index</a></li>
<li><a href="Hierarchical_Z-buffer" title="wikilink">Hierarchical Z-buffer</a></li>
<li><a class="uri" href="A-buffer" title="wikilink">A-buffer</a></li>
<li><a href="Depth_map" title="wikilink">Depth map</a></li>
<li><a href="Atmospheric_perspective" title="wikilink">Atmospheric perspective</a></li>
<li><a class="uri" href="HyperZ" title="wikilink">HyperZ</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.sjbaker.org/steve/omniv/love_your_z_buffer.html">Learning to Love your Z-buffer</a></li>
<li><a href="http://www.sjbaker.org/steve/omniv/alpha_sorting.html">Alpha-blending and the Z-buffer</a></li>
</ul>
<h2 id="notes">Notes</h2>

<p><cite id="1"><a href="#fn_1_back" title="wikilink">Note 1:</a></cite> see W.K. Giloi, J.L. Encarnação, W. Straßer. "The Giloi’s School of Computer Graphics". Computer Graphics 35 4:12–16.</p>

<p>"</p>

<p><a href="Category:3D_rendering" title="wikilink">Category:3D rendering</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
