<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1312">Stochastic programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Stochastic programming</h1>
<hr>In the field of [[mathematical optimization]], '''stochastic programming''' is a framework for [[Mathematical model|modeling]] [[Optimization (mathematics)|optimization]] problems that involve [[uncertainty]]. Whereas deterministic optimization problems are formulated with known parameters, real world problems almost invariably include some unknown parameters. When the parameters are known only within certain bounds, one approach to tackling such problems is called [[robust optimization]]. Here the goal is to find a solution which is feasible for all such data and [[Optimization (mathematics)|optimal]] in some sense. [[Stochastic]] programming [[mathematical model|models]] are similar in style but
<p><code>take advantage of the fact that </code><a href="probability_distributions" title="wikilink"><code>probability</code> <code>distributions</code></a><code> governing the data are known or can be estimated. The goal here is to find some policy that is feasible for all (or almost all) the possible data instances and maximizes the expectation of some function of the decisions and the </code><a href="random_variable" title="wikilink"><code>random</code> <code>variables</code></a><code>. More generally, such models are formulated, solved analytically or numerically, and analyzed in order to provide useful information to a decision-maker.</code><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>As an example, consider two-stage <a href="linear_program" title="wikilink">linear programs</a>. Here the decision maker takes some action in the first stage, after which a random event occurs affecting the outcome of the first-stage decision. A recourse decision can then be made in the second stage that compensates for any bad effects that might have been experienced as a result of the first-stage decision. The optimal policy from such a model is a single first-stage policy and a collection of recourse decisions (a decision rule) defining which second-stage action should be taken in response to each random outcome.</p>

<p>Stochastic programming has applications in a broad range of areas ranging from <a class="uri" href="finance" title="wikilink">finance</a> to <a class="uri" href="transportation" title="wikilink">transportation</a> to energy optimization.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This article includes an example of optimizing an <a href="investment_portfolio" title="wikilink">investment portfolio</a> over time.</p>
<h2 id="two-stage-problems">Two-Stage Problems</h2>

<p>The basic idea of two-stage stochastic programming is that (optimal) decisions should be based on data available at the time the decisions are made and should not depend on future observations. Two-stage formulation is widely used in stochastic programming. The general formulation of a two-stage stochastic programming problem is given by:</p>

<p>

<math display="inline" id="Stochastic_programming:0">
 <semantics>
  <mrow>
   <msub>
    <mi>min</mi>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>ξ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>Q</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>ξ</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{x\in X}\{g(x)=f(x)+E[Q(x,\xi)]\}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Stochastic_programming:1">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>ξ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x,\xi)
  </annotation>
 </semantics>
</math>

 is the optimal value of the second-stage problem</p>

<p>

<math display="inline" id="Stochastic_programming:2">
 <semantics>
  <mrow>
   <msub>
    <mi>min</mi>
    <mi>y</mi>
   </msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>ξ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ξ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>W</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ξ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ξ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>q</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>ξ</ci>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>ξ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>W</ci>
       <ci>ξ</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>ξ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{y}\{q(y,\xi)|T(\xi)x+W(\xi)y=h(\xi)\}
  </annotation>
 </semantics>
</math>

</p>

<p>The classical two-stage linear stochastic programming problems can be formulated as</p>

<p>

<math display="inline" id="Stochastic_programming:3">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>g</mi>
       <mo>;</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>c</mi>
         <mi>T</mi>
        </msup>
        <mi>x</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>Q</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>ξ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>x</mi>
      </mrow>
      <mo>=</mo>
      <mi>b</mi>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>x</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <list>
       <ci>g</ci>
       <ci>x</ci>
      </list>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>c</ci>
         <ci>T</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>E</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <ci>Q</ci>
          <interval closure="open">
           <ci>x</ci>
           <ci>ξ</ci>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <geq></geq>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{llr}\min\limits_{x\in\mathbb{R}^{n}}&g;(x)=c^{T}x+E[Q(x,\xi)]&%
\\
\text{subject to}&Ax=b&\\
&x\geq 0&\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Stochastic_programming:4">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>ξ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x,\xi)
  </annotation>
 </semantics>
</math>

 is the optimal value of the second-stage problem</p>

<p>

<math display="inline" id="Stochastic_programming:5">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mi>m</mi>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>q</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ξ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
      <mi>y</mi>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ξ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>x</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>W</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ξ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>y</mi>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ξ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>y</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ξ</ci>
       <ci>T</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <eq></eq>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>ξ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>W</ci>
        <ci>ξ</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>ξ</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <geq></geq>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{llr}\min\limits_{y\in\mathbb{R}^{m}}&q(\xi)^{T}y&\\
\text{subject to}&T(\xi)x+W(\xi)y=h(\xi)&\\
&y\geq 0&\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>In such formulation 

<math display="inline" id="Stochastic_programming:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 is the first-stage decision variable vector, 

<math display="inline" id="Stochastic_programming:7">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>m</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\mathbb{R}^{m}
  </annotation>
 </semantics>
</math>

 is the second-stage decision variable vector, and 

<math display="inline" id="Stochastic_programming:8">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo>,</mo>
    <mi>W</mi>
    <mo>,</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ξ</ci>
    <vector>
     <ci>q</ci>
     <ci>T</ci>
     <ci>W</ci>
     <ci>h</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi(q,T,W,h)
  </annotation>
 </semantics>
</math>

 contains the data of the second-stage problem. In this formulation, at the first stage we have to make a "here-and-now" decision 

<math display="inline" id="Stochastic_programming:9">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 before the realization of the uncertain data 

<math display="inline" id="Stochastic_programming:10">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

, viewed as a random vector, is known. At the second stage, after a realization of 

<math display="inline" id="Stochastic_programming:11">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 becomes available, we optimize our behavior by solving an appropriate optimization problem.</p>

<p>At the first stage we optimize (minimize in the above formulation) the cost 

<math display="inline" id="Stochastic_programming:12">
 <semantics>
  <mrow>
   <msup>
    <mi>c</mi>
    <mi>T</mi>
   </msup>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>T</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{T}x
  </annotation>
 </semantics>
</math>

 of the first-stage decision plus the expected cost of the (optimal) second-stage decision. We can view the second-stage problem simply as an optimization problem which describes our supposedly optimal behavior when the uncertain data is revealed, or we can consider its solution as a recourse action where the term 

<math display="inline" id="Stochastic_programming:13">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Wy
  </annotation>
 </semantics>
</math>

 compensates for a possible inconsistency of the system 

<math display="inline" id="Stochastic_programming:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi>x</mi>
   </mrow>
   <mo>≤</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>x</ci>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Tx\leq h
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:15">
 <semantics>
  <mrow>
   <msup>
    <mi>q</mi>
    <mi>T</mi>
   </msup>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>q</ci>
     <ci>T</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{T}y
  </annotation>
 </semantics>
</math>

 is the cost of this recourse action.</p>

<p>The considered two-stage problem is <em>linear</em> because the objective functions and the constraints are linear. Conceptually this is not essential and one can consider more general two-stage stochastic programs. For example, if the first-stage problem is integer, one could add integrality constraints to the first-stage problem so that the feasible set is discrete. Non-linear objectives and constraints could also be incorporated if needed.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="distributional-assumption">Distributional assumption</h3>

<p>The formulation of the above two-stage problem assumes that the second-stage data 

<math display="inline" id="Stochastic_programming:16">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 can be modeled as a random vector with a <strong><em>known</em></strong> probability distribution (not just uncertain). This would be justified in many situations. For example 

<math display="inline" id="Stochastic_programming:17">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 could be information derived from historical data and the distribution does not significantly change over the considered period of time. In such situations one may reliably estimate the required probability distribution and the optimization <em>on average</em> could be justified by the Law of Large Numbers. Another example is that 

<math display="inline" id="Stochastic_programming:18">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 could be realizations of a simulation model whose outputs are stochastic. The empirical distribution of the sample could be used as an approximation to the true but unknown output distribution.</p>
<h3 id="discretization">Discretization</h3>

<p>To solve the two-stage stochastic problem numerically, one often need to assume that the random vector 

<math display="inline" id="Stochastic_programming:19">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 has a finite number of possible realizations, called <em>scenarios</em>, say 

<math display="inline" id="Stochastic_programming:20">
 <semantics>
  <mrow>
   <msub>
    <mi>ξ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>ξ</mi>
    <mi>K</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <ci>K</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{1},\dots,\xi_{K}
  </annotation>
 </semantics>
</math>

, with respective probability masses 

<math display="inline" id="Stochastic_programming:21">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mi>K</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>K</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},\dots,p_{K}
  </annotation>
 </semantics>
</math>

. Then the expectation in the first-stage problem's objective function can be written as the summation:</p>

<p>

<math display="inline" id="Stochastic_programming:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>ξ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>K</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>k</mi>
     </msub>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msub>
       <mi>ξ</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>Q</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>ξ</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
      <ci>Q</ci>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <ci>k</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[Q(x,\xi)]=\sum\limits_{k=1}^{K}p_{k}Q(x,\xi_{k})
  </annotation>
 </semantics>
</math>

</p>

<p>and, moreover, the two-stage problem can be formulated as one large linear programming problem (this is called the deterministic equivalent of the original problem, see section ).</p>

<p>When 

<math display="inline" id="Stochastic_programming:23">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 has an infinite (or very large) number of possible realizations the standard approach is then to represent this distribution by scenarios. This approach raises three questions, namely:</p>
<ol>
<li>How to construct scenarios, see ;</li>
<li>How to solve the deterministic equivalent. Optimizers such as <a class="uri" href="CPLEX" title="wikilink">CPLEX</a>, <a href="GNU_Linear_Programming_Kit" title="wikilink">GLPK</a> and <a class="uri" href="Gurobi" title="wikilink">Gurobi</a> can solve large linear/nonlinear problems. NEOS <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> server hosted at the <a href="Argonne_National_Laboratory" title="wikilink">Argonne National Laboratory</a> allows free access to many modern solvers. The structure of a deterministic equivalent is particularly amenable to apply decomposition methods,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> such as <a href="Benders'_decomposition" title="wikilink">Benders' decomposition</a> or scenario decomposition;</li>
<li>How to measure quality of the obtained solution with respect to the "true" optimum.</li>
</ol>

<p>These questions are not independent. For example, the number of scenarios constructed will affect both the tractability of the deterministic equivalent and the quality of the obtained solutions.</p>
<h2 id="stochastic-linear-program">Stochastic linear program</h2>

<p>A stochastic <a href="linear_program" title="wikilink">linear program</a> is a specific instance of the classical two-stage stochastic program. A stochastic LP is built from a collection of multi-period linear programs (LPs), each having the same structure but somewhat different data. The 

<math display="inline" id="Stochastic_programming:24">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 two-period LP, representing the 

<math display="inline" id="Stochastic_programming:25">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 scenario, may be regarded as having the following form:</p>

<p>

<math display="inline" id="Stochastic_programming:26">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mtext>Minimize</mtext>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>T</mi>
      </msup>
      <mi>x</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msup>
       <mi>g</mi>
       <mi>T</mi>
      </msup>
      <mi>y</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msubsup>
       <mi>h</mi>
       <mi>k</mi>
       <mi>T</mi>
      </msubsup>
      <msub>
       <mi>z</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>T</mi>
      <mi>x</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>U</mi>
      <mi>y</mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi>r</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>V</mi>
       <mi>k</mi>
      </msub>
      <mi>y</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>W</mi>
       <mi>k</mi>
      </msub>
      <msub>
       <mi>z</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <msub>
      <mi>s</mi>
      <mi>k</mi>
     </msub>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="center">
     <mi>x</mi>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mi>y</mi>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <msub>
      <mi>z</mi>
      <mi>k</mi>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <mtext>Minimize</mtext>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>T</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>T</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>x</ci>
     </apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>y</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <eq></eq>
     <ci>r</ci>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>k</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>k</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>x</ci>
     <csymbol cd="latexml">absent</csymbol>
     <ci>y</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>k</ci>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lccccccc}\text{Minimize}&f^{T}x&+&g^{T}y&+&h_{k}^{T}z_{k}&&\\
\text{subject to}&Tx&+&Uy&&&=&r\\
&&&V_{k}y&+&W_{k}z_{k}&=&s_{k}\\
&x&,&y&,&z_{k}&\geq&0\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>The vectors 

<math display="inline" id="Stochastic_programming:27">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:28">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 contain the first-period variables, whose values must be chosen immediately. The vector 

<math display="inline" id="Stochastic_programming:29">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}
  </annotation>
 </semantics>
</math>

 contains all of the variables for subsequent periods. The constraints 

<math display="inline" id="Stochastic_programming:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>U</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Tx+Uy=r
  </annotation>
 </semantics>
</math>

 involve only first-period variables and are the same in every scenario. The other constraints involve variables of later periods and differ in some respects from scenario to scenario, reflecting uncertainty about the future.</p>

<p>Note that solving the 

<math display="inline" id="Stochastic_programming:31">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 two-period LP is equivalent to assuming the 

<math display="inline" id="Stochastic_programming:32">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 scenario in the second period with no uncertainty. In order to incorporate uncertainties in the second stage, one should assign probabilities to different scenarios and solve the corresponding deterministic equivalent.</p>
<h3 id="deterministic-equivalent-of-a-stochastic-problem">Deterministic equivalent of a stochastic problem</h3>

<p>With a finite number of scenarios, two-stage stochastic linear programs can be modelled as large linear programming problems. This formulation is often called the deterministic equivalent linear program, or abbreviated to deterministic equivalent. (Strictly speaking a deterministic equivalent is any mathematical program that can be used to compute the optimal first-stage decision, so these will exist for continuous probability distributions as well, when one can represent the second-stage cost in some closed form.) For example, to form the deterministic equivalent to the above stochastic linear program, we assign a probability 

<math display="inline" id="Stochastic_programming:33">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{k}
  </annotation>
 </semantics>
</math>

 to each scenario 

<math display="inline" id="Stochastic_programming:34">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>K</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,\dots,K
  </annotation>
 </semantics>
</math>

. Then we can minimize the expected value of the objective, subject to the constraints from all scenarios:</p>

<p>

<math display="inline" id="Stochastic_programming:35">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mtext>Minimize</mtext>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>T</mi>
      </msup>
      <mi>x</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msup>
       <mi>g</mi>
       <mi>T</mi>
      </msup>
      <mi>y</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
      <msubsup>
       <mi>h</mi>
       <mn>1</mn>
       <mi>T</mi>
      </msubsup>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>p</mi>
       <mn>2</mn>
      </msub>
      <msubsup>
       <mi>h</mi>
       <mn>2</mn>
       <mi>T</mi>
      </msubsup>
      <msub>
       <mi>z</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋯</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>K</mi>
      </msub>
      <msubsup>
       <mi>h</mi>
       <mi>K</mi>
       <mi>T</mi>
      </msubsup>
      <msub>
       <mi>z</mi>
       <mi>K</mi>
      </msub>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>T</mi>
      <mi>x</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>U</mi>
      <mi>y</mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi>r</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>V</mi>
       <mn>1</mn>
      </msub>
      <mi>y</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>W</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>V</mi>
       <mn>2</mn>
      </msub>
      <mi>y</mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>W</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>z</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <msub>
      <mi>s</mi>
      <mn>2</mn>
     </msub>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋱</mi>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>V</mi>
       <mi>K</mi>
      </msub>
      <mi>y</mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>+</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>W</mi>
       <mi>K</mi>
      </msub>
      <msub>
       <mi>z</mi>
       <mi>K</mi>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <msub>
      <mi>s</mi>
      <mi>K</mi>
     </msub>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="center">
     <mi>x</mi>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mi>y</mi>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <msub>
      <mi>z</mi>
      <mn>1</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <msub>
      <mi>z</mi>
      <mn>2</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">…</mi>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <msub>
      <mi>z</mi>
      <mi>K</mi>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <mtext>Minimize</mtext>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>T</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>T</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <plus></plus>
     <ci>normal-⋯</ci>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>K</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>K</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>x</ci>
     </apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>y</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <eq></eq>
     <ci>r</ci>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>y</ci>
     </apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>y</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-⋮</ci>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-⋱</ci>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-⋮</ci>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>K</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>K</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>K</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>x</ci>
     <csymbol cd="latexml">absent</csymbol>
     <ci>y</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-…</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>K</ci>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lccccccccccccc}\text{Minimize}&f^{T}x&+&g^{T}y&+&p_{1}h_{1}^{T%
}z_{1}&+&p_{2}h_{2}^{T}z_{2}&+&\cdots&+&p_{K}h_{K}^{T}z_{K}&&\\
\text{subject to}&Tx&+&Uy&&&&&&&&&=&r\\
&&&V_{1}y&+&W_{1}z_{1}&&&&&&&=&s_{1}\\
&&&V_{2}y&&&+&W_{2}z_{2}&&&&&=&s_{2}\\
&&&\vdots&&&&&&\ddots&&&&\vdots\\
&&&V_{K}y&&&&&&&+&W_{K}z_{K}&=&s_{K}\\
&x&,&y&,&z_{1}&,&z_{2}&,&\ldots&,&z_{K}&\geq&0\\
\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>We have a different vector 

<math display="inline" id="Stochastic_programming:36">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}
  </annotation>
 </semantics>
</math>

 of later-period variables for each scenario 

<math display="inline" id="Stochastic_programming:37">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. The first-period variables 

<math display="inline" id="Stochastic_programming:38">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:39">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are the same in every scenario, however, because we must make a decision for the first period before we know which scenario will be realized. As a result, the constraints involving just 

<math display="inline" id="Stochastic_programming:40">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:41">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 need only be specified once, while the remaining constraints must be given separately for each scenario.</p>
<h2 id="scenario-construction">Scenario construction</h2>

<p>In practice it might be possible to construct scenarios by eliciting expert's opinions on the future. The number of constructed scenarios should be relatively modest so that the obtained deterministic equivalent can be solved with reasonable computational effort. It is often claimed that a solution that is optimal using only a few scenarios provides more adaptable plans than one that assumes a single scenario only. In some cases such a claim could be verified by a simulation. In theory some measures of guarantee that an obtained solution solves the original problem with reasonable accuracy. Typically in applications only the <em>first stage</em> optimal solution 

<math display="inline" id="Stochastic_programming:42">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 has a practical value since almost always a "true" realization of the random data will be different from the set of constructed (generated) scenarios.</p>

<p>Suppose 

<math display="inline" id="Stochastic_programming:43">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 contains 

<math display="inline" id="Stochastic_programming:44">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 independent random components, each of which has three possible realizations (for example, future realizations of each random parameters are classified as low, medium and high), then the total number of scenarios is 

<math display="inline" id="Stochastic_programming:45">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <msup>
    <mn>3</mn>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3</cn>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=3^{d}
  </annotation>
 </semantics>
</math>

. Such <em>exponential growth</em> of the number of scenarios makes model development using expert opinion very difficult even for reasonable size 

<math display="inline" id="Stochastic_programming:46">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

. The situation becomes even worse if some random components of 

<math display="inline" id="Stochastic_programming:47">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 have continuous distributions.</p>
<h3 id="monte-carlo-sampling-and-sample-average-approximation-saa-method">Monte Carlo sampling and Sample Average Approximation (SAA) Method</h3>

<p>A common approach to reduce the scenario set to a manageable size is by using Monte Carlo simulation. Suppose the total number of scenarios is very large or even infinite. Suppose further that we can generate a sample 

<math display="inline" id="Stochastic_programming:48">
 <semantics>
  <mrow>
   <msup>
    <mi>ξ</mi>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>ξ</mi>
    <mn>2</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>ξ</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <ci>N</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi^{1},\xi^{2},\dots,\xi^{N}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Stochastic_programming:49">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 replications of the random vector 

<math display="inline" id="Stochastic_programming:50">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

. Usually the sample is assumed to be independent identically distributed (i.i.d sample). Given a sample, the expectation function 

<math display="inline" id="Stochastic_programming:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>ξ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>Q</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>ξ</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(x)=E[Q(x,\xi)]
  </annotation>
 </semantics>
</math>

 is approximated by the sample average</p>

<p>

<math display="inline" id="Stochastic_programming:52">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>q</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msup>
        <mi>ξ</mi>
        <mi>j</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>q</ci>
      </apply>
      <ci>N</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ξ</ci>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{q}_{N}(x)=\frac{1}{N}\sum_{j=1}^{N}Q(x,\xi^{j})
  </annotation>
 </semantics>
</math>

</p>

<p>and consequently the first-stage problem is given by</p>

<p>

<math display="inline" id="Stochastic_programming:53">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>g</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mi>N</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <msup>
        <mi>c</mi>
        <mi>T</mi>
       </msup>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mi>N</mi>
       </mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>N</mi>
        </msubsup>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <msup>
           <mi>ξ</mi>
           <mi>j</mi>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mi>A</mi>
      <mi>x</mi>
     </mrow>
    </mtd>
    <mtd columnalign="right">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="right">
     <mi>b</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="right">
     <mi>x</mi>
    </mtd>
    <mtd columnalign="right">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="right">
     <mn>0</mn>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>g</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>c</ci>
        <ci>T</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>N</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <apply>
         <times></times>
         <ci>Q</ci>
         <interval closure="open">
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ξ</ci>
           <ci>j</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <mtext>subject to</mtext>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <eq></eq>
     <ci>b</ci>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>x</ci>
     <geq></geq>
     <cn type="integer">0</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rlrrr}\hat{g}_{N}(x)=&\min\limits_{x\in\mathbb{R}^{n}}&c^{T}x+%
\frac{1}{N}\sum_{j=1}^{N}Q(x,\xi^{j})&\\
&\text{subject to}&Ax&=&b\\
&&x&\geq&0\end{array}
  </annotation>
 </semantics>
</math>


</p>

<p>This formulation is known as the <em>Sample Average Approximation</em> method. The SAA problem is a function of the considered sample and in that sense is random. For a given sample 

<math display="inline" id="Stochastic_programming:54">
 <semantics>
  <mrow>
   <msup>
    <mi>ξ</mi>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>ξ</mi>
    <mn>2</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>ξ</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <ci>N</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi^{1},\xi^{2},\dots,\xi^{N}
  </annotation>
 </semantics>
</math>

 the SAA problem is of the same form as a two-stage stochastic linear programming problem with the scenarios 

<math display="inline" id="Stochastic_programming:55">
 <semantics>
  <msup>
   <mi>ξ</mi>
   <mi>j</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ξ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi^{j}
  </annotation>
 </semantics>
</math>

., 

<math display="inline" id="Stochastic_programming:56">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1,\dots,N
  </annotation>
 </semantics>
</math>

, each taken with the same probability 

<math display="inline" id="Stochastic_programming:57">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>N</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{j}=\frac{1}{N}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="statistical-inference">Statistical Inference</h2>

<p>Consider the following stochastic programming problem</p>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">

<p>

<math display="inline" id="Stochastic_programming:58">
 <semantics>
  <mrow>
   <munder>
    <mi>min</mi>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
   </munder>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>ξ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>Q</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>ξ</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\limits_{x\in X}\{g(x)=f(x)+E[Q(x,\xi)]\}
  </annotation>
 </semantics>
</math>


</p>
</div>

<p>Here 

<math display="inline" id="Stochastic_programming:59">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is a nonempty closed subset of 

<math display="inline" id="Stochastic_programming:60">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Stochastic_programming:61">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 is a random vector whose probability distribution 

<math display="inline" id="Stochastic_programming:62">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is supported on a set 

<math display="inline" id="Stochastic_programming:63">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ξ</mi>
   <mo>⊂</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>normal-Ξ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Xi\subset\mathbb{R}^{d}
  </annotation>
 </semantics>
</math>


, and 

<math display="inline" id="Stochastic_programming:64">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Ξ</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>Q</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>normal-Ξ</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q:X\times\Xi\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

. In the framework of two-stage stochastic programming, 

<math display="inline" id="Stochastic_programming:65">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>ξ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x,\xi)
  </annotation>
 </semantics>
</math>

 is given by the optimal value of the corresponding second-stage problem.</p>

<p>Assume that 

<math display="inline" id="Stochastic_programming:66">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 is well defined and <em>finite valued</em> for all 

<math display="inline" id="Stochastic_programming:67">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

. This implies that for every 

<math display="inline" id="Stochastic_programming:68">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>


 the value 

<math display="inline" id="Stochastic_programming:69">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>ξ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x,\xi)
  </annotation>
 </semantics>
</math>

 is finite almost surely.</p>

<p>Suppose that we have a sample 

<math display="inline" id="Stochastic_programming:70">
 <semantics>
  <mrow>
   <msup>
    <mi>ξ</mi>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>ξ</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <ci>N</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi^{1},\dots,\xi^{N}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Stochastic_programming:71">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

realizations of the random vector 

<math display="inline" id="Stochastic_programming:72">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

. This random sample can be viewed as historical data of 

<math display="inline" id="Stochastic_programming:73">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 observations of 

<math display="inline" id="Stochastic_programming:74">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

, or it can be generated by Monte Carlo sampling techniques. Then we can formulate a corresponding <em>sample average approximation</em></p>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">

<p>

<math display="inline" id="Stochastic_programming:75">
 <semantics>
  <mrow>
   <munder>
    <mi>min</mi>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
   </munder>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mi>N</mi>
       </mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>N</mi>
        </msubsup>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <msup>
           <mi>ξ</mi>
           <mi>j</mi>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>g</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>N</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <apply>
         <times></times>
         <ci>Q</ci>
         <interval closure="open">
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ξ</ci>
           <ci>j</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\limits_{x\in X}\{\hat{g}_{N}(x)=f(x)+\frac{1}{N}\sum_{j=1}^{N}Q(x,\xi^{j})\}
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>By the <a href="Law_of_Large_Numbers" title="wikilink">Law of Large Numbers</a> we have that, under some regularity conditions 

<math display="inline" id="Stochastic_programming:76">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>N</mi>
   </mfrac>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msup>
       <mi>ξ</mi>
       <mi>j</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ξ</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N}\sum_{j=1}^{N}Q(x,\xi^{j})
  </annotation>
 </semantics>
</math>

 converges pointwise with probability 1 to 

<math display="inline" id="Stochastic_programming:77">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>ξ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>Q</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>ξ</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[Q(x,\xi)]
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Stochastic_programming:78">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>


. Moreover, under mild additional conditions the convergence is uniform. We also have 

<math display="inline" id="Stochastic_programming:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>g</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[\hat{g}_{N}(x)]=g(x)
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Stochastic_programming:80">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}(x)
  </annotation>
 </semantics>
</math>

 is an <em>unbiased</em> estimator of 

<math display="inline" id="Stochastic_programming:81">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

. Therefore it is natural to expect that the optimal value and optimal solutions of the SAA problem converge to their counterparts of the true problem as 

<math display="inline" id="Stochastic_programming:82">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="consistency-of-saa-estimators">Consistency of SAA estimators</h3>

<p>Suppose the feasible set 

<math display="inline" id="Stochastic_programming:83">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 of the SAA problem is fixed, i.e., it is independent of the sample. Let 

<math display="inline" id="Stochastic_programming:84">
 <semantics>
  <msup>
   <mi>ϑ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ϑ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vartheta^{*}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:85">
 <semantics>
  <msup>
   <mi>S</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{*}
  </annotation>
 </semantics>
</math>

 be the optimal value and the set of optimal solutions, respectively, of the true problem and let 

<math display="inline" id="Stochastic_programming:86">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>ϑ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>ϑ</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\vartheta}_{N}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:87">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>S</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>S</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{S}_{N}
  </annotation>
 </semantics>
</math>

 be the optimal value and the set of optimal solutions, respectively, of the SAA problem.</p>
<ol>
<li>Let 

<math display="inline" id="Stochastic_programming:88">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:X\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Stochastic_programming:89">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}:X\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 be a sequence of (deterministic) real valued functions. The following two properties are equivalent:
<ul>
<li>for any 

<math display="inline" id="Stochastic_programming:90">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>¯</mo>
   </mover>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{x}\in X
  </annotation>
 </semantics>
</math>

 and any sequence 

<math display="inline" id="Stochastic_programming:91">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊂</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
    </set>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{N}\}\subset X
  </annotation>
 </semantics>
</math>

 converging to 

<math display="inline" id="Stochastic_programming:92">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{x}
  </annotation>
 </semantics>
</math>

 it follows that 

<math display="inline" id="Stochastic_programming:93">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}(x_{N})
  </annotation>
 </semantics>
</math>


 converges to 

<math display="inline" id="Stochastic_programming:94">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\overline{x})
  </annotation>
 </semantics>
</math>

</li>
<li>the function 

<math display="inline" id="Stochastic_programming:95">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\cdot)
  </annotation>
 </semantics>
</math>

 is continuous on 

<math display="inline" id="Stochastic_programming:96">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:97">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}(\cdot)
  </annotation>
 </semantics>
</math>

 converges to 

<math display="inline" id="Stochastic_programming:98">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\cdot)
  </annotation>
 </semantics>
</math>


 uniformly on any compact subset of 

<math display="inline" id="Stochastic_programming:99">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
<li>If the objective of the SAA problem 

<math display="inline" id="Stochastic_programming:100">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}(x)
  </annotation>
 </semantics>
</math>

 converges to the true problem's objective 

<math display="inline" id="Stochastic_programming:101">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 with probability 1, as 

<math display="inline" id="Stochastic_programming:102">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>

, uniformly on the feasible set 

<math display="inline" id="Stochastic_programming:103">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


. Then 

<math display="inline" id="Stochastic_programming:104">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>ϑ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>ϑ</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\vartheta}_{N}
  </annotation>
 </semantics>
</math>

 converges to 

<math display="inline" id="Stochastic_programming:105">
 <semantics>
  <msup>
   <mi>ϑ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ϑ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vartheta^{*}
  </annotation>
 </semantics>
</math>

 with probability 1 as 

<math display="inline" id="Stochastic_programming:106">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>

.</li>
<li>Suppose that there exists a compact set 

<math display="inline" id="Stochastic_programming:107">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>⊂</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\subset\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 such that
<ul>
<li>the set 

<math display="inline" id="Stochastic_programming:108">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 of optimal solutions of the true problem is nonempty and is contained in 

<math display="inline" id="Stochastic_programming:109">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

</li>
<li>the function 

<math display="inline" id="Stochastic_programming:110">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 is finite valued and continuous on 

<math display="inline" id="Stochastic_programming:111">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

</li>
<li>the sequence of functions 

<math display="inline" id="Stochastic_programming:112">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}(x)
  </annotation>
 </semantics>
</math>

 converges to 

<math display="inline" id="Stochastic_programming:113">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>


 with probability 1, as 

<math display="inline" id="Stochastic_programming:114">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>

, uniformly in 

<math display="inline" id="Stochastic_programming:115">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in C
  </annotation>
 </semantics>
</math>

</li>
<li>for 

<math display="inline" id="Stochastic_programming:116">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 large enough the set 

<math display="inline" id="Stochastic_programming:117">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>S</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>S</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{S}_{N}
  </annotation>
 </semantics>
</math>

 is nonempty and 

<math display="inline" id="Stochastic_programming:118">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>S</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mo>⊂</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>S</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{S}_{N}\subset C
  </annotation>
 </semantics>
</math>


 with probability 1</li>
</ul></li>
</ol>
<dl>
<dd><dl>
<dd>then 

<math display="inline" id="Stochastic_programming:119">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>ϑ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mo>→</mo>
   <msup>
    <mi>ϑ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>ϑ</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ϑ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\vartheta}_{N}\rightarrow\vartheta^{*}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:120">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔻</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mo>*</mo>
     </msup>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>S</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>𝔻</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>S</ci>
       </apply>
       <ci>N</ci>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{D}(S^{*},\hat{S}_{N})\rightarrow 0
  </annotation>
 </semantics>
</math>

 with probability 1 as 

<math display="inline" id="Stochastic_programming:121">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="Stochastic_programming:122">
 <semantics>
  <mrow>
   <mi>𝔻</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔻</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>B</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{D}(A,B)
  </annotation>
 </semantics>
</math>

 denotes the <em>deviation of set 

<math display="inline" id="Stochastic_programming:123">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 from set 

<math display="inline" id="Stochastic_programming:124">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

</em>, defined as
</dd>
</dl>
</dd>
</dl>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">

<p>

<math display="inline" id="Stochastic_programming:125">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔻</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mo>sup</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mi>A</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mo>inf</mo>
       <mrow>
        <msup>
         <mi>x</mi>
         <mo>′</mo>
        </msup>
        <mo>∈</mo>
        <mi>B</mi>
       </mrow>
      </msub>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <msup>
         <mi>x</mi>
         <mo>′</mo>
        </msup>
       </mrow>
       <mo>∥</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>𝔻</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>B</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <set>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">infimum</csymbol>
        <apply>
         <in></in>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>B</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{D}(A,B):=\sup_{x\in A}\{\inf_{x^{\prime}\in B}\|x-x^{\prime}\|\}
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>In some situations the feasible set 

<math display="inline" id="Stochastic_programming:126">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 of the SAA problem is estimated, then the corresponding SAA problem takes the form</p>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">

<p>

<math display="inline" id="Stochastic_programming:127">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>min</mi>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <msub>
       <mi>X</mi>
       <mi>N</mi>
      </msub>
     </mrow>
    </msub>
    <msub>
     <mover accent="true">
      <mi>g</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>N</mi>
    </msub>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>g</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{x\in X_{N}}\hat{g}_{N}(x)
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>where 

<math display="inline" id="Stochastic_programming:128">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{N}
  </annotation>
 </semantics>
</math>


 is a subset of 

<math display="inline" id="Stochastic_programming:129">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 depending on the sample and therefore is random. Nevertheless consistency results for SAA estimators can still be derived under some additional assumptions:</p>
<ol>
<li>Suppose that there exists a compact set 

<math display="inline" id="Stochastic_programming:130">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>⊂</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\subset\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 such that
<ul>
<li>the set 

<math display="inline" id="Stochastic_programming:131">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of optimal solutions of the true problem is nonempty and is contained in 

<math display="inline" id="Stochastic_programming:132">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

</li>
<li>the function 

<math display="inline" id="Stochastic_programming:133">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>


 is finite valued and continuous on 

<math display="inline" id="Stochastic_programming:134">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

</li>
<li>the sequence of functions 

<math display="inline" id="Stochastic_programming:135">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}(x)
  </annotation>
 </semantics>
</math>

 converges to 

<math display="inline" id="Stochastic_programming:136">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 with probability 1, as 

<math display="inline" id="Stochastic_programming:137">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>

, uniformly in 

<math display="inline" id="Stochastic_programming:138">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in C
  </annotation>
 </semantics>
</math>


</li>
<li>for 

<math display="inline" id="Stochastic_programming:139">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 large enough the set 

<math display="inline" id="Stochastic_programming:140">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>S</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>S</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{S}_{N}
  </annotation>
 </semantics>
</math>

 is nonempty and 

<math display="inline" id="Stochastic_programming:141">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>S</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mo>⊂</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>S</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{S}_{N}\subset C
  </annotation>
 </semantics>
</math>

 with probability 1</li>
<li>if 

<math display="inline" id="Stochastic_programming:142">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>N</mi>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi>X</mi>
    <mi>N</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{N}\in X_{N}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:143">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{N}
  </annotation>
 </semantics>
</math>


 converges with probability 1 to a point 

<math display="inline" id="Stochastic_programming:144">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Stochastic_programming:145">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

</li>
<li>for some point 

<math display="inline" id="Stochastic_programming:146">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>S</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in S^{*}
  </annotation>
 </semantics>
</math>

 there exists a sequence 

<math display="inline" id="Stochastic_programming:147">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>N</mi>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi>X</mi>
    <mi>N</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{N}\in X_{N}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Stochastic_programming:148">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>N</mi>
   </msub>
   <mo>→</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{N}\rightarrow x
  </annotation>
 </semantics>
</math>


 with probability 1.</li>
</ul></li>
</ol>
<dl>
<dd><dl>
<dd>then 

<math display="inline" id="Stochastic_programming:149">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>ϑ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mo>→</mo>
   <msup>
    <mi>ϑ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>ϑ</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ϑ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\vartheta}_{N}\rightarrow\vartheta^{*}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:150">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔻</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mo>*</mo>
     </msup>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>S</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>𝔻</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>S</ci>
       </apply>
       <ci>N</ci>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{D}(S^{*},\hat{S}_{N})\rightarrow 0
  </annotation>
 </semantics>
</math>

 with probability 1 as 

<math display="inline" id="Stochastic_programming:151">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>N</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\rightarrow\infty
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>
<h3 id="asymptotics-of-the-saa-optimal-value">Asymptotics of the SAA optimal value</h3>

<p>Suppose the sample 

<math display="inline" id="Stochastic_programming:152">
 <semantics>
  <mrow>
   <msup>
    <mi>ξ</mi>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>ξ</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <ci>N</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi^{1},\dots,\xi^{N}
  </annotation>
 </semantics>
</math>

 is i.i.d. and fix a point 

<math display="inline" id="Stochastic_programming:153">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>


. Then the sample average estimator 

<math display="inline" id="Stochastic_programming:154">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}(x)
  </annotation>
 </semantics>
</math>

, of 

<math display="inline" id="Stochastic_programming:155">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

, is unbiased and have variance 

<math display="inline" id="Stochastic_programming:156">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>N</mi>
   </mfrac>
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N}\sigma^{2}(x)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Stochastic_programming:157">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>σ</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mi>V</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>ξ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>a</ci>
     <ci>r</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>Q</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>ξ</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}(x):=Var[Q(x,\xi)]
  </annotation>
 </semantics>
</math>

 is supposed to be finite. Moreover, by the <a href="central_limit_theorem" title="wikilink">central limit theorem</a> we have that</p>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">

<p>

<math display="inline" id="Stochastic_programming:158">
 <semantics>
  <mrow>
   <mrow>
    <msqrt>
     <mi>N</mi>
    </msqrt>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>N</mi>
      </msub>
      <mo>-</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mo class="ltx_font_mathcaligraphic">𝒟</mo>
   </mover>
   <msub>
    <mi>Y</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <ci>𝒟</ci>
     <ci>normal-→</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>g</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{N}[\hat{g}_{N}-g(x)]\xrightarrow{\mathcal{D}}Y_{x}
  </annotation>
 </semantics>
</math>


</p>
</div>

<p>where 

<math display="inline" id="Stochastic_programming:159">
 <semantics>
  <mover accent="true">
   <mo>→</mo>
   <mo class="ltx_font_mathcaligraphic">𝒟</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>𝒟</ci>
    <ci>normal-→</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xrightarrow{\mathcal{D}}
  </annotation>
 </semantics>
</math>

 denotes convergence in <em>distribution</em> and 

<math display="inline" id="Stochastic_programming:160">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{x}
  </annotation>
 </semantics>
</math>

 has a normal distribution with mean 

<math display="inline" id="Stochastic_programming:161">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 and variance 

<math display="inline" id="Stochastic_programming:162">
 <semantics>
  <mrow>
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}(x)
  </annotation>
 </semantics>
</math>

, written as 

<math display="inline" id="Stochastic_programming:163">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>σ</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(0,\sigma^{2}(0))
  </annotation>
 </semantics>
</math>


.</p>

<p>In other words, 

<math display="inline" id="Stochastic_programming:164">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}(x)
  </annotation>
 </semantics>
</math>

 has <em>asymptotically normal</em> distribution, i.e., for large 

<math display="inline" id="Stochastic_programming:165">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Stochastic_programming:166">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}_{N}(x)
  </annotation>
 </semantics>
</math>

 has approximately normal distribution with mean 

<math display="inline" id="Stochastic_programming:167">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 and variance 

<math display="inline" id="Stochastic_programming:168">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>N</mi>
   </mfrac>
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N}\sigma^{2}(x)
  </annotation>
 </semantics>
</math>


. This leads to the following (approximate) 

<math display="inline" id="Stochastic_programming:169">
 <semantics>
  <mrow>
   <mn>100</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>α</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">100</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   100(1-\alpha)
  </annotation>
 </semantics>
</math>

% confidence interval for 

<math display="inline" id="Stochastic_programming:170">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

:</p>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">

<p>

<math display="inline" id="Stochastic_programming:171">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>g</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>N</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <mrow>
       <mi>α</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msub>
     <mfrac>
      <mrow>
       <mover accent="true">
        <mi>σ</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <msqrt>
       <mi>N</mi>
      </msqrt>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>g</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>N</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <mrow>
       <mi>α</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msub>
     <mfrac>
      <mrow>
       <mover accent="true">
        <mi>σ</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <msqrt>
       <mi>N</mi>
      </msqrt>
     </mfrac>
    </mrow>
   </mrow>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>g</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <divide></divide>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <ci>normal-^</ci>
         <ci>σ</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <root></root>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>g</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <divide></divide>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <ci>normal-^</ci>
         <ci>σ</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <root></root>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\hat{g}_{N}(x)-z_{\alpha/2}\frac{\hat{\sigma}(x)}{\sqrt{N}},\hat{g}_{N}(%
x)+z_{\alpha/2}\frac{\hat{\sigma}(x)}{\sqrt{N}}\right]
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>where 

<math display="inline" id="Stochastic_programming:172">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mrow>
     <mi>α</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>α</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <apply>
      <divide></divide>
      <ci>α</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <ci>α</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{\alpha/2}:=\Phi^{-1}(1-\alpha/2)
  </annotation>
 </semantics>
</math>

 (here 

<math display="inline" id="Stochastic_programming:173">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(\cdot)
  </annotation>
 </semantics>
</math>


 denotes the cdf of the standard normal distribution) and</p>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">

<p>

<math display="inline" id="Stochastic_programming:174">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mover accent="true">
      <mi>σ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <msup>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <msup>
           <mi>ξ</mi>
           <mi>j</mi>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mi>N</mi>
         </mfrac>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>N</mi>
          </msubsup>
          <mrow>
           <mi>Q</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo>,</mo>
            <msup>
             <mi>ξ</mi>
             <mi>j</mi>
            </msup>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>σ</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>Q</ci>
          <interval closure="open">
           <ci>x</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>ξ</ci>
            <ci>j</ci>
           </apply>
          </interval>
         </apply>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <ci>N</ci>
          </apply>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <sum></sum>
             <apply>
              <eq></eq>
              <ci>j</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <ci>N</ci>
           </apply>
           <apply>
            <times></times>
            <ci>Q</ci>
            <interval closure="open">
             <ci>x</ci>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>ξ</ci>
              <ci>j</ci>
             </apply>
            </interval>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\sigma}^{2}(x):=\frac{1}{N-1}\sum_{j=1}^{N}\left[Q(x,\xi^{j})-\frac{1}{N}%
\sum_{j=1}^{N}Q(x,\xi^{j})\right]^{2}
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>is the sample variance estimate of 

<math display="inline" id="Stochastic_programming:175">
 <semantics>
  <mrow>
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}(x)
  </annotation>
 </semantics>
</math>

. That is, the error of estimation of 

<math display="inline" id="Stochastic_programming:176">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 is (stochastically) of order 

<math display="inline" id="Stochastic_programming:177">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>N</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{N})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="multistage-portfolio-optimization">Multistage portfolio optimization</h2>

<p>The following is an example from finance of multi-stage stochastic programming. Suppose that at time 

<math display="inline" id="Stochastic_programming:178">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>


 we have initial capital 

<math display="inline" id="Stochastic_programming:179">
 <semantics>
  <msub>
   <mi>W</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{0}
  </annotation>
 </semantics>
</math>

 to invest in 

<math display="inline" id="Stochastic_programming:180">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 assets. Suppose further that we are allowed to rebalance our portfolio at times 

<math display="inline" id="Stochastic_programming:181">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1,\dots,T-1
  </annotation>
 </semantics>
</math>

 but without injecting additional cash into it. At each period 

<math display="inline" id="Stochastic_programming:182">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 we make a decision about redistributing the current wealth 

<math display="inline" id="Stochastic_programming:183">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{t}
  </annotation>
 </semantics>
</math>


 among the 

<math display="inline" id="Stochastic_programming:184">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 assets. Let 

<math display="inline" id="Stochastic_programming:185">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>10</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mn>0</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">10</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}=(x_{10},\dots,x_{n0})
  </annotation>
 </semantics>
</math>

 be the initial amounts invested in the n assets. We require that each 

<math display="inline" id="Stochastic_programming:186">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>i</mi>
    <mn>0</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i0}
  </annotation>
 </semantics>
</math>

 is nonnegative and that the balance equation 

<math display="inline" id="Stochastic_programming:187">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mn>0</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>W</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}x_{i0}=W_{0}
  </annotation>
 </semantics>
</math>

 should hold.</p>

<p>Consider the total returns 

<math display="inline" id="Stochastic_programming:188">
 <semantics>
  <mrow>
   <msub>
    <mi>ξ</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ξ</mi>
     <mrow>
      <mn>1</mn>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>ξ</mi>
     <mrow>
      <mi>n</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <ci>t</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{t}=(\xi_{1t},\dots,\xi_{nt})
  </annotation>
 </semantics>
</math>


 for each period 

<math display="inline" id="Stochastic_programming:189">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>T</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1,\dots,T
  </annotation>
 </semantics>
</math>

. This forms a vector-valued random process 

<math display="inline" id="Stochastic_programming:190">
 <semantics>
  <mrow>
   <msub>
    <mi>ξ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>ξ</mi>
    <mi>T</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{1},\dots,\xi_{T}
  </annotation>
 </semantics>
</math>

. At time period 

<math display="inline" id="Stochastic_programming:191">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1
  </annotation>
 </semantics>
</math>

, we can rebalance the portfolio by specifying the amounts 

<math display="inline" id="Stochastic_programming:192">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>11</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">11</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=(x_{11},\dots,x_{n1})
  </annotation>
 </semantics>
</math>

 invested in the respective assets. At that time the returns in the first period have been realized so it is reasonable to use this information in the rebalancing decision. Thus, the second-stage decisions, at time 

<math display="inline" id="Stochastic_programming:193">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1
  </annotation>
 </semantics>
</math>


, are actually functions of realization of the random vector 

<math display="inline" id="Stochastic_programming:194">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{1}
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Stochastic_programming:195">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ξ</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=x_{1}(\xi_{1})
  </annotation>
 </semantics>
</math>

. Similarly, at time 

<math display="inline" id="Stochastic_programming:196">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 the decision 

<math display="inline" id="Stochastic_programming:197">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mn>1</mn>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}=(x_{1t},\dots,x_{nt})
  </annotation>
 </semantics>
</math>

 is a function 

<math display="inline" id="Stochastic_programming:198">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ξ</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>t</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}=x_{t}(\xi_{[t]})
  </annotation>
 </semantics>
</math>


 of the available information given by 

<math display="inline" id="Stochastic_programming:199">
 <semantics>
  <mrow>
   <msub>
    <mi>ξ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>t</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ξ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>ξ</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>t</ci>
     </apply>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <ci>t</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{[t]}=(\xi_{1},\dots,\xi_{t})
  </annotation>
 </semantics>
</math>

 the history of the random process up to time 

<math display="inline" id="Stochastic_programming:200">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. A sequence of functions 

<math display="inline" id="Stochastic_programming:201">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ξ</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>t</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}=x_{t}(\xi_{[t]})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Stochastic_programming:202">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0,\dots,T-1
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Stochastic_programming:203">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>


 being constant, defines an <em>implementable policy</em> of the decision process. It is said that such a policy is <em>feasible</em> if it satisfies the model constraints with probability 1, i.e., the nonnegativity constraints 

<math display="inline" id="Stochastic_programming:204">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ξ</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>t</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{it}(\xi_{[t]})\geq 0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Stochastic_programming:205">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,n
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Stochastic_programming:206">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0,\dots,T-1
  </annotation>
 </semantics>
</math>

, and the balance of wealth constraints,</p>

<p>

<math display="block" id="Stochastic_programming:207">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mi>t</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ξ</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>t</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>W</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}x_{it}(\xi_{[t]})=W_{t},
  </annotation>
 </semantics>
</math>

</p>

<p>where in period 

<math display="inline" id="Stochastic_programming:208">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>T</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1,\dots,T
  </annotation>
 </semantics>
</math>


 the wealth 

<math display="inline" id="Stochastic_programming:209">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{t}
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Stochastic_programming:210">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>W</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>ξ</mi>
       <mrow>
        <mi>i</mi>
        <mi>t</mi>
       </mrow>
      </msub>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ξ</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <list>
        <ci>i</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{t}=\sum_{i=1}^{n}\xi_{it}x_{i,t-1}(\xi_{[t-1]}),
  </annotation>
 </semantics>
</math>

</p>

<p>which depends on the realization of the random process and the decisions up to time 

<math display="inline" id="Stochastic_programming:211">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.</p>

<p>Suppose the objective is to maximize the expected utility of this wealth at the last period, that is, to consider the problem</p>

<p>

<math display="block" id="Stochastic_programming:212">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>max</mi>
     <mi>E</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>U</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>W</mi>
        <mi>T</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <max></max>
     <ci>E</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>U</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max E[U(W_{T})].
  </annotation>
 </semantics>
</math>

</p>

<p>This is a multistage stochastic programming problem, where stages are numbered from 

<math display="inline" id="Stochastic_programming:213">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Stochastic_programming:214">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=T-1
  </annotation>
 </semantics>
</math>

. Optimization is performed over all implementable and feasible policies. To complete the problem description one also needs to define the probability distribution of the random process 

<math display="inline" id="Stochastic_programming:215">
 <semantics>
  <mrow>
   <msub>
    <mi>ξ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>ξ</mi>
    <mi>T</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{1},\dots,\xi_{T}
  </annotation>
 </semantics>
</math>

. This can be done in various ways. For example, one can construct a particular scenario tree defining time evolution of the process. If at every stage the random return of each asset is allowed to have two continuations, independent of other assets, then the total number of scenarios is 

<math display="inline" id="Stochastic_programming:216">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>n</mi>
    <mi>T</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{nT}
  </annotation>
 </semantics>
</math>

.</p>

<p>In order to write <a href="dynamic_programming" title="wikilink">dynamic programming</a> equations, consider the above multistage problem backward in time. At the last stage 

<math display="inline" id="Stochastic_programming:217">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=T-1
  </annotation>
 </semantics>
</math>

, a realization 

<math display="inline" id="Stochastic_programming:218">
 <semantics>
  <mrow>
   <msub>
    <mi>ξ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ξ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>ξ</mi>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{[T-1]}=(\xi_{1},\dots,\xi_{T-1})
  </annotation>
 </semantics>
</math>


 of the random process is known and 

<math display="inline" id="Stochastic_programming:219">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <minus></minus>
     <ci>T</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{T-2}
  </annotation>
 </semantics>
</math>

 has been chosen. Therefore, one needs to solve the following problem</p>

<p>

<math display="block" id="Stochastic_programming:220">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <munder>
      <mi>max</mi>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </munder>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>U</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>W</mi>
         <mi>T</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>ξ</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>T</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="right">
     <msub>
      <mi>W</mi>
      <mi>T</mi>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>ξ</mi>
        <mrow>
         <mi>i</mi>
         <mi>T</mi>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mrow>
          <mi>T</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mrow>
         <mi>T</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>W</mi>
      <msub>
       <mo>;</mo>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">U</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <ci>T</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <minus></minus>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>T</ci>
     </apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <list>
         <ci>i</ci>
         <apply>
          <minus></minus>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <list>
        <ci>i</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </list>
      </apply>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">W</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lrclr}\max\limits_{x_{T-1}}&E[U(W_{T})|\xi_{[T-1]}]&\\
\text{subject to}&W_{T}&=&\sum_{i=1}^{n}\xi_{iT}x_{i,T-1}\\
&\sum_{i=1}^{n}x_{i,T-1}&=&W;_{T-1}\\
&x_{T-1}&\geq&0\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Stochastic_programming:221">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>W</mi>
      <mi>T</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>ξ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">U</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>T</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[U(W_{T})|\xi_{[T-1]}]
  </annotation>
 </semantics>
</math>

 denotes the conditional expectation of 

<math display="inline" id="Stochastic_programming:222">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mi>T</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(W_{T})
  </annotation>
 </semantics>
</math>


 given 

<math display="inline" id="Stochastic_programming:223">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{[T-1]}
  </annotation>
 </semantics>
</math>

. The optimal value of the above problem depends on 

<math display="inline" id="Stochastic_programming:224">
 <semantics>
  <msub>
   <mi>W</mi>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <apply>
     <minus></minus>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{T-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_programming:225">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{[T-1]}
  </annotation>
 </semantics>
</math>

 and is denoted 

<math display="inline" id="Stochastic_programming:226">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>ξ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{T-1}(W_{T-1},\xi_{[T-1]})
  </annotation>
 </semantics>
</math>

.</p>

<p>Similarly, at stages 

<math display="inline" id="Stochastic_programming:227">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=T-2,\dots,1
  </annotation>
 </semantics>
</math>


, one should solve the problem</p>

<p>

<math display="block" id="Stochastic_programming:228">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <munder>
      <mi>max</mi>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
     </munder>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>Q</mi>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>W</mi>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>ξ</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mi>t</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>ξ</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>t</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="right">
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>ξ</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>t</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>t</mi>
       </mrow>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>W</mi>
      <msub>
       <mo>;</mo>
       <mi>t</mi>
      </msub>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <msub>
      <mi>x</mi>
      <mi>t</mi>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-,</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ξ</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <plus></plus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <list>
         <ci>i</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <list>
         <ci>i</ci>
         <ci>t</ci>
        </list>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <list>
        <ci>i</ci>
        <ci>t</ci>
       </list>
      </apply>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">W</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <ci>t</ci>
      </apply>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lrclr}\max\limits_{x_{t}}&E[Q_{t+1}(W_{t+1},\xi_{[t+1]})|\xi_{%
[t]}]&\\
\text{subject to}&W_{t+1}&=&\sum_{i=1}^{n}\xi_{i,t+1}x_{i,t}\\
&\sum_{i=1}^{n}x_{i,t}&=&W;_{t}\\
&x_{t}&\geq&0\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>whose optimal value is denoted by 

<math display="inline" id="Stochastic_programming:229">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mi>t</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>ξ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>t</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>t</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{t}(W_{t},\xi_{[t]})
  </annotation>
 </semantics>
</math>

. Finally, at stage 

<math display="inline" id="Stochastic_programming:230">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>

, one solves the problem</p>

<p>

<math display="block" id="Stochastic_programming:231">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <munder>
      <mi>max</mi>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
     </munder>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>Q</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>W</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>ξ</mi>
          <mrow>
           <mo stretchy="false">[</mo>
           <mn>1</mn>
           <mo stretchy="false">]</mo>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="right">
     <msub>
      <mi>W</mi>
      <mn>1</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>ξ</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mn>0</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mn>0</mn>
       </mrow>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>W</mi>
      <msub>
       <mo>;</mo>
       <mn>0</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">1</cn>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>W</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ξ</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <list>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">W</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">0</cn>
      </apply>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lrclr}\max\limits_{x_{0}}&E[Q_{1}(W_{1},\xi_{[1]})]&\\
\text{subject to}&W_{1}&=&\sum_{i=1}^{n}\xi_{i,1}x_{i0}\\
&\sum_{i=1}^{n}x_{i0}&=&W;_{0}\\
&x_{0}&\geq&0\end{array}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="stagewise-independent-random-process">Stagewise independent random process</h3>

<p>For a general distribution of the process 

<math display="inline" id="Stochastic_programming:232">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{t}
  </annotation>
 </semantics>
</math>

, it may be hard to solve these dynamic programming equations. The situation simplifies dramatically if the process 

<math display="inline" id="Stochastic_programming:233">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{t}
  </annotation>
 </semantics>
</math>

 is stagewise independent, i.e., 

<math display="inline" id="Stochastic_programming:234">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{t}
  </annotation>
 </semantics>
</math>

 is (stochastically) independent of 

<math display="inline" id="Stochastic_programming:235">
 <semantics>
  <mrow>
   <msub>
    <mi>ξ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>ξ</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ξ</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{1},\dots,\xi_{t-1}
  </annotation>
 </semantics>
</math>


 for 

<math display="inline" id="Stochastic_programming:236">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>T</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=2,\dots,T
  </annotation>
 </semantics>
</math>

. In this case, the corresponding conditional expectations become unconditional expectations, and the function 

<math display="inline" id="Stochastic_programming:237">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{t}(W_{t})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Stochastic_programming:238">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1,\dots,T-1
  </annotation>
 </semantics>
</math>

 does not depend on 

<math display="inline" id="Stochastic_programming:239">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>t</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{[t]}
  </annotation>
 </semantics>
</math>

. That is, 

<math display="inline" id="Stochastic_programming:240">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{T-1}(W_{T-1})
  </annotation>
 </semantics>
</math>


 is the optimal value of the problem</p>

<p>

<math display="block" id="Stochastic_programming:241">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <munder>
      <mi>max</mi>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </munder>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>U</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>W</mi>
          <mi>T</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="right">
     <msub>
      <mi>W</mi>
      <mi>T</mi>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>ξ</mi>
        <mrow>
         <mi>i</mi>
         <mi>T</mi>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mrow>
          <mi>T</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mrow>
         <mi>T</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>W</mi>
      <msub>
       <mo>;</mo>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>U</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>T</ci>
     </apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <list>
         <ci>i</ci>
         <apply>
          <minus></minus>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <list>
        <ci>i</ci>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </list>
      </apply>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">W</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lrclr}\max\limits_{x_{T-1}}&E[U(W_{T})]&\\
\text{subject to}&W_{T}&=&\sum_{i=1}^{n}\xi_{iT}x_{i,T-1}\\
&\sum_{i=1}^{n}x_{i,T-1}&=&W;_{T-1}\\
&x_{T-1}&\geq&0\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Stochastic_programming:242">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{t}(W_{t})
  </annotation>
 </semantics>
</math>

 is the optimal value of</p>

<p>

<math display="block" id="Stochastic_programming:243">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <munder>
      <mi>max</mi>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
     </munder>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>Q</mi>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>W</mi>
          <mrow>
           <mi>t</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="right">
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>ξ</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>t</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>t</mi>
       </mrow>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>W</mi>
      <msub>
       <mo>;</mo>
       <mi>t</mi>
      </msub>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="right">
     <msub>
      <mi>x</mi>
      <mi>t</mi>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <list>
         <ci>i</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <list>
         <ci>i</ci>
         <ci>t</ci>
        </list>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <list>
        <ci>i</ci>
        <ci>t</ci>
       </list>
      </apply>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">W</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <ci>t</ci>
      </apply>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lrclr}\max\limits_{x_{t}}&E[Q_{t+1}(W_{t+1})]&\\
\text{subject to}&W_{t+1}&=&\sum_{i=1}^{n}\xi_{i,t+1}x_{i,t}\\
&\sum_{i=1}^{n}x_{i,t}&=&W;_{t}\\
&x_{t}&\geq&0\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>for 

<math display="inline" id="Stochastic_programming:244">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <list>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=T-2,\dots,1
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="stochastic-programming-for-nonlinear-optimization">Stochastic programming for nonlinear optimization</h2>

<p>Many of the optimization problems in science and engineering involve nonlinear objective functions with uncertain model. In these cases, stochastic programming is applied to optimize the expected objective (sample average) over a set of realizations generated using Monte Carlo simulation.</p>

<p>For expensive function evaluations, model selection is used to reduce the number of realizations. Techniques such as out-of-sample validation is used to reduce the number of required realizations and the number of representative realizations. Recently, optimization with sample validation (OSV) (also referred to as "multilevel optimization with validation", MLOV) is proposed to significantly reduce the computational cost in stochastic programming for expensive function evaluations. Optimization with sample validation determines, in a systematic way, the number of realizations in optimization to adequately represent the entire set. Stochastic programming with OSV has been applied for optimization of oil field development planning (well placement and control optimization). <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="biological-applications">Biological applications</h2>

<p>Stochastic <a href="dynamic_programming" title="wikilink">dynamic programming</a> is frequently used to model <a href="ethology" title="wikilink">animal behaviour</a> in such fields as <a href="behavioural_ecology" title="wikilink">behavioural ecology</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Empirical tests of models of <a href="Optimal_foraging_theory" title="wikilink">optimal foraging</a>, <a href="Biological_life_cycle" title="wikilink">life-history</a> transitions such as <a href="Fledge" title="wikilink">fledging in birds</a> and egg laying in <a class="uri" href="parasitoid" title="wikilink">parasitoid</a> wasps have shown the value of this modelling technique in explaining the evolution of behavioural decision making. These models are typically many-staged, rather than two-staged.</p>
<h2 id="economic-applications">Economic applications</h2>

<p>Stochastic dynamic programming is a useful tool in understanding decision making under uncertainty. The accumulation of capital stock under uncertainty is one example; often it is used by resource economists to analyze <a href="Bioeconomics" title="wikilink">bioeconomic problems</a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> where the uncertainty enters in such as weather, etc.</p>
<h2 id="software-tools">Software tools</h2>
<h3 id="modelling-languages">Modelling languages</h3>

<p>All discrete stochastic programming problems can be represented with any <a href="algebraic_modeling_language" title="wikilink">algebraic modeling language</a>, manually implementing explicit or implicit non-anticipativity to make sure the resulting model respects the structure of the information made available at each stage. An instance of an SP problem generated by a general modelling language tends to grow quite large (linearly in the number of scenarios), and its matrix looses the structure that is intrinsic to this class of problems, which could otherwise be exploited at solution time by specific decomposition algorithms. Extensions to modelling languages specifically designed for SP are starting to appear, see:</p>
<ul>
<li><a class="uri" href="AIMMS" title="wikilink">AIMMS</a> - supports the definition of SP problems</li>
<li><a class="uri" href="FuncDesigner" title="wikilink">FuncDesigner</a> - free software that includes stochastic programming and optimization by <a class="uri" href="OpenOpt" title="wikilink">OpenOpt</a> solvers; <a href="http://openopt.org/StochasticProgramming#Local_nonlinear_optimization_example">example1</a>, <a href="http://openopt.org/StochasticProgramming#Global_nonlinear_optimization_example">example2</a>, <a href="http://openopt.org/StochasticProgramming#Example_with_15_unknown_variables">example3</a></li>
<li><a class="uri" href="SAMPL" title="wikilink">SAMPL</a> - a set of extensions to <a class="uri" href="AMPL" title="wikilink">AMPL</a> specifically designed to express stochastic programs (includes syntax for chance constraints, integrated chance constraints and <a href="Robust_optimization" title="wikilink">Robust Optimization</a> problems)</li>
</ul>

<p>They both can generate SMPS instance level format, which conveys in a non-redundant form the structure of the problem to the solver.</p>
<h3 id="solvers">Solvers</h3>
<ul>
<li><a class="uri" href="FortSP" title="wikilink">FortSP</a> - solver for stochastic programming problems; it accepts SMPS input and implements various decomposition algorithms.</li>
<li>NEOS Solvers - Three solvers are available in the <a href="http://neos.mcs.anl.gov/neos/solvers/">Neos Server</a>: Bouncing Nested Benders Solvers (BNBS) for multi-stage stochastic linear programs, ddsip for two-stage stochastic programs with integer recourse, and Stochastic Decomposition (SD) for two-stage stochastic linear programs.</li>
<li><a href="http://www.coin-or.org/projects/Smi.xml">COIN-OR Stochastic Modeling Interface</a> - An open source project within <a class="uri" href="COIN-OR" title="wikilink">COIN-OR</a>. It can read Stochastic MPS<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> input format as well as supports direct interfaces for scenario input, and generates the deterministic equivalent linear program for solution by COIN-OR solvers.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Probabilistic-based_design_optimization" title="wikilink">Probabilistic-based design optimization</a></li>
<li><a href="SAMPL" title="wikilink"> SAMPL algebraic modeling language</a></li>
<li><a href="Scenario_optimization" title="wikilink">Scenario optimization</a></li>
<li><a href="Stochastic_optimization" title="wikilink">Stochastic optimization</a></li>
<li><a href="Stochastic_control" title="wikilink">Stochastic control</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>John R. Birge and François V. Louveaux. <em>Introduction to Stochastic Programming</em>. Springer Verlag, New York, 1997.</li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>G. Ch. Pflug: <em>Optimization of Stochastic Models. The Interface between Simulation and Optimization</em>. Kluwer, Dordrecht, 1996.</li>
</ul>
<ul>
<li><a href="Andras_Prekopa" title="wikilink">Andras Prekopa</a>. Stochastic Programming. Kluwer Academic Publishers, Dordrecht, 1995.</li>
</ul>
<ul>
<li><a href="Andrzej_Piotr_Ruszczyński" title="wikilink">Andrzej Ruszczynski</a> and Alexander Shapiro (eds.) (2003) <em>Stochastic Programming</em>. Handbooks in Operations Research and Management Science, Vol. 10, Elsevier.</li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>Stein W. Wallace and William T. Ziemba (eds.) (2005) <em>Applications of Stochastic Programming</em>. MPS-SIAM Book Series on Optimization 5</li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://stoprog.org">Stochastic Programming Community Home Page</a></li>
</ul>

<p>"</p>

<p><a href="Category:Stochastic_optimization" title="wikilink">Category:Stochastic optimization</a> <a href="Category:Stochastic_algorithms" title="wikilink">Category:Stochastic algorithms</a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Stein W. Wallace and William T. Ziemba (eds.). <em>Applications of Stochastic Programming</em>. MPS-SIAM Book Series on Optimization 5, 2005.<a href="#fnref2">↩</a></li>
<li id="fn3">Applications of stochastic programming are described at the following website, <a href="http://stoprog.org">Stochastic Programming Community</a>.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="http://www.neos-server.org/neos/">http://www.neos-server.org/neos/</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">Mangel, M. &amp; Clark, C. W. 1988. <em>Dynamic modeling in behavioral ecology.</em> Princeton University Press ISBN 0-691-08506-4<a href="#fnref8">↩</a></li>
<li id="fn9">Houston, A. I &amp; McNamara, J. M. 1999. <em>Models of adaptive behaviour: an approach based on state</em>. Cambridge University Press ISBN 0-521-65539-0<a href="#fnref9">↩</a></li>
<li id="fn10">Howitt, R., Msangi, S., Reynaud, A and K. Knapp. 2002. <a href="http://www.agecon.ucdavis.edu/aredepart/facultydocs/Howitt/Polyapprox3a.pdf">"Using Polynomial Approximations to Solve Stochastic Dynamic Programming Problems: or A "Betty Crocker " Approach to SDP."</a> University of California, Davis, Department of Agricultural and Resource Economics Working Paper.<a href="#fnref10">↩</a></li>
<li id="fn11">J.R. Birge, M.A.H. Dempster, H.I. Gassmann, E.A. Gunn, A.J. King and S.W. Wallace, <em>A standard input format for multiperiod stochastic linear programs</em>, COAL Newsletter #17 (1987) pp. 1-19.<a href="#fnref11">↩</a></li>
</ol>
</section>
</hr></body>
</html>
