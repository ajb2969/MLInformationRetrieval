<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1338">Torsion tensor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Torsion tensor</h1>
<hr/>

<p> In <a href="differential_geometry" title="wikilink">differential geometry</a>, the notion of <strong>torsion</strong> is a manner of characterizing a twist or <a href="screw_theory" title="wikilink">screw</a> of a <a href="moving_frame" title="wikilink">moving frame</a> around a curve. The <a href="torsion_of_curves" title="wikilink">torsion of a curve</a>, as it appears in the <a href="Frenet–Serret_formulas" title="wikilink">Frenet–Serret formulas</a>, for instance, quantifies the twist of a curve about its tangent vector as the curve evolves (or rather the rotation of the Frenet–Serret frame about the tangent vector). In the geometry of surfaces, the <em>geodesic torsion</em> describes how a surface twists about a curve on the surface. The companion notion of <a class="uri" href="curvature" title="wikilink">curvature</a> measures how moving frames "roll" along a curve "without twisting".</p>

<p>More generally, on a <a href="differentiable_manifold" title="wikilink">differentiable manifold</a> equipped with an <a href="affine_connection" title="wikilink">affine connection</a> (that is, a <a href="connection_(vector_bundle)" title="wikilink">connection</a> in the <a href="tangent_bundle" title="wikilink">tangent bundle</a>), torsion and curvature form the two fundamental invariants of the connection. In this context, torsion gives an intrinsic characterization of how <a href="tangent_space" title="wikilink">tangent spaces</a> twist about a curve when they are <a href="parallel_transport" title="wikilink">parallel transported</a>; whereas curvature describes how the tangent spaces roll along the curve. Torsion may be described concretely as a <a class="uri" href="tensor" title="wikilink">tensor</a>, or as a <a href="vector-valued_form" title="wikilink">vector-valued</a> <a class="uri" href="two-form" title="wikilink">two-form</a> on the manifold. If ∇ is an affine connection on a <a href="differential_manifold" title="wikilink">differential manifold</a>, then the torsion tensor is defined, in terms of vector fields <em>X</em> and <em>Y</em>, by</p>

<p>

<math display="block" id="Torsion_tensor:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mi>X</mi>
     </msub>
     <mi>Y</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mi>Y</mi>
     </msub>
     <mi>X</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <ci>X</ci>
      </apply>
      <ci>Y</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <ci>Y</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <interval closure="closed">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(X,Y)=\nabla_{X}Y-\nabla_{Y}X-[X,Y]
  </annotation>
 </semantics>
</math>

 where [<em>X</em>,<em>Y</em>] is the <a href="Lie_bracket_of_vector_fields" title="wikilink">Lie bracket of vector fields</a>.</p>

<p>Torsion is particularly useful in the study of the geometry of <a href="geodesic" title="wikilink">geodesics</a>. Given a system of parametrized geodesics, one can specify a class of affine connections having those geodesics, but differing by their torsions. There is a unique connection which <em>absorbs the torsion</em>, generalizing the <a href="Levi-Civita_connection" title="wikilink">Levi-Civita connection</a> to other, possibly non-metric situations (such as <a href="Finsler_geometry" title="wikilink">Finsler geometry</a>). Absorption of torsion also plays a fundamental role in the study of <a href="G-structure" title="wikilink">G-structures</a> and <a href="Cartan's_equivalence_method" title="wikilink">Cartan's equivalence method</a>. Torsion is also useful in the study of unparametrized families of geodesics, via the associated <a href="projective_connection" title="wikilink">projective connection</a>. In <a href="relativity_theory" title="wikilink">relativity theory</a>, such ideas have been implemented in the form of <a href="Einstein–Cartan_theory" title="wikilink">Einstein–Cartan theory</a>.</p>
<h2 id="the-torsion-tensor">The torsion tensor</h2>

<p>Let <em>M</em> be a manifold with a connection ∇ on the tangent bundle. The <strong>torsion tensor</strong> (sometimes called the <em>Cartan</em> (<em>torsion</em>) <em>tensor</em>) is a <a href="vector-valued_form" title="wikilink">vector-valued 2-form</a> defined on <a href="vector_field" title="wikilink">vector fields</a> <em>X</em> and <em>Y</em> by</p>

<p>

<math display="block" id="Torsion_tensor:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mi>X</mi>
     </msub>
     <mi>Y</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mi>Y</mi>
     </msub>
     <mi>X</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <ci>X</ci>
      </apply>
      <ci>Y</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <ci>Y</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <interval closure="closed">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(X,Y):=\nabla_{X}Y-\nabla_{Y}X-[X,Y]
  </annotation>
 </semantics>
</math>

</p>

<p>where [<em>X</em>,<em>Y</em>] is the <a href="Lie_bracket_of_vector_fields" title="wikilink">Lie bracket</a> of two vector fields. By the <a href="Leibniz_rule_(generalized_product_rule)" title="wikilink">Leibniz rule</a>, <em>T</em>(<em>fX</em>,<em>Y</em>) = <em>T</em>(<em>X</em>,<em>fY</em>) = <em>fT</em>(<em>X</em>,<em>Y</em>) for any <a href="smooth_function" title="wikilink">smooth function</a> <em>f</em>. So <em>T</em> is <a class="uri" href="tensorial" title="wikilink">tensorial</a>, despite being defined in terms of the non-tensorial <a href="covariant_derivative" title="wikilink">covariant derivative</a>: it gives a 2-form on tangent vectors, while the covariant derivative is only defined for vector fields.</p>
<h3 id="curvature-and-the-bianchi-identities">Curvature and the Bianchi identities</h3>

<p>The <a href="Riemann_curvature_tensor" title="wikilink">curvature tensor</a> of ∇ is a mapping T<em>M</em> × T<em>M</em> → End(T<em>M</em>) defined on vector fields <em>X</em>, <em>Y</em>, and <em>Z</em> by</p>

<p>

<math display="block" id="Torsion_tensor:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Z</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mo>∇</mo>
        <mi>X</mi>
       </msub>
       <msub>
        <mo>∇</mo>
        <mi>Y</mi>
       </msub>
      </mrow>
      <mi>Z</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <msub>
        <mo>∇</mo>
        <mi>Y</mi>
       </msub>
       <msub>
        <mo>∇</mo>
        <mi>X</mi>
       </msub>
      </mrow>
      <mi>Z</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mo>∇</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>X</mi>
        <mo>,</mo>
        <mi>Y</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </msub>
      <mi>Z</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
     <ci>Z</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <ci>Z</ci>
     </apply>
     <apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <ci>Y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <ci>Z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <interval closure="closed">
        <ci>X</ci>
        <ci>Y</ci>
       </interval>
      </apply>
      <ci>Z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(X,Y)Z=\nabla_{X}\nabla_{Y}Z-\nabla_{Y}\nabla_{X}Z-\nabla_{[X,Y]}Z.
  </annotation>
 </semantics>
</math>

 Note that, for vectors at a point, this definition is independent of how the vectors are extended to vector fields away from the point (thus it defines a tensor, much like the torsion).</p>

<p>The <strong>Bianchi identities</strong> relate the curvature and torsion as follows.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Let 

<math display="inline" id="Torsion_tensor:3">
 <semantics>
  <mi>𝔖</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔖</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{S}
  </annotation>
 </semantics>
</math>

 denote the <a href="cyclic_permutation" title="wikilink">cyclic sum</a> over <em>X</em>, <em>Y</em>, and <em>Z</em>. For instance,</p>

<p>

<math display="block" id="Torsion_tensor:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝔖</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo>,</mo>
        <mi>Y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>Z</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo>,</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>Z</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo>,</mo>
       <mi>Z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>X</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Z</mi>
       <mo>,</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>Y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>𝔖</ci>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <ci>X</ci>
       <ci>Y</ci>
      </interval>
      <ci>Z</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <ci>X</ci>
       <ci>Y</ci>
      </interval>
      <ci>Z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <ci>Y</ci>
       <ci>Z</ci>
      </interval>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <ci>Z</ci>
       <ci>X</ci>
      </interval>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{S}\left(R(X,Y)Z\right):=R(X,Y)Z+R(Y,Z)X+R(Z,X)Y.
  </annotation>
 </semantics>
</math>

 Then the following identities hold</p>

<p>1. <strong>Bianchi's first identity:</strong></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Torsion_tensor:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔖</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo>,</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>Z</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝔖</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>T</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo>,</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>Z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mo>∇</mo>
          <mi>X</mi>
         </msub>
         <mi>T</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Y</mi>
        <mo>,</mo>
        <mi>Z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝔖</ci>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <ci>X</ci>
       <ci>Y</ci>
      </interval>
      <ci>Z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝔖</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>T</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>T</ci>
         <interval closure="open">
          <ci>X</ci>
          <ci>Y</ci>
         </interval>
        </apply>
        <ci>Z</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-∇</ci>
         <ci>X</ci>
        </apply>
        <ci>T</ci>
       </apply>
       <interval closure="open">
        <ci>Y</ci>
        <ci>Z</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{S}\left(R(X,Y)Z\right)=\mathfrak{S}\left(T(T(X,Y),Z)+(\nabla_{X}T)(Y%
,Z)\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>2. <strong>Bianchi's second identity:</strong></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Torsion_tensor:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔖</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mo>∇</mo>
          <mi>X</mi>
         </msub>
         <mi>R</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Y</mi>
        <mo>,</mo>
        <mi>Z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>T</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo>,</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>Z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝔖</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-∇</ci>
         <ci>X</ci>
        </apply>
        <ci>R</ci>
       </apply>
       <interval closure="open">
        <ci>Y</ci>
        <ci>Z</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>T</ci>
         <interval closure="open">
          <ci>X</ci>
          <ci>Y</ci>
         </interval>
        </apply>
        <ci>Z</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{S}\left((\nabla_{X}R)(Y,Z)+R(T(X,Y),Z)\right)=0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="components-of-the-torsion-tensor">Components of the torsion tensor</h3>

<p>The components of the torsion tensor 

<math display="inline" id="Torsion_tensor:7">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mi>c</mi>
   </msup>
   <msub>
    <mi></mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{c}{}_{ab}
  </annotation>
 </semantics>
</math>

 in terms of a local <a href="basis_of_a_vector_space" title="wikilink">basis</a> of <a href="section_(fiber_bundle)" title="wikilink">sections</a> (<strong>e</strong><sub>1</sub>, ..., <strong>e</strong><sub>n</sub>) of the tangent bundle can be derived by setting <em>X</em>=<strong>e</strong><sub>i</sub>, <em>Y</em>=<strong>e</strong><sub>j</sub> and by introducing the commutator coefficients γ<sup>k</sup><sub>ij</sub><strong>e</strong><sub>k</sub> := [<strong>e</strong><sub>i</sub>,<strong>e</strong><sub>j</sub>]. The components of the torsion are then</p>

<p>

<math display="block" id="Torsion_tensor:8">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mo>:=</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mo>-</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mo>-</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>j</mi>
     <mi>i</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <msup>
    <mi>γ</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mo rspace="12.5pt">,</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo>=</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <minus></minus>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <minus></minus>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>γ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-,</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">i</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">j</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">k</csymbol>
    <eq></eq>
    <cn type="integer">1</cn>
    <ci>normal-,</ci>
    <cn type="integer">2</cn>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{k}{}_{ij}:=\Gamma^{k}{}_{ij}-\Gamma^{k}{}_{ji}-\gamma^{k}{}_{ij},\quad i,j,%
k=1,2,\ldots,n.
  </annotation>
 </semantics>
</math>

</p>

<p>If the basis is <a href="Holonomic_basis" title="wikilink">holonomic</a> then the Lie brackets vanish, 

<math display="inline" id="Torsion_tensor:9">
 <semantics>
  <mrow>
   <msup>
    <mi>γ</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mo>=</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>γ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma^{k}{}_{ij}=0
  </annotation>
 </semantics>
</math>

. So 

<math display="inline" id="Torsion_tensor:10">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mo>=</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <mn>2</mn>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mi>k</mi>
   </msup>
   <msub>
    <mi></mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{k}{}_{ij}=2\Gamma^{k}{}_{[ij]}
  </annotation>
 </semantics>
</math>

. In particular (see below) while the <a href="geodesic" title="wikilink"> geodesic equations</a> determine the symmetric part of the connection, the torsion tensor determines the antisymmetric part.</p>
<h3 id="the-torsion-form">The torsion form</h3>

<p>The <strong>torsion form</strong>, an alternative characterization of torsion, applies to the <a href="frame_bundle" title="wikilink">frame bundle</a> F<em>M</em> of the manifold <em>M</em>. This <a href="principal_bundle" title="wikilink">principal bundle</a> is equipped with a <a href="connection_(principal_bundle)" title="wikilink">connection form</a> ω, a <strong>gl</strong>(<em>n</em>)-valued one-form which maps vertical vectors to the generators of the right action in <strong>gl</strong>(<em>n</em>) and equivariantly intertwines the right action of GL(<em>n</em>) on the tangent bundle of F<em>M</em> with the <a href="Adjoint_representation_of_a_Lie_group" title="wikilink">adjoint representation</a> on <strong>gl</strong>(<em>n</em>). The frame bundle also carries a <a href="solder_form" title="wikilink">canonical one-form</a> θ, with values in <strong>R</strong><sup>n</sup>, defined at a frame <em>u</em> ∈ F<sub>x</sub><em>M</em> (regarded as a linear function <em>u</em> : <strong>R</strong><sup>n</sup> → T<sub>x</sub><em>M</em>) by</p>

<p>

<math display="block" id="Torsion_tensor:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>u</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>θ</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>π</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(X)=u^{-1}(d\pi(X))
  </annotation>
 </semantics>
</math>

 where π : F<em>M</em> → <em>M</em> is the projection mapping for the principal bundle. The torsion form is then</p>

<p>

<math display="block" id="Torsion_tensor:12">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>d</mi>
       <mi>θ</mi>
      </mrow>
      <mo>+</mo>
      <mi>ω</mi>
     </mrow>
     <mo>∧</mo>
     <mi>θ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Θ</ci>
    <apply>
     <and></and>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>θ</ci>
      </apply>
      <ci>ω</ci>
     </apply>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta=d\theta+\omega\wedge\theta.
  </annotation>
 </semantics>
</math>

 Equivalently, Θ = Dθ, where <em>D</em> is the <a href="exterior_covariant_derivative" title="wikilink">exterior covariant derivative</a> determined by the connection.</p>

<p>The torsion form is a (horizontal) <a href="tensorial_form" title="wikilink">tensorial form</a> with values in <strong>R</strong><sup>n</sup>, meaning that under the right action of <em>g</em> ∈ Gl(<em>n</em>) it transforms equivariantly:</p>

<p>

<math display="block" id="Torsion_tensor:13">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>R</mi>
     <mi>g</mi>
     <mo>*</mo>
    </msubsup>
    <mi mathvariant="normal">Θ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>⋅</mo>
    <mi mathvariant="normal">Θ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>g</ci>
      </apply>
      <times></times>
     </apply>
     <ci>normal-Θ</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-Θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{g}^{*}\Theta=g^{-1}\cdot\Theta
  </annotation>
 </semantics>
</math>

 where <em>g</em> acts on the right-hand side through its fundamental representation on <strong>R</strong><sup>n</sup>.</p>
<h3 id="the-curvature-form-and-bianchi-identities">The curvature form and Bianchi identities</h3>

<p>The <a href="curvature_form" title="wikilink">curvature form</a> is the <strong>gl</strong>(<em>n</em>)-valued 2-form</p>

<p>

<math display="block" id="Torsion_tensor:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mi>ω</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>d</mi>
      <mi>ω</mi>
     </mrow>
     <mo>+</mo>
     <mi>ω</mi>
    </mrow>
    <mo>∧</mo>
    <mi>ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>normal-Ω</ci>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>ω</ci>
       </apply>
       <ci>ω</ci>
      </apply>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=D\omega=d\omega+\omega\wedge\omega
  </annotation>
 </semantics>
</math>

 where, again, <em>D</em> denotes the exterior covariant derivative. In terms of the curvature form and torsion form, the corresponding Bianchi identities are<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<ol>
<li>

<math display="inline" id="Torsion_tensor:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mi mathvariant="normal">Θ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>∧</mo>
    <mi>θ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>normal-Θ</ci>
    </apply>
    <apply>
     <and></and>
     <ci>normal-Ω</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\Theta=\Omega\wedge\theta
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Torsion_tensor:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mi mathvariant="normal">Ω</mi>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>normal-Ω</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\Omega=0.\,
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>Moreover, one can recover the curvature and torsion tensors from the curvature and torsion forms as follows. At a point <em>u</em> of F<sub>x</sub><em>M</em>, one has<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Torsion_tensor:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Z</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>2</mn>
       <mi mathvariant="normal">Ω</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>π</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msup>
          <mi>π</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>u</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
     <ci>Z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>normal-Ω</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>π</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>π</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>Y</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>Z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(X,Y)Z=u\left(2\Omega(\pi^{-1}(X),\pi^{-1}(Y))\right)(u^{-1}(Z)),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Torsion_tensor:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>2</mn>
       <mi mathvariant="normal">Θ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>π</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msup>
          <mi>π</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>normal-Θ</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>π</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>π</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>Y</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(X,Y)=u\left(2\Theta(\pi^{-1}(X),\pi^{-1}(Y))\right),
  </annotation>
 </semantics>
</math>

 where again <em>u</em> : <strong>R</strong><sup>n</sup> → T<sub>x</sub><em>M</em> is the function specifying the frame in the fibre, and the choice of lift of the vectors via π<sup>−1</sup> is irrelevant since the curvature and torsion forms are horizontal (they vanish on the ambiguous vertical vectors).</p>
<h4 id="torsion-form-in-a-frame">Torsion form in a frame</h4>

<p>The torsion form may be expressed in terms of a <a href="connection_form" title="wikilink">connection form</a> on the base manifold <em>M</em>, written in a particular frame of the tangent bundle (<strong>e</strong><sub>1</sub>,...,<strong>e</strong><sub>n</sub>). The connection form expresses the exterior covariant derivative of these basic sections:</p>

<p>

<math display="block" id="Torsion_tensor:19">
 <semantics>
  <mrow>
   <mi>D</mi>
   <msub>
    <mi>𝐞</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>𝐞</mi>
    <mi>j</mi>
   </msub>
   <msup>
    <mi>ω</mi>
    <mi>j</mi>
   </msup>
   <mmultiscripts>
    <mo>.</mo>
    <mprescripts></mprescripts>
    <mi>i</mi>
    <none></none>
   </mmultiscripts>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐞</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐞</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-.</ci>
     <ci>i</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D{\mathbf{e}}_{i}={\mathbf{e}}_{j}\omega^{j}{}_{i}.
  </annotation>
 </semantics>
</math>

 The <a href="solder_form" title="wikilink">solder form</a> for the tangent bundle (relative to this frame) is the <a href="dual_basis" title="wikilink">dual basis</a> θ<sup>i</sup> ∈ T<sup>*</sup><em>M</em> of the <strong>e</strong><sub>i</sub>, so that θ<sup>i</sup>(<strong>e</strong><sub>j</sub>) = δ<sup>i</sup><sub>j</sub> (the <a href="Kronecker_delta" title="wikilink">Kronecker delta</a>.) Then the torsion 2-form has components</p>

<p>

<math display="block" id="Torsion_tensor:20">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Θ</mi>
    <mi>k</mi>
   </msup>
   <mo>=</mo>
   <mi>d</mi>
   <msup>
    <mi>θ</mi>
    <mi>k</mi>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>ω</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mo>∧</mo>
    <mprescripts></mprescripts>
    <mi>j</mi>
    <none></none>
   </mmultiscripts>
   <msup>
    <mi>θ</mi>
    <mi>j</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>T</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mi>θ</mi>
    <none></none>
    <mi>i</mi>
    <mprescripts></mprescripts>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <mo>∧</mo>
   <msup>
    <mi>θ</mi>
    <mi>j</mi>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Θ</ci>
     <ci>k</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">d</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>θ</ci>
     <ci>k</ci>
    </apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <and></and>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>θ</ci>
     <ci>j</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>θ</ci>
     <ci>j</ci>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta^{k}=d\theta^{k}+\omega^{k}{}_{j}\wedge\theta^{j}=T^{k}{}_{ij}\theta^{i}%
\wedge\theta^{j}.
  </annotation>
 </semantics>
</math>

</p>

<p>In the rightmost expression,</p>

<p>

<math display="block" id="Torsion_tensor:21">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mo>=</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <msup>
    <mi>θ</mi>
    <mi>k</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mo>∇</mo>
     <msub>
      <mi>𝐞</mi>
      <mi>i</mi>
     </msub>
    </msub>
    <msub>
     <mi>𝐞</mi>
     <mi>j</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mo>∇</mo>
     <msub>
      <mi>𝐞</mi>
      <mi>j</mi>
     </msub>
    </msub>
    <msub>
     <mi>𝐞</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>𝐞</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>𝐞</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>θ</ci>
     <ci>k</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-∇</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐞</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <ci>j</ci>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-∇</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐞</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <ci>i</ci>
     </apply>
     <minus></minus>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐞</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐞</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{k}{}_{ij}=\theta^{k}(\nabla_{\mathbf{e}_{i}}\mathbf{e}_{j}-\nabla_{\mathbf{%
e}_{j}}\mathbf{e}_{i}-[\mathbf{e}_{i},\mathbf{e}_{j}])
  </annotation>
 </semantics>
</math>

 are the frame-components of the torsion tensor, as given in the previous definition.</p>

<p>It can be easily shown that Θ<sup>i</sup> transforms tensorially in the sense that if a different frame</p>

<p>

<math display="block" id="Torsion_tensor:22">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>𝐞</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>𝐞</mi>
    <mi>j</mi>
   </msub>
   <msup>
    <mi>g</mi>
    <mi>j</mi>
   </msup>
   <msub>
    <mi></mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>𝐞</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐞</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <ci>i</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mathbf{e}}_{i}=\mathbf{e}_{j}g^{j}{}_{i}
  </annotation>
 </semantics>
</math>

 for some invertible matrix-valued function (<em>g</em><sub>i</sub><sup>j</sup>), then</p>

<p>

<math display="block" id="Torsion_tensor:23">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mover accent="true">
      <mi mathvariant="normal">Θ</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mi>i</mi>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>g</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>i</mi>
     </msup>
     <mmultiscripts>
      <mi mathvariant="normal">Θ</mi>
      <none></none>
      <mi>j</mi>
      <mprescripts></mprescripts>
      <mi>j</mi>
      <none></none>
     </mmultiscripts>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>normal-Θ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Θ</ci>
       <ci>j</ci>
      </apply>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\Theta}^{i}=(g^{-1})^{i}{}_{j}\Theta^{j}.
  </annotation>
 </semantics>
</math>

 In other terms, Θ is a tensor of type (1,2) (carrying one contravariant and two covariant indices).</p>

<p>Alternatively, the solder form can be characterized in a frame-independent fashion as the T<em>M</em>-valued one-form θ on <em>M</em> corresponding to the identity endomorphism of the tangent bundle under the duality isomorphism End(T<em>M</em>) ≈ T<em>M</em> ⊗ T<sup>*</sup><em>M</em>. Then the torsion two-form is a section of</p>

<p>

<math display="block" id="Torsion_tensor:24">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mo>∈</mo>
   <mrow>
    <mtext>Hom</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mo>∧</mo>
       <mn>2</mn>
      </msup>
      <mrow>
       <mi>T</mi>
       <mi>M</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>T</mi>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <mtext>Hom</mtext>
     <interval closure="open">
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <and></and>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>M</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>M</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta\in\text{Hom}(\wedge^{2}TM,TM)
  </annotation>
 </semantics>
</math>

 given by</p>

<p>

<math display="block" id="Torsion_tensor:25">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mo>=</mo>
    <mrow>
     <mi>D</mi>
     <mi>θ</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta=D\theta,\,
  </annotation>
 </semantics>
</math>

 where <em>D</em> is the <a href="exterior_covariant_derivative" title="wikilink">exterior covariant derivative</a>. (See <a href="connection_form" title="wikilink">connection form</a> for further details.)</p>
<h3 id="irreducible-decomposition">Irreducible decomposition</h3>

<p>The torsion tensor can be decomposed into two <a href="irreducible_representation" title="wikilink">irreducible</a> parts: a <a href="Trace_(linear_algebra)" title="wikilink">trace-free</a> part and another part which contains the trace terms. Using the <a href="index_notation" title="wikilink">index notation</a>, the trace of <em>T</em> is given by</p>

<p>

<math display="block" id="Torsion_tensor:26">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>T</mi>
    <mi>k</mi>
   </msup>
   <mmultiscripts>
    <mo>,</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>i</mi>
     <mi>k</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-,</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}=T^{k}{}_{ik},
  </annotation>
 </semantics>
</math>

 and the trace-free part is</p>

<p>

<math display="block" id="Torsion_tensor:27">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mi>i</mi>
   </msup>
   <mmultiscripts>
    <mo>=</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>j</mi>
     <mi>k</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <msup>
    <mi>T</mi>
    <mi>i</mi>
   </msup>
   <mmultiscripts>
    <mo>+</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>j</mi>
     <mi>k</mi>
    </mrow>
    <none></none>
   </mmultiscripts>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
   <msup>
    <mi>δ</mi>
    <mi>i</mi>
   </msup>
   <mmultiscripts>
    <mi>a</mi>
    <mi>k</mi>
    <none></none>
    <mprescripts></mprescripts>
    <mi>j</mi>
    <none></none>
   </mmultiscripts>
   <mo>-</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
   <msup>
    <mi>δ</mi>
    <mi>i</mi>
   </msup>
   <mmultiscripts>
    <mi>a</mi>
    <mi>j</mi>
    <none></none>
    <mprescripts></mprescripts>
    <mi>k</mi>
    <none></none>
   </mmultiscripts>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <plus></plus>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>δ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>k</ci>
     </apply>
     <ci>j</ci>
    </apply>
    <minus></minus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>δ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>j</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{i}{}_{jk}=T^{i}{}_{jk}+\frac{1}{n-1}\delta^{i}{}_{j}a_{k}-\frac{1}{n-1}%
\delta^{i}{}_{k}a_{j}
  </annotation>
 </semantics>
</math>

 where δ<sup>i</sup><sub>j</sub> is the <a href="Kronecker_delta" title="wikilink">Kronecker delta</a>.</p>

<p>Intrinsically, one has</p>

<p>

<math display="block" id="Torsion_tensor:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>∈</mo>
    <mrow>
     <mo>Hom</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mo>∧</mo>
        <mn>2</mn>
       </msup>
       <mrow>
        <mi>T</mi>
        <mi>M</mi>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>T</mi>
       <mi>M</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>T</ci>
    <apply>
     <ci>Hom</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <and></and>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\in\operatorname{Hom}\left(\wedge^{2}TM,TM\right).
  </annotation>
 </semantics>
</math>

 The trace of <em>T</em>, tr <em>T</em>, is an element of T<sup>*</sup><em>M</em> defined as follows. For each vector fixed <em>X</em> ∈ T<em>M</em>, <em>T</em> defines an element <em>T</em>(<em>X</em>) of Hom(T<em>M</em>, T<em>M</em>) via</p>

<p>

<math display="block" id="Torsion_tensor:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>Y</mi>
     <mo>↦</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>X</mi>
        <mo>∧</mo>
        <mi>Y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>Y</ci>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <and></and>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(X):Y\mapsto T(X\wedge Y).
  </annotation>
 </semantics>
</math>

 Then (tr <em>T</em>)(<em>X</em>) is defined as the trace of this endomorphism. That is,</p>

<p>

<math display="block" id="Torsion_tensor:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo rspace="4.2pt">tr</mo>
       <mi>T</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mover>
     <mo movablelimits="false">=</mo>
     <mtext>def</mtext>
    </mover>
    <mrow>
     <mo>tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <mtext>def</mtext>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>tr</ci>
      <ci>T</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>tr</ci>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{tr}\,T)(X)\stackrel{\text{def}}{=}\operatorname{tr}(T(X)).
  </annotation>
 </semantics>
</math>

</p>

<p>The trace-free part of <em>T</em> is then</p>

<p>

<math display="block" id="Torsion_tensor:31">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
     <mi>ι</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo rspace="4.2pt">tr</mo>
       <mi>T</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <minus></minus>
     <ci>T</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>ι</ci>
      <apply>
       <ci>tr</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{0}=T-\frac{1}{n-1}\iota(\operatorname{tr}\,T)
  </annotation>
 </semantics>
</math>

 where ι denotes the <a href="interior_product" title="wikilink">interior product</a>.</p>
<h2 id="characterizations-and-interpretations">Characterizations and interpretations</h2>

<p>Throughout this section, <em>M</em> is assumed to be a <a href="differentiable_manifold" title="wikilink">differentiable manifold</a>, and ∇ a <a href="covariant_derivative" title="wikilink">covariant derivative</a> on the <a href="tangent_bundle" title="wikilink">tangent bundle</a> of <em>M</em> unless otherwise noted.</p>
<h3 id="twisting-of-reference-frames">Twisting of reference frames</h3>

<p>In the classical <a href="differential_geometry_of_curves" title="wikilink">differential geometry of curves</a>, the <a href="Frenet-Serret_formulas" title="wikilink">Frenet-Serret formulas</a> describe how a particular moving frame (the Frenet-Serret frame) <em>twists</em> along a curve. In physical terms, the torsion corresponds to the <a href="angular_momentum" title="wikilink">angular momentum</a> of an idealized <a class="uri" href="top" title="wikilink">top</a> pointing along the tangent of the curve.</p>

<p>The case of a manifold with a (metric) connection admits an analogous interpretation. Suppose that an observer is moving along a geodesic for the connection. Such an observer is ordinarily thought of as <a href="inertial_reference_frame" title="wikilink">inertial</a> since she experiences no <a class="uri" href="acceleration" title="wikilink">acceleration</a>. Suppose that in addition the observer carries with herself a system of rigid straight measuring rods (a <a href="coordinate_system" title="wikilink">coordinate system</a>). Each rod is a straight segment; a <a class="uri" href="geodesic" title="wikilink">geodesic</a>. Assume that each rod is <a href="parallel_transport" title="wikilink">parallel transported</a> along the trajectory. The fact that these rods are physically <em>carried</em> along the trajectory means that they are <em>Lie-dragged</em>, or propagated so that the <a href="Lie_derivative" title="wikilink">Lie derivative</a> of each rod along the tangent vanishes. They may, however, experience torque (or torsional forces) analogous to the torque felt by the top in the Frenet-Serret frame. This force is measured by the torsion.</p>

<p>More precisely, suppose that the observer moves along a geodesic path γ(<em>t</em>) and carries a measuring rod along it. The rod sweeps out a surface as the observer travels along the path. There are natural coordinates (<em>t</em>,<em>x</em>) along this surface, where <em>t</em> is the parameter time taken by the observer, and <em>x</em> is the position along the measuring rod. The condition that the tangent of the rod should be parallel translated along the curve is</p>

<p>

<math display="block" id="Torsion_tensor:32">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mrow>
      <msub>
       <mo>∇</mo>
       <mrow>
        <mo>∂</mo>
        <mo>/</mo>
        <mrow>
         <mo>∂</mo>
         <mi>t</mi>
        </mrow>
       </mrow>
      </msub>
      <mfrac>
       <mo>∂</mo>
       <mrow>
        <mo>∂</mo>
        <mi>x</mi>
       </mrow>
      </mfrac>
     </mrow>
     <mo fence="true">|</mo>
    </mrow>
    <mrow>
     <mi>x</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <apply>
        <divide></divide>
        <partialdiff></partialdiff>
        <apply>
         <partialdiff></partialdiff>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.\nabla_{\partial/\partial t}\frac{\partial}{\partial x}\right|_{x=0}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Consequently, the torsion is given by</p>

<p>

<math display="block" id="Torsion_tensor:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mo>∂</mo>
         <mrow>
          <mo>∂</mo>
          <mi>x</mi>
         </mrow>
        </mfrac>
        <mo>,</mo>
        <mfrac>
         <mo>∂</mo>
         <mrow>
          <mo>∂</mo>
          <mi>t</mi>
         </mrow>
        </mfrac>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo fence="true">|</mo>
     </mrow>
     <mrow>
      <mi>x</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <msub>
     <mrow>
      <mrow>
       <msub>
        <mo>∇</mo>
        <mfrac>
         <mo>∂</mo>
         <mrow>
          <mo>∂</mo>
          <mi>x</mi>
         </mrow>
        </mfrac>
       </msub>
       <mfrac>
        <mo>∂</mo>
        <mrow>
         <mo>∂</mo>
         <mi>t</mi>
        </mrow>
       </mfrac>
      </mrow>
      <mo fence="true">|</mo>
     </mrow>
     <mrow>
      <mi>x</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <times></times>
      <ci>T</ci>
      <interval closure="open">
       <apply>
        <divide></divide>
        <partialdiff></partialdiff>
        <apply>
         <partialdiff></partialdiff>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <partialdiff></partialdiff>
        <apply>
         <partialdiff></partialdiff>
         <ci>t</ci>
        </apply>
       </apply>
      </interval>
     </apply>
     <apply>
      <eq></eq>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <apply>
        <divide></divide>
        <partialdiff></partialdiff>
        <apply>
         <partialdiff></partialdiff>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.T\left(\frac{\partial}{\partial x},\frac{\partial}{\partial t}\right)%
\right|_{x=0}=\left.\nabla_{\frac{\partial}{\partial x}}\frac{\partial}{%
\partial t}\right|_{x=0}.
  </annotation>
 </semantics>
</math>

</p>

<p>If this is not zero, then the marked points on the rod (the <em>x</em> = constant curves) will trace out helices instead of geodesics. They will tend to rotate around the observer. Note that for this argument it was not essential that 

<math display="inline" id="Torsion_tensor:34">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(t)
  </annotation>
 </semantics>
</math>

 is a geodesic. Any curve would work.</p>

<p>This interpretation of torsion plays a role in the theory of <a class="uri" href="teleparallelism" title="wikilink">teleparallelism</a>, also known as <a href="Einstein–Cartan_theory" title="wikilink">Einstein–Cartan theory</a>, an alternative formulation of <a href="relativity_theory" title="wikilink">relativity theory</a>.</p>
<h3 id="the-torsion-of-a-filament">The torsion of a filament</h3>

<p>In <a href="materials_science" title="wikilink">materials science</a>, and especially <a href="elasticity_theory" title="wikilink">elasticity theory</a>, ideas of torsion also play an important role. One problem models the growth of vines, focusing on the question of how vines manage to twist around objects.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The vine itself is modeled as a pair of elastic filaments twisted around one another. In its energy-minimizing state, the vine naturally grows in the shape of a <a class="uri" href="helix" title="wikilink">helix</a>. But the vine may also be stretched out to maximize its extent (or length). In this case, the torsion of the vine is related to the torsion of the pair of filaments (or equivalently the surface torsion of the ribbon connecting the filaments), and it reflects the difference between the length-maximizing (geodesic) configuration of the vine and its energy-minimizing configuration.</p>
<h3 id="torsion-and-vorticity">Torsion and vorticity</h3>

<p>In <a href="fluid_dynamics" title="wikilink">fluid dynamics</a>, torsion is naturally associated to <a href="vortex_line" title="wikilink">vortex lines</a>. </p>
<h2 id="geodesics-and-the-absorption-of-torsion">Geodesics and the absorption of torsion</h2>

<p>Suppose that γ(<em>t</em>) is a curve on <em>M</em>. Then γ is an <strong>affinely parametrized geodesic</strong> provided that</p>

<p>

<math display="block" id="Torsion_tensor:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mrow>
       <mover accent="true">
        <mi>γ</mi>
        <mo>˙</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mover accent="true">
      <mi>γ</mi>
      <mo>˙</mo>
     </mover>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <apply>
        <times></times>
        <apply>
         <ci>normal-˙</ci>
         <ci>γ</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-˙</ci>
       <ci>γ</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{\dot{\gamma}(t)}\dot{\gamma}(t)=0
  </annotation>
 </semantics>
</math>

 for all time <em>t</em> in the domain of γ. (Here the dot denotes differentiation with respect to <em>t</em>, which associates with γ the tangent vector pointing along it.) Each geodesic is uniquely determined by its initial tangent vector at time <em>t</em>=0, 

<math display="inline" id="Torsion_tensor:36">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>γ</mi>
    <mo>˙</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-˙</ci>
     <ci>γ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\gamma}(0)
  </annotation>
 </semantics>
</math>

.</p>

<p>One application of the torsion of a connection involves the <a href="geodesic_spray" title="wikilink">geodesic spray</a> of the connection: roughly the family of all affinely parametrized geodesics. Torsion is the ambiguity of classifying connections in terms of their geodesic sprays:</p>
<ul>
<li>Two connections ∇ and ∇′ which have the same affinely parametrized geodesics (i.e., the same geodesic spray) differ only by torsion.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>

<p>More precisely, if <em>X</em> and <em>Y</em> are a pair of tangent vectors at <em>p</em> ∈ <em>M</em>, then let</p>

<p>

<math display="block" id="Torsion_tensor:37">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mi>X</mi>
     </msub>
     <mover accent="true">
      <mi>Y</mi>
      <mo stretchy="false">~</mo>
     </mover>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mo>∇</mo>
      <mi>X</mi>
      <mo>′</mo>
     </msubsup>
     <mover accent="true">
      <mi>Y</mi>
      <mo stretchy="false">~</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>Y</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-∇</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>X</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>Y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(X,Y)=\nabla_{X}\tilde{Y}-\nabla^{\prime}_{X}\tilde{Y}
  </annotation>
 </semantics>
</math>

 be the difference of the two connections, calculated in terms of arbitrary extensions of <em>X</em> and <em>Y</em> away from <em>p</em>. By the <a href="product_rule" title="wikilink">Leibniz product rule</a>, one sees that Δ does not actually depend on how <em>X</em> and <em>Y</em>' are extended (so it defines a tensor on <em>M</em>). Let <em>S</em> and <em>A</em> be the symmmetric and alternating parts of Δ:</p>

<p>

<math display="block" id="Torsion_tensor:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo>,</mo>
        <mi>Y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Y</mi>
        <mo>,</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <interval closure="open">
        <ci>X</ci>
        <ci>Y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <interval closure="open">
        <ci>Y</ci>
        <ci>X</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(X,Y)=\tfrac{1}{2}\left(\Delta(X,Y)+\Delta(Y,X)\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Torsion_tensor:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo>,</mo>
        <mi>Y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Y</mi>
        <mo>,</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <interval closure="open">
        <ci>X</ci>
        <ci>Y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <interval closure="open">
        <ci>Y</ci>
        <ci>X</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(X,Y)=\tfrac{1}{2}\left(\Delta(X,Y)-\Delta(Y,X)\right)
  </annotation>
 </semantics>
</math>

 Then</p>
<ul>
<li>

<math display="inline" id="Torsion_tensor:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo>,</mo>
        <mi>Y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>T</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo>,</mo>
        <mi>Y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>T</ci>
       <interval closure="open">
        <ci>X</ci>
        <ci>Y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <ci>normal-′</ci>
       </apply>
       <interval closure="open">
        <ci>X</ci>
        <ci>Y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(X,Y)=\tfrac{1}{2}\left(T(X,Y)-T^{\prime}(X,Y)\right)
  </annotation>
 </semantics>
</math>

 is the difference of the torsion tensors.</li>
<li>∇ and ∇′ define the same families of affinely parametrized geodesics if and only if <em>S</em>(<em>X</em>,<em>Y</em>) = 0.</li>
</ul>

<p>In other words, the symmetric part of the difference of two connections determines whether they have the same parametrized geodesics, whereas the skew part of the difference is determined by the relative torsions of the two connections. Another consequence is:</p>
<ul>
<li>Given any affine connection ∇, there is a unique torsion-free connection ∇′ with the same family of affinely parametrized geodesics.</li>
</ul>

<p>This is a generalization of the <a href="fundamental_theorem_of_Riemannian_geometry" title="wikilink">fundamental theorem of Riemannian geometry</a> to general affine (possibly non-metric) connections. Picking out the unique torsion-free connection subordinate to a family of parametrized geodesics is known as <strong>absorption of torsion</strong>, and it is one of the stages of <a href="Cartan's_equivalence_method" title="wikilink">Cartan's equivalence method</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Riemann_curvature_tensor" title="wikilink">Curvature tensor</a></li>
<li><a href="Contorsion_tensor" title="wikilink">Contorsion tensor</a></li>
<li><a href="Levi-Civita_connection" title="wikilink">Levi-Civita connection</a></li>
<li><a href="Torsion_of_curves" title="wikilink">Torsion of curves</a></li>
<li><a href="Curtright_field" title="wikilink">Curtright field</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Hehl, F.W.; von der Heyde, P.; Kerlick, G.D.; Nester, J.M. (1976), <a href="http://rmp.aps.org/abstract/RMP/v48/i3/p393_1">"General relativity with spin and torsion: Foundations and prospects"</a>, Rev. Mod. Phys. <strong>48</strong>, 393.</li>
<li><a href="Tom_W._B._Kibble" title="wikilink">Kibble, T.W.B.</a> (1961), <a href="http://dx.doi.org/10.1063/1.1703702">"Lorentz invariance and the gravitational field"</a>, J. Math. Phys. <strong>2</strong>, 212.</li>
<li></li>
<li><a href="Nikodem_Poplawski" title="wikilink">Poplawski, N.J.</a> (2009), "Spacetime and fields", <a href="http://arxiv.org/abs/0911.0334">arXiv:0911.0334</a></li>
<li></li>
<li></li>
<li><a href="Dennis_W._Sciama" title="wikilink">Sciama, D.W.</a> (1964), <a href="http://rmp.aps.org/abstract/RMP/v36/i1/p463_1">"The physical structure of general relativity"</a>, Rev. Mod. Phys. <strong>36</strong>, 463.</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Differential_geometry" title="wikilink">Category:Differential geometry</a> <a href="Category:Connection_(mathematics)" title="wikilink">Category:Connection (mathematics)</a> <a href="Category:Curvature_(mathematics)" title="wikilink">Category:Curvature (mathematics)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">See Kobayashi–Nomizu (1996) Volume 1, Proposition III.5.2.<a href="#fnref1">↩</a></li>
<li id="fn2">Kobayashi–Nomizu (1996) Volume 1, III.2.<a href="#fnref2">↩</a></li>
<li id="fn3">Kobayashi–Nomizu (1996) Volume 1, III.5.<a href="#fnref3">↩</a></li>
<li id="fn4">Goriely <em>et al.</em> (2006).<a href="#fnref4">↩</a></li>
<li id="fn5">See Spivak (1999) Volume II, Addendum 1 to Chapter 6. See also Bishop and Goldberg (1980), section 5.10.<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
