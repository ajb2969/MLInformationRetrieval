<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1166">Prüfer sequence</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Prüfer sequence</h1>
<hr/>

<p>In <a href="combinatorics" title="wikilink">combinatorial</a> <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>Prüfer sequence</strong> (also <strong>Prüfer code</strong> or <strong>Prüfer numbers</strong>) of a <a href="labeled_tree" title="wikilink">labeled tree</a> is a unique <a class="uri" href="sequence" title="wikilink">sequence</a> associated with the tree. The sequence for a tree on <em>n</em> vertices has length <em>n</em> − 2, and can be generated by a simple iterative algorithm. Prüfer sequences were first used by <a href="Heinz_Prüfer" title="wikilink">Heinz Prüfer</a> to prove <a href="Cayley's_formula" title="wikilink">Cayley's formula</a> in 1918.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="algorithm-to-convert-a-tree-into-a-prüfer-sequence">Algorithm to convert a tree into a Prüfer sequence</h2>

<p>One can generate a labeled tree's Prüfer sequence by iteratively removing vertices from the tree until only two vertices remain. Specifically, consider a labeled tree <em>T</em> with vertices {1, 2, ..., <em>n</em>}. At step <em>i</em>, remove the leaf with the smallest label and set the <em>i</em>th element of the Prüfer sequence to be the label of this leaf's neighbour.</p>

<p>The Prüfer sequence of a labeled tree is unique and has length <em>n</em> − 2.</p>
<h3 id="example">Example</h3>

<p> Consider the above algorithm run on the tree shown to the right. Initially, vertex 1 is the leaf with the smallest label, so it is removed first and 4 is put in the Prüfer sequence. Vertices 2 and 3 are removed next, so 4 is added twice more. Vertex 4 is now a leaf and has the smallest label, so it is removed and we append 5 to the sequence. We are left with only two vertices, so we stop. The tree's sequence is {4,4,4,5}.</p>
<h2 id="algorithm-to-convert-a-prüfer-sequence-into-a-tree">Algorithm to convert a Prüfer sequence into a tree</h2>

<p>Let <code>{a[1], a[2], ..., a[n]}</code> be a Prüfer sequence:</p>

<p>The tree will have <code>n+2</code> nodes, numbered from <code>1</code> to <code>n+2</code>. For each node set its degree to the number of times it appears in the sequence plus 1. For instance, in pseudo-code:</p>

<p><code> </code><strong><code>Convert-Prüfer-to-Tree</code></strong><code>(</code><em><code>a</code></em><code>)</code><br/>
<code> 1 </code><em><code>n</code></em><code> ← </code><em><code>length</code></em><code>[</code><em><code>a</code></em><code>]</code><br/>
<code> 2 </code><em><code>T</code></em><code> ← a graph with </code><em><code>n</code></em><code> + 2 isolated nodes, numbered 1 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code> + 2</code><br/>
<code> 3 </code><em><code>degree</code></em><code> ← an array of integers</code><br/>
<code> 4 </code><strong><code>for</code></strong><code> each node </code><em><code>i</code></em><code> in </code><em><code>T</code></em><br/>
<code> 5     </code><strong><code>do</code></strong><code> </code><em><code>degree</code></em><code>[</code><em><code>i</code></em><code>] ← 1</code><br/>
<code> 6 </code><strong><code>for</code></strong><code> each value </code><em><code>i</code></em><code> in </code><em><code>a</code></em><br/>
<code> 7     </code><strong><code>do</code></strong><code> </code><em><code>degree</code></em><code>[</code><em><code>i</code></em><code>] ← </code><em><code>degree</code></em><code>[</code><em><code>i</code></em><code>] + 1</code></p>

<p>Next, for each number in the sequence <code>a[i]</code>, find the first (lowest-numbered) node, <code>j</code>, with degree equal to 1, add the edge <code>(j, a[i])</code> to the tree, and decrement the degrees of <code>j</code> and <code>a[i]</code>. In pseudo-code:</p>

<p><code> 8 </code><strong><code>for</code></strong><code> each value </code><em><code>i</code></em><code> in </code><em><code>a</code></em><br/>
<code> 9     </code><strong><code>for</code></strong><code> each node </code><em><code>j</code></em><code> in </code><em><code>T</code></em><br/>
<code>10          </code><strong><code>if</code></strong><code> </code><em><code>degree</code></em><code>[</code><em><code>j</code></em><code>] = 1</code><br/>
<code>11             </code><strong><code>then</code></strong><code> Insert </code><em><code>edge</code></em><code>[</code><em><code>i</code></em><code>, </code><em><code>j</code></em><code>] into </code><em><code>T</code></em><br/>
<code>12                  </code><em><code>degree</code></em><code>[</code><em><code>i</code></em><code>] ← </code><em><code>degree</code></em><code>[</code><em><code>i</code></em><code>] - 1</code><br/>
<code>13                  </code><em><code>degree</code></em><code>[</code><em><code>j</code></em><code>] ← </code><em><code>degree</code></em><code>[</code><em><code>j</code></em><code>] - 1</code><br/>
<code>14                  </code><strong><code>break</code></strong></p>

<p>At the end of this loop two nodes with degree 1 will remain (call them <code>u</code>, <code>v</code>). Lastly, add the edge <code>(u,v)</code> to the tree.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p><code>14 </code><em><code>u</code></em><code> ← </code><em><code>v</code></em><code> ← 0</code><br/>
<code>15 </code><strong><code>for</code></strong><code> each node </code><em><code>i</code></em><code> in </code><em><code>T</code></em><br/>
<code>16     </code><strong><code>if</code></strong><code> </code><em><code>degree</code></em><code>[</code><em><code>i</code></em><code>] = 1</code><br/>
<code>17         </code><strong><code>then</code></strong><code> </code><strong><code>if</code></strong><code> </code><em><code>u</code></em><code> = 0</code><br/>
<code>18             </code><strong><code>then</code></strong><code> </code><em><code>u</code></em><code> ← </code><em><code>i</code></em><br/>
<code>19             </code><strong><code>else</code></strong><code> </code><em><code>v</code></em><code> ← </code><em><code>i</code></em><br/>
<code>20                  </code><strong><code>break</code></strong><br/>
<code>21 Insert </code><em><code>edge</code></em><code>[</code><em><code>u</code></em><code>, </code><em><code>v</code></em><code>] into </code><em><code>T</code></em><br/>
<code>22 </code><em><code>degree</code></em><code>[</code><em><code>u</code></em><code>] ← </code><em><code>degree</code></em><code>[</code><em><code>u</code></em><code>] - 1</code><br/>
<code>23 </code><em><code>degree</code></em><code>[</code><em><code>v</code></em><code>] ← </code><em><code>degree</code></em><code>[</code><em><code>v</code></em><code>] - 1</code><br/>
<code>24 </code><strong><code>return</code></strong><code> </code><em><code>T</code></em></p>
<h2 id="cayleys-formula">Cayley's formula</h2>

<p>The Prüfer sequence of a labeled tree on <em>n</em> vertices is a unique sequence of length <em>n</em> − 2 on the labels 1 to <em>n</em> — this much is clear. Somewhat less obvious is the fact that for a given sequence <em>S</em> of length <em>n</em>–2 on the labels 1 to <em>n</em>, <strong>there is a <em>unique</em> labeled tree whose Prüfer sequence is <em>S</em></strong>.</p>

<p>The immediate consequence is that Prüfer sequences provide a <a class="uri" href="bijection" title="wikilink">bijection</a> between the set of labeled trees on <em>n</em> vertices and the set of sequences of length <em>n</em>–2 on the labels 1 to <em>n</em>. The latter set has size <em>n</em><sup><em>n</em>−2</sup>, so the existence of this bijection proves <a href="Cayley's_formula" title="wikilink">Cayley's formula</a>, i.e. that there are <em>n</em><sup><em>n</em>−2</sup> labeled trees on <em>n</em> vertices.</p>
<h2 id="other-applications">Other applications<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></h2>
<ul>
<li>Cayley's formula can be strengthened to prove the following claim:</li>
</ul>
<dl>
<dd>The number of spanning trees in a complete graph 

<math display="inline" id="Prüfer_sequence:0">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{n}
  </annotation>
 </semantics>
</math>

 with a degree 

<math display="inline" id="Prüfer_sequence:1">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i}
  </annotation>
 </semantics>
</math>

 specified for each vertex 

<math display="inline" id="Prüfer_sequence:2">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is equal to the <a href="multinomial_coefficient" title="wikilink">multinomial coefficient</a>

<p>

<math display="block" id="Prüfer_sequence:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mrow>
         <mrow>
          <msub>
           <mi>d</mi>
           <mn>1</mn>
          </msub>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo rspace="4.2pt">,</mo>
         <mrow>
          <msub>
           <mi>d</mi>
           <mn>2</mn>
          </msub>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo rspace="4.2pt">,</mo>
         <mi mathvariant="normal">…</mi>
         <mo rspace="4.2pt">,</mo>
         <mrow>
          <msub>
           <mi>d</mi>
           <mi>n</mi>
          </msub>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>d</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>d</mi>
          <mn>2</mn>
         </msub>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mi mathvariant="normal">⋯</mi>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>d</mi>
          <mi>n</mi>
         </msub>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <list>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <factorial></factorial>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{n-2}\atop{d_{1}-1,\,d_{2}-1,\,\dots,\,d_{n}-1}}\right)}=\frac{(n-2)!}%
{(d_{1}-1)!(d_{2}-1)!\cdots(d_{n}-1)!}.
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>The proof follows by observing that in the Prüfer sequence number 

<math display="inline" id="Prüfer_sequence:4">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 appears exactly 

<math display="inline" id="Prüfer_sequence:5">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d_{i}-1)
  </annotation>
 </semantics>
</math>

 times.
</dd>
</dl>
<ul>
<li>Cayley's formula can be generalized: a labeled tree is in fact a <a href="spanning_tree_(mathematics)" title="wikilink">spanning tree</a> of the labeled <a href="complete_graph" title="wikilink">complete graph</a>. By placing restrictions on the enumerated Prüfer sequences, similar methods can give the number of spanning trees of a complete <a href="bipartite_graph" title="wikilink">bipartite graph</a>. If <em>G</em> is the complete bipartite graph with vertices 1 to <em>n</em><sub>1</sub> in one partition and vertices <em>n</em><sub>1</sub> + 1 to <em>n</em> in the other partition, the number of labeled spanning trees of <em>G</em> is 

<math display="inline" id="Prüfer_sequence:6">
 <semantics>
  <mrow>
   <msubsup>
    <mi>n</mi>
    <mn>1</mn>
    <mrow>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <msubsup>
    <mi>n</mi>
    <mn>2</mn>
    <mrow>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{1}^{n_{2}-1}n_{2}^{n_{1}-1}
  </annotation>
 </semantics>
</math>

, where <em>n</em><sub>2</sub> = <em>n</em> − <em>n</em><sub>1</sub>.</li>
</ul>
<ul>
<li>Generating uniformly distributed random Prüfer sequences and converting them into the corresponding trees is a straightforward method of generating uniformly distributed random labelled trees.</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://mathworld.wolfram.com/PrueferCode.html">Prüfer code</a> – from <a class="uri" href="MathWorld" title="wikilink">MathWorld</a></li>
</ul>

<p>"</p>

<p><a href="Category:Enumerative_combinatorics" title="wikilink">Category:Enumerative combinatorics</a> <a href="Category:Trees_(graph_theory)" title="wikilink">Category:Trees (graph theory)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
