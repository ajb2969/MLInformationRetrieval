<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="575">Karp–Flatt metric</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Karp–Flatt metric</h1>
<hr/>

<p>The <strong>Karp–Flatt metric</strong> is a measure of <a class="uri" href="parallelization" title="wikilink">parallelization</a> of code in <a href="parallel_processor" title="wikilink">parallel processor</a> systems. This metric exists in addition to <a href="Amdahl's_law" title="wikilink">Amdahl's law</a> and the <a href="Gustafson's_law" title="wikilink">Gustafson's law</a> as an indication of the extent to which a particular computer code is parallelized. It was proposed by Alan H. Karp and Horace P. Flatt in 1990.</p>
<h2 id="description">Description</h2>

<p>Given a parallel computation exhibiting <a class="uri" href="speedup" title="wikilink">speedup</a> 

<math display="inline" id="Karp–Flatt_metric:0">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Karp–Flatt_metric:1">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 processors, where 

<math display="inline" id="Karp–Flatt_metric:2">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 &gt; 1, the experimentally determined <a href="serial_fraction" title="wikilink">serial fraction</a> 

<math display="inline" id="Karp–Flatt_metric:3">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is defined to be the Karp–Flatt Metric viz:</p>

<p>

<math display="block" id="Karp–Flatt_metric:4">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>ψ</mi>
     </mfrac>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <mi>p</mi>
     </mfrac>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <mi>p</mi>
     </mfrac>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>ψ</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=\frac{\frac{1}{\psi}-\frac{1}{p}}{1-\frac{1}{p}}
  </annotation>
 </semantics>
</math>

</p>

<p>The less the value of 

<math display="inline" id="Karp–Flatt_metric:5">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 the better the parallelization.</p>
<h2 id="justification">Justification</h2>

<p>There are many ways to measure the performance of a <a href="parallel_algorithm" title="wikilink">parallel algorithm</a> running on a parallel processor. The Karp–Flatt metric defines a metric which reveals aspects of the performance that are not easily discerned from other metrics. A pseudo-"derivation" of sorts follows from <a href="Amdahl's_Law" title="wikilink">Amdahl's Law</a>, which can be written as:</p>

<p>

<math display="block" id="Karp–Flatt_metric:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>s</mi>
    </msub>
    <mo>+</mo>
    <mfrac>
     <msub>
      <mi>T</mi>
      <mi>p</mi>
     </msub>
     <mi>p</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>p</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(p)=T_{s}+\frac{T_{p}}{p}
  </annotation>
 </semantics>
</math>

</p>

<p>Where:</p>
<ul>
<li>

<math display="inline" id="Karp–Flatt_metric:7">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(p)
  </annotation>
 </semantics>
</math>

 is the total time taken for code execution in a 

<math display="inline" id="Karp–Flatt_metric:8">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

-processor system</li>
<li>

<math display="inline" id="Karp–Flatt_metric:9">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{s}
  </annotation>
 </semantics>
</math>

 is the time taken for the serial part of the code to run</li>
<li>

<math display="inline" id="Karp–Flatt_metric:10">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{p}
  </annotation>
 </semantics>
</math>

 is the time taken for the parallel part of the code to run in one processor</li>
<li>

<math display="inline" id="Karp–Flatt_metric:11">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is the number of processors</li>
</ul>

<p>with the result obtained by substituting 

<math display="inline" id="Karp–Flatt_metric:12">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 = 1 viz. 

<math display="inline" id="Karp–Flatt_metric:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>s</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>T</mi>
     <mi>p</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(1)=T_{s}+T_{p}
  </annotation>
 </semantics>
</math>

, if we define the serial fraction 

<math display="inline" id="Karp–Flatt_metric:14">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Karp–Flatt_metric:15">
 <semantics>
  <mfrac>
   <msub>
    <mi>T</mi>
    <mi>s</mi>
   </msub>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{T_{s}}{T(1)}
  </annotation>
 </semantics>
</math>

 then the equation can be rewritten as</p>

<p>

<math display="block" id="Karp–Flatt_metric:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>e</mi>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>e</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi>p</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>T</ci>
      <cn type="integer">1</cn>
      <ci>e</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>e</ci>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(p)=T(1)e+\frac{T(1)(1-e)}{p}
  </annotation>
 </semantics>
</math>

</p>

<p>In terms of the <a class="uri" href="speedup" title="wikilink">speedup</a> 

<math display="inline" id="Karp–Flatt_metric:17">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Karp–Flatt_metric:18">
 <semantics>
  <mfrac>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{T(1)}{T(p)}
  </annotation>
 </semantics>
</math>

 :</p>

<p>

<math display="block" id="Karp–Flatt_metric:19">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>ψ</mi>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mi>e</mi>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>e</mi>
     </mrow>
     <mi>p</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>ψ</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>e</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>e</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\psi}=e+\frac{1-e}{p}
  </annotation>
 </semantics>
</math>

</p>

<p>Solving for the serial fraction, we get the Karp–Flatt metric as above. Note that this is not a "derivation" from Amdahl's law as the left hand side represents a <a href="Metric_(mathematics)" title="wikilink">metric</a> rather than a mathematically derived quantity. The treatment above merely shows that the Karp–Flatt metric is consistent with Amdahl's Law.</p>
<h2 id="use">Use</h2>

<p>While the serial fraction e is often mentioned in <a href="computer_science" title="wikilink">computer science</a> literature, it was rarely used as a diagnostic tool the way <a class="uri" href="speedup" title="wikilink">speedup</a> and <a href="Algorithmic_efficiency" title="wikilink">efficiency</a> are. Karp and Flatt hoped to correct this by proposing this metric. This metric addresses the inadequacies of the other laws and quantities used to measure the parallelization of computer code. In particular, Amdahl's law does not take into account <a href="Load_balancing_(computing)" title="wikilink">load balancing</a> issues, nor does it take <a href="Computational_overhead" title="wikilink">overhead</a> into consideration. Using the serial fraction as a metric poses definite advantages over the others, particularly as the number of processors grows.</p>

<p>For a problem of fixed size, the efficiency of a parallel computation typically decreases as the number of processors increases. By using the serial fraction obtained experimentally using the Karp–Flatt metric, we can determine if the efficiency decrease is due to limited opportunities of parallelism or increases in algorithmic or architectural overhead.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://courses.cs.vt.edu/~cs4234/F03/notes/ch7/1003.html">Lecture Notes on Karp–Flatt metric</a> - <a href="Virginia_Tech" title="wikilink">Virginia Tech</a></li>
</ul>

<p>"</p>

<p><a href="Category:Analysis_of_parallel_algorithms" title="wikilink">Category:Analysis of parallel algorithms</a></p>
</body>
</html>
