<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1069">Compact operator on Hilbert space</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Compact operator on Hilbert space</h1>
<hr/>

<p>In <a href="functional_analysis" title="wikilink">functional analysis</a>, <a href="compact_operator" title="wikilink">compact operators</a> on <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> are a direct extension of matrices: in the Hilbert spaces, they are precisely the closure of <a href="finite-rank_operator" title="wikilink">finite-rank operators</a> in the <a href="Operator_topology" title="wikilink">uniform operator topology</a>. As such, results from matrix theory can sometimes be extended to compact operators using similar arguments. In contrast, the study of general operators on infinite-dimensional spaces often requires a genuinely different approach.</p>

<p>For example, the <a href="spectral_theory_of_compact_operators" title="wikilink">spectral theory of compact operators</a> on <a href="Banach_space" title="wikilink">Banach spaces</a> takes a form that is very similar to the <a href="Jordan_canonical_form" title="wikilink">Jordan canonical form</a> of matrices. In the context of Hilbert spaces, a square matrix is unitarily diagonalizable if and only if it is <a href="normal_operator" title="wikilink">normal</a>. A corresponding result holds for normal compact operators on Hilbert spaces. (More generally, the compactness assumption can be dropped. But, as stated above, the techniques used are less routine.)</p>

<p>This article will discuss a few results for compact operators on Hilbert space, starting with general properties before considering subclasses of compact operators.</p>
<h2 id="some-general-properties">Some general properties</h2>

<p>Let <em>H</em> be a Hilbert space, <em>L</em>(<em>H</em>) be the bounded operators on <em>H</em>. <em>T</em> ∈ <em>L</em>(<em>H</em>) is a <strong>compact operator</strong> if the image of each bounded set under <em>T</em> is <a href="Relatively_compact_subspace" title="wikilink">relatively compact</a>. We list some general properties of compact operators.</p>

<p>If <em>X</em> and <em>Y</em> are Hilbert spaces (in fact <em>X</em> Banach and <em>Y</em> normed will suffice), then <em>T:</em> <em>X</em> → <em>Y</em> is compact if and only if it is continuous when viewed as a map from <em>X</em> with the <a href="Weak_convergence_(Hilbert_space)" title="wikilink">weak topology</a> to <em>Y</em> (with the norm topology). (See , and note in this reference that the uniform boundedness will apply in the situation where <em>F</em> ⊆ <em>X</em> satisfies (∀φ ∈ Hom(<em>X</em>, <em>K</em>)) sup{<em>x**</em>(φ) = φ(<em>x</em>):<em>x</em>} n'' → <em>S</em> in the <a href="strong_operator_topology" title="wikilink">strong operator topology</a> and <em>T</em> is compact, then <em>S<sub>n</sub>T</em> converges to <em>ST</em> in norm. For example, consider the Hilbert space <em>l</em><sup>2</sup>(<strong>N</strong>), with standard basis {<em>e<sub>n</sub></em>}. Let <em>P<sub>m</sub></em> be the orthogonal projection on the linear span of {<em>e</em><sub>1</sub> ... <em>e<sub>m</sub></em>}. The sequence {<em>P<sub>m</sub></em>} converges to the identity operator <em>I</em> strongly but not uniformly. Define <em>T</em> by <em>Te<sub>n</sub></em> = (1/<em>n</em>)<sup>2</sup> · <em>e<sub>n</sub></em>. <em>T</em> is compact, and, as claimed above, <em>P<sub>m</sub>T</em> → <em>I T</em> = <em>T</em> in the uniform operator topology: for all <em>x</em>,</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>P</mi>
        <mi>m</mi>
       </msub>
       <mi>T</mi>
       <mi>x</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>T</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mi>m</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo>∥</mo>
      <mi>x</mi>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>m</ci>
       </apply>
       <ci>T</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <plus></plus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|P_{m}Tx-Tx\right\|\leq\left(\frac{1}{m+1}\right)^{2}\|x\|.
  </annotation>
 </semantics>
</math>

</p>

<p>Notice each <em>P<sub>m</sub></em> is a finite-rank operator. Similar reasoning shows that if <em>T</em> is compact, then <em>T</em> is the uniform limit of some sequence of finite-rank operators.</p>

<p>By the norm-closedness of the ideal of compact operators, the converse is also true.</p>

<p>The quotient C*-algebra of <em>L</em>(<em>H</em>) modulo the compact operators is called the <a href="Calkin_algebra" title="wikilink">Calkin algebra</a>, in which one can consider properties of an operator up to compact perturbation.</p>
<h2 id="compact-self-adjoint-operator">Compact self adjoint operator</h2>

<p>A bounded operator <em>T</em> on a Hilbert space <em>H</em> is said to be <a href="self-adjoint_operator" title="wikilink">self-adjoint</a> if <em>T</em> = <em>T*</em>, or equivalently,</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mi>T</mi>
       <mi>x</mi>
      </mrow>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mrow>
        <mi>T</mi>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo rspace="12.5pt">,</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mi>H</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </list>
     <list>
      <list>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>y</ci>
       </apply>
      </list>
      <ci>x</ci>
     </list>
    </apply>
    <apply>
     <in></in>
     <ci>y</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Tx,y\rangle=\langle x,Ty\rangle,\quad x,y\in H.
  </annotation>
 </semantics>
</math>

</p>

<p>It follows that  is real for every <em>x</em> ∈ <em>H</em>, thus eigenvalues of <em>T</em>, when they exist, are real. When a closed linear subspace <em>L</em> of <em>H</em> is invariant under <em>T</em>, then the restriction of <em>T</em> to <em>L</em> is a self-adjoint operator on <em>L</em>, and furthermore, the <a href="orthogonal_complement" title="wikilink">orthogonal complement</a> <em>L</em><sup>⊥</sup> of <em>L</em> is also invariant under <em>T</em>. For example, the space <em>H</em> can be decomposed as orthogonal <a href="direct_sum" title="wikilink">direct sum</a> of two <em>T</em>–invariant closed linear subspaces: the <a href="Kernel_(linear_operator)" title="wikilink">kernel</a> of <em>T</em>, and the orthogonal complement <mtpl></mtpl> of the kernel (which is equal to the closure of the range of <em>T</em>, for any bounded self-adjoint operator). These basic facts play an important role in the proof of the spectral theorem below.</p>

<p>The classification result for Hermitian  matrices is the <a href="spectral_theorem" title="wikilink">spectral theorem</a>: If <em>M</em> = <em>M*</em>, then <em>M</em> is unitarily diagonalizable and the diagonalization of <em>M</em> has real entries. Let <em>T</em> be a compact self adjoint operator on a Hilbert space <em>H</em>. We will prove the same statement for <em>T</em>: the operator <em>T</em> can be diagonalized by an orthonormal set of eigenvectors, each of which corresponds to a real eigenvalue.</p>
<h3 id="spectral-theorem">Spectral theorem</h3>

<p><strong>Theorem</strong> For every compact self-adjoint operator <em>T</em> on a real or complex Hilbert space <em>H</em>, there exists an <a href="orthonormal_basis" title="wikilink">orthonormal basis</a> of <em>H</em> consisting of eigenvectors of <em>T</em>. More specifically, the orthogonal complement of the kernel of <em>T</em> admits, either a finite orthonormal basis of eigenvectors of <em>T</em>, or a <a href="Countable_set" title="wikilink">countably infinite</a> orthonormal basis {<em>e<sub>n</sub></em>} of eigenvectors of <em>T</em>, with corresponding eigenvalues , such that <mtpl></mtpl>.</p>

<p>In other words, a compact self-adjoint operator can be unitarily diagonalized. This is the spectral theorem.</p>

<p>When <em>H</em> is <a href="Separable_space" title="wikilink">separable</a>, one can mix the basis {<em>e<sub>n</sub></em>} with a <a href="Countable_set" title="wikilink">countable</a> orthonormal basis for the kernel of <em>T</em>, and obtain an orthonormal basis {<em>f</em><sub><em>n</em></sub>} for <em>H</em>, consisting of eigenvectors of <em>T</em> with real eigenvalues {μ<sub><em>n</em></sub>} such that <mtpl></mtpl>.</p>

<p><strong>Corollary</strong> For every compact self-adjoint operator <em>T</em> on a real or complex separable infinite-dimensional Hilbert space <em>H</em>, there exists a countably infinite orthonormal basis {<em>f<sub>n</sub></em>} of <em>H</em> consisting of eigenvectors of <em>T</em>, with corresponding eigenvalues , such that <mtpl></mtpl>.</p>
<h4 id="the-idea">The idea</h4>

<p>Proving the spectral theorem for a Hermitian <em>n</em> × <em>n</em> matrix <em>T</em> hinges on showing the existence of one eigenvector <em>x</em>. Once this is done, Hermiticity implies that both the linear span and orthogonal complement of <em>x</em> are invariant subspaces of <em>T</em>. The desired result is then obtained by iteration. The existence of an eigenvector can be shown in at least two ways:</p>
<ol>
<li>One can argue algebraically: The characteristic polynomial of <em>T</em> has a complex root, therefore <em>T</em> has an eigenvalue with a corresponding eigenvector. Or,</li>
<li>The eigenvalues can be characterized variationally: The largest eigenvalue is the maximum on the closed unit <em>sphere</em> of the function <mtpl></mtpl> defined by <em>f</em>(<em>x</em>) = <em>x*Tx</em> = .</li>
</ol>

<p><strong>Note.</strong> In the finite-dimensional case, part of the first approach works in much greater generailty; any square matrix, not necessarily Hermitian, has an eigenvector. This is simply not true for general operators on Hilbert spaces.</p>

<p>The spectral theorem for the compact self adjoint case can be obtained analogously: one finds an eigenvector by extending the second finite-dimensional argument above, then apply induction. We first sketch the argument for matrices.</p>

<p>Since the closed unit sphere <em>S</em> in <strong>R</strong><sup>2<em>n</em></sup> is compact, and <em>f</em> is continuous, <em>f</em>(<em>S</em>) is compact on the real line, therefore <em>f</em> attains a maximum on <em>S</em>, at some unit vector <em>y</em>. By <a href="Lagrange_multipliers" title="wikilink">Lagrange's multiplier</a> theorem, <em>y</em> satisfies</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:2">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="5.3pt">∇</mo>
    <mrow>
     <msup>
      <mi>y</mi>
      <mo>*</mo>
     </msup>
     <mi>T</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mo>⋅</mo>
    <mrow>
     <mo rspace="5.3pt">∇</mo>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>*</mo>
      </msup>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-∇</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <ci>normal-∇</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <times></times>
       </apply>
       <ci>T</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>λ</ci>
      <apply>
       <ci>normal-∇</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <times></times>
        </apply>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f=\nabla\;y^{*}Ty=\lambda\cdot\nabla\;y^{*}y
  </annotation>
 </semantics>
</math>

</p>

<p>for some λ. By Hermiticity, .</p>

<p>However, the Lagrange multipliers do not generalize easily to the infinite-dimensional case. Alternatively, let <em>z</em> ∈ <strong>C</strong><sup><em>n</em></sup> be any vector. Notice that if a unit vector <em>y</em> maximizes  on the unit sphere (or on the unit ball), it also maximizes the <a href="Rayleigh_quotient" title="wikilink">Rayleigh quotient</a>:</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mrow>
        <mi>T</mi>
        <mi>x</mi>
       </mrow>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msup>
       <mrow>
        <mo>∥</mo>
        <mi>x</mi>
        <mo>∥</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mn>0</mn>
     <mo>≠</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <msup>
      <mi>𝐂</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <divide></divide>
      <list>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>x</ci>
       </apply>
       <ci>x</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <neq></neq>
      <cn type="integer">0</cn>
      <ci>x</ci>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐂</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=\frac{\langle Tx,x\rangle}{\|x\|^{2}},\qquad 0\neq x\in\mathbf{C}^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>Consider the function:</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:4">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>h</mi>
       <mo>:</mo>
       <mrow>
        <mi>𝐑</mi>
        <mo>→</mo>
        <mi>𝐑</mi>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>h</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>y</mi>
          <mo>+</mo>
          <mrow>
           <mi>t</mi>
           <mi>z</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <ci>normal-:</ci>
     <ci>h</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>𝐑</ci>
      <ci>𝐑</ci>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <plus></plus>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}h:\mathbf{R}\to\mathbf{R}\\
h(t)=g(y+tz)\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>By calculus, , <em>i.e.</em>,</p>

<p>

<math display="inline" id="Compact_operator_on_Hilbert_space:5">
 <semantics>
  <mrow>
   <msup>
    <mi>h</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <ci>normal-′</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle h^{\prime}(0)
  </annotation>
 </semantics>
</math>


</p>

<p>Define:</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:6">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>T</mi>
      <mi>y</mi>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <divide></divide>
     <list>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>y</ci>
      </apply>
      <ci>y</ci>
     </list>
     <list>
      <ci>y</ci>
      <ci>y</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=\frac{\langle Ty,y\rangle}{\langle y,y\rangle}
  </annotation>
 </semantics>
</math>

</p>

<p>After some algebra the above expression becomes (<em>Re</em> denotes the real part of a complex number)</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:7">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">ℜ</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mrow>
        <mi>T</mi>
        <mi>y</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>m</mi>
        <mi>y</mi>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <real></real>
     <list>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <ci>z</ci>
     </list>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Re\left(\langle Ty-my,z\rangle\right)=0.
  </annotation>
 </semantics>
</math>

</p>

<p>But <em>z</em> is arbitrary, therefore . This is the crux of proof for spectral theorem in the matricial case.</p>
<h4 id="details">Details</h4>

<p><strong>Claim</strong>  If <em>T</em> is a compact self-adjoint operator on a non-zero Hilbert space <em>H</em> and</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mo maxsize="120%" minsize="120%">{</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mrow>
         <mi>T</mi>
         <mi>x</mi>
        </mrow>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <mi>H</mi>
       </mrow>
       <mo rspace="4.2pt">,</mo>
       <mrow>
        <mrow>
         <mo>∥</mo>
         <mi>x</mi>
         <mo>∥</mo>
        </mrow>
        <mo>≤</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
      <mo maxsize="120%" minsize="120%">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <abs></abs>
       <list>
        <apply>
         <times></times>
         <ci>T</ci>
         <ci>x</ci>
        </apply>
        <ci>x</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>H</ci>
       </apply>
       <apply>
        <leq></leq>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m(T):=\sup\bigl\{|\langle Tx,x\rangle|:x\in H,\,\|x\|\leq 1\bigr\},
  </annotation>
 </semantics>
</math>

</p>

<p>then <em>m</em>(<em>T</em>) or −<em>m</em>(<em>T</em>) is an eigenvalue of <em>T</em>.</p>

<p>If , then <em>T</em> = 0 by the <a href="polarization_identity" title="wikilink">polarization identity</a>, and this case is clear. Consider the function</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:9">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>f</mi>
       <mo>:</mo>
       <mrow>
        <mi>H</mi>
        <mo>→</mo>
        <mi>𝐑</mi>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mrow>
         <mi>T</mi>
         <mi>x</mi>
        </mrow>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <ci>normal-:</ci>
     <ci>f</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>H</ci>
      <ci>𝐑</ci>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <list>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>x</ci>
      </apply>
      <ci>x</ci>
     </list>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}f:H\to\mathbf{R}\\
f(x)=\langle Tx,x\rangle\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Replacing <em>T</em> by −<em>T</em> if necessary, one may assume that the supremum of <em>f</em> on the closed unit ball <em>B</em> ⊂ <em>H</em> is equal to . If <em>f</em> attains its maximum <em>m</em>(<em>T</em>) on <em>B</em> at some unit vector <em>y</em>, then, by the same argument used for matrices, <em>y</em> is an eigenvector of <em>T</em>, with corresponding eigenvalue  = .</p>

<p>By the <a href="Banach–Alaoglu_theorem" title="wikilink">Banach–Alaoglu theorem</a> and the reflexivity of <em>H</em>, the closed unit ball <em>B</em> is weakly compact. Also, the compactness of <em>T</em> means (see above) that <em>T</em> : <em>X</em> with the weak topology → <em>X</em> with the norm topology, is continuous. These two facts imply that <em>f</em> is continuous on <em>B</em> equipped with the weak topology, and <em>f</em> attains therefore its maximum <em>m</em> on <em>B</em> at some . By maximality, ||<em>y</em>|| = 1, which in turn implies that <em>y</em> also maximizes the Rayleigh quotient <em>g</em>(<em>x</em>) (see above). This shows that <em>y</em> is an eigenvector of <em>T</em>, and ends the proof of the claim.</p>

<p><strong>Note.</strong> The compactness of <em>T</em> is crucial. In general, <em>f</em> need not be continuous for the weak topology on the unit ball <em>B</em>. For example, let <em>T</em> be the identity operator, which is not compact when <em>H</em> is infinite-dimensional. Take any orthonormal sequence {<em>y<sub>n</sub></em>}. Then <em>y<sub>n</sub></em> converges to 0 weakly, but lim <em>f</em>(<em>y<sub>n</sub></em>) = 1 ≠ 0 = <em>f</em>(0).</p>

<p>Let <em>T</em> be a compact operator on a Hilbert space <em>H</em>. A finite (possibly empty) or countably infinite orthonormal sequence {<em>e<sub>n</sub></em>} of eigenvectors of <em>T</em>, with corresponding non-zero eigenvalues, is constructed by induction as follows. Let <em>H</em><sub>0</sub> = <em>H</em> and <em>T</em><sub>0</sub> = <em>T</em>. If <em>m</em>(<em>T</em><sub>0</sub>) = 0, then <em>T</em> = 0 and the construction stops without producing any eigenvector <em>e<sub>n</sub></em>. Suppose that orthonormal eigenvectors <mtpl></mtpl> of <em>T</em> have been found. Then <mtpl> span(<em>e</em><sub>0</sub>, …, <em>e</em><sub><em>n</em> − 1</sub>)}}</mtpl> is invariant under <em>T</em>, and by self-adjointness, the orthogonal complement <em>H<sub>n</sub></em> of <em>E</em><sub><em>n</em></sub> is an invariant subspace of <em>T</em>. Let <em>T<sub>n</sub></em> denote the restriction of <em>T</em> to <em>H<sub>n</sub></em>. If <em>m</em>(<em>T<sub>n</sub></em>) = 0, then <em>T<sub>n</sub></em> = 0, and the construction stops. Otherwise, by the <em>claim</em> applied to <em>T<sub>n</sub></em>, there is a norm one eigenvector <em>e<sub>n</sub></em> of <em>T</em> in <em>H</em><sub><em>n</em></sub>, with corresponding non-zero eigenvalue λ<sub><em>n</em></sub> = <mtpl></mtpl>.</p>

<p>Let <em>F</em> = (span{<em>e<sub>n</sub></em>})<sup>⊥</sup>, where {<em>e<sub>n</sub></em>} is the finite or infinite sequence constructed by the inductive process; by self-adjointness, <em>F</em> is invariant under <em>T</em>. Let <em>S</em> denote the restriction of <em>T</em> to <em>F</em>. If the process was stopped after finitely many steps, with a last vector <em>e</em><sub><em>m</em>−1</sub>, then <em>F</em>= <em>H<sub>m</sub></em> and <em>S</em> = <em>T<sub>m</sub></em> = 0 by construction. In the infinite case, compactness of <em>T</em> and the weak-convergence of <em>e<sub>n</sub></em> to 0 imply that <mtpl> λ<sub><em>n</em></sub><em>e<sub>n</sub></em> → 0}}</mtpl>, therefore <mtpl></mtpl>. Since <em>F</em> is contained in <em>H<sub>n</sub></em> for every <em>n</em>, it follows that <em>m</em>(<em>S</em>) ≤ <em>m</em>({<em>T<sub>n</sub></em>}) = |λ<sub><em>n</em></sub>| for every <em>n</em>, hence <em>m</em>(<em>S</em>) = 0. This implies again that .</p>

<p>The fact that <em>S</em> = 0 means that <em>F</em> is contained in the kernel of <em>T</em>. Conversely, if <em>x</em> ∈ ker(<em>T</em>), then by self-adjointness, <em>x</em> is orthogonal to every eigenvector {<em>e<sub>n</sub></em>} with non-zero eigenvalue. It follows that , and that {<em>e<sub>n</sub></em>} is an orthonormal basis for the orthogonal complement of the kernel of <em>T</em>. One can complete the diagonalization of <em>T</em> by selecting an orthonormal basis of the kernel. This proves the spectral theorem.</p>

<p>A shorter but more abstract proof goes as follows: by <a href="Zorn's_lemma" title="wikilink">Zorn's lemma</a>, select <em>U</em> to be a maximal subset of <em>H</em> with the following three properties: all elements of <em>U</em> are eigenvectors of <em>T</em>, they have norm one, and any two distinct elements of <em>U</em> are orthogonal. Let <em>F</em> be the orthogonal complement of the linear span of <em>U</em>. If <em>F</em> ≠ {0}, it is a non-trivial invariant subspace of <em>T</em>, and by the initial claim there must exist a norm one eigenvector <em>y</em> of <em>T</em> in <em>F</em>. But then <em>U</em> ∪ {<em>y</em>} contradicts the maximality of <em>U</em>. It follows that <em>F</em> = {0}, hence span(<em>U</em>) is dense in <em>H</em>. This shows that <em>U</em> is an orthonormal basis of <em>H</em> consisting of eigenvectors of <em>T</em>.</p>
<h3 id="functional-calculus">Functional calculus</h3>

<p>If <em>T</em> is compact on an infinite-dimensional Hilbert space <em>H</em>, then <em>T</em> is not invertible, hence σ(<em>T</em>), the spectrum of <em>T</em>, always contains 0. The spectral theorem shows that σ(<em>T</em>) consists of the eigenvalues {λ<sub><em>n</em></sub>} of <em>T</em>, and of 0 (if 0 is not already an eigenvalue). The set σ(<em>T</em>) is a compact subset of the real line, and the eigenvalues are dense in σ(<em>T</em>).</p>

<p>Any spectral theorem can be reformulated in terms of a <a href="functional_calculus" title="wikilink">functional calculus</a>. In the present context we have:</p>

<p><strong>Theorem.</strong> Let <em>C</em>(σ(<em>T</em>)) denote the <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a> of continuous functions on σ(<em>T</em>). There exists a unique isometric homomorphism  such that Φ(1) = <em>I</em> and, if <em>f</em> is the identity function <em>f</em>(λ) = λ, then . Moreover, .</p>

<p>The functional calculus map Φ is defined in a natural way: let {<em>e<sub>n</sub></em>} be an orthonormal basis of eigenvectors for <em>H</em>, with corresponding eigenvalues {λ<sub><em>n</em></sub>}; for , the operator Φ(<em>f</em>), diagonal with respect to the orthonormal basis {<em>e<sub>n</sub></em>}, is defined by setting</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:10">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>e</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>λ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>e</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(f)(e_{n})=f(\lambda_{n})e_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>for every <em>n</em>. Since Φ(<em>f</em>) is diagonal with respect to an orthonormal basis, its norm is equal to the supremum of the modulus of diagonal coefficients,</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>n</mi>
       </msub>
       <mo>∈</mo>
       <mrow>
        <mi>σ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>λ</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mi>f</mi>
      <mo>∥</mo>
     </mrow>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>σ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <ci>σ</ci>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>σ</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\Phi(f)\|=\sup_{\lambda_{n}\in\sigma(T)}|f(\lambda_{n})|=\|f\|_{C(\sigma(T))}.
  </annotation>
 </semantics>
</math>

</p>

<p>The other properties of Φ can be readily verified. Conversely, any homomorphism Ψ satisfying the requirements of the theorem must coincide with Φ when <em>f</em> is a polynomial. By the <a href="Stone–Weierstrass_theorem" title="wikilink">Weierstrass approximation theorem</a>, polynomial functions are dense in <em>C</em>(σ(<em>T</em>)), and it follows that . This shows that Φ is unique.</p>

<p>The more general <a href="continuous_functional_calculus" title="wikilink">continuous functional calculus</a> can be defined for any self-adjoint (or even normal, in the complex case) bounded linear operator on a Hilbert space. The compact case, described here, is a particularly simple instance of this functional calculus.</p>
<h3 id="simultaneous-diagonalisation">Simultaneous diagonalisation</h3>

<p>Consider an Hilbert space <em>H</em> (e.g. the finite-dimensional <strong>C</strong><sup><em>n</em></sup>), and a commuting set 

<math display="inline" id="Compact_operator_on_Hilbert_space:12">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mo>⊆</mo>
   <mrow>
    <mo>Hom</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo>,</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>ℱ</ci>
    <apply>
     <ci>Hom</ci>
     <ci>H</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}\subseteq\operatorname{Hom}(H,H)
  </annotation>
 </semantics>
</math>

 of self-adjoint operators. Then under suitable conditions, can be simultaneously (unitarily) diagonalised. <em>Viz.</em>, there exists an orthonormal basis <em>Q</em> consisting of common eigenvectors for the operators — <em>i.e.</em></p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>q</mi>
    <mo>∈</mo>
    <mi>Q</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">ℱ</mi>
    <mo rspace="5.8pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>σ</mi>
    <mo>∈</mo>
    <mi>𝐂</mi>
    <mo rspace="5.8pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>-</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <in></in>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">T</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">σ</csymbol>
     <in></in>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <minus></minus>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">q</csymbol>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall{q\in Q,T\in\mathcal{F}})~{}(\exists{\sigma\in\mathbf{C}})~{}(T-\sigma%
)q=0
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Lemma.</strong> Suppose all the operators in 

<math display="inline" id="Compact_operator_on_Hilbert_space:14">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 are compact. Then every closed non-zero 

<math display="inline" id="Compact_operator_on_Hilbert_space:15">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

-invariant sub-space <em>S</em> ⊆ <em>H</em> has a common eigenvector for 

<math display="inline" id="Compact_operator_on_Hilbert_space:16">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Proof.</strong> <em>Case I:</em> all the operators have each exactly one eigenvalue. Then take any 

<math display="inline" id="Compact_operator_on_Hilbert_space:17">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in S
  </annotation>
 </semantics>
</math>

 of unit length. This is a common eigenvector.</p>

<p><em>Case II:</em> there is some operator 

<math display="inline" id="Compact_operator_on_Hilbert_space:18">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>T</ci>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\in\mathcal{F}
  </annotation>
 </semantics>
</math>

 with at least 2 eigenvalues and let 

<math display="inline" id="Compact_operator_on_Hilbert_space:19">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≠</mo>
   <mi>α</mi>
   <mo>∈</mo>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>↾</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">0</cn>
    <neq></neq>
    <csymbol cd="unknown">α</csymbol>
    <in></in>
    <csymbol cd="unknown">σ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-↾</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\neq\alpha\in\sigma(T\upharpoonright S)
  </annotation>
 </semantics>
</math>

. Since <em>T</em> is compact and α is non-zero, we have 

<math display="inline" id="Compact_operator_on_Hilbert_space:20">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
   <mo>:=</mo>
   <mrow>
    <mi>ker</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>↾</mo>
      <mrow>
       <mi>S</mi>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">kernel</csymbol>
     <apply>
      <ci>normal-↾</ci>
      <ci>T</ci>
      <apply>
       <minus></minus>
       <ci>S</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}:=\ker(T\upharpoonright S-\alpha)
  </annotation>
 </semantics>
</math>

 is a finite-dimensional (and therefore closed) non-zero 

<math display="inline" id="Compact_operator_on_Hilbert_space:21">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

-invariant sub-space (because the operators all commute with <em>T</em>, we have for 

<math display="inline" id="Compact_operator_on_Hilbert_space:22">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mo>′</mo>
   </msup>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{\prime}\in\mathcal{F}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Compact_operator_on_Hilbert_space:23">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mi>ker</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>↾</mo>
      <mrow>
       <mi>S</mi>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">kernel</csymbol>
     <apply>
      <ci>normal-↾</ci>
      <ci>T</ci>
      <apply>
       <minus></minus>
       <ci>S</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\ker(T\upharpoonright S-\alpha)
  </annotation>
 </semantics>
</math>

, that 

<math display="inline" id="Compact_operator_on_Hilbert_space:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mi>α</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>T</mi>
       <mo>′</mo>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>T</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+3.3pt">
         <mi>T</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>α</mi>
      <msup>
       <mi>T</mi>
       <mo>′</mo>
      </msup>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <ci>α</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T-\alpha)(T^{\prime}x)=(T^{\prime}(T~{}x)-\alpha T^{\prime}x)=0
  </annotation>
 </semantics>
</math>

). In particular we definitely have 

<math display="inline" id="Compact_operator_on_Hilbert_space:25">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="5.8pt">dim</mo>
    <msup>
     <mi>S</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo rspace="5.8pt">dim</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dim~{}S^{\prime}<\dim~{}S
  </annotation>
 </semantics>
</math>

. Thus we could in principle argue by induction over dimension, yielding that 

<math display="inline" id="Compact_operator_on_Hilbert_space:26">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
   <mo>⊆</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}\subseteq S
  </annotation>
 </semantics>
</math>

 has a common eigenvector for 

<math display="inline" id="Compact_operator_on_Hilbert_space:27">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Theorem 1.</strong> If all the operators in 

<math display="inline" id="Compact_operator_on_Hilbert_space:28">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 are compact then the operators can be simultaneously (unitarily) diagonalised.</p>

<p><strong>Proof.</strong> The following set</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐏</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>A</mi>
      <mo>⊆</mo>
      <mi>H</mi>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mi>A</mi>
      <mtext>is an orthonormal set of common eigenvectors for</mtext>
      <mi class="ltx_font_mathcaligraphic">ℱ</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐏</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <subset></subset>
      <ci>A</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <mtext>is an orthonormal set of common eigenvectors for</mtext>
      <ci>ℱ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{P}=\{A\subseteq H:A\text{ is an orthonormal set of common eigenvectors%
 for }\mathcal{F}\},
  </annotation>
 </semantics>
</math>

</p>

<p>is partially ordered by inclusion. This clearly has the Zorn property. So taking <em>Q</em> a maximal member, if <em>Q</em> is a basis for the whole hilbert space <em>H</em>, we are done. If this were not the case, then letting 

<math display="inline" id="Compact_operator_on_Hilbert_space:30">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>Q</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>⊥</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>Q</ci>
     </apply>
     <csymbol cd="latexml">bottom</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S={\langle Q\rangle}^{\bot}
  </annotation>
 </semantics>
</math>

, it is easy to see that this would be an 

<math display="inline" id="Compact_operator_on_Hilbert_space:31">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

-invariant non-trivial closed subspace; and thus by the lemma above, therein would lie a common eigenvector for the operators (necessarily orthogonal to <em>Q</em>). But then there would then be a proper extension of <em>Q</em> within <strong>P</strong>; a contradiction to its maximality.</p>

<p><strong>Theorem 2.</strong> If there is an injective compact operator in 

<math display="inline" id="Compact_operator_on_Hilbert_space:32">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

; then the operators can be simultaneously (unitarily) diagonalised.</p>

<p><strong>Proof.</strong> Fix 

<math display="inline" id="Compact_operator_on_Hilbert_space:33">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{0}\in\mathcal{F}
  </annotation>
 </semantics>
</math>

 compact injective. Then we have, by the spectral theory of compact symmetric operators on hilbert spaces:</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>=</mo>
    <mover accent="true">
     <mrow>
      <munder>
       <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
       <mrow>
        <mi>λ</mi>
        <mo>∈</mo>
        <mrow>
         <mi>σ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>T</mi>
           <mn>0</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </munder>
      <mrow>
       <mi>ker</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>T</mi>
          <mn>0</mn>
         </msub>
         <mo>-</mo>
         <mi>σ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>¯</mo>
    </mover>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <in></in>
        <ci>λ</ci>
        <apply>
         <times></times>
         <ci>σ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">kernel</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\overline{\bigoplus_{\lambda\in\sigma(T_{0})}\ker(T_{0}-\sigma)},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Compact_operator_on_Hilbert_space:35">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>T</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(T_{0})
  </annotation>
 </semantics>
</math>

 is a discrete, countable subset of positive real numbers, and all the eigenspaces are finite-dimensional. Since 

<math display="inline" id="Compact_operator_on_Hilbert_space:36">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 a commuting set, we have all the eigenspaces are invariant. Since the operators restricted to the eigenspaces (which are finite-dimensional) are automatically all compact, we can apply Theorem 1 to each of these, and find orthonormal bases <em>Q</em><sub>σ</sub> for the 

<math display="inline" id="Compact_operator_on_Hilbert_space:37">
 <semantics>
  <mrow>
   <mi>ker</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>T</mi>
      <mn>0</mn>
     </msub>
     <mo>-</mo>
     <mi>σ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">kernel</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ker(T_{0}-\sigma)
  </annotation>
 </semantics>
</math>

. Since <em>T</em><sub>0</sub> is symmetric, we have that</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:38">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>:=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
     <mrow>
      <mi>σ</mi>
      <mo>∈</mo>
      <mrow>
       <mi>σ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>T</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </munder>
    <msub>
     <mi>Q</mi>
     <mi>σ</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>Q</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <in></in>
       <ci>σ</ci>
       <apply>
        <times></times>
        <ci>σ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q:=\bigcup_{\sigma\in\sigma(T_{0})}Q_{\sigma}
  </annotation>
 </semantics>
</math>

</p>

<p>is a (countable) orthonormal set. It is also, by the decomposition we first stated, a basis for <em>H</em>.</p>

<p><strong>Theorem 3.</strong> If <em>H</em> a finite-dimensional Hilbert space, and 

<math display="inline" id="Compact_operator_on_Hilbert_space:39">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mo>⊆</mo>
   <mrow>
    <mo>Hom</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo>,</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>ℱ</ci>
    <apply>
     <ci>Hom</ci>
     <ci>H</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}\subseteq\operatorname{Hom}(H,H)
  </annotation>
 </semantics>
</math>

 a commutative set of operators, each of which is diagonalisable; then the operators can be simultaneously diagonalised.</p>

<p><strong>Proof.</strong> <em>Case I:</em> all operators have exactly one eigenvalue. Then any basis for <em>H</em> will do.</p>

<p><em>Case II:</em> Fix 

<math display="inline" id="Compact_operator_on_Hilbert_space:40">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{0}\in\mathcal{F}
  </annotation>
 </semantics>
</math>

 an operator with at least two eigenvalues, and let 

<math display="inline" id="Compact_operator_on_Hilbert_space:41">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∈</mo>
   <mo>Hom</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo>,</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <in></in>
    <ci>Hom</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\in\operatorname{Hom}(H,H)^{\times}
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Compact_operator_on_Hilbert_space:42">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mpadded>
   <mpadded width="+3.3pt">
    <msub>
     <mi>T</mi>
     <mn>0</mn>
    </msub>
   </mpadded>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}~{}T_{0}~{}P
  </annotation>
 </semantics>
</math>

 is a symmetric operator. Now let α be an eigenvalue of 

<math display="inline" id="Compact_operator_on_Hilbert_space:43">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <msub>
    <mi>T</mi>
    <mn>0</mn>
   </msub>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}T_{0}P
  </annotation>
 </semantics>
</math>

. Then it is easy to see that both:</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:44">
 <semantics>
  <mrow>
   <mi>ker</mi>
   <mrow>
    <mo>(</mo>
    <mpadded width="+3.3pt">
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mpadded>
    <msub>
     <mi>T</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>-</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mi>ker</mi>
   <msup>
    <mrow>
     <mo>(</mo>
     <mpadded width="+3.3pt">
      <msup>
       <mi>P</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mpadded>
     <msub>
      <mi>T</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo>-</mo>
      <mi>α</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>⊥</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">kernel</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">0</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <minus></minus>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="latexml">kernel</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">0</cn>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">P</csymbol>
       <minus></minus>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="latexml">bottom</csymbol>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ker\left(P^{-1}~{}T_{0}(P-\alpha)\right),\quad\ker\left(P^{-1}~{}T_{0}(P-%
\alpha)\right)^{\bot}
  </annotation>
 </semantics>
</math>

</p>

<p>are non-trivial 

<math display="inline" id="Compact_operator_on_Hilbert_space:45">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>ℱ</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}\mathcal{F}P
  </annotation>
 </semantics>
</math>

-invariant subspaces. By induction over dimension we have that there are linearly independent bases <em>Q</em><sub>1</sub>, <em>Q</em><sub>2</sub> for the subspaces, which demonstrate that the operators in 

<math display="inline" id="Compact_operator_on_Hilbert_space:46">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>ℱ</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{-1}\mathcal{F}P
  </annotation>
 </semantics>
</math>

 can be simultaneously diagonalisable on the subspaces. Clearly then 

<math display="inline" id="Compact_operator_on_Hilbert_space:47">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>1</mn>
     </msub>
     <mo>∪</mo>
     <msub>
      <mi>Q</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(Q_{1}\cup Q_{2})
  </annotation>
 </semantics>
</math>

 demonstrates that the operators in 

<math display="inline" id="Compact_operator_on_Hilbert_space:48">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 can be simultaneously diagonalised.</p>

<p>Notice we did not have to directly use the machinery of matrices at all in this proof. There are other versions which do.</p>

<p>We can strengthen the above to the case where all the operators merely commute with their adjoint; in this case we remove the term "orthogonal" from the diagonalisation. There are weaker results for operators arising from representations due to Weyl–Peter. Let <em>G</em> be a fixed locally compact hausdorff group, and 

<math display="inline" id="Compact_operator_on_Hilbert_space:49">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>L</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=L^{2}(G)
  </annotation>
 </semantics>
</math>

 (the space of square integrable measurable functions with respect to the unique-up-to-scale Haar measure on <em>G</em>). Consider the continuous shift action:</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:50">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>G</mi>
        <mo>×</mo>
        <mi>H</mi>
       </mrow>
       <mo>→</mo>
       <mi>H</mi>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>g</mi>
          <mi>f</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msup>
           <mi>g</mi>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>H</ci>
     </apply>
     <ci>H</ci>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>f</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}G\times H\to H\\
(gf)(x)=f(g^{-1}x)\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Then if <em>G</em> were compact then there is a unique decomposition of <em>H</em> into a countable direct sum of finite-dimensional, irreducible, invariant subspaces (this is essentially diagonalisation of the family of operators 

<math display="inline" id="Compact_operator_on_Hilbert_space:51">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>G</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\subseteq U(H)
  </annotation>
 </semantics>
</math>

). If <em>G</em> were not compact, but were abelien, then diagonalisation is not achieved, but we get a unique <em>continuous</em> decomposition of <em>H</em> into 1-dimensional invariant subspaces.</p>
<h2 id="compact-normal-operator">Compact normal operator</h2>

<p>The family of Hermitian matrices is a proper subset of matrices that are unitarily diagonalizable. A matrix <em>M</em> is unitarily diagonalizable if and only if it is normal, i.e. <em>M*M</em> = <em>MM*</em>. Similar statements hold for compact normal operators.</p>

<p>Let <em>T</em> be compact and <em>T*T</em> = <em>TT*</em>. Apply the <em>Cartesian decomposition</em> to <em>T</em>: define</p>

<p>

<math display="block" id="Compact_operator_on_Hilbert_space:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <mi>T</mi>
       <mo>+</mo>
       <msup>
        <mi>T</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>J</mi>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <msup>
        <mi>T</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>i</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>R</ci>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <times></times>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>J</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <times></times>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\frac{T+T^{*}}{2},\quad J=\frac{T-T^{*}}{2i}.
  </annotation>
 </semantics>
</math>

</p>

<p>The self adjoint compact operators <em>R</em> and <em>J</em> are called the real and imaginary parts of <em>T</em> respectively. <em>T</em> is compact means <em>T*</em>, consequently <em>R</em> and <em>J</em>, are compact. Furthermore, the normality of <em>T</em> implies <em>R</em> and <em>J</em> commute. Therefore they can be simultaneously diagonalized, from which follows the claim.</p>

<p>A <a href="hyponormal_operator" title="wikilink">hyponormal compact operator</a> (in particular, a <a href="subnormal_operator" title="wikilink">subnormal operator</a>) is normal.</p>
<h2 id="unitary-operator">Unitary operator</h2>

<p>The spectrum of a <a href="unitary_operator" title="wikilink">unitary operator</a> <em>U</em> lies on the unit circle in the complex plane; it could be the entire unit circle. However, if <em>U</em> is identity plus a compact perturbation, <em>U</em> has only countable spectrum, containing 1 and possibly, a finite set or a sequence tending to 1 on the unit circle. More precisely, suppose  where <em>C</em> is compact. The equations  and  show that <em>C</em> is normal. The spectrum of <em>C</em> contains 0, and possibly, a finite set or a sequence tending to 0. Since , the spectrum of <em>U</em> is obtained by shifting the spectrum of <em>C</em> by 1.</p>
<h2 id="examples">Examples</h2>
<ul>
<li>Let <em>H</em> = [[Lp space|<em>L</em><sup>2</sup>([0, 1])]]. The multiplication operator <em>M</em> defined by</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Compact_operator_on_Hilbert_space:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>M</mi>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mo>∈</mo>
     <mi>H</mi>
    </mrow>
    <mo rspace="5.9pt">,</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>f</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>f</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <in></in>
      <ci>x</ci>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Mf)(x)=xf(x),\quad f\in H,\,\,x\in[0,1]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>is a bounded self-adjoint operator on <em>H</em> that has no eigenvector and hence, by the spectral theorem, cannot
</dd>
</dl>

<p>be compact.</p>
<ul>
<li>Let <em>K</em>(<em>x</em>, <em>y</em>) be square integrable on [0, 1]<sup>2</sup> and define <em>T</em><sub><em>K</em></sub> on <em>H</em> by</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Compact_operator_on_Hilbert_space:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>T</mi>
        <mi>K</mi>
       </msub>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mn>1</mn>
     </msubsup>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>K</ci>
      </apply>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <ci>f</ci>
      <ci>y</ci>
      <ci>normal-d</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T_{K}f)(x)=\int_{0}^{1}K(x,y)f(y)\,\mathrm{d}y.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>Then <em>T<sub>K</sub></em> is compact on <em>H</em>; it is a <a href="Hilbert–Schmidt_operator" title="wikilink">Hilbert–Schmidt operator</a>.
</dd>
</dl>
<ul>
<li>Suppose that the kernel <em>K</em>(<em>x</em>, <em>y</em>) satisfies the Hermiticity condition</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Compact_operator_on_Hilbert_space:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mover accent="true">
       <mrow>
        <mi>K</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>¯</mo>
      </mover>
      <mo rspace="12.5pt">,</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>y</ci>
       <ci>x</ci>
      </interval>
     </apply>
     <list>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <ci>K</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
      </apply>
      <ci>x</ci>
     </list>
    </apply>
    <apply>
     <in></in>
     <ci>y</ci>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(y,x)=\overline{K(x,y)},\quad x,y\in[0,1].
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>Then <em>T<sub>K</sub></em> is compact and self-adjoint on <em>H</em>; if {φ<sub><em>n</em></sub>} is an orthonormal basis of eigenvectors, with eigenvalues {λ<sub><em>n</em></sub>}, it can be proved that
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Compact_operator_on_Hilbert_space:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo largeop="true" symmetric="true">∑</mo>
      <msubsup>
       <mi>λ</mi>
       <mi>n</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo><</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∼</mo>
     <mrow>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>φ</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mover accent="true">
        <mrow>
         <msub>
          <mi>φ</mi>
          <mi>n</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>¯</mo>
       </mover>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <ci>n</ci>
       </apply>
       <ci>x</ci>
       <apply>
        <ci>normal-¯</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>φ</ci>
          <ci>n</ci>
         </apply>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum\lambda_{n}^{2}<\infty,\ \ K(x,y)\sim\sum\lambda_{n}\varphi_{n}(x)%
\overline{\varphi_{n}(y)},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>where the sum of the series of functions is understood as <em>L</em><sup>2</sup> convergence for the Lebesgue measure <mtpl></mtpl>. <a href="Mercer's_theorem" title="wikilink">Mercer's theorem</a> gives conditions under which the series converges to <em>K</em>(<em>x</em>, <em>y</em>) pointwise, and uniformly <mtpl></mtpl>.
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Singular_value_decomposition#Bounded_operators_on_Hilbert_spaces" title="wikilink">Singular value decomposition#Bounded operators on Hilbert spaces</a>. The notion of singular values can be extended from matrices to compact operators.</li>
<li><a href="Decomposition_of_spectrum_(functional_analysis)" title="wikilink">Decomposition of spectrum (functional analysis)</a>. If the compactness assumption is removed, operators need not have countable spectrum in general.</li>
<li><a href="Calkin_algebra" title="wikilink">Calkin algebra</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>J. Blank, P. Exner, and M. Havlicek, <em>Hilbert Space Operators in Quantum Physics</em>, American Institute of Physics, 1994.</li>
<li>M. Reed and B. Simon, <em>Methods of Modern Mathematical Physics I: Functional Analysis</em>, Academic Press, 1972.</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a> <a href="Category:Hilbert_space" title="wikilink">Category:Hilbert space</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
</body>
</html>
