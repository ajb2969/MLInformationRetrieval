   Kernel principal component analysis      Kernel principal component analysis   In the field of multivariate statistics , kernel principal component analysis (kernel PCA)  1 is an extension of principal component analysis (PCA) using techniques of kernel methods . Using a kernel, the originally linear operations of PCA are done in a reproducing kernel Hilbert space with a non-linear mapping.  Background: Linear PCA  Recall that conventional PCA operates on zero-centered data; that is,        1  N     âˆ‘   i  =  1   N    ğ±  i     =  ğŸ          1  N     superscript   subscript     i  1    N    subscript  ğ±  i     0    \frac{1}{N}\sum_{i=1}^{N}\mathbf{x}_{i}=\mathbf{0}   . It operates by diagonalizing the covariance matrix ,      C  =    1  N     âˆ‘   i  =  1   N     ğ±  i    ğ±  i  âŠ¤          C      1  N     superscript   subscript     i  1    N      subscript  ğ±  i    superscript   subscript  ğ±  i   top        C=\frac{1}{N}\sum_{i=1}^{N}\mathbf{x}_{i}\mathbf{x}_{i}^{\top}   in other words, it gives an eigendecomposition of the covariance matrix:       Î»  ğ¯   =   C  ğ¯         Î»  ğ¯     C  ğ¯     \lambda\mathbf{v}=C\mathbf{v}   which can be rewritten as        Î»   ğ±  i  âŠ¤   ğ¯   =    ğ±  i  âŠ¤   C  ğ¯      âˆ€  i   âˆˆ   [  1  ,  N  ]       formulae-sequence      Î»   superscript   subscript  ğ±  i   top   ğ¯      superscript   subscript  ğ±  i   top   C  ğ¯       for-all  i    1  N      \lambda\mathbf{x}_{i}^{\top}\mathbf{v}=\mathbf{x}_{i}^{\top}C\mathbf{v}\quad%
 \forall i\in[1,N]   . 2 (See also: Covariance matrix as a linear operator )  Introduction of the Kernel to PCA  To understand the utility of kernel PCA, particularly for clustering, observe that, while N points cannot in general be linearly separated in    ğ±  i     subscript  ğ±  i    \mathbf{x}_{i}   dimensions. That is, given N points,    Î¦   (   ğ±  i   )       normal-Î¦   subscript  ğ±  i     \Phi(\mathbf{x}_{i})   , if we map them to an N -dimensional space with      Î¦  :    â„  d   â†’   â„  N       normal-:  normal-Î¦   normal-â†’   superscript  â„  d    superscript  â„  N      \Phi:\mathbb{R}^{d}\to\mathbb{R}^{N}   where   Î¦   normal-Î¦   \Phi   , it is easy to construct a hyperplane that divides the points into arbitrary clusters. Of course, this   Î¦   normal-Î¦   \Phi   creates linearly independent vectors, so there is no covariance on which to perform eigendecomposition explicitly as we would in linear PCA.  Instead, in kernel PCA, a non-trivial, arbitrary   Î¦   normal-Î¦   \Phi   function is 'chosen' that is never calculated explicitly, allowing the possibility to use very-high-dimensional   Î¦   normal-Î¦   \Phi   's if we never have to actually evaluate the data in that space. Since we generally try to avoid working in the    K  =   k   (  ğ±  ,  ğ²  )    =   (   Î¦   (  ğ±  )    ,   Î¦   (  ğ²  )    )   =   Î¦    (  ğ±  )   T   Î¦   (  ğ²  )          K    k   ğ±  ğ²            normal-Î¦  ğ±     normal-Î¦  ğ²           normal-Î¦   superscript  ğ±  T   normal-Î¦  ğ²      K=k(\mathbf{x},\mathbf{y})=(\Phi(\mathbf{x}),\Phi(\mathbf{y}))=\Phi(\mathbf{x}%
 )^{T}\Phi(\mathbf{y})   -space, which we will call the 'feature space', we can create the N-by-N kernel      Î¦   (  ğ±  )       normal-Î¦  ğ±    \Phi(\mathbf{x})     which represents the inner product space (see Gramian matrix ) of the otherwise intractable feature space. The dual form that arises in the creation of a kernel allows us to mathematically formulate a version of PCA in which we never actually solve the eigenvectors and eigenvalues of the covariance matrix in the    Î¦   (  ğ±  )       normal-Î¦  ğ±    \Phi(\mathbf{x})   -space (see Kernel trick ). The N-elements in each column of K represent the dot product of one point of the transformed data with respect to all the transformed points (N points). Some well-known kernels are shown in the example below.  Because we are never working directly in the feature space, the kernel-formulation of PCA is restricted in that it computes not the principal components themselves, but the projections of our data onto those components. To evaluate the projection from a point in the feature space   V   V   V   onto the kth principal component      ğ•   k   T   Î¦   (  ğ±  )    =     (    âˆ‘   i  =  1   N     ğš  ğ¢    k   Î¦   (   ğ±  ğ¢   )     )   T   Î¦   (  ğ±  )           superscript   superscript  ğ•  k   T   normal-Î¦  ğ±      superscript    superscript   subscript     i  1    N      superscript   subscript  ğš  ğ¢   k   normal-Î¦   subscript  ğ±  ğ¢     T   normal-Î¦  ğ±     {\mathbf{V}^{k}}^{T}\Phi(\mathbf{x})=\left(\sum_{i=1}^{N}\mathbf{a_{i}}^{k}%
 \Phi(\mathbf{x_{i}})\right)^{T}\Phi(\mathbf{x})   (where superscript k means the component k, not powers of k)      Î¦    (   ğ±  ğ¢   )   T   Î¦   (  ğ±  )       normal-Î¦   superscript   subscript  ğ±  ğ¢   T   normal-Î¦  ğ±    \Phi(\mathbf{x_{i}})^{T}\Phi(\mathbf{x})     We note that   K   K   K   denotes dot product, which is simply the elements of the kernel    ğš  ğ¢    k     superscript   subscript  ğš  ğ¢   k    \mathbf{a_{i}}^{k}   . It seems all that's left is to calculate and normalize the     N  Î»  ğš   =   K  ğš         N  Î»  ğš     K  ğš     N\lambda\mathbf{a}=K\mathbf{a}   , which can be done by solving the eigenvector equation     Î»   Î»   \lambda     where N is the number of data points in the set, and   ğš   ğš   \mathbf{a}   and    ğš  k     superscript  ğš  k    \mathbf{a}^{k}   are the eigenvalues and eigenvectors of K. Then to normalize the eigenvectors    1  =     (   ğš  k   )   T    ğš  k        1     superscript   superscript  ğš  k   T    superscript  ğš  k      1=(\mathbf{a}^{k})^{T}\mathbf{a}^{k}   's, we require that     x   x   x     Care must be taken regarding the fact that, whether or not    K  â€²     superscript  K  normal-â€²    K^{\prime}   has zero-mean in its original space, it is not guaranteed to be centered in the feature space (which we never compute explicitly). Since centered data is required to perform an effective principal component analysis, we 'centralize' K to become     K  â€²   =    K  -    ğŸ  ğ   K   -   K   ğŸ  ğ     +    ğŸ  ğ   K   ğŸ  ğ          superscript  K  normal-â€²       K     subscript  1  ğ   K     K   subscript  1  ğ        subscript  1  ğ   K   subscript  1  ğ       K^{\prime}=K-\mathbf{1_{N}}K-K\mathbf{1_{N}}+\mathbf{1_{N}}K\mathbf{1_{N}}         ğŸ  ğ     subscript  1  ğ    \mathbf{1_{N}}     where    1  /  N      1  N    1/N   denotes a N-by-N matrix for which each element takes value    K  â€²     superscript  K  normal-â€²    K^{\prime}   . We use     k   (  ğ’™  ,  ğ’š  )    =    (     ğ’™  T   ğ’š   +  1   )   2         k   ğ’™  ğ’š     superscript       superscript  ğ’™  normal-T   ğ’š   1   2     k(\boldsymbol{x},\boldsymbol{y})=(\boldsymbol{x}^{\mathrm{T}}\boldsymbol{y}+1)%
 ^{2}   to perform the kernel PCA algorithm described above.  One caveat of kernel PCA should be illustrated here. In linear PCA, we can use the eigenvalues to rank the eigenvectors based on how much of the variation of the data is captured by each principal component. This is useful for data dimensionality reduction and it could also be applied to KPCA. However, in practice there are cases that all variations of the data are same. This is typically caused by a wrong choice of kernel scale.  Large Datasets  In practice, a large data set leads to a large K, and storing K may become a problem. One way to deal with this is to perform clustering on the dataset, and populate the kernel with the means of those clusters. Since even this method may yield a relatively large K, it is common to compute only the top P eigenvalues and eigenvectors of K.  Example  (Figure)  Input points before kernel PCA   Consider three concentric clouds of points (shown); we wish to use kernel PCA to identify these groups. The color of the points is not part of the algorithm, but only there to show how the data groups together before and after the transformation.  First, consider the kernel       k   (  ğ’™  ,  ğ’š  )    =    (     ğ’™  T   ğ’š   +  1   )   2         k   ğ’™  ğ’š     superscript       superscript  ğ’™  normal-T   ğ’š   1   2     k(\boldsymbol{x},\boldsymbol{y})=(\boldsymbol{x}^{\mathrm{T}}\boldsymbol{y}+1)%
 ^{2}     Applying this to kernel PCA yields the next image.  (Figure)  Output after kernel PCA with      k   (  ğ’™  ,  ğ’š  )    =   e    -    ||   ğ’™  -  ğ’š   ||   2     2   Ïƒ  2       ,        k   ğ’™  ğ’š     superscript  e       superscript   norm    ğ’™  ğ’š    2      2   superscript  Ïƒ  2        k(\boldsymbol{x},\boldsymbol{y})=e^{\frac{-||\boldsymbol{x}-\boldsymbol{y}||^{%
 2}}{2\sigma^{2}}},   . The three groups are distinguishable using the first component only.   Now consider a Gaussian kernel:  $$k(\boldsymbol{x},\boldsymbol{y}) = e^\frac{-| |\boldsymbol{x} - \boldsymbol{y}| |^2}{2\sigma^2},$$  That is, this kernel is a measure of closeness, equal to 1 when the points coincide and equal to 0 at infinity.  (Figure)  Output after kernel PCA, with a Gaussian kernel.   Note in particular that the first principal component is enough to distinguish the three different groups, which is impossible using only linear PCA, because linear PCA operates only in the given (in this case two-dimensional) space, in which these concentric point clouds are not linearly separable.  Applications  Kernel PCA has been demonstrated to be useful for novelty detection, 3 and image de-noising. 4  See also   Cluster analysis  Kernel trick  Multilinear PCA  Multilinear subspace learning  Nonlinear dimensionality reduction  Spectral clustering   References  sv:Principalkomponentanalys#OlinjÃ¤r PCA "  Category:Multivariate statistics  Category:Signal processing  Category:Machine learning algorithms  Category:Kernel methods for machine learning     Nonlinear Component Analysis as a Kernel Eigenvalue Problem â†©  Nonlinear Component Analysis as a Kernel Eigenvalue Problem (Technical Report) â†©  Kernel PCA for Novelty Detection. Pattern Recognition, 40, 863-874, 2007 â†©  Kernel PCA and De-Noising in Feature Spaces. NIPS, 1999 â†©     