<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1498">Normal polytope</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Normal polytope</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, specifically in <a href="combinatorial_commutative_algebra" title="wikilink">combinatorial commutative algebra</a>, a <a href="convex_lattice_polytope" title="wikilink">convex lattice polytope</a> <em>P</em> is called <strong>normal</strong> if it has the following property: given any positive integer <em>n</em>, every lattice point of the dilation <em>nP</em>, obtained from <em>P</em> by scaling its vertices by the factor <em>n</em> and taking the <a href="convex_hull" title="wikilink">convex hull</a> of the resulting points, can be written as the sum of exactly <em>n</em> lattice points in <em>P</em>. This property plays an important role in the theory of <a href="toric_variety" title="wikilink">toric varieties</a>, where it corresponds to <a href="projective_normality" title="wikilink">projective normality</a> of the toric variety determined by <em>P</em>. Normal polytopes have popularity in algebraic combinatorics. These polytopes also represent the homogeneous case of the Hilbert bases of finite positive rational cones and the connection to algebraic geometry is that they define projectively normal embeddings of toric varieties.</p>
<h2 id="definition">Definition</h2>

<p>Let <em>P</em> ⊂ ℝ<sup><em>d</em></sup> be a lattice <a class="uri" href="polytope" title="wikilink">polytope</a>. Denote the <a class="uri" href="affine" title="wikilink">affine</a> lattice in ℤ<sup><em>d</em></sup> generated by the lattice points in <em>P</em> by <em>L</em>:</p>

<p>

<math display="block" id="Normal_polytope:0">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mi>v</mi>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mi>P</mi>
        <mo>∩</mo>
        <mi>ℤ</mi>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mi>ℤ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <msup>
    <mi>ℤ</mi>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>v</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <list>
          <ci>x</ci>
          <ci>y</ci>
         </list>
         <apply>
          <intersect></intersect>
          <ci>P</ci>
          <ci>ℤ</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>ℤ</ci>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=v+\sum_{x,y\in P\cap\mathbb{Z}}\mathbb{Z}(x-y)\subseteq\mathbb{Z}^{d}
  </annotation>
 </semantics>
</math>

 where <em>v</em> is some lattice point in <em>P</em>.</p>

<p>P is <strong>integrally closed</strong> if the following condition is satisfied:</p>

<p>

<math display="block" id="Normal_polytope:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mo>∈</mo>
     <mi>ℕ</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>z</mi>
     <mo>∈</mo>
     <mrow>
      <mrow>
       <mi>c</mi>
       <mi>P</mi>
      </mrow>
      <mo>∩</mo>
      <msup>
       <mi>ℤ</mi>
       <mi>d</mi>
      </msup>
     </mrow>
     <mo>⟹</mo>
     <mrow>
      <mo>∃</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>c</mi>
     </msub>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>P</mi>
     <mo>∩</mo>
     <msup>
      <mi>ℤ</mi>
      <mi>d</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>c</ci>
      <ci>ℕ</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <ci>z</ci>
       <apply>
        <intersect></intersect>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>P</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ℤ</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <implies></implies>
       <share href="#.cmml">
       </share>
       <apply>
        <exists></exists>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <list>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>c</ci>
      </apply>
     </list>
     <apply>
      <intersect></intersect>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℤ</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\mathbb{N},z\in cP\cap\mathbb{Z}^{d}\implies\exists x_{1},\ldots,x_{c}\in P%
\cap\mathbb{Z}^{d}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Normal_polytope:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mi>c</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}+\cdots+x_{c}=z
  </annotation>
 </semantics>
</math>

.</p>

<p><em>P</em> is <strong>normal</strong> if the following condition is satisfied:</p>

<p>

<math display="block" id="Normal_polytope:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mo>∈</mo>
     <mi>ℕ</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>z</mi>
     <mo>∈</mo>
     <mrow>
      <mrow>
       <mi>c</mi>
       <mi>P</mi>
      </mrow>
      <mo>∩</mo>
      <mi>L</mi>
     </mrow>
     <mo>⟹</mo>
     <mrow>
      <mo>∃</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>c</mi>
     </msub>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>P</mi>
     <mo>∩</mo>
     <mi>L</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>c</ci>
      <ci>ℕ</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <ci>z</ci>
       <apply>
        <intersect></intersect>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>P</ci>
        </apply>
        <ci>L</ci>
       </apply>
      </apply>
      <apply>
       <implies></implies>
       <share href="#.cmml">
       </share>
       <apply>
        <exists></exists>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <list>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>c</ci>
      </apply>
     </list>
     <apply>
      <intersect></intersect>
      <ci>P</ci>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\mathbb{N},z\in cP\cap L\implies\exists x_{1},\ldots,x_{c}\in P\cap L
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Normal_polytope:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mi>c</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}+\cdots+x_{c}=z
  </annotation>
 </semantics>
</math>

.</p>

<p>The normality property is <a href="invariant_(mathematics)" title="wikilink">invariant</a> under affine-lattice <a href="isomorphism" title="wikilink">isomorphisms</a> of lattice polytopes and the integrally closed property is invariant under an affine change of coordinates. Note sometimes in combinatorial literature the difference between normal and integrally closed is blurred.</p>
<h2 id="examples">Examples</h2>

<p>The <a class="uri" href="simplex" title="wikilink">simplex</a> in <strong>R</strong><sup><em>k</em></sup> with the vertices at the origin and along the unit coordinate vectors is normal. <a href="unimodular_simplex" title="wikilink">unimodular simplices</a> are the smallest polytope in the world of normal polytopes. After unimodular simplices, lattice parallelepipeds are the simplest normal polytopes.</p>

<p>For any lattice polytope P and 

<math display="inline" id="Normal_polytope:5">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi mathvariant="normal">∈</mi>
   <mi mathvariant="normal">ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>normal-∈</ci>
    <ci>normal-ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c∈ℕ
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Normal_polytope:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mi mathvariant="normal">≥</mi>
    <mi>d</mi>
    <mi>i</mi>
    <mi>m</mi>
    <mi>P</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>normal-≥</ci>
     <ci>d</ci>
     <ci>i</ci>
     <ci>m</ci>
     <ci>P</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c≥dimP-1
  </annotation>
 </semantics>
</math>


 cP is normal.</p>

<p>All <a class="uri" href="polygons" title="wikilink">polygons</a> or two-dimensional polytopes are normal.</p>

<p>If <em>A</em> is a <a href="Unimodular_matrix" title="wikilink">totally unimodular matrix</a>, then the convex hull of the column vectors in <em>A</em> is a normal polytope.</p>

<p>The <a href="Birkhoff_polytope" title="wikilink">Birkhoff polytope</a> is normal. This can easily be proved using <a href="Hall's_marriage_theorem" title="wikilink">Hall's marriage theorem</a>. In fact, the Birkhoff polytope is compressed, which is a much stronger statement.</p>

<p>All order polytopes are known to be compressed. This implies that these polytopes are normal. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="properties">Properties</h2>
<ul>
<li>A lattice polytope is integrally closed if and only if it is normal and <em>L</em> is a direct summand of ℤ<sup><em>d</em></sup>.</li>
<li>A normal polytope can be made into a full-dimensional integrally closed polytope by changing the lattice of reference from ℤ<sup><em>d</em></sup> to <em>L</em> and the <a href="ambient_space" title="wikilink">ambient</a> <a href="Euclidean_space" title="wikilink">Euclidean space</a> ℝ<sup><em>d</em></sup> to the subspace ℝL.</li>
<li>If a lattice polytope can be subdivided into normal polytopes then it is normal as well.</li>
<li>If a lattice polytope in dimension <em>d</em> has lattice lengths greater than or equal to 4<em>d</em>(<em>d</em> + 1) then the polytope is normal.</li>
<li>If <em>P</em> is normal and <em>φ</em>:ℝ<sup><em>d</em></sup> → ℝ<sup><em>d</em></sup> is an affine map with φ(ℤ<sup><em>d</em></sup>) = ℤ<sup><em>d</em></sup> then <em>φ</em>(<em>P</em>) is normal.</li>
<li>Every <em>k</em>-dimensional face of a normal polytope is normal.</li>
</ul>
<dl>
<dt>Proposition:</dt>
</dl>

<p><strong>P</strong> ⊂ ℝ<sup><em>d</em></sup> a lattice polytope. Let C(<strong>P</strong>)=ℝ<sub>+</sub>(<strong>P</strong>,1) ⊂ ℝ<sup><em>d</em>+1</sup> the following are equivalent:</p>
<ol>
<li><strong>P</strong> is normal.</li>
<li>The <a href="Hilbert_basis" title="wikilink">Hilbert basis</a> of C(<strong>P</strong>) ∩ ℤ<sup><em>d</em>+1</sup> = (<strong>P</strong>,1) ∩ ℤ<sup><em>d</em>+1</sup></li>
</ol>

<p>Conversely, for a full dimensional <a href="rational_pointed_cone" title="wikilink">rational pointed cone</a> <strong>C</strong>⊂ℝ<sup>d</sup> if the Hilbert basis of <strong>C</strong>∩ℤ<sup>d</sup> is in a <a class="uri" href="hyperplane" title="wikilink">hyperplane</a> <strong>H</strong> ⊂ ℝ<sup><em>d</em></sup> (dim <strong>H</strong> = <em>d</em> − 1). Then <strong>C</strong> ∩ <strong>H</strong> is a normal polytope of dimension <em>d</em> − 1.</p>
<h2 id="relation-to-normal-monoids">Relation to normal monoids</h2>

<p>Any <a class="uri" href="cancellative" title="wikilink">cancellative</a> <a class="uri" href="commutative" title="wikilink">commutative</a> <a class="uri" href="monoid" title="wikilink">monoid</a> <em>M</em> can be embedded into an <a href="abelian_group" title="wikilink">abelian group</a>. More precisely, the canonical map from <em>M</em> into its <a href="Grothendieck_group" title="wikilink">Grothendieck group</a> <em>K</em>(<em>M</em>) is an embedding. Define the <strong>normalization</strong> of <em>M</em> to be the set</p>

<p>

<math display="block" id="Normal_polytope:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mi>x</mi>
      </mrow>
      <mo>∈</mo>
      <mi>M</mi>
     </mrow>
     <mo rspace="7.5pt">,</mo>
     <mrow>
      <mi>n</mi>
      <mo>∈</mo>
      <mi>ℕ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>x</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <in></in>
      <ci>n</ci>
      <ci>ℕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\in K(M)\mid nx\in M,\ n\in\mathbb{N}\},
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>nx</em> here means <em>x</em> added to itself <em>n</em> times. If <em>M</em> is equal to its normalization, then we say that <em>M</em> is a <strong>normal monoid</strong>. For example, the monoid <strong>N</strong><sup><em>n</em></sup> consisting of <em>n</em>-tuples of natural numbers is a normal monoid, with the Grothendieck group <strong>Z</strong><sup><em>n</em></sup>.</p>

<p>For a polytope <em>P</em>  ⊆ <strong>R</strong><sup>k</sup>, lift <em>P</em> into <strong>R</strong><sup><em>k</em>+1</sup> so that it lies in the hyperplane <em>x</em><sub>k+1</sub> = 1, and let <em>C</em>(<em>P</em>) be the set of all linear combinations with nonnegative coefficients of points in (<em>P</em>,1). Then <em>C</em>(<em>P</em>) is a <a href="convex_cone" title="wikilink">convex cone</a>,</p>

<p>

<math display="block" id="Normal_polytope:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mtext>𝐱</mtext>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mtext>𝐱</mtext>
         <mi>n</mi>
        </msub>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <msub>
        <mtext>𝐱</mtext>
        <mi>i</mi>
       </msub>
       <mo>∈</mo>
       <mi>P</mi>
      </mrow>
      <mo rspace="7.5pt">,</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>λ</mi>
         <mi>i</mi>
        </msub>
        <mo>∈</mo>
        <mi>ℝ</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>λ</mi>
         <mi>i</mi>
        </msub>
        <mo>≥</mo>
        <mn>0</mn>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <mtext>x</mtext>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">1</cn>
       </interval>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>n</ci>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <mtext>x</mtext>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </interval>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>x</mtext>
        <ci>i</ci>
       </apply>
       <ci>P</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>i</ci>
        </apply>
        <ci>ℝ</ci>
       </apply>
       <apply>
        <geq></geq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(P)=\{\lambda_{1}(\textbf{x}_{1},1)+\cdots+\lambda_{n}(\textbf{x}_{n},1)\mid%
\textbf{x}_{i}\in P,\ \lambda_{i}\in\mathbb{R},\lambda_{i}\geq 0\}.
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>P</em> is a convex lattice polytope, then it follows from <a href="Gordan's_lemma" title="wikilink">Gordan's lemma</a> that the intersection of <em>C</em>(<em>P</em>) with the lattice <strong>Z</strong><sup><em>k</em>+1</sup> is a finitely generated (commutative, cancellative) monoid. One can prove that <em>P</em> is a normal polytope if and only if this monoid is normal.</p>
<h2 id="open-problem">Open problem</h2>

<p><strong>Oda's question:</strong> <em>Are all smooth polytopes integrally closed?</em> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>A lattice polytope is smooth if the primitive edge vectors at every vertex of the polytope define a part of a basis of ℤ<sup><em>d</em></sup>. So far, every smooth polytope that has been found has a regular unimodular triangulation. It is known that up to trivial equivalences, there are only a finite number of smooth <em>d</em>-dimensional polytopes with 

<math display="inline" id="Normal_polytope:9">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 lattice points, for each natural number <em>n</em> and <em>d</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Convex_cone" title="wikilink">Convex cone</a></li>
<li><a href="Algebraic_geometry" title="wikilink">Algebraic geometry</a></li>
<li><a href="Number_theory" title="wikilink">Number theory</a></li>
<li><a href="Ring_theory" title="wikilink">Ring theory</a></li>
<li><a href="Ehrhart_polynomial" title="wikilink">Ehrhart polynomial</a></li>
<li><a href="Rational_cone" title="wikilink">Rational cone</a></li>
<li><a href="Toric_ring" title="wikilink">Toric ring</a></li>
<li><a href="Toric_variety" title="wikilink">Toric variety</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Ezra Miller, <a href="Bernd_Sturmfels" title="wikilink">Bernd Sturmfels</a>, <em>Combinatorial commutative algebra</em>. Graduate Texts in Mathematics, 227. Springer-Verlag, New York, 2005. xiv+417 pp. ISBN 0-387-22356-8</li>
<li>Winfried Bruns, Joseph Gubeladze, preprint. <a href="http://math.sfsu.edu/gubeladze/publications/kripo/kripo.pdf">Polytopes, rings and K-theory</a></li>
<li>W. Bruns, J. Gubeladze and N. V. Trung, Normal polytopes, triangulations, and Koszul algebras, J. Reine. Angew. Math. 485 (1997), 123–160.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Polytopes" title="wikilink">Category:Polytopes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Tadao Oda, Convex bodies and algebraic geometry<a href="#fnref2">↩</a></li>
<li id="fn3">arXiv:1010.3887<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
