<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="924">Maze generation algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Maze generation algorithm</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Maze generation <a href="algorithm" title="wikilink">algorithms</a></strong> are automated methods for the creation of <a href="maze" title="wikilink">mazes</a>.</p>
<figure><b>(Figure)</b>
<figcaption>This maze generated by modified version of <a href="Prim's_algorithm" title="wikilink">Prim's algorithm</a>, below.</figcaption>
</figure>
<h2 id="graph-theory-based-methods">Graph theory based methods</h2>
<figure><b>(Figure)</b>
<figcaption>Animation of Graph theory based method</figcaption>
</figure>

<p>A maze can be generated by starting with a predetermined arrangement of cells (most commonly a rectangular grid but other arrangements are possible) with wall sites between them. This predetermined arrangement can be considered as a <a href="connected_graph" title="wikilink">connected graph</a> with the edges representing possible wall sites and the nodes representing cells. The purpose of the maze generation algorithm can then be considered to be making a subgraph in which it is challenging to find a route between two particular nodes.</p>

<p>If the subgraph is not <a href="connected_graph" title="wikilink">connected</a>, then there are regions of the graph that are wasted because they do not contribute to the search space. If the graph contains loops, then there may be multiple paths between the chosen nodes. Because of this, maze generation is often approached as generating a random <a href="spanning_tree_(mathematics)" title="wikilink">spanning tree</a>. Loops which can confound naive maze solvers may be introduced by adding random edges to the result during the course of the algorithm.</p>

<p>The animation shows the maze generation steps for a graph that is not on a rectangular grid. First, the computer creates a random <a href="planar_graph" title="wikilink">planar graph</a> G shown in blue, and its <a href="Dual_graph" title="wikilink">dual</a> F shown in yellow. Second, computer traverses F using a chosen algorithm, such as a depth-first search, coloring the path red. During the traversal, whenever a red edge crosses over a blue edge, the blue edge is removed. Finally, when all vertices of F have been visited, F is erased and two edges from G, one for the entrance and one for the exit, are removed.</p>
<h3 id="depth-first-search">Depth-first search</h3>
<figure><b>(Figure)</b>
<embed src="Depth-First Search Animation.ogv" title="Animation of generator's thinking process using Depth-First Search"></embed><figcaption>Animation of generator's thinking process using Depth-First Search</figcaption>
</figure>

<p>This algorithm is a randomized version of the <a href="depth-first_search" title="wikilink">depth-first search</a> algorithm. Frequently implemented with a stack, this approach is one of the simplest ways to generate a maze using a computer. Consider the space for a maze being a large grid of cells (like a large chess board), each cell starting with four walls. Starting from a random cell, the computer then selects a random neighbouring cell that has not yet been visited. The computer removes the 'wall' between the two cells and adds the new cell to a stack (this is analogous to drawing the line on the floor). The computer continues this process, with a cell that has no unvisited neighbours being considered a dead-end. When at a dead-end it backtracks through the path until it reaches a cell with an unvisited neighbour, continuing the path generation by visiting this new, unvisited cell (creating a new junction). This process continues until every cell has been visited, causing the computer to backtrack all the way back to the beginning cell. This approach guarantees that the maze space is completely visited.</p>

<p>As stated, the algorithm is very simple and does not produce over-complex mazes. More specific refinements to the algorithm can help to generate mazes that are harder to solve.</p>
<ol>
<li>Start at a particular cell and call it the "exit."</li>
<li>Mark the current cell as visited, and get a list of its neighbors. For each neighbor, starting with a randomly selected neighbor:
<ol>
<li>If that neighbor hasn't been visited, remove the wall between this cell and that neighbor, and then <a href="recursion" title="wikilink">recur</a> with that neighbor as the current cell.</li>
</ol></li>
</ol>

<p>As given above this algorithm involves deep recursion which may cause stack overflow issues on some computer architectures. The algorithm can be rearranged into a loop by storing backtracking information in the maze itself. This also provides a quick way to display a solution, by starting at any given point and backtracking to the exit.</p>
<figure><b>(Figure)</b>
<figcaption>Horizontal Passage Bias</figcaption>
</figure>

<p>Mazes generated with a depth-first search have a low branching factor and contain many long corridors, because the algorithm explores as far as possible along each branch before backtracking.</p>

<p>To add difficulty and a fun factor to depth-first search generated mazes, you can influence the likelihood of which neighbor you should visit, instead of it being completely random. By making it more likely to visit neighbors to your sides, you can have a more horizontal maze generation. Experimenting with directional passage "bias" in certain places could lead to creating fun designs, such as a checkerboard pattern, an X, and more.</p>
<h3 id="recursive-backtracker">Recursive backtracker</h3>

<p>The depth-first search algorithm of maze generation is frequently implemented using <a class="uri" href="backtracking" title="wikilink">backtracking</a>:</p>
<ol>
<li>Make the initial cell the current cell and mark it as visited</li>
<li>While there are unvisited cells
<ol>
<li>If the current cell has any neighbours which have not been visited
<ol>
<li>Choose randomly one of the unvisited neighbours</li>
<li>Push the current cell to the stack</li>
<li>Remove the wall between the current cell and the chosen cell</li>
<li>Make the chosen cell the current cell and mark it as visited</li>
</ol></li>
<li>Else if stack is not empty
<ol>
<li>Pop a cell from the stack</li>
<li>Make it the current cell</li>
</ol></li>
<li>Else
<ol>
<li>Pick a random unvisited cell, make it the current cell and mark it as visited</li>
</ol></li>
</ol></li>
</ol>
<h3 id="randomized-kruskals-algorithm">Randomized Kruskal's algorithm</h3>

<p><embed src="KruskalGeneratedMaze.webm" title="fig:An animation of generating a 30 by 20 maze using Kruskal's algorithm."></embed> This algorithm is a randomized version of <a href="Kruskal's_algorithm" title="wikilink">Kruskal's algorithm</a>.</p>
<ol>
<li>Create a list of all walls, and create a set for each cell, each containing just that one cell.</li>
<li>For each wall, in some random order:
<ol>
<li>If the cells divided by this wall belong to distinct sets:
<ol>
<li>Remove the current wall.</li>
<li>Join the sets of the formerly divided cells.</li>
</ol></li>
</ol></li>
</ol>

<p>There are several data structures that can be used to model the sets of cells. An efficient implementation using a <a href="disjoint-set_data_structure" title="wikilink">disjoint-set data structure</a> can perform each union and find operation on two sets in nearly constant <a href="amortized_time" title="wikilink">amortized time</a> (specifically, 

<math display="inline" id="Maze_generation_algorithm:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>α</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\alpha(V))
  </annotation>
 </semantics>
</math>

 time; 

<math display="inline" id="Maze_generation_algorithm:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(x)<5
  </annotation>
 </semantics>
</math>

 for any plausible value of 

<math display="inline" id="Maze_generation_algorithm:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

), so the running time of this algorithm is essentially proportional to the number of walls available to the maze.</p>

<p>It matters little whether the list of walls is initially randomized or if a wall is randomly chosen from a nonrandom list, either way is just as easy to code.</p>

<p>Because the effect of this algorithm is to produce a minimal spanning tree from a graph with equally weighted edges, it tends to produce regular patterns which are fairly easy to solve.</p>
<h3 id="randomized-prims-algorithm">Randomized Prim's algorithm</h3>

<p><a href="File:MAZE_30x20_Prim.ogv" title="wikilink">thumb|upright=1.6|An animation of generating a 30 by 20 maze using Prim's algorithm.</a> This algorithm is a randomized version of <a href="Prim's_algorithm" title="wikilink">Prim's algorithm</a>.</p>
<ol>
<li>Start with a grid full of walls.</li>
<li>Pick a cell, mark it as part of the maze. Add the walls of the cell to the wall list.</li>
<li>While there are walls in the list:
<ol>
<li>Pick a random wall from the list. If the cell on the opposite side isn't in the maze yet:
<ol>
<li>Make the wall a passage and mark the cell on the opposite side as part of the maze.</li>
<li>Add the neighboring walls of the cell to the wall list.</li>
</ol></li>
<li>Remove the wall from the list.</li>
</ol></li>
</ol>

<p>It will usually be relatively easy to find the way to the starting cell, but hard to find the way anywhere else.</p>

<p>Note that simply running classical Prim's on a graph with random edge weights would create mazes stylistically identical to Kruskal's, because they are both minimal spanning tree algorithms. Instead, this algorithm introduces stylistic variation because the edges closer to the starting point have a lower effective weight.</p>
<h4 id="modified-version">Modified version</h4>

<p>Although the classical Prim's algorithm keeps a list of edges, for maze generation we could instead maintain a list of adjacent cells. If the randomly chosen cell has multiple edges that connect it to the existing maze, select one of these edges at random. This will tend to branch slightly more than the edge-based version above.</p>
<h2 id="recursive-division-method">Recursive division method</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Illustration of Recursive Division</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>original chamber</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Chamber.png</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>Mazes can be created with <em>recursive division</em>, an algorithm which works as follows: Begin with the maze's space with no walls. Call this a chamber. Divide the chamber with a randomly positioned wall (or multiple walls) where each wall contains a randomly positioned passage opening within it. Then recursively repeat the process on the subchambers until all chambers are minimum sized. This method results in mazes with long straight walls crossing their space, making it easier to see which areas to avoid.</p>

<p>For example, in a rectangular maze, build at random points two walls that are perpendicular to each other. These two walls divide the large chamber into four smaller chambers separated by four walls. Choose three of the four walls at random, and open a one cell-wide hole at a random point in each of the three. Continue in this manner recursively, until every chamber has a width of one cell in either of the two directions. </p>
<h2 id="simple-algorithms">Simple algorithms</h2>

<p> Other algorithms exist that require only enough memory to store one line of a 2D maze or one plane of a 3D maze. They prevent loops by storing which cells in the current line are connected through cells in the previous lines, and never remove walls between any two cells already connected.</p>

<p>Most maze generation algorithms require maintaining relationships between cells within it, to ensure the end result will be solvable. Valid simply connected mazes can however be generated by focusing on each cell independently. A binary tree maze is a standard orthogonal maze where each cell always has a passage leading up or leading left, but never both. To create a binary tree maze, for each cell flip a coin to decide whether to add a passage leading up or left. Always pick the same direction for cells on the boundary, and the end result will be a valid simply connected maze that looks like a <a href="binary_tree" title="wikilink">binary tree</a>, with the upper left corner its root.</p>

<p>A related form of flipping a coin for each cell is to create an image using a random mix of forward slash and backslash characters. This doesn't generate a valid simply connected maze, but rather a selection of closed loops and unicursal passages. (The manual for the <a href="Commodore_64" title="wikilink">Commodore 64</a> presents a BASIC program using this algorithm, but using <a class="uri" href="PETSCII" title="wikilink">PETSCII</a> diagonal line graphic characters instead for a smoother graphic appearance.)</p>
<h2 id="cellular-automaton-algorithms">Cellular automaton algorithms</h2>

<p>Certain types of <a href="cellular_automata" title="wikilink">cellular automata</a> can be used to generate mazes.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Two well-known such cellular automata, Maze and Mazectric, have rulestrings B3/S12345 and B3/S1234.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In the former, this means that cells survive from one generation to the next if they have at least one and at most five <a href="Moore_neighbourhood" title="wikilink">neighbours</a>. In the latter, this means that cells survive if they have one to four neighbours. If a cell has exactly three neighbours, it is born. It is similar to <a href="Conway's_Game_of_Life" title="wikilink">Conway's Game of Life</a> in that patterns that do not have a living cell adjacent to 1, 4, or 5 other living cells in any generation will behave identically to it.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> However, for large patterns, it behaves very differently.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>For a random starting pattern, these maze-generating cellular automata will evolve into complex mazes with well-defined walls outlining corridors. Mazecetric, which has the rule B3/S1234 has a tendency to generate longer and straighter corridors compared with Maze, with the rule B3/S12345.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Since these cellular automaton rules are <a class="uri" href="deterministic" title="wikilink">deterministic</a>, each maze generated is uniquely determined by its random starting pattern. This is a significant drawback since the mazes tend to be relatively predictable.</p>

<p>Like some of the graph-theory based methods described above, these cellular automata typically generate mazes from a single starting pattern; hence it will usually be relatively easy to find the way to the starting cell, but harder to find the way anywhere else.</p>
<h2 id="python-code-example">Python code example</h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy
<span class="im">from</span> numpy.random <span class="im">import</span> random_integers <span class="im">as</span> rand
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> pyplot

<span class="kw">def</span> maze(width<span class="op">=</span><span class="dv">81</span>, height<span class="op">=</span><span class="dv">51</span>, complexity<span class="op">=</span>.<span class="dv">75</span>, density<span class="op">=</span>.<span class="dv">75</span>):
    <span class="co"># Only odd shapes</span>
    shape <span class="op">=</span> ((height <span class="op">//</span> <span class="dv">2</span>) <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>, (width <span class="op">//</span> <span class="dv">2</span>) <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>)
    <span class="co"># Adjust complexity and density relative to maze size</span>
    complexity <span class="op">=</span> <span class="bu">int</span>(complexity <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (shape[<span class="dv">0</span>] <span class="op">+</span> shape[<span class="dv">1</span>])))
    density    <span class="op">=</span> <span class="bu">int</span>(density <span class="op">*</span> (shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span> <span class="op">*</span> shape[<span class="dv">1</span>] <span class="op">//</span> <span class="dv">2</span>))
    <span class="co"># Build actual maze</span>
    Z <span class="op">=</span> numpy.zeros(shape, dtype<span class="op">=</span><span class="bu">bool</span>)
    <span class="co"># Fill borders</span>
    Z[<span class="dv">0</span>, :] <span class="op">=</span> Z[<span class="op">-</span><span class="dv">1</span>, :] <span class="op">=</span> <span class="dv">1</span>
    Z[:, <span class="dv">0</span>] <span class="op">=</span> Z[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>
    <span class="co"># Make aisles</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(density):
        x, y <span class="op">=</span> rand(<span class="dv">0</span>, shape[<span class="dv">1</span>] <span class="op">//</span> <span class="dv">2</span>) <span class="op">*</span> <span class="dv">2</span>, rand(<span class="dv">0</span>, shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>) <span class="op">*</span> <span class="dv">2</span>
        Z[y, x] <span class="op">=</span> <span class="dv">1</span>
        <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(complexity):
            neighbours <span class="op">=</span> []
            <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">1</span>:             neighbours.append((y, x <span class="op">-</span> <span class="dv">2</span>))
            <span class="cf">if</span> x <span class="op">&lt;</span> shape[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">2</span>:  neighbours.append((y, x <span class="op">+</span> <span class="dv">2</span>))
            <span class="cf">if</span> y <span class="op">&gt;</span> <span class="dv">1</span>:             neighbours.append((y <span class="op">-</span> <span class="dv">2</span>, x))
            <span class="cf">if</span> y <span class="op">&lt;</span> shape[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">2</span>:  neighbours.append((y <span class="op">+</span> <span class="dv">2</span>, x))
            <span class="cf">if</span> <span class="bu">len</span>(neighbours):
                y_,x_ <span class="op">=</span> neighbours[rand(<span class="dv">0</span>, <span class="bu">len</span>(neighbours) <span class="op">-</span> <span class="dv">1</span>)]
                <span class="cf">if</span> Z[y_, x_] <span class="op">==</span> <span class="dv">0</span>:
                    Z[y_, x_] <span class="op">=</span> <span class="dv">1</span>
                    Z[y_ <span class="op">+</span> (y <span class="op">-</span> y_) <span class="op">//</span> <span class="dv">2</span>, x_ <span class="op">+</span> (x <span class="op">-</span> x_) <span class="op">//</span> <span class="dv">2</span>] <span class="op">=</span> <span class="dv">1</span>
                    x, y <span class="op">=</span> x_, y_
    <span class="cf">return</span> Z

pyplot.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))
pyplot.imshow(maze(<span class="dv">80</span>, <span class="dv">40</span>), cmap<span class="op">=</span>pyplot.cm.binary, interpolation<span class="op">=</span><span class="st">'nearest'</span>)
pyplot.xticks([]), pyplot.yticks([])
pyplot.show()</code></pre></div>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Maze_solving_algorithm" title="wikilink">Maze solving algorithm</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.astrolog.org/labyrnth/algrithm.htm#perfect">Think Labyrinth: Maze algorithms</a> (details on these and other maze generation algorithms)</li>
<li><a href="http://www.jamisbuck.org/presentations/rubyconf2011/index.html">Jamis Buck: HTML 5 Presentation with Demos of Maze generation Algorithms</a></li>
<li><a href="http://www.martinfoltin.sk/mazes">Maze Generation</a> - Master's Thesis (Java Applet enabling users to have a maze created using various algorithms and human solving of mazes)</li>
<li><a href="http://totologic.blogspot.com/2013/04/maze-generation-in-3d.html">Maze generation and navigation in 3D</a></li>
<li><a href="http://totologic.blogspot.com/2014/09/triangulated-circular-maze-generation.html">Triangulated circular maze generation</a> with Daedalus Lib</li>
<li><a href="http://rosettacode.org/wiki/Maze">Collection of maze generation code</a> in different languages in Rosetta Code</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Mazes" title="wikilink">Category:Mazes</a> <a class="uri" href="Category:Algorithms" title="wikilink">Category:Algorithms</a> <a href="Category:Random_graphs" title="wikilink">Category:Random graphs</a> <a href="Category:Articles_with_example_Python_code" title="wikilink">Category:Articles with example Python code</a> <a href="Category:Articles_containing_video_clips" title="wikilink">Category:Articles containing video clips</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
</ol>
</section>
</body>

