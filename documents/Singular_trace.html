<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="389">Singular trace</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Singular trace</h1>
<hr/>

<p>In mathematics, a <strong>singular trace</strong> is a <a href="Von_Neumann_algebra#Weights,_states,_and_traces" title="wikilink">trace</a> on a space of <a href="linear_operators" title="wikilink">linear operators</a> of a separable <a href="Hilbert_space" title="wikilink">Hilbert space</a> that vanishes on operators of <a href="finite-rank_operator" title="wikilink">finite rank</a>. Singular traces are a feature of infinite-dimensional Hilbert spaces such as the space of <a href="Lp_space#The_p-norm_in_countably_infinite_dimensions" title="wikilink">square-summable sequences</a> and spaces of <a href="Hilbert_space#Examples" title="wikilink">square-integrable functions</a>. Linear operators on a finite-dimensional Hilbert space have only the zero functional as a singular trace since all operators have finite rank. For example, <a href="matrix_ring" title="wikilink">matrix algebras</a> have no non-trivial singular traces and the <a href="Trace_(linear_algebra)" title="wikilink">matrix trace</a> is the unique trace up to scaling.</p>

<p>American mathematician Gary Weiss and, later, British mathematician <a href="Nigel_Kalton" title="wikilink">Nigel Kalton</a> observed in the infinite-dimensional case that there are non-trivial singular traces on the ideal of <a href="Trace_class" title="wikilink">trace class operators</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Therefore, in distinction to the finite-dimensional case, in infinite dimensions the canonical <a href="trace_class#Definition" title="wikilink">operator trace</a> is not the unique trace up to scaling. The operator trace is the continuous extension of the matrix trace from finite rank operators to all trace class operators, and the term singular derives from the fact that a singular trace vanishes where the matrix trace is supported, analogous to a <a href="singular_measure" title="wikilink">singular measure</a> vanishing where Lebesgue measure is supported.</p>

<p>Singular traces measure the asymptotic spectral behaviour of operators and have found applications in the <a href="noncommutative_geometry" title="wikilink">noncommutative geometry</a> of French mathematician <a href="Alain_Connes" title="wikilink">Alain Connes</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In heurestic terms, a singular trace corresponds to a way of summing numbers <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, ... that is completely orthogonal or 'singular' with respect to the usual sum <em>a</em><sub>1</sub> + <em>a</em><sub>2</sub> + <em>a</em><sub>3</sub> + ... . This allows mathematicians to sum sequences like the <a href="harmonic_series_(mathematics)" title="wikilink">harmonic sequence</a> (and operators with similar spectral behaviour) that are divergent for the usual <a href="summation" title="wikilink">sum</a>. In similar terms a (noncommutative) <a href="measure_theory" title="wikilink">measure theory</a> or <a class="uri" href="probability" title="wikilink">probability</a> theory can be built for distributions like the <a href="Cauchy_distribution" title="wikilink">Cauchy distribution</a> (and operators with similar spectral behaviour) that do not have finite expectation in the usual sense.</p>
<h2 id="origin">Origin</h2>

<p>By 1950 French mathematician <a href="Jacques_Dixmier" title="wikilink">Jacques Dixmier</a>, a founder of the semifinite theory of <a href="von_Neumann_algebra" title="wikilink">von Neumann algebras</a>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> thought that a trace on the bounded operators of a separable Hilbert space would automatically be normal up to some trivial counterexamples.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Over the course of 15 years Dixmier, aided by a suggestion of Nachman Aronszajn and inequalities proved by Joseph Hersch, developed an example of a non-trivial yet non-normal trace on <a href="weak_trace-class_operator" title="wikilink">weak trace-class operators</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> disproving his earlier view. Singular traces based on Dixmier's construction are called <a href="Dixmier_trace" title="wikilink">Dixmier traces</a>.</p>

<p>Independently and by different methods, German mathematician <a href=":de:Albrecht_Pietsch" title="wikilink">Albrecht Pietsch (de)</a> investigated traces on ideals of operators on Banach spaces.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In 1987 Nigel Kalton answered a question of Piestch by showing that the operator trace is not the unique trace on quasi-normed proper subideals of the trace-class operators on a Hilbert space.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> József Varga independently studied a similar question.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> To solve the question of uniqueness of the trace on the full ideal of trace-class operators, Kalton developed a spectral condition for the <a href="commutator_subspace" title="wikilink">commutator subspace</a> of trace class operators following on from results of Gary Weiss.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> A consequence of the results of Weiss and the spectral condition of Kalton was the existence of non-trivial singular traces on trace class operators .<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Also independently, and from a different direction, Mariusz Wodzicki investigated the <a href="noncommutative_residue" title="wikilink">noncommutative residue</a>, a trace on classical pseudo-differential operators on a compact manifold that vanishes on trace class pseudo-differential operators of order less than the negative of the dimension of the manifold.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="definition">Definition</h2>

<p>A trace φ on a two-sided ideal <em>J</em> of the bounded linear operators <em>B</em>(<em>H</em>) on a separable Hilbert space <em>H</em> is a linear functional φ:<em>J</em> → ℂ such that φ(<em>AB</em>) = φ(<em>BA</em>) for all operators <em>A</em> from <em>J</em> and <em>B</em> from <em>B</em>(<em>H</em>). That is, a trace is a linear functional on <em>J</em> that vanishes on the <a href="commutator_subspace" title="wikilink">commutator subspace</a> Com(<em>J</em>) of <em>J</em>.</p>

<p>A trace φ is <em>singular</em> if <em>φ</em>(<em>A</em>) = 0 for every <em>A</em> from the subideal of finite rank operators <em>F</em>(<em>H</em>) within <em>J</em>.</p>
<h2 id="existence-and-characterisation">Existence and characterisation</h2>

<p>Singular traces are characterised by the spectral <a href="Calkin_correspondence" title="wikilink">Calkin correspondence</a> between two-sided ideals of bounded operators on Hilbert space and rearrangement invariant sequence spaces. Using the spectral characterisation of the <a href="commutator_subspace" title="wikilink">commutator subspace</a> due to Ken Dykema, Tadeusz Figiel, Gary Weiss and Mariusz Wodzicki,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> to every trace φ on a two-sided ideal <em>J</em> there is a unique <a href="symmetric_functional" title="wikilink">symmetric functional</a> <em>f</em> on the corresponding Calkin sequence space <em>j</em> such that</p>

<p>for every positive operator <em>A</em> belonging to <em>J</em>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Here μ: <em>J</em><sub>+</sub> → <em>j</em><sub>+</sub> is the map from a positive operator to its <a href="singular_value" title="wikilink">singular values</a>. A singular trace φ corresponds to a symmetric functional <em>f</em> on the sequence space <em>j</em> that vanishes on <em>c</em><sub>00</sub>, the sequences with finite non-zero terms.</p>

<p>The characterisation parallels the construction of the usual <a href="trace_class#Definition" title="wikilink">operator trace</a> where</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>Tr</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>μ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Tr</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>μ</ci>
       <interval closure="open">
        <ci>n</ci>
        <ci>A</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <ci>μ</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Tr}(A)=\sum_{n=0}^{\infty}\mu(n,A)=\sum\left(\mu(A)\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>for <em>A</em> a positive trace class operator. The trace class operators and the sequence space of <a href="Lp_space" title="wikilink">summable sequences</a> are in Calkin correspondence and the sum ∑ is a symmetric functional on the space of summable sequences.</p>
<h3 id="existence">Existence</h3>

<p>A non-zero trace φ exists on a two-sided ideal <em>J</em> of operators on a separable Hilbert space if the co-dimension of its <a href="commutator_subspace" title="wikilink">commutator subspace</a> is not zero. There are ideals that admit infinitely many linearly independent non-zero singular traces. For example, the commutator subspace of the ideal of <a href="weak_trace-class_operator" title="wikilink">weak trace-class operators</a> contains the ideal of trace class operators and every positive operator in the commutator subspace of the weak trace class is trace class.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Consequently, every trace on the weak trace class ideal is singular and the co-dimension of the weak trace class ideal commutator subspace is infinite.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Not all of the singular traces on the weak trace class ideal are Dixmier traces.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h3 id="lidskii-formulation">Lidskii formulation</h3>

<p>The trace of a square matrix is the sum of its eigenvalues. <a href="Trace_class" title="wikilink">Lidskii's formula</a> extends this result to functional analysis and states that the trace of a trace class operator <em>A</em> is given by the sum of its eigenvalues,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Tr</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Tr</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <interval closure="open">
        <ci>n</ci>
        <ci>A</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Tr}(A)=\sum_{n=0}^{\infty}\lambda(n,A)=\sum(\lambda(A)).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The characterisation () of a trace φ on positive operators of a two-ideal <em>J</em> as a symmetric functional applied to singular values can be improved to the statement that the trace φ on any operator in <em>J</em> is given by the same symmetric functional applied to <a href="eigenvalue" title="wikilink">eigenvalue sequences</a>, provided that the eigenvalues of all operators in <em>J</em> belong to the Calkin sequence space <em>j</em>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> In particular, if a bounded operator <em>A</em> belongs to <em>J</em> whenever there is a bounded operator <em>B</em> in <em>J</em> such that</p>

<p>for every natural number <em>n</em>, then for each trace φ on <em>J</em> there is a unique symmetric functional <em>f</em> on the Calkin space <em>j</em> with</p>

<p>where λ(<em>A</em>) is the sequence of eigenvalues of an operator <em>A</em> in <em>J</em> rearranged so that the absolute value of the eigenvalues is decreasing. If <em>A</em> is <a href="nilpotent_operator" title="wikilink">quasi-nilpotent</a> then λ(<em>A</em>) is the zero sequence. Most two-sided ideals satisfy the property (), including all Banach ideals and quasi-Banach ideals.</p>

<p>Equation () is the precise statement that singular traces measure asymptotic spectral behaviour of operators.</p>
<h3 id="fredholm-formulation">Fredholm formulation</h3>

<p>The trace of a square matrix is the sum of its diagonal elements. In functional analysis the corresponding formula for trace class operators is</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>Tr</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>A</mi>
      <msub>
       <mi>e</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>e</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mrow>
         <mi>A</mi>
         <msub>
          <mi>e</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>,</mo>
        <msub>
         <mi>e</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Tr</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <list>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>n</ci>
       </apply>
      </list>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <set>
         <list>
          <apply>
           <times></times>
           <ci>A</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>e</ci>
            <ci>n</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <ci>n</ci>
          </apply>
         </list>
        </set>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Tr}(A)=\sum_{n=0}^{\infty}\langle Ae_{n},e_{n}\rangle=\sum(\{\langle Ae_{%
n},e_{n}\rangle\}_{n=0}^{\infty})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where { <em>e</em><sub><em>n</em></sub> }<sub><em>n</em>=0</sub><sup>∞</sup> is an arbitrary <a href="orthonormal_basis" title="wikilink">orthonormal basis</a> of the separable Hilbert space <em>H</em>. Singular traces do not have an equivalent formulation for arbitrary bases. Only when φ(<em>A</em>)=0 will an operator <em>A</em> generally satisfy</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mrow>
         <mi>A</mi>
         <msub>
          <mi>e</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>,</mo>
        <msub>
         <mi>e</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <set>
        <list>
         <apply>
          <times></times>
          <ci>A</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <ci>n</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <ci>n</ci>
         </apply>
        </list>
       </set>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(A)={\rm f}(\{\langle Ae_{n},e_{n}\rangle\}_{n=0}^{\infty})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>for a singular trace φ and an arbitrary orthonormal basis { <em>e</em><sub><em>n</em></sub> }<sub><em>n</em>=0</sub><sup>∞</sup> .<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>The diagonal formulation is often used instead of the Lidskii formulation to calculate the trace of products, since eigenvalues of products are hard to determine. For example, in <a href="quantum_statistical_mechanics" title="wikilink">quantum statistical mechanics</a> the expectation of an observable <em>S</em> is calculated against a fixed trace-class energy density operator <em>T</em> by the formula</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>S</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Tr</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mi>S</mi>
       <msub>
        <mi>e</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>e</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mrow>
         <mi>S</mi>
         <msub>
          <mi>e</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo>,</mo>
        <msub>
         <mi>e</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>S</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Tr</ci>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <list>
        <apply>
         <times></times>
         <ci>S</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <ci>n</ci>
        </apply>
       </list>
       <ci>λ</ci>
       <interval closure="open">
        <ci>n</ci>
        <ci>T</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <set>
         <list>
          <apply>
           <times></times>
           <ci>S</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>e</ci>
            <ci>n</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <ci>n</ci>
          </apply>
         </list>
        </set>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle S\rangle={\rm Tr}(ST)=\sum_{n=0}^{\infty}\langle Se_{n},e_{n}\rangle%
\lambda(n,T)=v_{T}(\{\langle Se_{n},e_{n}\rangle\}_{n=0}^{\infty})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where <em>v</em><sub><em>T</em></sub> belongs to (<em>l</em><sub>∞</sub>)<sub>*</sub> ≅ <em>l</em><sub>1</sub>. The expectation is calculated from the expectation values ⟨<em>Se</em><sub><em>n</em></sub>, <em>e</em><sub><em>n</em></sub>⟩ and the probability ⟨<em>P</em><sub><em>n</em></sub>⟩ 

<math display="inline" id="Singular_trace:5">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 λ(<em>n</em>,<em>T</em>) of the system being in the bound quantum state <em>e</em><sub><em>n</em></sub>. Here <em>P</em><sub><em>n</em></sub> is the projection operator onto the one-dimensional subspace spanned by the energy <a class="uri" href="eigenstate" title="wikilink">eigenstate</a> <em>e</em><sub><em>n</em></sub>. The eigenvalues of the product, λ(<em>n</em>,<em>ST</em>), have no equivalent interpretation.</p>

<p>There are results for singular traces of products.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> For a product <em>ST</em> where <em>S</em> is bounded and <em>T</em> is <a class="uri" href="selfadjoint" title="wikilink">selfadjoint</a> and belongs to a two-sided ideal <em>J</em> then</p>
<dl>
<dd><dl>
<dd><math> \varphi(ST) = {\rm f}( \{ \langle S e_n , e_n \rangle \lambda(n,T) \}_{n=0}^\infty)
</math></dd>
</dl>
</dd>
</dl>
<h1 id="v_varphit-langle-s-e_n-e_n-rangle-_n">v_{\varphi,T}( \{ \langle S e_n , e_n \rangle \}_{n</h1>

<p>0}^\infty )  for any trace φ on <em>J</em>. The orthonormal basis { <em>e</em><sub><em>n</em></sub> }<sub><em>n</em>=0</sub><sup>∞</sup> must be ordered so that <em>Te</em><sub><em>n</em></sub> 

<math display="inline" id="Singular_trace:6">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 μ(<em>n</em>,<em>T</em>)<em>e</em><sub><em>n</em></sub>, <em>n</em>

<math display="inline" id="Singular_trace:7">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

0,1,2... . When φ is singular and φ(<em>T</em>)

<math display="inline" id="Singular_trace:8">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

1 then <em>v</em><sub><em>φ</em>,<em>T</em></sub> is a linear functional on <em>l</em><sub>∞</sub> that extends the <a href="limit_of_a_function" title="wikilink">limit at infinity</a> on the convergent sequences <em>c</em>. The expectation ⟨<em>S</em>⟩ 

<math display="inline" id="Singular_trace:9">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 φ(<em>ST</em>) in this case has the property that ⟨<em>P</em><sub><em>n</em></sub>⟩

<math display="inline" id="Singular_trace:10">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 0 for each <em>n</em>, or that there is no probability of being in a bound quantum state. That</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>S</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mtext>“limit at infinity”</mtext>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>S</mi>
      <msub>
       <mi>e</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>e</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>“limit at infinity”</mtext>
     <list>
      <apply>
       <times></times>
       <ci>S</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle S\rangle=\text{``limit at infinity''}\langle Se_{n},e_{n}\rangle
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>has led to a link between singular traces, the <a href="correspondence_principle" title="wikilink">correspondence principle</a>, and classical limits,.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="use-in-noncommutative-geometry">Use in noncommutative geometry</h2>

<p>The first application of singular traces was the <a href="noncommutative_residue" title="wikilink">noncommutative residue</a>, a trace on classical pseudo-differential operators on a compact manifold that vanishes on trace class pseudo-differential operators of order less than the negative of the dimension of the manifold, introduced Mariusz Wodzicki and Victor Guillemin independently .<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Alain Connes characterised the noncommutative residue within <a href="noncommutative_geometry" title="wikilink">noncommutative geometry</a>, Connes' generalisation of differential geometry, using Dixmier traces.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>An expectation involving a singular trace and non-trace class density is used in <a href="noncommutative_geometry" title="wikilink">noncommutative geometry</a>,  Here <em>S</em> is a bounded linear operator on the Hilbert space <em>L</em><sub>2</sub>(<em>X</em>) of square-integrable functions on a <em>d</em>-dimensional <a href="closed_manifold" title="wikilink">closed manifold</a> <em>X</em>, Tr<sub>ω</sub> is a Dixmier trace on the weak trace class ideal, and the density |<em>D</em>|<sup>−<em>d</em></sup> in the weak trace class ideal is the <em>d</em>th power of the 'line element' |<em>D</em>|<sup>−1</sup> where <em>D</em> is a <a href="Dirac_operator" title="wikilink">Dirac type operator</a> suitably normalised so that Tr<sub>ω</sub>(|<em>D</em>|<sup>−<em>d</em></sup>)

<math display="inline" id="Singular_trace:12">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

1.</p>

<p>The expectation (<mtpl><eqref>4<eqref></eqref></eqref></mtpl>) is an extension of the Lebesgue integral on the commutative algebra of essentially bounded functions acting by multiplication on <em>L</em><sub>2</sub>(<em>X</em>) to the full <em>noncommutative</em> algebra of bounded operators on <em>L</em><sub>2</sub>(<em>X</em>).<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> That is,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <msub>
      <mi>M</mi>
      <mi>f</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>X</mi>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <int></int>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int M_{f}=\int_{X}f(x)\,dx.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where <em>dx</em> is the <a href="volume_form" title="wikilink">volume form</a> on <em>X</em>, <em>f</em> is an essentially bounded function, and <em>M</em><sub><em>f</em></sub> is the bounded operator <em>M</em><sub><em>f</em></sub> <em>h</em>(<em>x</em>) = (<em>fh</em>)(<em>x</em>) for any square-integrable function <em>h</em> in <em>L</em><sub>2</sub>(<em>X</em>). Simultaneously, the expectation (<mtpl><eqref>4<eqref></eqref></eqref></mtpl>) is the limit at infinity of the quantum expectations <em>S</em> → ⟨<em>Se</em><sub><em>n</em></sub>,<em>e</em><sub><em>n</em></sub>⟩ defined by the eigenvectors of the <a href="Laplace-Beltrami_operator" title="wikilink">Laplacian</a> on <em>X</em>. More precisely, for many bounded operators on <em>L</em><sub>2</sub>(<em>X</em>), included all zero-order classical <a href="pseudo-differential_operators" title="wikilink">pseudo-differential operators</a> and operators of the form <em>M</em><sub><em>f</em></sub> where <em>f</em> is an essentially bounded function, the sequence ⟨<em>Se</em><sub><em>n</em></sub>, <em>e</em><sub><em>n</em></sub>⟩ logarithmically converges and<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:14">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi>S</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mfrac>
     <mrow>
      <mstyle displaystyle="false">
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>n</mi>
       </msubsup>
      </mstyle>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mi>k</mi>
        </mrow>
       </mfrac>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mrow>
         <mi>S</mi>
         <msub>
          <mi>e</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mo>,</mo>
        <msub>
         <mi>e</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mstyle displaystyle="false">
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>n</mi>
       </msubsup>
      </mstyle>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mi>k</mi>
       </mrow>
      </mfrac>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <int></int>
     <ci>S</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <ci>k</ci>
         </apply>
        </apply>
        <list>
         <apply>
          <times></times>
          <ci>S</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>e</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <ci>k</ci>
         </apply>
        </list>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int S=\lim_{n\to\infty}\frac{\sum_{k=0}^{n}\frac{1}{1+k}\langle Se_{k},e_{k}%
\rangle}{\sum_{k=0}^{n}\frac{1}{1+k}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>These properties are linked to the spectrum of Dirac type operators and not to Dixmier traces; they still hold if the Dixmier trace in (<mtpl><eqref>4<eqref></eqref></eqref></mtpl>) is replaced by any trace on weak trace class operators.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h2 id="examples">Examples</h2>

<p>Suppose <em>H</em> is a separable infinite-dimensional Hilbert space.</p>
<h3 id="ideals-without-traces">Ideals without traces</h3>
<ul>
<li><strong>Bounded operators.</strong> <a href="Paul_Halmos" title="wikilink">Paul Halmos</a> showed in 1954 that every bounded operator on a separable infinite-dimensional Hilbert space is the sum of two commutators.<ref name="Ha2"></ref></li>
</ul>

<p> That is, Com(<em>B</em>(<em>H</em>)) 

<math display="inline" id="Singular_trace:15">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 <em>B</em>(<em>H</em>) and the co-dimension of the commutator subspace of <em>B</em>(<em>H</em>) is zero. The bounded linear operators admit no <em>everywhere defined</em> traces. The qualification is relevant; as a <a href="von_Neumann_algebra" title="wikilink">von Neumann algebra</a> <em>B</em>(<em>H</em>) admits semifinite (strong-densely defined) traces.</p>

<p>Modern examination of the commutator subspace involves checking its <a href="commutator_subspace" title="wikilink">spectral characterisation</a>. The following ideals have no traces since the <a href="Cesàro_mean" title="wikilink">Cesàro means</a> of positive sequences from the Calkin corresponding sequence space belong back in the sequence space, indicating that the ideal and its commutator subspace are equal.</p>
<ul>
<li><strong>Compact operators.</strong> The commutator subspace Com(<em>K</em>(<em>H</em>)) 

<math display="inline" id="Singular_trace:16">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 <em>K</em>(<em>H</em>) where <em>K</em>(<em>H</em>) denotes the <a href="compact_operator_on_hilbert_space" title="wikilink">compact linear operators</a>. The ideal of compact operators admits no traces.</li>
</ul>
<ul>
<li><strong>Schatten <em>p</em>-ideals.</strong> The commutator subspace Com(<em>L</em><sub><em>p</em></sub>) 

<math display="inline" id="Singular_trace:17">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 <em>L</em><sub><em>p</em></sub>, <em>p</em> &gt; 1, where <em>L</em><sub><em>p</em></sub> denotes the <a href="Schatten_class_operator" title="wikilink">Schatten <em>p</em>-ideal</a>,</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>p</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>A</mi>
      <mo>∈</mo>
      <mrow>
       <mi>K</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>H</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>:</mo>
     <mrow>
      <msup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <msubsup>
          <mo largeop="true" symmetric="true">∑</mo>
          <mrow>
           <mi>n</mi>
           <mo>=</mo>
           <mn>0</mn>
          </mrow>
          <mi mathvariant="normal">∞</mi>
         </msubsup>
         <mrow>
          <mi>μ</mi>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo>,</mo>
            <mi>A</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>p</mi>
          </msup>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mfrac>
        <mn>1</mn>
        <mi>p</mi>
       </mfrac>
      </msup>
      <mo><</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>n</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <infinity></infinity>
        </apply>
        <apply>
         <times></times>
         <ci>μ</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <interval closure="open">
           <ci>n</ci>
           <ci>A</ci>
          </interval>
          <ci>p</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>p</ci>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{p}=\{A\in K(H):\left(\sum_{n=0}^{\infty}\mu(n,A)^{p}\right)^{\frac{1}{p}}<%
\infty\},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>and μ(<em>A</em>) denotes the sequence of singular values of a compact operator <em>A</em>. The Schatten ideals for <em>p</em> &gt; 1 admit no traces.
</dd>
</dl>
<ul>
<li><strong>Lorentz <em>p</em>-ideals or weak-<em>L</em><sub><em>p</em></sub> ideals</strong>. The commutator subspace Com(<em>L</em><sub><em>p</em>,∞</sub>) 

<math display="inline" id="Singular_trace:19">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 <em>L</em><sub><em>p</em>,∞</sub>, <em>p</em> &gt; 1, where</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:20">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>p</mi>
     <mo>,</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>A</mi>
     <mo>∈</mo>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>H</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>n</mi>
        <mrow>
         <mo>-</mo>
         <mfrac>
          <mn>1</mn>
          <mi>p</mi>
         </mfrac>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <list>
      <ci>p</ci>
      <infinity></infinity>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>μ</ci>
       <interval closure="open">
        <ci>n</ci>
        <ci>A</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <ci>p</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{p,\infty}=\{A\in K(H):\mu(n,A)=O(n^{-\frac{1}{p}})\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>is the weak-<em>L</em><sub><em>p</em></sub> ideal. The weak-<em>L</em><sub><em>p</em></sub> ideals, <em>p</em> &gt; 1, admit no traces. The weak-<em>L</em><sub><em>p</em></sub> ideals are equal to the Lorentz ideals (below) with concave function ψ(<em>n</em>)

<math display="inline" id="Singular_trace:21">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

<em>n</em><sup>1-1/<em>p</em></sup>.
</dd>
</dl>
<h3 id="ideals-with-traces">Ideals with traces</h3>
<ul>
<li><strong>Finite rank operators.</strong> It is checked from the spectral condition that the kernel of the <a href="trace_class#Definition" title="wikilink">operator trace</a> Tr and the commutator subspace of the finite rank operators are equal, ker Tr = Com(<em>F</em>(<em>H</em>)). It follows that the commutator subspace Com(<em>F</em>(<em>H</em>)) has co-dimension 1 in <em>F</em>(<em>H</em>). Up to scaling Tr is the unique trace on <em>F</em>(<em>H</em>).</li>
</ul>
<ul>
<li><strong>Trace class operators.</strong> The trace class operators <em>L</em><sub>1</sub> have Com(<em>L</em><sub>1</sub>) strictly contained in ker Tr. The co-dimension of the <a href="commutator_subspace" title="wikilink">commutator subspace</a> is therefore greater than one, and is shown to be infinite.<ref name="GW2"></ref></li>
</ul>

<p> Whilst Tr is, up to scaling, the unique continuous trace on <em>L</em><sub>1</sub> for the norm ||A||<sub>1</sub> = Tr(|A|), the ideal of trace class operators admits infinitely many linearly independent and non-trivial singular traces.</p>
<ul>
<li><strong>Weak trace class operators</strong>. Since Com(<em>L</em><sub><em>1</em>,∞</sub>)<sub>+</sub> 

<math display="inline" id="Singular_trace:22">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 (<em>L</em><sub>1</sub>)<sub>+</sub> the co-dimension of the commutator subspace of the weak-<em>L</em><sub><em>1</em></sub> ideal is infinite. Every trace on weak trace class operators vanishes on trace class operators, and hence is singular. The weak trace class operators form the smallest ideal where every trace on the ideal must be singular.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> <a href="Dixmier_trace" title="wikilink">Dixmier traces</a> provide an explicit construction of traces on the weak trace class operators.</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>Tr</mi>
       <mi>ω</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>ω</mi>
      <mrow>
       <mo>(</mo>
       <msubsup>
        <mrow>
         <mo>{</mo>
         <mrow>
          <mfrac>
           <mn>1</mn>
           <mrow>
            <mi>log</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mn>1</mn>
              <mo>+</mo>
              <mi>n</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mfrac>
          <mrow>
           <msubsup>
            <mo largeop="true" symmetric="true">∑</mo>
            <mrow>
             <mi>k</mi>
             <mo>=</mo>
             <mn>0</mn>
            </mrow>
            <mi>n</mi>
           </msubsup>
           <mrow>
            <mi>λ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>k</mi>
             <mo>,</mo>
             <mi>A</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </mrow>
         <mo>}</mo>
        </mrow>
        <mrow>
         <mi>n</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi mathvariant="normal">∞</mi>
       </msubsup>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>A</mi>
     <mo>∈</mo>
     <msub>
      <mi>L</mi>
      <mrow>
       <mn>1</mn>
       <mo>,</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Tr</ci>
       <ci>ω</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <set>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <apply>
            <log></log>
            <apply>
             <plus></plus>
             <cn type="integer">1</cn>
             <ci>n</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <sum></sum>
             <apply>
              <eq></eq>
              <ci>k</ci>
              <cn type="integer">0</cn>
             </apply>
            </apply>
            <ci>n</ci>
           </apply>
           <apply>
            <times></times>
            <ci>λ</ci>
            <interval closure="open">
             <ci>k</ci>
             <ci>A</ci>
            </interval>
           </apply>
          </apply>
         </apply>
        </set>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <list>
       <cn type="integer">1</cn>
       <infinity></infinity>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Tr}_{\omega}(A)=\omega\left(\left\{\frac{1}{\log(1+n)}\sum_{k=0}^{n}%
\lambda(k,A)\right\}_{n=0}^{\infty}\right),\quad A\in L_{1,\infty}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>This formula is valid for every weak trace class operator <em>A</em> and involves the eigenvalues ordered in decreasing absolute value. Also ω can be any extension to <em>l</em><sub>∞</sub> of the ordinary limit, it does not need to be dilation invariant as in Dixmier's original formulation. Not all of the singular traces on the weak trace class ideal are Dixmier traces.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a>
</dd>
</dl>
<ul>
<li><strong><em>k</em>-tensor weak trace class ideals</strong>. The weak-<em>L</em><sub><em>p</em></sub> ideals, <em>p</em> &gt; 1, admit no traces as explained above. They are not the right setting for higher order factorisations of the traces on the weak trace class ideal <em>L</em><sub><em>1</em>,∞</sub>. For a natural number <em>k</em> ≥ 1 the ideals</li>
</ul>
<dl>
<dd><dl>
<dd><math> E_{\otimes k} = \{ A \in K(H) :
</math></dd>
</dl>
</dd>
</dl>

<p>\mu(n,A) = O (\log^{k-1}(n)/n ) \} </p>
<dl>
<dd>form the appropriate setting. They have commutator subspaces of infinite co-dimension that form a chain such that <em>E</em><sub>⊗<em>k</em>-1</sub> ⊂ Com(<em>E</em><sub>⊗<em>k</em></sub>) (with the convention that <em>E</em><sub>0</sub> = <em>L</em><sub>1</sub>). Dixmier traces on <em>E</em><sub>⊗<em>k</em></sub> have the form
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msubsup>
       <mi>Tr</mi>
       <mi>ω</mi>
       <mi>k</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>ω</mi>
      <mrow>
       <mo>(</mo>
       <msubsup>
        <mrow>
         <mo>{</mo>
         <mrow>
          <mfrac>
           <mn>1</mn>
           <mrow>
            <msup>
             <mi>log</mi>
             <mi>k</mi>
            </msup>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mn>1</mn>
              <mo>+</mo>
              <mi>n</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mfrac>
          <mrow>
           <msubsup>
            <mo largeop="true" symmetric="true">∑</mo>
            <mrow>
             <mi>j</mi>
             <mo>=</mo>
             <mn>0</mn>
            </mrow>
            <mi>n</mi>
           </msubsup>
           <mrow>
            <mi>λ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>j</mi>
             <mo>,</mo>
             <mi>A</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </mrow>
         <mo>}</mo>
        </mrow>
        <mrow>
         <mi>n</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi mathvariant="normal">∞</mi>
       </msubsup>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>A</mi>
     <mo>∈</mo>
     <msub>
      <mi>E</mi>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Tr</ci>
        <ci>k</ci>
       </apply>
       <ci>ω</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <set>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <apply>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <log></log>
             <ci>k</ci>
            </apply>
            <apply>
             <plus></plus>
             <cn type="integer">1</cn>
             <ci>n</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <sum></sum>
             <apply>
              <eq></eq>
              <ci>j</ci>
              <cn type="integer">0</cn>
             </apply>
            </apply>
            <ci>n</ci>
           </apply>
           <apply>
            <times></times>
            <ci>λ</ci>
            <interval closure="open">
             <ci>j</ci>
             <ci>A</ci>
            </interval>
           </apply>
          </apply>
         </apply>
        </set>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Tr}^{k}_{\omega}(A)=\omega\left(\left\{\frac{1}{\log^{k}(1+n)}\sum_{j=0}^%
{n}\lambda(j,A)\right\}_{n=0}^{\infty}\right),\quad A\in E_{\otimes k}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Lorentz ψ-ideals.</strong> The natural setting for Dixmier traces is on a Lorentz ψ-ideal for a concave increasing function ψ : [0,∞) → [0,∞),</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>ψ</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>A</mi>
      <mo>∈</mo>
      <mrow>
       <mi>K</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>H</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mi>ψ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>+</mo>
           <mi>n</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mi>n</mi>
        </msubsup>
        <mrow>
         <mi>μ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo>,</mo>
          <mi>A</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo><</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>ψ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>ψ</ci>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <ci>μ</ci>
         <interval closure="open">
          <ci>n</ci>
          <ci>A</ci>
         </interval>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\psi}=\{A\in K(H):\frac{1}{\psi(1+n)}\sum_{j=0}^{n}\mu(n,A)<\infty\}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>There are <em>some</em> ω that extend the ordinary limit to <em>l</em><sub>∞</sub> such that
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>Tr</mi>
      <mi>ω</mi>
      <mi>ψ</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>ω</mi>
     <mrow>
      <mo>(</mo>
      <msubsup>
       <mrow>
        <mo>{</mo>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mrow>
           <mi>ψ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mn>1</mn>
             <mo>+</mo>
             <mi>n</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mfrac>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>0</mn>
           </mrow>
           <mi>n</mi>
          </msubsup>
          <mrow>
           <mi>λ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>j</mi>
            <mo>,</mo>
            <mi>A</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
        <mo>}</mo>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>A</mi>
    <mo>∈</mo>
    <msub>
     <mi>L</mi>
     <mi>ψ</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Tr</ci>
        <ci>ψ</ci>
       </apply>
       <ci>ω</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <set>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <apply>
            <times></times>
            <ci>ψ</ci>
            <apply>
             <plus></plus>
             <cn type="integer">1</cn>
             <ci>n</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <sum></sum>
             <apply>
              <eq></eq>
              <ci>j</ci>
              <cn type="integer">0</cn>
             </apply>
            </apply>
            <ci>n</ci>
           </apply>
           <apply>
            <times></times>
            <ci>λ</ci>
            <interval closure="open">
             <ci>j</ci>
             <ci>A</ci>
            </interval>
           </apply>
          </apply>
         </apply>
        </set>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>ψ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Tr}^{\psi}_{\omega}(A)=\omega\left(\left\{\frac{1}{\psi(1+n)}\sum_{j=0}^{%
n}\lambda(j,A)\right\}_{n=0}^{\infty}\right),\quad A\in L_{\psi}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
<dd>is a singular trace if and only if<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Singular_trace:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>lim inf</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mfrac>
     <mrow>
      <mi>ψ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>ψ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">limit-infimum</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>ψ</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>ψ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \liminf_{n\to\infty}\frac{\psi(2n)}{\psi(n)}=1.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
<dd>The principal ideal generated by any compact operator <em>A</em> with μ(<em>A</em>)=ψ' is called the 'small ideal' inside <em>L</em><sub>ψ</sub>. The <em>k</em>-tensor weak trace class ideal is the small ideal inside the Lorentz ideal with ψ

<math display="inline" id="Singular_trace:28">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

log<sup>k</sup>.
</dd>
</dl>
<ul>
<li><strong><a href="Fully_symmetric_ideal" title="wikilink">Fully symmetric ideals</a></strong> generalise Lorentz ideals. Dixmier traces form all the fully symmetric traces on a Lorentz ideal up to scaling, and form a <a href="Weak_topology#the_weak-*_topology" title="wikilink">weak* dense</a> subset of the fully symmetric traces on a general fully symmetric ideal. It is known the fully symmetric traces are a strict subset of the positive traces on a fully symmetric ideal.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> Therefore Dixmier traces are not the full set of positive traces on Lorentz ideals.</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Dixmier_trace" title="wikilink">Dixmier trace</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Traces" title="wikilink">Category:Traces</a> <a href="Category:Hilbert_space" title="wikilink">Category:Hilbert space</a> <a href="Category:Von_Neumann_algebras" title="wikilink">Category:Von Neumann algebras</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">,<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
</ol>
</section>
</body>
</html>
