<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1862">Continuous knapsack problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Continuous knapsack problem</h1>
<hr>In [[theoretical computer science]], the '''continuous knapsack problem''' (also known as the '''fractional knapsack problem''') is an [[algorithm]]ic problem in [[combinatorial optimization]] in which the goal is to fill a container (the "knapsack") with fractional amounts of different materials chosen to maximize the value of the selected materials.<ref name="gt">{{citation|title=Algorithm Design: Foundations, Analysis, and Internet Examples|first1=Michael T.|last1=Goodrich|author1-link=
<p>Michael T. Goodrich|first2=Roberto|last2=Tamassia|author2-link=Roberto Tamassia|publisher=John Wiley &amp; Sons|year=2002|contribution=5.1.1 The Fractional Knapsack Problem|pages=259–260}}.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It resembles the classic <a href="knapsack_problem" title="wikilink">knapsack problem</a>, in which the items to be placed in the container are indivisible; however, the continuous knapsack problem may be solved in <a href="polynomial_time" title="wikilink">polynomial time</a> whereas the classic knapsack problem is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It is a classic example of how a seemingly small change in the formulation of a problem can have a large impact on its <a href="Analysis_of_algorithms" title="wikilink">computational complexity</a>.</p>
<h2 id="problem-definition">Problem definition</h2>

<p>An instance of either the continuous or classic knapsack problems may be specified by the numerical capacity <em>W</em> of the knapsack, together with a collection of materials, each of which has two numbers associated with it: the weight <em>w<sub>i</sub></em> of material that is available to be selected and the value per unit weight <em>v<sub>i</sub></em> of that material. The goal is to choose an amount <em>x<sub>i</sub></em> ≤ <em>w<sub>i</sub></em> of each material, subject to the capacity constraint</p>

<p>

<math display="block" id="Continuous_knapsack_problem:0">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>≤</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}x_{i}\leq W
  </annotation>
 </semantics>
</math>

 and maximizing the total benefit</p>

<p>

<math display="block" id="Continuous_knapsack_problem:1">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}x_{i}v_{i}
  </annotation>
 </semantics>
</math>

. In the classic knapsack problem, each of the amounts <em>x<sub>i</sub></em> must be either zero or <em>w<sub>i</sub></em>; the continuous knapsack problem differs by allowing <em>x<sub>i</sub></em> to range continuously from zero to <em>w<sub>i</sub></em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Some formulations of this problem rescale the variables <em>x<sub>i</sub></em> to be in the range from 0 to 1</p>
<h2 id="solution-technique">Solution technique</h2>

<p>The continuous knapsack problem may be solved by a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>, first published in 1957 by <a href="George_Dantzig" title="wikilink">George Dantzig</a>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> that considers the materials in sorted order by their values per unit weight. For each material, the amount <em>x<sub>i</sub></em> is chosen to be as large as possible:</p>
<ul>
<li>If the sum of the choices made so far equals the capacity <em>W</em>, then the algorithm sets <em>x<sub>i</sub></em> = 0.</li>
<li>If the difference <em>d</em> between the sum of the choices made so far and <em>W</em> is smaller than <em>w<sub>i</sub></em>, then the algorithm sets <em>x<sub>i</sub></em> = <em>d</em>.</li>
<li>In the remaining case, the algorithm chooses <em>x<sub>i</sub></em> = <em>w<sub>i</sub></em>.</li>
</ul>

<p>Because of the need to sort the materials, this algorithm takes time <em>O</em>(<em>n</em> log <em>n</em>) on inputs with <em>n</em> materials.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> However, by adapting an algorithm for finding <a href="weighted_median" title="wikilink">weighted medians</a>, it is possible to solve the problem in time <em>O</em>(<em>n</em>).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
</ol>
</section>
</ref></hr></body>
</html>
