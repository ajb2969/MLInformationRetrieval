<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="979">Quantum error correction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum error correction</h1>
<hr/>

<p><strong>Quantum error correction</strong> is used in <a href="Quantum_computer" title="wikilink">quantum computing</a> to protect <a href="quantum_information" title="wikilink">quantum information</a> from errors due to <a class="uri" href="decoherence" title="wikilink">decoherence</a> and other <a href="quantum_noise" title="wikilink">quantum noise</a>. Quantum error correction is essential if one is to achieve fault-tolerant quantum computation that can deal not only with noise on stored quantum information, but also with faulty quantum gates, faulty quantum preparation, and faulty measurements.</p>

<p>Classical <a href="error_correction" title="wikilink">error correction</a> employs <a href="Redundancy_(information_theory)" title="wikilink">redundancy</a>. The simplest way is to store the information multiple times, and—if these copies are later found to disagree—just take a majority vote; e.g. Suppose we copy a bit three times. Suppose further that a noisy error corrupts the three-bit state so that one bit is equal to zero but the other two are equal to one. If we assume that noisy errors are independent and occur with some probability p. It is most likely that the error is a single-bit error and the transmitted message is three ones. It is possible that a double-bit error occurs and the transmitted message is equal to three zeros, but this outcome is less likely than the above outcome.</p>

<p>Copying quantum information is not possible due to the <a href="no-cloning_theorem" title="wikilink">no-cloning theorem</a>. This theorem seems to present an obstacle to formulating a theory of quantum error correction. But it is possible to <em>spread</em> the information of one <a class="uri" href="qubit" title="wikilink">qubit</a> onto a highly entangled state of several (<em>physical</em>) qubits. <a href="Peter_Shor" title="wikilink">Peter Shor</a> first discovered this method of formulating a <em>quantum error correcting code</em> by storing the information of one qubit onto a highly entangled state of nine qubits. A quantum error correcting code protects quantum information against errors of a limited form.</p>

<p>Classical error correcting codes use a <em>syndrome measurement</em> to diagnose which error corrupts an encoded state. We then reverse an error by applying a corrective operation based on the syndrome. Quantum error correction also employs syndrome measurements. We perform a multi-qubit measurement that does not disturb the quantum information in the encoded state but retrieves information about the error. A syndrome measurement can determine whether a qubit has been corrupted, and if so, which one. What is more, the outcome of this operation (the <em>syndrome</em>) tells us not only which physical qubit was affected, but also, in which of several possible ways it was affected. The latter is counter-intuitive at first sight: Since noise is arbitrary, how can the effect of noise be one of only few distinct possibilities? In most codes, the effect is either a bit flip, or a sign (of the <a href="phase_(waves)" title="wikilink">phase</a>) flip, or both (corresponding to the <a href="Pauli_matrices" title="wikilink">Pauli matrices</a> <em>X</em>, <em>Z</em>, and <em>Y</em>). The reason is that the measurement of the syndrome has the <a href="projection_(linear_algebra)" title="wikilink">projective</a> effect of a <a href="quantum_measurement" title="wikilink">quantum measurement</a>. So even if the error due to the noise was arbitrary, it can be expressed as a <a href="quantum_superposition" title="wikilink">superposition</a> of <a href="Basis_(linear_algebra)" title="wikilink">basis</a> operations—the <em>error basis</em> (which is here given by the Pauli matrices and the <a href="identity_(mathematics)" title="wikilink">identity</a>). The syndrome measurement "forces" the qubit to "decide" for a certain specific "Pauli error" to "have happened", and the syndrome tells us which, so that we can let the same Pauli operator act again on the corrupted qubit to revert the effect of the error.</p>

<p>The syndrome measurement tells us as much as possible about the error that has happened, but <em>nothing</em> at all about the <em>value</em> that is stored in the logical qubit—as otherwise the measurement would destroy any <a href="quantum_superposition" title="wikilink">quantum superposition</a> of this logical qubit with other qubits in the <a href="quantum_computer" title="wikilink">quantum computer</a>.</p>
<h2 id="the-bit-flip-code">The bit flip code</h2>

<p>The repetition code works in a classical channel, because classical bits are easy to measure and to repeat. However, in a quantum channel, it is no longer possible, due to the <a href="no-cloning_theorem" title="wikilink">no-cloning theorem</a>, which forbids the creation of identical copies of an arbitrary unknown quantum state. So a single qubit can not be repeated three times as in the previous example, as any measurement of the qubit will change its <a href="wave_function" title="wikilink">wave function</a>. Nevertheless, in a quantum computer, there is another method, which is called the three qubits bit flip code. It uses entanglement and syndrome measurements, and can perform the similar results to the repetition code.</p>

<p> Let 

<math display="inline" id="Quantum_error_correction:0">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>0</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>1</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle=\alpha_{0}|0\rangle+\alpha_{1}|1\rangle
  </annotation>
 </semantics>
</math>

 be an arbitrary qubit. The first step of the three qubit bit flip code is to entangle the qubit with two other qubits using two <a href="Controlled_NOT_gate" title="wikilink">CNOT gates</a> with input 

<math display="inline" id="Quantum_error_correction:1">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>0</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The result will be 

<math display="inline" id="Quantum_error_correction:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msup>
      <mi>ψ</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>α</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>000</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>α</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>111</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ψ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">000</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">111</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi^{\prime}\rangle=\alpha_{0}|000\rangle+\alpha_{1}|111\rangle.
  </annotation>
 </semantics>
</math>

 This is just a tensor product of three qubits, and different from cloning a state.</p>

<p>Now these qubits will be sent through a channel 

<math display="inline" id="Quantum_error_correction:3">
 <semantics>
  <msub>
   <mi>E</mi>
   <mtext>bit</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <mtext>bit</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{\text{bit}}
  </annotation>
 </semantics>
</math>

 where we assume that at most one bit flip may occur. For example, in the case where the first qubit is flipped, the result would be 

<math display="inline" id="Quantum_error_correction:4">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msubsup>
     <mi>ψ</mi>
     <mi>r</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>100</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>011</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">100</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">011</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi^{\prime}_{r}\rangle=\alpha_{0}|100\rangle+\alpha_{1}|011\rangle
  </annotation>
 </semantics>
</math>

. To diagnose bit flips in any of the three possible qubits, syndrome diagnosis is needed, which includes four projection operators:</p>

<p>

<math display="inline" id="Quantum_error_correction:5">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>000</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>000</mn>
     <mo fence="true" stretchy="false">|</mo>
     <mo>+</mo>
     <mo fence="true" stretchy="false">|</mo>
     <mn>111</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>111</mn>
     <mo fence="true" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">000</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">quantum-operator-product</csymbol>
      <cn type="integer">000</cn>
      <plus></plus>
      <cn type="integer">111</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">bra</csymbol>
      <cn type="integer">111</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{0}=|000\rangle\langle 000|+|111\rangle\langle 111|
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_error_correction:6">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>100</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>100</mn>
     <mo fence="true" stretchy="false">|</mo>
     <mo>+</mo>
     <mo fence="true" stretchy="false">|</mo>
     <mn>011</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>011</mn>
     <mo fence="true" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">100</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">quantum-operator-product</csymbol>
      <cn type="integer">100</cn>
      <plus></plus>
      <cn type="integer">011</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">bra</csymbol>
      <cn type="integer">011</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}=|100\rangle\langle 100|+|011\rangle\langle 011|
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_error_correction:7">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>010</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>010</mn>
     <mo fence="true" stretchy="false">|</mo>
     <mo>+</mo>
     <mo fence="true" stretchy="false">|</mo>
     <mn>101</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>101</mn>
     <mo fence="true" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">010</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">quantum-operator-product</csymbol>
      <cn type="integer">010</cn>
      <plus></plus>
      <cn type="integer">101</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">bra</csymbol>
      <cn type="integer">101</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{2}=|010\rangle\langle 010|+|101\rangle\langle 101|
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_error_correction:8">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>001</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>001</mn>
     <mo fence="true" stretchy="false">|</mo>
     <mo>+</mo>
     <mo fence="true" stretchy="false">|</mo>
     <mn>110</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>110</mn>
     <mo fence="true" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">001</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">quantum-operator-product</csymbol>
      <cn type="integer">001</cn>
      <plus></plus>
      <cn type="integer">110</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">bra</csymbol>
      <cn type="integer">110</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{3}=|001\rangle\langle 001|+|110\rangle\langle 110|
  </annotation>
 </semantics>
</math>

</p>

<p>It can be obtained:</p>

<p>

<math display="inline" id="Quantum_error_correction:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msubsup>
     <mi>ψ</mi>
     <mi>r</mi>
     <mo>′</mo>
    </msubsup>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>P</mi>
     <mn>0</mn>
    </msub>
    <mo fence="true" stretchy="false">|</mo>
    <msubsup>
     <mi>ψ</mi>
     <mi>r</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">quantum-operator-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\psi^{\prime}_{r}|P_{0}|\psi^{\prime}_{r}\rangle=0
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_error_correction:10">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msubsup>
     <mi>ψ</mi>
     <mi>r</mi>
     <mo>′</mo>
    </msubsup>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>P</mi>
     <mn>1</mn>
    </msub>
    <mo fence="true" stretchy="false">|</mo>
    <msubsup>
     <mi>ψ</mi>
     <mi>r</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">quantum-operator-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\psi^{\prime}_{r}|P_{1}|\psi^{\prime}_{r}\rangle=1
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_error_correction:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msubsup>
     <mi>ψ</mi>
     <mi>r</mi>
     <mo>′</mo>
    </msubsup>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>P</mi>
     <mn>2</mn>
    </msub>
    <mo fence="true" stretchy="false">|</mo>
    <msubsup>
     <mi>ψ</mi>
     <mi>r</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">quantum-operator-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\psi^{\prime}_{r}|P_{2}|\psi^{\prime}_{r}\rangle=0
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_error_correction:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msubsup>
     <mi>ψ</mi>
     <mi>r</mi>
     <mo>′</mo>
    </msubsup>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>P</mi>
     <mn>3</mn>
    </msub>
    <mo fence="true" stretchy="false">|</mo>
    <msubsup>
     <mi>ψ</mi>
     <mi>r</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">quantum-operator-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\psi^{\prime}_{r}|P_{3}|\psi^{\prime}_{r}\rangle=0
  </annotation>
 </semantics>
</math>

</p>

<p>So it will be known that the error syndrome corresponds to 

<math display="inline" id="Quantum_error_correction:13">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}
  </annotation>
 </semantics>
</math>

. This three qubits bit flip code can correct one error if at most one bit-flip-error occurred in the channel. It is similar to the three bits repetition code in a classical computer.</p>
<h2 id="the-sign-flip-code">The sign flip code</h2>

<p> Flipped bits are the only kind of error in classical computer, but there is another possibility of an error with quantum computers, the sign flip. Through the transmission in a channel the relative sign between 

<math display="inline" id="Quantum_error_correction:14">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>0</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_error_correction:15">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>1</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |1\rangle
  </annotation>
 </semantics>
</math>

 can become inverted. For instance, a qubit in the state 

<math display="inline" id="Quantum_error_correction:16">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mo>-</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <msqrt>
     <mn>2</mn>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <minus></minus>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |-\rangle=(|0\rangle-|1\rangle)/\sqrt{2}
  </annotation>
 </semantics>
</math>

 may have its sign flip to 

<math display="inline" id="Quantum_error_correction:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mo>+</mo>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <plus></plus>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |+\rangle=(|0\rangle+|1\rangle)/\sqrt{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>The original state of the qubit</p>

<p>

<math display="inline" id="Quantum_error_correction:18">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mo>+</mo>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mo>-</mo>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <minus></minus>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle=\alpha_{0}|+\rangle+\alpha_{1}|-\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>will be changed into the state</p>

<p>

<math display="inline" id="Quantum_error_correction:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <msup>
      <mi>ψ</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>α</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">|</mo>
    <mo>+</mo>
    <mo>+</mo>
    <mo>+</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>+</mo>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">|</mo>
   <mo>-</mo>
   <mo>-</mo>
   <mo>-</mo>
   <mo stretchy="false">⟩</mo>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-⟩</ci>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-|</ci>
     <plus></plus>
     <plus></plus>
     <plus></plus>
     <ci>normal-⟩</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-|</ci>
    <minus></minus>
    <minus></minus>
    <minus></minus>
    <ci>normal-⟩</ci>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi^{\prime}\rangle=\alpha_{0}|{+}{+}{+}\rangle+\alpha_{1}|{-}{-}{-}\rangle.
  </annotation>
 </semantics>
</math>

</p>

<p>In the Hadamard basis, bit flips become sign flips and sign flips become bit flips. Let 

<math display="inline" id="Quantum_error_correction:20">
 <semantics>
  <msub>
   <mi>E</mi>
   <mtext>phase</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <mtext>phase</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{\text{phase}}
  </annotation>
 </semantics>
</math>

 be a quantum channel that can cause at most one phase flip. Then the bit flip code from above can recover 

<math display="inline" id="Quantum_error_correction:21">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 by transforming into the Hadamard basis before and after transmission through 

<math display="inline" id="Quantum_error_correction:22">
 <semantics>
  <msub>
   <mi>E</mi>
   <mtext>phase</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <mtext>phase</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{\text{phase}}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="the-shor-code">The Shor code</h2>

<p>The error channel may induce either a bit flip, a sign flip, or both. It is possible to correct for both types of errors using one code, and the Shor code does just that. In fact, the Shor code corrects arbitrary single-qubit errors.</p>

<p> Let 

<math display="inline" id="Quantum_error_correction:23">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 be a quantum channel that can arbitrarily corrupt a single qubit. The 1st, 4th and 7th qubits are for the sign flip code, while the three group of qubits (1,2,3), (4,5,6), and (7,8,9) are designed for the bit flip code. With the Shor code, a qubit state 

<math display="inline" id="Quantum_error_correction:24">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>0</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>1</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle=\alpha_{0}|0\rangle+\alpha_{1}|1\rangle
  </annotation>
 </semantics>
</math>

 will be transformed into the product of 9 qubits 

<math display="inline" id="Quantum_error_correction:25">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msup>
     <mi>ψ</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mn>0</mn>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mn>1</mn>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ψ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">0</cn>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi^{\prime}\rangle=\alpha_{0}|0_{S}\rangle+\alpha_{1}|1_{S}\rangle
  </annotation>
 </semantics>
</math>

, where</p>

<p>

<math display="block" id="Quantum_error_correction:26">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mn>0</mn>
     <mi>S</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <msqrt>
        <mn>2</mn>
       </msqrt>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>000</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>111</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊗</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>000</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>111</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊗</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>000</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>111</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">0</cn>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <root></root>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">000</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">111</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">000</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">111</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">000</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">111</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0_{S}\rangle=\frac{1}{2\sqrt{2}}(|000\rangle+|111\rangle)\otimes(|000\rangle+%
|111\rangle)\otimes(|000\rangle+|111\rangle)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantum_error_correction:27">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mn>1</mn>
     <mi>S</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <msqrt>
        <mn>2</mn>
       </msqrt>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>000</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>111</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊗</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>000</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>111</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊗</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>000</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>111</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <root></root>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">000</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">111</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">000</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">111</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">000</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">111</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |1_{S}\rangle=\frac{1}{2\sqrt{2}}(|000\rangle-|111\rangle)\otimes(|000\rangle-%
|111\rangle)\otimes(|000\rangle-|111\rangle)
  </annotation>
 </semantics>
</math>

</p>

<p>If a bit flip error happens to a qubit, the syndrome analysis will be performed on each set of states (1,2,3), (4,5,6), and (7,8,9), then correct the error.</p>

<p>If the three bit flip group (1,2,3), (4,5,6), and (7,8,9) are considered as three inputs, then the Shor code circuit can be reduced as a sign flip code. This means that the Shor code can also repair sign flip error for a single qubit.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The Shor code also can correct for any arbitrary errors (both bit flip and sign flip) to a single qubit. If an error is modeled by a unitary transform U, which will act on a qubit 

<math display="inline" id="Quantum_error_correction:28">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Quantum_error_correction:29">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 can be described in the form</p>

<p>

<math display="block" id="Quantum_error_correction:30">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>0</mn>
     </msub>
     <mi>I</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>σ</mi>
      <mi>x</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>σ</mi>
      <mi>y</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>3</mn>
     </msub>
     <msub>
      <mi>σ</mi>
      <mi>z</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>I</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=c_{0}I+c_{1}\sigma_{x}+c_{2}\sigma_{y}+c_{3}\sigma_{z}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Quantum_error_correction:31">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{0}
  </annotation>
 </semantics>
</math>

,

<math display="inline" id="Quantum_error_correction:32">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

,

<math display="inline" id="Quantum_error_correction:33">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Quantum_error_correction:34">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{3}
  </annotation>
 </semantics>
</math>

 are complex constants, I is the identity, and the <a href="Pauli_matrices" title="wikilink">Pauli matrices</a> are given by</p>

<p>

<math display="block" id="Quantum_error_correction:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mi>x</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>x</ci>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{x}=\biggl(\begin{matrix}0&1\\
1&0\end{matrix}\biggr);
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantum_error_correction:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mi>y</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mi>i</mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>i</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>y</ci>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>i</ci>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{y}=\biggl(\begin{matrix}0&-i\\
i&0\end{matrix}\biggr);
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantum_error_correction:37">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>z</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo maxsize="210%" minsize="210%">(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo maxsize="210%" minsize="210%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>z</ci>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{z}=\biggl(\begin{matrix}1&0\\
0&-1\end{matrix}\biggr)
  </annotation>
 </semantics>
</math>

</p>

<p>If U is equal to I, then no error occurs. If 

<math display="inline" id="Quantum_error_correction:38">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <msub>
    <mi>σ</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=\sigma_{x}
  </annotation>
 </semantics>
</math>

, a bit flip error occurs. If 

<math display="inline" id="Quantum_error_correction:39">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <msub>
    <mi>σ</mi>
    <mi>z</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=\sigma_{z}
  </annotation>
 </semantics>
</math>

, a sign flip error occurs. If 

<math display="inline" id="Quantum_error_correction:40">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mi>i</mi>
    <msub>
     <mi>σ</mi>
     <mi>y</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=i\sigma_{y}
  </annotation>
 </semantics>
</math>

 then both a bit flip error and a sign flip error occur. Due to linearity, it follows that the Shor code can correct arbitrary 1-qubit errors.</p>
<h2 id="general-codes">General codes</h2>

<p>In general, a <em>quantum code</em> for a <a href="quantum_channel" title="wikilink">quantum channel</a> 

<math display="inline" id="Quantum_error_correction:41">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℰ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℰ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

 is a subspace 

<math display="inline" id="Quantum_error_correction:42">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>⊆</mo>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>𝒞</ci>
    <ci>ℋ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}\subseteq\mathcal{H}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Quantum_error_correction:43">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 is the state Hilbert space, such that there exists another quantum channel 

<math display="inline" id="Quantum_error_correction:44">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℛ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℛ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{R}
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="inline" id="Quantum_error_correction:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi class="ltx_font_mathcaligraphic">ℛ</mi>
        <mo>∘</mo>
        <mi class="ltx_font_mathcaligraphic">ℰ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ρ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>ρ</mi>
    </mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>ρ</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      </msub>
      <mi>ρ</mi>
      <msub>
       <mi>P</mi>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <compose></compose>
       <ci>ℛ</ci>
       <ci>ℰ</ci>
      </apply>
      <ci>ρ</ci>
     </apply>
     <ci>ρ</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>ρ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>𝒞</ci>
      </apply>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>𝒞</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{R}\circ\mathcal{E})(\rho)=\rho\quad\forall\rho=P_{\mathcal{C}}\rho P%
_{\mathcal{C}},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Quantum_error_correction:46">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\mathcal{C}}
  </annotation>
 </semantics>
</math>

 is the <a href="orthogonal_projection" title="wikilink">orthogonal projection</a> onto 

<math display="inline" id="Quantum_error_correction:47">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

. Here 

<math display="inline" id="Quantum_error_correction:48">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℛ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℛ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{R}
  </annotation>
 </semantics>
</math>

 is known as the <em>correction operation</em>.</p>
<h2 id="models">Models</h2>

<p>Over time, researchers have come up with several codes:</p>
<ul>
<li><a href="Peter_Shor" title="wikilink">Peter Shor</a>'s 9-qubit-code, a.k.a. the <a href="Shor_code" title="wikilink">Shor code</a>, encodes 1 logical qubit in 9 physical qubits and can correct for arbitrary errors in a single qubit.</li>
<li><a href="Andrew_Steane" title="wikilink">Andrew Steane</a> found a code which does the same with 7 instead of 9 qubits, see <a href="Steane_code" title="wikilink">Steane code</a>.</li>
<li><a href="Raymond_Laflamme" title="wikilink">Raymond Laflamme</a> and collaborators found a class of 5-qubit codes which do the same, which also have the property of being <a class="uri" href="fault-tolerant" title="wikilink">fault-tolerant</a>. A 5-qubit code is the smallest possible code which protects a single logical qubit against single-qubit errors.</li>
<li>A generalisation of this concept are the <a href="CSS_code" title="wikilink">CSS codes</a>, named for their inventors: <a href="A._R._Calderbank" title="wikilink">A. R. Calderbank</a>, <a href="Peter_Shor" title="wikilink">Peter Shor</a> and <a href="Andrew_Steane" title="wikilink">Andrew Steane</a>. According to the quantum Hamming bound, encoding a single logical qubit and providing for arbitrary error correction in a single qubit requires a minimum of 5 physical qubits.</li>
<li>A more general class of codes (encompassing the former) are the <a href="stabilizer_code" title="wikilink">stabilizer codes</a> discovered by <a href="Daniel_Gottesman" title="wikilink">Daniel Gottesman</a> (<a href="http://arxiv.org/abs/quant-ph/9604038">1</a>), and by <a href="A._R._Calderbank" title="wikilink">A. R. Calderbank</a>, <a href="Eric_Rains" title="wikilink">Eric Rains</a>, <a href="Peter_Shor" title="wikilink">Peter Shor</a>, and <a href="N._J._A._Sloane" title="wikilink">N. J. A. Sloane</a> (<a href="http://arxiv.org/abs/quant-ph/9605005">2</a>, <a href="http://arxiv.org/abs/quant-ph/9608006">3</a>); these are also called <a href="additive_code" title="wikilink">additive codes</a>.</li>
<li>A newer idea is <a href="Alexei_Kitaev" title="wikilink">Alexei Kitaev</a>'s <a href="toric_code" title="wikilink">topological quantum codes</a> and the more general idea of a <a href="topological_quantum_computer" title="wikilink">topological quantum computer</a>.</li>
<li><a href="Todd_Brun" title="wikilink">Todd Brun</a>, <a href="Igor_Devetak" title="wikilink">Igor Devetak</a>, and <a href="Min-Hsiu_Hsieh" title="wikilink">Min-Hsiu Hsieh</a> also constructed the <a href="entanglement-assisted_stabilizer_formalism" title="wikilink">entanglement-assisted stabilizer formalism</a> as an extension of the standard <a href="stabilizer_formalism" title="wikilink">stabilizer formalism</a> that incorporates <a href="quantum_entanglement" title="wikilink">quantum entanglement</a> shared between a sender and a receiver.</li>
</ul>

<p>That these codes allow indeed for quantum computations of arbitrary length is the content of the <em>threshold theorem</em>, found by <a href="Michael_Ben-Or" title="wikilink">Michael Ben-Or</a> and <a href="Dorit_Aharonov" title="wikilink">Dorit Aharonov</a>, which asserts that you can correct for all errors if you concatenate quantum codes such as the CSS codes—i.e. re-encode each logical qubit by the same code again, and so on, on logarithmically many levels—<em>provided</em> the error rate of individual <a href="quantum_gate" title="wikilink">quantum gates</a> is below a certain threshold; as otherwise, the attempts to measure the syndrome and correct the errors would introduce more new errors than they correct for.</p>

<p>As of late 2004, estimates for this threshold indicate that it could be as high as 1-3% <a href="http://www.arxiv.org/abs/quant-ph/0410199">4</a>, provided that there are sufficiently many <a href="qubit" title="wikilink">qubits</a> available.</p>
<h2 id="experimental-realization">Experimental realization</h2>

<p>There have been several experimental realizations of CSS-based codes. The first demonstration was with NMR qubits.<ref></ref></p>

<p>D. G. Cory, M. D. Price, W. Maas, E. Knill, R. Laflamme, W. H. Zurek, T. F. Havel and S. S. Somaroo, "Experimental Quantum Error Correction," <em>Phys. Rev. Lett.</em> <strong>81</strong>, 2152–2155 (1998),  Subsequently demonstrations have been made with linear optics,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> trapped ions,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and superconducting (<a class="uri" href="transmon" title="wikilink">transmon</a>) qubits.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Other error correcting codes have also been implemented, such as one aimed at correcting for photon loss, the dominant error source in photonic qubit schemes.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>Freedman, Michael H.; Meyer, David A.; Luo, Feng: Z<sub>2</sub>-<a href="Systolic_freedom" title="wikilink">Systolic freedom</a> and quantum codes. <em>Mathematics of quantum computation</em>, 287–320, Comput. Math. Ser., Chapman &amp; Hall/CRC, Boca Raton, FL, 2002.</li>
</ul>
<ul>
<li>Freedman, Michael H.; Meyer, David A.: <a href="real_projective_plane" title="wikilink">Projective plane</a> and planar quantum codes. <em>Found. Comput. Math.</em> 1 (2001), no. 3, 325–332.</li>
</ul>
<ul>
<li>Mikael Lassen, Metin Sabuncu, Alexander Huck, Julien Niset, Gerd Leuchs, Nicolas J. Cerf, Ulrik L. Andersen, '' Quantum optical coherence can survive photon losses using a continuous-variable quantum erasure-correcting code '', <a href="Nature_Photonics" title="wikilink">Nature Photonics</a> <strong>4</strong> 10 (2010)(<a href="http://www.nature.com/nphoton/journal/v4/n10/full/nphoton.2010.168.html">this document online</a>)</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Error_detection_and_correction" title="wikilink">Error detection and correction</a></li>
<li><a href="Soft_error" title="wikilink">Soft error</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.arxiv.org/abs/quant-ph/0410199">Prospects</a></li>
<li>[<a class="uri" href="http://www.newscientisttech.com/article.ns?id=dn9301&amp;feedId">http://www.newscientisttech.com/article.ns?id=dn9301&amp;feedId;</a>;=online-news_rss20 Error-check breakthrough in quantum computing]</li>
<li>[<a class="uri" href="http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1">http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1;</a>;=362347 Quantum error correction on arxiv.org]</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a href="Category:Quantum_computing" title="wikilink">Category:Quantum computing</a> <a href="Category:Fault-tolerant_computer_systems" title="wikilink">Category:Fault-tolerant computer systems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">T. B. Pittman, B. C. Jacobs and J. D. Franson, "Demonstration of quantum error correction using linear optics," <em>Phys. Rev. A</em> <strong>71</strong>, 052332 (2005), <a href="#fnref3">↩</a></li>
<li id="fn4">J. Chiaverini, D. Leibfried, T. Schaetz, M. D. Barrett, R. B. Blakestad, J. Britton, W. M. Itano, J. D. Jost, E. Knill, C. Langer, R. Ozeri and D. J. Wineland, "Realization of quantum error correction," <em>Nature</em> <strong>432</strong>, 602-605 (2004), <a href="#fnref4">↩</a></li>
<li id="fn5">P. Schindler, J. T. Barreiro, T. Monz, V. Nebendahl, D. Nigg, M. Chwalla, M. Hennrich and R. Blatt, "Experimental Repetitive Quantum Error Correction," <em>Science</em> <strong>332</strong>, 1059-1061 (2011), <a href="#fnref5">↩</a></li>
<li id="fn6">M. D. Reed, L. DiCarlo, S. E. Nigg, L. Sun, L. Frunzio, S. M. Girvin and R. J. Schoelkopf, "Realization of Three-Qubit Quantum Error Correction with Superconducting Circuits," <em>Nature</em> <strong>482</strong>, 382-385 (2012), , <a href="http://arxiv.org/abs/1109.4948">arXiv:1109.4948</a><a href="#fnref6">↩</a></li>
<li id="fn7">M. Lassen, M. Sabuncu, A. Huck, J. Niset, G. Leuchs, N. J. Cerf and U. L. Andersen, "Quantum optical coherence can survive photon losses using a continuous-variable quantum erasure-correcting code," <em>Nature Photonics</em> 4, 700 (2010), <a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
