<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1646">Vertex cover</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Vertex cover</h1>
<hr/>

<p>In the <a href="mathematics" title="wikilink">mathematical</a> discipline of <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>vertex cover</strong> (sometimes <strong>node cover</strong>) of a <a href="graph_(mathematics)" title="wikilink">graph</a> is a set of vertices such that each edge of the graph is <a href="graph_(mathematics)" title="wikilink">incident</a> to at least one vertex of the set. The problem of finding a <strong>minimum vertex cover</strong> is a classical <a href="optimization_problem" title="wikilink">optimization problem</a> in <a href="computer_science" title="wikilink">computer science</a> and is a typical example of an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> optimization problem that has an <a href="approximation_algorithm" title="wikilink">approximation algorithm</a>. Its <a href="decision_problem" title="wikilink">decision version</a>, the <strong>vertex cover problem</strong>, was one of <a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a> and is therefore a classical <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>. Furthermore, the vertex cover problem is <a href="fixed-parameter_tractable" title="wikilink">fixed-parameter tractable</a> and a central problem in <a href="parameterized_complexity" title="wikilink">parameterized complexity theory</a>.</p>

<p>The minimum vertex cover problem can be formulated as a <a class="uri" href="half-integral" title="wikilink">half-integral</a> <a href="linear_program" title="wikilink">linear program</a> whose <a href="dual_linear_program" title="wikilink">dual linear program</a> is the <a href="maximum_matching_problem" title="wikilink">maximum matching problem</a>.</p>
<h2 id="definition">Definition</h2>

<p>Formally, a vertex-cover of an undirected graph 

<math display="inline" id="Vertex_cover:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 is a subset <em>V′</em> of <em>V</em> such that if edge <em>(u, v)</em> is an edge of <em>G</em>, then <em>u</em> is in <em>V′</em>, or <em>v</em> is in <em>V′</em>, or both. The set <em>V′</em> is said to "cover" the edges of <em>G</em>. The following figure shows examples of vertex covers in two graphs (and the set <em>V</em>' is marked with red).</p>
<dl>
<dd>
</dd>
</dl>

<p>A minimum vertex cover is a vertex cover of smallest possible size. The vertex cover number 

<math display="inline" id="Vertex_cover:1">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 is the size of a minimum vertex cover. The following figure shows examples of minimum vertex covers in the previous graphs.</p>
<dl>
<dd>
</dd>
</dl>
<h3 id="examples">Examples</h3>
<ul>
<li>The set of all vertices is a vertex cover.</li>
<li>The endpoints of any <a href="maximal_matching" title="wikilink">maximal matching</a> form a vertex cover.</li>
<li>The <a href="complete_bipartite_graph" title="wikilink">complete bipartite graph</a> 

<math display="inline" id="Vertex_cover:2">
 <semantics>
  <msub>
   <mi>K</mi>
   <mrow>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <list>
     <ci>m</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{m,n}
  </annotation>
 </semantics>
</math>

 has a minimum vertex cover of size 

<math display="inline" id="Vertex_cover:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>K</mi>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>τ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <list>
       <ci>m</ci>
       <ci>n</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <min></min>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(K_{m,n})=\min(m,n)
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h3 id="properties">Properties</h3>
<ul>
<li>A set of vertices is a vertex cover if and only if its <a href="complement_(set_theory)" title="wikilink">complement</a> is an <a href="independent_set_(graph_theory)" title="wikilink">independent set</a>.</li>
<li>Consequently, the number of vertices of a graph is equal to its minimum vertex cover number plus the size of a maximum independent set (<a href="Tibor_Gallai" title="wikilink">Gallai</a> 1959).</li>
</ul>
<h2 id="computational-problem">Computational problem</h2>

<p>The <strong>minimum vertex cover problem</strong> is the <a href="optimization_problem" title="wikilink">optimization problem</a> of finding a smallest vertex cover in a given graph.</p>
<dl>
<dd>INSTANCE: Graph 

<math display="inline" id="Vertex_cover:4">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


</dd>
<dd>OUTPUT: Smallest number 

<math display="inline" id="Vertex_cover:5">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Vertex_cover:6">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 has a vertex cover of size 

<math display="inline" id="Vertex_cover:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>If the problem is stated as a <a href="decision_problem" title="wikilink">decision problem</a>, it is called the <strong>vertex cover problem</strong>:</p>
<dl>
<dd>INSTANCE: Graph 

<math display="inline" id="Vertex_cover:8">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and positive integer 

<math display="inline" id="Vertex_cover:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>QUESTION: Does 

<math display="inline" id="Vertex_cover:10">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 have a vertex cover of size at most 

<math display="inline" id="Vertex_cover:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

?
</dd>
</dl>

<p>The vertex cover problem is an <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem: it was one of <a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a>. It is often used in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> as a starting point for <a href="NP-hard" title="wikilink">NP-hardness</a> proofs.</p>
<h3 id="ilp-formulation">ILP formulation</h3>

<p>Assume that every vertex has an associated cost of 

<math display="inline" id="Vertex_cover:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>v</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(v)\geq 0
  </annotation>
 </semantics>
</math>

. The (weighted) minimum vertex cover problem can be formulated as the following <a href="integer_linear_program" title="wikilink">integer linear program</a> (ILP).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>minimize</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Vertex_cover:13">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mi>V</mi>
    </mrow>
   </msub>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>x</mi>
     <mi>v</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>v</ci>
      <ci>V</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>v</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{v\in V}c(v)x_{v}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>  </p></td>
<td style="text-align: left;">
<p>(minimize the total cost)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>subject to</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Vertex_cover:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>u</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mi>v</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{u}+x_{v}\geq 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>for all 

<math display="inline" id="Vertex_cover:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <set>
     <ci>u</ci>
     <ci>v</ci>
    </set>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{u,v\}\in E
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Vertex_cover:16">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>v</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>v</ci>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{v}\in\{0,1\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>for all 

<math display="inline" id="Vertex_cover:17">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

.</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>This ILP belongs to the more general class of ILPs for <a href="covering_problem" title="wikilink">covering problems</a>. The <a href="Linear_programming_relaxation#Approximation_and_integrality_gap" title="wikilink">integrality gap</a> of this ILP is 

<math display="inline" id="Vertex_cover:18">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

, so its <a href="Linear_programming_relaxation" title="wikilink">relaxation</a> gives a factor-

<math display="inline" id="Vertex_cover:19">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

 <a href="approximation_algorithm" title="wikilink">approximation algorithm</a> for the minimum vertex cover problem. Furthermore, the linear programming relaxation of that ILP is <em>half-integral</em>, that is, there exists an optimal solution for which each entry 

<math display="inline" id="Vertex_cover:20">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{v}
  </annotation>
 </semantics>
</math>

 is either 0, 1/2, or 1.</p>
<h3 id="exact-evaluation">Exact evaluation</h3>

<p>The <a href="decision_problem" title="wikilink">decision</a> variant of the vertex cover problem is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, which means it is unlikely that there is an efficient algorithm to solve it exactly. NP-completeness can be proven by reduction from <a href="Boolean_satisfiability_problem" title="wikilink">3-satisfiability</a> or, as Karp did, by reduction from the <a href="clique_problem" title="wikilink">clique problem</a>. Vertex cover remains NP-complete even in <a href="cubic_graph" title="wikilink">cubic graphs</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and even in <a href="planar_graph" title="wikilink">planar graphs</a> of degree at most 3.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>For <a href="bipartite_graph" title="wikilink">bipartite graphs</a>, the equivalence between vertex cover and maximum matching described by <a href="König's_theorem_(graph_theory)" title="wikilink">König's theorem</a> allows the bipartite vertex cover problem to be solved in <a href="polynomial_time" title="wikilink">polynomial time</a>.</p>

<p>For <a href="tree_graph" title="wikilink">tree graphs</a>, a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> finds a minimal vertex cover in polynomial time.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h4 id="fixed-parameter-tractability">Fixed-parameter tractability</h4>

<p>An <a href="Brute-force_search" title="wikilink">exhaustive search</a> algorithm can solve the problem in time 2<sup>k</sup><em>n</em><sup><em>O</em>(1)</sup>. Vertex cover is therefore <a href="fixed-parameter_tractable" title="wikilink">fixed-parameter tractable</a>, and if we are only interested in small <em>k</em>, we can solve the problem in <a href="polynomial_time" title="wikilink">polynomial time</a>. One algorithmic technique that works here is called <em>bounded search tree algorithm</em>, and its idea is to repeatedly choose some vertex and recursively branch, with two cases at each step: place either the current vertex or all its neighbours into the vertex cover. The algorithm for solving vertex cover that achieves the best asymptotic dependence on the parameter runs in time 

<math display="inline" id="Vertex_cover:21">
 <semantics>
  <mrow>
   <msup>
    <mn>1.2738</mn>
    <mi>k</mi>
   </msup>
   <mo>⋅</mo>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="float">1.2738</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1.2738^{k}\cdot n^{O(1)}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Under reasonable complexity-theoretic assumptions, namely the <a href="exponential_time_hypothesis" title="wikilink">exponential time hypothesis</a>, this running time cannot be improved to 2<sup><em>o</em>(<em>k</em>)</sup><em>n</em><sup><em>O</em>(1)</sup>.</p>

<p>However, for <a href="planar_graph" title="wikilink">planar graphs</a>, and more generally, for graphs excluding some fixed graph as a minor, a vertex cover of size <em>k</em> can be found in time <em>

<math display="inline" id="Vertex_cover:22">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mi>k</mi>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <root></root>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(\sqrt{k})}n^{O(1)}
  </annotation>
 </semantics>
</math>

</em>, i.e., the problem is subexponential <a href="fixed-parameter_tractable" title="wikilink">fixed-parameter tractable</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This algorithm is again optimal, in the sense that, under the <a href="exponential_time_hypothesis" title="wikilink">exponential time hypothesis</a>, no algorithm can solve vertex cover on planar graphs in time <em>

<math display="inline" id="Vertex_cover:23">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mi>k</mi>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <root></root>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{o(\sqrt{k})}n^{O(1)}
  </annotation>
 </semantics>
</math>

</em>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="approximate-evaluation">Approximate evaluation</h3>

<p>One can find a factor-2 <a href="approximation_algorithm" title="wikilink">approximation</a> by repeatedly taking <em>both</em> endpoints of an edge into the vertex cover, then removing them from the graph. Put otherwise, we find a <a href="maximal_matching" title="wikilink">maximal matching</a> <em>M</em> with a greedy algorithm and construct a vertex cover <em>C</em> that consists of all endpoints of the edges in <em>M</em>. In the following figure, a maximal matching <em>M</em> is marked with red, and the vertex cover <em>C</em> is marked with blue.</p>
<dl>
<dd>
</dd>
</dl>

<p>The set <em>C</em> constructed this way is a vertex cover: suppose that an edge <em>e</em> is not covered by <em>C</em>; then <em>M</em> ∪ {<em>e</em>} is a matching and <em>e</em> ∉ <em>M</em>, which is a contradiction with the assumption that <em>M</em> is maximal. Furthermore, if <em>e</em> = {<em>u</em>, <em>v</em>} ∈ <em>M</em>, then any vertex cover – including an optimal vertex cover – must contain <em>u</em> or <em>v</em> (or both); otherwise the edge <em>e</em> is not covered. That is, an optimal cover contains at least <em>one</em> endpoint of each edge in <em>M</em>; in total, the set <em>C</em> is at most 2 times as large as the optimal vertex cover.</p>

<p>This simple algorithm was discovered independently by Fanica Gavril and <a href="Mihalis_Yannakakis" title="wikilink">Mihalis Yannakakis</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>More involved techniques show that there are approximation algorithms with a slightly better approximation factor. For example, an approximation algorithm with an approximation factor of 

<math display="inline" id="Vertex_cover:24">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>-</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <msqrt>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>V</mi>
         <mo stretchy="false">|</mo>
        </mrow>
       </mrow>
      </msqrt>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>normal-Θ</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <log></log>
        <apply>
         <abs></abs>
         <ci>V</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2-\Theta\left(1/\sqrt{\log|V|}\right)
  </annotation>
 </semantics>
</math>

 is known.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The problem can be approximated with an approximation factor 

<math display="inline" id="Vertex_cover:25">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mi>δ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">2</cn>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2/(1+\delta)
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Vertex_cover:26">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 - dense graphs.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h4 id="inapproximability">Inapproximability</h4>

<p>No better <a href="constant-factor_approximation_algorithm" title="wikilink">constant-factor approximation algorithm</a> than the above one is known. The minimum vertex cover problem is <a href="APX" title="wikilink">APX-complete</a>, that is, it cannot be approximated arbitrarily well unless <a href="P_=_NP_problem" title="wikilink"><strong>P</strong> = <strong>NP</strong></a>. Using techniques from the <a href="PCP_theorem" title="wikilink">PCP theorem</a>, <a href="Irit_Dinur" title="wikilink">Dinur</a> and <a href="Shmuel_Safra" title="wikilink">Safra</a> proved in 2005 that minimum vertex cover cannot be approximated within a factor of 1.3606 for any sufficiently large vertex degree unless <strong>P</strong> = <strong>NP</strong>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Moreover, if the <a href="unique_games_conjecture" title="wikilink">unique games conjecture</a> is true then minimum vertex cover cannot be approximated within any constant factor better than 2.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>Although finding the minimum-size vertex cover is equivalent to finding the maximum-size independent set, as described above, the two problems are not equivalent in an approximation-preserving way: The Independent Set problem has <em>no</em> constant-factor approximation unless <strong>P</strong> = <strong>NP</strong>.</p>
<h4 id="pseudo-code">Pseudo Code</h4>

<p>APPROX VERTEX COVER(G)<br/>
C=∅<br/>
E'= G.E<br/>
while E'≠ ∅<br/>
:let (u,v) be an arbitrary edge of E'<br/>
:C = C ∪ {u,v}<br/>
:remove from E' every edge incident on either u or v<br/>
return C<br/>
<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="vertex-cover-in-hypergraphs">Vertex cover in hypergraphs</h2>

<p>Given a collection of sets, a set which intersects all sets in the collection in at least one element is called a <strong>hitting set</strong>, and a simple NP-hard problem is to find a hitting set of smallest size or <strong>minimum hitting set</strong>. By mapping the sets in the collection onto hyperedges, this can be understood as a natural generalization of the vertex cover problem to <a href="hypergraph" title="wikilink">hypergraphs</a> which is often just called <strong>vertex cover for hypergraphs</strong> and, in a more combinatorial context, <strong><a href="Hypergraph#Transversals" title="wikilink">transversal</a></strong>. The notions of hitting set and <a href="set_cover" title="wikilink">set cover</a> are equivalent.</p>

<p>Formally, let <em>H</em> = (<em>V</em>, <em>E</em>) be a hypergraph with vertex set <em>V</em> and hyperedge set <em>E</em>. Then a set <em>S</em> ⊆ <em>V</em> is called <em>hitting set</em> of <em>H</em> if, for all edges <em>e</em> ∈ <em>E</em>, it holds <em>S</em> ∩ <em>e</em> ≠ ∅. The computational problems <em>minimum hitting set</em> and <em>hitting set</em> are defined as in the case of graphs. Note that we get back the case of vertex covers for simple graphs if the maximum size of the hyperedges is 2.</p>

<p>If that size is restricted to <em>d</em>, the problem of finding a minimum <em>d</em>-hitting set permits a <a href="K-approximation_of_k-hitting_set" title="wikilink"><em>d</em>-approximation</a> algorithm. Assuming the <a href="unique_games_conjecture" title="wikilink">unique games conjecture</a>, this is the best constant-factor algorithm that is possible and otherwise there is the possibility of improving the approximation to <em>d</em> − 1.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="fixed-parameter-tractability-1">Fixed-parameter tractability</h3>

<p>For the hitting set problem, different <a href="fixed-parameter_tractable" title="wikilink">parameterizations</a> make sense.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The hitting set problem is <em>W</em>[2]-complete for the parameter OPT, that is, it is unlikely that there is an algorithm that runs in time <em>f</em>(OPT)<em>n</em><sup><em>O</em>(1)</sup> where OPT is the cardinality of the smallest hitting set. The hitting set problem is fixed-parameter tractable for the parameter OPT + <em>d</em>, where <em>d</em> is the size of the largest edge of the hypergraph. More specifically, there is an algorithm for hitting set that runs in time <em>d</em><sup>OPT</sup><em>n</em><sup><em>O</em>(1)</sup>.</p>
<h3 id="hitting-set-and-set-cover">Hitting set and set cover</h3>

<p>The hitting set problem is equivalent to the <a href="set_cover_problem" title="wikilink">set cover problem</a>: An instance of set cover can be viewed as an arbitrary bipartite graph, with sets represented by vertices on the left, elements of the universe represented by vertices on the right, and edges representing the inclusion of elements in sets. The task is then to find a minimum cardinality subset of left-vertices which covers all of the right-vertices. In the hitting set problem, the objective is to cover the left-vertices using a minimum subset of the right vertices. Converting from one problem to the other is therefore achieved by interchanging the two sets of vertices.</p>
<h3 id="applications">Applications</h3>

<p>An example of a practical application involving the hitting set problem arises in efficient dynamic detection of <a href="race_condition" title="wikilink">race conditions</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> In this case, each time global memory is written, the current thread and set of locks held by that thread are stored. Under lockset-based detection, if later another thread writes to that location and there is <em>not</em> a race, it must be because it holds at least one lock in common with each of the previous writes. Thus the size of the hitting set represents the minimum lock set size to be race-free. This is useful in eliminating redundant write events, since large lock sets are considered unlikely in practice.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>A1.1: GT1, pg.190.</p></li>
<li></li>
<li>Gallai, Tibor "Über extreme Punkt- und Kantenmengen." Ann. Univ. Sci. Budapest, Eötvös Sect. Math. <strong>2</strong>, 133-138, 1959.</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_problems_in_graph_theory" title="wikilink">Category:Computational problems in graph theory</a> <a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">; , pp. 190 and 195.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">, p. 432, mentions both Gavril and Yannakakis. , p. 134, cites Gavril.<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
</ol>
</section>
</body>
</html>
