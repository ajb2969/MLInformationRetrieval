<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1190">Tikhonov regularization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Tikhonov regularization</h1>
<hr/>

<p><strong>Tikhonov regularization</strong>, named for <a href="Andrey_Nikolayevich_Tikhonov" title="wikilink">Andrey Tikhonov</a>, is the most commonly used method of <a href="regularization_(mathematics)" title="wikilink">regularization</a> of <a href="ill-posed_problem" title="wikilink">ill-posed problems</a>. In <a class="uri" href="statistics" title="wikilink">statistics</a>, the method is known as <strong>ridge regression</strong>, and with multiple independent discoveries, it is also variously known as the <strong>Tikhonov–Miller method</strong>, the <strong>Phillips–Twomey method</strong>, the <strong>constrained linear inversion</strong> method, and the method of <strong>linear regularization</strong>. It is related to the <a href="Levenberg–Marquardt_algorithm" title="wikilink">Levenberg–Marquardt algorithm</a> for <a href="non-linear_least_squares" title="wikilink">non-linear least-squares</a> problems.</p>

<p>When the following problem is not <a href="Well-posed_problem" title="wikilink">well posed</a> (either because of non-existence or non-uniqueness of 

<math display="inline" id="Tikhonov_regularization:0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

)</p>

<p>

<math display="block" id="Tikhonov_regularization:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>𝐱</mi>
    </mrow>
    <mo>=</mo>
    <mi>𝐛</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>𝐱</ci>
    </apply>
    <ci>𝐛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\mathbf{x}=\mathbf{b},
  </annotation>
 </semantics>
</math>

 then the standard approach (known as <a href="ordinary_least_squares" title="wikilink">ordinary least squares</a>) leads to an <a href="Overdetermined_system" title="wikilink">overdetermined</a>, or more often an <a href="Underdetermined_system" title="wikilink">underdetermined</a> system of equations. Most real-world phenomena operate as low-pass filters in the forward direction where 

<math display="inline" id="Tikhonov_regularization:2">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 maps 

<math display="inline" id="Tikhonov_regularization:3">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Tikhonov_regularization:4">
 <semantics>
  <mi>𝐛</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{b}
  </annotation>
 </semantics>
</math>

. Therefore in solving the inverse-problem, the inverse-mapping operates as a high-pass filter that has the undesirable tendency of amplifying noise (eigenvalues / singular values are largest in the reverse mapping where they were smallest in the forward mapping). In addition, ordinary least squares implicitly nullifies every element of the reconstructed version of 

<math display="inline" id="Tikhonov_regularization:5">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 that is in the null-space of 

<math display="inline" id="Tikhonov_regularization:6">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, rather than allowing for a model to be used as a prior for 

<math display="inline" id="Tikhonov_regularization:7">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

. Ordinary least squares seeks to minimize the sum of squared <a href="Residual_(numerical_analysis)" title="wikilink">residuals</a>, which can be compactly written as</p>

<p>

<math display="block" id="Tikhonov_regularization:8">
 <semantics>
  <msup>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mi>𝐱</mi>
     </mrow>
     <mo>-</mo>
     <mi>𝐛</mi>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>𝐱</ci>
      </apply>
      <ci>𝐛</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|A\mathbf{x}-\mathbf{b}\|^{2}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Tikhonov_regularization:9">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mo>⋅</mo>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-∥</ci>
    <ci>normal-⋅</ci>
    <ci>normal-∥</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|\cdot\right\|
  </annotation>
 </semantics>
</math>

 is the <a href="Norm_(mathematics)#Euclidean_norm" title="wikilink">Euclidean norm</a>. In order to give preference to a particular solution with desirable properties, a regularization term can be included in this minimization:</p>

<p>

<math display="block" id="Tikhonov_regularization:10">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>𝐱</mi>
      </mrow>
      <mo>-</mo>
      <mi>𝐛</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mi>𝐱</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>𝐱</ci>
       </apply>
       <ci>𝐛</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <ci>𝐱</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|A\mathbf{x}-\mathbf{b}\|^{2}+\|\Gamma\mathbf{x}\|^{2}
  </annotation>
 </semantics>
</math>

 for some suitably chosen <strong>Tikhonov matrix</strong>, 

<math display="inline" id="Tikhonov_regularization:11">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

. In many cases, this matrix is chosen as a multiple of the <a href="identity_matrix" title="wikilink">identity matrix</a> (

<math display="inline" id="Tikhonov_regularization:12">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>=</mo>
   <mrow>
    <mi>α</mi>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Γ</ci>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma=\alpha I
  </annotation>
 </semantics>
</math>

), giving preference to solutions with smaller <a href="Norm_(mathematics)" title="wikilink">norms</a>; this is known as <strong><mtpl></mtpl> regularization</strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In other cases, <a class="uri" href="lowpass" title="wikilink">lowpass</a> operators (e.g., a <a href="difference_operator" title="wikilink">difference operator</a> or a weighted <a href="discrete_fourier_transform" title="wikilink">Fourier operator</a>) may be used to enforce smoothness if the underlying vector is believed to be mostly continuous. This regularization improves the conditioning of the problem, thus enabling a direct numerical solution. An explicit solution, denoted by 

<math display="inline" id="Tikhonov_regularization:13">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}
  </annotation>
 </semantics>
</math>

, is given by:</p>

<p>

<math display="block" id="Tikhonov_regularization:14">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>A</mi>
         <mi>T</mi>
        </msup>
        <mi>A</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msup>
         <mi mathvariant="normal">Γ</mi>
         <mi>T</mi>
        </msup>
        <mi mathvariant="normal">Γ</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>A</mi>
     <mi>T</mi>
    </msup>
    <mi>𝐛</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>T</ci>
        </apply>
        <ci>A</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Γ</ci>
         <ci>T</ci>
        </apply>
        <ci>normal-Γ</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>T</ci>
     </apply>
     <ci>𝐛</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}=(A^{T}A+\Gamma^{T}\Gamma)^{-1}A^{T}\mathbf{b}
  </annotation>
 </semantics>
</math>

 The effect of regularization may be varied via the scale of matrix 

<math display="inline" id="Tikhonov_regularization:15">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

. For 

<math display="inline" id="Tikhonov_regularization:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Γ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma=0
  </annotation>
 </semantics>
</math>

 this reduces to the unregularized least squares solution provided that (A<sup>T</sup>A)<sup>−1</sup> exists.</p>

<p><mtpl></mtpl> regularization is used in many contexts aside from linear regression, such as <a href="Statistical_classification" title="wikilink">classification</a> with <a href="logistic_regression" title="wikilink">logistic regression</a> or <a href="support_vector_machine" title="wikilink">support vector machines</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and matrix factorization.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="history">History</h2>

<p>Tikhonov regularization has been invented independently in many different contexts. It became widely known from its application to integral equations from the work of <a href="Andrey_Nikolayevich_Tikhonov" title="wikilink">Andrey Tikhonov</a> and David L. Phillips. Some authors use the term <strong>Tikhonov–Phillips regularization</strong>. The finite-dimensional case was expounded by Arthur E. Hoerl, who took a statistical approach, and by Manus Foster, who interpreted this method as a <a href="Norbert_Wiener" title="wikilink">Wiener</a>–<a href="Andrey_Nikolaevich_Kolmogorov" title="wikilink">Kolmogorov</a> filter. Following Hoerl, it is known in the statistical literature as <strong>ridge regression</strong>.</p>
<h2 id="generalized-tikhonov-regularization">Generalized Tikhonov regularization</h2>

<p>For general multivariate normal distributions for 

<math display="inline" id="Tikhonov_regularization:17">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and the data error, one can apply a transformation of the variables to reduce to the case above. Equivalently, one can seek an 

<math display="inline" id="Tikhonov_regularization:18">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to minimize</p>

<p>

<math display="block" id="Tikhonov_regularization:19">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>x</mi>
      </mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mi>P</mi>
    <mn>2</mn>
   </msubsup>
   <mo>+</mo>
   <mpadded width="+1.7pt">
    <msubsup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mi>Q</mi>
     <mn>2</mn>
    </msubsup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>P</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <ci>Q</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|Ax-b\|_{P}^{2}+\|x-x_{0}\|_{Q}^{2}\,
  </annotation>
 </semantics>
</math>

</p>

<p>where we have used 

<math display="inline" id="Tikhonov_regularization:20">
 <semantics>
  <msubsup>
   <mrow>
    <mo>∥</mo>
    <mi>x</mi>
    <mo>∥</mo>
   </mrow>
   <mi>Q</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
     <ci>Q</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|x\right\|_{Q}^{2}
  </annotation>
 </semantics>
</math>

 to stand for the weighted norm 

<math display="inline" id="Tikhonov_regularization:21">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mi>T</mi>
   </msup>
   <mi>Q</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>T</ci>
    </apply>
    <ci>Q</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{T}Qx
  </annotation>
 </semantics>
</math>

 (compare with the <a href="Mahalanobis_distance" title="wikilink">Mahalanobis distance</a>). In the Bayesian interpretation 

<math display="inline" id="Tikhonov_regularization:22">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the inverse <a href="covariance_matrix" title="wikilink">covariance matrix</a> of 

<math display="inline" id="Tikhonov_regularization:23">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Tikhonov_regularization:24">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 is the <a href="expected_value" title="wikilink">expected value</a> of 

<math display="inline" id="Tikhonov_regularization:25">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Tikhonov_regularization:26">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is the inverse covariance matrix of 

<math display="inline" id="Tikhonov_regularization:27">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. The Tikhonov matrix is then given as a factorization of the matrix 

<math display="inline" id="Tikhonov_regularization:28">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Γ</mi>
     <mi>T</mi>
    </msup>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Γ</ci>
      <ci>T</ci>
     </apply>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\Gamma^{T}\Gamma
  </annotation>
 </semantics>
</math>

 (e.g. the <a href="Cholesky_factorization" title="wikilink">Cholesky factorization</a>), and is considered a <a href="Whitening_transformation" title="wikilink">whitening filter</a>.</p>

<p>This generalized problem has an optimal solution 

<math display="inline" id="Tikhonov_regularization:29">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 which can be solved explicitly using the formula</p>

<p>

<math display="block" id="Tikhonov_regularization:30">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msup>
          <mi>A</mi>
          <mi>T</mi>
         </msup>
         <mi>P</mi>
         <mi>A</mi>
        </mrow>
        <mo>+</mo>
        <mi>Q</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>A</mi>
         <mi>T</mi>
        </msup>
        <mi>P</mi>
        <mi>b</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>Q</mi>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>T</ci>
        </apply>
        <ci>P</ci>
        <ci>A</ci>
       </apply>
       <ci>Q</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>T</ci>
       </apply>
       <ci>P</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}=(A^{T}PA+Q)^{-1}(A^{T}Pb+Qx_{0}).\,
  </annotation>
 </semantics>
</math>

</p>

<p>or equivalently</p>

<p>

<math display="block" id="Tikhonov_regularization:31">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <msup>
           <mi>A</mi>
           <mi>T</mi>
          </msup>
          <mi>P</mi>
          <mi>A</mi>
         </mrow>
         <mo>+</mo>
         <mi>Q</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>A</mi>
         <mi>T</mi>
        </msup>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>b</mi>
          <mo>-</mo>
          <mrow>
           <mi>A</mi>
           <msub>
            <mi>x</mi>
            <mn>0</mn>
           </msub>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>A</ci>
          <ci>T</ci>
         </apply>
         <ci>P</ci>
         <ci>A</ci>
        </apply>
        <ci>Q</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>T</ci>
       </apply>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <ci>b</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}=x_{0}+(A^{T}PA+Q)^{-1}(A^{T}P(b-Ax_{0})).\,
  </annotation>
 </semantics>
</math>

</p>
<h2 id="regularization-in-hilbert-space">Regularization in Hilbert space</h2>

<p>Typically discrete linear ill-conditioned problems result from discretization of <a href="integral_equation" title="wikilink">integral equations</a>, and one can formulate a Tikhonov regularization in the original infinite-dimensional context. In the above we can interpret 

<math display="inline" id="Tikhonov_regularization:32">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 as a <a href="compact_operator" title="wikilink">compact operator</a> on <a href="Hilbert_space" title="wikilink">Hilbert spaces</a>, and 

<math display="inline" id="Tikhonov_regularization:33">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tikhonov_regularization:34">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 as elements in the domain and range of 

<math display="inline" id="Tikhonov_regularization:35">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. The operator 

<math display="inline" id="Tikhonov_regularization:36">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>A</mi>
     <mo>*</mo>
    </msup>
    <mi>A</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Γ</mi>
     <mi>T</mi>
    </msup>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <times></times>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Γ</ci>
      <ci>T</ci>
     </apply>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{*}A+\Gamma^{T}\Gamma
  </annotation>
 </semantics>
</math>

 is then a <a href="Hermitian_adjoint" title="wikilink">self-adjoint</a> bounded invertible operator.</p>
<h2 id="relation-to-singular-value-decomposition-and-wiener-filter">Relation to singular value decomposition and Wiener filter</h2>

<p>With 

<math display="inline" id="Tikhonov_regularization:37">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>=</mo>
   <mrow>
    <mi>α</mi>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Γ</ci>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma=\alpha I
  </annotation>
 </semantics>
</math>

, this least squares solution can be analyzed in a special way via the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a>. Given the singular value decomposition of A</p>

<p>

<math display="block" id="Tikhonov_regularization:38">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mi mathvariant="normal">Σ</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>V</mi>
      <mi>T</mi>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>normal-Σ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=U\Sigma V^{T}\,
  </annotation>
 </semantics>
</math>

</p>

<p>with singular values 

<math display="inline" id="Tikhonov_regularization:39">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

, the Tikhonov regularized solution can be expressed as</p>

<p>

<math display="block" id="Tikhonov_regularization:40">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mi>D</mi>
    <msup>
     <mi>U</mi>
     <mi>T</mi>
    </msup>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>D</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <ci>T</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}=VDU^{T}b
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Tikhonov_regularization:41">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 has diagonal values</p>

<p>

<math display="block" id="Tikhonov_regularization:42">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mrow>
     <mi>i</mi>
     <mi>i</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>σ</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <msubsup>
      <mi>σ</mi>
      <mi>i</mi>
      <mn>2</mn>
     </msubsup>
     <mo>+</mo>
     <msup>
      <mi>α</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{ii}=\frac{\sigma_{i}}{\sigma_{i}^{2}+\alpha^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>and is zero elsewhere. This demonstrates the effect of the Tikhonov parameter on the <a href="condition_number" title="wikilink">condition number</a> of the regularized problem. For the generalized case a similar representation can be derived using a <a href="generalized_singular_value_decomposition" title="wikilink">generalized singular value decomposition</a>.</p>

<p>Finally, it is related to the <a href="Wiener_filter" title="wikilink">Wiener filter</a>:</p>

<p>

<math display="block" id="Tikhonov_regularization:43">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>q</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mfrac>
      <mrow>
       <msubsup>
        <mi>u</mi>
        <mi>i</mi>
        <mi>T</mi>
       </msubsup>
       <mi>b</mi>
      </mrow>
      <msub>
       <mi>σ</mi>
       <mi>i</mi>
      </msub>
     </mfrac>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>q</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <ci>i</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}=\sum_{i=1}^{q}f_{i}\frac{u_{i}^{T}b}{\sigma_{i}}v_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where the Wiener weights are 

<math display="inline" id="Tikhonov_regularization:44">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msubsup>
     <mi>σ</mi>
     <mi>i</mi>
     <mn>2</mn>
    </msubsup>
    <mrow>
     <msubsup>
      <mi>σ</mi>
      <mi>i</mi>
      <mn>2</mn>
     </msubsup>
     <mo>+</mo>
     <msup>
      <mi>α</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}=\frac{\sigma_{i}^{2}}{\sigma_{i}^{2}+\alpha^{2}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tikhonov_regularization:45">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is the <a href="Rank_(linear_algebra)" title="wikilink">rank</a> of 

<math display="inline" id="Tikhonov_regularization:46">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="determination-of-the-tikhonov-factor">Determination of the Tikhonov factor</h2>

<p>The optimal regularization parameter 

<math display="inline" id="Tikhonov_regularization:47">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is usually unknown and often in practical problems is determined by an <em>ad hoc</em> method. A possible approach relies on the Bayesian interpretation described below. Other approaches include the <a href="discrepancy_principle" title="wikilink">discrepancy principle</a>, <a href="cross-validation_(statistics)" title="wikilink">cross-validation</a>, <a href="L-curve_method" title="wikilink">L-curve method</a>, <a href="restricted_maximum_likelihood" title="wikilink">restricted maximum likelihood</a> and <a href="unbiased_predictive_risk_estimator" title="wikilink">unbiased predictive risk estimator</a>. <a href="Grace_Wahba" title="wikilink">Grace Wahba</a> proved that the optimal parameter, in the sense of <a href="cross-validation_(statistics)#Leave-one-out_cross-validation" title="wikilink">leave-one-out cross-validation</a> minimizes:</p>

<p>

<math display="block" id="Tikhonov_regularization:48">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mfrac>
    <mo>RSS</mo>
    <msup>
     <mi>τ</mi>
     <mn>2</mn>
    </msup>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mrow>
        <mi>X</mi>
        <mover accent="true">
         <mi>β</mi>
         <mo stretchy="false">^</mo>
        </mover>
       </mrow>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <msup>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mo>Tr</mo>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>I</mi>
         <mo>-</mo>
         <mrow>
          <mi>X</mi>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mrow>
              <msup>
               <mi>X</mi>
               <mi>T</mi>
              </msup>
              <mi>X</mi>
             </mrow>
             <mo>+</mo>
             <mrow>
              <msup>
               <mi>α</mi>
               <mn>2</mn>
              </msup>
              <mi>I</mi>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
          <msup>
           <mi>X</mi>
           <mi>T</mi>
          </msup>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>G</ci>
     <apply>
      <divide></divide>
      <ci>RSS</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>X</ci>
          <apply>
           <ci>normal-^</ci>
           <ci>β</ci>
          </apply>
         </apply>
         <ci>y</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <ci>Tr</ci>
         <apply>
          <minus></minus>
          <ci>I</ci>
          <apply>
           <times></times>
           <ci>X</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <plus></plus>
             <apply>
              <times></times>
              <apply>
               <csymbol cd="ambiguous">superscript</csymbol>
               <ci>X</ci>
               <ci>T</ci>
              </apply>
              <ci>X</ci>
             </apply>
             <apply>
              <times></times>
              <apply>
               <csymbol cd="ambiguous">superscript</csymbol>
               <ci>α</ci>
               <cn type="integer">2</cn>
              </apply>
              <ci>I</ci>
             </apply>
            </apply>
            <apply>
             <minus></minus>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>X</ci>
            <ci>T</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\frac{\operatorname{RSS}}{\tau^{2}}=\frac{\left\|X\hat{\beta}-y\right\|^{2}}%
{\left[\operatorname{Tr}\left(I-X(X^{T}X+\alpha^{2}I)^{-1}X^{T}\right)\right]^%
{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Tikhonov_regularization:49">
 <semantics>
  <mo>RSS</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>RSS</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{RSS}
  </annotation>
 </semantics>
</math>

 is the <a href="residual_sum_of_squares" title="wikilink">residual sum of squares</a> and 

<math display="inline" id="Tikhonov_regularization:50">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 is the effective number of <a href="Degrees_of_freedom_(statistics)" title="wikilink">degrees of freedom</a>.</p>

<p>Using the previous SVD decomposition, we can simplify the above expression:</p>

<p>

<math display="block" id="Tikhonov_regularization:51">
 <semantics>
  <mrow>
   <mo>RSS</mo>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>y</mi>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>q</mi>
        </munderover>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msubsup>
            <mi>u</mi>
            <mi>i</mi>
            <mo>′</mo>
           </msubsup>
           <mi>b</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>u</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>q</mi>
       </munderover>
       <mrow>
        <mfrac>
         <msup>
          <mi>α</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <msubsup>
           <mi>σ</mi>
           <mi>i</mi>
           <mn>2</mn>
          </msubsup>
          <mo>+</mo>
          <msup>
           <mi>α</mi>
           <mn>2</mn>
          </msup>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msubsup>
           <mi>u</mi>
           <mi>i</mi>
           <mo>′</mo>
          </msubsup>
          <mi>b</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>u</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>RSS</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>y</ci>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>q</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>u</ci>
             <ci>i</ci>
            </apply>
            <ci>normal-′</ci>
           </apply>
           <ci>b</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>u</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>q</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>α</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>σ</ci>
             <ci>i</ci>
            </apply>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>α</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>u</ci>
            <ci>i</ci>
           </apply>
           <ci>normal-′</ci>
          </apply>
          <ci>b</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{RSS}=\left\|y-\sum_{i=1}^{q}(u_{i}^{\prime}b)u_{i}\right\|^{2}+%
\left\|\sum_{i=1}^{q}\frac{\alpha^{2}}{\sigma_{i}^{2}+\alpha^{2}}(u_{i}^{%
\prime}b)u_{i}\right\|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Tikhonov_regularization:52">
 <semantics>
  <mrow>
   <mo>RSS</mo>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>RSS</mo>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>q</mi>
       </munderover>
       <mrow>
        <mfrac>
         <msup>
          <mi>α</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <msubsup>
           <mi>σ</mi>
           <mi>i</mi>
           <mn>2</mn>
          </msubsup>
          <mo>+</mo>
          <msup>
           <mi>α</mi>
           <mn>2</mn>
          </msup>
         </mrow>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msubsup>
           <mi>u</mi>
           <mi>i</mi>
           <mo>′</mo>
          </msubsup>
          <mi>b</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>u</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>RSS</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>RSS</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>q</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>α</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>σ</ci>
             <ci>i</ci>
            </apply>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>α</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>u</ci>
            <ci>i</ci>
           </apply>
           <ci>normal-′</ci>
          </apply>
          <ci>b</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{RSS}=\operatorname{RSS}_{0}+\left\|\sum_{i=1}^{q}\frac{\alpha^{2%
}}{\sigma_{i}^{2}+\alpha^{2}}(u_{i}^{\prime}b)u_{i}\right\|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Tikhonov_regularization:53">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mo>-</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>q</mi>
     </munderover>
     <mfrac>
      <msubsup>
       <mi>σ</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
      <mrow>
       <msubsup>
        <mi>σ</mi>
        <mi>i</mi>
        <mn>2</mn>
       </msubsup>
       <mo>+</mo>
       <msup>
        <mi>α</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mi>q</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>q</mi>
     </munderover>
     <mfrac>
      <msup>
       <mi>α</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <msubsup>
        <mi>σ</mi>
        <mi>i</mi>
        <mn>2</mn>
       </msubsup>
       <mo>+</mo>
       <msup>
        <mi>α</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>τ</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>q</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>i</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>σ</ci>
           <ci>i</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>q</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>α</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>σ</ci>
           <ci>i</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau=m-\sum_{i=1}^{q}\frac{\sigma_{i}^{2}}{\sigma_{i}^{2}+\alpha^{2}}=m-q+\sum%
_{i=1}^{q}\frac{\alpha^{2}}{\sigma_{i}^{2}+\alpha^{2}}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="relation-to-probabilistic-formulation">Relation to probabilistic formulation</h2>

<p>The probabilistic formulation of an <a href="inverse_problem" title="wikilink">inverse problem</a> introduces (when all uncertainties are Gaussian) a covariance matrix 

<math display="inline" id="Tikhonov_regularization:54">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>M</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{M}
  </annotation>
 </semantics>
</math>

 representing the <em>a priori</em> uncertainties on the model parameters, and a covariance matrix 

<math display="inline" id="Tikhonov_regularization:55">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>D</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{D}
  </annotation>
 </semantics>
</math>

 representing the uncertainties on the observed parameters (see, for instance, Tarantola, 2005 <a href="http://www.ipgp.jussieu.fr/~tarantola/Files/Professional/SIAM/index.html">1</a>). In the special case when these two matrices are diagonal and isotropic, 

<math display="inline" id="Tikhonov_regularization:56">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>M</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>σ</mi>
     <mi>M</mi>
     <mn>2</mn>
    </msubsup>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>M</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{M}=\sigma_{M}^{2}I
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tikhonov_regularization:57">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>D</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>σ</mi>
     <mi>D</mi>
     <mn>2</mn>
    </msubsup>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>D</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>D</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{D}=\sigma_{D}^{2}I
  </annotation>
 </semantics>
</math>

, and, in this case, the equations of inverse theory reduce to the equations above, with 

<math display="inline" id="Tikhonov_regularization:58">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mi>D</mi>
    </msub>
    <mo>/</mo>
    <msub>
     <mi>σ</mi>
     <mi>M</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>D</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha={\sigma_{D}}/{\sigma_{M}}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="bayesian-interpretation">Bayesian interpretation</h2>

<p>Although at first the choice of the solution to this regularized problem may look artificial, and indeed the matrix 

<math display="inline" id="Tikhonov_regularization:59">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 seems rather arbitrary, the process can be justified from a <a href="Bayesian_probability" title="wikilink">Bayesian point of view</a>. Note that for an ill-posed problem one must necessarily introduce some additional assumptions in order to get a unique solution. Statistically, the <a href="prior_probability" title="wikilink">prior probability</a> distribution of 

<math display="inline" id="Tikhonov_regularization:60">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is sometimes taken to be a <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distribution</a>. For simplicity here, the following assumptions are made: the means are zero; their components are independent; the components have the same <a href="standard_deviation" title="wikilink">standard deviation</a> 

<math display="inline" id="Tikhonov_regularization:61">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{x}
  </annotation>
 </semantics>
</math>

. The data are also subject to errors, and the errors in 

<math display="inline" id="Tikhonov_regularization:62">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 are also assumed to be <a href="statistical_independence" title="wikilink">independent</a> with zero mean and standard deviation 

<math display="inline" id="Tikhonov_regularization:63">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>b</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{b}
  </annotation>
 </semantics>
</math>

. Under these assumptions the Tikhonov-regularized solution is the <a href="maximum_a_posteriori" title="wikilink">most probable</a> solution given the data and the <em>a priori</em> distribution of 

<math display="inline" id="Tikhonov_regularization:64">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, according to <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>If the assumption of <a href="normal_distribution" title="wikilink">normality</a> is replaced by assumptions of <a class="uri" href="homoskedasticity" title="wikilink">homoskedasticity</a> and uncorrelatedness of <a href="errors_and_residuals_in_statistics" title="wikilink">errors</a>, and if one still assumes zero mean, then the <a href="Gauss–Markov_theorem" title="wikilink">Gauss–Markov theorem</a> entails that the solution is the minimal <a href="Bias_of_an_estimator" title="wikilink">unbiased estimator</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lasso_(statistics)#Lasso_method" title="wikilink">LASSO estimator</a> is another regularization method in statistics.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li>

<p>. Translated in </p></li>
<li></li>
<li>Tikhonov A.N., Goncharsky A.V., Stepanov V.V., Yagola A.G., 1995, <em>Numerical Methods for the Solution of Ill-Posed Problems</em>, Kluwer Academic Publishers.</li>
<li>Tikhonov A.N., Leonov A.S., Yagola A.G., 1998, <em>Nonlinear Ill-Posed Problems</em>, V. 1, V. 2, Chapman and Hall.</li>
<li>Hansen, P.C., 1998, <em>Rank-deficient and Discrete ill-posed problems</em>, SIAM</li>
<li>Hoerl AE, 1962, <em>Application of ridge analysis to regression problems</em>, Chemical Engineering Progress, 1958, 54–59.</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Tarantola A, 2005, <em>Inverse Problem Theory</em> (<a href="http://www.ipgp.jussieu.fr/~tarantola/Files/Professional/SIAM/index.html">free PDF version</a>), Society for Industrial and Applied Mathematics, ISBN 0-89871-572-5</li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Linear_algebra" title="wikilink">Category:Linear algebra</a> <a href="Category:Estimation_theory" title="wikilink">Category:Estimation theory</a> <a href="Category:Inverse_problems" title="wikilink">Category:Inverse problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
