<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1612">Church encoding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Church encoding</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>Church encoding</strong> is a means of representing data and operators in the <a href="lambda_calculus" title="wikilink">lambda calculus</a>. The data and operators form a mathematical structure which is <a href="embedding" title="wikilink">embedded</a> in the lambda calculus. The <strong>Church numerals</strong> are a representation of the natural numbers using lambda notation. The method is named for <a href="Alonzo_Church" title="wikilink">Alonzo Church</a>, who first encoded data in the lambda calculus this way.</p>

<p>Terms that are usually considered primitive in other notations (such as integers, booleans, pairs, lists, and tagged unions) are mapped to <a href="higher-order_function" title="wikilink">higher-order functions</a> under Church encoding. The <a href="Church-Turing_thesis" title="wikilink">Church-Turing thesis</a> asserts that any computable operator (and its operands) can be represented under Church encoding. In the <a href="Lambda_calculus" title="wikilink">untyped lambda calculus</a> the only primitive data type is the function.</p>

<p>The Church encoding is not intended as a practical implementation of primitive data types. Its use is to show that other primitives data types are not required to represent any calculation. The completeness is representational. Additional functions are needed to translate the representation into common data types, for display to people. It is not possible in general to decide if two functions are <a href="Extensionality" title="wikilink">extensionally</a> equal due to the <a href="Lambda_calculus#Undecidability_of_equivalence" title="wikilink">undecidability of equivalence</a> from <a href="Church's_theorem" title="wikilink">Church's theorem</a>. The translation may apply the function in some way to retrieve the value it represents, or look up its value as a literal lambda term.</p>

<p>Lambda calculus is usually interpreted as using <a href="Deductive_lambda_calculus#Intensional_versus_extensional_equality" title="wikilink">intensional equality</a>. There are <a href="Deductive_lambda_calculus#Intensional_versus_extensional_equality" title="wikilink">potential problems</a> with the interpretation of results because of the difference between the intensional and extensional definition of equality.</p>
<h2 id="church-numerals">Church numerals</h2>

<p>Church numerals are the representations of <a href="natural_number" title="wikilink">natural numbers</a> under Church encoding. The <a href="higher-order_function" title="wikilink">higher-order function</a> that represents natural number 

<math display="inline" id="Church_encoding:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is a function that maps any function 

<math display="inline" id="Church_encoding:1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 to its <em>n</em>-fold <a href="function_composition" title="wikilink">composition</a>. In simpler terms, the "value" of the numeral is equivalent to the number of times the function encapsulates its argument.</p>

<p>

<math display="block" id="Church_encoding:2">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mi>n</mi>
    </msup>
    <mo>=</mo>
    <munder>
     <munder accentunder="true">
      <mrow>
       <mi>f</mi>
       <mo movablelimits="false">∘</mo>
       <mi>f</mi>
       <mo movablelimits="false">∘</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo movablelimits="false">∘</mo>
       <mi>f</mi>
      </mrow>
      <mo movablelimits="false">⏟</mo>
     </munder>
     <mrow>
      <mi>n</mi>
      <mtext>times</mtext>
     </mrow>
    </munder>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-⏟</ci>
      <apply>
       <compose></compose>
       <ci>f</ci>
       <ci>f</ci>
       <ci>normal-⋯</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <mtext>times</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{n}=\underbrace{f\circ f\circ\cdots\circ f}_{n\text{ times}}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>All Church numerals are functions that take two parameters. Church numerals <strong>0</strong>, <strong>1</strong>, <strong>2</strong>, ..., are defined as follows in the <a href="lambda_calculus" title="wikilink">lambda calculus</a>.</p>

<p><em>Starting with</em> <code>zero</code> <em>not applying the function at all, proceed with</em> <code>one</code> <em>applying the function once, ...</em>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Number</p></th>
<th style="text-align: left;">
<p>Function definition</p></th>
<th style="text-align: left;">
<p>Lambda expression</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:3">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mn>0</mn>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">0</cn>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\ f\ x=x
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:4">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=\lambda f.\lambda x.x
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:5">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mn>1</mn>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\ f\ x=f\ x
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:6">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1=\lambda f.\lambda x.f\ x
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:7">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mn>2</mn>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\ f\ x=f\ (f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:8">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2=\lambda f.\lambda x.f\ (f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:9">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mn>3</mn>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">3</cn>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3\ f\ x=f\ (f\ (f\ x))
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:10">
 <semantics>
  <mrow>
   <mrow>
    <mn>3</mn>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <cn type="integer">3</cn>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3=\lambda f.\lambda x.f\ (f\ (f\ x))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>...</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:11">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mi>f</mi>
      <mi>n</mi>
     </msup>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\ f\ x=f^{n}\ x
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mi>f</mi>
      <mi>n</mi>
     </msup>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=\lambda f.\lambda x.f^{n}\ x
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The Church numeral <strong>3</strong> represents the action of applying any given function three times to a value. The supplied function is first applied to a supplied parameter and then successively to its own result. The end result is not the numeral 3 (unless the supplied parameter happens to be 0 and the function is a successor function). The function itself, and not its end result, is the Church numeral <strong>3</strong>. The Church numeral <strong>3</strong> means simply to do anything three times. It is an <a href="Ostensive_definition" title="wikilink">ostensive</a> demonstration of what is meant by "three times".</p>
<h3 id="calculation-with-church-numerals">Calculation with Church numerals</h3>

<p><a class="uri" href="Arithmetic" title="wikilink">Arithmetic</a> operations on numbers may be represented by functions on Church numerals. These functions may be defined in <a href="lambda_calculus" title="wikilink">lambda calculus</a>, or implemented in most functional programming languages (see <a href="Lambda_lifting#Conversion_without_lifting" title="wikilink">converting lambda expressions to functions</a>).</p>

<p>The addition function 

<math display="inline" id="Church_encoding:13">
 <semantics>
  <mrow>
   <mrow>
    <mo>plus</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mo>+</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>plus</ci>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{plus}(m,n)=m+n
  </annotation>
 </semantics>
</math>

 uses the identity 

<math display="inline" id="Church_encoding:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mi>m</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>n</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{(m+n)}(x)=f^{m}(f^{n}(x))
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Church_encoding:15">
 <semantics>
  <mrow>
   <mrow>
    <mo>plus</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>plus</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{plus}\equiv\lambda m.\lambda n.\lambda f.\lambda x.m\ f\ (n\ f\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>The successor function 

<math display="inline" id="Church_encoding:16">
 <semantics>
  <mrow>
   <mrow>
    <mo>succ</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>succ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}(n)=n+1
  </annotation>
 </semantics>
</math>

 is <a href="Beta_reduction#.CE.B2-reduction" title="wikilink">β-equivalent</a> to 

<math display="inline" id="Church_encoding:17">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>plus</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>plus</ci>
    <cn type="float">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{plus}\ 1)
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Church_encoding:18">
 <semantics>
  <mrow>
   <mrow>
    <mo>succ</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>succ</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}\equiv\lambda n.\lambda f.\lambda x.f\ (n\ f\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>The multiplication function 

<math display="inline" id="Church_encoding:19">
 <semantics>
  <mrow>
   <mrow>
    <mo>mult</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mo>*</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>mult</ci>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{mult}(m,n)=m*n
  </annotation>
 </semantics>
</math>

 uses the identity 

<math display="inline" id="Church_encoding:20">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>*</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>f</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>m</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <ci>m</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{(m*n)}(x)=(f^{n})^{m}(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Church_encoding:21">
 <semantics>
  <mrow>
   <mrow>
    <mo>mult</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>mult</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{mult}\equiv\lambda m.\lambda n.\lambda f.m\ (n\ f)
  </annotation>
 </semantics>
</math>

</p>

<p>The exponentiation function 

<math display="inline" id="Church_encoding:22">
 <semantics>
  <mrow>
   <mrow>
    <mo>exp</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>m</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>exp</ci>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{exp}(m,n)=m^{n}
  </annotation>
 </semantics>
</math>

 is given by the definition of Church numerals; 

<math display="inline" id="Church_encoding:23">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mi>f</mi>
      <mi>n</mi>
     </msup>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\ f\ x=f^{n}\ x
  </annotation>
 </semantics>
</math>

. In the definition substitute 

<math display="inline" id="Church_encoding:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>→</mo>
    <mi>m</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>x</mi>
    <mo>→</mo>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>f</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>x</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\to m,x\to f
  </annotation>
 </semantics>
</math>

 to get 

<math display="inline" id="Church_encoding:25">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mi>m</mi>
      <mi>n</mi>
     </msup>
    </mpadded>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>m</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\ m\ f=m^{n}\ f
  </annotation>
 </semantics>
</math>

 and,</p>

<p>

<math display="block" id="Church_encoding:26">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">exp</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>m</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>exp</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{exp}\ m\ n=m^{n}=n\ m
  </annotation>
 </semantics>
</math>

 which gives the lambda expression,</p>

<p>

<math display="block" id="Church_encoding:27">
 <semantics>
  <mrow>
   <mrow>
    <mo>exp</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>exp</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{exp}\equiv\lambda m.\lambda n.n\ m
  </annotation>
 </semantics>
</math>

</p>

<p>The 

<math display="inline" id="Church_encoding:28">
 <semantics>
  <mrow>
   <mo>pred</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>pred</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pred}(n)
  </annotation>
 </semantics>
</math>

 function is more difficult to understand.</p>

<p>

<math display="block" id="Church_encoding:29">
 <semantics>
  <mrow>
   <mo>pred</mo>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>n</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>g</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>u</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>u</mi>
    <mo>.</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>pred</ci>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">g</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pred}\equiv\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h%
.h\ (g\ f))\ (\lambda u.x)\ (\lambda u.u)
  </annotation>
 </semantics>
</math>

</p>

<p>A Church numeral applies a function <em>n</em> times. The predecessor function must return a function that applies its parameter <em>n - 1</em> times. This is achieved by building a container around <em>f</em> and <em>x</em>, which is initialized in a way that omits the application of the function the first time. See <a href="#Derivation_of_predecessor_function" title="wikilink">predecessor</a> for a more detailed explanation.</p>

<p>The subtraction function can be written based on the predecessor function.</p>

<p>

<math display="block" id="Church_encoding:30">
 <semantics>
  <mrow>
   <mrow>
    <mo>minus</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>pred</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>minus</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>pred</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{minus}\equiv\lambda m.\lambda n.(n\operatorname{pred})\ m
  </annotation>
 </semantics>
</math>

</p>
<h3 id="table-of-functions-on-church-numerals">Table of functions on Church numerals</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Function</p></th>
<th style="text-align: left;">
<p>Algebra</p></th>
<th style="text-align: left;">
<p>Identity</p></th>
<th style="text-align: left;">
<p>Function definition</p></th>
<th style="text-align: left;">
<p>Lambda expressions</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Successor_function" title="wikilink">Successor</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:31">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:32">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mi>f</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>n</mi>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{n+1}\ x=f(f^{n}x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:33">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">succ</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>succ</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}\ n\ f\ x=f\ (n\ f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda n.\lambda f.\lambda x.f\ (n\ f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Addition" title="wikilink">Addition</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:35">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>+</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m+n
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:36">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mi>f</mi>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <mi>n</mi>
      </mrow>
     </msup>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mi>m</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>n</mi>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{m+n}\ x=f^{m}(f^{n}x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:37">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">plus</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>plus</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{plus}\ m\ n\ f\ x=m\ f\ (n\ f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>m</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda m.\lambda n.\lambda f.\lambda x.m\ f\ (n\ f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Multiplication" title="wikilink">Multiplication</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:39">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>*</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m*n
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:40">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mi>f</mi>
      <mrow>
       <mi>m</mi>
       <mo>*</mo>
       <mi>n</mi>
      </mrow>
     </msup>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>f</mi>
        <mi>m</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>m</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{m*n}\ x=(f^{m})^{n}\ x
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:41">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">multiply</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>multiply</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{multiply}\ m\ n\ f\ x=m\ (n\ f)\ x
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>m</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda m.\lambda n.\lambda f.\lambda x.m\ (n\ f)\ x
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Exponentiation" title="wikilink">Exponentiation</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:43">
 <semantics>
  <msup>
   <mi>m</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{n}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:44">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mi>m</mi>
      <mi>n</mi>
     </msup>
    </mpadded>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>m</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\ m\ f=m^{n}\ f
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:45">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">exp</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>m</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>exp</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{exp}\ m\ n\ f\ x=(n\ m)\ f\ x
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>m</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>m</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda m.\lambda n.\lambda f.\lambda x.(n\ m)\ f\ x
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="#Derivation_of_predecessor_function" title="wikilink">Predecessor</a>*</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:47">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:48">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mo>inc</mo>
     <mi>n</mi>
    </msup>
    <mo>con</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>val</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>inc</ci>
      <ci>n</ci>
     </apply>
     <ci>con</ci>
    </apply>
    <apply>
     <ci>val</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}^{n}\operatorname{con}=\operatorname{val}(f^{n-1}x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:49">
 <semantics>
  <mo>pred</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>pred</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pred}
  </annotation>
 </semantics>
</math>

 ...</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:50">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>n</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>g</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>u</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>u</mi>
    <mo>.</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">g</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (g\ f))\ (\lambda u.x%
)\ (\lambda u.u)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Subtraction" title="wikilink">Subtraction</a>*</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:51">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>-</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-n
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:52">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mi>f</mi>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mi>n</mi>
      </mrow>
     </msup>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>f</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>m</mi>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>m</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{m-n}\ x=(f^{-1})^{n}(f^{m}x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:53">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">minus</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>pred</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>minus</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>pred</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{minus}\ m\ n=(n\operatorname{pred})\ m
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>...</p></td>
</tr>
</tbody>
</table>

<p>* Note that in the Church encoding,</p>
<ul>
<li>

<math display="inline" id="Church_encoding:54">
 <semantics>
  <mrow>
   <mrow>
    <mo>pred</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>pred</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pred}(0)=0
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Church_encoding:55">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo><</mo>
   <mi>n</mi>
   <mo>→</mo>
   <mrow>
    <mi>m</mi>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m<n\to m-n=0
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h3 id="translation-with-other-representations">Translation with other representations</h3>

<p>Most real-world languages have support for machine-native integers; the <em>church</em> and <em>unchurch</em> functions convert between nonnegative integers and their corresponding Church numerals. The functions are given here in <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>, where the <code>\</code> corresponds to the λ of Lambda calculus. Implementations in other languages are similar.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">type</span> <span class="dt">Church</span> a <span class="fu">=</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

<span class="ot">church ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Church</span> <span class="dt">Integer</span>
church <span class="dv">0</span> <span class="fu">=</span> \f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> x
church n <span class="fu">=</span> \f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> f (church (n<span class="fu">-</span><span class="dv">1</span>) f x)

<span class="ot">unchurch ::</span> <span class="dt">Church</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
unchurch cn <span class="fu">=</span> cn (<span class="fu">+</span> <span class="dv">1</span>) <span class="dv">0</span></code></pre></div>
<h2 id="church-booleans">Church Booleans</h2>

<p><em>Church Booleans</em> are the Church encoding of the Boolean values <em>true</em> and <em>false.</em> Some programming languages use these as an implementation model for Boolean arithmetic; examples are <a class="uri" href="Smalltalk" title="wikilink">Smalltalk</a> and <a href="Pico_(programming_language)" title="wikilink">Pico</a>.</p>

<p>Boolean logic may be considered as a choice. The Church encoding of <em>true</em> and <em>false</em> are functions of two parameters;</p>
<ul>
<li><em>true</em> chooses the first parameter.</li>
<li><em>false</em> chooses the second parameter.</li>
</ul>

<p>The two definitions are known as Church Booleans;</p>

<p>

<math display="block" id="Church_encoding:56">
 <semantics>
  <mrow>
   <mrow>
    <mo>true</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>a</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>true</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>b</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{true}\equiv\lambda a.\lambda b.a
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:57">
 <semantics>
  <mrow>
   <mrow>
    <mo>false</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>a</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>false</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>b</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{false}\equiv\lambda a.\lambda b.b
  </annotation>
 </semantics>
</math>

</p>

<p>This definition allows predicates (i.e. functions returning <a href="Truth_value" title="wikilink">logical values</a>) to directly act as if-clauses. A function returning a Boolean, which is then applied to two parameters, returns either the first or the second parameter;</p>

<p>

<math display="block" id="Church_encoding:58">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">predicate</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
   </mrow>
   <mrow>
    <mpadded width="+5pt">
     <mrow>
      <mi>then</mi>
      <mo>-</mo>
      <mi>clause</mi>
     </mrow>
    </mpadded>
    <mrow>
     <mi>else</mi>
     <mo>-</mo>
     <mi>clause</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>predicate</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <minus></minus>
      <ci>then</ci>
      <ci>clause</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>else</ci>
      <ci>clause</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{predicate}\ x\ \operatorname{then-clause}\ \operatorname{else-clause}
  </annotation>
 </semantics>
</math>

 evaluates to <em>then-clause</em> if <em>predicate</em> x evaluates to <em>true</em>, and to <em>else-clause</em> if <em>predicate</em> x evaluates to <em>false</em>.</p>

<p>Because <em>true</em> and <em>false</em> choose the first or second parameter they may be combined to provide logic operators,</p>

<p>

<math display="block" id="Church_encoding:59">
 <semantics>
  <mrow>
   <mrow>
    <mo>and</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>q</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>and</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>q</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{and}=\lambda p.\lambda q.p\ q\ p
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:60">
 <semantics>
  <mrow>
   <mrow>
    <mo>or</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>q</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>or</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{or}=\lambda p.\lambda q.p\ p\ q
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:61">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>not</mo>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>a</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>b</mi>
    </mpadded>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>not</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>b</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{not}_{1}=\lambda p.\lambda a.\lambda b.p\ b\ a
  </annotation>
 </semantics>
</math>

 - This is only a correct implementation if the evaluation strategy is applicative order.</p>

<p>

<math display="block" id="Church_encoding:62">
 <semantics>
  <mrow>
   <msub>
    <mo>not</mo>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>p</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>p</mi>
   <mo>.</mo>
   <mi>p</mi>
   <mo>false</mo>
   <mo>true</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>not</ci>
     <cn type="integer">2</cn>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>false</ci>
    <ci>true</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{not}_{2}=\lambda p.p\ (\lambda a.\lambda b.b)\ (\lambda a.%
\lambda b.a)=\lambda p.p\operatorname{false}\operatorname{true}
  </annotation>
 </semantics>
</math>

 - This is only a correct implementation if the evaluation strategy is normal order.</p>

<p>

<math display="block" id="Church_encoding:63">
 <semantics>
  <mrow>
   <mrow>
    <mo>xor</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>a</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>a</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">not</mo>
      <mi>b</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>xor</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <ci>not</ci>
      <ci>b</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{xor}=\lambda a.\lambda b.a\ (\operatorname{not}\ b)\ b
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:64">
 <semantics>
  <mrow>
   <mrow>
    <mo>if</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>a</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>a</mi>
    </mpadded>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>if</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{if}=\lambda p.\lambda a.\lambda b.p\ a\ b
  </annotation>
 </semantics>
</math>

</p>

<p>Some examples:</p>

<p>

<math display="block" id="Church_encoding:65">
 <semantics>
  <mrow>
   <mo>and</mo>
   <mo>true</mo>
   <mo>false</mo>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>q</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>q</mi>
    </mpadded>
    <mi>p</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">true</mo>
   <mo>false</mo>
   <mo>=</mo>
   <mo>true</mo>
   <mo>false</mo>
   <mo>true</mo>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>false</mo>
   <mo>true</mo>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>and</ci>
    <ci>true</ci>
    <ci>false</ci>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>true</ci>
    <ci>false</ci>
    <eq></eq>
    <ci>true</ci>
    <ci>false</ci>
    <ci>true</ci>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>false</ci>
    <ci>true</ci>
    <eq></eq>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{and}\operatorname{true}\operatorname{false}=(\lambda p.\lambda q%
.p\ q\ p)\ \operatorname{true}\ \operatorname{false}=\operatorname{true}%
\operatorname{false}\operatorname{true}=(\lambda a.\lambda b.a)\operatorname{%
false}\operatorname{true}=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:66">
 <semantics>
  <mrow>
   <mo>or</mo>
   <mo>true</mo>
   <mo>false</mo>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>q</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mi>q</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>true</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>or</ci>
    <ci>true</ci>
    <ci>false</ci>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <ci>true</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{or}\operatorname{true}\operatorname{false}=(\lambda p.\lambda q.%
p\ p\ q)\ (\lambda a.\lambda b.a)\ (\lambda a.\lambda b.b)=(\lambda a.\lambda b%
.a)\ (\lambda a.\lambda b.a)\ (\lambda a.\lambda b.b)=(\lambda a.\lambda b.a)=%
\operatorname{true}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:67">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msub>
     <mo>not</mo>
     <mn>1</mn>
    </msub>
   </mpadded>
   <mo>true</mo>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>b</mi>
    </mpadded>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>a</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>b</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+5pt">
    <mi>b</mi>
   </mpadded>
   <mi>a</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>a</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>b</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>a</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>b</mi>
   <mo>.</mo>
   <mi>b</mi>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>not</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>true</ci>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">a</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">b</csymbol>
    <eq></eq>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{not}_{1}\ \operatorname{true}=(\lambda p.\lambda a.\lambda b.p\ %
b\ a)(\lambda a.\lambda b.a)=\lambda a.\lambda b.(\lambda a.\lambda b.a)\ b\ a%
=\lambda a.\lambda b.(\lambda x.b)\ a=\lambda a.\lambda b.b=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:68">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msub>
     <mo>not</mo>
     <mn>2</mn>
    </msub>
   </mpadded>
   <mo>true</mo>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>a</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>b</mi>
   <mo>.</mo>
   <mi>b</mi>
   <mo>=</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>not</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>true</ci>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">b</csymbol>
    <eq></eq>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{not}_{2}\ \operatorname{true}=(\lambda p.p\ (\lambda a.\lambda b%
.b)(\lambda a.\lambda b.a))(\lambda a.\lambda b.a)=(\lambda a.\lambda b.a)(%
\lambda a.\lambda b.b)(\lambda a.\lambda b.a)=(\lambda b.(\lambda a.\lambda b.%
b))\ (\lambda a.\lambda b.a)=\lambda a.\lambda b.b=\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="predicates">Predicates</h2>

<p>A <em>predicate</em> is a function that returns a Boolean value. The most fundamental predicate is 

<math display="inline" id="Church_encoding:69">
 <semantics>
  <mo>IsZero</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>IsZero</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{IsZero}
  </annotation>
 </semantics>
</math>

, which returns 

<math display="inline" id="Church_encoding:70">
 <semantics>
  <mo>true</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>true</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{true}
  </annotation>
 </semantics>
</math>

 if its argument is the Church numeral 

<math display="inline" id="Church_encoding:71">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

, and 

<math display="inline" id="Church_encoding:72">
 <semantics>
  <mo>false</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>false</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{false}
  </annotation>
 </semantics>
</math>

 if its argument is any other Church numeral:</p>

<p>

<math display="block" id="Church_encoding:73">
 <semantics>
  <mrow>
   <mo>IsZero</mo>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>n</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mo>false</mo>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo>true</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>IsZero</ci>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <ci>false</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>true</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{IsZero}=\lambda n.n\ (\lambda x.\operatorname{false})\ %
\operatorname{true}
  </annotation>
 </semantics>
</math>

</p>

<p>The following predicate tests whether the first argument is less-than-or-equal-to the second:</p>

<p>

<math display="block" id="Church_encoding:74">
 <semantics>
  <mrow>
   <mrow>
    <mo>LEQ</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo rspace="7.5pt">IsZero</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">minus</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>m</mi>
       </mpadded>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>LEQ</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>IsZero</ci>
     <apply>
      <ci>minus</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{LEQ}=\lambda m.\lambda n.\operatorname{IsZero}\ (\operatorname{%
minus}\ m\ n)
  </annotation>
 </semantics>
</math>

,</p>

<p>Because of the identity,</p>

<p>

<math display="block" id="Church_encoding:75">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>≤</mo>
    <mi>y</mi>
    <mi mathvariant="italic">and</mi>
    <mi>y</mi>
    <mo>≤</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <leq></leq>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <leq></leq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y\equiv(x<=y\and y<=x)
  </annotation>
 </semantics>
</math>

 The test for equality may be implemented as,</p>

<p>

<math display="block" id="Church_encoding:76">
 <semantics>
  <mrow>
   <mrow>
    <mo>EQ</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">and</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo rspace="7.5pt">LEQ</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>m</mi>
        </mpadded>
        <mi>n</mi>
       </mrow>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">LEQ</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>n</mi>
       </mpadded>
       <mi>m</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>EQ</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <ci>and</ci>
      <apply>
       <ci>LEQ</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>LEQ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{EQ}=\lambda m.\lambda n.\operatorname{and}\ (\operatorname{LEQ}%
\ m\ n)\ (\operatorname{LEQ}\ n\ m)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="church-pairs">Church pairs</h2>

<p>Church pairs are the Church encoding of the <a href="cons" title="wikilink">pair</a> (two-tuple) type. The pair is represented as a function that takes a function argument. When given its argument it will apply the argument to the two components of the pair. The definition in <a href="lambda_calculus" title="wikilink">lambda calculus</a> is,</p>

<p>

<math display="block" id="Church_encoding:77">
 <semantics>
  <mrow>
   <mrow>
    <mo>pair</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>z</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>z</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>pair</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pair}\equiv\lambda x.\lambda y.\lambda z.z\ x\ y
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:78">
 <semantics>
  <mrow>
   <mo>first</mo>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>p</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>first</ci>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{first}\equiv\lambda p.p\ (\lambda x.\lambda y.x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:79">
 <semantics>
  <mrow>
   <mo>second</mo>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>p</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>second</ci>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{second}\equiv\lambda p.p\ (\lambda x.\lambda y.y)
  </annotation>
 </semantics>
</math>

</p>

<p>For example,</p>

<p>

<math display="block" id="Church_encoding:80">
 <semantics>
  <mrow>
   <mo rspace="7.5pt">first</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo rspace="7.5pt">pair</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>a</mi>
      </mpadded>
      <mi>b</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>first</ci>
    <apply>
     <ci>pair</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{first}\ (\operatorname{pair}\ a\ b)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Church_encoding:81">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>y</mi>
     <mo>.</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>y</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>z</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>z</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>y</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mpadded width="+5pt">
     <mi>a</mi>
    </mpadded>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(\lambda p.p\ (\lambda x.\lambda y.x))\ ((\lambda x.\lambda y.\lambda z.z\ x%
\ y)\ a\ b)
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Church_encoding:82">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>y</mi>
     <mo>.</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>z</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>z</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>a</mi>
    </mpadded>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">z</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(\lambda p.p\ (\lambda x.\lambda y.x))\ (\lambda z.z\ a\ b)
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Church_encoding:83">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>z</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>z</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>a</mi>
    </mpadded>
    <mi>b</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">z</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(\lambda z.z\ a\ b)\ (\lambda x.\lambda y.x)
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Church_encoding:84">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+5pt">
    <mi>a</mi>
   </mpadded>
   <mi>b</mi>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <eq></eq>
    <csymbol cd="unknown">a</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(\lambda x.\lambda y.x)\ a\ b=a
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h2 id="list-encodings">List encodings</h2>

<p>An (<a href="Immutable_object" title="wikilink">immutable</a>) <a href="list_(computing)" title="wikilink">list</a> is constructed from list nodes. The basic operations on the list are;</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Function</p></th>
<th style="text-align: left;">
<p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>nil</em></p></td>
<td style="text-align: left;">
<p>Construct an empty list.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>isnil</em></p></td>
<td style="text-align: left;">
<p>Test if list is empty.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>cons</em></p></td>
<td style="text-align: left;">
<p>Prepend a given value to a (possibly empty) list.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>head</em></p></td>
<td style="text-align: left;">
<p>Get the first element of the list.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>tail</em></p></td>
<td style="text-align: left;">
<p>Get the rest of the list.</p></td>
</tr>
</tbody>
</table>

<p>Three different representations of lists are given.</p>
<ul>
<li>Build each list node from two pairs (to allow for empty lists).</li>
<li>Build each list node from one pair.</li>
<li>Represent the list using the <a href="Fold_(higher-order_function)" title="wikilink">right fold function</a>.</li>
</ul>
<h3 id="two-pairs-as-a-list-node">Two pairs as a list node</h3>

<p>A nonempty list can implemented by a Church pair;</p>
<ul>
<li><em>First</em> contains the head.</li>
<li><em>Second</em> contains the tail.</li>
</ul>

<p>However this does not give a representation of the empty list, because there is no "null" pointer. To represent null, the pair may be wrapped in another pair, giving free values,</p>
<ul>
<li><em>First</em> - Is the null pointer (empty list).</li>
<li><em>Second.First</em> contains the head.</li>
<li><em>Second.Second</em> contains the tail.</li>
</ul>

<p>Using this idea the basic list operations can be defined like this:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Expression</p></th>
<th style="text-align: left;">
<p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:85">
 <semantics>
  <mrow>
   <mo>nil</mo>
   <mo>≡</mo>
   <mrow>
    <mo rspace="7.5pt">pair</mo>
    <mrow>
     <mo rspace="7.5pt">true</mo>
     <mo>true</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>nil</ci>
    <apply>
     <ci>pair</ci>
     <apply>
      <ci>true</ci>
      <ci>true</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{nil}\equiv\operatorname{pair}\ \operatorname{true}\ %
\operatorname{true}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>The first element of the pair is <em>true</em> meaning the list is null.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:86">
 <semantics>
  <mrow>
   <mo>isnil</mo>
   <mo>≡</mo>
   <mo>first</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>isnil</ci>
    <ci>first</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{isnil}\equiv\operatorname{first}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>Retrieve the null (or empty list) indicator.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:87">
 <semantics>
  <mrow>
   <mrow>
    <mo>cons</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>h</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>t</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo>pair</mo>
    <mrow>
     <mo rspace="7.5pt">false</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>pair</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>h</mi>
        </mpadded>
        <mi>t</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>cons</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <ci>pair</ci>
     <apply>
      <ci>false</ci>
      <apply>
       <ci>pair</ci>
       <apply>
        <times></times>
        <ci>h</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{cons}\equiv\lambda h.\lambda t.\operatorname{pair}\operatorname{%
false}\ (\operatorname{pair}h\ t)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>Create a list node, which is not null, and give it a head <em>h</em> and a tail <em>t</em>.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:88">
 <semantics>
  <mrow>
   <mrow>
    <mo>head</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>z</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo rspace="7.5pt">first</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>second</mo>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>head</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <ci>first</ci>
     <apply>
      <ci>second</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{head}\equiv\lambda z.\operatorname{first}\ (\operatorname{second%
}z)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>second.first</em> is the head.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:89">
 <semantics>
  <mrow>
   <mrow>
    <mo>tail</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>z</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo rspace="7.5pt">second</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>second</mo>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>tail</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <ci>second</ci>
     <apply>
      <ci>second</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tail}\equiv\lambda z.\operatorname{second}\ (\operatorname{%
second}z)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>second.second</em> is the tail.</p></td>
</tr>
</tbody>
</table>

<p>In a <em>nil</em> node <em>second</em> is never accessed, provided that <strong>head</strong> and <strong>tail</strong> are only applied to nonempty lists.</p>
<h3 id="one-pair-as-a-list-node">One pair as a list node</h3>

<p>Alternatively, define<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Church_encoding:90">
 <semantics>
  <mrow>
   <mo>cons</mo>
   <mo>≡</mo>
   <mo>pair</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>cons</ci>
    <ci>pair</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{cons}\equiv\operatorname{pair}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:91">
 <semantics>
  <mrow>
   <mo>head</mo>
   <mo>≡</mo>
   <mo>first</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>head</ci>
    <ci>first</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{head}\equiv\operatorname{first}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:92">
 <semantics>
  <mrow>
   <mo>tail</mo>
   <mo>≡</mo>
   <mo>second</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>tail</ci>
    <ci>second</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tail}\equiv\operatorname{second}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:93">
 <semantics>
  <mrow>
   <mo>nil</mo>
   <mo>≡</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>nil</ci>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{nil}\equiv\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:94">
 <semantics>
  <mrow>
   <mo>isnil</mo>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>l</mi>
   <mo>.</mo>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>t</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>d</mi>
    <mo>.</mo>
    <mo>false</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>true</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>isnil</ci>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-.</ci>
     <ci>false</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>true</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{isnil}\equiv\lambda l.l(\lambda h.\lambda t.\lambda d.%
\operatorname{false})\operatorname{true}
  </annotation>
 </semantics>
</math>

 where the last definition is a special case of the general</p>

<p>

<math display="block" id="Church_encoding:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>process</mi>
    <mo>-</mo>
    <mi>list</mi>
   </mrow>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>l</mi>
   <mo>.</mo>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>t</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>d</mi>
    <mo>.</mo>
    <mrow>
     <mi>head</mi>
     <mo>-</mo>
     <mi>and</mi>
     <mo>-</mo>
     <mi>tail</mi>
     <mo>-</mo>
     <mi>clause</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>nil</mi>
    <mo>-</mo>
    <mi>clause</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>process</ci>
     <ci>list</ci>
    </apply>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-.</ci>
     <apply>
      <minus></minus>
      <ci>head</ci>
      <ci>and</ci>
      <ci>tail</ci>
      <ci>clause</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <minus></minus>
     <ci>nil</ci>
     <ci>clause</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{process-list}\equiv\lambda l.l(\lambda h.\lambda t.\lambda d.%
\operatorname{head-and-tail-clause})\operatorname{nil-clause}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="represent-the-list-using-right-fold">Represent the list using <em>right fold</em></h3>

<p>As an alternative to the encoding using Church pairs, a list can be encoded by identifying it with its <a href="Fold_(higher-order_function)" title="wikilink">right fold function</a>. For example, a list of three elements x, y and z can be encoded by a higher-order function that when applied to a combinator c and a value n returns c x (c y (c z n)).</p>

<p>

<math display="block" id="Church_encoding:96">
 <semantics>
  <mrow>
   <mrow>
    <mo>nil</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>c</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>nil</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{nil}\equiv\lambda c.\lambda n.n
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:97">
 <semantics>
  <mrow>
   <mo>isnil</mo>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>l</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>l</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>t</mi>
    <mo>.</mo>
    <mo>false</mo>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo>true</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>isnil</ci>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-.</ci>
     <ci>false</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>true</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{isnil}\equiv\lambda l.l\ (\lambda h.\lambda t.\operatorname{%
false})\ \operatorname{true}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:98">
 <semantics>
  <mrow>
   <mrow>
    <mo>cons</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>h</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>t</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>c</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>c</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>t</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>c</mi>
      </mpadded>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>cons</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>h</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{cons}\equiv\lambda h.\lambda t.\lambda c.\lambda n.c\ h\ (t\ c\ n)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:99">
 <semantics>
  <mrow>
   <mo>head</mo>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>l</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>l</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>t</mi>
    <mo>.</mo>
    <mi>h</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>head</ci>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>false</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{head}\equiv\lambda l.l\ (\lambda h.\lambda t.h)\ \operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:100">
 <semantics>
  <mrow>
   <mo>tail</mo>
   <mo>≡</mo>
   <mi>λ</mi>
   <mi>l</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>c</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>n</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>l</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>t</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>t</mi>
     </mpadded>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>t</mi>
    <mo>.</mo>
    <mi>n</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>t</mi>
    <mo>.</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>tail</ci>
    <equivalent></equivalent>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tail}\equiv\lambda l.\lambda c.\lambda n.l\ (\lambda h.\lambda t%
.\lambda g.g\ h\ (t\ c))\ (\lambda t.n)\ (\lambda h.\lambda t.t)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="derivation-of-predecessor-function">Derivation of predecessor function</h2>

<p>The predecessor function used in the Church encoding is,</p>

<p>

<math display="inline" id="Church_encoding:101">
 <semantics>
  <mrow>
   <mrow>
    <mo>pred</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>n</mi>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>pred</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>n</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pred}(n)=\begin{cases}0&\mbox{if }n=0,\\
n-1&\mbox{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

.</p>

<p>To build the predecessor we need a way of applying the function 1 fewer time. A numeral <em>n</em> applies the function <em>f</em> <em>n</em> times to <em>x</em>. The predecessor function must use the numeral <em>n</em> to apply the function <em>n-1</em> times.</p>

<p>Before implementing the predecessor function, here is a scheme that wraps the value in a container function. We will define new functions to use in place of <em>f</em> and <em>x</em>, called <em>inc</em> and <em>init</em>. The container function is called <em>value</em>. The left hand side of the table shows a numeral <em>n</em> applied to <em>inc</em> and <em>init</em>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Number</p></th>
<th style="text-align: left;">
<p>Using init</p></th>
<th style="text-align: left;">
<p>Using const</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:102">
 <semantics>
  <mrow>
   <mo>init</mo>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>init</ci>
    <apply>
     <ci>value</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{init}=\operatorname{value}\ x
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:103">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mo>init</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <ci>init</ci>
    </apply>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ \operatorname{init}=\operatorname{value}\ (f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:104">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mo>const</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <ci>const</ci>
    </apply>
    <apply>
     <ci>value</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ \operatorname{const}=\operatorname{value}\ x
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:105">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">inc</mo>
      <mo>init</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <apply>
      <ci>inc</ci>
      <ci>init</ci>
     </apply>
    </apply>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ (\operatorname{inc}\ \operatorname{init})=\operatorname{%
value}\ (f\ (f\ x))
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:106">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">inc</mo>
      <mo>const</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <apply>
      <ci>inc</ci>
      <ci>const</ci>
     </apply>
    </apply>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ (\operatorname{inc}\ \operatorname{const})=\operatorname{%
value}\ (f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:107">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">inc</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo rspace="7.5pt">inc</mo>
        <mo>init</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+5pt">
           <mi>f</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <apply>
      <ci>inc</ci>
      <apply>
       <ci>inc</ci>
       <ci>init</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ (\operatorname{inc}\ (\operatorname{inc}\ \operatorname{%
init}))=\operatorname{value}\ (f\ (f\ (f\ x)))
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:108">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">inc</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo rspace="7.5pt">inc</mo>
        <mo>const</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <apply>
      <ci>inc</ci>
      <apply>
       <ci>inc</ci>
       <ci>const</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ (\operatorname{inc}\ (\operatorname{inc}\ \operatorname{%
const}))=\operatorname{value}\ (f\ (f\ x))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>...</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:109">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo rspace="7.5pt">inc</mo>
     <mo>init</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <msup>
        <mi>f</mi>
        <mi>n</mi>
       </msup>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <ci>inc</ci>
       <ci>init</ci>
      </apply>
     </apply>
     <apply>
      <ci>value</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>value</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\operatorname{inc}\ \operatorname{init}=\operatorname{value}\ (f^{n}\ x)=%
\operatorname{value}\ (n\ f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo rspace="7.5pt">inc</mo>
     <mo>const</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <msup>
        <mi>f</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <ci>inc</ci>
       <ci>const</ci>
      </apply>
     </apply>
     <apply>
      <ci>value</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>value</ci>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\operatorname{inc}\ \operatorname{const}=\operatorname{value}\ (f^{n-1}\ x)=%
\operatorname{value}\ ((n-1)\ f\ x)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The general recurrence rule is,</p>

<p>

<math display="block" id="Church_encoding:111">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">value</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <apply>
      <ci>value</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ (\operatorname{value}\ v)=\operatorname{value}\ (f\ v)
  </annotation>
 </semantics>
</math>

</p>

<p>If there is also a function to retrieve the value from the container (called <em>extract</em>),</p>

<p>

<math display="block" id="Church_encoding:112">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">extract</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">value</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>extract</ci>
     <apply>
      <ci>value</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{extract}\ (\operatorname{value}\ v)=v
  </annotation>
 </semantics>
</math>

</p>

<p>Then <em>extract</em> may be used to define the <em>samenum</em> function as,</p>

<p>

<math display="block" id="Church_encoding:113">
 <semantics>
  <mrow>
   <mrow>
    <mo>samenum</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">extract</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mrow>
        <mo>inc</mo>
        <mo>init</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">extract</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo rspace="7.5pt">value</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mpadded width="+5pt">
          <mi>n</mi>
         </mpadded>
         <mpadded width="+5pt">
          <mi>f</mi>
         </mpadded>
         <mi>x</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>samenum</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <ci>extract</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <ci>inc</ci>
        <ci>init</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <ci>extract</ci>
      <apply>
       <ci>value</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{samenum}=\lambda n.\lambda f.\lambda x.\operatorname{extract}\ (%
n\operatorname{inc}\operatorname{init})=\lambda n.\lambda f.\lambda x.%
\operatorname{extract}\ (\operatorname{value}\ (n\ f\ x))=\lambda n.\lambda f.%
\lambda x.n\ f\ x=\lambda n.n
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>samenum</em> function is not intrinsically useful. However, as <em>inc</em> delegates calling of <em>f</em> to its container argument, we can arrange that on the first application <em>inc</em> receives a special container that ignores its argument allowing to skip the first application of <em>f</em>. Call this new initial container <em>const</em>. The right hand side of the above table shows the expansions of <em>n</em> <em>inc</em> <em>const</em>. Then by replacing <em>init</em> with <em>const</em> in the expression for the <em>same</em> function we get the predecessor function,</p>

<p>

<math display="block" id="Church_encoding:114">
 <semantics>
  <mrow>
   <mrow>
    <mo>pred</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">extract</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mrow>
        <mo>inc</mo>
        <mo>const</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">extract</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo rspace="7.5pt">value</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo rspace="7.5pt" stretchy="false">)</mo>
         </mrow>
         <mpadded width="+5pt">
          <mi>f</mi>
         </mpadded>
         <mi>x</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>pred</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <ci>extract</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <ci>inc</ci>
        <ci>const</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <ci>extract</ci>
      <apply>
       <ci>value</ci>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pred}=\lambda n.\lambda f.\lambda x.\operatorname{extract}\ (n%
\operatorname{inc}\operatorname{const})=\lambda n.\lambda f.\lambda x.%
\operatorname{extract}\ (\operatorname{value}\ ((n-1)\ f\ x))=\lambda n.%
\lambda f.\lambda x.(n-1)\ f\ x=\lambda n.(n-1)
  </annotation>
 </semantics>
</math>

</p>

<p>As explained below the functions <em>inc</em>, <em>init</em>, <em>const</em>, <em>value</em> and <em>extract</em> may be defined as,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:115">
 <semantics>
  <mo>value</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>value</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{value}
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:116">
 <semantics>
  <mrow>
   <mo rspace="7.5pt">extract</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>extract</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{extract}\ k
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:117">
 <semantics>
  <mo>inc</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>inc</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:118">
 <semantics>
  <mo>init</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>init</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{init}
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:119">
 <semantics>
  <mo>const</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>const</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{const}
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:120">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>v</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">h</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda v.(\lambda h.h\ v)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:121">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>k</mi>
    </mpadded>
    <mi>λ</mi>
    <mi>u</mi>
   </mrow>
   <mo>.</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>λ</ci>
     <ci>u</ci>
    </apply>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\ \lambda u.u
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:122">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>g</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>h</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda g.\lambda h.h\ (g\ f)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:123">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>h</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda h.h\ x
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Church_encoding:124">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>u</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>u</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda u.x
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Which gives the lambda expression for <em>pred</em> as,</p>

<p>

<math display="block" id="Church_encoding:125">
 <semantics>
  <mrow>
   <mo>pred</mo>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>n</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>g</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>u</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>u</mi>
    <mo>.</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>pred</ci>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">g</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pred}=\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (%
g\ f))\ (\lambda u.x)\ (\lambda u.u)
  </annotation>
 </semantics>
</math>

</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><h3 id="value-container">Value container</h3>

<p>The value container applies a function to its value. It is defined by,</p>

<p>

<math display="block" id="Church_encoding:126">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>v</mi>
     </mpadded>
     <mi>h</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mi>v</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{value}\ v\ h=h\ v
  </annotation>
 </semantics>
</math>

 so,</p>

<p>

<math display="block" id="Church_encoding:127">
 <semantics>
  <mrow>
   <mo>value</mo>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>v</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>value</ci>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">h</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{value}=\lambda v.(\lambda h.h\ v)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="inc">Inc</h3>

<p>The <em>inc</em> function should take a value containing <em>v</em>, and return a new value containing <em>f v</em>.</p>

<p>

<math display="block" id="Church_encoding:128">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">value</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <apply>
      <ci>value</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ (\operatorname{value}\ v)=\operatorname{value}\ (f\ v)
  </annotation>
 </semantics>
</math>

 Letting g be the value container,</p>

<p>

<math display="block" id="Church_encoding:129">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mi>v</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>g</ci>
    <apply>
     <ci>value</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g=\operatorname{value}\ v
  </annotation>
 </semantics>
</math>

 then,</p>

<p>

<math display="block" id="Church_encoding:130">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>v</mi>
     </mpadded>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>v</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <ci>value</ci>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\ f=\operatorname{value}\ v\ f=f\ v
  </annotation>
 </semantics>
</math>

 so,</p>

<p>

<math display="block" id="Church_encoding:131">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mi>g</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ g=\operatorname{value}\ (g\ f)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:132">
 <semantics>
  <mrow>
   <mrow>
    <mo>inc</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>g</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>h</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>g</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>inc</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}=\lambda g.\lambda h.h\ (g\ f)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><h3 id="extract">Extract</h3>

<p>The value may be extracted by applying the identity function,</p>

<p>

<math display="block" id="Church_encoding:133">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>u</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>I</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=\lambda u.u
  </annotation>
 </semantics>
</math>

 Using <em>I</em>,</p>

<p>

<math display="block" id="Church_encoding:134">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>v</mi>
     </mpadded>
     <mi>I</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>value</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{value}\ v\ I=v
  </annotation>
 </semantics>
</math>

 so,</p>

<p>

<math display="block" id="Church_encoding:135">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">extract</mo>
    <mi>k</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>k</mi>
    </mpadded>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>extract</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{extract}\ k=k\ I
  </annotation>
 </semantics>
</math>

</p>
<h3 id="const">Const</h3>

<p>To implement <em>pred</em> the <em>init</em> function is replaced with the <em>const</em> that does not apply <em>f</em>. We need <em>const</em> to satisfy,</p>

<p>

<math display="block" id="Church_encoding:136">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">inc</mo>
    <mo>const</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">value</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>inc</ci>
     <ci>const</ci>
    </apply>
    <apply>
     <ci>value</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{inc}\ \operatorname{const}=\operatorname{value}\ x
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:137">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>h</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mi>h</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo rspace="7.5pt">const</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>h</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <ci>const</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda h.h\ (\operatorname{const}\ f)=\lambda h.h\ x
  </annotation>
 </semantics>
</math>

 Which is satisfied if,</p>

<p>

<math display="block" id="Church_encoding:138">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">const</mo>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>const</ci>
     <ci>f</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{const}\ f=x
  </annotation>
 </semantics>
</math>

 Or as a lambda expression,</p>

<p>

<math display="block" id="Church_encoding:139">
 <semantics>
  <mrow>
   <mrow>
    <mo>const</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>u</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>const</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{const}=\lambda u.x
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h2 id="division">Division</h2>

<p><a href="Division_(mathematics)" title="wikilink">Division</a> of natural numbers may be implemented by,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>

<math display="block" id="Church_encoding:140">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">if</mo>
    <mi>n</mi>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mrow>
      <mo>then</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>m</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
     </mrow>
     <mrow>
      <mo>else</mo>
      <mn>0</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <ci>if</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>m</ci>
       <apply>
        <ci>then</ci>
        <cn type="float">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>m</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <ci>else</ci>
        <cn type="float">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/m=\operatorname{if}\ n>=m\ \operatorname{then}\ 1+(n-m)/m\ \operatorname{%
else}\ 0
  </annotation>
 </semantics>
</math>

</p>

<p>Calculating 

<math display="inline" id="Church_encoding:141">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-m
  </annotation>
 </semantics>
</math>

 takes many beta reductions. Unless doing the reduction by hand, this doesn't matter that much, but it is preferable to not have to do this calculation twice. The simplest predicate for testing numbers is <em>IsZero</em> so consider the condition.</p>

<p>

<math display="block" id="Church_encoding:142">
 <semantics>
  <mrow>
   <mo rspace="7.5pt">IsZero</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo rspace="7.5pt">minus</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>m</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>IsZero</ci>
    <apply>
     <ci>minus</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{IsZero}\ (\operatorname{minus}\ n\ m)
  </annotation>
 </semantics>
</math>

 But this condition is equivalent to 

<math display="inline" id="Church_encoding:143">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>m
  </annotation>
 </semantics>
</math>

, not 

<math display="inline" id="Church_encoding:144">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≥</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>=m
  </annotation>
 </semantics>
</math>

. If this expression is used then the mathematical definition of division given above is translated into function on Church numerals as,</p>

<p>

<math display="block" id="Church_encoding:145">
 <semantics>
  <mrow>
   <mo rspace="7.5pt">divide1</mo>
   <mpadded width="+5pt">
    <mi>n</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>m</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>d</mi>
    <mo>.</mo>
    <mo rspace="7.5pt">IsZero</mo>
    <mpadded width="+5pt">
     <mi>d</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mn>0</mn>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo rspace="7.5pt">divide1</mo>
      <mpadded width="+5pt">
       <mi>d</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo rspace="7.5pt">minus</mo>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>divide1</ci>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-.</ci>
     <ci>IsZero</ci>
     <csymbol cd="unknown">d</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">0</cn>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <ci>divide1</ci>
       <csymbol cd="unknown">d</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>minus</ci>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{divide1}\ n\ m\ f\ x=(\lambda d.\operatorname{IsZero}\ d\ (0\ f%
\ x)\ (f\ (\operatorname{divide1}\ d\ m\ f\ x)))\ (\operatorname{minus}\ n\ m)
  </annotation>
 </semantics>
</math>

</p>

<p>As desired, this definition has a single call to 

<math display="inline" id="Church_encoding:146">
 <semantics>
  <mrow>
   <mo rspace="7.5pt">minus</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>minus</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{minus}\ n\ m
  </annotation>
 </semantics>
</math>

. However the result is that this formula gives the value of 

<math display="inline" id="Church_encoding:147">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)/m
  </annotation>
 </semantics>
</math>

.</p>

<p>This problem may be corrected by adding 1 to <em>n</em> before calling <em>divide</em>.The definition of <em>divide</em> is then,</p>

<p>

<math display="block" id="Church_encoding:148">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="7.5pt">divide</mo>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo rspace="7.5pt">divide1</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">succ</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>divide</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>divide1</ci>
     <apply>
      <ci>succ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{divide}\ n=\operatorname{divide1}\ (\operatorname{succ}\ n)
  </annotation>
 </semantics>
</math>

</p>

<p><em>divide1</em> is a recursive definition. The <a href="Fixed-point_combinator" title="wikilink">Y combinator</a> may be used to implement the recursion. Create a new function called <em>div</em> by;</p>
<ul>
<li>In the left hand side 

<math display="inline" id="Church_encoding:149">
 <semantics>
  <mrow>
   <mo>divide1</mo>
   <mo>→</mo>
   <mrow>
    <mo rspace="7.5pt">div</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>divide1</ci>
    <apply>
     <ci>div</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{divide1}\rightarrow\operatorname{div}\ c
  </annotation>
 </semantics>
</math>

</li>
<li>In the right hand side 

<math display="inline" id="Church_encoding:150">
 <semantics>
  <mrow>
   <mo>divide1</mo>
   <mo>→</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>divide1</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{divide1}\rightarrow c
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>to get,</p>

<p>

<math display="block" id="Church_encoding:151">
 <semantics>
  <mrow>
   <mo>div</mo>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>c</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>n</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>m</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>d</mi>
    <mo>.</mo>
    <mo rspace="7.5pt">IsZero</mo>
    <mpadded width="+5pt">
     <mi>d</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mn>0</mn>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>c</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>d</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>m</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo rspace="7.5pt">minus</mo>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>div</ci>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-.</ci>
     <ci>IsZero</ci>
     <csymbol cd="unknown">d</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">0</cn>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">c</csymbol>
       <csymbol cd="unknown">d</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>minus</ci>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{div}=\lambda c.\lambda n.\lambda m.\lambda f.\lambda x.(\lambda d%
.\operatorname{IsZero}\ d\ (0\ f\ x)\ (f\ (c\ d\ m\ f\ x)))\ (\operatorname{%
minus}\ n\ m)
  </annotation>
 </semantics>
</math>

</p>

<p>Then,</p>

<p>

<math display="block" id="Church_encoding:152">
 <semantics>
  <mrow>
   <mrow>
    <mo>divide</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo rspace="7.5pt">divide1</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">succ</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>divide</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>divide1</ci>
     <apply>
      <ci>succ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{divide}=\lambda n.\operatorname{divide1}\ (\operatorname{succ}\ n)
  </annotation>
 </semantics>
</math>

 where,</p>

<p>

<math display="block" id="Church_encoding:153">
 <semantics>
  <mrow>
   <mo>divide1</mo>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>Y</mi>
    </mpadded>
    <mo>div</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>divide1</ci>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>div</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{divide1}=Y\ \operatorname{div}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:154">
 <semantics>
  <mrow>
   <mrow>
    <mo>succ</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>succ</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{succ}=\lambda n.\lambda f.\lambda x.f\ (n\ f\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:155">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\lambda f.(\lambda x.x\ x)\ (\lambda x.f\ (x\ x))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:156">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=\lambda f.\lambda x.x
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:157">
 <semantics>
  <mrow>
   <mo>IsZero</mo>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>n</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mo>false</mo>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo>true</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>IsZero</ci>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <ci>false</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>true</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{IsZero}=\lambda n.n\ (\lambda x.\operatorname{false})\ %
\operatorname{true}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:158">
 <semantics>
  <mrow>
   <mrow>
    <mo>true</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>a</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>true</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>b</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{true}\equiv\lambda a.\lambda b.a
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:159">
 <semantics>
  <mrow>
   <mrow>
    <mo>false</mo>
    <mo>≡</mo>
    <mrow>
     <mi>λ</mi>
     <mi>a</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>false</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>b</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{false}\equiv\lambda a.\lambda b.b
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:160">
 <semantics>
  <mrow>
   <mrow>
    <mo>minus</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo>pred</mo>
     <mi>m</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>minus</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <ci>pred</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{minus}=\lambda m.\lambda n.n\operatorname{pred}m
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:161">
 <semantics>
  <mrow>
   <mo>pred</mo>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>n</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>f</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mpadded width="+5pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>g</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>h</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>h</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>g</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>u</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>u</mi>
    <mo>.</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>pred</ci>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">g</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pred}=\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (%
g\ f))\ (\lambda u.x)\ (\lambda u.u)
  </annotation>
 </semantics>
</math>

 Gives,</p>

<p>

<math display="block" id="Church_encoding:162">
 <semantics>
  <mrow>
   <mo>divide</mo>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>n</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>c</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>n</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>m</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>d</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mi>n</mi>
       <mo>.</mo>
       <mpadded width="+5pt">
        <mi>n</mi>
       </mpadded>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>λ</mi>
        <mi>x</mi>
        <mo>.</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>λ</mi>
         <mi>a</mi>
         <mo>.</mo>
         <mi>λ</mi>
         <mi>b</mi>
         <mo>.</mo>
         <mi>b</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>λ</mi>
        <mi>a</mi>
        <mo>.</mo>
        <mi>λ</mi>
        <mi>b</mi>
        <mo>.</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mpadded width="+5pt">
       <mi>d</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>λ</mi>
        <mi>f</mi>
        <mo>.</mo>
        <mi>λ</mi>
        <mi>x</mi>
        <mo>.</mo>
        <mi>x</mi>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
       <mpadded width="+5pt">
        <mi>f</mi>
       </mpadded>
       <mi>x</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>f</mi>
       </mpadded>
       <mrow>
        <mo stretchy="false">(</mo>
        <mpadded width="+5pt">
         <mi>c</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>d</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>m</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mi>m</mi>
       <mo>.</mo>
       <mi>λ</mi>
       <mi>n</mi>
       <mo>.</mo>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>λ</mi>
        <mi>n</mi>
        <mo>.</mo>
        <mi>λ</mi>
        <mi>f</mi>
        <mo>.</mo>
        <mi>λ</mi>
        <mi>x</mi>
        <mo>.</mo>
        <mpadded width="+5pt">
         <mi>n</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>λ</mi>
         <mi>g</mi>
         <mo>.</mo>
         <mi>λ</mi>
         <mi>h</mi>
         <mo>.</mo>
         <mpadded width="+5pt">
          <mi>h</mi>
         </mpadded>
         <mrow>
          <mo stretchy="false">(</mo>
          <mpadded width="+5pt">
           <mi>g</mi>
          </mpadded>
          <mi>f</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo rspace="7.5pt" stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>λ</mi>
         <mi>u</mi>
         <mo>.</mo>
         <mi>x</mi>
         <mo rspace="7.5pt" stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>λ</mi>
         <mi>u</mi>
         <mo>.</mo>
         <mi>u</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>m</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>n</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>divide</ci>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">m</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">d</csymbol>
       <ci>normal-.</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">n</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">n</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">λ</csymbol>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-.</ci>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">λ</csymbol>
          <csymbol cd="unknown">a</csymbol>
          <ci>normal-.</ci>
          <csymbol cd="unknown">λ</csymbol>
          <csymbol cd="unknown">b</csymbol>
          <ci>normal-.</ci>
          <csymbol cd="unknown">b</csymbol>
          <ci>normal-)</ci>
         </cerror>
         <ci>normal-)</ci>
        </cerror>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">λ</csymbol>
         <csymbol cd="unknown">a</csymbol>
         <ci>normal-.</ci>
         <csymbol cd="unknown">λ</csymbol>
         <csymbol cd="unknown">b</csymbol>
         <ci>normal-.</ci>
         <csymbol cd="unknown">a</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">d</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">λ</csymbol>
         <csymbol cd="unknown">f</csymbol>
         <ci>normal-.</ci>
         <csymbol cd="unknown">λ</csymbol>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-.</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <csymbol cd="unknown">f</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">f</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">c</csymbol>
         <csymbol cd="unknown">d</csymbol>
         <csymbol cd="unknown">m</csymbol>
         <csymbol cd="unknown">f</csymbol>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">m</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">n</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">n</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">λ</csymbol>
         <csymbol cd="unknown">n</csymbol>
         <ci>normal-.</ci>
         <csymbol cd="unknown">λ</csymbol>
         <csymbol cd="unknown">f</csymbol>
         <ci>normal-.</ci>
         <csymbol cd="unknown">λ</csymbol>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-.</ci>
         <csymbol cd="unknown">n</csymbol>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">λ</csymbol>
          <csymbol cd="unknown">g</csymbol>
          <ci>normal-.</ci>
          <csymbol cd="unknown">λ</csymbol>
          <csymbol cd="unknown">h</csymbol>
          <ci>normal-.</ci>
          <csymbol cd="unknown">h</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <csymbol cd="unknown">g</csymbol>
           <csymbol cd="unknown">f</csymbol>
           <ci>normal-)</ci>
          </cerror>
          <ci>normal-)</ci>
         </cerror>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">λ</csymbol>
          <csymbol cd="unknown">u</csymbol>
          <ci>normal-.</ci>
          <csymbol cd="unknown">x</csymbol>
          <ci>normal-)</ci>
         </cerror>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">λ</csymbol>
          <csymbol cd="unknown">u</csymbol>
          <ci>normal-.</ci>
          <csymbol cd="unknown">u</csymbol>
          <ci>normal-)</ci>
         </cerror>
         <ci>normal-)</ci>
        </cerror>
        <csymbol cd="unknown">m</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{divide}=\lambda n.((\lambda f.(\lambda x.x\ x)\ (\lambda x.f\ (x%
\ x)))\ (\lambda c.\lambda n.\lambda m.\lambda f.\lambda x.(\lambda d.(\lambda
n%
.n\ (\lambda x.(\lambda a.\lambda b.b))\ (\lambda a.\lambda b.a))\ d\ ((%
\lambda f.\lambda x.x)\ f\ x)\ (f\ (c\ d\ m\ f\ x)))\ ((\lambda m.\lambda n.n(%
\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (g\ f))\ (\lambda u.x%
)\ (\lambda u.u))m)\ n\ m)))\ ((\lambda n.\lambda f.\lambda x.f\ (n\ f\ x))\ n)
  </annotation>
 </semantics>
</math>

</p>

<p>Or as text, using \ for 

<math display="inline" id="Church_encoding:163">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

,</p>

<p><code> divide = (\n.((\f.(\x.x x) (\x.f (x x))) (\c.\n.\m.\f.\x.(\d.(\n.n (\x.(\a.\b.b)) (\a.\b.a)) d ((\f.\x.x) f x) (f (c d m f x))) ((\m.\n.n (\n.\f.\x.n (\g.\h.h (g f)) (\u.x) (\u.u)) m) n m))) ((\n.\f.\x. f (n f x)) n))</code></p>

<p>For example, 9/3 is represented by</p>

<p><code> divide (\f.\x.f (f (f (f (f (f (f (f (f x))))))))) (\f.\x.f (f (f x)))</code></p>

<p>Using a lambda calculus calculator, the above expression reduces to 3, using normal order.</p>

<p><code> \f.\x.f (f (f (x)))</code></p>
<h2 id="signed-numbers">Signed numbers</h2>

<p>One simple approach for extending Church Numerals to <a href="Integer" title="wikilink">signed numbers</a> is to use a Church pair, containing Church numerals representing a positive and a negative value.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The integer value is the difference between the two Church numerals.</p>

<p>A natural number is converted to a signed number by,</p>

<p>

<math display="block" id="Church_encoding:164">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>convert</mo>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo rspace="7.5pt">pair</mo>
    <mrow>
     <mi>x</mi>
     <mn>0</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>convert</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <ci>pair</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <cn type="float">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{convert}_{s}=\lambda x.\operatorname{pair}\ x\ 0
  </annotation>
 </semantics>
</math>

</p>

<p>Negation is performed by swapping the values.</p>

<p>

<math display="block" id="Church_encoding:165">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>neg</mo>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">pair</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo rspace="7.5pt">second</mo>
       <mi>x</mi>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">first</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>neg</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <ci>pair</ci>
      <apply>
       <ci>second</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <ci>first</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{neg}_{s}=\lambda x.\operatorname{pair}\ (\operatorname{second}\ %
x)\ (\operatorname{first}\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>The integer value is more naturally represented if one of the pair is zero. The <em>OneZero</em> function achieves this condition,</p>

<p>

<math display="block" id="Church_encoding:166">
 <semantics>
  <mrow>
   <mrow>
    <mo>OneZero</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo rspace="7.5pt">IsZero</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo rspace="7.5pt">first</mo>
        <mi>x</mi>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo rspace="7.5pt">IsZero</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo rspace="7.5pt">second</mo>
          <mi>x</mi>
         </mrow>
         <mo rspace="7.5pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo rspace="7.5pt">OneZero</mo>
         <mrow>
          <mo rspace="7.5pt">pair</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">pred</mo>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mo rspace="7.5pt">first</mo>
              <mi>x</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo rspace="7.5pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo rspace="7.5pt">pred</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">second</mo>
            <mi>x</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>OneZero</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <ci>IsZero</ci>
       <apply>
        <ci>first</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <ci>IsZero</ci>
        <apply>
         <ci>second</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <apply>
        <ci>OneZero</ci>
        <apply>
         <ci>pair</ci>
         <apply>
          <ci>pred</ci>
          <apply>
           <ci>first</ci>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>pred</ci>
        <apply>
         <ci>second</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{OneZero}=\lambda x.\operatorname{IsZero}\ (\operatorname{first}%
\ x)\ x\ (\operatorname{IsZero}\ (\operatorname{second}\ x)\ x\ (\operatorname%
{OneZero}\ \operatorname{pair}\ (\operatorname{pred}\ (\operatorname{first}\ x%
))\ (\operatorname{pred}\ (\operatorname{second}\ x))))
  </annotation>
 </semantics>
</math>

</p>

<p>The recursion may be implemented using the Y combinator,</p>

<p>

<math display="block" id="Church_encoding:167">
 <semantics>
  <mrow>
   <mrow>
    <mo>OneZ</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>c</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo rspace="7.5pt">IsZero</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo rspace="7.5pt">first</mo>
        <mi>x</mi>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo rspace="7.5pt">IsZero</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo rspace="7.5pt">second</mo>
          <mi>x</mi>
         </mrow>
         <mo rspace="7.5pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>c</mi>
        </mpadded>
        <mrow>
         <mrow>
          <mo rspace="7.5pt">pair</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">pred</mo>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mo rspace="7.5pt">first</mo>
              <mi>x</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo rspace="7.5pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">pred</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mo rspace="7.5pt">second</mo>
             <mi>x</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>OneZ</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <ci>IsZero</ci>
       <apply>
        <ci>first</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <ci>IsZero</ci>
        <apply>
         <ci>second</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <apply>
        <apply>
         <ci>pair</ci>
         <apply>
          <ci>pred</ci>
          <apply>
           <ci>first</ci>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <ci>pred</ci>
         <apply>
          <ci>second</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{OneZ}=\lambda c.\lambda x.\operatorname{IsZero}\ (\operatorname{%
first}\ x)\ x\ (\operatorname{IsZero}\ (\operatorname{second}\ x)\ x\ (c\ %
\operatorname{pair}\ (\operatorname{pred}\ (\operatorname{first}\ x))\ (%
\operatorname{pred}\ (\operatorname{second}\ x))))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Church_encoding:168">
 <semantics>
  <mrow>
   <mo>OneZero</mo>
   <mo>=</mo>
   <mrow>
    <mi>Y</mi>
    <mo>OneZ</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>OneZero</ci>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>OneZ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{OneZero}=Y\operatorname{OneZ}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="plus-and-minus">Plus and minus</h3>

<p>Addition is defined mathematically on the pair by,</p>

<p>

<math display="block" id="Church_encoding:169">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>x</mi>
      <mi>p</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>p</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>p</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>y</mi>
       <mi>p</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>p</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <plus></plus>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </interval>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <interval closure="closed">
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+y=[x_{p},x_{n}]+[y_{p},y_{n}]=x_{p}-x_{n}+y_{p}-y_{n}=(x_{p}+y_{p})-(x_{n}+y%
_{n})=[x_{p}+y_{p},x_{n}+y_{n}]
  </annotation>
 </semantics>
</math>

</p>

<p>The last expression is translated into lambda calculus as,</p>

<p>

<math display="block" id="Church_encoding:170">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>plus</mo>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo rspace="7.5pt">OneZero</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo rspace="7.5pt">pair</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo rspace="7.5pt">plus</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">first</mo>
            <mi>x</mi>
           </mrow>
           <mo rspace="7.5pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">first</mo>
           <mi>y</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo rspace="7.5pt">plus</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">second</mo>
           <mi>x</mi>
          </mrow>
          <mo rspace="7.5pt" stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo rspace="7.5pt">second</mo>
          <mi>y</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>plus</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <ci>OneZero</ci>
     <apply>
      <apply>
       <ci>pair</ci>
       <apply>
        <apply>
         <ci>plus</ci>
         <apply>
          <ci>first</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <apply>
         <ci>first</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <ci>plus</ci>
        <apply>
         <ci>second</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <ci>second</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{plus}_{s}=\lambda x.\lambda y.\operatorname{OneZero}\ (%
\operatorname{pair}\ (\operatorname{plus}\ (\operatorname{first}\ x)\ (%
\operatorname{first}\ y))\ (\operatorname{plus}\ (\operatorname{second}\ x)\ (%
\operatorname{second}\ y)))
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly subtraction is defined,</p>

<p>

<math display="block" id="Church_encoding:171">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>x</mi>
      <mi>p</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>p</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>p</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>y</mi>
       <mi>p</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>p</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <minus></minus>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </interval>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <interval closure="closed">
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-y=[x_{p},x_{n}]-[y_{p},y_{n}]=x_{p}-x_{n}-y_{p}+y_{n}=(x_{p}+y_{n})-(x_{n}+y%
_{p})=[x_{p}+y_{n},x_{n}+y_{p}]
  </annotation>
 </semantics>
</math>

</p>

<p>giving,</p>

<p>

<math display="block" id="Church_encoding:172">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>minus</mo>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo rspace="7.5pt">OneZero</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo rspace="7.5pt">pair</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo rspace="7.5pt">plus</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">first</mo>
            <mi>x</mi>
           </mrow>
           <mo rspace="7.5pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">second</mo>
           <mi>y</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo rspace="7.5pt">plus</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">second</mo>
           <mi>x</mi>
          </mrow>
          <mo rspace="7.5pt" stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo rspace="7.5pt">first</mo>
          <mi>y</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>minus</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <ci>OneZero</ci>
     <apply>
      <apply>
       <ci>pair</ci>
       <apply>
        <apply>
         <ci>plus</ci>
         <apply>
          <ci>first</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <apply>
         <ci>second</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <ci>plus</ci>
        <apply>
         <ci>second</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <ci>first</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{minus}_{s}=\lambda x.\lambda y.\operatorname{OneZero}\ (%
\operatorname{pair}\ (\operatorname{plus}\ (\operatorname{first}\ x)\ (%
\operatorname{second}\ y))\ (\operatorname{plus}\ (\operatorname{second}\ x)\ %
(\operatorname{first}\ y)))
  </annotation>
 </semantics>
</math>

</p>
<h3 id="multiply-and-divide">Multiply and divide</h3>

<p>Multiplication may be defined by,</p>

<p>

<math display="block" id="Church_encoding:173">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>*</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>x</mi>
      <mi>p</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>p</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>p</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>p</mi>
       </msub>
       <mo>*</mo>
       <msub>
        <mi>y</mi>
        <mi>p</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo>*</mo>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>p</mi>
       </msub>
       <mo>*</mo>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo>*</mo>
       <msub>
        <mi>y</mi>
        <mi>p</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>p</mi>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>y</mi>
       <mi>p</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>p</mi>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>y</mi>
       <mi>p</mi>
      </msub>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </interval>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>p</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <interval closure="closed">
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>p</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x*y=[x_{p},x_{n}]*[y_{p},y_{n}]=(x_{p}-x_{n})*(y_{p}-y_{n})=(x_{p}*y_{p}+x_{n}%
*y_{n})-(x_{p}*y_{n}+x_{n}*y_{p})=[x_{p}*y_{p}+x_{n}*y_{n},x_{p}*y_{n}+x_{n}*y%
_{p}]
  </annotation>
 </semantics>
</math>

 The last expression is translated into lambda calculus as,</p>

<p>

<math display="block" id="Church_encoding:174">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>mult</mo>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">pair</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo rspace="7.5pt">plus</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mo rspace="7.5pt">mult</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mo rspace="7.5pt">first</mo>
             <mi>x</mi>
            </mrow>
            <mo rspace="7.5pt" stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">first</mo>
            <mi>y</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo rspace="7.5pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo rspace="7.5pt">mult</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">second</mo>
            <mi>x</mi>
           </mrow>
           <mo rspace="7.5pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">second</mo>
           <mi>y</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo rspace="7.5pt">plus</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo rspace="7.5pt">mult</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">first</mo>
            <mi>x</mi>
           </mrow>
           <mo rspace="7.5pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">second</mo>
           <mi>y</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo rspace="7.5pt">mult</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">second</mo>
           <mi>x</mi>
          </mrow>
          <mo rspace="7.5pt" stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo rspace="7.5pt">first</mo>
          <mi>y</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>mult</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <apply>
      <ci>pair</ci>
      <apply>
       <apply>
        <ci>plus</ci>
        <apply>
         <apply>
          <ci>mult</ci>
          <apply>
           <ci>first</ci>
           <ci>x</ci>
          </apply>
         </apply>
         <apply>
          <ci>first</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <ci>mult</ci>
         <apply>
          <ci>second</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <apply>
         <ci>second</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <ci>plus</ci>
       <apply>
        <apply>
         <ci>mult</ci>
         <apply>
          <ci>first</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <apply>
         <ci>second</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <ci>mult</ci>
        <apply>
         <ci>second</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <ci>first</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{mult}_{s}=\lambda x.\lambda y.\operatorname{pair}\ (%
\operatorname{plus}\ (\operatorname{mult}\ (\operatorname{first}\ x)\ (%
\operatorname{first}\ y))\ (\operatorname{mult}\ (\operatorname{second}\ x)\ (%
\operatorname{second}\ y)))\ (\operatorname{plus}\ (\operatorname{mult}\ (%
\operatorname{first}\ x)\ (\operatorname{second}\ y))\ (\operatorname{mult}\ (%
\operatorname{second}\ x)\ (\operatorname{first}\ y)))
  </annotation>
 </semantics>
</math>

</p>

<p>A similar definition is given here for division, except in this definition, one value in each pair must be zero (see <em>OneZero</em> above). The <em>divZ</em> function allows us to ignore the value that has a zero component.</p>

<p>

<math display="block" id="Church_encoding:175">
 <semantics>
  <mrow>
   <mrow>
    <mo>divZ</mo>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">IsZero</mo>
     <mrow>
      <mi>y</mi>
      <mpadded width="+5pt">
       <mn>0</mn>
      </mpadded>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">divide</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>divZ</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>IsZero</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <cn type="float">0</cn>
      </apply>
     </apply>
     <apply>
      <ci>divide</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{divZ}=\lambda x.\lambda y.\operatorname{IsZero}\ y\ 0\ (%
\operatorname{divide}\ x\ y)
  </annotation>
 </semantics>
</math>

</p>

<p><em>divZ</em> is then used in the following formula, which is the same as for multiplication, but with <em>mult</em> replaced by <em>divZ</em>.</p>

<p>

<math display="block" id="Church_encoding:176">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>divide</mo>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">pair</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo rspace="7.5pt">plus</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mo rspace="7.5pt">divZ</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mo rspace="7.5pt">first</mo>
             <mi>x</mi>
            </mrow>
            <mo rspace="7.5pt" stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">first</mo>
            <mi>y</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo rspace="7.5pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo rspace="7.5pt">divZ</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">second</mo>
            <mi>x</mi>
           </mrow>
           <mo rspace="7.5pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">second</mo>
           <mi>y</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo rspace="7.5pt">plus</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo rspace="7.5pt">divZ</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo rspace="7.5pt">first</mo>
            <mi>x</mi>
           </mrow>
           <mo rspace="7.5pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">second</mo>
           <mi>y</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo rspace="7.5pt">divZ</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo rspace="7.5pt">second</mo>
           <mi>x</mi>
          </mrow>
          <mo rspace="7.5pt" stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo rspace="7.5pt">first</mo>
          <mi>y</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>divide</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <apply>
      <ci>pair</ci>
      <apply>
       <apply>
        <ci>plus</ci>
        <apply>
         <apply>
          <ci>divZ</ci>
          <apply>
           <ci>first</ci>
           <ci>x</ci>
          </apply>
         </apply>
         <apply>
          <ci>first</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <ci>divZ</ci>
         <apply>
          <ci>second</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <apply>
         <ci>second</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <ci>plus</ci>
       <apply>
        <apply>
         <ci>divZ</ci>
         <apply>
          <ci>first</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <apply>
         <ci>second</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <ci>divZ</ci>
        <apply>
         <ci>second</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <ci>first</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{divide}_{s}=\lambda x.\lambda y.\operatorname{pair}\ (%
\operatorname{plus}\ (\operatorname{divZ}\ (\operatorname{first}\ x)\ (%
\operatorname{first}\ y))\ (\operatorname{divZ}\ (\operatorname{second}\ x)\ (%
\operatorname{second}\ y)))\ (\operatorname{plus}\ (\operatorname{divZ}\ (%
\operatorname{first}\ x)\ (\operatorname{second}\ y))\ (\operatorname{divZ}\ (%
\operatorname{second}\ x)\ (\operatorname{first}\ y)))
  </annotation>
 </semantics>
</math>

</p>
<h2 id="rational-and-real-numbers">Rational and real numbers</h2>

<p>Rational and real numbers may also be encoded in lambda calculus. Rational numbers may be encoded as a pair of signed numbers. Real numbers may be encoded by a limiting process that guarantees that the difference from the real value differs by a number which may be made as small as we need<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> .<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The references given describe software that could, in theory, be translated into lambda calculus. Once real numbers are defined, complex numbers are naturally encoded as a pair of real numbers.</p>

<p>The data types and functions described above demonstrate that any data type or calculation may be encoded in lambda calculus. This is the <a href="Church-Turing_thesis" title="wikilink">Church-Turing thesis</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lambda_calculus" title="wikilink">Lambda calculus</a></li>
<li><a href="System_F" title="wikilink">System F</a> for Church numerals in a typed calculus</li>
<li><a href="Mogensen–Scott_encoding" title="wikilink">Mogensen–Scott encoding</a></li>
<li><a href="Ordinal_number#Von_Neumann_definition_of_ordinals" title="wikilink">Von Neumann definition of ordinals</a> — another way to encode natural numbers: as sets</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.cs.uiowa.edu/~astump/papers/archon.pdf">Directly Reﬂective Meta-Programming</a></li>
<li><a href="http://www.cs.rice.edu/~javaplt/311/Readings/supplemental.pdf">Church numerals and booleans explained</a> by Robert Cartwright at <a href="Rice_University" title="wikilink">Rice University</a></li>
<li><a href="http://www.archive.org/download/TheoreticalFoundationsForPracticaltotallyFunctionalProgramming/33429551_PHD_totalthesis.pdf">Theoretical Foundations For Practical 'Totally Functional Programming'</a> (Chapters 2 and 5) All about Church and other similar encodings, including how to derive them and operations on them, from first principles</li>
<li><a href="http://www.csse.monash.edu.au/~lloyd/tildeFP/Lambda/Examples/const-int/">Some interactive examples of Church numerals</a></li>
</ul>
<references>
</references>

<p>"</p>

<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">This formula is the definition of a Church numeral n with f -&gt; m, x -&gt; f.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">John Tromp, Binary Lambda Calculus and Combinatory Logic, in <em>Randomness And Complexity, from Leibniz To Chaitin</em>, ed. Cristian S. Calude, World Scientific Publishing Company, October 2008. <a href="http://tromp.github.io/cl/LC.pdf">(pdf version)</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>

