   Blum–Goldwasser cryptosystem      Blum–Goldwasser cryptosystem   The Blum-Goldwasser (BG) cryptosystem is an asymmetric key encryption algorithm proposed by Manuel Blum and Shafi Goldwasser in 1984. Blum-Goldwasser is a probabilistic , semantically secure cryptosystem with a constant-size ciphertext expansion . The encryption algorithm implements an XOR-based stream cipher using the Blum Blum Shub (BBS) pseudo-random number generator to generate the keystream . Decryption is accomplished by manipulating the final state of the BBS generator using the private key , in order to find the initial seed and reconstruct the keystream.  The BG cryptosystem is semantically secure based on the assumed intractability of integer factorization ; specifically, factoring a composite value    N  =   p  q       N    p  q     N=pq   where    p  ,  q     p  q    p,q   are large primes . BG has multiple advantages over earlier probabilistic encryption schemes such as the Goldwasser-Micali cryptosystem . First, its semantic security reduces solely to integer factorization, without requiring any additional assumptions (e.g., hardness of the quadratic residuosity problem or the RSA problem ). Secondly, BG is efficient in terms of storage, inducing a constant-size ciphertext expansion regardless of message length. BG is also relatively efficient in terms of computation, and fares well even in comparison with cryptosystems such as RSA (depending on message length and exponent choices). However, BG is highly vulnerable to adaptive chosen ciphertext attacks (see below).  Because encryption is performed using a probabilistic algorithm, a given plaintext may produce very different ciphertexts each time it is encrypted. This has significant advantages, as it prevents an adversary from recognizing intercepted messages by comparing them to a dictionary of known ciphertexts.  Scheme definition  Note that the following description is a draft, and may contain errors!  Blum-Goldwasser consists of three algorithms: a probabilistic key generation algorithm which produces a public and a private key, a probabilistic encryption algorithm, and a deterministic decryption algorithm.  Key generation  To allow for decryption, the modulus used in Blum-Goldwasser encryption should be a Blum integer . This value is generated in the same manner as an RSA modulus, except that the prime factors    (  p  ,  q  )     p  q    (p,q)   must be congruent to 3 mod 4. (See RSA , key generation for details.)   Alice generates two large prime numbers     p    p   p\,   and    q    q   q\,   such that    p  ≠  q      p  q    p\neq q   , randomly and independently of each other, where    p  ≡  q  ≡  3        p  q       3     p\equiv q\equiv 3   mod   4   4   4   .   RFC 4086 section "6.2.2. The Blum Blum Shub Sequence Generator"   Alice computes    N  =   p  q       N    p  q     N=pq   .   The public key is   N   N   N   . The private key is the factorization    (  p  ,  q  )     p  q    (p,q)   . 1   Alice keeps the private key secret.    Alice gives   N   N   N   to Bob.   Message encryption  Suppose Bob wishes to send a message m to Alice:   Bob first encodes   m   m   m   as a string of   L   L   L   bits    (   m  0   ,  …  ,   m   L  -  1    )      subscript  m  0   normal-…   subscript  m    L  1      (m_{0},\dots,m_{L-1})   .  Bob selects a random element   r   r   r   , where    1  <  r  <  N        1  r       N     1   , and computes     x  0   =     r  2    m  o   d   N        subscript  x  0      superscript  r  2   m  o  d  N     x_{0}=r^{2}~{}mod~{}N   .  Bob uses the BBS pseudo-random number generator to generate   L   L   L   random bits     b  →   =   (   b  0   ,  …  ,   b   L  -  1    )        normal-→  b     subscript  b  0   normal-…   subscript  b    L  1       {\vec{b}}=(b_{0},\dots,b_{L-1})   (the keystream), as follows:  For    i  =  0      i  0    i=0   to   L   L   L   :  Set    b  i     subscript  b  i    b_{i}   equal to the least-significant bit of    x  i     subscript  x  i    x_{i}   .  Increment   i   i   i   .  Compute     x  i   =      (   x   i  -  1    )   2    m  o   d   N        subscript  x  i      superscript   subscript  x    i  1    2   m  o  d  N     x_{i}=(x_{i-1})^{2}~{}mod~{}N   .   Bob computes the ciphertext bits using the bits from the BBS as a stream cipher keystream, XORing the plaintext bits with the keystream:  For    i  =  0      i  0    i=0   to    L  -  1      L  1    L-1   :       c  →   =    m  →   ⊕   b  →         normal-→  c    direct-sum   normal-→  m    normal-→  b      {\vec{c}}={\vec{m}}\oplus{\vec{b}}        Bob sends a message to Alice -- the enciphered bits and the final    x  L     subscript  x  L    x_{L}   value     (   c  0   ,  …  ,   c   L  -  1    )   ,   x  L        subscript  c  0   normal-…   subscript  c    L  1      subscript  x  L     (c_{0},\dots,c_{L-1}),x_{L}   .   (The value    x  L     subscript  x  L    x_{L}   is equal to     x  L   =     x  0   2  L     m  o   d   N        subscript  x  L      superscript   subscript  x  0    superscript  2  L    m  o  d  N     x_{L}=x_{0}^{2^{L}}~{}mod~{}N   . )  To improve performance, the BBS generator can securely output up to    O   (   l  o  g  l  o  g  N   )       O    l  o  g  l  o  g  N     O(loglogN)   of the least-significant bits of    x  i     subscript  x  i    x_{i}   during each round. See Blum Blum Shub for details.  Message decryption  Alice receives     (   c  0   ,  …  ,   c   L  -  1    )   ,  y       subscript  c  0   normal-…   subscript  c    L  1     y    (c_{0},\dots,c_{L-1}),y   . She can recover   m   m   m   using the following procedure:   Using the prime factorization    (  p  ,  q  )     p  q    (p,q)   , Alice computes     r  p   =     y    (    (   p  +  1   )   /  4   )   L     m  o   d   p        subscript  r  p      superscript  y   superscript      p  1   4   L    m  o  d  p     r_{p}=y^{((p+1)/4)^{L}}~{}mod~{}p   and     r  q   =     y    (    (   q  +  1   )   /  4   )   L     m  o   d   q        subscript  r  q      superscript  y   superscript      q  1   4   L    m  o  d  q     r_{q}=y^{((q+1)/4)^{L}}~{}mod~{}q   .  Compute the initial seed     x  0   =    (    q   (     q   -  1     m  o   d   p   )    r  p    +   p   (     p   -  1     m  o   d   q   )    r  q     )   m  o   d   N        subscript  x  0         q     superscript  q    1    m  o  d  p    subscript  r  p      p     superscript  p    1    m  o  d  q    subscript  r  q     m  o  d  N     x_{0}=(q(q^{-1}~{}{mod}~{}p)r_{p}+p(p^{-1}~{}{mod}~{}q)r_{q})~{}{mod}~{}N     From    x  0     subscript  x  0    x_{0}   , recompute the bit-vector    b  →     normal-→  b    {\vec{b}}   using the BBS generator, as in the encryption algorithm.  Compute the plaintext by XORing the keystream with the ciphertext     m  →   =    c  →   ⊕   b  →         normal-→  m    direct-sum   normal-→  c    normal-→  b      {\vec{m}}={\vec{c}}\oplus{\vec{b}}   .   Alice recovers the plaintext    m  =   (   m  0   ,  …  ,   m   L  -  1    )       m    subscript  m  0   normal-…   subscript  m    L  1       m=(m_{0},\dots,m_{L-1})   .  Security and efficiency  The Blum-Goldwasser scheme is semantically-secure based on the hardness of predicting the keystream bits given only the final BBS state   y   y   y   and the public key   N   N   N   . However, ciphertexts of the form     c  →   ,  y      normal-→  c   y    {\vec{c}},y   are vulnerable to an adaptive chosen ciphertext attack in which the adversary requests the decryption    m  ′     superscript  m  normal-′    m^{\prime}   of a chosen ciphertext     a  →   ,  y      normal-→  a   y    {\vec{a}},y   . The decryption   m   m   m   of the original ciphertext can be computed as     a  →   ⊕   m  ′   ⊕   c  →      direct-sum   normal-→  a    superscript  m  normal-′    normal-→  c     {\vec{a}}\oplus m^{\prime}\oplus{\vec{c}}   .  Depending on plaintext size, BG may be more or less computationally expensive than RSA. Because most RSA deployments use a fixed encryption exponent optimized to minimize encryption time, RSA encryption will typically outperform BG for all but the shortest messages. However, as the RSA decryption exponent is randomly distributed, modular exponentiation may require a comparable number of squarings/multiplications to BG decryption for a ciphertext of the same length. BG has the advantage of scaling more efficiently to longer ciphertexts, where RSA requires multiple separate encryptions. In these cases, BG may be significantly more efficient.  References   M. Blum, S. Goldwasser, "An Efficient Probabilistic Public Key Encryption Scheme which Hides All Partial Information", Proceedings of Advances in Cryptology - CRYPTO '84 , pp. 289–299, Springer Verlag, 1985.  Menezes, Alfred; van Oorschot, Paul C.; and Vanstone, Scott A. Handbook of Applied Cryptography . CRC Press, October 1996. ISBN 0-8493-8523-7   External links   Menezes, Oorschot, Vanstone, Scott: Handbook of Applied Cryptography (free PDF downloads), see Chapter 8   "  Category:Public-key encryption schemes         