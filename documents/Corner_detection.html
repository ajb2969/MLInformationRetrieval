<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1879">Corner detection</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Corner detection</h1>
<hr/>

<p> </p>

<p><strong>Corner detection</strong> is an approach used within <a href="computer_vision" title="wikilink">computer vision</a> systems to extract certain kinds of <a href="feature_detection" title="wikilink">features</a> and infer the contents of an image. Corner detection is frequently used in <a href="motion_detection" title="wikilink">motion detection</a>, <a href="image_registration" title="wikilink">image registration</a>, <a href="video_tracking" title="wikilink">video tracking</a>, <a href="photographic_mosaic" title="wikilink">image mosaicing</a>, <a href="panorama_stitching" title="wikilink">panorama stitching</a>, <a href="3D_modelling" title="wikilink">3D modelling</a> and <a href="object_recognition" title="wikilink">object recognition</a>. Corner detection overlaps with the topic of <strong><a href="interest_point_detection" title="wikilink">interest point detection</a></strong>.</p>
<h2 id="formalization">Formalization</h2>

<p>A corner can be defined as the intersection of two edges. A corner can also be defined as a point for which there are two dominant and different edge directions in a local neighbourhood of the point.</p>

<p>An interest point is a point in an image which has a well-defined position and can be robustly detected. This means that an interest point can be a corner but it can also be, for example, an isolated point of local intensity maximum or minimum, line endings, or a point on a curve where the curvature is locally maximal.</p>

<p>In practice, most so-called corner detection methods detect interest points in general, and in fact, the term "corner" and "interest point" are used more or less interchangably through the literature.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> As a consequence, if only corners are to be detected it is necessary to do a local analysis of detected interest points to determine which of these are real corners. Examples of edge detection that can be used with post-processing to detect corners are the <a href="Kirsch_operator" title="wikilink">Kirsch operator</a> and the Frei-Chen masking set.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>"Corner", "interest point" and "feature" are used interchangeably in literature, confusing the issue. Specifically, there are several <a href="blob_detection" title="wikilink">blob detectors</a> that can be referred to as "interest point operators", but which are sometimes erroneously referred to as "corner detectors". Moreover, there exists a notion of <a href="ridge_detection" title="wikilink">ridge detection</a> to capture the presence of elongated objects.</p>

<p>Corner detectors are not usually very robust and often require large redundancies introduced to prevent the effect of individual errors from dominating the recognition task.</p>

<p>One determination of the quality of a corner detector is its ability to detect the same corner in multiple similar images, under conditions of different lighting, translation, rotation and other transforms.</p>

<p>A simple approach to corner detection in images is using <a class="uri" href="correlation" title="wikilink">correlation</a>, but this gets very computationally expensive and suboptimal. An alternative approach used frequently is based on a method proposed by Harris and Stephens (below), which in turn is an improvement of a method by Moravec.</p>
<h2 id="the-moravec-corner-detection-algorithm">The Moravec corner detection algorithm</h2>

<p>This is one of the earliest corner detection algorithms and defines a corner to be a point with low self-similarity.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The algorithm tests each pixel in the image to see if a corner is present, by considering how similar a patch centered on the pixel is to nearby, largely overlapping patches. The similarity is measured by taking the sum of squared differences (SSD) between the two patches. A lower number indicates more similarity.</p>

<p>If the pixel is in a region of uniform intensity, then the nearby patches will look similar. If the pixel is on an edge, then nearby patches in a direction perpendicular to the edge will look quite different, but nearby patches in a direction parallel to the edge will result only in a small change. If the pixel is on a feature with variation in all directions, then none of the nearby patches will look similar.</p>

<p>The corner strength is defined as the smallest SSD between the patch and its neighbors (horizontal, vertical and on the two diagonals). If this number is locally maximal, then a feature of interest is present.</p>

<p>As pointed out by Moravec, one of the main problems with this operator is that it is not <a class="uri" href="isotropic" title="wikilink">isotropic</a>: if an edge is present that is not in the direction of the neighbours, then the smallest SSD will be large and the edge will be incorrectly chosen as an interest point.</p>
<h2 id="the-harris-stephens-plessey-shitomasi-corner-detection-algorithm">The Harris &amp; Stephens / Plessey / Shi–Tomasi corner detection algorithm</h2>

<p>Harris and Stephens<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> improved upon Moravec's corner detector by considering the differential of the corner score with respect to direction directly, instead of using shifted patches. (This corner score is often referred to as <a class="uri" href="autocorrelation" title="wikilink">autocorrelation</a>, since the term is used in the paper in which this detector is described. However, the mathematics in the paper clearly indicate that the sum of squared differences is used.)</p>

<p>Without loss of generality, we will assume a grayscale 2-dimensional image is used. Let this image be given by 

<math display="inline" id="Corner_detection:0">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

. Consider taking an image patch over the area 

<math display="inline" id="Corner_detection:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)
  </annotation>
 </semantics>
</math>

 and shifting it by 

<math display="inline" id="Corner_detection:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

. The weighted <em>sum of squared differences</em> (SSD) between these two patches, denoted 

<math display="inline" id="Corner_detection:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, is given by:</p>

<p>

<math display="block" id="Corner_detection:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>u</mi>
    </munder>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>v</mi>
     </munder>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <msup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mi>I</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>u</mi>
            <mo>+</mo>
            <mi>x</mi>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>v</mi>
            <mo>+</mo>
            <mi>y</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>I</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>u</mi>
           <mo>,</mo>
           <mi>v</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>u</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>v</ci>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>I</ci>
          <interval closure="open">
           <apply>
            <plus></plus>
            <ci>u</ci>
            <ci>x</ci>
           </apply>
           <apply>
            <plus></plus>
            <ci>v</ci>
            <ci>y</ci>
           </apply>
          </interval>
         </apply>
         <apply>
          <times></times>
          <ci>I</ci>
          <interval closure="open">
           <ci>u</ci>
           <ci>v</ci>
          </interval>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(x,y)=\sum_{u}\sum_{v}w(u,v)\,\left(I(u+x,v+y)-I(u,v)\right)^{2}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Corner_detection:5">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>u</mi>
     <mo>+</mo>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>v</mi>
     <mo>+</mo>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <interval closure="open">
     <apply>
      <plus></plus>
      <ci>u</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>v</ci>
      <ci>y</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(u+x,v+y)
  </annotation>
 </semantics>
</math>

 can be approximated by a <a href="Taylor_series" title="wikilink">Taylor expansion</a>. Let 

<math display="inline" id="Corner_detection:6">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Corner_detection:7">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{y}
  </annotation>
 </semantics>
</math>

 be the partial <a href="Image_Derivatives" title="wikilink">derivatives</a> of 

<math display="inline" id="Corner_detection:8">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

, such that</p>

<p>

<math display="block" id="Corner_detection:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>+</mo>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>v</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>y</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>I</ci>
     <interval closure="open">
      <apply>
       <plus></plus>
       <ci>u</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>v</ci>
       <ci>y</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>I</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>x</ci>
      </apply>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>y</ci>
      </apply>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(u+x,v+y)\approx I(u,v)+I_{x}(u,v)x+I_{y}(u,v)y
  </annotation>
 </semantics>
</math>

</p>

<p>This produces the approximation</p>

<p>

<math display="block" id="Corner_detection:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>u</mi>
     </munder>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>v</mi>
      </munder>
      <mrow>
       <mi>w</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mrow>
           <msub>
            <mi>I</mi>
            <mi>x</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>u</mi>
            <mo>,</mo>
            <mi>v</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>x</mi>
          </mrow>
          <mo>+</mo>
          <mrow>
           <msub>
            <mi>I</mi>
            <mi>y</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>u</mi>
            <mo>,</mo>
            <mi>v</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>y</mi>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>S</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>u</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>v</ci>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>I</ci>
           <ci>x</ci>
          </apply>
          <interval closure="open">
           <ci>u</ci>
           <ci>v</ci>
          </interval>
          <ci>x</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>I</ci>
           <ci>y</ci>
          </apply>
          <interval closure="open">
           <ci>u</ci>
           <ci>v</ci>
          </interval>
          <ci>y</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(x,y)\approx\sum_{u}\sum_{v}w(u,v)\,\left(I_{x}(u,v)x+I_{y}(u,v)y\right)^{2},
  </annotation>
 </semantics>
</math>

</p>

<p>which can be written in matrix form:</p>

<p>

<math display="block" id="Corner_detection:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>x</mi>
        </mtd>
        <mtd columnalign="center">
         <mi>y</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mi>A</mi>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>x</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>y</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>S</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <ci>x</ci>
       <ci>y</ci>
      </matrixrow>
     </matrix>
     <ci>A</ci>
     <matrix>
      <matrixrow>
       <ci>x</ci>
      </matrixrow>
      <matrixrow>
       <ci>y</ci>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(x,y)\approx\begin{pmatrix}x&y\end{pmatrix}A\begin{pmatrix}x\\
y\end{pmatrix},
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>A</em> is the <a href="structure_tensor" title="wikilink">structure tensor</a>,</p>

<p>

<math display="block" id="Corner_detection:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>u</mi>
    </munder>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>v</mi>
     </munder>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msubsup>
           <mi>I</mi>
           <mi>x</mi>
           <mn>2</mn>
          </msubsup>
         </mtd>
         <mtd columnalign="center">
          <mrow>
           <msub>
            <mi>I</mi>
            <mi>x</mi>
           </msub>
           <msub>
            <mi>I</mi>
            <mi>y</mi>
           </msub>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <msub>
            <mi>I</mi>
            <mi>x</mi>
           </msub>
           <msub>
            <mi>I</mi>
            <mi>y</mi>
           </msub>
          </mrow>
         </mtd>
         <mtd columnalign="center">
          <msubsup>
           <mi>I</mi>
           <mi>y</mi>
           <mn>2</mn>
          </msubsup>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo stretchy="false">⟨</mo>
        <msubsup>
         <mi>I</mi>
         <mi>x</mi>
         <mn>2</mn>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mrow>
         <msub>
          <mi>I</mi>
          <mi>x</mi>
         </msub>
         <msub>
          <mi>I</mi>
          <mi>y</mi>
         </msub>
        </mrow>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mrow>
         <msub>
          <mi>I</mi>
          <mi>x</mi>
         </msub>
         <msub>
          <mi>I</mi>
          <mi>y</mi>
         </msub>
        </mrow>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo stretchy="false">⟨</mo>
        <msubsup>
         <mi>I</mi>
         <mi>y</mi>
         <mn>2</mn>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>A</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>u</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>v</ci>
       </apply>
       <apply>
        <times></times>
        <ci>w</ci>
        <interval closure="open">
         <ci>u</ci>
         <ci>v</ci>
        </interval>
        <matrix>
         <matrixrow>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>I</ci>
            <ci>x</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>I</ci>
            <ci>x</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>I</ci>
            <ci>y</ci>
           </apply>
          </apply>
         </matrixrow>
         <matrixrow>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>I</ci>
            <ci>x</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>I</ci>
            <ci>y</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>I</ci>
            <ci>y</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </matrixrow>
        </matrix>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>x</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>y</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\sum_{u}\sum_{v}w(u,v)\begin{bmatrix}I_{x}^{2}&I_{x}I_{y}\\
I_{x}I_{y}&I_{y}^{2}\end{bmatrix}=\begin{bmatrix}\langle I_{x}^{2}\rangle&%
\langle I_{x}I_{y}\rangle\\
\langle I_{x}I_{y}\rangle&\langle I_{y}^{2}\rangle\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>This matrix is a Harris matrix, and angle brackets denote averaging (i.e. summation over 

<math display="inline" id="Corner_detection:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)
  </annotation>
 </semantics>
</math>

). If a circular window (or circularly weighted window, such as a <a href="Gaussian_function" title="wikilink">Gaussian</a>) is used, then the response will be isotropic.</p>

<p>A corner (or in general an interest point) is characterized by a large variation of 

<math display="inline" id="Corner_detection:14">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 in all directions of the vector 

<math display="inline" id="Corner_detection:15">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mi>x</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>y</mi>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <ci>x</ci>
     <ci>y</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}x&y\end{pmatrix}
  </annotation>
 </semantics>
</math>

. By analyzing the eigenvalues of 

<math display="inline" id="Corner_detection:16">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


, this characterization can be expressed in the following way

<math display="block" id="Corner_detection:17">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 should have two "large" eigenvalues for an interest point. Based on the magnitudes of the eigenvalues, the following inferences can be made based on this argument:</p>
<ol>
<li>If 

<math display="inline" id="Corner_detection:18">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mn>1</mn>
   </msub>
   <mo>≈</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{1}\approx 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Corner_detection:19">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mn>2</mn>
   </msub>
   <mo>≈</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{2}\approx 0
  </annotation>
 </semantics>
</math>

 then this pixel 

<math display="inline" id="Corner_detection:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 has no features of interest.</li>
<li>If 

<math display="inline" id="Corner_detection:21">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mn>1</mn>
   </msub>
   <mo>≈</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{1}\approx 0
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Corner_detection:22">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{2}
  </annotation>
 </semantics>
</math>

 has some large positive value, then an edge is found.</li>
<li>If 

<math display="inline" id="Corner_detection:23">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Corner_detection:24">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{2}
  </annotation>
 </semantics>
</math>

 have large positive values, then a corner is found.</li>
</ol>

<p>Harris and Stephens note that exact computation of the eigenvalues is computationally expensive, since it requires the computation of a <a href="square_root" title="wikilink">square root</a>, and instead suggest the following function 

<math display="inline" id="Corner_detection:25">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{c}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Corner_detection:26">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>


 is a tunable sensitivity parameter:</p>

<p>

<math display="block" id="Corner_detection:27">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>λ</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>κ</mi>
     </mpadded>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>λ</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>λ</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>det</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>κ</mi>
     </mpadded>
     <mrow>
      <msup>
       <mo>trace</mo>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>κ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <ci>det</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>κ</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>trace</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{c}=\lambda_{1}\lambda_{2}-\kappa\,(\lambda_{1}+\lambda_{2})^{2}=%
\operatorname{det}(A)-\kappa\,\operatorname{trace}^{2}(A)
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, the algorithm does not have to actually compute the <a href="eigenvalue_decomposition" title="wikilink">eigenvalue decomposition</a> of the matrix 

<math display="inline" id="Corner_detection:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and instead it is sufficient to evaluate the <a class="uri" href="determinant" title="wikilink">determinant</a> and <a href="Trace_(linear_algebra)" title="wikilink">trace</a> of 

<math display="inline" id="Corner_detection:29">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to find corners, or rather interest points in general.</p>

<p>The Shi–Tomasi<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> corner detector directly computes 

<math display="inline" id="Corner_detection:30">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>λ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>λ</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>i</ci>
    <ci>n</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   min(\lambda_{1},\lambda_{2})
  </annotation>
 </semantics>
</math>

 because under certain assumptions, the corners are more stable for tracking. Note that this method is also sometimes referred to as the Kanade-Tomasi corner detector.</p>

<p>The value of 

<math display="inline" id="Corner_detection:31">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 has to be determined empirically, and in the literature values in the range 0.04–0.15 have been reported as feasible.</p>

<p>One can avoid setting the parameter 

<math display="inline" id="Corner_detection:32">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 by using Noble's<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> corner measure 

<math display="inline" id="Corner_detection:33">
 <semantics>
  <msubsup>
   <mi>M</mi>
   <mi>c</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>c</ci>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{c}^{\prime}
  </annotation>
 </semantics>
</math>

 which amounts to the <a href="harmonic_mean" title="wikilink">harmonic mean</a> of the eigenvalues:</p>

<p>

<math display="block" id="Corner_detection:34">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>M</mi>
     <mi>c</mi>
     <mo>′</mo>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mfrac>
      <mrow>
       <mo>det</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo>trace</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mi>ϵ</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>c</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <divide></divide>
      <apply>
       <ci>det</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <ci>trace</ci>
        <ci>A</ci>
       </apply>
       <ci>ϵ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{c}^{\prime}=2\frac{\operatorname{det}(A)}{\operatorname{trace}(A)+\epsilon},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Corner_detection:35">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 being a small positive constant.</p>

<p>The <a href="covariance_matrix" title="wikilink">covariance matrix</a> for the corner position is 

<math display="inline" id="Corner_detection:36">
 <semantics>
  <msup>
   <mi>A</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{-1}
  </annotation>
 </semantics>
</math>

, i.e.</p>

<p>

<math display="block" id="Corner_detection:37">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <msubsup>
         <mi>I</mi>
         <mi>x</mi>
         <mn>2</mn>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <msubsup>
         <mi>I</mi>
         <mi>y</mi>
         <mn>2</mn>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <msup>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mrow>
         <msub>
          <mi>I</mi>
          <mi>x</mi>
         </msub>
         <msub>
          <mi>I</mi>
          <mi>y</mi>
         </msub>
        </mrow>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo stretchy="false">⟨</mo>
         <msubsup>
          <mi>I</mi>
          <mi>y</mi>
          <mn>2</mn>
         </msubsup>
         <mo stretchy="false">⟩</mo>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mrow>
          <mo stretchy="false">⟨</mo>
          <mrow>
           <msub>
            <mi>I</mi>
            <mi>x</mi>
           </msub>
           <msub>
            <mi>I</mi>
            <mi>y</mi>
           </msub>
          </mrow>
          <mo stretchy="false">⟩</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mrow>
          <mo stretchy="false">⟨</mo>
          <mrow>
           <msub>
            <mi>I</mi>
            <mi>x</mi>
           </msub>
           <msub>
            <mi>I</mi>
            <mi>y</mi>
           </msub>
          </mrow>
          <mo stretchy="false">⟩</mo>
         </mrow>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo stretchy="false">⟨</mo>
         <msubsup>
          <mi>I</mi>
          <mi>x</mi>
          <mn>2</mn>
         </msubsup>
         <mo stretchy="false">⟩</mo>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>x</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>y</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\langle I_{x}^{2}\rangle\langle I_{y}^{2}\rangle-\langle I_{x}I_{y}%
\rangle^{2}}\begin{bmatrix}\langle I_{y}^{2}\rangle&-\langle I_{x}I_{y}\rangle%
\\
-\langle I_{x}I_{y}\rangle&\langle I_{x}^{2}\rangle\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="the-förstner-corner-detector">The Förstner corner detector</h2>

<p> In some cases, one may wish to compute the location of a corner with subpixel accuracy. To achieve an approximate solution, the Förstner<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> algorithm solves for the point closest to all the tangent lines of the corner in a given window and is a least-square solution. The algorithm relies on the fact that for an ideal corner, tangent lines cross at a single point.</p>

<p>The equation of a tangent line 

<math display="inline" id="Corner_detection:38">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <msup>
     <mi>𝐱</mi>
     <mo>′</mo>
    </msup>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐱</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{\mathbf{x^{\prime}}}(\mathbf{x})
  </annotation>
 </semantics>
</math>

 at pixel 

<math display="inline" id="Corner_detection:39">
 <semantics>
  <msup>
   <mi>𝐱</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐱</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x^{\prime}}
  </annotation>
 </semantics>
</math>

 is given by:</p>

<p>

<math display="block" id="Corner_detection:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <msup>
      <mi>𝐱</mi>
      <mo>′</mo>
     </msup>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>I</mi>
    </mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>𝐱</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⊤</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐱</mi>
      <mo>-</mo>
      <msup>
       <mi>𝐱</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>I</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>normal-′</ci>
       </apply>
       <csymbol cd="latexml">top</csymbol>
      </apply>
      <apply>
       <minus></minus>
       <ci>𝐱</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{\mathbf{x^{\prime}}}(\mathbf{x})=\nabla I(\mathbf{x^{\prime}})^{\top}(%
\mathbf{x}-\mathbf{x^{\prime}})=0
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Corner_detection:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>I</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>𝐱</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>I</mi>
      <mi>𝐱</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>I</mi>
      <mi>𝐲</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>⊤</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐱</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <interval closure="closed">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>𝐱</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>𝐲</ci>
      </apply>
     </interval>
     <csymbol cd="latexml">top</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla I(\mathbf{x^{\prime}})=[I_{\mathbf{x}},I_{\mathbf{y}}]^{\top}
  </annotation>
 </semantics>
</math>

 is the gradient vector of the image 

<math display="inline" id="Corner_detection:42">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Corner_detection:43">
 <semantics>
  <msup>
   <mi>𝐱</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐱</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x^{\prime}}
  </annotation>
 </semantics>
</math>

.</p>

<p>The point 

<math display="inline" id="Corner_detection:44">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{0}
  </annotation>
 </semantics>
</math>

 closest to all the tangent lines in the window 

<math display="inline" id="Corner_detection:45">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 is:</p>

<p>

<math display="block" id="Corner_detection:46">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mo>argmin</mo>
     <mrow>
      <mi>𝐱</mi>
      <mo>∈</mo>
      <msup>
       <mi>ℝ</mi>
       <mrow>
        <mn>2</mn>
        <mo>×</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <msup>
        <mi>𝐱</mi>
        <mo>′</mo>
       </msup>
       <mo>∈</mo>
       <mi>N</mi>
      </mrow>
     </msub>
     <mrow>
      <msub>
       <mi>T</mi>
       <msup>
        <mi>𝐱</mi>
        <mo>′</mo>
       </msup>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝐱</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mi>d</mi>
      <msup>
       <mi>𝐱</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>𝐱</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>argmin</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐱</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐱</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{0}=\underset{\mathbf{x}\in\mathbb{R}^{2\times 2}}{\operatorname{%
argmin}}\int_{\mathbf{x^{\prime}}\in N}T_{\mathbf{x^{\prime}}}(\mathbf{x})^{2}%
d\mathbf{x^{\prime}}
  </annotation>
 </semantics>
</math>

</p>

<p>The distance from 

<math display="inline" id="Corner_detection:47">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{0}
  </annotation>
 </semantics>
</math>

 to the tangent lines 

<math display="inline" id="Corner_detection:48">
 <semantics>
  <msub>
   <mi>T</mi>
   <msup>
    <mi>𝐱</mi>
    <mo>′</mo>
   </msup>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐱</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{\mathbf{x^{\prime}}}
  </annotation>
 </semantics>
</math>

 is weighted by the gradient magnitude, thus giving more importance to tangents passing through pixels with strong gradients.</p>

<p>Solving for 

<math display="inline" id="Corner_detection:49">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{0}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Corner_detection:50">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{x}_{0}
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Corner_detection:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mn>2</mn>
      <mo>×</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mtext>𝐛</mtext>
     <mo>∈</mo>
     <msup>
      <mi>ℝ</mi>
      <mrow>
       <mn>2</mn>
       <mo>×</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>c</mi>
     <mo>∈</mo>
     <mi>ℝ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <mtext>b</mtext>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>c</ci>
      <ci>ℝ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\mathbb{R}^{2\times 2},\textbf{b}\in\mathbb{R}^{2\times 1},c\in\mathbb{R}
  </annotation>
 </semantics>
</math>

 are defined as:</p>

<p>

<math display="inline" id="Corner_detection:52">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A
  </annotation>
 </semantics>
</math>


</p>

<p>Minimizing this equation can be done by differentiating with respect to 

<math display="inline" id="Corner_detection:53">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and setting it equal to 0:</p>

<p>

<math display="block" id="Corner_detection:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>A</mi>
     <mi>𝐱</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>𝐛</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>⇒</mo>
   <mrow>
    <mi>A</mi>
    <mi>𝐱</mi>
   </mrow>
   <mo>=</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>A</ci>
       <ci>𝐱</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>𝐛</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>𝐱</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>𝐛</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2A\mathbf{x}-2\mathbf{b}=0\Rightarrow A\mathbf{x}=\mathbf{b}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that 

<math display="inline" id="Corner_detection:55">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mn>2</mn>
     <mo>×</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\mathbb{R}^{2\times 2}
  </annotation>
 </semantics>
</math>

 is the <a href="structure_tensor" title="wikilink">structure tensor</a>. For the equation to have a solution, 

<math display="inline" id="Corner_detection:56">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 must be invertible, which implies that 

<math display="inline" id="Corner_detection:57">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 must be full rank (rank 2). Thus, the solution</p>

<p>

<math display="block" id="Corner_detection:58">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>𝐛</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>𝐛</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}=A^{-1}\mathbf{b}
  </annotation>
 </semantics>
</math>

</p>

<p>only exists where an actual corner exists in the window 

<math display="inline" id="Corner_detection:59">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

.</p>

<p>A methodology for performing <em>automatic scale selection</em> for this corner localization method has been presented by Lindeberg<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> by minimizing the normalized residual</p>

<p>

<math display="block" id="Corner_detection:60">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>d</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>c</mi>
     <mo>-</mo>
     <mrow>
      <msup>
       <mi>b</mi>
       <mi>T</mi>
      </msup>
      <msup>
       <mi>A</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>b</mi>
     </mrow>
    </mrow>
    <mrow>
     <mtext>trace</mtext>
     <mi>A</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>c</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>trace</mtext>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{d}_{min}=\frac{c-b^{T}A^{-1}b}{\mbox{trace}A}
  </annotation>
 </semantics>
</math>

</p>

<p>over scales. Thereby, the method has the ability to automatically adapt the scale levels for computing the image gradients to the noise level in the image data, by choosing coarser scale levels for noisy image data and finer scale levels for near ideal corner-like structures.</p>

<p>Notes:</p>
<ul>
<li>

<math display="inline" id="Corner_detection:61">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 can be viewed as a residual in the least-square solution computation: if 

<math display="inline" id="Corner_detection:62">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=0
  </annotation>
 </semantics>
</math>

, then there was no error.</li>
</ul>
<ul>
<li>this algorithm can be modified to compute centers of circular features by changing tangent lines to normal lines.</li>
</ul>
<h2 id="the-multi-scale-harris-operator">The multi-scale Harris operator</h2>

<p>The computation of the second moment matrix (sometimes also referred to as the <a href="structure_tensor" title="wikilink">structure tensor</a>) 

<math display="inline" id="Corner_detection:63">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 in the Harris operator, requires the computation of <a href="Image_Derivatives" title="wikilink">image derivatives</a> 

<math display="inline" id="Corner_detection:64">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>x</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>I</mi>
    <mi>y</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>y</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{x},I_{y}
  </annotation>
 </semantics>
</math>

 in the image domain as well as the summation of non-linear combinations of these derivatives over local neighbourhoods. Since the computation of derivatives usually involves a stage of scale-space smoothing, an operational definition of the Harris operator requires two scale parameters: (i) a <em>local scale</em> for smoothing prior to the computation of <a href="Image_Derivatives" title="wikilink">image derivatives</a>, and (ii) an <em>integration scale</em> for accumulating the non-linear operations on derivative operators into an integrated image descriptor.</p>

<p>With 

<math display="inline" id="Corner_detection:65">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 denoting the original image intensity, let 

<math display="inline" id="Corner_detection:66">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 denote the <a href="scale_space_representation" title="wikilink">scale space representation</a> of 

<math display="inline" id="Corner_detection:67">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 obtained by convolution with a Gaussian kernel</p>

<p>

<math display="block" id="Corner_detection:68">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msup>
           <mi>x</mi>
           <mn>2</mn>
          </msup>
          <mo>+</mo>
          <msup>
           <mi>y</mi>
           <mn>2</mn>
          </msup>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
       <mi>t</mi>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>y</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y,t)=\frac{1}{2{\pi}t}e^{-(x^{2}+y^{2})/2t}
  </annotation>
 </semantics>
</math>

 with local scale parameter 

<math display="inline" id="Corner_detection:69">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Corner_detection:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <mi>I</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>g</ci>
       <vector>
        <ci>x</ci>
        <ci>y</ci>
        <ci>t</ci>
       </vector>
      </apply>
      <ci>I</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y,t)\ =g(x,y,t)*I(x,y)
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Corner_detection:71">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>x</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>x</mi>
    </msub>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>x</ci>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}=\partial_{x}L
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Corner_detection:72">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>y</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>y</mi>
    </msub>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>y</ci>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{y}=\partial_{y}L
  </annotation>
 </semantics>
</math>

 denote the partial derivatives of 

<math display="inline" id="Corner_detection:73">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. Moreover, introduce a Gaussian window function 

<math display="inline" id="Corner_detection:74">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>s</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y,s)
  </annotation>
 </semantics>
</math>

 with integration scale parameter 

<math display="inline" id="Corner_detection:75">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. Then, the <a href="Structure_tensor#The_multi-scale_structure_tensor" title="wikilink"><em>multi-scale second-moment matrix</em></a> <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> can be defined as</p>

<p>

<math display="block" id="Corner_detection:76">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>μ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>;</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mi>ξ</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mi>η</mi>
        <mo>=</mo>
        <mrow>
         <mo>-</mo>
         <mi mathvariant="normal">∞</mi>
        </mrow>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <msubsup>
             <mi>L</mi>
             <mi>x</mi>
             <mn>2</mn>
            </msubsup>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>x</mi>
              <mo>-</mo>
              <mi>ξ</mi>
             </mrow>
             <mo>,</mo>
             <mrow>
              <mi>y</mi>
              <mo>-</mo>
              <mi>η</mi>
             </mrow>
             <mo>;</mo>
             <mi>t</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mtd>
          <mtd columnalign="center">
           <mrow>
            <msub>
             <mi>L</mi>
             <mi>x</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>x</mi>
              <mo>-</mo>
              <mi>ξ</mi>
             </mrow>
             <mo>,</mo>
             <mrow>
              <mi>y</mi>
              <mo>-</mo>
              <mi>η</mi>
             </mrow>
             <mo>;</mo>
             <mi>t</mi>
             <mo rspace="4.2pt" stretchy="false">)</mo>
            </mrow>
            <msub>
             <mi>L</mi>
             <mi>y</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>x</mi>
              <mo>-</mo>
              <mi>ξ</mi>
             </mrow>
             <mo>,</mo>
             <mrow>
              <mi>y</mi>
              <mo>-</mo>
              <mi>η</mi>
             </mrow>
             <mo>;</mo>
             <mi>t</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <msub>
             <mi>L</mi>
             <mi>x</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>x</mi>
              <mo>-</mo>
              <mi>ξ</mi>
             </mrow>
             <mo>,</mo>
             <mrow>
              <mi>y</mi>
              <mo>-</mo>
              <mi>η</mi>
             </mrow>
             <mo>;</mo>
             <mi>t</mi>
             <mo rspace="4.2pt" stretchy="false">)</mo>
            </mrow>
            <msub>
             <mi>L</mi>
             <mi>y</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>x</mi>
              <mo>-</mo>
              <mi>ξ</mi>
             </mrow>
             <mo>,</mo>
             <mrow>
              <mi>y</mi>
              <mo>-</mo>
              <mi>η</mi>
             </mrow>
             <mo>;</mo>
             <mi>t</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mtd>
          <mtd columnalign="center">
           <mrow>
            <msubsup>
             <mi>L</mi>
             <mi>y</mi>
             <mn>2</mn>
            </msubsup>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>x</mi>
              <mo>-</mo>
              <mi>ξ</mi>
             </mrow>
             <mo>,</mo>
             <mrow>
              <mi>y</mi>
              <mo>-</mo>
              <mi>η</mi>
             </mrow>
             <mo>;</mo>
             <mi>t</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mtd>
         </mtr>
        </mtable>
        <mo>]</mo>
       </mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ξ</mi>
        <mo>,</mo>
        <mi>η</mi>
        <mo>;</mo>
        <mi>s</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mpadded width="+1.7pt">
        <mi>ξ</mi>
       </mpadded>
       <mi>d</mi>
       <mi>η</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>μ</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
      <ci>s</ci>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <eq></eq>
        <ci>ξ</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <eq></eq>
         <ci>η</ci>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>L</ci>
            <ci>x</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <vector>
           <apply>
            <minus></minus>
            <ci>x</ci>
            <ci>ξ</ci>
           </apply>
           <apply>
            <minus></minus>
            <ci>y</ci>
            <ci>η</ci>
           </apply>
           <ci>t</ci>
          </vector>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>L</ci>
           <ci>x</ci>
          </apply>
          <vector>
           <apply>
            <minus></minus>
            <ci>x</ci>
            <ci>ξ</ci>
           </apply>
           <apply>
            <minus></minus>
            <ci>y</ci>
            <ci>η</ci>
           </apply>
           <ci>t</ci>
          </vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>L</ci>
           <ci>y</ci>
          </apply>
          <vector>
           <apply>
            <minus></minus>
            <ci>x</ci>
            <ci>ξ</ci>
           </apply>
           <apply>
            <minus></minus>
            <ci>y</ci>
            <ci>η</ci>
           </apply>
           <ci>t</ci>
          </vector>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>L</ci>
           <ci>x</ci>
          </apply>
          <vector>
           <apply>
            <minus></minus>
            <ci>x</ci>
            <ci>ξ</ci>
           </apply>
           <apply>
            <minus></minus>
            <ci>y</ci>
            <ci>η</ci>
           </apply>
           <ci>t</ci>
          </vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>L</ci>
           <ci>y</ci>
          </apply>
          <vector>
           <apply>
            <minus></minus>
            <ci>x</ci>
            <ci>ξ</ci>
           </apply>
           <apply>
            <minus></minus>
            <ci>y</ci>
            <ci>η</ci>
           </apply>
           <ci>t</ci>
          </vector>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>L</ci>
            <ci>y</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <vector>
           <apply>
            <minus></minus>
            <ci>x</ci>
            <ci>ξ</ci>
           </apply>
           <apply>
            <minus></minus>
            <ci>y</ci>
            <ci>η</ci>
           </apply>
           <ci>t</ci>
          </vector>
         </apply>
        </matrixrow>
       </matrix>
       <ci>g</ci>
       <vector>
        <ci>ξ</ci>
        <ci>η</ci>
        <ci>s</ci>
       </vector>
       <ci>d</ci>
       <ci>ξ</ci>
       <ci>d</ci>
       <ci>η</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(x,y;t,s)=\int_{\xi=-\infty}^{\infty}\int_{\eta=-\infty}^{\infty}\begin{%
bmatrix}L_{x}^{2}(x-\xi,y-\eta;t)&L_{x}(x-\xi,y-\eta;t)\,L_{y}(x-\xi,y-\eta;t)%
\\
L_{x}(x-\xi,y-\eta;t)\,L_{y}(x-\xi,y-\eta;t)&L_{y}^{2}(x-\xi,y-\eta;t)\end{%
bmatrix}g(\xi,\eta;s)\,d\xi\,d\eta.
  </annotation>
 </semantics>
</math>

 Then, we can compute eigenvalues of 

<math display="inline" id="Corner_detection:77">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 in a similar way as the eigenvalues of 

<math display="inline" id="Corner_detection:78">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and define the <em>multi-scale Harris corner measure</em> as</p>

<p>

<math display="block" id="Corner_detection:79">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>c</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>det</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>μ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo>;</mo>
        <mi>t</mi>
        <mo>,</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>κ</mi>
     </mpadded>
     <mrow>
      <msup>
       <mo>trace</mo>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>μ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo>;</mo>
         <mi>t</mi>
         <mo>,</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>c</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
      <ci>s</ci>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>det</ci>
      <apply>
       <times></times>
       <ci>μ</ci>
       <vector>
        <ci>x</ci>
        <ci>y</ci>
        <ci>t</ci>
        <ci>s</ci>
       </vector>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>κ</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>trace</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>μ</ci>
        <vector>
         <ci>x</ci>
         <ci>y</ci>
         <ci>t</ci>
         <ci>s</ci>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{c}(x,y;t,s)=\operatorname{det}(\mu(x,y;t,s))-\kappa\,\operatorname{trace}^{%
2}(\mu(x,y;t,s))
  </annotation>
 </semantics>
</math>

. Concerning the choice of the local scale parameter 

<math display="inline" id="Corner_detection:80">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and the integration scale parameter 

<math display="inline" id="Corner_detection:81">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, these scale parameters are usually coupled by a relative integration scale parameter 

<math display="inline" id="Corner_detection:82">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Corner_detection:83">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>γ</mi>
     <mn>2</mn>
    </msup>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>γ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\gamma^{2}t
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Corner_detection:84">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 is usually chosen in the interval 

<math display="inline" id="Corner_detection:85">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [1,2]
  </annotation>
 </semantics>
</math>

. Thus, we can compute the multi-scale Harris corner measure 

<math display="inline" id="Corner_detection:86">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>c</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>γ</mi>
      <mn>2</mn>
     </msup>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>c</ci>
    </apply>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>γ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{c}(x,y;t,\gamma^{2}t)
  </annotation>
 </semantics>
</math>

 at any scale 

<math display="inline" id="Corner_detection:87">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 in scale-space to obtain a multi-scale corner detector, which responds to corner structures of varying sizes in the image domain.</p>

<p>In practice, this multi-scale corner detector is often complemented by a <em>scale selection step</em>, where the scale-normalized Laplacian operator<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>

<math display="block" id="Corner_detection:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo>∇</mo>
      <mrow>
       <mi>n</mi>
       <mi>o</mi>
       <mi>r</mi>
       <mi>m</mi>
      </mrow>
      <mn>2</mn>
     </msubsup>
     <mi>L</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mi>t</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mrow>
     <msup>
      <mo>∇</mo>
      <mn>2</mn>
     </msup>
     <mi>L</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>L</mi>
        <mrow>
         <mi>x</mi>
         <mi>x</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>L</mi>
        <mrow>
         <mi>y</mi>
         <mi>y</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-∇</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>o</ci>
         <ci>r</ci>
         <ci>m</ci>
        </apply>
       </apply>
       <ci>L</ci>
      </apply>
      <vector>
       <ci>x</ci>
       <ci>y</ci>
       <ci>t</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-∇</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>L</ci>
      </apply>
      <vector>
       <ci>x</ci>
       <ci>y</ci>
       <ci>t</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <times></times>
          <ci>x</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <vector>
         <ci>x</ci>
         <ci>y</ci>
         <ci>t</ci>
        </vector>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <times></times>
          <ci>y</ci>
          <ci>y</ci>
         </apply>
        </apply>
        <vector>
         <ci>x</ci>
         <ci>y</ci>
         <ci>t</ci>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla^{2}_{norm}L(x,y;t)\ =t\nabla^{2}L(x,y,t)=t(L_{xx}(x,y,t)+L_{yy}(x,y,t))
  </annotation>
 </semantics>
</math>

 is computed at every scale in scale-space and <em>scale adapted corner points with automatic scale selection</em> (the "Harris-Laplace operator") are computed from the points that are simultaneously:<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<ul>
<li>spatial maxima of the multi-scale corner measure 

<math display="inline" id="Corner_detection:89">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>c</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>γ</mi>
      <mn>2</mn>
     </msup>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>c</ci>
    </apply>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>γ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{c}(x,y;t,\gamma^{2}t)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>

<math display="block" id="Corner_detection:90">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>;</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>argmaxlocal</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <msub>
      <mi>M</mi>
      <mi>c</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>γ</mi>
       <mn>2</mn>
      </msup>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <vector>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>y</ci>
     </apply>
     <ci>t</ci>
    </vector>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>argmaxlocal</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>γ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>t</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{x},\hat{y};t)=\operatorname{argmaxlocal}_{(x,y)}M_{c}(x,y;t,\gamma^{2}t)
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>local maxima or minima over scales of the scale-normalized Laplacian operator<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> 

<math display="inline" id="Corner_detection:91">
 <semantics>
  <mrow>
   <msubsup>
    <mo>∇</mo>
    <mrow>
     <mi>n</mi>
     <mi>o</mi>
     <mi>r</mi>
     <mi>m</mi>
    </mrow>
    <mn>2</mn>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-∇</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>o</ci>
      <ci>r</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <ci>x</ci>
    <ci>y</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla^{2}_{norm}(x,y,t)
  </annotation>
 </semantics>
</math>

:</li>
</ul>

<p>

<math display="block" id="Corner_detection:92">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>t</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mo>argmaxminlocal</mo>
       <mi>t</mi>
      </msub>
      <msubsup>
       <mo>∇</mo>
       <mrow>
        <mi>n</mi>
        <mi>o</mi>
        <mi>r</mi>
        <mi>m</mi>
       </mrow>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mi>L</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo>,</mo>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo>;</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>argmaxminlocal</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-∇</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>o</ci>
         <ci>r</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
      <ci>L</ci>
     </apply>
     <vector>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>y</ci>
      </apply>
      <ci>t</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{t}=\operatorname{argmaxminlocal}_{t}\nabla^{2}_{norm}L(\hat{x},\hat{y};t)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="the-level-curve-curvature-approach">The level curve curvature approach</h2>

<p>An earlier approach to corner detection is to detect points where the <a class="uri" href="curvature" title="wikilink">curvature</a> of level curves and the gradient magnitude are <em>simultaneously</em> high.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> A differential way to detect such points is by computing <em>the rescaled level curve curvature</em> (the product of the level curve curvature and the gradient magnitude raised to the power of three)</p>

<p>

<math display="block" id="Corner_detection:93">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>κ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msubsup>
       <mi>L</mi>
       <mi>x</mi>
       <mn>2</mn>
      </msubsup>
      <msub>
       <mi>L</mi>
       <mrow>
        <mi>y</mi>
        <mi>y</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msubsup>
       <mi>L</mi>
       <mi>y</mi>
       <mn>2</mn>
      </msubsup>
      <msub>
       <mi>L</mi>
       <mrow>
        <mi>x</mi>
        <mi>x</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>L</mi>
      <mi>x</mi>
     </msub>
     <msub>
      <mi>L</mi>
      <mi>y</mi>
     </msub>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>κ</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>y</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\kappa}(x,y;t)=L_{x}^{2}L_{yy}+L_{y}^{2}L_{xx}-2L_{x}L_{y}L_{xy}
  </annotation>
 </semantics>
</math>

 and to detect positive maxima and negative minima of this differential expression at some scale 

<math display="inline" id="Corner_detection:94">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 in the <a href="scale_space_representation" title="wikilink">scale space representation</a> 

<math display="inline" id="Corner_detection:95">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 of the original image.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> A main problem when computing the rescaled level curve curvature entity at a single scale however, is that it may be sensitive to noise and to the choice of the scale level. A better method is to compute the <em>

<math display="inline" id="Corner_detection:96">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

-normalized rescaled level curve curvature</em></p>

<p>

<math display="block" id="Corner_detection:97">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>κ</mi>
      <mrow>
       <mi>n</mi>
       <mi>o</mi>
       <mi>r</mi>
       <mi>m</mi>
      </mrow>
     </msub>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>t</mi>
     <mrow>
      <mn>2</mn>
      <mi>γ</mi>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <msubsup>
         <mi>L</mi>
         <mi>x</mi>
         <mn>2</mn>
        </msubsup>
        <msub>
         <mi>L</mi>
         <mrow>
          <mi>y</mi>
          <mi>y</mi>
         </mrow>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msubsup>
         <mi>L</mi>
         <mi>y</mi>
         <mn>2</mn>
        </msubsup>
        <msub>
         <mi>L</mi>
         <mrow>
          <mi>x</mi>
          <mi>x</mi>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>L</mi>
        <mi>x</mi>
       </msub>
       <msub>
        <mi>L</mi>
        <mi>y</mi>
       </msub>
       <msub>
        <mi>L</mi>
        <mrow>
         <mi>x</mi>
         <mi>y</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>κ</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>o</ci>
        <ci>r</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>γ</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>L</ci>
          <ci>x</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <times></times>
          <ci>y</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>L</ci>
          <ci>y</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <times></times>
          <ci>x</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\kappa_{norm}}(x,y;t)=t^{2\gamma}(L_{x}^{2}L_{yy}+L_{y}^{2}L_{xx}-2L_{x%
}L_{y}L_{xy})
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Corner_detection:98">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>=</mo>
   <mrow>
    <mn>7</mn>
    <mo>/</mo>
    <mn>8</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>γ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">7</cn>
     <cn type="integer">8</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma=7/8
  </annotation>
 </semantics>
</math>

 and to detect <em>signed scale-space extrema</em> of this expression, that are points and scales that are positive maxima and negative minima with respect to both space and scale</p>

<p>

<math display="block" id="Corner_detection:99">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>;</mo>
    <mover accent="true">
     <mi>t</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>argminmaxlocal</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>;</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <msub>
      <mover accent="true">
       <mi>κ</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mrow>
       <mi>n</mi>
       <mi>o</mi>
       <mi>r</mi>
       <mi>m</mi>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <vector>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>t</ci>
     </apply>
    </vector>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>argminmaxlocal</ci>
       <vector>
        <ci>x</ci>
        <ci>y</ci>
        <ci>t</ci>
       </vector>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>κ</ci>
       </apply>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>o</ci>
        <ci>r</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{x},\hat{y};\hat{t})=\operatorname{argminmaxlocal}_{(x,y;t)}\tilde{\kappa%
}_{norm}(x,y;t)
  </annotation>
 </semantics>
</math>

 in combination with a complementary localization step to handle the increase in localization error at coarser scales.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> In this way, larger scale values will be associated with rounded corners of large spatial extent while smaller scale values will be associated with sharp corners with small spatial extent. This approach is the first corner detector with automatic scale selection (prior to the "Harris-Laplace operator" above) and has been used for tracking corners under large scale variations in the image domain<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> and for matching corner responses to edges to compute structural image features for geon-based object recognition.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="log-dog-and-doh-feature-detection">LoG, DoG, and DoH feature detection</h2>

<p>LoG<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> is an acronym standing for <em>Laplacian of Gaussian</em>, DoG<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> is an acronym standing for <em>difference of Gaussians</em> (DoG is an approximation of LoG), and DoH is an acronym standing for <em>determinant of the Hessian.</em><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>

<p>These detectors are more completely described in <a href="blob_detection" title="wikilink">blob detection</a>, however the LoG and DoG blobs do not necessarily make highly selective features, since these operators may also respond to edges. To improve the corner detection ability of the DoG detector, the feature detector used in the <a href="Scale-invariant_feature_transform" title="wikilink">SIFT</a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> system uses an additional post-processing stage, where the <a href="eigenvalue" title="wikilink">eigenvalues</a> of the <a href="Hessian_matrix" title="wikilink">Hessian</a> of the image at the detection scale are examined in a similar way as in the Harris operator. If the ratio of the eigenvalues is too high, then the local image is regarded as too edge-like, so the feature is rejected. The DoH operator on the other hand only responds when there are significant grey-level variations in two directions.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>

<p>The scale selection properties of these and other scale-space interest point detectors are analyzed in detail in (Lindeberg 2013).<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>
<h2 id="affine-adapted-interest-point-operators">Affine-adapted interest point operators</h2>

<p>The interest points obtained from the multi-scale Harris operator with automatic scale selection are invariant to translations, rotations and uniform rescalings in the spatial domain. The images that constitute the input to a computer vision system are, however, also subject to perspective distortions. To obtain an interest point operator that is more robust to perspective transformations, a natural approach is to devise a feature detector that is <em>invariant to affine transformations</em>. In practice, affine invariant interest points can be obtained by applying <a href="affine_shape_adaptation" title="wikilink">affine shape adaptation</a> where the shape of the smoothing kernel is iteratively warped to match the local image structure around the interest point or equivalently a local image patch is iteratively warped while the shape of the smoothing kernel remains rotationally symmetric.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> Hence, besides the commonly used multi-scale Harris operator, affine shape adaptation can be applied to other corner detectors as listed in this article as well as to <a href="blob_detection" title="wikilink">differential blob detectors</a> such as the Laplacian/difference of Gaussian operator, the determinant of the Hessian<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> and the Hessian–Laplace operator.</p>
<h2 id="the-wang-and-brady-corner-detection-algorithm">The Wang and Brady corner detection algorithm</h2>

<p>The Wang and Brady<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> detector considers the image to be a surface, and looks for places where there is large <a class="uri" href="curvature" title="wikilink">curvature</a> along an image edge. In other words, the algorithm looks for places where the edge changes direction rapidly. The corner score, 

<math display="inline" id="Corner_detection:100">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, is given by:</p>

<p>

<math display="block" id="Corner_detection:101">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mo>∇</mo>
       <mn>2</mn>
      </msup>
      <mi>I</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>c</mi>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mo>∇</mo>
         <mi>I</mi>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-∇</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>I</ci>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <ci>normal-∇</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\nabla^{2}I-c|\nabla I|^{2},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Corner_detection:102">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 determines how edge-phobic the detector is. The authors also note that smoothing (Gaussian is suggested) is required to reduce noise. In this case, the first term of 

<math display="inline" id="Corner_detection:103">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 becomes the Laplacian (single-scale) <a href="blob_detection" title="wikilink">blob detector</a>.</p>

<p>Smoothing also causes displacement of corners, so the authors derive an expression for the displacement of a 90 degree corner, and apply this as a correction factor to the detected corners.</p>
<h2 id="the-susan-corner-detector">The SUSAN corner detector</h2>

<p>SUSAN<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> is an acronym standing for <em>smallest univalue segment assimilating nucleus.</em> This method is the subject of a 1994 UK patent which is no longer in force.<ref> {{ cite patent</ref></p>

<p><code>| country = GB</code><br/>
<code>| number = 2272285</code><br/>
<code>| status = patent</code><br/>
<code>| title = Determining the position of edges and corners in images</code><br/>
<code>| pubdate = 1994-05-11</code><br/>
<code>| gdate = 1994-05-11</code><br/>
<code>| fdate = 1993-06-07</code><br/>
<code>| inventor = list of inventors (free format)</code><br/>
<code>| invent1 = Smith, Stephen Mark</code><br/>
<code>| assign1 = Secr Defence</code><br/>
<code>| class=G06T5/00</code></p>

<p>}}</p>

<p>For feature detection, SUSAN places a circular mask over the pixel to be tested (the nucleus). The region of the mask is 

<math display="inline" id="Corner_detection:104">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, and a pixel in this mask is represented by 

<math display="inline" id="Corner_detection:105">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>∈</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>normal-→</ci>
     <ci>m</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{m}\in M
  </annotation>
 </semantics>
</math>

. The nucleus is at 

<math display="inline" id="Corner_detection:106">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>m</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{m}_{0}
  </annotation>
 </semantics>
</math>

. Every pixel is compared to the nucleus using the comparison function:</p>

<p>

<math display="block" id="Corner_detection:107">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mrow>
          <mi>I</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mover accent="true">
            <mi>m</mi>
            <mo stretchy="false">→</mo>
           </mover>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>I</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mover accent="true">
             <mi>m</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mn>0</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mi>t</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mn>6</mn>
     </msup>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>I</ci>
          <apply>
           <ci>normal-→</ci>
           <ci>m</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>I</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-→</ci>
            <ci>m</ci>
           </apply>
           <cn type="integer">0</cn>
          </apply>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
       <cn type="integer">6</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(\vec{m})=e^{-\left(\frac{I(\vec{m})-I(\vec{m}_{0})}{t}\right)^{6}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Corner_detection:108">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 determines the radius, 

<math display="inline" id="Corner_detection:109">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is the brightness of the pixel and the power of the exponent has been determined empirically. This function has the appearance of a smoothed <a href="Rectangular_function" title="wikilink">top-hat or rectangular function</a>. The area of the SUSAN is given by:</p>

<p>

<math display="block" id="Corner_detection:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mover accent="true">
       <mi>m</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>∈</mo>
      <mi>M</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>m</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <apply>
        <ci>normal-→</ci>
        <ci>m</ci>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(M)=\sum_{\vec{m}\in M}c(\vec{m})
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Corner_detection:111">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is the rectangular function, then 

<math display="inline" id="Corner_detection:112">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of pixels in the mask which are within 

<math display="inline" id="Corner_detection:113">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 of the nucleus. The response of the SUSAN operator is given by:</p>

<p>

<math display="block" id="Corner_detection:114">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>g</mi>
        <mo>-</mo>
        <mrow>
         <mi>n</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>M</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>n</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>M</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo><</mo>
        <mi>g</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise,</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <minus></minus>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>n</ci>
       <ci>M</ci>
      </apply>
      <ci>g</ci>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise,</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(M)=\begin{cases}g-n(M)&\mbox{if}\ n(M)<g\\
0&\mbox{otherwise,}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Corner_detection:115">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is named the `geometric threshold'. In other words the SUSAN operator only has a positive score if the area is small enough. The smallest SUSAN locally can be found using non-maximal suppression, and this is the complete SUSAN operator.</p>

<p>The value 

<math display="inline" id="Corner_detection:116">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 determines how similar points have to be to the nucleus before they are considered to be part of the univalue segment. The value of 

<math display="inline" id="Corner_detection:117">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 determines the minimum size of the univalue segment. If 

<math display="inline" id="Corner_detection:118">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is large enough, then this becomes an <a href="Edge_detection" title="wikilink">edge detector</a>.</p>

<p>For corner detection, two further steps are used. Firstly, the <a class="uri" href="centroid" title="wikilink">centroid</a> of the SUSAN is found. A proper corner will have the centroid far from the nucleus. The second step insists that all points on the line from the nucleus through the centroid out to the edge of the mask are in the SUSAN.</p>
<h2 id="the-trajkovic-and-hedley-corner-detector">The Trajkovic and Hedley corner detector</h2>

<p>In a manner similar to SUSAN, this detector<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> directly tests whether a patch under a pixel is self-similar by examining nearby pixels. 

<math display="inline" id="Corner_detection:119">
 <semantics>
  <mover accent="true">
   <mi>c</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{c}
  </annotation>
 </semantics>
</math>

 is the pixel to be considered, and 

<math display="inline" id="Corner_detection:120">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>p</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>∈</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>normal-→</ci>
     <ci>p</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{p}\in P
  </annotation>
 </semantics>
</math>

 is point on a circle 

<math display="inline" id="Corner_detection:121">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 centered around 

<math display="inline" id="Corner_detection:122">
 <semantics>
  <mover accent="true">
   <mi>c</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{c}
  </annotation>
 </semantics>
</math>

. The point 

<math display="inline" id="Corner_detection:123">
 <semantics>
  <mover accent="true">
   <msup>
    <mi>p</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{p^{\prime}}
  </annotation>
 </semantics>
</math>

 is the point opposite to 

<math display="inline" id="Corner_detection:124">
 <semantics>
  <mover accent="true">
   <mi>p</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{p}
  </annotation>
 </semantics>
</math>

 along the diameter.</p>

<p>The response function is defined as:</p>

<p>

<math display="block" id="Corner_detection:125">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>c</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mi>min</mi>
     <mrow>
      <mover accent="true">
       <mi>p</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>∈</mo>
      <mi>P</mi>
     </mrow>
    </munder>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>I</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>p</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>I</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>c</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>I</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <msup>
            <mi>p</mi>
            <mo>′</mo>
           </msup>
           <mo stretchy="false">→</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>I</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>c</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <apply>
        <ci>normal-→</ci>
        <ci>p</ci>
       </apply>
       <ci>P</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <ci>normal-→</ci>
          <ci>p</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <ci>normal-→</ci>
          <ci>c</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <ci>normal-→</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>p</ci>
           <ci>normal-′</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <ci>normal-→</ci>
          <ci>c</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(\vec{c})=\min_{\vec{p}\in P}\quad(I(\vec{p})-I(\vec{c}))^{2}+(I(\vec{p^{%
\prime}})-I(\vec{c}))^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>This will be large when there is no direction in which the centre pixel is similar to two nearby pixels along a diameter. 

<math display="inline" id="Corner_detection:126">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a discretised circle (a <a href="Midpoint_circle_algorithm" title="wikilink">Bresenham circle</a>), so <a class="uri" href="interpolation" title="wikilink">interpolation</a> is used for intermediate diameters to give a more isotropic response. Since any computation gives an upper bound on the 

<math display="inline" id="Corner_detection:127">
 <semantics>
  <mi>min</mi>
  <annotation-xml encoding="MathML-Content">
   <min></min>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min
  </annotation>
 </semantics>
</math>

, the horizontal and vertical directions are checked first to see if it is worth proceeding with the complete computation of 

<math display="inline" id="Corner_detection:128">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="ast-based-feature-detectors">AST-based feature detectors</h2>

<p>AST is an acronym standing for <em>accelerated segment test.</em> This test is a relaxed version of the SUSAN corner criterion. Instead of evaluating the circular disc only the pixels in a <a href="Midpoint_circle_algorithm" title="wikilink">Bresenham circle</a> of radius 

<math display="inline" id="Corner_detection:129">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 around the candidate point are considered. If 

<math display="inline" id="Corner_detection:130">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 contiguous pixels are all brighter than the nucleus by at least 

<math display="inline" id="Corner_detection:131">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 or all darker than the nucleus by 

<math display="inline" id="Corner_detection:132">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, then the pixel under the nucleus is considered to be a feature. This test is reported to produce very stable features.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> The choice of the order in which the pixels are tested is a so-called <a href="Twenty_Questions" title="wikilink">Twenty Questions problem</a>. Building short decision trees for this problem results in the most computationally efficient feature detectors available.</p>

<p>The first corner detection algorithm based on the AST is FAST (<a href="features_from_accelerated_segment_test" title="wikilink">features from accelerated segment test</a>).<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> Although 

<math display="inline" id="Corner_detection:133">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 can in principle take any value, FAST uses only a value of 3 (corresponding to a circle of 16 pixels circumference), and tests show that the best results are achieved with 

<math display="inline" id="Corner_detection:134">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 being 9. This value of 

<math display="inline" id="Corner_detection:135">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the lowest one at which edges are not detected. The order in which pixels are tested is determined by the <a href="ID3_algorithm" title="wikilink">ID3 algorithm</a> from a training set of images. Confusingly, the name of the detector is somewhat similar to the name of the paper describing Trajkovic and Hedley's detector.</p>
<h2 id="automatic-synthesis-of-detectors">Automatic synthesis of detectors</h2>

<p>Trujillo and Olague<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> introduced a method by which <a href="genetic_programming" title="wikilink">genetic programming</a> is used to automatically synthesize image operators that can detect interest points. The terminal and function sets contain primitive operations that are common in many previously proposed man-made designs. <a href="Fitness_function" title="wikilink">Fitness</a> measures the stability of each operator through the repeatability rate, and promotes a uniform dispersion of detected points across the image plane. The performance of the evolved operators has been confirmed experimentally using training and testing sequences of progressively transformed images. Hence, the proposed GP algorithm is considered to be human-competitive for the problem of interest point detection.</p>
<h2 id="bibliography">Bibliography</h2>
<h2 id="reference-implementations">Reference implementations</h2>

<p>This section provides external links to reference implementations of some of the detectors described above. These reference implementations are provided by the authors of the paper in which the detector is first described. These may contain details not present or explicit in the papers describing the features.</p>
<ul>
<li><a href="http://www.cs.ubc.ca/spider/lowe/keypoints/siftDemoV4.zip">DoG detection</a> (as part of the <a href="Scale-invariant_feature_transform" title="wikilink">SIFT</a> system), <a href="Microsoft_Windows" title="wikilink">Windows</a> and <a class="uri" href="x86" title="wikilink">x86</a> <a class="uri" href="Linux" title="wikilink">Linux</a> executables</li>
<li><a href="http://lear.inrialpes.fr/people/dorko/ipld/ipld_static.tgz">Harris-Laplace</a>, static <a class="uri" href="Linux" title="wikilink">Linux</a> executables. Also contains DoG and LoG detectors and affine adaptation for all detectors included.</li>
<li><a href="http://edwardrosten.com/work/fast.html">FAST detector</a>, C, C++, MATLAB source code and executables for various operating systems and architectures.</li>
<li><a href="http://pami.xmu.edu.cn/~wlzhao/lip-vireo.htm">lip-vireo</a>,[LoG, DoG, Harris-Laplacian, Hessian and Hessian-Laplacian],[SIFT, flip invariant SIFT, PCA-SIFT, PSIFT, Steerable Filters, SPIN][Linux, Windows and SunOS] executables.</li>
<li><a href="http://users.fmrib.ox.ac.uk/~steve/susan/">SUSAN Low Level Image Processing</a>, C source code.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="blob_detection" title="wikilink">blob detection</a></li>
<li><a href="affine_shape_adaptation" title="wikilink">affine shape adaptation</a></li>
<li><a href="scale_space" title="wikilink">scale space</a></li>
<li><a href="ridge_detection" title="wikilink">ridge detection</a></li>
<li><a href="interest_point_detection" title="wikilink">interest point detection</a></li>
<li><a href="feature_detection_(computer_vision)" title="wikilink">feature detection (computer vision)</a></li>
<li><a href="Image_Derivatives" title="wikilink">image derivatives</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li>Brostow, <a href="http://www0.cs.ucl.ac.uk/staff/G.Brostow/classes/IP2008/L7_CornerDetection.pdf">"Corner Detection -- UCL Computer Science"</a></li>
</ul>

<p>"</p>

<p><a href="Category:Feature_detection_(computer_vision)" title="wikilink">Category:Feature detection (computer vision)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2">Shapiro, Linda and George C. Stockman (2001). <em>Computer Vision</em>, p. 257. Prentice Books, Upper Saddle River. ISBN 0-13-030796-3.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"><a href="http://www.dx.doi.org/10.1007/s10851-012-0378-3">Tony Lindeberg (2013) "Scale Selection Properties of Generalized Scale-Space Interest Point Detectors", Journal of Mathematical Imaging and Vision, Volume 46, Issue 2, pages 177-210.</a><a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"></li>
</ol>
</section>
</body>
</html>
