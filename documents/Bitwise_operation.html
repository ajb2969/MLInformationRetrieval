<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1557">Bitwise operation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bitwise operation</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="digital_computer" title="wikilink">digital computer</a> <a href="computer_programming" title="wikilink">programming</a>, a <strong>bitwise operation</strong> operates on one or more <a href="bit_pattern" title="wikilink">bit patterns</a> or <a href="Binary_numeral_system" title="wikilink">binary numerals</a> at the level of their individual <a href="bit" title="wikilink">bits</a>. It is a fast, primitive action directly supported by the <a href="central_processing_unit" title="wikilink">processor</a>, and is used to manipulate values for comparisons and calculations.</p>

<p>On simple low-cost processors, typically, bitwise operations are substantially faster than division, several times faster than multiplication, and sometimes significantly faster than addition. While modern processors usually perform addition and multiplication just as fast as bitwise operations due to their longer <a href="instruction_pipeline" title="wikilink">instruction pipelines</a> and other <a href="computer_architecture" title="wikilink">architectural</a> design choices, bitwise operations do commonly use less power because of the reduced use of resources.</p>
<h2 id="bitwise-operators">Bitwise operators</h2>

<p>In the explanations below, any indication of a bit's position is counted from the right (least significant) side, advancing left. For example, the binary value 0001 (decimal 1) has zeroes at every position but the first one.</p>
<h3 id="not">NOT</h3>

<p>The <strong>bitwise NOT</strong>, or <strong>complement</strong>, is a <a href="unary_operation" title="wikilink">unary operation</a> that performs <a href="negation" title="wikilink">logical negation</a> on each bit, forming the <a href="ones'_complement" title="wikilink">ones' complement</a> of the given binary value. Bits that are 0 become 1, and those that are 1 become 0. For example:</p>

<p><code>NOT 0111  (decimal 7)</code><br/>
<code>  = 1000  (decimal 8)</code></p>

<p>The bitwise complement is equal to the <a href="two's_complement" title="wikilink">two's complement</a> of the value minus one. If two's complement arithmetic is used, then</p>
<dl>
<dd>NOT <em>x</em> = −<em>x</em> − 1.
</dd>
</dl>

<p>For unsigned <a href="Integer_(computer_science)" title="wikilink">integers</a>, the bitwise complement of a number is the "mirror reflection" of the number across the half-way point of the unsigned integer's range. For example, for 8-bit unsigned integers, <code>NOT x = 255 - x</code>, which can be visualized on a graph as a downward line that effectively "flips" an increasing range from 0 to 255, to a decreasing range from 255 to 0. A simple but illustrative example use is to invert a grayscale image where each pixel is stored as an unsigned integer.</p>
<h3 id="and">AND</h3>

<p>A <strong>bitwise AND</strong> takes two equal-length binary representations and performs the <a href="Logical_conjunction" title="wikilink">logical AND</a> operation on each pair of the corresponding bits, by multiplying them. Thus, if both bits in the compared position are 1, the bit in the resulting binary representation is 1 (1 × 1 = 1); otherwise, the result is 0 (1 × 0 = 0). For example:</p>

<p><code>    0101 (decimal 5)</code><br/>
<code>AND 0011 (decimal 3)</code><br/>
<code>  = 0001 (decimal 1)</code></p>

<p>The operation may be used to determine whether a particular bit is <em>set</em> (1) or <em>clear</em> (0). For example, given a bit pattern 0011 (decimal 3), to determine whether the second bit is set we use a bitwise AND with a bit pattern containing 1 only in the second bit:</p>

<p><code>    0011 (decimal 3)</code><br/>
<code>AND 0010 (decimal 2)</code><br/>
<code>  = 0010 (decimal 2)</code></p>

<p>Because the result 0010 is non-zero, we know the second bit in the original pattern was set. This is often called <em>bit masking</em>. (By analogy, the use of <a href="masking_tape" title="wikilink">masking tape</a> covers, or <em>masks</em>, portions that should not be altered or portions that are not of interest. In this case, the 0 values mask the bits that are not of interest.)</p>

<p>If we store the result, this may be used to clear selected bits in a register. Given the example 0110 (decimal 6), the second bit may be cleared by using a bitwise AND with the pattern that has a zero only in the second bit:</p>

<p><code>    0110 (decimal 6)</code><br/>
<code>AND 1101 (decimal 13)</code><br/>
<code>  = 0100 (decimal 4)</code></p>

<p>Because of this property, it becomes easy to check the <a href="Parity_(mathematics)" title="wikilink">parity</a> of a binary number by checking the value of the lowest valued bit. Using the example above:</p>

<p><code>    0110 (decimal 6)</code><br/>
<code>AND 0001 (decimal 1)</code><br/>
<code>  = 0000 (decimal 0)</code></p>

<p>Therefore 6 is divisible by two and is even.</p>
<h3 id="or">OR</h3>

<p>A <strong>bitwise OR</strong> takes two bit patterns of equal length and performs the <a href="Logical_disjunction" title="wikilink">logical inclusive OR</a> operation on each pair of corresponding bits. The result in each position is 0 if both bits are 0, while otherwise the result is 1. For example:</p>

<p><code>   0101 (decimal 5)</code><br/>
<code>OR 0011 (decimal 3)</code><br/>
<code> = 0111 (decimal 7)</code></p>

<p>The bitwise OR may be used to set the selected bits to 1. For example, it can be used for setting a specific bit (or <a href="Flag_word" title="wikilink">flag</a>) in a register, where each bit represents an individual <a href="Boolean_data_type" title="wikilink">Boolean</a> state. Thus, 0010 (decimal 2) can be considered a set of four flags, where the first, third, and fourth flags are clear (0) and the second flag is set (1). The fourth flag may be set by performing a bitwise OR between this value and a bit pattern with only the fourth bit set:</p>

<p><code>   0010 (decimal 2)</code><br/>
<code>OR 1000 (decimal 8)</code><br/>
<code> = 1010 (decimal 10)</code></p>

<p>This technique is an efficient way to store a number of Boolean values using as little memory as possible.</p>
<h3 id="xor">XOR</h3>

<p>A <strong>bitwise XOR</strong> takes two bit patterns of equal length and performs the <a href="Exclusive_disjunction" title="wikilink">logical exclusive OR</a> operation on each pair of corresponding bits. The result in each position is 1 if only the first bit is 1 <em>or</em> only the second bit is 1, but will be 0 if both are 0 or both are 1. In this we perform the comparison of two bits, being 1 if the two bits are different, and 0 if they are the same. For example:</p>

<p><code>    0101 (decimal 5)</code><br/>
<code>XOR 0011 (decimal 3)</code><br/>
<code>  = 0110 (decimal 6)</code></p>

<p>The bitwise XOR may be used to invert selected bits in a register (also called toggle or flip). Any bit may be toggled by XORing it with 1. For example, given the bit pattern 0010 (decimal 2) the second and fourth bits may be toggled by a bitwise XOR with a bit pattern containing 1 in the second and fourth positions:</p>

<p><code>    0010 (decimal 2)</code><br/>
<code>XOR 1010 (decimal 10)</code><br/>
<code>  = 1000 (decimal 8)</code></p>

<p>This technique may be used to manipulate bit patterns representing sets of Boolean states.</p>

<p><a href="Assembly_language" title="wikilink">Assembly language</a> programmers sometimes use XOR as a short-cut to setting the value of a <a href="Processor_register" title="wikilink">register</a> to zero. Performing XOR on a value against itself always yields zero, and on many architectures this operation requires fewer clock cycles and/or memory than loading a zero value and saving it to the register.</p>
<h3 id="mathematical-equivalents">Mathematical equivalents</h3>

<p>Assuming 

<math display="inline" id="Bitwise_operation:0">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>></mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x>y
  </annotation>
 </semantics>
</math>

, for the non-negative integers, the bitwise operations can be written as follows:</p>

<p>

<math display="inline" id="Bitwise_operation:1">
 <semantics>
  <mrow>
   <mrow>
    <mtext>NOT</mtext>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mo>⌊</mo>
          <mfrac>
           <mi>x</mi>
           <msup>
            <mn>2</mn>
            <mi>n</mi>
           </msup>
          </mfrac>
          <mo>⌋</mo>
         </mrow>
         <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
         <mrow>
          <mn>2</mn>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mn>2</mn>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>NOT</mtext>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="latexml">modulo</csymbol>
        <apply>
         <csymbol cd="latexml">modulo</csymbol>
         <apply>
          <floor></floor>
          <apply>
           <divide></divide>
           <ci>x</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <cn type="integer">2</cn>
            <ci>n</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <cn type="integer">2</cn>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{NOT }x=\sum_{n=0}^{b}2^{n}\left[\left(\left\lfloor\frac{x}{2^{n}}\right%
\rfloor\bmod 2+1\right)\bmod 2\right]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Bitwise_operation:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mtext>AND</mtext>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mo>⌊</mo>
        <mfrac>
         <mi>x</mi>
         <msup>
          <mn>2</mn>
          <mi>n</mi>
         </msup>
        </mfrac>
        <mo>⌋</mo>
       </mrow>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mn>2</mn>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mo>⌊</mo>
        <mfrac>
         <mi>y</mi>
         <msup>
          <mn>2</mn>
          <mi>n</mi>
         </msup>
        </mfrac>
        <mo>⌋</mo>
       </mrow>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mn>2</mn>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <mtext>AND</mtext>
     <ci>y</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <floor></floor>
        <apply>
         <divide></divide>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <apply>
        <floor></floor>
        <apply>
         <divide></divide>
         <ci>y</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\text{ AND }y=\sum_{n=0}^{b}2^{n}\left(\left\lfloor\frac{x}{2^{n}}\right%
\rfloor\bmod 2\right)\left(\left\lfloor\frac{y}{2^{n}}\right\rfloor\bmod 2\right)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Bitwise_operation:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mtext>OR</mtext>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mrow>
         <mrow>
          <mrow>
           <mo>(</mo>
           <mrow>
            <mrow>
             <mo>⌊</mo>
             <mfrac>
              <mi>x</mi>
              <msup>
               <mn>2</mn>
               <mi>n</mi>
              </msup>
             </mfrac>
             <mo>⌋</mo>
            </mrow>
            <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
            <mn>2</mn>
           </mrow>
           <mo>)</mo>
          </mrow>
          <mo>+</mo>
          <mrow>
           <mo>(</mo>
           <mrow>
            <mrow>
             <mo>⌊</mo>
             <mfrac>
              <mi>y</mi>
              <msup>
               <mn>2</mn>
               <mi>n</mi>
              </msup>
             </mfrac>
             <mo>⌋</mo>
            </mrow>
            <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
            <mn>2</mn>
           </mrow>
           <mo>)</mo>
          </mrow>
          <mo>+</mo>
          <mrow>
           <mrow>
            <mo>(</mo>
            <mrow>
             <mrow>
              <mo>⌊</mo>
              <mfrac>
               <mi>x</mi>
               <msup>
                <mn>2</mn>
                <mi>n</mi>
               </msup>
              </mfrac>
              <mo>⌋</mo>
             </mrow>
             <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
             <mn>2</mn>
            </mrow>
            <mo>)</mo>
           </mrow>
           <mrow>
            <mo>(</mo>
            <mrow>
             <mrow>
              <mo>⌊</mo>
              <mfrac>
               <mi>y</mi>
               <msup>
                <mn>2</mn>
                <mi>n</mi>
               </msup>
              </mfrac>
              <mo>⌋</mo>
             </mrow>
             <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
             <mn>2</mn>
            </mrow>
            <mo>)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
         <mn>2</mn>
        </mrow>
        <mo>]</mo>
       </mrow>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mn>2</mn>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <mtext>OR</mtext>
     <ci>y</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="latexml">modulo</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="latexml">modulo</csymbol>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="latexml">modulo</csymbol>
            <apply>
             <floor></floor>
             <apply>
              <divide></divide>
              <ci>x</ci>
              <apply>
               <csymbol cd="ambiguous">superscript</csymbol>
               <cn type="integer">2</cn>
               <ci>n</ci>
              </apply>
             </apply>
            </apply>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <csymbol cd="latexml">modulo</csymbol>
            <apply>
             <floor></floor>
             <apply>
              <divide></divide>
              <ci>y</ci>
              <apply>
               <csymbol cd="ambiguous">superscript</csymbol>
               <cn type="integer">2</cn>
               <ci>n</ci>
              </apply>
             </apply>
            </apply>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="latexml">modulo</csymbol>
             <apply>
              <floor></floor>
              <apply>
               <divide></divide>
               <ci>x</ci>
               <apply>
                <csymbol cd="ambiguous">superscript</csymbol>
                <cn type="integer">2</cn>
                <ci>n</ci>
               </apply>
              </apply>
             </apply>
             <cn type="integer">2</cn>
            </apply>
            <apply>
             <csymbol cd="latexml">modulo</csymbol>
             <apply>
              <floor></floor>
              <apply>
               <divide></divide>
               <ci>y</ci>
               <apply>
                <csymbol cd="ambiguous">superscript</csymbol>
                <cn type="integer">2</cn>
                <ci>n</ci>
               </apply>
              </apply>
             </apply>
             <cn type="integer">2</cn>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\text{ OR }y=\sum_{n=0}^{b}2^{n}\left[\left[\left(\left\lfloor\frac{x}{2^{n}}%
\right\rfloor\bmod 2\right)+\left(\left\lfloor\frac{y}{2^{n}}\right\rfloor%
\bmod 2\right)+\left(\left\lfloor\frac{x}{2^{n}}\right\rfloor\bmod 2\right)%
\left(\left\lfloor\frac{y}{2^{n}}\right\rfloor\bmod 2\right)\bmod 2\right]%
\bmod 2\right]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Bitwise_operation:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mtext>XOR</mtext>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mrow>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mrow>
            <mo>⌊</mo>
            <mfrac>
             <mi>x</mi>
             <msup>
              <mn>2</mn>
              <mi>n</mi>
             </msup>
            </mfrac>
            <mo>⌋</mo>
           </mrow>
           <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
           <mn>2</mn>
          </mrow>
          <mo>)</mo>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mrow>
            <mo>⌊</mo>
            <mfrac>
             <mi>y</mi>
             <msup>
              <mn>2</mn>
              <mi>n</mi>
             </msup>
            </mfrac>
            <mo>⌋</mo>
           </mrow>
           <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
           <mn>2</mn>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>]</mo>
       </mrow>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mn>2</mn>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <mtext>XOR</mtext>
     <ci>y</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="latexml">modulo</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="latexml">modulo</csymbol>
           <apply>
            <floor></floor>
            <apply>
             <divide></divide>
             <ci>x</ci>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <cn type="integer">2</cn>
              <ci>n</ci>
             </apply>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="latexml">modulo</csymbol>
           <apply>
            <floor></floor>
            <apply>
             <divide></divide>
             <ci>y</ci>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <cn type="integer">2</cn>
              <ci>n</ci>
             </apply>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\text{ XOR }y=\sum_{n=0}^{b}2^{n}\left[\left[\left(\left\lfloor\frac{x}{2^{n}%
}\right\rfloor\bmod 2\right)+\left(\left\lfloor\frac{y}{2^{n}}\right\rfloor%
\bmod 2\right)\right]\bmod 2\right]
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Bitwise_operation:5">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is the number of bits in 

<math display="inline" id="Bitwise_operation:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⌊</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">⌋</mo>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <apply>
      <floor></floor>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\lfloor\log_{2}x\rfloor+1
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Bitwise_operation:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq 0
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="bit-shifts">Bit shifts</h2>

<p>The <strong>bit shifts</strong> are sometimes considered bitwise operations, because they treat a value as a series of bits rather than as a numerical quantity. In these operations the digits are moved, or <em>shifted</em>, to the left or right. <a href="Processor_register" title="wikilink">Registers</a> in a computer processor have a fixed width, so some bits will be "shifted out" of the register at one end, while the same number of bits are "shifted in" from the other end; the differences between bit shift operators lie in how they determine the values of the shifted-in bits.</p>
<h3 id="arithmetic-shift">Arithmetic shift</h3>

<p>  In an <em>arithmetic shift</em>, the bits that are shifted out of either end are discarded. In a left arithmetic shift, zeros are shifted in on the right; in a right arithmetic shift, the <a href="sign_bit" title="wikilink">sign bit</a> (the MSB in two's complement) is shifted in on the left, thus preserving the sign of the operand.</p>

<p>This example uses an 8-bit register:</p>

<p><code>   00010111 (decimal +23) LEFT-SHIFT</code><br/>
<code>=  00101110 (decimal +46)</code></p>

<p><code>   10010111 (decimal −105) RIGHT-SHIFT</code><br/>
<code>=  11001011 (decimal −53)</code></p>

<p>In the first case, the leftmost digit was shifted past the end of the register, and a new 0 was shifted into the rightmost position. In the second case, the rightmost 1 was shifted out (perhaps into the carry flag), and a new 1 was copied into the leftmost position, preserving the sign of the number. Multiple shifts are sometimes shortened to a single shift by some number of digits. For example:</p>

<p><code>   00010111 (decimal +23) LEFT-SHIFT-BY-TWO</code><br/>
<code>=  01011100 (decimal +92)</code></p>

<p>A left arithmetic shift by <em>n</em> is equivalent to multiplying by 2<sup><em>n</em></sup> (provided the value does not <a href="arithmetic_overflow" title="wikilink">overflow</a>), while a right arithmetic shift by <em>n</em> of a <a href="two's_complement" title="wikilink">two's complement</a> value is equivalent to dividing by 2<sup><em>n</em></sup> and rounding toward <a href="negative_infinity" title="wikilink">negative infinity</a>. If the binary number is treated as <a href="ones'_complement" title="wikilink">ones' complement</a>, then the same right-shift operation results in division by 2<sup><em>n</em></sup> and rounding toward zero.</p>
<h3 id="logical-shift">Logical shift</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Left logical shift</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Right logical shift</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>In a <em>logical shift</em>, zeros are shifted in to replace the discarded bits. Therefore the logical and arithmetic left-shifts are exactly the same.</p>

<p>However, as the logical right-shift inserts value 0 bits into the most significant bit, instead of copying the sign bit, it is ideal for unsigned binary numbers, while the arithmetic right-shift is ideal for signed <a href="two's_complement" title="wikilink">two's complement</a> binary numbers. {{-}}</p>
<h3 id="rotate-no-carry">Rotate no carry</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Left circular shift or rotate</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Right circular shift or rotate</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>Another form of shift is the <em>circular shift</em> or <em>bit rotation</em>. In this operation, the bits are "rotated" as if the left and right ends of the register were joined. The value that is shifted in on the right during a left-shift is whatever value was shifted out on the left, and vice versa. This operation is useful if it is necessary to retain all the existing bits, and is frequently used in digital <a class="uri" href="cryptography" title="wikilink">cryptography</a>. {{-}}</p>
<h3 id="rotate-through-carry">Rotate through carry</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Left rotate through carry</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Right rotate through carry</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p><em>Rotate through carry</em> is similar to the <em>rotate no carry</em> operation, but the two ends of the register are separated by the <a href="carry_flag" title="wikilink">carry flag</a>. The bit that is shifted in (on either end) is the old value of the carry flag, and the bit that is shifted out (on the other end) becomes the new value of the carry flag.</p>

<p>A single <em>rotate through carry</em> can simulate a logical or arithmetic shift of one position by setting up the carry flag beforehand. For example, if the carry flag contains 0, then <code>x RIGHT-ROTATE-THROUGH-CARRY-BY-ONE</code> is a logical right-shift, and if the carry flag contains a copy of the sign bit, then <code>x RIGHT-ROTATE-THROUGH-CARRY-BY-ONE</code> is an arithmetic right-shift. For this reason, some microcontrollers such as low end <a href="PIC_microcontroller" title="wikilink">PICs</a> just have <em>rotate</em> and <em>rotate through carry</em>, and don't bother with arithmetic or logical shift instructions.</p>

<p>Rotate through carry is especially useful when performing shifts on numbers larger than the processor's native <a href="word_size" title="wikilink">word size</a>, because if a large number is stored in two registers, the bit that is shifted off the end of the first register must come in at the other end of the second. With rotate-through-carry, that bit is "saved" in the carry flag during the first shift, ready to shift in during the second shift without any extra preparation. {{-}}</p>
<h3 id="shifts-in-c-c-c-and-python">Shifts in C, C++, C# and Python</h3>

<p>In C-inspired languages, the left and right shift operators are "<code>" and "<code>&gt;&gt;</code>", respectively. The number of places to shift is given as the second argument to the shift operators. For example,</code></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">x = y &lt;&lt; <span class="dv">2</span>;</code></pre></div>

<p>assigns <code>x</code> the result of shifting <code>y</code> to the left by two bits, which is equivalent to a multiplication by four.</p>

<p>In C, the result of right-shifting a negative value is implementation-defined, and the result of left-shifting a signed value is undefined if the result cannot be represented in the result type.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In C#, the right-shift is an arithmetic shift when the first operand is an int or long. If the first operand is of type uint or ulong, the right-shift is a logical shift.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>There are also compiler-specific intrinsics implementing <a href="circular_shift" title="wikilink">circular shifts</a>, like <a href="http://msdn.microsoft.com/en-us/library/t5e2f3sc(VS.80).aspx">_rotl8, _rotl16</a>, <a href="http://msdn.microsoft.com/en-us/library/yy0728bz(VS.80).aspx">_rotr8, _rotr16</a> in Microsoft <a href="Visual_C++" title="wikilink">Visual C++</a>.</p>
<h3 id="shifts-in-java">Shifts in Java</h3>

<p>In <a href="Java_(programming_language)" title="wikilink">Java</a>, all integer types are signed, and the "<code>" and "<code>&gt;&gt;</code>" operators perform arithmetic shifts. Java adds the operator "<code>&gt;&gt;&gt;</code>" to perform logical right shifts, but because the logical and arithmetic left-shift operations are identical, there is no "<code>" operator in Java.</code></code></p>

<p>More details of Java shift operators:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li>The operators <code> (left shift), <code>&gt;&gt;</code> (signed right shift), and <code>&gt;&gt;&gt;</code> (unsigned right shift) are called the <em>shift operators</em>.</code></li>
<li>The type of the shift expression is the promoted type of the left-hand operand. For example, <code>aByte &gt;&gt;&gt; 2</code> is equivalent to <code>((int) aByte) &gt;&gt;&gt; 2</code>.</li>
<li>If the promoted type of the left-hand operand is int, only the five lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator &amp; with the mask value 0x1f (0b11111).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The shift distance actually used is therefore always in the range 0 to 31, inclusive.</li>
<li>If the promoted type of the left-hand operand is long, then only the six lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator &amp; with the mask value 0x3f (0b111111).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The shift distance actually used is therefore always in the range 0 to 63, inclusive.</li>
<li>The value of <em>n &gt;&gt;&gt; s</em> is <em>n</em> right-shifted <em>s</em> bit positions with zero-extension.</li>
<li>In bit and shift operations, the type <code>''byte''</code> is implicitly converted to <code>''int''</code>. If the byte value is negative, the highest bit is one, then ones are used to fill up the extra bytes in the int. So <code>byte b1=-5; int i = b1 | 0x0200;</code> will give i == -5 as result.</li>
</ul>
<h3 id="shifts-in-pascal">Shifts in Pascal</h3>

<p>In Pascal, as well as in all its dialects (such as <a href="Object_Pascal" title="wikilink">Object Pascal</a> and <a href="GNU_Pascal" title="wikilink">Standard Pascal</a>), the left and right shift operators are "<code>shl</code>" and "<code>shr</code>", respectively. The number of places to shift is given as the second argument. For example, the following assigns <em>x</em> the result of shifting <em>y</em> to the left by two bits:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal">x := y <span class="kw">shl</span> <span class="dv">2</span>;</code></pre></div>
<h2 id="applications">Applications</h2>

<p>Bitwise operations are necessary particularly in lower-level programming such as writing device drivers, low-level graphics, communications protocol packet assembly, and decoding.</p>

<p>Although machines often have efficient built-in instructions for performing arithmetic and logical operations, in fact, all these operations can be performed by combining the bitwise operators and zero-testing in various ways.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> For example, here is a <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> implementation of <a href="ancient_Egyptian_multiplication" title="wikilink">ancient Egyptian multiplication</a> showing how to multiply two arbitrary integers <code>a</code> and <code>b</code> (<code>a</code> greater than <code>b</code>) using only bitshifts and addition:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">c = <span class="dv">0</span>

<span class="kw">while</span> b ≠ <span class="dv">0</span>
    <span class="kw">if</span> (b and <span class="dv">1</span>) ≠ <span class="dv">0</span>
        c = c + a
    left shift a by <span class="dv">1</span>
    right shift b by <span class="dv">1</span>

<span class="kw">return</span> c</code></pre></div>

<p>Another example is a pseudocode implementation of addition, showing how to calculate a sum of two integers <code>a</code> and <code>b</code> using bitwise operators and zero-testing:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">while</span> a ≠ <span class="dv">0</span>
    c = b and a
    b = b xor a
    left shift c by <span class="dv">1</span>
    a = c

<span class="kw">return</span> b</code></pre></div>

<p>As a note, in these code samples "<code>=</code>" is the assignment operator, not the equality operator.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bit_manipulation" title="wikilink">Bit manipulation</a></li>
<li><a class="uri" href="Bitboard" title="wikilink">Bitboard</a></li>
<li><a href="Bitwise_operations_in_C" title="wikilink">Bitwise operations in C</a></li>
<li><a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra (logic)</a></li>
<li><a href="Double_dabble" title="wikilink">Double dabble</a></li>
<li><a href="Find_first_set" title="wikilink">Find first set</a></li>
<li><a href="Karnaugh_map" title="wikilink">Karnaugh map</a></li>
<li><a href="Logic_gate" title="wikilink">Logic gate</a></li>
<li><a href="Logical_operator" title="wikilink">Logical operator</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.miniwebtool.com/bitwise-calculator/">Online Bitwise Calculator</a> supports Bitwise AND, OR and XOR</li>
<li><a href="http://www.cs.uiowa.edu/~jones/bcd/divide.html">Division using bitshifts</a></li>
<li>"<a href="http://demonstrations.wolfram.com/BitwiseOperationsModN/">Bitwise Operations Mod N</a>" by Enrique Zeleny, <a href="Wolfram_Demonstrations_Project" title="wikilink">Wolfram Demonstrations Project</a>.</li>
<li>"<a href="http://demonstrations.wolfram.com/PlotsOfCompositionsOfBitwiseOperations/">Plots Of Compositions Of Bitwise Operations</a>" by Enrique Zeleny, The Wolfram Demonstrations Project.</li>
</ul>

<p>"</p>

<p><a href="Category:Binary_arithmetic" title="wikilink">Category:Binary arithmetic</a> <a href="Category:Operators_(programming)" title="wikilink">Category:Operators (programming)</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://std.dkuug.dk/JTC1/SC22/WG14/www/docs/n843.htm">JTC1/SC22/WG14 N843 "C programming language"</a>, section 6.5.7<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">The Java Language Specification, section <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.19">15.19. Shift Operators</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.1">JLS §15.22.1</a><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>

