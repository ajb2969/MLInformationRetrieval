   Sardinas–Patterson algorithm      Sardinas–Patterson algorithm   In coding theory , the Sardinas–Patterson algorithm is a classical algorithm for determining in polynomial time whether a given variable-length code is uniquely decodable, named after August Albert Sardinas and George W. Patterson, who published it in 1953. The algorithm carries out a systematic search for a string which admits two different decompositions into codewords. As Knuth reports, the algorithm was rediscovered about ten years later in 1963 by Floyd , despite the fact that it was at the time already well known in coding theory. 1  Idea of the algorithm  Consider the code    {    a  ↦  1   ,    b  ↦  011   ,    c  ↦  01110   ,    d  ↦  1110   ,   e  ↦   10011        }      formulae-sequence   maps-to  a  1    formulae-sequence   maps-to  b  011    formulae-sequence   maps-to  c  01110    formulae-sequence   maps-to  d  1110    maps-to  e  10011         \{\,a\mapsto 1,b\mapsto 011,c\mapsto 01110,d\mapsto 1110,e\mapsto 10011\,\}   . This code, which is based on an example by Berstel, 2 is an example of a code which is not uniquely decodable, since the string   011101110011   can be interpreted as the sequence of codewords   01110 – 1110 – 011,   but also as the sequence of codewords   011 – 1 – 011 – 10011.   Two possible decodings of this encoded string are thus given by cdb and babe .  In general, a codeword can be found by the following idea: In the first round, we choose two codewords    x  1     subscript  x  1    x_{1}   and    y  1     subscript  y  1    y_{1}   such that    x  1     subscript  x  1    x_{1}   is a prefix of    y  1     subscript  y  1    y_{1}   , that is,      x  1   w   =   y  1          subscript  x  1   w    subscript  y  1     x_{1}w=y_{1}   for some "dangling suffix"   w   w   w   . If one tries first     x  1   =  011       subscript  x  1   011    x_{1}=011   and     y  1   =  01110       subscript  y  1   01110    y_{1}=01110   , the dangling suffix is    w  =  10      w  10    w=10   . If we manage to find two sequences     x  2   ,  …  ,   x  p       subscript  x  2   normal-…   subscript  x  p     x_{2},\ldots,x_{p}   and     y  2   ,  …  ,   y  q       subscript  y  2   normal-…   subscript  y  q     y_{2},\ldots,y_{q}   of codewords such that      x  2   ⋯   x  p    =   w   y  2   ⋯   y  q           subscript  x  2   normal-⋯   subscript  x  p      w   subscript  y  2   normal-⋯   subscript  y  q      x_{2}\cdots x_{p}=wy_{2}\cdots y_{q}   , then we are finished: For then the string    x  =    x  1    x  2   ⋯   x  p        x     subscript  x  1    subscript  x  2   normal-⋯   subscript  x  p      x=x_{1}x_{2}\cdots x_{p}   can alternatively be decomposed as     y  1    y  2   ⋯   y  q        subscript  y  1    subscript  y  2   normal-⋯   subscript  y  q     y_{1}y_{2}\cdots y_{q}   , and we have found the desired string having at least two different decompositions into codewords. In the second round, we try out two different approaches: the first trial is to look for a codeword that has w as prefix. Then we obtain a new dangling suffix w ', with which we can continue our search. If we eventually encounter a dangling suffix that is itself a codeword (or the empty word ), then the search will terminate, as we know there exists a string with two decompositions. The second trial is to seek for a codeword that is itself a prefix of w . In our example, we have    w  =  10      w  10    w=10   , and the sequence 1 is a codeword. We can thus also continue with w'=0 as the new dangling suffix.  Precise description of the algorithm  The algorithm is described most conveniently using quotients of formal languages . In general, for two sets of strings D and N , the (left) quotient     N   -  1    D       superscript  N    1    D    N^{-1}D   is defined as the residual words obtained from D by removing some prefix in N . Formally,      N   -  1    D   =   {  y  ∣    x  y   ∈    D    and   x   ∈   N    }          superscript  N    1    D    conditional-set  y        x  y     D  and  x        N       N^{-1}D=\{\,y\mid xy\in D~{}\textrm{ and }~{}x\in N\,\}   . Now let   C   C   C   denote the (finite) set of codewords in the given code.  The algorithm proceeds in rounds, where we maintain in each round not only one dangling suffix as described above, but the (finite) set of all potential dangling suffixes. Starting with round    i  =  1      i  1    i=1   , the set of potential dangling suffixes will be denoted by    S  i     subscript  S  i    S_{i}   . The sets    S  i     subscript  S  i    S_{i}   are defined inductively as follows:       S  1   =     C   -  1    C   ∖   {  ε  }         subscript  S  1        superscript  C    1    C    ε      S_{1}=C^{-1}C\setminus\{\varepsilon\}   . Here, the symbol   ε   ε   \varepsilon   denotes the empty word .       S   i  +  1    =     C   -  1     S  i    ∪    S  i   -  1    C         subscript  S    i  1         superscript  C    1     subscript  S  i       superscript   subscript  S  i     1    C      S_{i+1}=C^{-1}S_{i}\cup S_{i}^{-1}C   , for all    i  ≥  1      i  1    i\geq 1   .  The algorithm computes the sets    S  i     subscript  S  i    S_{i}   in increasing order of   i   i   i   . As soon as one of the    S  i     subscript  S  i    S_{i}   contains a word from C or the empty word, then the algorithm terminates and answers that the given code is not uniquely decodable. Otherwise, once a set    S  i     subscript  S  i    S_{i}   equals a previously encountered set    S  j     subscript  S  j    S_{j}   with    S  i     subscript  S  i    S_{i}   are sets of suffixes of a finite set of codewords, there are only finitely many different candidates for $S_i$ . Since visiting one of the sets for the second time will cause the algorithm to stop, the algorithm cannot continue endlessly and thus must always terminate . More precisely, the total number of dangling suffixes that the algorithm considers is at most equal to the total of the lengths of the codewords in the input, so the algorithm runs in polynomial time as a function of this input length. By using a suffix tree to speed the comparison between each dangling suffix and the codewords, the time for the algorithm can be bounded by O( nk ), where n is the total length of the codewords and k is the number of codewords. The algorithm can be implemented using a pattern matching machine.  The algorithm can also be implemented to run on a nondeterministic turing machine that uses only logarithmic space ; the problem of testing unique decipherability is NL-complete , so this space bound is optimal. 3  A proof that the algorithm is correct , i.e. that it always gives the correct answer, is found in the textbooks by Salomaa 4 and by Berstel et al. 5  See also   Kraft's inequality in some cases provides a quick way to exclude the possibility that a given code is uniquely decodable.  Prefix codes and block codes are important classes of codes which are uniquely decodable by definition.  Timeline of information theory   Notes    References       .   .   .    .    Further reading    Robert G. Gallager : Information Theory and Reliable Communication. Wiley, 1968   "  Category:Algorithms  Category:Coding theory  Category:Data compression     Knuth (2003), p. 2 ↩  Berstel et al. (2009), Example 2.3.1 p. 63 ↩  proves that the complementary problem, of testing for the existence of a string with two decodings, is NL-complete, and therefore that unique decipherability is co-NL-complete. The equivalence of NL-completeness and co-NL-completeness follows from the Immerman–Szelepcsényi theorem . ↩  Salomaa (1981) ↩  Berstel et al. (2009), Chapter 2.3 ↩     