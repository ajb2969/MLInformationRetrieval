<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1684">Exponential smoothing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Exponential smoothing</h1>
<hr/>

<p><strong>Exponential smoothing</strong> is a <a href="rule_of_thumb" title="wikilink">rule of thumb</a> technique for smoothing time series data, particularly for recursively applying as many as 3 <a href="Low-pass_filter" title="wikilink">Low-pass filters</a> with exponential window functions. Such techniques have broad application that is not intended to be strictly accurate or reliable for every situation. It is an easily learned and easily applied procedure for approximately calculating or recalling some value, or for making some determination based on prior assumptions by the user, such as seasonality. Like any application of repeated low-pass filtering, the observed phenomenon may be an essentially <a href="stochastic_process" title="wikilink">random process</a>, or it may be an orderly, but <a href="statistical_noise" title="wikilink">noisy</a>, process. Whereas in the <a href="simple_moving_average" title="wikilink">simple moving average</a> the past observations are weighted equally, exponential <a href="window_functions" title="wikilink">window functions</a> assign exponentially decreasing weights over time. The use of three filters is based on empirical evidence and broad application, as well as its role in <a href="prime_number" title="wikilink">prime number</a> theory as the second most common prime number, and extensive use in <a class="uri" href="numerology" title="wikilink">numerology</a>.</p>

<p>Exponential smoothing is commonly applied to smooth data, as many <a href="window_functions" title="wikilink">window functions</a> are in <a href="signal_processing" title="wikilink">signal processing</a>, acting as low-pass filters to remove high frequency <a class="uri" href="noise" title="wikilink">noise</a>. This method parrots <a class="uri" href="Poisson" title="wikilink">Poisson</a>'s use of recursive exponential window functions in convolutions from the 19th century, as well as <a class="uri" href="Kolmogorov" title="wikilink">Kolmogorov</a> and <a class="uri" href="Zurbenko" title="wikilink">Zurbenko</a>'s use of recursive moving averages from their studies of turbulence in the 1940s. See <a href="Kolmogorov-Zurbenko_filter" title="wikilink">Kolmogorov-Zurbenko filter</a> for more information.</p>

<p>The raw data sequence is often represented by 

<math display="inline" id="Exponential_smoothing:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mi>t</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{t}\}
  </annotation>
 </semantics>
</math>

 beginning at time 

<math display="inline" id="Exponential_smoothing:1">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>

, and the output of the exponential smoothing algorithm is commonly written as 

<math display="inline" id="Exponential_smoothing:2">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>s</mi>
    <mi>t</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{s_{t}\}
  </annotation>
 </semantics>
</math>

, which may be regarded as a best estimate of what the next value of 

<math display="inline" id="Exponential_smoothing:3">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 will be. When the sequence of observations begins at time 

<math display="inline" id="Exponential_smoothing:4">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>

, the simplest form of exponential smoothing is given by the formulae:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> 

<math display="inline" id="Exponential_smoothing:5">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>s</mi>
      <mn>0</mn>
     </msub>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>s</mi>
      <mi>t</mi>
     </msub>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>α</mi>
         <msub>
          <mi>x</mi>
          <mi>t</mi>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mi>α</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>t</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="7.5pt">,</mo>
      <mrow>
       <mi>t</mi>
       <mo>></mo>
       <mn>0</mn>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>α</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <ci>α</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <apply>
           <minus></minus>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <gt></gt>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle s_{0}&\displaystyle=x_{0}\\
\displaystyle s_{t}&\displaystyle=\alpha x_{t}+(1-\alpha)s_{t-1},\ t>0\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Exponential_smoothing:6">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is the <em>smoothing factor</em>, and 

<math display="inline" id="Exponential_smoothing:7">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>α</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>α</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\alpha<1
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="background">Background</h2>
<h3 id="window-functions">Window functions</h3>
<h4 id="the-simple-moving-average">The simple moving average</h4>

<p>Intuitively, the simplest way to smooth a time series is to calculate a simple, or unweighted, moving average. This is known as using a rectangular or "boxcar" <a href="window_function" title="wikilink">window function</a>. The smoothed statistic <em>s</em><sub><em>t</em></sub> is then just the <a href="mean#Arithmetic_mean" title="wikilink">mean</a> of the last <em>k</em> observations:</p>

<p>

<math display="block" id="Exponential_smoothing:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mfrac>
       <mn>1</mn>
       <mi>k</mi>
      </mfrac>
     </mpadded>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mi>n</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msub>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>+</mo>
      <msub>
       <mi>x</mi>
       <mrow>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mi>k</mi>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>t</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
       </msub>
      </mrow>
      <mi>k</mi>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>n</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <ci>k</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{t}=\frac{1}{k}\,\sum_{n=0}^{k-1}x_{t-n}=\frac{x_{t}+x_{t-1}+x_{t-2}+\cdots+%
x_{t-k+1}}{k}=s_{t-1}+\frac{x_{t}-x_{t-k}}{k},
  </annotation>
 </semantics>
</math>

</p>

<p>where the choice of an integer <em>k</em> &gt; 1 is arbitrary. A small value of <em>k</em> will have less of a smoothing effect and be more responsive to recent changes in the data, while a larger <em>k</em> will have a greater smoothing effect, and produce a more pronounced <a href="autocorrelation#Statistics" title="wikilink">lag</a> in the smoothed sequence. One disadvantage of this technique is that it cannot be used on the first <em>k</em> −1 terms of the time series without the addition of values created by some other means. This means effectively <a class="uri" href="extrapolating" title="wikilink">extrapolating</a> outside the existing data, and the validity of this section would therefore be questionable and not a direct representation of the data.</p>

<p>It also introduces a <a href="phase_shift" title="wikilink">phase shift</a> into the data of half the window length. For example if the data were all the same except for one high data point, the peak in the "smoothed" data would appear half a window length later than when it actually occurred. Where the phase of the result is important, this can be simply corrected by shifting the resulting series back by half the window length.</p>

<p>A major drawback with the SMA is that it lets through a significant amount of the signal shorter than the window length. Worse, it actually inverts it. This can lead to unexpected artifacts, such as peaks in the "smoothed" result appearing where there were troughs in the data. It also leads to the result being less "smooth" than expected since some of the higher frequencies are not properly removed.</p>

<p>See <a href="moving_average" title="wikilink">moving average</a> for more detail.</p>
<h4 id="the-weighted-moving-average">The weighted moving average</h4>

<p>A slightly more intricate method for smoothing a raw time series {<em>x</em><sub><em>t</em></sub>} is to calculate a weighted moving average by first choosing a set of weighting factors</p>

<p>

<math display="block" id="Exponential_smoothing:9">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>w</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>w</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>k</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{w_{1},w_{2},\dots,w_{k}\}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Exponential_smoothing:10">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </msubsup>
    <msub>
     <mi>w</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n=1}^{k}w_{n}=1
  </annotation>
 </semantics>
</math>

</p>

<p>and then using these weights to calculate the smoothed statistics {<em>s</em><sub><em>t</em></sub>}:</p>

<p>

<math display="block" id="Exponential_smoothing:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mrow>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo>-</mo>
        <mi>n</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>w</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>w</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>k</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mrow>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <ci>k</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{t}=\sum_{n=1}^{k}w_{n}x_{t+1-n}=w_{1}x_{t}+w_{2}x_{t-1}+\cdots+w_{k}x_{t-k+%
1}.
  </annotation>
 </semantics>
</math>

</p>

<p>In practice the weighting factors are often chosen to give more weight to the most recent terms in the time series and less weight to older data. Notice that this technique has the same disadvantage as the simple moving average technique (i.e., it cannot be used until at least <em>k</em> observations have been made), and that it entails a more complicated calculation at each step of the smoothing procedure. In addition to this disadvantage, if the data from each stage of the averaging is not available for analysis, it may be difficult if not impossible to reconstruct a changing signal accurately (because older samples may be given less weight). If the number of stages missed is known however, the weighting of values in the average can be adjusted to give equal weight to all missed samples to avoid this issue.</p>
<h2 id="the-exponential-moving-average">The exponential moving average</h2>

<p>The use of the exponential window function is first attributed to <a class="uri" href="Poisson" title="wikilink">Poisson</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> as an extension of a numerical analysis technique from the 17th century, and later adopted by the <a href="signal_processing" title="wikilink">signal processing</a> community in the 1940s. Here, exponential smoothing is the application of the exponential, or Poisson, <a href="window_function" title="wikilink">window function</a>. Exponential smoothing was first suggested in the statistical literature without citation to previous work by <a href="Robert_Goodell_Brown" title="wikilink">Robert Goodell Brown</a> in 1956,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and then expanded by <a href="Charles_C._Holt" title="wikilink">Charles C. Holt</a> in 1957.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The formulation below, which is the one commonly used, is attributed to Brown and is known as “Brown’s simple exponential smoothing”.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> All the methods of Holt, Winters and Brown may be seen as a simple application of recursive filtering, first found in the 1940's<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> to convert FIR filters to IIR filters.</p>

<p>The simplest form of exponential smoothing is given by the formula:</p>

<p>

<math display="block" id="Exponential_smoothing:12">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>⋅</mo>
     <msub>
      <mi>x</mi>
      <mi>t</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>α</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{t}=\alpha\cdot x_{t}+(1-\alpha)\cdot s_{t-1}
  </annotation>
 </semantics>
</math>

.</p>

<p>where α is the <em>smoothing factor</em>, and 0 <em>t</em> is a simple weighted average of the current observation <em>x</em><sub><em>t</em></sub> and the previous smoothed statistic <em>s</em><sub><em>t</em>−1</sub>. The term <em>smoothing factor</em> applied to α here is something of a misnomer, as larger values of α actually reduce the level of smoothing, and in the limiting case with α = 1 the output series is just the same as the original series. Simple exponential smoothing is easily applied, and it produces a smoothed statistic as soon as two observations are available.</p>

<p>Values of α close to one have less of a smoothing effect and give greater weight to recent changes in the data, while values of α closer to zero have a greater smoothing effect and are less responsive to recent changes. There is no formally correct procedure for choosing α. Sometimes the statistician’s judgment is used to choose an appropriate factor. Alternatively, a statistical technique may be used to <em>optimize</em> the value of α. For example, the <a href="least_squares" title="wikilink">method of least squares</a> might be used to determine the value of α for which the sum of the quantities (<em>s</em><sub><em>n</em>-1</sub> − <em>x</em><sub><em>n</em>-1</sub>)<sup>2</sup> is minimized.</p>

<p>Unlike some other smoothing methods (which?), this technique does not require any minimum number of observations to be made before it begins to produce results. In practice, however, a “good average” will not be achieved until several samples have been averaged together; for example, a constant signal will take approximately <em>3</em>/<em>α</em> stages to reach 95% of the actual value. To accurately reconstruct the original signal without information loss all stages of the exponential moving average must also be available, because older samples decay in weight exponentially. This is in contrast to a simple moving average, in which some samples can be skipped without as much loss of information due to the constant weighting of samples within the average. If a known number of samples will be missed, one can adjust a weighted average for this as well, by giving equal weight to the new sample and all those to be skipped.</p>

<p>This simple form of exponential smoothing is also known as an <a href="Moving_average#Exponential_moving_average" title="wikilink">exponentially weighted moving average</a> (EWMA). Technically it can also be classified as an <a href="Autoregressive_integrated_moving_average" title="wikilink">Autoregressive integrated moving average</a> (ARIMA) (0,1,1) model with no constant term.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="time-constant">Time Constant</h3>

<p>The <a href="Time_Constant" title="wikilink">Time Constant</a> of an exponential moving average is the amount of time for the smoothed response of a unit set function to reach 

<math display="inline" id="Exponential_smoothing:13">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>e</mi>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>63.2</mn>
    </mpadded>
    <mo lspace="0pt" rspace="3.5pt">%</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">percent</csymbol>
     <cn type="float">63.2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-1/e\approx 63.2\,\%
  </annotation>
 </semantics>
</math>

 of the final final. The relationship between this time constant and the the smoothing factor is given by the formula:</p>

<p>

<math display="block" id="Exponential_smoothing:14">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msup>
     <mi>e</mi>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>T</mi>
       </mrow>
      </mrow>
      <mrow>
       <mi>T</mi>
       <mi>C</mi>
      </mrow>
     </mfrac>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>C</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=1-e^{-\Delta T\over TC}
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Exponential_smoothing:15">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta T
  </annotation>
 </semantics>
</math>

 is the sampling time interval of the discrete time implementation. If the sampling time is fast compared to the time constant then</p>

<p>

<math display="block" id="Exponential_smoothing:16">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>≈</mo>
   <mfrac>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>T</mi>
    </mrow>
    <mrow>
     <mi>T</mi>
     <mi>C</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>α</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\approx{\Delta T\over TC}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="choosing-the-initial-smoothed-value">Choosing the initial smoothed value</h3>

<p>Note that in the above definition <em>s</em><sub><em>1</em></sub> is being initialized to <em>x</em><sub><em>0</em></sub>. Because exponential smoothing requires that at each stage we have the previous forecast, it is not obvious how to get the method started. We could assume that the initial forecast is equal to the initial value of demand; however, this approach has a serious drawback. Exponential smoothing puts substantial weight on past observations, so the initial value of demand will have an unreasonably large effect on early forecasts. This problem can be overcome by allowing the process to evolve for a reasonable number of periods (10 or more) and using the average of the demand during those periods as the initial forecast. There are many other ways of setting this initial value, but it is important to note that the smaller the value of <em>α</em>, the more sensitive your forecast will be on the selection of this initial smoother value <em>s</em><sub><em>1</em></sub>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="optimization">Optimization</h3>

<p>For every exponential smoothing method we also need to choose the value for the smoothing parameters. For simple exponential smoothing, there is only one smoothing parameter (α), but for the methods that follow there is usually more than one smoothing parameter.</p>

<p>There are cases where the smoothing parameters may be chosen in a subjective manner — the forecaster specifies the value of the smoothing parameters based on previous experience. However, a more robust and objective way to obtain values for the unknown parameters included in any exponential smoothing method is to estimate them from the observed data.</p>

<p>The unknown parameters and the initial values for any exponential smoothing method can be estimated by minimizing the SSE. The errors are specified as 

<math display="inline" id="Exponential_smoothing:17">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>t</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>t</mi>
      <mo stretchy="false">|</mo>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>y</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">t</csymbol>
       <minus></minus>
       <cn type="integer">1</cn>
      </cerror>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{t}=y_{t}-\hat{y}_{t|t-1}
  </annotation>
 </semantics>
</math>

 for t=1,…,T (the one-step-ahead within-sample forecast errors). Hence we find the values of the unknown parameters and the initial values that minimize</p>

<p>

<math display="inline" id="Exponential_smoothing:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mi>S</mi>
    <mi>E</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>t</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>T</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>t</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mover accent="true">
         <mi>y</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mrow>
         <mi>t</mi>
         <mo stretchy="false">|</mo>
         <mi>t</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>t</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>T</mi>
    </msubsup>
    <msubsup>
     <mi>e</mi>
     <mi>t</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>S</ci>
      <ci>E</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>y</ci>
         </apply>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <csymbol cd="unknown">t</csymbol>
          <ci>normal-|</ci>
          <csymbol cd="unknown">t</csymbol>
          <minus></minus>
          <cn type="integer">1</cn>
         </cerror>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>t</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SSE=\sum_{t=1}^{T}(y_{t}-\hat{y}_{t|t-1})^{2}=\sum_{t=1}^{T}e_{t}^{2}
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Unlike the regression case (where we have formulae that return the values of the regression coefficients which minimize the SSE) this involves a non-linear minimization problem and we need to use an optimization tool to perform this.</p>
<h3 id="why-is-it-exponential">Why is it “exponential”?</h3>

<p>The name 'exponential smoothing' is attributed to the use of the exponential window function during convolution. It is no longer attributed to Holt, Winters &amp; Brown.</p>

<p>By direct substitution of the defining equation for simple exponential smoothing back into itself we find that</p>

<p>

<math display="inline" id="Exponential_smoothing:19">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle s_{t}
  </annotation>
 </semantics>
</math>


</p>

<p>In other words, as time passes the smoothed statistic <em>s</em><sub><em>t</em></sub> becomes the weighted average of a greater and greater number of the past observations <em>x</em><sub><em>t−n</em></sub>, and the weights assigned to previous observations are in general proportional to the terms of the geometric progression {1, (1 − α), (1 − α)<sup>2</sup>, (1 − α)<sup>3</sup>, ...}. A <a href="geometric_progression" title="wikilink">geometric progression</a> is the discrete version of an <a href="exponential_function" title="wikilink">exponential function</a>, so this is where the name for this smoothing method originated according to <a class="uri" href="Statistics" title="wikilink">Statistics</a> lore.</p>
<h3 id="comparison-with-moving-average">Comparison with moving average</h3>

<p>Exponential smoothing and moving average have similar defects of introducing a lag relative to the input data. While this can be corrected by shifting the result by half the window length for a symmetrical kernel, such as a moving average or gaussian, it is unclear how appropriate this would be for exponential smoothing. They also both have roughly the same distribution of forecast error when <em>α = 2/(k+1)</em>. They differ in that exponential smoothing takes into account all past data, whereas moving average only takes into account <em>k</em> past data points. Computationally speaking, they also differ in that moving average requires that the past <em>k</em> data points be kept, whereas exponential smoothing only needs the most recent forecast value to be kept.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>In the <a href="signal_processing" title="wikilink">signal processing</a> literature, the use of non-causal (symmetric) filters is commonplace, and the exponential <a href="window_function" title="wikilink">window function</a> is broadly used in this fashion.</p>
<h2 id="double-exponential-smoothing">Double exponential smoothing</h2>

<p>Simple exponential smoothing does not do well when there is a <a href="Trend_estimation" title="wikilink">trend</a> in the data, which is inconvenient.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> In such situations, several methods were devised under the name "double exponential smoothing" or "second-order exponential smoothing.", which is the recursive application of an exponential filter twice, thus being termed "double exponential smoothing". This nomenclature is similar to quadruple exponential smoothing, which also references its recursion depth.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The basic idea behind double exponential smoothing is to introduce a term to take into account the possibility of a series exhibiting some form of trend. This slope component is itself updated via exponential smoothing.</p>

<p>One method, sometimes referred to as "Holt-Winters double exponential smoothing"<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> works as follows:<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Again, the raw data sequence of observations is represented by {<em>x</em><sub><em>t</em></sub>}, beginning at time <em>t</em> = 0. We use {<em>s</em><sub><em>t</em></sub>} to represent the smoothed value for time <em>t</em>, and {<em>b</em><sub><em>t</em></sub>} is our best estimate of the trend at time <em>t</em>. The output of the algorithm is now written as <em>F</em><sub><em>t+m</em></sub>, an estimate of the value of <em>x</em> at time <em>t+m, m&gt;0</em> based on the raw data up to time <em>t</em>. Double exponential smoothing is given by the formulas</p>

<p>

<math display="inline" id="Exponential_smoothing:20">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle s_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>And for t &gt; 1 by</p>

<p>

<math display="inline" id="Exponential_smoothing:21">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle s_{t}
  </annotation>
 </semantics>
</math>


 where α is the <em>data smoothing factor</em>, 0 <em>t</em></p>

<p>

<math display="inline" id="Exponential_smoothing:22">
 <semantics>
  <msub>
   <mi>F</mi>
   <mrow>
    <mi>t</mi>
    <mo>+</mo>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle F_{t+m}
  </annotation>
 </semantics>
</math>


</p>

<p>Setting the initial value <em>b</em><sub><em>0</em></sub> is a matter of preference. An option other than the one listed above is <em>(x<sub><em>n</em></sub> - x<sub><em>0</em></sub>)/n</em> for some <em>n &gt; 1</em>.</p>

<p>Note that <em>F</em><sub>0</sub> is undefined (there is no estimation for time 0), and according to the definition <em>F</em><sub>1</sub>=<em>s</em><sub>0</sub>+<em>b</em><sub>0</sub>, which is well defined, thus further values can be evaluated.</p>

<p>A second method, referred to as either Brown's linear exponential smoothing (LES) or Brown's double exponential smoothing works as follows.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>

<math display="inline" id="Exponential_smoothing:23">
 <semantics>
  <msubsup>
   <mi>s</mi>
   <mn>0</mn>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle s^{\prime}_{0}
  </annotation>
 </semantics>
</math>


</p>

<p>where <em>a</em><sub><em>t</em></sub>, the estimated level at time <em>t</em> and <em>b</em><sub><em>t</em></sub>, the estimated trend at time <em>t</em> are:</p>

<p>

<math display="inline" id="Exponential_smoothing:24">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle a_{t}
  </annotation>
 </semantics>
</math>


</p>
<h2 id="triple-exponential-smoothing">Triple exponential smoothing</h2>

<p>Triple exponential smoothing takes into account seasonal changes as well as trends (all of which are trends). Seasonality is deﬁned to be the tendency of time-series data to exhibit behavior that repeats itself every L periods, much like any harmonic function. The term season is used to represent the period of time before behavior begins to repeat itself. There are different types of seasonality: 'mutiplicative' and 'additive' in nature, much like addition and multiplication are basic operations in mathematics. It is unclear why the statistical literature chooses to adopt special terminology for this application of common filters which predates the use in <a class="uri" href="Statistics" title="wikilink">Statistics</a> by nearly 150 years.</p>

<p>If every month of December we sell 10.000 more apartments that we do in November the seasonality is <em>additive</em> in nature. Can be represented by an 'absolute' increase. However, if we sell 10% more apartments in the summer months than we do in the winter months the seasonality is <em>multiplicative</em> in nature. Mutiplicative seasonality can be represented as a constant factor, not an absolute amount. <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Triple exponential smoothing was first suggested by Holt's student, Peter Winters, in 1960 after reading a signal processing book from the 1940s on exponential smoothing.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Holt's novel idea was to repeat filtering an odd number of times (ignoring 1) . While recursive filtering had been used previously, it was applied twice and four times to coincide with the <a href="Hadamard_conjecture" title="wikilink">Hadamard conjecture</a>, while triple application required more than double the operations of singular convolution.</p>

<p>Suppose we have a sequence of observations {<em>x</em><sub><em>t</em></sub>}, beginning at time <em>t</em> = 0 with a cycle of seasonal change of length <em>L</em>.</p>

<p>The method calculates a trend line for the data as well as seasonal indices that weight the values in the trend line based on where that time point falls in the cycle of length <em>L</em>.</p>

<p>{<em>s</em><sub><em>t</em></sub>} represents the smoothed value of the constant part for time <em>t</em>. {<em>b</em><sub><em>t</em></sub>} represents the sequence of best estimates of the linear trend that are superimposed on the seasonal changes. {<em>c</em><sub><em>t</em></sub>} is the sequence of seasonal correction factors. <em>c</em><sub><em>t</em></sub> is the expected proportion of the predicted trend at any time <em>t mod L</em> in the cycle that the observations take on. As a rule of thumb, a minimum of two full seasons (or 2L periods) of historical data is needed to initialize a set of seasonal factors.</p>

<p>The output of the algorithm is again written as <em>F</em><sub><em>t+m</em></sub>, an estimate of the value of <em>x</em> at time <em>t+m, m&gt;0</em> based on the raw data up to time <em>t</em>. Triple exponential smoothing is given by the formulas<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>

<math display="inline" id="Exponential_smoothing:25">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle s_{0}
  </annotation>
 </semantics>
</math>


</p>

<p>where α is the <em>data smoothing factor</em>, 0 <em>0</em> is:</p>

<p>

<math display="inline" id="Exponential_smoothing:26">
 <semantics>
  <msub>
   <mi>b</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle b_{0}
  </annotation>
 </semantics>
</math>


</p>

<p>Setting the initial estimates for the seasonal indices <em>c</em><sub><em>i</em></sub> for <em>i</em> = 1,2,...,L is a bit more involved. If <em>N</em> is the number of complete cycles present in your data, then:</p>

<p>

<math display="inline" id="Exponential_smoothing:27">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle c_{i}
  </annotation>
 </semantics>
</math>


 where</p>

<p>

<math display="inline" id="Exponential_smoothing:28">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A_{j}
  </annotation>
 </semantics>
</math>


 Note that <em>A</em><sub><em>j</em></sub> is the average value of <em>x</em> in the <em>j</em>th cycle of your data.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Moving_average" title="wikilink">Moving average</a></li>
<li><a href="Autoregressive_moving_average_model" title="wikilink">Autoregressive moving average model</a> (ARMA)</li>
<li><a href="Autoregressive_integrated_moving_average" title="wikilink">Autoregressive integrated moving average</a> (ARIMA)</li>
<li><a href="Errors_and_residuals_in_statistics" title="wikilink">Errors and residuals in statistics</a></li>
<li><a href="Low-pass_filter" title="wikilink">Low-pass filter</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://people.duke.edu/~rnau/411avg.htm">Lecture notes on exponential smoothing (Robert Nau, Duke University)</a></li>
<li><a href="http://demonstrations.wolfram.com/DataSmoothing/">Data Smoothing</a> by Jon McLoone, <a href="The_Wolfram_Demonstrations_Project" title="wikilink">The Wolfram Demonstrations Project</a></li>
<li><a href="http://forecasters.org/pdfs/foresight/free/Issue19_goodwin.pdf">The Holt-Winters Approach to Exponential Smoothing: 50 Years Old and Going Strong</a> by Paul Goodwin (2010) <a href="Foresight:_The_International_Journal_of_Applied_Forecasting" title="wikilink">Foresight: The International Journal of Applied Forecasting</a></li>
<li><a href="http://www.eckner.com/papers/ts_alg.pdf">Algorithms for Unevenly Spaced Time Series: Moving Averages and Other Rolling Operators</a> by Andreas Eckner</li>
</ul>

<p>"</p>

<p><a href="Category:Time_series_analysis" title="wikilink">Category:Time series analysis</a> <a href="Category:Data_analysis" title="wikilink">Category:Data analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"> reprinted in <a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">"Production and Operations Analysis" Nahmias. 2009.<a href="#fnref8">↩</a></li>
<li id="fn9"><a class="uri" href="https://www.otexts.org/fpp/7/1">https://www.otexts.org/fpp/7/1</a><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
</ol>
</section>
</body>
</html>
