   BrownBoost      BrownBoost   BrownBoost is a boosting algorithm that may be robust to noisy datasets. BrownBoost is an adaptive version of the boost by majority algorithm. As is true for all boosting algorithms, BrownBoost is used in conjunction with other machine learning methods. BrownBoost was introduced by Yoav Freund in 2001. 1  Motivation  AdaBoost performs well on a variety of datasets; however, it can be shown that AdaBoost does not perform well on noisy data sets. 2 This is a result of AdaBoost's focus on examples that are repeatedly misclassified. In contrast, BrownBoost effectively "gives up" on examples that are repeatedly misclassified. The core assumption of BrownBoost is that noisy examples will be repeatedly mislabeled by the weak hypotheses and non-noisy examples will be correctly labeled frequently enough to not be "given up on." Thus only noisy examples will be "given up on," whereas non-noisy examples will contribute to the final classifier. In turn, if the final classifier is learned from the non-noisy examples, the generalization error of the final classifier may be much better than if learned from noisy and non-noisy examples.  The user of the algorithm can set the amount of error to be tolerated in the training set. Thus, if the training set is noisy (say 10% of all examples are assumed to be mislabeled), the booster can be told to accept a 10% error rate. Since the noisy examples may be ignored, only the true examples will contribute to the learning process.  Algorithm Description  BrownBoost uses a non-convex potential loss function, thus it does not fit into the AnyBoost framework. The non-convex optimization provides a method to avoid overfitting noisy data sets. However, in contrast to boosting algorithms that analytically minimize a convex loss function (e.g. AdaBoost and LogitBoost ), BrownBoost solves a system of two equations and two unknowns using standard numerical methods.  The only parameter of BrownBoost (   c   c   c   in the algorithm) is the "time" the algorithm runs. The theory of BrownBoost states that each hypothesis takes a variable amount of time (   t   t   t   in the algorithm) which is directly related to the weight given to the hypothesis   α   α   \alpha   . The time parameter in BrownBoost is analogous to the number of iterations   T   T   T   in AdaBoost.  A larger value of   c   c   c   means that BrownBoost will treat the data as if it were less noisy and therefore will give up on fewer examples. Conversely, a smaller value of   c   c   c   means that   c   c   c   BrownBoost will treat the data as more noisy and give up on more examples.  During each iteration of the algorithm, a hypothesis is selected with some advantage over random guessing. The weight of this hypothesis   α   α   \alpha   and the "amount of time passed"   t   t   t   during the iteration are simultaneously solved in a system of two non-linear equations ( 1. uncorrelate hypothesis w.r.t example weights and 2. hold the potential constant) with two unknowns (weight of hypothesis   α   α   \alpha   and time passed   t   t   t   ). This can be solved by bisection (as implemented in the JBoost software package) or Newton's method (as described in the original paper by Freund). Once these equations are solved, the margins of each example (     r  i    (   x  j   )        subscript  r  i    subscript  x  j     r_{i}(x_{j})   in the algorithm) and the amount of time remaining   s   s   s   are updated appropriately. This process is repeated until there is no time remaining.  The initial potential is defined to be       1  m     ∑   j  =  1   m   1    -   erf   (   c   )     =   1  -   erf   (   c   )               1  m     superscript   subscript     j  1    m   1      erf    c       1    erf    c       \frac{1}{m}\sum_{j=1}^{m}1-\mbox{erf}(\sqrt{c})=1-\mbox{erf}(\sqrt{c})   . Since a constraint of each iteration is that the potential be held constant, the final potential is       1  m     ∑   j  =  1   m   1    -   erf   (     r  i    (   x  j   )    /   c    )     =   1  -   erf   (   c   )               1  m     superscript   subscript     j  1    m   1      erf       subscript  r  i    subscript  x  j      c        1    erf    c       \frac{1}{m}\sum_{j=1}^{m}1-\mbox{erf}(r_{i}(x_{j})/\sqrt{c})=1-\mbox{erf}(%
 \sqrt{c})   . Thus the final error is likely to be near    1  -   erf   (   c   )        1    erf    c      1-\mbox{erf}(\sqrt{c})   . However, the final potential function is not the 0-1 loss error function. For the final error to be exactly    1  -   erf   (   c   )        1    erf    c      1-\mbox{erf}(\sqrt{c})   , the variance of the loss function must decrease linearly w.r.t. time to form the 0-1 loss function at the end of boosting iterations. This is not yet discussed in the literature and is not in the definition of the algorithm below.  The final classifier is a linear combination of weak hypotheses and is evaluated in the same manner as most other boosting algorithms.  BrownBoost Learning Algorithm Definition  Input:      m   m   m   training examples     (   x  1   ,   y  1   )   ,  …  ,   (   x  m   ,   y  m   )        subscript  x  1    subscript  y  1    normal-…    subscript  x  m    subscript  y  m      (x_{1},y_{1}),\ldots,(x_{m},y_{m})   where      x  j   ∈  X   ,    y  j   ∈  Y  =   {   -  1   ,   +  1   }       formulae-sequence     subscript  x  j   X        subscript  y  j   Y          1     1        x_{j}\in X,\,y_{j}\in Y=\{-1,+1\}     The parameter   c   c   c      Initialise:       s  =  c      s  c    s=c   . The value of   s   s   s   is the amount of time remaining in the game)        r  i    (   x  j   )    =  0         subscript  r  i    subscript  x  j    0    r_{i}(x_{j})=0       ∀  j     for-all  j    \forall j   . The value of     r  i    (   x  j   )        subscript  r  i    subscript  x  j     r_{i}(x_{j})   is the margin at iteration   i   i   i   for example    x  j     subscript  x  j    x_{j}   .   While    s  >  0      s  0    s>0   :   Set the weights of each example      W  i    (   x  j   )    =   e   -     (     r  i    (   x  j   )    +  s   )   2   c            subscript  W  i    subscript  x  j     superscript  e       superscript       subscript  r  i    subscript  x  j    s   2   c       W_{i}(x_{j})=e^{-\frac{(r_{i}(x_{j})+s)^{2}}{c}}   , where     r  i    (   x  j   )        subscript  r  i    subscript  x  j     r_{i}(x_{j})   is the margin of example    x  j     subscript  x  j    x_{j}     Find a classifier     h  i   :   X  →   {   -  1   ,   +  1   }       normal-:   subscript  h  i    normal-→  X     1     1       h_{i}:X\to\{-1,+1\}   such that      ∑  j     W  i    (   x  j   )    h  i    (   x  j   )    y  j     >  0        subscript   j      subscript  W  i    subscript  x  j    subscript  h  i    subscript  x  j    subscript  y  j     0    \sum_{j}W_{i}(x_{j})h_{i}(x_{j})y_{j}>0     Find values    α  ,  t     α  t    \alpha,t   that satisfy the equation:       ∑  j     h  i    (   x  j   )    y  j    e   -     (      r  i    (   x  j   )    +   α   h  i    (   x  j   )    y  j    +  s   -  t   )   2   c       =  0        subscript   j      subscript  h  i    subscript  x  j    subscript  y  j    superscript  e       superscript         subscript  r  i    subscript  x  j      α   subscript  h  i    subscript  x  j    subscript  y  j    s   t   2   c       0    \sum_{j}h_{i}(x_{j})y_{j}e^{-\frac{(r_{i}(x_{j})+\alpha h_{i}(x_{j})y_{j}+s-t)%
 ^{2}}{c}}=0   . (Note this is similar to the condition      E   W   i  +  1      [    h  i    (   x  j   )    y  j    ]    =  0         subscript  E   subscript  W    i  1      delimited-[]     subscript  h  i    subscript  x  j    subscript  y  j      0    E_{W_{i+1}}[h_{i}(x_{j})y_{j}]=0   set forth by Schapire and Singer. 3 In this setting, we are numerically finding the     W   i  +  1    =   exp   (   …  …   )         subscript  W    i  1        normal-…  normal-…      W_{i+1}=\exp(\frac{\ldots}{\ldots})   such that      E   W   i  +  1      [    h  i    (   x  j   )    y  j    ]    =  0         subscript  E   subscript  W    i  1      delimited-[]     subscript  h  i    subscript  x  j    subscript  y  j      0    E_{W_{i+1}}[h_{i}(x_{j})y_{j}]=0   .) This update is subject to the constraint      ∑   (    Φ   (      r  i    (   x  j   )    +   α  h   (   x  j   )    y  j    +  s   -  t   )    -   Φ   (     r  i    (   x  j   )    +  s   )     )    =  0            normal-Φ         subscript  r  i    subscript  x  j      α  h   subscript  x  j    subscript  y  j    s   t      normal-Φ       subscript  r  i    subscript  x  j    s      0    \sum\left(\Phi\left(r_{i}(x_{j})+\alpha h(x_{j})y_{j}+s-t\right)-\Phi\left(r_{%
 i}(x_{j})+s\right)\right)=0   , where     Φ   (  z  )    =   1  -   erf   (   z  /   c    )           normal-Φ  z     1    erf    z    c        \Phi(z)=1-\mbox{erf}(z/\sqrt{c})   is the potential loss for a point with margin     r  i    (   x  j   )        subscript  r  i    subscript  x  j     r_{i}(x_{j})     Update the margins for each example      r   i  +  1     (   x  j   )    =     r  i    (   x  j   )    +   α  h   (   x  j   )    y  j            subscript  r    i  1     subscript  x  j         subscript  r  i    subscript  x  j      α  h   subscript  x  j    subscript  y  j       r_{i+1}(x_{j})=r_{i}(x_{j})+\alpha h(x_{j})y_{j}     Update the time remaining    s  =   s  -  t       s    s  t     s=s-t      Output     H   (  x  )    =   sign   (    ∑  i     α  i    h  i    (  x  )     )          H  x     sign    subscript   i      subscript  α  i    subscript  h  i   x       H(x)=\textrm{sign}\left(\sum_{i}\alpha_{i}h_{i}(x)\right)     Empirical Results  In preliminary experimental results with noisy datasets, BrownBoost outperformed AdaBoost 's generalization error; however, LogitBoost performed as well as BrownBoost. 4 An implementation of BrownBoost can be found in the open source software JBoost .  References  See also   Boosting  AdaBoost  Alternating decision trees  JBoost   "  Category:Classification algorithms  Category:Ensemble learning     Yoav Freund. An adaptive version of the boost by majority algorithm. Machine Learning, 43(3):293--318, June 2001. ↩  Dietterich, T. G., (2000). An experimental comparison of three methods for constructing ensembles of decision trees: Bagging, boosting, and randomization. Machine Learning, 40 (2) 139-158. ↩  Robert Schapire and Yoram Singer. Improved Boosting Using Confidence-rated Predictions. Journal of Machine Learning, Vol 37(3), pages 297-336. 1999 ↩  Ross A. McDonald, David J. Hand, Idris A. Eckley. An Empirical Comparison of Three Boosting Algorithms on Real Data Sets with Artificial Class Noise. Multiple Classifier Systems, In Series Lecture Notes in Computer Science, pages 35-44, 2003. ↩     