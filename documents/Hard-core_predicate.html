<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1919">Hard-core predicate</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hard-core predicate</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, a <strong>hard-core predicate</strong> of a <a href="one-way_function" title="wikilink">one-way function</a> <em>f</em> is a <a href="Predicate_(mathematics)" title="wikilink">predicate</a> <em>b</em> (i.e., a function whose output is a single bit) which is easy to compute given <em>x</em> but is hard to compute given <em>f(x)</em>. In formal terms, there is no <a href="Bounded-error_probabilistic_polynomial" title="wikilink">probabilistic polynomial-time algorithm</a> that computes <em>b(x)</em> from <em>f(x)</em> with probability <a href="negligible_function_(cryptography)" title="wikilink">significantly greater</a> than one half over random choice of <em>x</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>A <strong>hard-core function</strong> can be defined similarly.</p>

<p>A hard-core predicate captures "in a concentrated sense" the hardness of inverting <em>f</em>.</p>

<p>While a one-way function is hard to invert, there are no guarantees about the feasibility of computing partial information about the <a class="uri" href="preimage" title="wikilink">preimage</a> <em>c</em> from the image <em>f(x)</em>. For instance, while <a href="RSA_(algorithm)" title="wikilink">RSA</a> is conjectured to be a one-way function, the <a href="Jacobi_symbol" title="wikilink">Jacobi symbol</a> of the preimage can be easily computed from that of the image.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>It is clear that if a <a href="injective_function" title="wikilink">one-to-one function</a> has a hard-core predicate, then it must be one way. <a href="Oded_Goldreich" title="wikilink">Oded Goldreich</a> and <a href="Leonid_Levin" title="wikilink">Leonid Levin</a> (1989) showed how every one-way function can be trivially modified to obtain a one-way function that has a specific hard-core predicate.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Let <em>f</em> be a one-way function. Define</p>
<dl>
<dd><em>g(x, r)</em> = <em>(f(x), r)</em>,
</dd>
</dl>

<p>where the length of <em>r</em> is the same as that of <em>x</em>. Let 

<math display="inline" id="Hard-core_predicate:0">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

 denote the <em>j</em><sup>th</sup> bit of <em>x</em> and 

<math display="inline" id="Hard-core_predicate:1">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{j}
  </annotation>
 </semantics>
</math>

 the <em>j</em><sup>th</sup> bit of <em>r</em>. Then</p>

<p>

<math display="block" id="Hard-core_predicate:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mi>j</mi>
    </munder>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>r</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>r</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(x,r)=\bigoplus_{j}x_{j}r_{j}
  </annotation>
 </semantics>
</math>

</p>

<p>is a hard core predicate of <em>g</em>. Note that 

<math display="inline" id="Hard-core_predicate:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>r</ci>
     </interval>
    </apply>
    <list>
     <ci>x</ci>
     <ci>r</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(x,r)=\langle x,r\rangle
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Hard-core_predicate:4">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mo>⋅</mo>
   <mo>,</mo>
   <mo>⋅</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-⋅</ci>
    <ci>normal-⋅</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle
  </annotation>
 </semantics>
</math>

 denotes the standard <a href="Inner_product_space" title="wikilink">inner product</a> on the <a href="vector_space" title="wikilink">vector space</a> 

<math display="inline" id="Hard-core_predicate:5">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\Z</mtext>
      </merror>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Z</mtext>
     </merror>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <mtext>\Z</mtext>
      <cn type="integer">2</cn>
     </apply>
     <mtext>\Z</mtext>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Z/2\Z)^{n}
  </annotation>
 </semantics>
</math>

. This predicate is hard-core due to computational issues; that is, it is not hard to compute because <em>g(x, r)</em> is <a href="information_theory" title="wikilink">information theoretically</a> lossy. Rather, if an algorithm exists to compute this predicate efficiently, then an algorithm exists to invert <em>f</em> efficiently. A similar construction yields a hard-core function with <em>log (|x|)</em> output bits.</p>

<p>It is sometimes the case that an actual bit of the input <em>x</em> is hard-core. For example, every single bit of inputs to the RSA function is a hard-core predicate of RSA and blocks of 

<math display="inline" id="Hard-core_predicate:6">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log|x|)
  </annotation>
 </semantics>
</math>

 bits of x are indistinguishable from random bit strings in polynomial time (under the assumption that the RSA function is hard to invert).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Hard-core predicates give a way to construct a <a href="CSPRNG" title="wikilink">pseudorandom generator</a> from any <a href="one-way_permutation" title="wikilink">one-way permutation</a>. If <em>b</em> is a hard-core predicate of a one-way permutation <em>f</em>, and <em>s</em> is a random seed, then</p>

<p>

<math display="block" id="Hard-core_predicate:7">
 <semantics>
  <msub>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>b</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>f</mi>
        <mi>n</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <times></times>
      <ci>b</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <ci>s</ci>
      </apply>
     </apply>
    </set>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{b(f^{n}(s))\right\}_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>is a pseudorandom bit sequence.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Hard-core predicates of trapdoor one-way permutations (known as <strong>trapdoor predicates</strong>) can be used to construct <a href="semantic_security" title="wikilink">semantically secure</a> public-key encryption schemes.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="List-decoding" title="wikilink">List-decoding</a> (describes list decoding; the core of the Goldreich-Levin construction of hard-core predicates from one-way functions can be viewed as an algorithm for list-decoding the <a href="Hadamard_code" title="wikilink">Hadamard code</a>).</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Oded Goldreich, <em>Foundations of Cryptography vol 1: Basic Tools</em>, Cambridge University Press, 2001.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Pseudorandomness" title="wikilink">Category:Pseudorandomness</a> <a href="Category:Theory_of_cryptography" title="wikilink">Category:Theory of cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Shafi_Goldwasser" title="wikilink">Goldwasser, S.</a> and <a href="Mihir_Bellare" title="wikilink">Bellare, M.</a> <a href="http://cseweb.ucsd.edu/~mihir/papers/gb.html">"Lecture Notes on Cryptography"</a>. Summer course on cryptography, MIT, 1996-2001<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3">O. Goldreich and L.A. Levin, [<a class="uri" href="http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.95.2079&amp;rep">http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.95.2079&amp;rep;</a>;=rep1&amp;type;=pdf A Hard-Core Predicate for all One-Way Functions], STOC 1989, pp25–32.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="Johan_Håstad" title="wikilink">J. Håstad</a>, M. Naslund, <a href="http://www.csc.kth.se/tcs/tfrutv99/rsabit.pdf">The Security of all RSA and Discrete Log Bits (2004)</a>: Journal of the ACM (JACM), 2004.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
</ol>
</section>
</body>
</html>
