<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="123">Recursively enumerable set</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Recursively enumerable set</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a>, traditionally called recursion theory, a set <em>S</em> of <a href="natural_numbers" title="wikilink">natural numbers</a> is called <strong>recursively enumerable</strong>, <strong>computably enumerable</strong>, <strong>semidecidable</strong>, <strong>provable</strong> or <strong>Turing-recognizable</strong> if:</p>
<ul>
<li>There is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> such that the set of input numbers for which the algorithm halts is exactly <em>S</em>.</li>
</ul>

<p>Or, equivalently,</p>
<ul>
<li>There is an algorithm that <a href="enumeration" title="wikilink">enumerates</a> the members of <em>S</em>. That means that its output is simply a list of the members of <em>S</em>: <em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, <em>s</em><sub>3</sub>, ... . If necessary, this algorithm may run forever.</li>
</ul>

<p>The first condition suggests why the term <em>semidecidable</em> is sometimes used; the second suggests why <em>computably enumerable</em> is used. The abbreviations <strong>r.e.</strong> and <strong>c.e.</strong> are often used, even in print, instead of the full phrase.</p>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the <a href="complexity_class" title="wikilink">complexity class</a> containing all recursively enumerable sets is <a href="RE_(complexity)" title="wikilink">RE</a>. In <a href="recursion_theory" title="wikilink">recursion theory</a>, the <a href="Lattice_(order)" title="wikilink">lattice</a> of r.e. sets under inclusion is denoted 

<math display="inline" id="Recursively_enumerable_set:0">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℰ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℰ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>A set <em>S</em> of natural numbers is called <strong>recursively enumerable</strong> if there is a <a href="partial_recursive_function" title="wikilink">partial recursive function</a> whose <a href="domain_(mathematics)" title="wikilink">domain</a> is exactly <em>S</em>, meaning that the function is defined if and only if its input is a member of <em>S</em>.</p>
<h2 id="equivalent-formulations">Equivalent formulations</h2>

<p>The following are all equivalent properties of a set <em>S</em> of natural numbers:</p>
<dl>
<dd>Semidecidability:
<ul>
<li>The set <em>S</em> is recursively enumerable. That is, <em>S</em> is the domain (co-range) of a partial recursive function.</li>
<li>There is a partial recursive function <em>f</em> such that:</li>
</ul>

<p>:<math>f(x) =</math></p>
</dd>
</dl>

<p>\left\{\begin{matrix} 1 &amp;\mbox{if}\ x \in S \\ \mbox{undefined/does not halt}\ &amp;\mbox{if}\ x \notin S \end{matrix}\right. </p>
<dl>
<dd>Enumerability:
<ul>
<li>The set <em>S</em> is the range of a partial recursive function.</li>
<li>The set <em>S</em> is the range of a total recursive function or empty. If <em>S</em> is infinite, the function can be chosen to be <a class="uri" href="injective" title="wikilink">injective</a>.</li>
<li>The set <em>S</em> is the range of a <a href="primitive_recursive_function" title="wikilink">primitive recursive function</a> or empty. Even if <em>S</em> is infinite, repetition of values may be necessary in this case.</li>
</ul>
</dd>
<dd>Diophantine:
<ul>
<li>There is a polynomial <em>p</em> with integer coefficients and variables <em>x</em>, <em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em>, <em>f</em>, <em>g</em>, <em>h</em>, <em>i</em> ranging over the natural numbers such that</li>
</ul>

<p>

<math display="block" id="Recursively_enumerable_set:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>S</mi>
   <mo>⇔</mo>
   <mo>∃</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo>,</mo>
   <mi>d</mi>
   <mo>,</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>f</mi>
   <mo>,</mo>
   <mi>g</mi>
   <mo>,</mo>
   <mi>h</mi>
   <mo>,</mo>
   <mpadded width="+5pt">
    <mi>i</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo>,</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>g</mi>
     <mo>,</mo>
     <mi>h</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">S</csymbol>
    <ci>normal-⇔</ci>
    <exists></exists>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">c</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">d</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">g</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">h</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">i</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">e</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">g</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">h</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">i</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in S\Leftrightarrow\exists a,b,c,d,e,f,g,h,i\ (p(x,a,b,c,d,e,f,g,h,i)=0).
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>There is a polynomial from the integers to the integers such that the set <em>S</em> contains exactly the non-negative numbers in its range.</li>
</ul>
</dd>
</dl>

<p>The equivalence of semidecidability and enumerability can be obtained by the technique of <a href="Dovetailing_(computer_science)" title="wikilink">dovetailing</a>.</p>

<p>The Diophantine characterizations of a recursively enumerable set, while not as straightforward or intuitive as the first definitions, were found by <a href="Yuri_Matiyasevich" title="wikilink">Yuri Matiyasevich</a> as part of the negative solution to <a href="Hilbert's_tenth_problem" title="wikilink">Hilbert's Tenth Problem</a>. Diophantine sets predate recursion theory and are therefore historically the first way to describe these sets (although this equivalence was only remarked more than three decades after the introduction of recursively enumerable sets). The number of bound variables in the above definition of the <a href="Diophantine_set" title="wikilink">Diophantine set</a> is the best known so far; it might be that a lower number can be used to define all diophantine sets.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Recursive enumeration of the set of all Turing machines halting on a fixed input: Simulate all Turing machines (enumerated on vertical axis) step by step (horizontal axis), using the shown diagonalization scheduling. If a machine terminates, print its number. This way, the number of each terminating machine is eventually printed. In the example, the algorithm prints "9, 13, 4, 15, 12, 18, 6, 2, 8, 0, ..."</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h2 id="examples">Examples</h2>
<ul>
<li>Every <a href="recursive_set" title="wikilink">recursive set</a> is recursively enumerable, but it is not true that every recursively enumerable set is recursive. For recursive sets, the algorithm must also say if an input is <em>not</em> in the set – this is not required of recursively enumerable sets.</li>
<li>A <a href="recursively_enumerable_language" title="wikilink">recursively enumerable language</a> is a recursively enumerable subset of a <a href="formal_language" title="wikilink">formal language</a>.</li>
<li>The set of all provable sentences in an effectively presented axiomatic system is a recursively enumerable set.</li>
<li><a href="Matiyasevich's_theorem" title="wikilink">Matiyasevich's theorem</a> states that every recursively enumerable set is a <a href="Diophantine_set" title="wikilink">Diophantine set</a> (the converse is trivially true).</li>
<li>The <a href="simple_set" title="wikilink">simple sets</a> are recursively enumerable but not recursive.</li>
<li>The <a href="creative_set" title="wikilink">creative sets</a> are recursively enumerable but not recursive.</li>
<li>Any <a href="productive_set" title="wikilink">productive set</a> is <strong>not</strong> recursively enumerable.</li>
<li>Given a <a href="Gödel_numbering" title="wikilink">Gödel numbering</a> 

<math display="inline" id="Recursively_enumerable_set:2">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 of the computable functions, the set 

<math display="inline" id="Recursively_enumerable_set:3">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>∣</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↓</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-↓</ci>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\langle i,x\rangle\mid\phi_{i}(x)\downarrow\}
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Recursively_enumerable_set:4">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>x</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>x</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle i,x\rangle
  </annotation>
 </semantics>
</math>

 is the <a href="Cantor_pairing_function" title="wikilink">Cantor pairing function</a> and 

<math display="inline" id="Recursively_enumerable_set:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↓</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↓</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{i}(x)\downarrow
  </annotation>
 </semantics>
</math>

 indicates 

<math display="inline" id="Recursively_enumerable_set:6">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{i}(x)
  </annotation>
 </semantics>
</math>

 is defined) is recursively enumerable (cf. picture for a fixed <em>x</em>). This set encodes the <a href="halting_problem" title="wikilink">halting problem</a> as it describes the input parameters for which each <a href="Turing_machine" title="wikilink">Turing machine</a> halts.</li>
<li>Given a Gödel numbering 

<math display="inline" id="Recursively_enumerable_set:7">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 of the computable functions, the set 

<math display="inline" id="Recursively_enumerable_set:8">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo>⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo>⟩</mo>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>ϕ</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>z</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <list>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </list>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\left\langle x,y,z\right\rangle\mid\phi_{x}(y)=z\}
  </annotation>
 </semantics>
</math>

 is recursively enumerable. This set encodes the problem of deciding a function value.</li>
<li>Given a partial function <em>f</em> from the natural numbers into the natural numbers, <em>f</em> is a partial recursive function if and only if the graph of <em>f</em>, that is, the set of all pairs 

<math display="inline" id="Recursively_enumerable_set:9">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,f(x)\rangle
  </annotation>
 </semantics>
</math>

 such that <em>f(x)</em> is defined, is recursively enumerable.</li>
</ul>
<h2 id="properties">Properties</h2>

<p>If <em>A</em> and <em>B</em> are recursively enumerable sets then <em>A</em> ∩ <em>B</em>, <em>A</em> ∪ <em>B</em> and <em>A</em> × <em>B</em> (with the ordered pair of natural numbers mapped to a single natural number with the <a href="Cantor_pairing_function" title="wikilink">Cantor pairing function</a>) are recursively enumerable sets. The <a class="uri" href="preimage" title="wikilink">preimage</a> of a recursively enumerable set under a partial recursive function is a recursively enumerable set.</p>

<p>A set is recursively enumerable if and only if it is at level 

<math display="inline" id="Recursively_enumerable_set:10">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{1}
  </annotation>
 </semantics>
</math>

 of the <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a>.</p>

<p>A set 

<math display="inline" id="Recursively_enumerable_set:11">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is called <strong>co-recursively enumerable</strong> or <strong>co-r.e.</strong> if its <a href="complement_(set_theory)" title="wikilink">complement</a> 

<math display="inline" id="Recursively_enumerable_set:12">
 <semantics>
  <mrow>
   <mi>ℕ</mi>
   <mo>∖</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>ℕ</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}\setminus T
  </annotation>
 </semantics>
</math>

 is recursively enumerable. Equivalently, a set is co-r.e. if and only if it is at level 

<math display="inline" id="Recursively_enumerable_set:13">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

 of the arithmetical hierarchy.</p>

<p>A set <em>A</em> is <a href="recursive_set" title="wikilink">recursive</a> (synonym: computable) if and only if both <em>A</em> and the complement of <em>A</em> are recursively enumerable. A set is recursive if and only if it is either the range of an increasing total recursive function or finite.</p>

<p>Some pairs of recursively enumerable sets are <a href="effectively_separable" title="wikilink">effectively separable</a> and some are not.</p>
<h2 id="remarks">Remarks</h2>

<p>According to the <a href="Church–Turing_thesis" title="wikilink">Church–Turing thesis</a>, any effectively calculable function is calculable by a <a href="Turing_machine" title="wikilink">Turing machine</a>, and thus a set <em>S</em> is recursively enumerable if and only if there is some <a class="uri" href="algorithm" title="wikilink">algorithm</a> which yields an enumeration of <em>S</em>. This cannot be taken as a formal definition, however, because the Church–Turing thesis is an informal conjecture rather than a formal axiom.</p>

<p>The definition of a recursively enumerable set as the <em>domain</em> of a partial function, rather than the <em>range</em> of a total recursive function, is common in contemporary texts. This choice is motivated by the fact that in generalized recursion theories, such as <a href="Alpha_recursion_theory" title="wikilink">α-recursion theory</a>, the definition corresponding to domains has been found to be more natural. Other texts use the definition in terms of enumerations, which is equivalent for recursively enumerable sets.</p>
<h2 id="references">References</h2>
<ul>
<li>Rogers, H. <em>The Theory of Recursive Functions and Effective Computability</em>, <a href="MIT_Press" title="wikilink">MIT Press</a>. ISBN 0-262-68052-1; ISBN 0-07-053522-1.</li>
<li>Soare, R. Recursively enumerable sets and degrees. <em>Perspectives in Mathematical Logic.</em> <a class="uri" href="Springer-Verlag" title="wikilink">Springer-Verlag</a>, Berlin, 1987. ISBN 3-540-15299-7.</li>
<li>Soare, Robert I. Recursively enumerable sets and degrees. <em>Bull. Amer. Math. Soc.</em> 84 (1978), no. 6, 1149–1181.</li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a></p>
</body>
</html>
