   Resolution proof compression by splitting      Resolution proof compression by splitting   In mathematical logic , proof compression by splitting is an algorithm that operates as a post-process on resolution proofs. It was proposed by Scott Cotton in his paper "Two Techniques for Minimizing Resolution Proof". 1  The Splitting algorithm is based on the following observation:  Given a proof of unsatisfiability   π   π   \pi   and a variable   x   x   x   , it is easy to re-arrange (split) the proof in a proof of   x   x   x   and a proof of    ¬   x        x    \neg x\!   and the recombination of these two proofs (by an additional resolution step) may result in a proof smaller than the original.  Note that applying Splitting in a proof   π   π   \pi   using a variable   x   x   x   does not invalidates a latter application of the algorithm using a differente variable   y   y   y   . Actually, the method proposed by Cotton 2 generates a sequence of proofs     π  1    π  2   …       subscript  π  1    subscript  π  2   normal-…    \pi_{1}\pi_{2}\ldots   , where each proof    π   i  +  1      subscript  π    i  1     \pi_{i+1}   is the result of applying Splitting to    π  i     subscript  π  i    \pi_{i}   . During the construction of the sequence, if a proof    π  j     subscript  π  j    \pi_{j}   happens to be too large,    π   j  +  1      subscript  π    j  1     \pi_{j+1}   is setted to be the smallest proof in    {   π  1   ,   π  2   ,  …  ,   π  j   }      subscript  π  1    subscript  π  2   normal-…   subscript  π  j     \{\pi_{1},\pi_{2},\ldots,\pi_{j}\}   .  For achieving a better compression/time ratio, a heuristic for variable selection is desirable. For this purpose, Cotton 3 defines the "additivity" of a resolution step (with antecedents   p   p   p   and   n   n   n   and resolvent   r   r   r   ):       add   (  r  )    :=   max   (    |  r  |   -   max   (   |  p  |   ,   |  n  |   )     ,  0  )       assign   add  r         r       p     n     0     \operatorname{add}(r):=\max(|r|-\max(|p|,|n|),0)\,     Then, for each variable   v   v   v   , a score is calculated summing the additivity of all the resolution steps in   π   π   \pi   with pivot   v   v   v   together with the number of these resolution steps. Denoting each score calculated this way by    a  d  d   (  v  ,  π  )       a  d  d   v  π     add(v,\pi)   , each variable is selected with a probability proportional to its score:       p   (  v  )    =    add   (  v  ,   π  i   )      ∑  x    add   (  x  ,   π  i   )            p  v      add  v   subscript  π  i      subscript   x    add  x   subscript  π  i        p(v)=\frac{\operatorname{add}(v,\pi_{i})}{\sum_{x}{\operatorname{add}(x,\pi_{i%
 })}}     To split a proof of unsatisfiability   π   π   \pi   in a proof    π  x     subscript  π  x    \pi_{x}   of   x   x   x   and a proof    π   ¬  x      subscript  π     x     \pi_{\neg x}   of    ¬  x       x    \neg x   , Cotton 4 proposes the following:  Let   l   l   l   denote a literal and    p   ⊕  x   n      subscript  direct-sum  x   p  n    p\oplus_{x}n   denote the resolvent of clauses   p   p   p   and   n   n   n   where    x  ∈  p      x  p    x\in p   and     ¬  x   ∈  n         x   n    \neg x\in n   . Then, define the map    π  l     subscript  π  l    \pi_{l}   on nodes in the resolution dag of   π   π   \pi   :        π  l    (  c  )    :=   {      c  ,      if  c  is an input          π  l    (  p  )    ,      if  c  =  p   ⊕  x   n  and   (  l  =  x  or  x  ∉   π  l    (  p  )   )           π  l    (  n  )    ,      if  c  =  p   ⊕  x   n  and   (  l  =  ¬  x  or  ¬  x  ∉   π  l    (  n  )   )            π  l    (  p  )     ⊕  x     π  l    (  p  )     ,       if  x   ∈    π  l    (  p  )   and  ¬  x   ∈    π  l    (  n  )            assign     subscript  π  l   c    cases  c    if  c  is an input      subscript  π  l   p    fragments  if  c   p   subscript  direct-sum  x   n  and   fragments  normal-(  l   x  or  x    subscript  π  l    fragments  normal-(  p  normal-)   normal-)       subscript  π  l   n    fragments  if  c   p   subscript  direct-sum  x   n  and   fragments  normal-(  l    x  or   x    subscript  π  l    fragments  normal-(  n  normal-)   normal-)      subscript  direct-sum  x      subscript  π  l   p      subscript  π  l   p          if  x      subscript  π  l   p  and   x           subscript  π  l   n        \pi_{l}(c):=\begin{cases}c,&\text{if }c\text{ is an input}\\
 \pi_{l}(p),&\text{if }c=p\oplus_{x}n\text{ and }(l=x\text{ or }x\notin\pi_{l}(%
 p))\\
 \pi_{l}(n),&\text{if }c=p\oplus_{x}n\text{ and }(l=\neg x\mbox{ or }\neg x%
 \notin\pi_{l}(n))\\
 \pi_{l}(p)\oplus_{x}\pi_{l}(p),&\text{if }x\in\pi_{l}(p)\text{ and }\neg x\in%
 \pi_{l}(n)\end{cases}     Also, let   o   o   o   be the empty clause in   π   π   \pi   . Then,    π  x     subscript  π  x    \pi_{x}   and    π   ¬  x      subscript  π     x     \pi_{\neg x}   are obtained by computing     π  x    (  o  )        subscript  π  x   o    \pi_{x}(o)   and     π   ¬  x     (  o  )        subscript  π     x    o    \pi_{\neg x}(o)   , respectively.  Notes  "  Category:Proof theory     Cotton, Scott. "Two Techniques for Minimizing Resolution Proofs". 13th International Conference on Theory and Applications of Satisfiability Testing, 2010. ↩        