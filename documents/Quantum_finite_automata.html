<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1794">Quantum finite automata</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum finite automata</h1>
<hr/>

<p>In <a href="quantum_computing" title="wikilink">quantum computing</a>, <strong>quantum finite automata</strong> or <strong>QFA</strong> or quantum state machines are a quantum analog of <a href="probabilistic_automata" title="wikilink">probabilistic automata</a> or a <a href="Markov_decision_process" title="wikilink">Markov decision process</a>. They are related to <a href="quantum_computer" title="wikilink">quantum computers</a> in a similar fashion as <a href="finite_automata" title="wikilink">finite automata</a> are related to <a href="Turing_machine" title="wikilink">Turing machines</a>. Several types of automata may be defined, including <em>measure-once</em> and <em>measure-many</em> automata. Quantum finite automata can also be understood as the quantization of <a href="subshifts_of_finite_type" title="wikilink">subshifts of finite type</a>, or as a quantization of <a href="Markov_chain" title="wikilink">Markov chains</a>. QFA's are, in turn, special cases of <strong>geometric finite automata</strong> or <strong>topological finite automata</strong>.</p>

<p>The automata work by accepting a finite-length <a href="string_(computer_science)" title="wikilink">string</a> 

<math display="inline" id="Quantum_finite_automata:0">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>σ</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>σ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>σ</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=(\sigma_{0},\sigma_{1},\cdots,\sigma_{k})
  </annotation>
 </semantics>
</math>

 of letters 

<math display="inline" id="Quantum_finite_automata:1">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

 from a finite <a href="alphabet_(computer_science)" title="wikilink">alphabet</a> 

<math display="inline" id="Quantum_finite_automata:2">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, and assigning to each such string a <a class="uri" href="probability" title="wikilink">probability</a> 

<math display="inline" id="Quantum_finite_automata:3">
 <semantics>
  <mrow>
   <mo>Pr</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Pr</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pr}(\sigma)
  </annotation>
 </semantics>
</math>

 indicating the probability of the automaton being in an <a href="accept_state" title="wikilink">accept state</a>; that is, indicating whether the automaton accepted or rejected the string.</p>

<p>The <a href="formal_language" title="wikilink">languages</a> accepted by QFA's are not the <a href="regular_language" title="wikilink">regular languages</a> of <a href="deterministic_finite_automata" title="wikilink">deterministic finite automata</a>, nor are they the <a href="stochastic_language" title="wikilink">stochastic languages</a> of <a href="probabilistic_finite_automata" title="wikilink">probabilistic finite automata</a>. Study of these <strong>quantum languages</strong> remains an active area of research.</p>
<h2 id="informal-description">Informal description</h2>

<p>There is a simple, intuitive way of understanding quantum finite automata. One begins with a <a href="graph_theory" title="wikilink">graph-theoretic</a> interpretation of <a href="deterministic_finite_automata" title="wikilink">deterministic finite automata</a> (DFA). A DFA can be represented as a directed graph, with states as nodes in the graph, and arrows representing state transitions. Each arrow is labelled with a possible input symbol, so that, given a specific state and an input symbol, the arrow points at the next state. One way of representing such a graph is by means of a set of <a href="adjacency_matrix" title="wikilink">adjacency matrices</a>, with one matrix for each input symbol. In this case, the list of possible DFA states is written as a column vector. For a given input symbol, the adjacency matrix indicates how any given state (row in the state vector) will transition to the next state; a state transition is given by <a href="matrix_multiplication" title="wikilink">matrix multiplication</a>.</p>

<p>One needs a distinct adjacency matrix for each possible input symbol, since each input symbol can result in a different transition. The entries in the adjacency matrix must be zero's and one's. For any given column in the matrix, only one entry can be non-zero: this is the entry that indicates the next (unique) state transition. Similarly, the state of the system is a column vector, in which only one entry is non-zero: this entry corresponds to the current state of the system. Let 

<math display="inline" id="Quantum_finite_automata:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>α</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Σ</ci>
    <set>
     <ci>α</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma=\{\alpha\}
  </annotation>
 </semantics>
</math>

 denote the set of input symbols. For a given input symbol 

<math display="inline" id="Quantum_finite_automata:5">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in\Sigma
  </annotation>
 </semantics>
</math>

, write 

<math display="inline" id="Quantum_finite_automata:6">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\alpha}
  </annotation>
 </semantics>
</math>

 as the adjacency matrix that describes the evolution of the DFA to its next state. The set 

<math display="inline" id="Quantum_finite_automata:7">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>U</mi>
    <mi>α</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>α</mi>
    <mo>∈</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <in></in>
     <ci>α</ci>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{U_{\alpha}|\alpha\in\Sigma\}
  </annotation>
 </semantics>
</math>

 then completely describes the state transition function of the DFA. Let <em>Q</em> represent the set of possible states of the DFA. If there are <em>N</em> states in <em>Q</em>, then each matrix 

<math display="inline" id="Quantum_finite_automata:8">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\alpha}
  </annotation>
 </semantics>
</math>

 is <em>N</em> by <em>N</em>-dimensional. The initial state 

<math display="inline" id="Quantum_finite_automata:9">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{0}\in Q
  </annotation>
 </semantics>
</math>

 corresponds to a column vector with a one in the <em>q</em><sub>0</sub>'th row. A general state <em>q</em> is then a column vector with a one in the <em>q</em>'th row. By <a href="abuse_of_notation" title="wikilink">abuse of notation</a>, let <em>q</em><sub>0</sub> and <em>q</em> also denote these two vectors. Then, after reading input symbols 

<math display="inline" id="Quantum_finite_automata:10">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mi>β</mi>
   <mi>γ</mi>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>β</ci>
    <ci>γ</ci>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\beta\gamma\cdots
  </annotation>
 </semantics>
</math>

 from the input tape, the state of the DFA will be given by 

<math display="inline" id="Quantum_finite_automata:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">⋯</mi>
     <msub>
      <mi>U</mi>
      <mi>γ</mi>
     </msub>
     <msub>
      <mi>U</mi>
      <mi>β</mi>
     </msub>
     <msub>
      <mi>U</mi>
      <mi>α</mi>
     </msub>
     <msub>
      <mi>q</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <apply>
     <times></times>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>γ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>β</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\cdots U_{\gamma}U_{\beta}U_{\alpha}q_{0}.
  </annotation>
 </semantics>
</math>

 The state transitions are given by ordinary <a href="matrix_multiplication" title="wikilink">matrix multiplication</a> (that is, multiply <em>q</em><sub>0</sub> by 

<math display="inline" id="Quantum_finite_automata:12">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\alpha}
  </annotation>
 </semantics>
</math>

, <em>etc.</em>); the order of application is 'reversed' only because we follow the standard application order in linear algebra.</p>

<p>The above description of a DFA, in terms of <a href="linear_operator" title="wikilink">linear operators</a> and vectors, almost begs for generalization, by replacing the state-vector <em>q</em> by some general vector, and the matrices 

<math display="inline" id="Quantum_finite_automata:13">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>U</mi>
    <mi>α</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>α</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{U_{\alpha}\}
  </annotation>
 </semantics>
</math>

 by some general operators. This is essentially what a QFA does: it replaces <em>q</em> by a <a href="probability_amplitude" title="wikilink">probability amplitude</a>, and the 

<math display="inline" id="Quantum_finite_automata:14">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>U</mi>
    <mi>α</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>α</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{U_{\alpha}\}
  </annotation>
 </semantics>
</math>

 by <a href="unitary_matrix" title="wikilink">unitary matrices</a>. Other, similar generalizations also become obvious: the vector <em>q</em> can be some <a href="probability_distribution" title="wikilink">distribution</a> on a <a class="uri" href="manifold" title="wikilink">manifold</a>; the set of transition matrices become <a class="uri" href="automorphisms" title="wikilink">automorphisms</a> of the manifold; this defines a topological finite automaton. Similarly, the matrices could be taken as automorphisms of a <a href="homogeneous_space" title="wikilink">homogeneous space</a>; this defines a geometric finite automaton.</p>

<p>Before moving on to the formal description of a QFA, there are two noteworthy generalizations that should be mentioned and understood. The first is the <a href="non-deterministic_finite_automaton" title="wikilink">non-deterministic finite automaton</a> (NFA). In this case, the vector <em>q</em> is replaced by a vector which can have more than one entry that is non-zero. Such a vector then represents an element of the <a href="power_set" title="wikilink">power set</a> of <em>Q</em>; its just an <a href="indicator_function" title="wikilink">indicator function</a> on <em>Q</em>. Likewise, the state transition matrices 

<math display="inline" id="Quantum_finite_automata:15">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>U</mi>
    <mi>α</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>α</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{U_{\alpha}\}
  </annotation>
 </semantics>
</math>

 are defined in such a way that a given column can have several non-zero entries in it. After each application of 

<math display="inline" id="Quantum_finite_automata:16">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>U</mi>
    <mi>α</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>α</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{U_{\alpha}\}
  </annotation>
 </semantics>
</math>

, though, the column vector <em>q</em> must be renormalized so that it only contains zeros and ones. Equivalently, the multiply-add operations performed during component-wise matrix multiplication should be replaced by Boolean and-or operations, that is, so that one is working with a <a href="ring_(mathematics)" title="wikilink">ring</a> of <a href="characteristic_2" title="wikilink">characteristic 2</a>.</p>

<p>A well-known theorem states that, for each DFA, there is an equivalent NFA, and vice versa. This implies that the set of <a href="formal_language" title="wikilink">languages</a> that can be recognized by DFA's and NFA's are the same; these are the <a href="regular_language" title="wikilink">regular languages</a>. In the generalization to QFA's, the set of recognized languages will be different. Describing that set is one of the outstanding research problems in QFA theory.</p>

<p>Another generalization that should be immediately apparent is to use a <a href="stochastic_matrix" title="wikilink">stochastic matrix</a> for the transition matrices, and a <a href="probability_vector" title="wikilink">probability vector</a> for the state; this gives a <a href="probabilistic_finite_automaton" title="wikilink">probabilistic finite automaton</a>. The entries in the state vector must be real numbers, positive, and sum to one, in order for the state vector to be interpreted as a probability. The transition matrices must preserve this property: this is why they must be stochastic. Each state vector should be imagined as specifying a point in a <a class="uri" href="simplex" title="wikilink">simplex</a>; thus, this is a topological automaton, with the simplex being the manifold, and the stochastic matrices being linear automorphisms of the simplex onto itself. Since each transition is (essentially) independent of the previous (if we disregard the distinction between accepted and rejected languages), the PFA essentially becomes a kind of <a href="Markov_chain" title="wikilink">Markov chain</a>.</p>

<p>By contrast, in a QFA, the manifold is <a href="complex_projective_space" title="wikilink">complex projective space</a> 

<math display="inline" id="Quantum_finite_automata:17">
 <semantics>
  <mrow>
   <mi>ℂ</mi>
   <msup>
    <mi>P</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℂ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}P^{N}
  </annotation>
 </semantics>
</math>

, and the transition matrices are unitary matrices. Each point in 

<math display="inline" id="Quantum_finite_automata:18">
 <semantics>
  <mrow>
   <mi>ℂ</mi>
   <msup>
    <mi>P</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℂ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}P^{N}
  </annotation>
 </semantics>
</math>

 corresponds to a quantum-mechanical <a href="probability_amplitude" title="wikilink">probability amplitude</a> or <a href="pure_state" title="wikilink">pure state</a>; the unitary matrices can be thought of as governing the time evolution of the system (viz in the <a href="Schrödinger_picture" title="wikilink">Schrödinger picture</a>). The generalization from pure states to <a href="mixed_state_(physics)" title="wikilink">mixed states</a> should be straightforward: A mixed state is simply a <a href="measure_theory" title="wikilink">measure-theoretic</a> <a href="probability_distribution" title="wikilink">probability distribution</a> on 

<math display="inline" id="Quantum_finite_automata:19">
 <semantics>
  <mrow>
   <mi>ℂ</mi>
   <msup>
    <mi>P</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℂ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}P^{N}
  </annotation>
 </semantics>
</math>

.</p>

<p>A worthy point to contemplate is the distributions that result on the manifold during the input of a language. In order for an automaton to be 'efficient' in recognizing a language, that distribution should be 'as uniform as possible'. This need for uniformity is the underlying principle behind <a href="maximum_entropy_method" title="wikilink">maximum entropy methods</a>: these simply guarantee crisp, compact operation of the automaton. Put in other words, the <a href="machine_learning" title="wikilink">machine learning</a> methods used to train <a href="hidden_Markov_model" title="wikilink">hidden Markov models</a> generalize to QFA's as well: the <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a> and the <a href="forward-backward_algorithm" title="wikilink">forward-backward algorithm</a> generalize readily to the QFA.</p>
<h2 id="measure-once-automata">Measure-once automata</h2>

<p>Measure-once automata were introduced by <a href="Cris_Moore" title="wikilink">Cris Moore</a> and <a href="James_P._Crutchfield" title="wikilink">James P. Crutchfield</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> They may be defined formally as follows.</p>

<p>As with an ordinary <a href="finite_automaton" title="wikilink">finite automaton</a>, the quantum automaton is considered to have 

<math display="inline" id="Quantum_finite_automata:20">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 possible internal states, represented in this case by an 

<math display="inline" id="Quantum_finite_automata:21">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-state <a class="uri" href="qubit" title="wikilink">qubit</a> 

<math display="inline" id="Quantum_finite_automata:22">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

. More precisely, the 

<math display="inline" id="Quantum_finite_automata:23">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-state qubit 

<math display="inline" id="Quantum_finite_automata:24">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>ℂ</mi>
    <msup>
     <mi>P</mi>
     <mi>N</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ℂ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle\in\mathbb{C}P^{N}
  </annotation>
 </semantics>
</math>

 is an element of 

<math display="inline" id="Quantum_finite_automata:25">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-dimensional <a href="complex_projective_space" title="wikilink">complex projective space</a>, carrying an <a href="inner_product" title="wikilink">inner product</a> 

<math display="inline" id="Quantum_finite_automata:26">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mo>⋅</mo>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">parallel-to</csymbol>
    <ci>normal-⋅</ci>
    <csymbol cd="latexml">parallel-to</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\cdot\|
  </annotation>
 </semantics>
</math>

 that is the <a href="Fubini–Study_metric" title="wikilink">Fubini–Study metric</a>.</p>

<p>The <a href="state_transition" title="wikilink">state transitions</a>, <a href="transition_matrix" title="wikilink">transition matrixes</a> or <a href="de_Bruijn_graph" title="wikilink">de Bruijn graphs</a> are represented by a collection of 

<math display="inline" id="Quantum_finite_automata:27">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times N
  </annotation>
 </semantics>
</math>

 <a href="unitary_matrix" title="wikilink">unitary matrixes</a> 

<math display="inline" id="Quantum_finite_automata:28">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\alpha}
  </annotation>
 </semantics>
</math>

, with one unitary matrix for each letter 

<math display="inline" id="Quantum_finite_automata:29">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in\Sigma
  </annotation>
 </semantics>
</math>

. That is, given an input letter 

<math display="inline" id="Quantum_finite_automata:30">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, the unitary matrix describes the transition of the automaton from its current state 

<math display="inline" id="Quantum_finite_automata:31">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 to its next state 

<math display="inline" id="Quantum_finite_automata:32">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msup>
    <mi>ψ</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ψ</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi^{\prime}\rangle
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Quantum_finite_automata:33">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msup>
     <mi>ψ</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ψ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ψ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi^{\prime}\rangle=U_{\alpha}|\psi\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, the triple 

<math display="inline" id="Quantum_finite_automata:34">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>ℂ</mi>
    <msup>
     <mi>P</mi>
     <mi>N</mi>
    </msup>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>U</mi>
     <mi>α</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>α</mi>
     <mo>∈</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <times></times>
     <ci>ℂ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>normal-Σ</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <in></in>
      <ci>α</ci>
      <ci>normal-Σ</ci>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{C}P^{N},\Sigma,\{U_{\alpha}|\alpha\in\Sigma\})
  </annotation>
 </semantics>
</math>

 form a <a href="quantum_semiautomaton" title="wikilink">quantum semiautomaton</a>.</p>

<p>The <a href="accept_state" title="wikilink">accept state</a> of the automaton is given by an 

<math display="inline" id="Quantum_finite_automata:35">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times N
  </annotation>
 </semantics>
</math>

 <a href="projection_matrix" title="wikilink">projection matrix</a> 

<math display="inline" id="Quantum_finite_automata:36">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, so that, given a 

<math display="inline" id="Quantum_finite_automata:37">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-dimensional quantum state 

<math display="inline" id="Quantum_finite_automata:38">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

, the probability of 

<math display="inline" id="Quantum_finite_automata:39">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 being in the accept state is</p>

<p>

<math display="block" id="Quantum_finite_automata:40">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ψ</mi>
    <mo fence="true" stretchy="false">|</mo>
    <mi>P</mi>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>ψ</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">quantum-operator-product</csymbol>
     <ci>ψ</ci>
     <ci>P</ci>
     <ci>ψ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>ψ</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\psi|P|\psi\rangle=\|P|\psi\rangle\|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>The probability of the state machine accepting a given finite input string 

<math display="inline" id="Quantum_finite_automata:41">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>σ</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>σ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>σ</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=(\sigma_{0},\sigma_{1},\cdots,\sigma_{k})
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Quantum_finite_automata:42">
 <semantics>
  <mrow>
   <mrow>
    <mo>Pr</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>P</mi>
      <msub>
       <mi>U</mi>
       <msub>
        <mi>σ</mi>
        <mi>k</mi>
       </msub>
      </msub>
      <mi mathvariant="normal">⋯</mi>
      <msub>
       <mi>U</mi>
       <msub>
        <mi>σ</mi>
        <mn>1</mn>
       </msub>
      </msub>
      <msub>
       <mi>U</mi>
       <msub>
        <mi>σ</mi>
        <mn>0</mn>
       </msub>
      </msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>ψ</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Pr</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>ψ</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pr}(\sigma)=\|PU_{\sigma_{k}}\cdots U_{\sigma_{1}}U_{\sigma_{0}}%
|\psi\rangle\|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Here, the vector 

<math display="inline" id="Quantum_finite_automata:43">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 is understood to represent the initial state of the automaton, that is, the state the automaton was in before it started accepting the string input. The empty string 

<math display="inline" id="Quantum_finite_automata:44">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varnothing
  </annotation>
 </semantics>
</math>

 is understood to be just the unit matrix, so that</p>

<p>

<math display="block" id="Quantum_finite_automata:45">
 <semantics>
  <mrow>
   <mrow>
    <mo>Pr</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">∅</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>ψ</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Pr</ci>
     <emptyset></emptyset>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>ψ</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pr}(\varnothing)=\|P|\psi\rangle\|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>is just the probability of the initial state being an accepted state.</p>

<p>Because the left-action of 

<math display="inline" id="Quantum_finite_automata:46">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\alpha}
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Quantum_finite_automata:47">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 reverses the order of the letters in the string 

<math display="inline" id="Quantum_finite_automata:48">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, it is not uncommon for QFA's to be defined using a right action on the <a href="Hermitian_transpose" title="wikilink">Hermitian transpose</a> states, simply in order to keep the order of the letters the same.</p>

<p>A <a href="regular_language" title="wikilink">regular language</a> is accepted with probability 

<math display="inline" id="Quantum_finite_automata:49">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 by a quantum finite automaton, if, for all sentences 

<math display="inline" id="Quantum_finite_automata:50">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 in the language, (and a given, fixed initial state 

<math display="inline" id="Quantum_finite_automata:51">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

), one has 

<math display="inline" id="Quantum_finite_automata:52">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo><</mo>
   <mrow>
    <mo>Pr</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>p</ci>
    <apply>
     <ci>Pr</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p<\operatorname{Pr}(\sigma)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="example">Example</h2>

<p>Consider the classical <a href="deterministic_finite_automaton" title="wikilink">deterministic finite automaton</a> given by the <a href="state_transition_table" title="wikilink">state transition table</a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>State Transition Table</strong></p></td>
<td style="text-align: left;">
<p>  Input<br/>
State</p></td>
<td style="text-align: left;">
<p>align="center" <strong>1</strong></p></td>
<td style="text-align: left;">
<p>align="center" <strong>0</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>S<sub>1</sub></p></td>
<td style="text-align: left;">
<p>S<sub>1</sub></p></td>
<td style="text-align: left;">
<p>S<sub>2</sub></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>S<sub>2</sub></p></td>
<td style="text-align: left;">
<p>S<sub>2</sub></p></td>
<td style="text-align: left;">
<p>S<sub>1</sub></p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p><strong>State Diagram</strong><br/>
</p></td>
</tr>
</tbody>
</table>

<p>The quantum state is a vector, in <a href="bra–ket_notation" title="wikilink">bra–ket notation</a></p>

<p>

<math display="block" id="Quantum_finite_automata:53">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ψ</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle=a_{1}|S_{1}\rangle+a_{2}|S_{2}\rangle=\begin{bmatrix}a_{1}\\
a_{2}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>with the <a href="complex_number" title="wikilink">complex numbers</a> 

<math display="inline" id="Quantum_finite_automata:54">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},a_{2}
  </annotation>
 </semantics>
</math>

 normalized so that</p>

<p>

<math display="block" id="Quantum_finite_automata:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mpadded width="+5.6pt">
          <msubsup>
           <mi>a</mi>
           <mn>1</mn>
           <mo>*</mo>
          </msubsup>
         </mpadded>
         <msubsup>
          <mi>a</mi>
          <mn>2</mn>
          <mo>*</mo>
         </msubsup>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>a</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>a</mi>
         <mn>2</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>a</mi>
      <mn>1</mn>
      <mo>*</mo>
     </msubsup>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mi>a</mi>
      <mn>2</mn>
      <mo>*</mo>
     </msubsup>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>a</ci>
           <times></times>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>a</ci>
           <times></times>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">2</cn>
        </apply>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}a^{*}_{1}\;\;a^{*}_{2}\end{bmatrix}\begin{bmatrix}a_{1}\\
a_{2}\end{bmatrix}=a_{1}^{*}a_{1}+a_{2}^{*}a_{2}=1
  </annotation>
 </semantics>
</math>

</p>

<p>The unitary transition matrices are</p>

<p>

<math display="block" id="Quantum_finite_automata:56">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">0</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{0}=\begin{bmatrix}0&1\\
1&0\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Quantum_finite_automata:57">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">1</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{1}=\begin{bmatrix}1&0\\
0&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Taking 

<math display="inline" id="Quantum_finite_automata:58">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 to be the accept state, the projection matrix is</p>

<p>

<math display="block" id="Quantum_finite_automata:59">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\begin{bmatrix}1&0\\
0&0\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>As should be readily apparent, if the initial state is the pure state 

<math display="inline" id="Quantum_finite_automata:60">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>S</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S_{1}\rangle
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Quantum_finite_automata:61">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>S</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S_{2}\rangle
  </annotation>
 </semantics>
</math>

, then the result of running the machine will be exactly identical to the classical deterministic finite state machine. In particular, there is a language accepted by this automaton with probability one, for these initial states, and it is identical to the <a href="regular_language" title="wikilink">regular language</a> for the classical DFA, and is given by the <a href="regular_expression" title="wikilink">regular expression</a>:</p>

<p>

<math display="block" id="Quantum_finite_automata:62">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mn>1</mn>
      <mo>*</mo>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mn>01</mn>
         <mo>*</mo>
        </msup>
        <mn>0</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">1</cn>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">01</cn>
        <times></times>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <times></times>
     </apply>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1^{*}(01^{*}0)^{*})^{*}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>The non-classical behaviour occurs if both 

<math display="inline" id="Quantum_finite_automata:63">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_finite_automata:64">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{2}
  </annotation>
 </semantics>
</math>

 are non-zero. More subtle behaviour occurs when the matrices 

<math display="inline" id="Quantum_finite_automata:65">
 <semantics>
  <msub>
   <mi>U</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_finite_automata:66">
 <semantics>
  <msub>
   <mi>U</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{1}
  </annotation>
 </semantics>
</math>

 are not so simple; see, for example, the <a href="de_Rham_curve" title="wikilink">de Rham curve</a> as an example of a quantum finite state machine acting on the set of all possible finite binary strings.</p>
<h2 id="measure-many-automata">Measure-many automata</h2>

<p>Measure-many automata were introduced by Kondacs and Watrous in 1997.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The general framework resembles that of the measure-once automaton, except that instead of there being one projection, at the end, there is a projection, or <a href="quantum_measurement" title="wikilink">quantum measurement</a>, performed after each letter is read. A formal definition follows.</p>

<p>The <a href="Hilbert_space" title="wikilink">Hilbert space</a> 

<math display="inline" id="Quantum_finite_automata:67">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mi>Q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℋ</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{Q}
  </annotation>
 </semantics>
</math>

 is decomposed into three <a href="orthogonal_subspace" title="wikilink">orthogonal subspaces</a></p>

<p>

<math display="block" id="Quantum_finite_automata:68">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mi>Q</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mtext>accept</mtext>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mtext>reject</mtext>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mtext>non-halting</mtext>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℋ</ci>
     <ci>Q</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℋ</ci>
      <mtext>accept</mtext>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℋ</ci>
      <mtext>reject</mtext>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℋ</ci>
      <mtext>non-halting</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{Q}=\mathcal{H}_{\mbox{accept}}\oplus\mathcal{H}_{\mbox{reject}}%
\oplus\mathcal{H}_{\mbox{non-halting}}
  </annotation>
 </semantics>
</math>

</p>

<p>In the literature, these orthogonal subspaces are usually formulated in terms of the set 

<math display="inline" id="Quantum_finite_automata:69">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 of orthogonal basis vectors for the Hilbert space 

<math display="inline" id="Quantum_finite_automata:70">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mi>Q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℋ</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{Q}
  </annotation>
 </semantics>
</math>

. This set of basis vectors is divided up into subsets 

<math display="inline" id="Quantum_finite_automata:71">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mtext>acc</mtext>
   </msub>
   <mo>⊂</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <mtext>acc</mtext>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{\mbox{acc}}\subset Q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_finite_automata:72">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mtext>rej</mtext>
   </msub>
   <mo>⊂</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <mtext>rej</mtext>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{\mbox{rej}}\subset Q
  </annotation>
 </semantics>
</math>

, such that</p>

<p>

<math display="block" id="Quantum_finite_automata:73">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mtext>accept</mtext>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>span</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>q</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mi>q</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>∈</mo>
       <msub>
        <mi>Q</mi>
        <mtext>acc</mtext>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℋ</ci>
     <mtext>accept</mtext>
    </apply>
    <apply>
     <ci>span</ci>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>q</ci>
      </apply>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>q</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <mtext>acc</mtext>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{\mbox{accept}}=\operatorname{span}\{|q\rangle:|q\rangle\in Q_{%
\mbox{acc}}\}
  </annotation>
 </semantics>
</math>

</p>

<p>is the <a href="linear_span" title="wikilink">linear span</a> of the basis vectors in the accept set. The reject space is defined analogously, and the remaining space is designated the <em>non-halting</em> subspace. There are three projection matrices, 

<math display="inline" id="Quantum_finite_automata:74">
 <semantics>
  <msub>
   <mi>P</mi>
   <mtext>acc</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <mtext>acc</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\mbox{acc}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Quantum_finite_automata:75">
 <semantics>
  <msub>
   <mi>P</mi>
   <mtext>rej</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <mtext>rej</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\mbox{rej}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_finite_automata:76">
 <semantics>
  <msub>
   <mi>P</mi>
   <mtext>non</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <mtext>non</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\mbox{non}}
  </annotation>
 </semantics>
</math>

, each projecting to the respective subspace:</p>

<p>

<math display="block" id="Quantum_finite_automata:77">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mtext>acc</mtext>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mi>Q</mi>
    </msub>
    <mo>→</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mtext>accept</mtext>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <mtext>acc</mtext>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℋ</ci>
      <ci>Q</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℋ</ci>
      <mtext>accept</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\mbox{acc}:\mathcal{H}_{Q}\to\mathcal{H}_{\mbox{accept}}
  </annotation>
 </semantics>
</math>

</p>

<p>and so on. The parsing of the input string proceeds as follows. Consider the automaton to be in a state 

<math display="inline" id="Quantum_finite_automata:78">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

. After reading an input letter 

<math display="inline" id="Quantum_finite_automata:79">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, the automaton will be in the state</p>

<p>

<math display="block" id="Quantum_finite_automata:80">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msup>
     <mi>ψ</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ψ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ψ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi^{\prime}\rangle=U_{\alpha}|\psi\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>At this point, a measurement is performed on the state 

<math display="inline" id="Quantum_finite_automata:81">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msup>
    <mi>ψ</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ψ</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi^{\prime}\rangle
  </annotation>
 </semantics>
</math>

, using the projection operators 

<math display="inline" id="Quantum_finite_automata:82">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, at which time its wave-function collapses into one of the three subspaces 

<math display="inline" id="Quantum_finite_automata:83">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mtext>accept</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℋ</ci>
    <mtext>accept</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{\mbox{accept}}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Quantum_finite_automata:84">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mtext>reject</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℋ</ci>
    <mtext>reject</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{\mbox{reject}}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Quantum_finite_automata:85">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mtext>non-halting</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℋ</ci>
    <mtext>non-halting</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}_{\mbox{non-halting}}
  </annotation>
 </semantics>
</math>

. The probability of collapse is given by</p>

<p>

<math display="block" id="Quantum_finite_automata:86">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>Pr</mo>
     <mtext>acc</mtext>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mtext>acc</mtext>
      </msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msup>
        <mi>ψ</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Pr</ci>
      <mtext>acc</mtext>
     </apply>
     <ci>σ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <mtext>acc</mtext>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ψ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Pr}_{\mbox{acc}}(\sigma)=\|P_{\mbox{acc}}|\psi^{\prime}\rangle\|%
^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>for the "accept" subspace, and analogously for the other two spaces.</p>

<p>If the wave function has collapsed to either the "accept" or "reject" subspaces, then further processing halts. Otherwise, processing continues, with the next letter read from the input, and applied to what must be an eigenstate of 

<math display="inline" id="Quantum_finite_automata:87">
 <semantics>
  <msub>
   <mi>P</mi>
   <mtext>non</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <mtext>non</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\mbox{non}}
  </annotation>
 </semantics>
</math>

. Processing continues until the whole string is read, or the machine halts. Often, additional symbols 

<math display="inline" id="Quantum_finite_automata:88">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 and $ are adjoined to the alphabet, to act as the left and right end-markers for the string.</p>

<p>In the literature, the meaure-many automaton is often denoted by the tuple 

<math display="inline" id="Quantum_finite_automata:89">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>Q</mi>
   <mo>;</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>;</mo>
   <mi>δ</mi>
   <mo>;</mo>
   <msub>
    <mi>q</mi>
    <mn>0</mn>
   </msub>
   <mo>;</mo>
   <msub>
    <mi>Q</mi>
    <mtext>acc</mtext>
   </msub>
   <mo>;</mo>
   <msub>
    <mi>Q</mi>
    <mtext>rej</mtext>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>Q</ci>
    <ci>normal-Σ</ci>
    <ci>δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <mtext>acc</mtext>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <mtext>rej</mtext>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q;\Sigma;\delta;q_{0};Q_{\mbox{acc}};Q_{\mbox{rej}})
  </annotation>
 </semantics>
</math>

. Here, 

<math display="inline" id="Quantum_finite_automata:90">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Quantum_finite_automata:91">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Quantum_finite_automata:92">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mtext>acc</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <mtext>acc</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\mbox{acc}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_finite_automata:93">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mtext>rej</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <mtext>rej</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\mbox{rej}
  </annotation>
 </semantics>
</math>

 are as defined above. The initial state is denoted by 

<math display="inline" id="Quantum_finite_automata:94">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle=|q_{0}\rangle
  </annotation>
 </semantics>
</math>

. The unitary transformations are denoted by the map 

<math display="inline" id="Quantum_finite_automata:95">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Quantum_finite_automata:96">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Σ</mi>
     <mo>×</mo>
     <mi>Q</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℂ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>δ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>normal-Σ</ci>
      <ci>Q</ci>
     </apply>
     <ci>ℂ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta:Q\times\Sigma\times Q\to\mathbb{C}
  </annotation>
 </semantics>
</math>

</p>

<p>so that</p>

<p>

<math display="block" id="Quantum_finite_automata:97">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi>q</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>q</mi>
       <mn>2</mn>
      </msub>
      <mo>∈</mo>
      <mi>Q</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>q</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi>α</mi>
      <mo>,</mo>
      <msub>
       <mi>q</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi>q</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>Q</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <cn type="integer">2</cn>
       </apply>
      </vector>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{\alpha}|q_{1}\rangle=\sum_{q_{2}\in Q}\delta(q_{1},\alpha,q_{2})|q_{2}\rangle
  </annotation>
 </semantics>
</math>

</p>
<h2 id="geometric-generalizations">Geometric generalizations</h2>

<p>The above constructions indicate how the concept of a quantum finite automaton can be generalized to arbitrary <a href="topological_space" title="wikilink">topological spaces</a>. For example, one may take some (<em>N</em>-dimensional) <a href="Riemann_symmetric_space" title="wikilink">Riemann symmetric space</a> to take the place of 

<math display="inline" id="Quantum_finite_automata:98">
 <semantics>
  <mrow>
   <mi>ℂ</mi>
   <msup>
    <mi>P</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℂ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}P^{N}
  </annotation>
 </semantics>
</math>

. In place of the unitary matrices, one uses the <a href="isometry" title="wikilink">isometries</a> of the Riemannian manifold, or, more generally, some set of <a href="open_function" title="wikilink">open functions</a> appropriate for the given topological space. The initial state may be taken to be a point in the space. The set of accept states can be taken to be some arbitrary subset of the topological space. One then says that a <a href="formal_language" title="wikilink">formal language</a> is accepted by this <strong>topological automaton</strong> if the point, after iteration by the homeomorphisms, intersects the accept set. But, of course, this is nothing more than the standard definition of an <a class="uri" href="M-automaton" title="wikilink">M-automaton</a>. The behaviour of topological automata is studied in the field of <a href="topological_dynamics" title="wikilink">topological dynamics</a>.</p>

<p>The quantum automaton differs from the topological automaton in that, instead of having a binary result (is the iterated point in, or not in, the final set?), one has a probability. The quantum probability is the (square of) the initial state projected onto some final state <em>P</em>; that is 

<math display="inline" id="Quantum_finite_automata:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℙ</mi>
    <mi>𝕣</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>P</mi>
      <mo stretchy="false">|</mo>
      <mi>ψ</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℙ</ci>
     <ci>𝕣</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="latexml">inner-product</csymbol>
       <ci>P</ci>
       <ci>ψ</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Pr}=|\langle P|\psi\rangle|^{2}
  </annotation>
 </semantics>
</math>

. But this probability amplitude is just a very simple function of the distance between the point 

<math display="inline" id="Quantum_finite_automata:100">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>P</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |P\rangle
  </annotation>
 </semantics>
</math>

 and the point 

<math display="inline" id="Quantum_finite_automata:101">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Quantum_finite_automata:102">
 <semantics>
  <mrow>
   <mi>ℂ</mi>
   <msup>
    <mi>P</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℂ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}P^{N}
  </annotation>
 </semantics>
</math>

, under the distance <a href="metric_(mathematics)" title="wikilink">metric</a> given by the <a href="Fubini–Study_metric" title="wikilink">Fubini–Study metric</a>. To recap, the quantum probability of a language being accepted can be interpreted as a metric, with the probability of accept being unity, if the metric distance between the initial and final states is zero, and otherwise the probability of accept is less than one, if the metric distance is non-zero. Thus, it follows that the quantum finite automaton is just a special case of a <strong>geometric automaton</strong> or a <strong>metric automaton</strong>, where 

<math display="inline" id="Quantum_finite_automata:103">
 <semantics>
  <mrow>
   <mi>ℂ</mi>
   <msup>
    <mi>P</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℂ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}P^{N}
  </annotation>
 </semantics>
</math>

 is generalized to some <a href="metric_space" title="wikilink">metric space</a>, and the probability measure is replaced by a simple function of the metric on that space.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quantum_Markov_chain" title="wikilink">Quantum Markov chain</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>

<p><em>(Provides an intro to quantum Markov chains.)</em></p></li>
<li>Alex Brodsky, Nicholas Pippenger, <a href="http://xxx.lanl.gov/abs/quant-ph/9903014">"Characterization of 1-way Quantum Finite Automata"</a>, <em>SIAM Journal on Computing</em> <strong>31</strong>(2002) pp 1456–1478.</li>
<li>Vincent D. Blondel, Emmanual Jeandel, Pascal Koiran and Natacha Portier, "Decidable and Undecidable Problems about Quantum Automata", <em>SIAM Journal on Computing</em> <strong>34</strong> (2005) pp 1464–1473.</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_information_theory" title="wikilink">Category:Quantum information theory</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">C. Moore, J. Crutchfield, "Quantum automata and quantum grammars", <em>Theoretical Computer Science</em>, <strong>237</strong> (2000) pp 275-306.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
