   Binary Goppa code      Binary Goppa code   In mathematics and computer science , the binary Goppa code is an error-correcting code that belongs to the class of general Goppa codes originally described by Valerii Denisovich Goppa , but the binary structure gives it several mathematical advantages over non-binary variants, also providing a better fit for common usage in computers and telecommunication. Binary Goppa codes have interesting properties suitable for cryptography in McEliece-like cryptosystems and similar setups.  Construction and properties  A binary Goppa code is defined by a polynomial     g   (  x  )       g  x    g(x)   of degree   t   t   t   over a finite field     G  F   (   2  m   )       G  F   superscript  2  m     GF(2^{m})   without multiple zeros, and a sequence   L   L   L   of   n   n   n   distinct elements from    G  F   (   2  m   )       G  F   superscript  2  m     GF(2^{m})   that aren't roots of the polynomial:         ∀  i   ,  j   ∈   {  0  ,  …  ,   n  -  1   }    :    L  i   ∈   G  F   (   2  m   )   and   L  i    ≠    L  j   and  g   (   L  i   )    ≠  0      normal-:      for-all  i   j    0  normal-…    n  1          subscript  L  i     G  F   superscript  2  m   italic- and   subscript  L  i            subscript  L  j   italic- and  g   subscript  L  i         0      \forall i,j\in\{0,\ldots,n-1\}:L_{i}\in GF(2^{m})\and L_{i}\neq L_{j}\and g(L_%
 {i})\neq 0     Codewords belong to the kernel of syndrome function, forming a subspace of     {  0  ,  1  }   n     superscript   0  1   n    \{0,1\}^{n}   :       Γ   (  g  ,  L  )    =   {   c  ∈    {  0  ,  1  }   n    |     ∑   i  =  0    n  -  1      c  i    x  -   L  i      ≡   0  mod   g   (  x  )      }         normal-Γ   g  L     conditional-set    c   superscript   0  1   n        superscript   subscript     i  0      n  1       subscript  c  i     x   subscript  L  i       modulo  0    g  x        \Gamma(g,L)=\left\{c\in\{0,1\}^{n}|\sum_{i=0}^{n-1}\frac{c_{i}}{x-L_{i}}\equiv
 0%
 \mod g(x)\right\}     Code defined by a tuple    (  g  ,  L  )     g  L    (g,L)   has minimum distance     2  t   +  1        2  t   1    2t+1   , thus it can correct    t  =   ⌊     (    2  t   +  1   )   -  1   2   ⌋       t            2  t   1   1   2      t=\left\lfloor\frac{(2t+1)-1}{2}\right\rfloor   errors in a word of size    n  -   m  t       n    m  t     n-mt   using codewords of size   n   n   n   . It also possesses a convenient parity-check matrix    H   H   H   in form      H  =   V  D   =    (     1    1    1    ⋯    1       L  0  1      L  1  1      L  2  1     ⋯     L   n  -  1   1        L  0  2      L  1  2      L  2  2     ⋯     L   n  -  1   2       ⋮    ⋮    ⋮    ⋱    ⋮       L  0  t      L  1  t      L  2  t     ⋯     L   n  -  1   t      )    (       1   g   (   L  0   )                           1   g   (   L  1   )                           1   g   (   L  2   )                         ⋱                       1   g   (   L   n  -  1    )         )          H    V  D            1  1  1  normal-⋯  1     superscript   subscript  L  0   1    superscript   subscript  L  1   1    superscript   subscript  L  2   1   normal-⋯   superscript   subscript  L    n  1    1      superscript   subscript  L  0   2    superscript   subscript  L  1   2    superscript   subscript  L  2   2   normal-⋯   superscript   subscript  L    n  1    2     normal-⋮  normal-⋮  normal-⋮  normal-⋱  normal-⋮     superscript   subscript  L  0   t    superscript   subscript  L  1   t    superscript   subscript  L  2   t   normal-⋯   superscript   subscript  L    n  1    t         1    g   subscript  L  0     absent  absent  absent  absent    absent    1    g   subscript  L  1     absent  absent  absent    absent  absent    1    g   subscript  L  2     absent  absent    absent  absent  absent  normal-⋱  absent    absent  absent  absent  absent    1    g   subscript  L    n  1            H=VD=\begin{pmatrix}1&1&1&\cdots&1\\
 L_{0}^{1}&L_{1}^{1}&L_{2}^{1}&\cdots&L_{n-1}^{1}\\
 L_{0}^{2}&L_{1}^{2}&L_{2}^{2}&\cdots&L_{n-1}^{2}\\
 \vdots&\vdots&\vdots&\ddots&\vdots\\
 L_{0}^{t}&L_{1}^{t}&L_{2}^{t}&\cdots&L_{n-1}^{t}\end{pmatrix}\begin{pmatrix}%
 \frac{1}{g(L_{0})}&&&&\\
 &\frac{1}{g(L_{1})}&&&\\
 &&\frac{1}{g(L_{2})}&&\\
 &&&\ddots&\\
 &&&&\frac{1}{g(L_{n-1})}\end{pmatrix}     Note that this form of the parity-check matrix, being composed of a Vandermonde matrix    V   V   V   and diagonal matrix    D   D   D   , shares the form with check matrices of alternant codes , thus alternant decoders can be used on this form. Such decoders usually provide only limited error-correcting capability (in most cases    t  /  2      t  2    t/2   ).  For practical purposes, parity-check matrix of a binary Goppa code is usually converted to a more computer-friendly binary form by a trace construction, that converts the   t   t   t   -by-   n   n   n   matrix over    G  F   (   2  m   )       G  F   superscript  2  m     GF(2^{m})   to a    m  t      m  t    mt   -by-   n   n   n   binary matrix by writing polynomial cofficients of    G  F   (   2  m   )       G  F   superscript  2  m     GF(2^{m})   elements on   m   m   m   successive rows.  Decoding  Decoding of binary Goppa codes is traditionally done by Patterson algorithm, which gives good error-correcting capability (it corrects all   t   t   t   design errors), and is also fairly simple to implement.  Patterson algorithm converts a syndrome to a vector of errors. The syndrome of a word    c  =   (   c  0   ,  …  ,   c   n  -  1    )       c    subscript  c  0   normal-…   subscript  c    n  1       c=(c_{0},\dots,c_{n-1})   is expected to take a form of       s   (  x  )    ≡     ∑    c  i   =  1     1   x  -   L  i      mod   g   (  x  )           s  x    modulo    subscript      subscript  c  i   1      1    x   subscript  L  i        g  x      s(x)\equiv\sum_{c_{i}=1}\frac{1}{x-L_{i}}\mod g(x)     Alternative form of a parity-check matrix based on formula for    s   (  x  )       s  x    s(x)   can be used to produce such syndrome with a simple matrix multiplication.  The algorithm then computes     v   (  x  )    ≡      s    (  x  )    -  1     -  x    mod   g   (  x  )           v  x    modulo        s   superscript  x    1     x      g  x      v(x)\equiv\sqrt{s(x)^{-1}-x}\mod g(x)   . That fails when     s   (  x  )    ≡  0        s  x   0    s(x)\equiv 0   , but that is the case when the input word is a codeword, so no error correction is necessary.      v   (  x  )       v  x    v(x)   is reduced to polynomials    a   (  x  )       a  x    a(x)   and    b   (  x  )       b  x    b(x)   using the extended euclidean algorithm , so that     a   (  x  )    ≡      b   (  x  )    ⋅  v    (  x  )    mod   g   (  x  )           a  x    modulo     normal-⋅    b  x   v   x     g  x      a(x)\equiv b(x)\cdot v(x)\mod g(x)   , while     deg   (  a  )    ≤   ⌊   t  /  2   ⌋        degree  a       t  2      \deg(a)\leq\lfloor t/2\rfloor   and     deg   (  b  )    ≤   ⌊    (   t  -  1   )   /  2   ⌋        degree  b         t  1   2      \deg(b)\leq\lfloor(t-1)/2\rfloor   .  Finally, the error locator polynomial is computed as     σ   (  x  )    =    a    (  x  )   2    +    x  ⋅  b     (  x  )   2           σ  x       a   superscript  x  2       normal-⋅  x  b    superscript  x  2       \sigma(x)=a(x)^{2}+x\cdot b(x)^{2}   . Note that in binary case, locating the errors is sufficient to correct them, as there's only one other value possible. Note that in all non-binary cases, separate error correction polynomial has to be computed as well.  If the original codeword was decodable and the    e  =   (   e  0   ,   e  1   ,  …  ,   e   n  -  1    )       e    subscript  e  0    subscript  e  1   normal-…   subscript  e    n  1       e=(e_{0},e_{1},\dots,e_{n-1})   was the error vector, then       σ   (  x  )    =    ∏    e  i   =  1     (   x  -   L  i    )          σ  x     subscript  product     subscript  e  i   1      x   subscript  L  i       \sigma(x)=\prod_{e_{i}=1}(x-L_{i})     Factoring or evaluating all roots of    σ   (  x  )       σ  x    \sigma(x)   therefore gives enough information to recover the error vector and fix the errors.  Properties and usage  Binary Goppa codes viewed as a special case of Goppa codes have the interesting property that they correct full    deg   (  g  )      degree  g    \deg(g)   errors, while only     deg   (  g  )    /  2       degree  g   2    \deg(g)/2   errors in ternary and all other cases. Asymptotically, this error correcting capability meets the famous Gilbert–Varshamov bound .  Because of the high error correction capacity compared to code rate and form of parity-check matrix (which is usually hardly distinguishable from a random binary matrix of full rank), the binary Goppa codes are used in several post-quantum  cryptosystems , notably McEliece cryptosystem and Niederreiter cryptosystem .  References   Elwyn R. Berlekamp, Goppa Codes, IEEE Transactions on information theory, Vol. IT-19, No. 5, September 1973, http://infosec.seu.edu.cn/space/kangwei/senior_thesis/Goppa.pdf  Daniela Engelbert, Raphael Overbeck, Arthur Schmidt. "A summary of McEliece-type cryptosystems and their security." Journal of Mathematical Cryptology 1, 151–199. MR 2008h:94056. Previous version: http://eprint.iacr.org/2006/162/  Daniel J. Bernstein. "List decoding for binary Goppa codes." http://cr.yp.to/codes/goppalist-20110303.pdf   See also   BCH codes  Code rate  Reed–Solomon error correction   "  Category:Coding theory   