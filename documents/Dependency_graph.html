<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1977">Dependency graph</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dependency graph</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <a href="computer_science" title="wikilink">computer science</a> and <a href="digital_electronics" title="wikilink">digital electronics</a>, a <strong>dependency graph</strong> is a <a href="directed_graph" title="wikilink">directed graph</a> representing dependencies of several objects towards each other. It is possible to derive an evaluation order or the absence of an evaluation order that respects the given dependencies from the dependency graph.</p>
<h2 id="definition">Definition</h2>

<p> Given a set of objects S and a <a href="transitive_relation" title="wikilink">transitive relation</a> 

<math display="inline" id="Dependency_graph:0">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>S</mi>
    <mo>×</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\subseteq S\times S
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Dependency_graph:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)\in R
  </annotation>
 </semantics>
</math>

 modeling a dependency "a needs b evaluated first", the dependency graph is a graph 

<math display="inline" id="Dependency_graph:2">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>T</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(S,T)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Dependency_graph:3">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>⊆</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>T</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\subseteq R
  </annotation>
 </semantics>
</math>

 and R being the <a href="transitive_closure" title="wikilink">transitive closure</a> of T.</p>

<p>For example, assume a simple calculator. This calculator supports assignment of constant values to variables and assigning the sum of exactly 2 variables to a third variable. Given several equations like "<em>A</em> = <em>B</em>+<em>C</em>; <em>B</em> = 5+<em>D</em>; <em>C</em>=4; <em>D</em>=2;", then 

<math display="inline" id="Dependency_graph:4">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>C</mi>
    <mo>,</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <list>
     <ci>A</ci>
     <ci>B</ci>
     <ci>C</ci>
     <ci>D</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S={A,B,C,D}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependency_graph:5">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <list>
     <interval closure="open">
      <ci>A</ci>
      <ci>B</ci>
     </interval>
     <interval closure="open">
      <ci>A</ci>
      <ci>C</ci>
     </interval>
     <interval closure="open">
      <ci>B</ci>
      <ci>D</ci>
     </interval>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R={(A,B),(A,C),(B,D)}
  </annotation>
 </semantics>
</math>

. You can derive this relation directly: <em>A</em> depends on <em>B</em> and <em>C</em>, because you can add two variables <a href="if_and_only_if" title="wikilink">if and only if</a> you know the values of both variables. Thus, <em>B</em> and <em>C</em> must be calculated before <em>A</em> can be calculated. However, <em>D</em>'s value is known immediately, because it is a number literal.</p>
<h2 id="recognizing-impossible-evaluations">Recognizing impossible evaluations</h2>

<p>In a dependency graph, the cycles of dependencies (also called <strong>circular dependencies</strong>) lead to a situation in which no valid evaluation order exists, because none of the objects in the cycle may be evaluated first. If a dependency graph does not have any circular dependencies, it forms a <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a>, and an evaluation order may be found by <a href="topological_sorting" title="wikilink">topological sorting</a>. Most topological sorting algorithms are also capable of detecting cycles in their inputs, however, it may be desirable to perform <a href="cycle_detection_(graph_theory)" title="wikilink">cycle detection</a> separately from topological sorting in order to provide appropriate handling for the detected cycles.</p>

<p>Assume the simple calculator from before. The equation system "A=B; B=D+C; C=D+A; D=12;" contains a <a href="circular_dependency" title="wikilink">circular dependency</a> formed by A, B and C, as B must be evaluated before A, C must be evaluated before B and A must be evaluated before C.</p>
<h2 id="deriving-an-evaluation-order">Deriving an evaluation order</h2>

<p>A <strong>correct evaluation order</strong> is a numbering 

<math display="inline" id="Dependency_graph:6">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>n</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n:S\rightarrow\mathbb{N}
  </annotation>
 </semantics>
</math>

 of the objects that form the nodes of the dependency graph so that the following equation holds

<math display="block" id="Dependency_graph:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∉</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <notin></notin>
     <share href="#.cmml">
     </share>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(a)<n(b)\Rightarrow(a,b)\notin R
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Dependency_graph:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>a</ci>
     <ci>b</ci>
    </list>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b\in S
  </annotation>
 </semantics>
</math>

. This means, if the numbering orders two elements a and b so that a will be evaluated before b, then a must not depend on b. Furthermore, there can be more than a single correct evaluation order. In fact, a correct numbering is a <a href="Topological_sorting" title="wikilink">topological order</a>, and any topological order is a correct numbering. Thus, any algorithm that derives a correct topological order derives a correct evaluation order.</p>

<p>Assume the simple calculator from above once more. Given the equation system "A = B+C; B = 5+D; C=4; D=2;", a correct evaluation order would be (D, C, B, A). However, (C, D, B, A) is a correct evaluation order as well.</p>
<h2 id="examples">Examples</h2>

<p>Dependency graphs are used in:</p>
<ul>
<li>Automated software <a href="installer" title="wikilink">installers</a>. They walk the graph looking for <a href="Software_package_(installation)" title="wikilink">software packages</a> that are required but not yet installed. The dependency is given by the <a href="coupling_(computer_science)" title="wikilink">coupling</a> of the packages.</li>
<li>Software build scripts such as <a class="uri" href="Unix" title="wikilink">Unix</a> <a href="Make_(software)" title="wikilink">Make</a>, <a href="Node.js" title="wikilink">Node</a> npm install, <a class="uri" href="Twitter" title="wikilink">Twitter</a> bower install, or <a href="Apache_Ant" title="wikilink">Apache Ant</a>. They need to know what files have changed so only the correct files need to be recompiled.</li>
<li>In <a class="uri" href="Compiler" title="wikilink">Compiler</a> technology and <a href="formal_language" title="wikilink">formal language</a> implementation:
<ul>
<li><a href="Instruction_scheduling" title="wikilink">Instruction Scheduling</a>. Dependency graphs are computed for the operands of assembly or intermediate instructions and used to determine an optimal order for the instructions.</li>
<li><a href="Dead_code_elimination" title="wikilink">Dead code elimination</a>. If no side effected operation depends on a variable, this variable is considered dead and can be removed.</li>
</ul></li>
<li>Spreadsheet calculators. They need to derive a correct calculation order similar to that one in the example used in this article.</li>
<li>Web Forms standards such as <a class="uri" href="XForms" title="wikilink">XForms</a> to know what visual elements to update if data in the model changes.</li>
</ul>

<p>Dependency graphs are one aspect of:</p>
<ul>
<li><a href="Theory_of_Constraints#Plant_types" title="wikilink">Manufacturing Plant Types</a>. Raw materials are processed into products via several dependent stages.</li>
<li><a href="Job_Shop_Scheduling" title="wikilink">Job Shop Scheduling</a>. A collection of related theoretical problems in computer science.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Call_graph" title="wikilink">Call graph</a></li>
<li><a href="Topological_sort" title="wikilink">Topological sort</a></li>
<li><a href="Data_dependency" title="wikilink">Data dependency</a></li>
<li><a href="Incremental_computing" title="wikilink">Incremental computing</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Balmas, Francoise (2001) <em><a href="http://www.ai.univ-paris8.fr/~fb/version-ps/pdep.ps">Displaying dependence graphs: a hierarchical approach</a>,</em> <a href="http://doi.ieeecomputersociety.org/10.1109/WCRE.2001.957830">1</a> wcre, p. 261, Eighth Working Conference on Reverse Engineering (WCRE'01)</li>
</ul>

<p>"</p>

<p><a href="Category:Incremental_computing" title="wikilink">Category:Incremental computing</a> <a href="Category:Directed_graphs" title="wikilink">Category:Directed graphs</a> <a href="Category:Application-specific_graphs" title="wikilink">Category:Application-specific graphs</a></p>
</body>
</html>
