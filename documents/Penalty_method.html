<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1519">Penalty method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Penalty method</h1>
<hr/>

<p><strong>Penalty methods</strong> are a certain class of <a href="algorithm" title="wikilink">algorithms</a> for solving <a href="Constraint_(mathematics)" title="wikilink">constrained</a> <a href="optimization_(mathematics)" title="wikilink">optimization</a> problems.</p>

<p>A penalty method replaces a constrained optimization problem by a series of unconstrained problems whose solutions ideally converge to the solution of the original constrained problem. The unconstrained problems are formed by adding a term, called a <strong>penalty function</strong>, to the <a href="objective_function" title="wikilink">objective function</a> that consists of a <em>penalty parameter</em> multiplied by a measure of violation of the constraints. The measure of violation is nonzero when the constraints are violated and is zero in the region where constraints are not violated.</p>
<h2 id="example">Example</h2>

<p>Let us say we are solving the following constrained problem:</p>

<p>

<math display="block" id="Penalty_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mi>f</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ùï©</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <min></min>
     <ci>f</ci>
    </apply>
    <ci>ùï©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min f(\mathbb{x})
  </annotation>
 </semantics>
</math>

 subject to</p>

<p>

<math display="block" id="Penalty_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùï©</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚â•</mo>
    <mrow>
     <mpadded width="+3.3pt">
      <mn>0</mn>
     </mpadded>
     <mrow>
      <mo>‚àÄ</mo>
      <mi>i</mi>
     </mrow>
    </mrow>
    <mo>‚àà</mo>
    <mi>I</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <ci>ùï©</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}(\mathbb{x})\geq 0~{}\forall i\in I.
  </annotation>
 </semantics>
</math>

</p>

<p>This problem can be solved as a series of unconstrained minimization problems</p>

<p>

<math display="block" id="Penalty_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>min</mi>
     <msub>
      <mi mathvariant="normal">Œ¶</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùï©</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùï©</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+3.3pt">
      <msub>
       <mi>œÉ</mi>
       <mi>k</mi>
      </msub>
     </mpadded>
     <mrow>
      <mpadded width="+3.3pt">
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
        <mrow>
         <mi>i</mi>
         <mo>‚àà</mo>
         <mi>I</mi>
        </mrow>
       </munder>
      </mpadded>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>c</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ùï©</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <min></min>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ¶</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>ùï©</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>ùï©</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œÉ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>i</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>g</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>i</ci>
         </apply>
         <ci>ùï©</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\Phi_{k}(\mathbb{x})=f(\mathbb{x})+\sigma_{k}~{}\sum_{i\in I}~{}g(c_{i}(%
\mathbb{x}))
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Penalty_method:3">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùï©</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>min</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo rspace="5.8pt">,</mo>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùï©</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <min></min>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">0</cn>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(c_{i}(\mathbb{x}))=\min(0,~{}c_{i}(\mathbb{x}))^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>In the above equations, 

<math display="inline" id="Penalty_method:4">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùï©</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>ùï©</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(c_{i}(\mathbb{x}))
  </annotation>
 </semantics>
</math>

 is the <em>penalty function</em> while 

<math display="inline" id="Penalty_method:5">
 <semantics>
  <msub>
   <mi>œÉ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œÉ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{k}
  </annotation>
 </semantics>
</math>

 are the <em>penalty coefficients</em>. In each iteration <em>k</em> of the method, we increase the penalty coefficient 

<math display="inline" id="Penalty_method:6">
 <semantics>
  <msub>
   <mi>œÉ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>œÉ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{k}
  </annotation>
 </semantics>
</math>

 (e.g. by a factor of 10), solve the unconstrained problem and use the solution as the initial guess for the next iteration. Solutions of the successive unconstrained problems will eventually converge to the solution of the original constrained problem.</p>
<h2 id="practical-application">Practical application</h2>

<p><a href="Image_compression" title="wikilink">Image compression</a> optimization algorithms can make use of penalty functions for selecting how best to compress zones of colour to single representative values.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="barrier-methods">Barrier methods</h2>

<p><a href="Barrier_method_(mathematics)" title="wikilink">Barrier methods</a> constitute an alternative class of algorithms for constrained optimization. These methods also add a penalty-like term to the objective function, but in this case the iterates are forced to remain interior to the feasible domain and the barrier is in place to bias the iterates to remain away from the boundary of the feasible region.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Barrier_function" title="wikilink">Barrier function</a></li>
<li><a href="Interior_point_method" title="wikilink">Interior point method</a></li>
<li><a href="Augmented_Lagrangian_method" title="wikilink">Augmented Lagrangian method</a></li>
</ul>
<h2 id="references">References</h2>

<p>Smith, Alice E.; Coit David W. <a href="http://140.138.143.31/teachers/ycliang/heuristic%20optimization%20912/penalty%20function.pdf">Penalty functions</a> Handbook of Evolutionary Computation, Section C 5.2. Oxford University Press and Institute of Physics Publishing, 1996.</p>

<p>Courant, R. <a href="http://www.ams.org/bull/1943-49-01/S0002-9904-1943-07818-4/S0002-9904-1943-07818-4.pdf">Variational methods for the solution of problems of equilibrium and vibrations</a>. Bull. Amer. Math. Soc., 49, 1‚Äì23, 1943.</p>

<p>"</p>

<p><a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
