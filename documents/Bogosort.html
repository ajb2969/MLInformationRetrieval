<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="215">Bogosort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bogosort</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>bogosort</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> (also <strong>stupid sort</strong>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <strong>slowsort</strong>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <strong>random sort</strong>, <strong>shotgun sort</strong> or <strong>monkey sort</strong>) is a particularly ineffective <a href="sorting_algorithm" title="wikilink">sorting algorithm</a> based on the <a href="Trial_and_error" title="wikilink">generate and test</a> paradigm. It is not useful for sorting, but may be used for educational purposes, to contrast it with other more realistic algorithms; it has also been used as an example in <a href="logic_programming" title="wikilink">logic programming</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> If bogosort were used to sort a <a href="deck_of_cards" title="wikilink">deck of cards</a>, it would consist of checking if the deck were in order, and if it were not, throwing the deck into the air, picking the cards up at random, and repeating the process until the deck is sorted. Its name comes from the word <em>bogus</em>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="description-of-the-algorithm">Description of the algorithm</h2>

<p>The following is a description of the algorithm in <a class="uri" href="pseudocode" title="wikilink">pseudocode</a>:</p>

<p><strong><code>while</code> <code>not</code></strong><code> isInOrder(deck):</code><br/>
<code>    shuffle(deck)</code></p>
<h2 id="running-time-and-termination">Running time and termination</h2>

<p>This <a href="sorting_algorithm" title="wikilink">sorting algorithm</a> is probabilistic in nature. If all elements to be sorted are distinct, the expected number of comparisons in the average case is <a href="Asymptotic_analysis" title="wikilink">asymptotically equivalent to</a> 

<math display="inline" id="Bogosort:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>e</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <factorial></factorial>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (e-1)n!
  </annotation>
 </semantics>
</math>

, and the expected number of swaps in the average case equals 

<math display="inline" id="Bogosort:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <factorial></factorial>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)n!
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The expected number of swaps grows faster than the expected number of comparisons, because if the elements are not in order, this will usually be discovered after only a few comparisons no matter how many elements there are, but the work of shuffling the collection is proportional to its size. In the worst case, the number of comparisons and swaps are both unbounded, for the same reason that a tossed coin might turn up heads any number of times in a row.</p>

<p>The best case occurs if the list as given is already sorted; in this case the expected number of comparisons is 

<math display="inline" id="Bogosort:2">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

, and no swaps at all are carried out.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>For any collection of fixed size, the expected running time of the algorithm is finite for much the same reason that the <a href="infinite_monkey_theorem" title="wikilink">infinite monkey theorem</a> holds: there is some probability of getting the right permutation, so given an unbounded number of tries it will <a href="almost_surely" title="wikilink">almost surely</a> eventually be chosen.</p>
<h2 id="related-algorithms">Related algorithms</h2>
<dl>
<dt>Gorosort: is a sorting algorithm introduced in the 2011 <a href="Google_Code_Jam" title="wikilink">Google Code Jam</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> As long as the list is not in order, a subset of all elements is randomly permuted. If this subset is optimally chosen each time this is performed, the <a href="expected_value" title="wikilink">expected value</a> of the total number of times this operation needs to be done is equal to the number of misplaced elements.<br/>
Bogobogosort: is an algorithm that was designed not to succeed before the <a href="heat_death_of_the_universe" title="wikilink">heat death of the universe</a> on any sizable list. It works by recursively calling itself with smaller and smaller copies of the beginning of the list to see if they are sorted. The base case is a single element, which is always sorted. For other cases, it compares the last element to the maximum element from the previous elements in the list. If the last element is greater or equal, it checks if the order of the copy matches the previous version, copies back if not, and returns. Otherwise, it reshuffles the current copy of the list and goes back to its recursive check.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></dt>
</dl>
<dl>
<dt>Bozosort: is another sorting algorithm based on random numbers. If the list is not in order, it picks two items at random and swaps them, then checks to see if the list is sorted. The running time analysis of a bozosort is more difficult, but some estimates are found in H. Gruber's analysis of "perversely awful" randomized sorting algorithms.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> O(n!) is found to be the expected average case.</dt>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Las_Vegas_algorithm" title="wikilink">Las Vegas algorithm</a></li>
<li><a href="Stooge_sort" title="wikilink">Stooge sort</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="c2:BogoSort" title="wikilink">BogoSort</a> on <a class="uri" href="WikiWikiWeb" title="wikilink">WikiWikiWeb</a></li>
<li><a href="http://richardhartersworld.com/cri_d/cri/2001/badsort.html">Inefficient sort algorithms</a></li>
<li><a href="http://www.lysator.liu.se/~qha/bogosort/">Bogosort</a>: an implementation that runs on <a class="uri" href="Unix-like" title="wikilink">Unix-like</a> systems, similar to the standard <a href="sort_(Unix)" title="wikilink">sort</a> program.</li>
<li><a href="http://github.com/versesane/algorithms-and-data-structures-in-c/tree/master/bogosort.c">Bogosort</a> and <a href="http://libjmmcg.cvs.sourceforge.net/viewvc/libjmmcg/libjmmcg/core/bogo_sort.hpp">jmmcg::bogosort</a>: Simple, yet perverse, C++ implementations of the bogosort algorithm.</li>
</ul>

<p>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a> <a href="Category:Comparison_sorts" title="wikilink">Category:Comparison sorts</a> <a href="Category:Computer_humor" title="wikilink">Category:Computer humor</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">E. S. Raymond. "bogo-sort". <em>The New Hacker’s Dictionary</em>. MIT Press, 1996.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="http://code.google.com/codejam/contest/dashboard?c=975485#s=p3">Google Code Jam 2011, Qualification Rounds, Problem D</a><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://www.dangermouse.net/esoteric/bogobogosort.html">Bogobogosort</a><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
</ol>
</section>
</body>
</html>
