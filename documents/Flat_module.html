<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1259">Flat module</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Flat module</h1>
<hr/>

<p>In <a href="homological_algebra" title="wikilink">homological algebra</a> and <a href="algebraic_geometry" title="wikilink">algebraic geometry</a>, a <strong>flat module</strong> over a <a href="ring_(mathematics)" title="wikilink">ring</a> <em>R</em> is an <em>R</em>-<a href="module_(mathematics)" title="wikilink">module</a> <em>M</em> such that taking the <a href="tensor_product" title="wikilink">tensor product</a> over <em>R</em> with <em>M</em> preserves <a href="exact_sequence" title="wikilink">exact sequences</a>. A module is <strong>faithfully flat</strong> if taking the tensor product with a sequence produces an exact sequence if and only if the original sequence is exact.</p>

<p><a href="Vector_space" title="wikilink">Vector spaces</a> over a <a href="field_(mathematics)" title="wikilink">field</a> are flat modules. <a href="Free_module" title="wikilink">Free modules</a>, or more generally <a href="projective_module" title="wikilink">projective modules</a>, are also flat, over any <em>R</em>. For <a href="finitely_generated_module" title="wikilink">finitely generated modules</a> over a <a href="Noetherian_ring" title="wikilink">Noetherian ring</a>, flatness and projectivity are equivalent. For finitely generated modules over <a href="local_ring" title="wikilink">local rings</a>, flatness, projectivity and freeness are all equivalent.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The <a href="field_of_quotients" title="wikilink">field of quotients</a> of an <a href="integral_domain" title="wikilink">integral domain</a>, and, more generally, any <a href="localization_of_a_ring" title="wikilink">localization</a> of a <a href="commutative_ring" title="wikilink">commutative ring</a> are flat modules. The product of the <a href="local_ring" title="wikilink">local rings</a> of a commutative ring is a faithfully flat module.</p>

<p>Flatness was introduced by  in his paper <em><a href="Géometrie_Algébrique_et_Géométrie_Analytique" title="wikilink">Géometrie Algébrique et Géométrie Analytique</a></em>. See also <a href="flat_morphism" title="wikilink">flat morphism</a>.</p>
<h2 id="definition">Definition</h2>
<h3 id="commutative-rings">Commutative rings</h3>

<p>Let <em>M</em> be an <em>R</em>-module. The following conditions are all equivalent, so <em>M</em> is flat if it satisfies any (thus all) of them:</p>
<ul>
<li>The functor</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Flat_module:0">
<semantics>
<mrow>
<msub>
<mi>F</mi>
<mi>M</mi>
</msub>
<mo>:</mo>
<mrow>
<mrow>
<mrow>
<mi>M</mi>
<mi>o</mi>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>R</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mrow>
<mi>M</mi>
<mi>o</mi>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>R</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo rspace="12.5pt">,</mo>
<mrow>
<mi>N</mi>
<mo>↦</mo>
<mrow>
<mi>M</mi>
<msub>
<mo>⊗</mo>
<mi>R</mi>
</msub>
<mi>N</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>F</ci>
<ci>M</ci>
</apply>
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>M</ci>
<ci>o</ci>
<ci>d</ci>
<ci>R</ci>
</apply>
<apply>
<times></times>
<ci>M</ci>
<ci>o</ci>
<ci>d</ci>
<ci>R</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">maps-to</csymbol>
<ci>N</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">tensor-product</csymbol>
<ci>R</ci>
</apply>
<ci>M</ci>
<ci>N</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   F_{M}:Mod(R)\to Mod(R),\quad N\mapsto M\otimes_{R}N
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
<dd>is exact, where 

<math display="inline" id="Flat_module:1">
<semantics>
<mrow>
<mi>M</mi>
<mi>o</mi>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>R</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>M</ci>
<ci>o</ci>
<ci>d</ci>
<ci>R</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Mod(R)
  </annotation>
</semantics>
</math>

 is the category of 

<math display="inline" id="Flat_module:2">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

-modules.
</dd>
</dl>
<ul>
<li>For every injective morphism 

<math display="inline" id="Flat_module:3">
<semantics>
<mrow>
<mi>ϕ</mi>
<mo>:</mo>
<mrow>
<mi>K</mi>
<mo>→</mo>
<mi>L</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>ϕ</ci>
<apply>
<ci>normal-→</ci>
<ci>K</ci>
<ci>L</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \phi:K\to L
  </annotation>
</semantics>
</math>

 of 

<math display="inline" id="Flat_module:4">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

-modules 

<math display="inline" id="Flat_module:5">
<semantics>
<mi>K</mi>
<annotation-xml encoding="MathML-Content">
<ci>K</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   K
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Flat_module:6">
<semantics>
<mi>L</mi>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L
  </annotation>
</semantics>
</math>

, the induced map</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Flat_module:7">
<semantics>
<mrow>
<mrow>
<msub>
<mi>F</mi>
<mi>M</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>ϕ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>:</mo>
<mrow>
<mrow>
<mi>M</mi>
<msub>
<mo>⊗</mo>
<mi>R</mi>
</msub>
<mi>K</mi>
</mrow>
<mo>→</mo>
<mrow>
<mi>M</mi>
<msub>
<mo>⊗</mo>
<mi>R</mi>
</msub>
<mi>L</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>F</ci>
<ci>M</ci>
</apply>
<ci>ϕ</ci>
</apply>
<apply>
<ci>normal-→</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">tensor-product</csymbol>
<ci>R</ci>
</apply>
<ci>M</ci>
<ci>K</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">tensor-product</csymbol>
<ci>R</ci>
</apply>
<ci>M</ci>
<ci>L</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   F_{M}(\phi):M\otimes_{R}K\to M\otimes_{R}L
  </annotation>
</semantics>
</math>

,
</dd>
</dl>
</dd>
<dd>is injective.
</dd>
</dl>
<ul>
<li>For every finitely generated ideal 

<math display="inline" id="Flat_module:8">
<semantics>
<mrow>
<mi>I</mi>
<mo>↪</mo>
<mi>R</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-↪</ci>
<ci>I</ci>
<ci>R</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I\hookrightarrow R
  </annotation>
</semantics>
</math>

, the induced morphism 

<math display="inline" id="Flat_module:9">
<semantics>
<mrow>
<mrow>
<mi>I</mi>
<msub>
<mo>⊗</mo>
<mi>R</mi>
</msub>
<mi>M</mi>
</mrow>
<mo>→</mo>
<mrow>
<mi>R</mi>
<msub>
<mo>⊗</mo>
<mi>R</mi>
</msub>
<mi>M</mi>
</mrow>
<mo>≅</mo>
<mi>M</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<ci>normal-→</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">tensor-product</csymbol>
<ci>R</ci>
</apply>
<ci>I</ci>
<ci>M</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">tensor-product</csymbol>
<ci>R</ci>
</apply>
<ci>R</ci>
<ci>M</ci>
</apply>
</apply>
<apply>
<approx></approx>
<share href="#.cmml">
</share>
<ci>M</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I\otimes_{R}M\to R\otimes_{R}M\cong M
  </annotation>
</semantics>
</math>

 is injective.</li>
<li>There exists a directed system of 

<math display="inline" id="Flat_module:10">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

-modules 

<math display="inline" id="Flat_module:11">
<semantics>
<msub>
<mrow>
<mo stretchy="false">{</mo>
<msub>
<mi>F</mi>
<mi>α</mi>
</msub>
<mo stretchy="false">}</mo>
</mrow>
<mi>α</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>F</ci>
<ci>α</ci>
</apply>
</set>
<ci>α</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{F_{\alpha}\}_{\alpha}
  </annotation>
</semantics>
</math>

 with the following properties:</li>
</ul>
<ol>
<li>For all 

<math display="inline" id="Flat_module:12">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Flat_module:13">
<semantics>
<msub>
<mi>F</mi>
<mi>α</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>F</ci>
<ci>α</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   F_{\alpha}
  </annotation>
</semantics>
</math>

 is a finitely generated, free 

<math display="inline" id="Flat_module:14">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

-module.</li>
<li>The direct limit is 

<math display="inline" id="Flat_module:15">
<semantics>
<mi>M</mi>
<annotation-xml encoding="MathML-Content">
<ci>M</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   M
  </annotation>
</semantics>
</math>
<math display="block" id="Flat_module:16">
<semantics>
<mrow>
<mrow>
<msub>
<munder accentunder="true">
<mo movablelimits="false">lim</mo>
<mo>→</mo>
</munder>
<mi>α</mi>
</msub>
<msub>
<mi>F</mi>
<mi>α</mi>
</msub>
</mrow>
<mo>=</mo>
<mi>M</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">injective-limit</csymbol>
<ci>α</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>F</ci>
<ci>α</ci>
</apply>
</apply>
<ci>M</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \underrightarrow{\lim}_{\alpha}F_{\alpha}=M
  </annotation>
</semantics>
</math>

.</li>
</ol>
<ul>
<li><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> For every linear dependency in 

<math display="inline" id="Flat_module:17">
<semantics>
<mi>M</mi>
<annotation-xml encoding="MathML-Content">
<ci>M</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   M
  </annotation>
</semantics>
</math>

,</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Flat_module:18">
<semantics>
<mrow>
<mrow>
<msup>
<mi>r</mi>
<mi>T</mi>
</msup>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>k</mi>
</msubsup>
<mrow>
<msub>
<mi>r</mi>
<mi>i</mi>
</msub>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<ci>T</ci>
</apply>
<ci>x</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>r</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r^{T}x=\sum_{i=1}^{k}r_{i}x_{i}=0
  </annotation>
</semantics>
</math>

,
</dd>
</dl>
</dd>
<dd>where 

<math display="inline" id="Flat_module:19">
<semantics>
<mrow>
<mrow>
<msub>
<mi>r</mi>
<mi>i</mi>
</msub>
<mo>∈</mo>
<mi>R</mi>
</mrow>
<mo>,</mo>
<mrow>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo>∈</mo>
<mi>M</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>r</ci>
<ci>i</ci>
</apply>
<ci>R</ci>
</apply>
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
<ci>M</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r_{i}\in R,x_{i}\in M
  </annotation>
</semantics>
</math>

, there exists a matrix 

<math display="inline" id="Flat_module:20">
<semantics>
<mrow>
<mi>A</mi>
<mo>∈</mo>
<msup>
<mi>R</mi>
<mrow>
<mi>k</mi>
<mo>×</mo>
<mi>j</mi>
</mrow>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<apply>
<times></times>
<ci>k</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\in R^{k\times j}
  </annotation>
</semantics>
</math>

 such that
<ol>
<li>
<math display="inline" id="Flat_module:21">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<mi>y</mi>
</mrow>
<mo>=</mo>
<mi>x</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<ci>y</ci>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Ay=x
  </annotation>
</semantics>
</math>

 has a solution for some 

<math display="inline" id="Flat_module:22">
<semantics>
<mrow>
<mi>y</mi>
<mo>∈</mo>
<msup>
<mi>M</mi>
<mi>j</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y\in M^{j}
  </annotation>
</semantics>
</math>

.</li>
<li>
<math display="inline" id="Flat_module:23">
<semantics>
<mrow>
<mrow>
<msup>
<mi>r</mi>
<mi>T</mi>
</msup>
<mi>A</mi>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<ci>T</ci>
</apply>
<ci>A</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r^{T}A=0
  </annotation>
</semantics>
</math>

.</li>
</ol>
</dd>
</dl>
<ul>
<li>For every 

<math display="inline" id="Flat_module:24">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

-module 

<math display="inline" id="Flat_module:25">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

,</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Flat_module:26">
<semantics>
<mrow>
<mrow>
<msubsup>
<mi>Tor</mi>
<mn>1</mn>
<mi>R</mi>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>N</mi>
<mo>,</mo>
<mi>M</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Tor</ci>
<cn type="integer">1</cn>
</apply>
<ci>R</ci>
</apply>
<interval closure="open">
<ci>N</ci>
<ci>M</ci>
</interval>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{Tor}_{1}^{R}(N,M)=0
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>For every finitely generated ideal 

<math display="inline" id="Flat_module:27">
<semantics>
<mrow>
<mi>I</mi>
<mo>⊂</mo>
<mi>R</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>I</ci>
<ci>R</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I\subset R
  </annotation>
</semantics>
</math>

,</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Flat_module:28">
<semantics>
<mrow>
<mrow>
<msubsup>
<mi>Tor</mi>
<mn>1</mn>
<mi>R</mi>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>R</mi>
<mo>/</mo>
<mi>I</mi>
</mrow>
<mo>,</mo>
<mi>M</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Tor</ci>
<cn type="integer">1</cn>
</apply>
<ci>R</ci>
</apply>
<interval closure="open">
<apply>
<divide></divide>
<ci>R</ci>
<ci>I</ci>
</apply>
<ci>M</ci>
</interval>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{Tor}_{1}^{R}(R/I,M)=0
  </annotation>
</semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>
<ul>
<li>For every map 

<math display="inline" id="Flat_module:29">
<semantics>
<mrow>
<mi>f</mi>
<mo>:</mo>
<mrow>
<mi>F</mi>
<mo>→</mo>
<mi>M</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>f</ci>
<apply>
<ci>normal-→</ci>
<ci>F</ci>
<ci>M</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f:F\to M
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Flat_module:30">
<semantics>
<mi>F</mi>
<annotation-xml encoding="MathML-Content">
<ci>F</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   F
  </annotation>
</semantics>
</math>

 is a finitely generated free 

<math display="inline" id="Flat_module:31">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

-module, and for every finitely generated 

<math display="inline" id="Flat_module:32">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

-submodule 

<math display="inline" id="Flat_module:33">
<semantics>
<mrow>
<mi>K</mi>
<mo>≤</mo>
<mrow>
<mi>ker</mi>
<mi>f</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<ci>K</ci>
<apply>
<csymbol cd="latexml">kernel</csymbol>
<ci>f</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K\leq\ker f
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Flat_module:34">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 factors through a map to a free 

<math display="inline" id="Flat_module:35">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

-module 

<math display="inline" id="Flat_module:36">
<semantics>
<mi>G</mi>
<annotation-xml encoding="MathML-Content">
<ci>G</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   G
  </annotation>
</semantics>
</math>

 that kills 

<math display="inline" id="Flat_module:37">
<semantics>
<mi>K</mi>
<annotation-xml encoding="MathML-Content">
<ci>K</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   K
  </annotation>
</semantics>
</math>

:</li>
</ul>
<figure><b>(Figure)</b>
<figcaption>Factor property of a flat module</figcaption>
</figure>
<h3 id="general-rings">General rings</h3>

<p>When <em>R</em> isn't commutative one needs the more careful statement that, if <em>M</em> is a flat left <em>R</em>-module, the tensor product with <em>M</em> maps exact sequences of right <em>R</em>-modules to exact sequences of <a href="abelian_group" title="wikilink">abelian groups</a>.</p>

<p>Taking tensor products (over arbitrary rings) is always a <a href="right_exact_functor" title="wikilink">right exact functor</a>. Therefore, the <em>R</em>-module <em>M</em> is flat if and only if for any <a class="uri" href="injective" title="wikilink">injective</a> <a href="module_homomorphism" title="wikilink">homomorphism</a> <em>K</em> → <em>L</em> of <em>R</em>-modules, the induced homomorphism <em>K</em>
<math display="inline" id="Flat_module:38">
<semantics>
<mo>⊗</mo>
<annotation-xml encoding="MathML-Content">
<csymbol cd="latexml">tensor-product</csymbol>
</annotation-xml>
<annotation encoding="application/x-tex">
   \otimes
  </annotation>
</semantics>
</math>
<em>M</em> → <em>L</em>
<math display="inline" id="Flat_module:39">
<semantics>
<mo>⊗</mo>
<annotation-xml encoding="MathML-Content">
<csymbol cd="latexml">tensor-product</csymbol>
</annotation-xml>
<annotation encoding="application/x-tex">
   \otimes
  </annotation>
</semantics>
</math>
<em>M</em> is also injective.</p>
<h2 id="examples">Examples</h2>
<ul>
<li>For any multiplicatively closed subset <em>S</em> of a commutative ring <em>R</em>, the <a href="localization_of_a_ring" title="wikilink">localization ring</a>
<math display="inline" id="Flat_module:40">
<semantics>
<mrow>
<msup>
<mi>S</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>R</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>S</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>R</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   S^{-1}R
  </annotation>
</semantics>
</math>

 is flat as an <em>R</em>-module. For example, 

<math display="inline" id="Flat_module:41">
<semantics>
<mi>ℚ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℚ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Q}
  </annotation>
</semantics>
</math>

 is flat over 

<math display="inline" id="Flat_module:42">
<semantics>
<mi>ℤ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℤ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
</semantics>
</math>

 (though not projective).</li>
<li>
<math display="inline" id="Flat_module:43">
<semantics>
<mrow>
<mrow>
<mi>ℤ</mi>
<mo>/</mo>
<mi>n</mi>
</mrow>
<mi>ℤ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<divide></divide>
<ci>ℤ</ci>
<ci>n</ci>
</apply>
<ci>ℤ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
</semantics>
</math>

 is not flat over 

<math display="inline" id="Flat_module:44">
<semantics>
<mi>ℤ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℤ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
</semantics>
</math>

, because, for example, 

<math display="inline" id="Flat_module:45">
<semantics>
<mrow>
<mi>n</mi>
<mo>:</mo>
<mrow>
<mrow>
<mi>ℤ</mi>
<mo>→</mo>
<mi>ℤ</mi>
</mrow>
<mo rspace="4.2pt">,</mo>
<mrow>
<mi>x</mi>
<mo>↦</mo>
<mrow>
<mi>n</mi>
<mi>x</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>n</ci>
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<ci>normal-→</ci>
<ci>ℤ</ci>
<ci>ℤ</ci>
</apply>
<apply>
<csymbol cd="latexml">maps-to</csymbol>
<ci>x</ci>
<apply>
<times></times>
<ci>n</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n:\mathbb{Z}\to\mathbb{Z},\,x\mapsto nx
  </annotation>
</semantics>
</math>

 is injective, but tensored with 

<math display="inline" id="Flat_module:46">
<semantics>
<mrow>
<mrow>
<mi>ℤ</mi>
<mo>/</mo>
<mi>n</mi>
</mrow>
<mi>ℤ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<divide></divide>
<ci>ℤ</ci>
<ci>n</ci>
</apply>
<ci>ℤ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
</semantics>
</math>

 it is not.</li>
<li>Similarly, 

<math display="inline" id="Flat_module:47">
<semantics>
<mrow>
<mi>ℚ</mi>
<mo>/</mo>
<mi>ℤ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>ℚ</ci>
<ci>ℤ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Q}/\mathbb{Z}
  </annotation>
</semantics>
</math>

 is not flat over 

<math display="inline" id="Flat_module:48">
<semantics>
<mi>ℤ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℤ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
</semantics>
</math>

.</li>
<li>Let 

<math display="inline" id="Flat_module:49">
<semantics>
<mrow>
<mi>R</mi>
<mo>=</mo>
<mrow>
<mrow>
<mi>k</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>t</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>,</mo>
<mi>k</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>R</ci>
<list>
<apply>
<times></times>
<ci>k</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>t</ci>
</apply>
</apply>
<ci>k</ci>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R=k[t],k
  </annotation>
</semantics>
</math>

 a field, and 

<math display="inline" id="Flat_module:50">
<semantics>
<mrow>
<mi>S</mi>
<mo>=</mo>
<mrow>
<mrow>
<mi>R</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>x</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>/</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>t</mi>
<mi>x</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>S</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>R</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>x</ci>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>t</ci>
<ci>x</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   S=R[x]/(tx-1)
  </annotation>
</semantics>
</math>

. Since <em>S</em> is the same thing as the localization 

<math display="inline" id="Flat_module:51">
<semantics>
<mrow>
<mi>R</mi>
<mrow>
<mo stretchy="false">[</mo>
<msup>
<mi>t</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>R</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R[t^{-1}]
  </annotation>
</semantics>
</math>

, it is flat over <em>R</em>. On the other hand, 

<math display="inline" id="Flat_module:52">
<semantics>
<mrow>
<mrow>
<mi>R</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>x</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>/</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>t</mi>
<mi>x</mi>
</mrow>
<mo>-</mo>
<mi>t</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<apply>
<times></times>
<ci>R</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>x</ci>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>t</ci>
<ci>x</ci>
</apply>
<ci>t</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R[x]/(tx-t)
  </annotation>
</semantics>
</math>

 is not flat over <em>R</em> since <em>t</em> is a <a href="torsion_element" title="wikilink">torsion element</a> on it (so it is not torsion-free).</li>
<li>Let <em>A</em> be a noetherian ring and <em>I</em> an ideal. Then the <a href="completion_(ring_theory)" title="wikilink">completion</a>
<math display="inline" id="Flat_module:53">
<semantics>
<mrow>
<mi>A</mi>
<mo>→</mo>
<mover accent="true">
<mi>A</mi>
<mo>^</mo>
</mover>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>A</ci>
<apply>
<ci>normal-^</ci>
<ci>A</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\to\widehat{A}
  </annotation>
</semantics>
</math>

 with respect to <em>I</em> is flat.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> It is faithfully flat if and only if <em>I</em> is contained in the Jacobson radical of <em>A</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (cf. <a href="Zariski_ring" title="wikilink">Zariski ring</a>.)</li>
<li>The direct sum 

<math display="inline" id="Flat_module:54">
<semantics>
<mrow>
<msub>
<mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⊕</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</msub>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \bigoplus_{i\in I}M_{i}
  </annotation>
</semantics>
</math>

 is flat if and only if each 

<math display="inline" id="Flat_module:55">
<semantics>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M_{i}
  </annotation>
</semantics>
</math>

 is flat.</li>
<li>Every product of <em>A</em>-modules is flat if and only if <em>A</em> is a <a href="coherent_ring" title="wikilink">coherent ring</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>(Kunz) A noetherian ring containing a field of characteristic <em>p</em> is <a href="regular_ring" title="wikilink">regular</a> if and only if the <a href="Frobenius_morphism" title="wikilink">Frobenius morphism</a> <em>R</em> →<em>R</em> is flat and <em>R</em> is reduced.</li>
</ul>
<h2 id="case-of-commutative-rings">Case of commutative rings</h2>

<p>When M is a <a href="finitely-generated_module" title="wikilink">finitely-generated</a> R-module, being flat is the same as being locally free in the following sense: M is a flat R-module if and only if for every <a href="prime_ideal" title="wikilink">prime ideal</a> (or even just for every <a href="maximal_ideal" title="wikilink">maximal ideal</a>) P of R, the <a href="localization_of_a_module" title="wikilink">localization</a>
<math display="inline" id="Flat_module:56">
<semantics>
<msub>
<mi>M</mi>
<mi>P</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>P</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M_{P}
  </annotation>
</semantics>
</math>

 is <a href="free_module" title="wikilink">free</a> as a module over the <a href="localization_of_a_ring" title="wikilink">localization</a>
<math display="inline" id="Flat_module:57">
<semantics>
<msub>
<mi>R</mi>
<mi>P</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>P</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R_{P}
  </annotation>
</semantics>
</math>

.</p>

<p>Let <em>R</em> be a <a href="local_ring" title="wikilink">local ring</a> with nilpotent maximal ideal (e.g., an <a href="artinian_local_ring" title="wikilink">artinian local ring</a>) and <em>M</em> a module over it. Then <em>M</em> flat implies <em>M</em> free.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The <strong>local criterion for flatness</strong> states:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<dl>
<dd>Let <em>R</em> be a local noetherian ring, <em>S</em> a local noetherian <em>R</em>-algebra with 

<math display="inline" id="Flat_module:58">
<semantics>
<mrow>
<mrow>
<msub>
<mi>𝔪</mi>
<mi>R</mi>
</msub>
<mi>S</mi>
</mrow>
<mo>⊂</mo>
<msub>
<mi>𝔪</mi>
<mi>S</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔪</ci>
<ci>R</ci>
</apply>
<ci>S</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔪</ci>
<ci>S</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathfrak{m}_{R}S\subset\mathfrak{m}_{S}
  </annotation>
</semantics>
</math>

, and <em>M</em> a finitely generated <em>S</em>-module. Then <em>M</em> is flat over <em>R</em> if and only if 

<math display="inline" id="Flat_module:59">
<semantics>
<mrow>
<mrow>
<msubsup>
<mo>Tor</mo>
<mn>1</mn>
<mi>R</mi>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>M</mi>
<mo>,</mo>
<mrow>
<mi>R</mi>
<mo>/</mo>
<msub>
<mi>𝔪</mi>
<mi>R</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0.</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Tor</ci>
<cn type="integer">1</cn>
</apply>
<ci>R</ci>
</apply>
<ci>M</ci>
<apply>
<divide></divide>
<ci>R</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔪</ci>
<ci>R</ci>
</apply>
</apply>
</apply>
<cn type="float">0.</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Tor}_{1}^{R}(M,R/\mathfrak{m}_{R})=0.
  </annotation>
</semantics>
</math>
</dd>
</dl>

<p>The significance of this is that <em>S</em> need not be finite over <em>R</em> and we only need to consider the maximal ideal of <em>R</em> instead of an arbitrary ideal of <em>R</em>.</p>

<p>The next criterion is also useful for testing flatness:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<dl>
<dd>Let <em>R</em>, <em>S</em> be as in the local criterion for flatness. Assume <em>S</em> is <a href="Cohen–Macaulay_ring" title="wikilink">Cohen–Macaulay</a> and <em>R</em> is <a href="regular_local_ring" title="wikilink">regular</a>. Then <em>S</em> is flat over <em>R</em> if and only if 

<math display="inline" id="Flat_module:60">
<semantics>
<mrow>
<mrow>
<mo>dim</mo>
<mi>S</mi>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo>dim</mo>
<mi>R</mi>
</mrow>
<mo>+</mo>
<mrow>
<mo>dim</mo>
<mrow>
<mrow>
<mi>S</mi>
<mo>/</mo>
<msub>
<mi>𝔪</mi>
<mi>R</mi>
</msub>
</mrow>
<mi>S</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>dim</ci>
<ci>S</ci>
</apply>
<apply>
<plus></plus>
<apply>
<ci>dim</ci>
<ci>R</ci>
</apply>
<apply>
<ci>dim</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>S</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>𝔪</ci>
<ci>R</ci>
</apply>
</apply>
<ci>S</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{dim}S=\operatorname{dim}R+\operatorname{dim}S/\mathfrak{m}_{R}S
  </annotation>
</semantics>
</math>

.
</dd>
</dl>

<p>If <em>S</em> is an <em>R</em>-algebra, i.e., we have a homomorphism 

<math display="inline" id="Flat_module:61">
<semantics>
<mrow>
<mi>f</mi>
<mo>:</mo>
<mrow>
<mi>R</mi>
<mo>→</mo>
<mi>S</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>f</ci>
<apply>
<ci>normal-→</ci>
<ci>R</ci>
<ci>S</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f\colon R\to S
  </annotation>
</semantics>
</math>

, then <em>S</em> has the structure of an <em>R</em>-module, and hence it makes sense to ask if <em>S</em> is flat over <em>R</em>. If this is the case, then <em>S</em> is faithfully flat over <em>R</em> if and only if every prime ideal of <em>R</em> is the inverse image under <em>f</em> of a prime ideal in <em>S</em>. In other words, if and only if the induced map 

<math display="inline" id="Flat_module:62">
<semantics>
<mrow>
<msup>
<mi>f</mi>
<mo>*</mo>
</msup>
<mo>:</mo>
<mrow>
<mrow>
<mi>Spec</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>S</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mrow>
<mi>Spec</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>R</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<times></times>
</apply>
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>Spec</ci>
<ci>S</ci>
</apply>
<apply>
<times></times>
<ci>Spec</ci>
<ci>R</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f^{*}\colon\mathrm{Spec}(S)\to\mathrm{Spec}(R)
  </annotation>
</semantics>
</math>

 is surjective.</p>

<p>Flat modules over commutative rings are always <a href="torsion-free_module" title="wikilink">torsion-free</a>. <a href="Projective_module" title="wikilink">Projective modules</a> (and thus <a href="free_module" title="wikilink">free modules</a>) are always flat. For certain common classes of rings, these statements can be reversed (for example, every torsion-free module over a <a href="Dedekind_ring" title="wikilink">Dedekind ring</a> is automatically flat and flat modules over <a href="perfect_ring" title="wikilink">perfect rings</a> are always projective), as is subsumed in the following diagram of module properties:</p>
<figure><b>(Figure)</b>
<figcaption>Module properties in commutative algebra</figcaption>
</figure>

<p>An integral domain is called a <a href="Prüfer_domain" title="wikilink">Prüfer domain</a> if every torsion-free module over it is flat.</p>
<h2 id="categorical-colimits">Categorical colimits</h2>

<p>In general, arbitrary <a href="direct_sum_of_modules" title="wikilink">direct sums</a> and <a href="direct_limit" title="wikilink">direct limits</a> of flat modules are flat, a consequence of the fact that the tensor product commutes with direct sums and direct limits (in fact with all <a class="uri" href="colimits" title="wikilink">colimits</a>), and that both direct sums and direct limits are <a href="exact_functor" title="wikilink">exact functors</a>. <a href="Submodule" title="wikilink">Submodules</a> and <a href="factor_module" title="wikilink">factor modules</a> of flat modules need not be flat in general (e.g. Z/nZ is not a flat Z-module for n&gt;1). However we have the following result: the homomorphic image of a flat module <em>M</em> is flat if and only if the kernel is a <a href="pure_submodule" title="wikilink">pure submodule</a> of <em>M</em>.</p>

<p><a href="Daniel_Lazard" title="wikilink">Daniel Lazard</a> proved in 1969 that a module <em>M</em> is flat if and only if it is a <a href="direct_limit" title="wikilink">direct limit</a> of <a href="finitely_generated_module" title="wikilink">finitely-generated</a> <a href="free_module" title="wikilink">free modules</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> As a consequence, one can deduce that every <a href="finitely-presented_module" title="wikilink">finitely-presented</a> flat module is projective.</p>

<p>An abelian group is flat (viewed as a Z-module) if and only if it is torsion-free.</p>
<h2 id="homological-algebra">Homological algebra</h2>

<p>Flatness may also be expressed using the <a href="Tor_functor" title="wikilink">Tor functors</a>, the <a href="derived_functor" title="wikilink">left derived functors</a> of the tensor product. A left <em>R</em>-module <em>M</em> is flat if and only if Tor<sub>n</sub><sup><em>R</em></sup>(–, <em>M</em>) = 0 for all 

<math display="inline" id="Flat_module:63">
<semantics>
<mrow>
<mi>n</mi>
<mo>≥</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\geq 1
  </annotation>
</semantics>
</math>

 (i.e., if and only if Tor<sub>n</sub><sup><em>R</em></sup>(<em>X</em>, <em>M</em>) = 0 for all 

<math display="inline" id="Flat_module:64">
<semantics>
<mrow>
<mi>n</mi>
<mo>≥</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\geq 1
  </annotation>
</semantics>
</math>

 and all right <em>R</em>-modules <em>X</em>). Similarly, a right <em>R</em>-module <em>M</em> is flat if and only if Tor<sub>n</sub><sup><em>R</em></sup>(<em>M</em>, <em>X</em>) = 0 for all 

<math display="inline" id="Flat_module:65">
<semantics>
<mrow>
<mi>n</mi>
<mo>≥</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\geq 1
  </annotation>
</semantics>
</math>

 and all left <em>R</em>-modules <em>X</em>. Using the Tor functor's <a href="long_exact_sequence" title="wikilink">long exact sequences</a>, one can then easily prove facts about a <a href="short_exact_sequence" title="wikilink">short exact sequence</a></p>
<dl>
<dd><a href="image:short_exact_sequence_ABC.png" title="wikilink">image:short exact sequence ABC.png</a>
</dd>
</dl>
<ul>
<li>If <em>A</em> and <em>C</em> are flat, then so is <em>B</em></li>
<li>If <em>B</em> and <em>C</em> are flat, then so is <em>A</em></li>
</ul>

<p>If <em>A</em> and <em>B</em> are flat, <em>C</em> need not be flat in general. However, it can be shown that</p>
<ul>
<li>If <em>A</em> is <a href="pure_submodule" title="wikilink">pure</a> in <em>B</em> and <em>B</em> is flat, then <em>A</em> and <em>C</em> are flat.</li>
</ul>
<h2 id="flat-resolutions">Flat resolutions</h2>

<p>A <strong>flat resolution</strong> of a module <em>M</em> is a <a href="resolution_of_a_module" title="wikilink">resolution</a> of the form</p>
<dl>
<dd>... → <em>F</em><sub>2</sub> → <em>F</em><sub>1</sub> → <em>F</em><sub>0</sub> → <em>M</em> → 0
</dd>
</dl>

<p>where the <em>F</em><sub><em>i</em></sub> are all flat modules. Any free or projective resolution is necessarily a flat resolution. Flat resolutions can be used to compute the <a href="Tor_functor" title="wikilink">Tor functor</a>.</p>

<p>The <em>length</em> of a finite flat resolution is the first subscript <em>n</em> such that <em>F</em><sub><em>n</em></sub> is nonzero and <em>F</em><sub><em>i</em></sub>=0 for <em>i</em> greater than <em>n</em>. If a module <em>M</em> admits a finite flat resolution, the minimal length among all finite flat resolutions of <em>M</em> is called its <a href="flat_dimension" title="wikilink">flat dimension</a> and denoted fd(<em>M</em>). If <em>M</em> does not admit a finite flat resolution, then by convention the flat dimension is said to be infinite. As an example, consider a module <em>M</em> such that fd(<em>M</em>) = 0. In this situation, the exactness of the sequence 0 → <em>F</em><sub>0</sub> → <em>M</em> → 0 indicates that the arrow in the center is an isomorphism, and hence <em>M</em> itself is flat.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>In some areas of module theory, a flat resolution must satisfy the additional requirement that each map is a flat pre-cover of the kernel of the map to the right. For projective resolutions, this condition is almost invisible: a projective pre-cover is simply an <a class="uri" href="epimorphism" title="wikilink">epimorphism</a> from a projective module. These ideas are inspired from Auslander's work in approximations. These ideas are also familiar from the more common notion of minimal projective resolutions, where each map is required to be a <a href="projective_cover" title="wikilink">projective cover</a> of the kernel of the map to the right. However, projective covers need not exist in general, so minimal projective resolutions are only of limited use over rings like the integers.</p>

<p>While projective covers for modules do not always exist, it was speculated that for general rings, every module would have a flat cover, that is, every module would be the epimorphic image of a flat module under a homomorphism with <a href="superfluous_submodule" title="wikilink">superfluous</a> kernel. This <strong>flat cover conjecture</strong> was explicitly first stated in . The conjecture turned out to be true, resolved positively and proved simultaneously by L. Bican, R. El Bashir and E. Enochs. This was preceded by important contributions by P. Eklof, J. Trlifaj and J. Xu.</p>

<p>Since flat covers exist for all modules over all rings, minimal flat resolutions can take the place of minimal projective resolutions in many circumstances. The measurement of the departure of flat resolutions from projective resolutions is called <em>relative homological algebra</em>, and is covered in classics such as  and in more recent works focussing on flat resolutions such as .</p>
<h2 id="in-constructive-mathematics">In constructive mathematics</h2>

<p>Flat modules have increased importance in <a href="constructive_mathematics" title="wikilink">constructive mathematics</a>, where projective modules are less useful. For example, that all free modules are projective is equivalent to the full <a href="axiom_of_choice" title="wikilink">axiom of choice</a>, so theorems about projective modules, even if proved constructively, do not necessarily apply to free modules. In contrast, no choice is needed to prove that free modules are flat, so theorems about flat modules can still apply.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="generic_flatness" title="wikilink">generic flatness</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>N. Bourbaki, <em>Commutative Algebra</em></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>- page 33</p></li>
<li></li>
<li></li>
</ul>
<h2 id="see-also-1">See also</h2>
<ul>
<li><a href="localization_of_a_module" title="wikilink">localization of a module</a></li>
<li><a href="flat_morphism" title="wikilink">flat morphism</a></li>
<li><a href="von_Neumann_regular_ring" title="wikilink">von Neumann regular ring</a>: those rings over which <em>all</em> modules are flat.</li>
</ul>

<p>"</p>

<p><a href="Category:Homological_algebra" title="wikilink">Category:Homological algebra</a> <a href="Category:Algebraic_geometry" title="wikilink">Category:Algebraic geometry</a> <a href="Category:Module_theory" title="wikilink">Category:Module theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="http://mathoverflow.net/questions/120403/flatness-of-power-series-rings/">http://mathoverflow.net/questions/120403/flatness-of-power-series-rings/</a><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">A module isomorphic to an flat module is of course flat.<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
