<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="783">Relevance logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Relevance logic</h1>
<hr/>

<p><strong>Relevance logic</strong>, also called <strong>relevant logic</strong>, is a kind of non-<a href="classical_logic" title="wikilink">classical logic</a> requiring the <a href="Antecedent_(logic)" title="wikilink">antecedent</a> and <a class="uri" href="consequent" title="wikilink">consequent</a> of <a href="Entailment" title="wikilink">implications</a> to be relevantly related. They may be viewed as a family of <a href="substructural_logic" title="wikilink">substructural</a> or <a href="modal_logic" title="wikilink">modal</a> logics. (It is generally, but not universally, called <em>relevant logic</em> by Australian <a href="logician" title="wikilink">logicians</a>, and <em>relevance logic</em> by other English-speaking logicians.)</p>

<p>Relevance logic aims to capture aspects of implication that are ignored by the "<a href="material_conditional" title="wikilink">material implication</a>" operator in classical <a href="truth-functional_logic" title="wikilink">truth-functional logic</a>, namely the notion of relevance between antecedent and conditional of a true implication. This idea is not new: <a href="C._I._Lewis" title="wikilink">C. I. Lewis</a> was led to invent modal logic, and specifically <a href="strict_implication" title="wikilink">strict implication</a>, on the grounds that classical logic grants <a href="paradoxes_of_material_implication" title="wikilink">paradoxes of material implication</a> such as the principle that <a href="Vacuous_truth" title="wikilink">a falsehood implies any proposition</a>. Hence "if I'm a donkey, then two and two is four" is true when translated as a material implication, yet it seems intuitively false since a true implication must tie the antecedent and consequent together by some notion of relevance. And whether or not I'm a donkey seems in no way relevant to whether two and two is four.</p>

<p>How does relevance logic formally capture a notion of relevance? In terms of a syntactical constraint for a <a href="propositional_calculus" title="wikilink">propositional calculus</a>, it is necessary, but not sufficient, that premises and conclusion share <a href="atomic_formula" title="wikilink">atomic formulae</a> (formulae that do not contain any <a href="logical_connective" title="wikilink">logical connectives</a>). In a <a href="predicate_calculus" title="wikilink">predicate calculus</a>, relevance requires sharing of variables and constants between premises and conclusion. This can be ensured (along with stronger conditions) by, e.g., placing certain restrictions on the rules of a natural deduction system. In particular, a Fitch-style <a href="natural_deduction" title="wikilink">natural deduction</a> can be adapted to accommodate relevance by introducing tags at the end of each line of an application of an inference indicating the premises relevant to the conclusion of the inference. <a class="uri" href="Gentzen" title="wikilink">Gentzen</a>-style <a href="sequent_calculus" title="wikilink">sequent calculi</a> can be modified by removing the weakening rules that allow for the introduction of arbitrary formulae on the right or left side of the <a href="sequent" title="wikilink">sequents</a>.</p>

<p>A notable feature of relevance logics is that they are <a href="paraconsistent_logic" title="wikilink">paraconsistent logics</a>: the existence of a contradiction will not cause "<a href="principle_of_explosion" title="wikilink">explosion</a>". This follows from the fact that a conditional with a contradictory antecedent that does not share any propositional or predicate letters with the consequent cannot be true (or derivable).</p>
<h2 id="history">History</h2>

<p>Relevance logic was proposed in 1928 by Soviet (Russian) philosopher <a href="Ivan_E._Orlov" title="wikilink">Ivan E. Orlov</a> (1886–circa 1936) in his strictly mathematical paper "The Logic of Compatibility of Propositions" published in Matematicheskii Sbornik. The basic idea of relevant implication appears in medieval logic, and some pioneering work was done by <a href="Wilhelm_Ackermann" title="wikilink">Ackermann</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a href="Moh_Shaw-Kwei" title="wikilink">Moh</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and <a href="Alonzo_Church" title="wikilink">Church</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> in the 1950s. Drawing on them, <a href="Nuel_Belnap" title="wikilink">Nuel Belnap</a> and <a href="Alan_Ross_Anderson" title="wikilink">Alan Ross Anderson</a> (with others) wrote the <em>magnum opus</em> of the subject, <em>Entailment: The Logic of Relevance and Necessity</em> in the 1970s (the second volume being published in the nineties). They focused on both systems of <a class="uri" href="entailment" title="wikilink">entailment</a> and systems of relevance, where implications of the former kinds are supposed to be both relevant and necessary.</p>
<h2 id="semantics">Semantics</h2>

<p>Relevance logic is, in syntactic terms, a substructural logic because it is obtained from classical logic by removing some of its structural rules (e.g. explicitly of some sequent calculus or implicitly by "tagging" inferences of a natural deduction system). It is sometimes referred to as a modal logic because it can be characterized as a class of formulas valid over a class of <a href="Kripke_semantics" title="wikilink">Kripke (relational) frames</a>. In Kripke semantics for relevance logic, the implication operator is a binary modal operator, and negation is usually taken to be a unary modal operator. As such, the accessibility relation governing the operator is ternary rather than the usual binary ones that govern unary modal operators often read as "necessarily".</p>

<p>A Kripke frame F for a propositional relevance language is a triple (W,R,*) where W is a set of indices (or points or worlds), R is a ternary accessibility relation between indices, and * is a unary function taking indices to indices. A model M for the language is an ordered pair (F,V) where F is a frame and V is a valuation function mapping sets of worlds (propositions) to propositional letters. Let M be a model and a,b,c indices from M. An implication is defined</p>
<ul>
<li>

<math display="inline" id="Relevance_logic:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo>⊧</mo>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mi>ψ</mi>
   <mo>⇔</mo>
   <mo>∀</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mi>a</mi>
     <mi>b</mi>
     <mi>c</mi>
     <mo>∧</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo>⊧</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⇒</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>c</mi>
    <mo>⊧</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="latexml">models</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">ψ</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">R</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">c</csymbol>
      <and></and>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M,a\models\phi\to\psi\iff\forall b,c((Rabc\land M,b\models\phi)\Rightarrow M,c%
\models\psi)
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Negation is defined</p>
<ul>
<li>

<math display="inline" id="Relevance_logic:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>,</mo>
     <mi>a</mi>
    </mrow>
    <mo>⊧</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>ϕ</mi>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>,</mo>
     <msup>
      <mi>a</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo>⊧̸</mo>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <list>
      <ci>M</ci>
      <ci>a</ci>
     </list>
     <apply>
      <times></times>
      <not></not>
      <ci>ϕ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">not-models</csymbol>
     <list>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <times></times>
      </apply>
     </list>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M,a\models\lnot\phi\iff M,a^{*}\not\models\phi
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>One obtains various relevance logics by placing appropriate restrictions on R and on *. <em>Details need to be filled in.</em></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Relevant_type_system" title="wikilink">Relevant type system</a>, a <a href="substructural_type_system" title="wikilink">substructural type system</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li><a href="Alan_Ross_Anderson" title="wikilink">Alan Ross Anderson</a> and <a href="Nuel_Belnap" title="wikilink">Nuel Belnap</a>, 1975. <em>Entailment: the logic of relevance and necessity, vol. I</em>. Princeton University Press. ISBN 0-691-07192-6</li>
<li>------- and J. M. Dunn, 1992. <em>Entailment: the logic of relevance and necessity, vol. II</em>, Princeton University Press.</li>
<li>Mares, Edwin, and Meyer, R. K., 2001, "Relevant Logics," in Goble, Lou, ed., <em>The Blackwell Guide to Philosophical Logic</em>. Blackwell.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="Stanford_Encyclopaedia_of_Philosophy" title="wikilink">Stanford Encyclopaedia of Philosophy</a>: "<a href="http://plato.stanford.edu/entries/logic-relevance/">Relevance logic</a>" -- by Edwin Mares.</li>
</ul>

<p>"</p>

<p><a href="Category:Substructural_logic" title="wikilink">Category:Substructural logic</a> <a href="Category:Non-classical_logic" title="wikilink">Category:Non-classical logic</a> <a href="Category:Paraconsistent_logic" title="wikilink">Category:Paraconsistent logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"> Moh Shaw-Kwei, 1950, "," Methodos 2 56-75.<a href="#fnref2">↩</a></li>
<li id="fn3"> in <em>Kontroliertes Denken: Untersuchungen zum Logikkalkül und zur Logik der Einzelwissenschaften</em>, Kommissions-Verlag Karl Alber, edited by A. Menne, A. Wilhelmy and H. Angsil, pp.22-37.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
