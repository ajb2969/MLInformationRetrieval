<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1585">Operational semantics</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Operational semantics</h1>
<hr/>

<p><strong>Operational semantics</strong> are a category of <a href="Semantics_(computer_science)" title="wikilink">formal programming language semantics</a> in which certain desired properties of a program, such as correctness, safety or security, are <a href="formal_verification" title="wikilink">verified</a> by constructing proofs from logical statements about its execution and procedures, rather than by attaching mathematical meanings to its terms (<a href="denotational_semantics" title="wikilink">denotational semantics</a>). Operational semantics are classified in two categories: <strong>structural operational semantics</strong> (or <strong>small-step semantics</strong>) formally describe how the <em>individual steps</em> of a <a class="uri" href="computation" title="wikilink">computation</a> take place in a computer-based system. By opposition <strong>natural semantics</strong> (or <strong>big-step semantics</strong>) describe how the <em>overall results</em> of the executions are obtained. Other approaches to providing a <a href="formal_semantics_of_programming_languages" title="wikilink">formal semantics of programming languages</a> include <a href="axiomatic_semantics" title="wikilink">axiomatic semantics</a> and <a href="denotational_semantics" title="wikilink">denotational semantics</a>.</p>

<p>The operational semantics for a programming language describes how a valid program is interpreted as sequences of computational steps. These sequences then <em>are</em> the meaning of the program. In the context of <a href="functional_program" title="wikilink">functional programs</a>, the final step in a terminating sequence returns the value of the program. (In general there can be many return values for a single program, because the program could be <a href="Nondeterministic_algorithm" title="wikilink">nondeterministic</a>, and even for a deterministic program there can be many computation sequences since the semantics may not specify exactly what sequence of operations arrives at that value.)</p>

<p>The concept of operational semantics was used for the first time in defining the semantics of Algol 68. The following statement is a quote from the revised ALGOL 68 report:</p>
<blockquote>

<p>The meaning of a program in the strict language is explained in terms of a hypothetical computer which performs the set of actions which constitute the elaboration of that program. (<a href="#algol68" title="wikilink">Algol68</a>, Section 2)</p>
</blockquote>

<p>The first use of the term "operational semantics" in its present meaning is attributed to <a href="Dana_Scott" title="wikilink">Dana Scott</a> (<a href="#plotkin04" title="wikilink">Plotkin04</a>). What follows is a quote from Scott's seminal paper on formal semantics, in which he mentions the "operational" aspects of semantics.</p>
<blockquote>

<p>It is all very well to aim for a more ‘abstract’ and a ‘cleaner’ approach to semantics, but if the plan is to be any good, the operational aspects cannot be completely ignored. (<a href="#scott70" title="wikilink">Scott70</a>)</p>
</blockquote>

<p>Perhaps the first formal incarnation of operational semantics was the use of the <a href="lambda_calculus" title="wikilink">lambda calculus</a> to define the semantics of <a class="uri" href="LISP" title="wikilink">LISP</a> by []. <a href="Abstract_machine" title="wikilink">Abstract machines</a> in the tradition of the <a href="SECD_machine" title="wikilink">SECD machine</a> are also closely related.</p>
<h2 id="approaches">Approaches</h2>

<p><a href="Gordon_Plotkin" title="wikilink">Gordon Plotkin</a> introduced the structural operational semantics, Robert Hieb and <a href="Matthias_Felleisen" title="wikilink">Matthias Felleisen</a> the reduction contexts,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="Gilles_Kahn" title="wikilink">Gilles Kahn</a> the natural semantics.</p>
<h3 id="small-step-semantics">Small-step semantics</h3>
<h4 id="structural-operational-semantics">Structural operational semantics</h4>

<p><strong>Structural operational semantics</strong> (also called <strong>structured operational semantics</strong> or <strong>small-step semantics</strong>) was introduced by <a href="Gordon_Plotkin" title="wikilink">Gordon Plotkin</a> in (<a href="#plotkin81" title="wikilink">Plotkin81</a>) as a logical means to define operational semantics. The basic idea behind SOS is to define the behavior of a program in terms of the behavior of its parts, thus providing a structural, i.e., syntax oriented and <a href="inductive_definition" title="wikilink">inductive</a>, view on operational semantics. An SOS specification defines the behavior of a program in terms of a (set of) <a href="State_transition_system" title="wikilink">transition relation</a>(s). SOS specifications take the form of a set of <a href="inference_rule" title="wikilink">inference rules</a> that define the valid transitions of a composite piece of syntax in terms of the transitions of its components.</p>

<p>For a simple example, we consider part of the semantics of a simple programming language; proper illustrations are given in <a href="#plotkin81" title="wikilink">Plotkin81</a> and <a href="#hennessybook" title="wikilink">Hennessy90</a>, and other textbooks. Let 

<math display="inline" id="Operational_semantics:0">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1},C_{2}
  </annotation>
 </semantics>
</math>

 range over programs of the language, and let 

<math display="inline" id="Operational_semantics:1">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 range over states (e.g. functions from memory locations to values). If we have expressions (ranged over by 

<math display="inline" id="Operational_semantics:2">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

), values (

<math display="inline" id="Operational_semantics:3">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

) and locations (

<math display="inline" id="Operational_semantics:4">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

), then a memory update command would have semantics:</p>

<p>

<math display="inline" id="Operational_semantics:5">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>E</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>⇒</mo>
    <mi>V</mi>
   </mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>L</mi>
     <mo>:=</mo>
     <mpadded width="+1.7pt">
      <mi>E</mi>
     </mpadded>
     <mo rspace="4.2pt">,</mo>
     <mi>s</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>⟶</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>⊎</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>L</mi>
      <mo>↦</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <ci>normal-⇒</ci>
     <list>
      <ci>E</ci>
      <ci>s</ci>
     </list>
     <ci>V</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">L</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-⟶</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-⊎</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">L</csymbol>
       <csymbol cd="latexml">maps-to</csymbol>
       <csymbol cd="unknown">V</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\langle E,s\rangle\Rightarrow V}{\langle L:=E\,,\,s\rangle%
\longrightarrow(s\uplus(L\mapsto V))}
  </annotation>
 </semantics>
</math>

</p>

<p>Informally, the rule says that "<strong>if</strong> the expression 

<math display="inline" id="Operational_semantics:6">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Operational_semantics:7">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 reduces to value 

<math display="inline" id="Operational_semantics:8">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, <strong>then</strong> the program 

<math display="inline" id="Operational_semantics:9">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>:=</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>L</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L:=E
  </annotation>
 </semantics>
</math>

 will update the state 

<math display="inline" id="Operational_semantics:10">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 with the assignment 

<math display="inline" id="Operational_semantics:11">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=V
  </annotation>
 </semantics>
</math>

".</p>

<p>The semantics of sequencing can be given by the following three rules:</p>

<p>

<math display="inline" id="Operational_semantics:12">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>C</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>⟶</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>C</mi>
       <mn>1</mn>
      </msub>
      <mo>;</mo>
      <mpadded width="+1.7pt">
       <msub>
        <mi>C</mi>
        <mn>2</mn>
       </msub>
      </mpadded>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>⟶</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>C</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>C</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>⟶</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msubsup>
       <mi>C</mi>
       <mn>1</mn>
       <mo>′</mo>
      </msubsup>
      <mo>,</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>C</mi>
       <mn>1</mn>
      </msub>
      <mo>;</mo>
      <mpadded width="+1.7pt">
       <msub>
        <mi>C</mi>
        <mn>2</mn>
       </msub>
      </mpadded>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>⟶</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msubsup>
       <mi>C</mi>
       <mn>1</mn>
       <mo>′</mo>
      </msubsup>
      <mo>;</mo>
      <mpadded width="+1.7pt">
       <msub>
        <mi>C</mi>
        <mn>2</mn>
       </msub>
      </mpadded>
      <mo>,</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mfrac>
    <mi></mi>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>𝐬𝐤𝐢𝐩</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>⟶</mo>
     <mi>s</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-⟶</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>s</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⟶</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>s</ci>
      </list>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
      </list>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-⟶</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>s</ci>
      </list>
      <list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <ci>normal-⟶</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>s</ci>
      </list>
      <list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
      </list>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>normal-⟶</ci>
      <list>
       <ci>𝐬𝐤𝐢𝐩</ci>
       <ci>s</ci>
      </list>
      <ci>s</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\langle C_{1},s\rangle\longrightarrow s^{\prime}}{\langle C_{1};C_{2}\,,%
s\rangle\longrightarrow\langle C_{2},s^{\prime}\rangle}\quad\quad\frac{\langle
C%
_{1},s\rangle\longrightarrow\langle C_{1}^{\prime},s^{\prime}\rangle}{\langle C%
_{1};C_{2}\,,s\rangle\longrightarrow\langle C_{1}^{\prime};C_{2}\,,s^{\prime}%
\rangle}\quad\quad\frac{}{\langle\mathbf{skip},s\rangle\longrightarrow s}
  </annotation>
 </semantics>
</math>

</p>

<p>Informally, the first rule says that, if program 

<math display="inline" id="Operational_semantics:13">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Operational_semantics:14">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 finishes in state 

<math display="inline" id="Operational_semantics:15">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

, then the program 

<math display="inline" id="Operational_semantics:16">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>;</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1};C_{2}
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Operational_semantics:17">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 will reduce to the program 

<math display="inline" id="Operational_semantics:18">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Operational_semantics:19">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

. (You can think of this as formalizing "You can run 

<math display="inline" id="Operational_semantics:20">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

, and then run 

<math display="inline" id="Operational_semantics:21">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>

 using the resulting memory store.) The second rule says that if the program 

<math display="inline" id="Operational_semantics:22">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Operational_semantics:23">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 can reduce to the program 

<math display="inline" id="Operational_semantics:24">
 <semantics>
  <msubsup>
   <mi>C</mi>
   <mn>1</mn>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}^{\prime}
  </annotation>
 </semantics>
</math>

 with state 

<math display="inline" id="Operational_semantics:25">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

, then the program 

<math display="inline" id="Operational_semantics:26">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>;</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1};C_{2}
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Operational_semantics:27">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 will reduce to the program 

<math display="inline" id="Operational_semantics:28">
 <semantics>
  <mrow>
   <msubsup>
    <mi>C</mi>
    <mn>1</mn>
    <mo>′</mo>
   </msubsup>
   <mo>;</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}^{\prime};C_{2}
  </annotation>
 </semantics>
</math>

 in state 

<math display="inline" id="Operational_semantics:29">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

. (You can think of this as formalizing the principle for an optimizing compiler: "You are allowed to transform 

<math display="inline" id="Operational_semantics:30">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

 as if it were stand-alone, even if it is just the first part of a program.") The semantics is structural, because the meaning of the sequential program 

<math display="inline" id="Operational_semantics:31">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>;</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1};C_{2}
  </annotation>
 </semantics>
</math>

, is defined by the meaning of 

<math display="inline" id="Operational_semantics:32">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1}
  </annotation>
 </semantics>
</math>

 and the meaning of 

<math display="inline" id="Operational_semantics:33">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>If we also have Boolean expressions over the state, ranged over by 

<math display="inline" id="Operational_semantics:34">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, then we can define the semantics of the <strong>while</strong> command: 

<math display="inline" id="Operational_semantics:35">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>B</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>⇒</mo>
     <mi>𝐭𝐫𝐮𝐞</mi>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>𝐰𝐡𝐢𝐥𝐞</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>B</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>𝐝𝐨</mi>
       </mpadded>
       <mi>C</mi>
      </mrow>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>⟶</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>C</mi>
      <mo>;</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>𝐰𝐡𝐢𝐥𝐞</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>B</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>𝐝𝐨</mi>
       </mpadded>
       <mi>C</mi>
      </mrow>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>B</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>⇒</mo>
     <mi>𝐟𝐚𝐥𝐬𝐞</mi>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>𝐰𝐡𝐢𝐥𝐞</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>B</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>𝐝𝐨</mi>
       </mpadded>
       <mi>C</mi>
      </mrow>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>⟶</mo>
     <mi>s</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-⇒</ci>
      <list>
       <ci>B</ci>
       <ci>s</ci>
      </list>
      <ci>𝐭𝐫𝐮𝐞</ci>
     </apply>
     <apply>
      <ci>normal-⟶</ci>
      <list>
       <apply>
        <times></times>
        <ci>𝐰𝐡𝐢𝐥𝐞</ci>
        <ci>B</ci>
        <ci>𝐝𝐨</ci>
        <ci>C</ci>
       </apply>
       <ci>s</ci>
      </list>
      <list>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>𝐰𝐡𝐢𝐥𝐞</ci>
        <ci>B</ci>
        <ci>𝐝𝐨</ci>
        <ci>C</ci>
       </apply>
       <ci>s</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-⇒</ci>
      <list>
       <ci>B</ci>
       <ci>s</ci>
      </list>
      <ci>𝐟𝐚𝐥𝐬𝐞</ci>
     </apply>
     <apply>
      <ci>normal-⟶</ci>
      <list>
       <apply>
        <times></times>
        <ci>𝐰𝐡𝐢𝐥𝐞</ci>
        <ci>B</ci>
        <ci>𝐝𝐨</ci>
        <ci>C</ci>
       </apply>
       <ci>s</ci>
      </list>
      <ci>s</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\langle B,s\rangle\Rightarrow\mathbf{true}}{\langle\mathbf{while}\ B\ %
\mathbf{do}\ C,s\rangle\longrightarrow\langle C;\mathbf{while}\ B\ \mathbf{do}%
\ C,s\rangle}\quad\frac{\langle B,s\rangle\Rightarrow\mathbf{false}}{\langle%
\mathbf{while}\ B\ \mathbf{do}\ C,s\rangle\longrightarrow s}
  </annotation>
 </semantics>
</math>

</p>

<p>Such a definition allows formal analysis of the behavior of programs, permitting the study of <a href="Relation_(mathematics)" title="wikilink">relations</a> between programs. Important relations include <a href="simulation_preorder" title="wikilink">simulation preorders</a> and <a class="uri" href="bisimulation" title="wikilink">bisimulation</a>. These are especially useful in the context of <a href="Concurrency_(computer_science)" title="wikilink">concurrency theory</a>.</p>

<p>Thanks to its intuitive look and easy to follow structure, SOS has gained great popularity and has become a de facto standard in defining operational semantics. As a sign of success, the original report (so-called Aarhus report) on SOS (<a href="#plotkin81" title="wikilink">Plotkin81</a>) has attracted more than 1000 citations according to the CiteSeer <a href="http://citeseer.ist.psu.edu/673965.html">1</a>, making it one of the most cited technical reports in <a href="Computer_Science" title="wikilink">Computer Science</a>.</p>
<h4 id="reduction-semantics">Reduction semantics</h4>

<p><strong>Reduction semantics</strong> are an alternative presentation of operational semantics using so-called reduction contexts. The method was introduced by Robert Hieb and <a href="Matthias_Felleisen" title="wikilink">Matthias Felleisen</a> in 1992 as a technique for formalizing an <a href="equational_theory" title="wikilink">equational theory</a> for <a href="control_flow" title="wikilink">control</a> and <a href="program_state" title="wikilink">state</a>. For example, the grammar of a simple <a class="uri" href="call-by-value" title="wikilink">call-by-value</a> <a href="lambda_calculus" title="wikilink">lambda calculus</a> and its contexts can be given as:</p>

<p>

<math display="inline" id="Operational_semantics:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mo>=</mo>
     <mrow>
      <mpadded width="+2.8pt">
       <mi>v</mi>
      </mpadded>
      <mrow>
       <mo rspace="5.3pt" stretchy="false">|</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mpadded width="+2.8pt">
          <mi>e</mi>
         </mpadded>
         <mi>e</mi>
        </mrow>
        <mo rspace="5.3pt" stretchy="false">)</mo>
       </mrow>
       <mo rspace="5.3pt" stretchy="false">|</mo>
      </mrow>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mrow>
     <mi>v</mi>
     <mo>=</mo>
     <mrow>
      <mi>λ</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mi>C</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo rspace="4.2pt">[</mo>
      <mo rspace="5.3pt">]</mo>
     </mrow>
     <mrow>
      <mo rspace="5.3pt" stretchy="false">|</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+2.8pt">
         <mi>C</mi>
        </mpadded>
        <mi>e</mi>
       </mrow>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
      <mo rspace="5.3pt" stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mi>v</mi>
       </mpadded>
       <mi>C</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>v</ci>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>e</ci>
         <ci>e</ci>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <ci>v</ci>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <list>
      <ci>e</ci>
      <ci>C</ci>
     </list>
     <apply>
      <times></times>
      <list></list>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>C</ci>
        <ci>e</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=v\;|\;(e\;e)\;|\;x\quad\quad v=\lambda x.e\quad\quad C=\left[\,\right]\;|\;(%
C\;e)\;|\;(v\;C)
  </annotation>
 </semantics>
</math>


</p>

<p>The contexts 

<math display="inline" id="Operational_semantics:37">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 include a hole 

<math display="inline" id="Operational_semantics:38">
 <semantics>
  <mrow>
   <mo rspace="4.2pt">[</mo>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list></list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\,\right]
  </annotation>
 </semantics>
</math>

 where a term can be plugged in. The shape of the contexts indicate where reduction can occur (i.e., a term can be plugged into) a term. To describe a semantics for this language, axioms or reduction rules are provided:</p>

<p>

<math display="inline" id="Operational_semantics:39">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+2.8pt">
     <mi>e</mi>
    </mpadded>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⟶</mo>
   <mpadded width="+1.7pt">
    <mi>e</mi>
   </mpadded>
   <mrow>
    <mo>[</mo>
    <mi>x</mi>
    <mo>/</mo>
    <mi>v</mi>
    <mo>]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⟶</ci>
    <csymbol cd="unknown">e</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <divide></divide>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci></ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">β</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.e\;v)\longrightarrow e\,\left[x/v\right]\quad(\mathrm{\beta})
  </annotation>
 </semantics>
</math>

</p>

<p>This single axiom is the beta rule from the lambda calculus. The reduction contexts show how this rule composes with more complicated terms. In particular, this rule can trigger for the argument position of an application like 

<math display="inline" id="Operational_semantics:40">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+2.8pt">
     <mi>x</mi>
    </mpadded>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+2.8pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\lambda x.x\;\lambda x.x)\lambda x.(x\;x))
  </annotation>
 </semantics>
</math>

 because there is a context 

<math display="inline" id="Operational_semantics:41">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mo rspace="5.3pt" stretchy="false">]</mo>
     </mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+2.8pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <list></list>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ([\,]\;\lambda x.(x\;x))
  </annotation>
 </semantics>
</math>


 that matches the term. In this case, the contexts uniquely decompose terms so that only one reduction is possible at any given step. Extending the axiom to match the reduction contexts gives the <em>compatible closure</em>. Taking the reflexive, transitive closure of this relation gives the <em>reduction relation</em> for this language.</p>

<p>The technique is useful for the ease in which reduction contexts can model state or control constructs (e.g., <a class="uri" href="continuations" title="wikilink">continuations</a>). In addition, reduction semantics have been used to model <a class="uri" href="object-oriented" title="wikilink">object-oriented</a> languages,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a href="design_by_contract" title="wikilink">contract systems</a>, and other language features.</p>
<h3 id="big-step-semantics">Big-step semantics</h3>
<h4 id="natural-semantics">Natural semantics</h4>

<p><strong>Natural semantics</strong> (or <strong>big-step semantics</strong>) ... </p>
<h2 id="comparison">Comparison</h2>

<p>There are a number of distinctions between small-step and big-step semantics that influence whether one or the other forms a more suitable basis for specifying the semantics of a programming language.</p>

<p>Big-step semantics have the advantage of often being simpler (needing fewer inference rules) and often directly correspond to an efficient implementation of an interpreter for the language (hence Kahn calling them "natural".) Both can lead to simpler proofs, for example when proving the preservation of correctness under some <a href="program_transformation" title="wikilink">program transformation</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The main disadvantage of big-step semantics is that non-terminating (<a href="divergence_(computer_science)" title="wikilink">diverging</a>) computations do not have an inference tree, making it impossible to state and prove properties about such computations.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Small-step semantics give more control of the details and order of evaluation. In the case of instrumented operational semantics, this allows the operational semantics to track and the semanticist to state and prove more accurate theorems about the run-time behaviour of the language. These properties make small-step semantics more convenient when proving <a href="type_soundness" title="wikilink">type soundness</a> of a type system against an operational semantics.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Algebraic_semantics_(computer_science)" title="wikilink">Algebraic semantics</a></li>
<li><a href="Axiomatic_semantics" title="wikilink">Axiomatic semantics</a></li>
<li><a href="Denotational_semantics" title="wikilink">Denotational semantics</a></li>
<li><a href="Interpreter_semantics" title="wikilink">Interpreter semantics</a></li>
<li><a href="Formal_semantics_of_programming_languages" title="wikilink">Formal semantics of programming languages</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Gilles_Kahn" title="wikilink">Gilles Kahn</a>. "Natural Semantics". <em>Proceedings of the 4th Annual Symposium on Theoretical Aspects of Computer Science</em>. Springer-Verlag. London. 1987.</li>
<li><cite id="plotkin81"> <a href="Gordon_Plotkin" title="wikilink">Gordon D. Plotkin.</a> <a href="http://citeseer.ist.psu.edu/673965.html">A Structural Approach to Operational Semantics</a>. (1981) Tech. Rep. DAIMI FN-19, Computer Science Department, Aarhus University, Aarhus, Denmark. (Reprinted with corrections in J. Log. Algebr. Program. 60-61: 17-139 (2004), <a href="http://homepages.inf.ed.ac.uk/gdp/publications/sos_jlap.pdf">preprint</a>). </cite></li>
<li><cite id="plotkin04"> <a href="Gordon_Plotkin" title="wikilink">Gordon D. Plotkin.</a> The Origins of Structural Operational Semantics. J. Log. Algebr. Program. 60-61:3-15, 2004. (<a href="http://homepages.inf.ed.ac.uk/gdp/publications/Origins_SOS.pdf">preprint</a>). </cite></li>
<li><cite id="scott70"> <a href="Dana_Scott" title="wikilink">Dana S. Scott.</a> Outline of a Mathematical Theory of Computation, Programming Research Group, Technical Monograph PRG–2, Oxford University, 1970.</cite></li>
<li><cite id="algol68"> <a href="Adriaan_van_Wijngaarden" title="wikilink">Adriaan van Wijngaarden</a> et al. <a href="ALGOL_68" title="wikilink">Revised Report on the Algorithmic Language ALGOL 68. IFIP. 1968.</a> (<a href="http://vestein.arb-phys.uni-dortmund.de/~wb/RR/rr.pdf">2</a>)</cite></li>
<li><cite id="hennessybook"><a href="Matthew_Hennessy" title="wikilink">Matthew Hennessy</a>. Semantics of Programming Languages. Wiley, 1990. <a href="https://www.scss.tcd.ie/Matthew.Hennessy/slexternal/resources/sembookWiley.pdf">available online</a>.</cite></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_specification_languages" title="wikilink">Category:Formal specification languages</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:Programming_language_semantics" title="wikilink">Category:Programming language semantics</a> <a href="Category:Operational_semantics" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="Xavier_Leroy" title="wikilink">Xavier Leroy</a>. "Coinductive big-step operational semantics".<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
</ol>
</section>
</body>
</html>
