<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="899">Jump search</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Jump search</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>jump search</strong> or <strong>block search</strong> refers to a <a href="search_algorithm" title="wikilink">search algorithm</a> for <a href="list_(computing)" title="wikilink">ordered lists</a>. It works by first checking all items <em>L</em><sub><em>km</em></sub>, where 

<math display="inline" id="Jump_search:0">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in\mathbb{N}
  </annotation>
 </semantics>
</math>

 and <em>m</em> is the block size, until an item is found that is larger than the <a href="search_key" title="wikilink">search key</a>. To find the exact position of the search key in the list a <a href="linear_search" title="wikilink">linear search</a> is performed on the <a class="uri" href="sublist" title="wikilink">sublist</a> <em>L</em><sub>[(<em>k</em>-1)<em>m</em>, <em>km</em>]</sub>.</p>

<p>The optimal value of <em>m</em> is √<em>n</em>, where <em>n</em> is the length of the list <em>L</em>. Because both steps of the <a class="uri" href="algorithm" title="wikilink">algorithm</a> look at, at most, √<em>n</em> items the algorithm runs in O(√<em>n</em>) time. This is better than a <a href="linear_search" title="wikilink">linear search</a>, but worse than a <a href="binary_search" title="wikilink">binary search</a>. The advantage over the latter is that a jump search only needs to jump backwards once, while a binary can jump backwards up to log <em>n</em> times. This can be important if a jumping backwards takes significantly more time than jumping forward.</p>

<p>The algorithm can be modified by performing multiple levels of jump search on the sublists, before finally performing the <a href="linear_search" title="wikilink">linear search</a>. For an <em>k</em>-level jump search the optimum block size <em>m</em><sub><em>l</em></sub> for the <em>l</em><sup>th</sup> level (counting from 1) is <em>n</em><sup>(k-l)/k</sup>. The modified algorithm will perform <em>k</em> backward jumps and runs in O(<em>kn</em><sup>1/(<em>k</em>+1)</sup>) time.</p>
<h2 id="implementation">Implementation</h2>

<p><strong><code>Algorithm</code></strong><code> JumpSeach</code><br/>
<code>  Input: An ordered list </code><em><code>L</code></em><code>, its length </code><em><code>n</code></em><code> and a search key </code><em><code>s</code></em><code>.</code><br/>
<code>  Output: The position of </code><em><code>s</code></em><code> in </code><em><code>L</code></em><code>, or </code><strong><code>nothing</code></strong><code> if </code><em><code>s</code></em><code> is not in </code><em><code>L</code></em><code>.</code><br/>
<br/>
<code>  </code><em><code>a</code></em><code> ← 0</code><br/>
<code>  </code><em><code>b</code></em><code> ← ⌊√</code><em><code>n</code></em><code>⌋</code><br/>
<br/>
<code>  </code><strong><code>while</code></strong><code> </code><em><code>L</code></em><sub><code>min(</code><em><code>b</code></em><code>,</code><em><code>n</code></em><code>)-1</code></sub><code> </code><em><code>a</code></em><code> </code><em><code>a</code></em><code> = </code><em><code>s</code></em><code> </code><strong><code>then</code></strong><br/>
<code>    </code><strong><code>return</code></strong><code> </code><em><code>a</code></em><br/>
<code>  </code><strong><code>else</code></strong><br/>
<code>    </code><strong><code>return</code></strong><code> </code><strong><code>nothing</code></strong></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Jump_list" title="wikilink">Jump list</a></li>
<li><a href="Interpolation_search" title="wikilink">Interpolation search</a></li>
<li><a href="Linear_search" title="wikilink">Linear search</a> - runs in O(<em>n</em>) time, only looks forward</li>
<li><a href="Binary_search" title="wikilink">Binary search</a> - runs in O(log <em>n</em>) time, looks both forward and backward</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li><a href="Ben_Shneiderman" title="wikilink">Ben Shneiderman</a>, <em>Jump Searching: A Fast Sequential Search Technique</em>, CACM, 21(10):831-834, October 1978.</li>
</ul>

<p>"</p>

<p><a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a></p>
</body>
</html>
