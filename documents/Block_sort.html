<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="913">Block sort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Block sort</h1>
<hr/>

<p><strong>Block sort</strong>, or block merge sort, is a <a href="sorting_algorithm" title="wikilink">sorting algorithm</a> combining at least two <a href="Merge_algorithm" title="wikilink">merge</a> operations with an <a href="insertion_sort" title="wikilink">insertion sort</a> to arrive at O(n log n) <a class="uri" href="in-place" title="wikilink">in-place</a> <a href="Sorting_algorithm#Stability" title="wikilink">stable</a> sorting. It gets its name from the observation that merging two sorted lists, A and B, is equivalent to breaking A into evenly sized <em>blocks</em>, inserting each A block into B under special rules, and merging AB pairs.</p>

<p>One practical algorithm for block sort was proposed by Pok-Son Kim and Arne Kutzner in 2008.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="overview">Overview</h2>

<p>The outer loop of block sort is identical to a <a href="Merge_sort#Bottom-up_implementation" title="wikilink">bottom-up merge sort</a>, where each <em>level</em> of the sort merges pairs of subarrays, A and B, in sizes of 1, then 2, then 4, 8, 16, and so on, until both subarrays combined are the array itself.</p>

<p>Rather than merging A and B directly as with traditional methods, a block-based merge algorithm divides A into discrete blocks of size 

<math display="inline" id="Block_sort:0">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 (resulting in 

<math display="inline" id="Block_sort:1">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 <em>number</em> of blocks as well),<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> inserts each A block into B such that the first value of each A block is less than or equal to the B value immediately after it, then <em>locally merges</em> each A block with any B values between it and the next A block.</p>

<p>As merges still require a separate buffer large enough to hold the A block to be merged, two areas within the array are reserved for this purpose (known as <em>internal buffers</em>).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The first two A blocks are thus modified to contain the first instance of each value within A, with the original contents of those blocks shifted over if necessary. The remaining A blocks are then inserted into B and merged using one of the two buffers as swap space. This process causes the values in that buffer to be rearranged.</p>

<p>Once every A and B block of every A and B subarray have been merged for that level of the merge sort, the values in that buffer must be sorted to restore their original order, so an insertion sort must be applied. The values in the buffers are then redistributed to their first sorted position within the array. This process repeats for each level of the outer bottom-up merge sort, at which point the array will have been stably sorted.</p>
<h2 id="algorithm">Algorithm</h2>

<p>The following operators are used in the code examples:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>|</p></th>
<th style="text-align: left;">
<p><a href="Bitwise_operation#OR" title="wikilink">bitwise OR</a></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>&gt;&gt;</p></td>
<td style="text-align: left;">
<p><a href="Bitwise_operation#Logical_shift" title="wikilink">shift right</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>%</p></td>
<td style="text-align: left;">
<p><a href="Modulo_operation" title="wikilink">modulo</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>++ and +=</p></td>
<td style="text-align: left;">
<p><a href="Increment_and_decrement_operators" title="wikilink">increment</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>[<em>x</em>, <em>y</em>)</p></td>
<td style="text-align: left;">
<p><a href="Interval_(mathematics)#Excluding_the_endpoints" title="wikilink">range</a> from ≥ <em>x</em> and &lt; <em>y</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>|range|</p></td>
<td style="text-align: left;">
<p>range.end - range.start</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>array[i]</p></td>
<td style="text-align: left;">
<p><strong>i</strong>th item of <em>array</em></p></td>
</tr>
</tbody>
</table>

<p>Additionally, block sort relies on the following operations as part of its overall algorithm:</p>
<ul>
<li><strong><a href="Swap_(computer_science)" title="wikilink">Swap</a></strong>: exchange the positions of two values in an array.</li>
<li><strong>Block swap</strong>: exchange a range of values within an array with values in a different range of the array.</li>
<li><strong><a href="Binary_search_algorithm" title="wikilink">Binary search</a></strong>: assuming the array is sorted, check the middle value of the current search range, then if the value is lesser check the lower range, and if the value is greater check the upper range. Block sort uses two variants: one which finds the <em>first</em> position to insert a value in the sorted array, and one which finds the <em>last</em> position.</li>
<li><strong><a href="Linear_search" title="wikilink">Linear search</a></strong>: find a particular value in an array by checking every single element in order, until it is found.</li>
<li><strong><a href="Insertion_sort" title="wikilink">Insertion sort</a></strong>: for each item in the array, loop backward and find where it needs to be inserted, then insert it at that position.</li>
<li><strong>Array rotation</strong>: move the items in an array to the left or right by some number of spaces, with values on the edges wrapping around to the other side. Rotations can be implemented as three <a href="In-place_algorithm#Examples" title="wikilink">reversals</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
</ul>

<p><code>   </code><strong><code>Rotate</code></strong><code>(array, amount, range)</code><br/>
<code>       </code><strong><code>Reverse</code></strong><code>(array, range)</code><br/>
<code>       </code><strong><code>Reverse</code></strong><code>(array, [range.start, range.start + amount))</code><br/>
<code>       </code><strong><code>Reverse</code></strong><code>(array, [range.start + amount, range.end))</code></p>
<ul>
<li><strong>Floor power of two</strong>: <a href="Floor_and_ceiling_functions" title="wikilink">floor</a> a value to the next power of two. 63 becomes 32, 64 stays 64, and so forth.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>

<p><code>   </code><strong><code>FloorPowerOfTwo</code></strong><code>(x)</code><br/>
<code>       x = x | (x &gt;&gt; 1)</code><br/>
<code>       x = x | (x &gt;&gt; 2)</code><br/>
<code>       x = x | (x &gt;&gt; 4)</code><br/>
<code>       x = x | (x &gt;&gt; 8)</code><br/>
<code>       x = x | (x &gt;&gt; 16)</code><br/>
<code>       </code><strong><code>if</code></strong><code> (this is a </code><a href="64-bit_computing" title="wikilink"><code>64-bit</code></a><code> system)</code><br/>
<code>           x = x | (x &gt;&gt; 32)</code><br/>
<code>       return x - (x &gt;&gt; 1)</code></p>
<h3 id="outer-loop">Outer Loop</h3>

<p>As previously stated, the outer loop of a block sort is identical to a bottom-up merge sort. However, it benefits from the variant that ensures each A and B subarray are the same size to within one item:</p>

<p><code>   </code><strong><code>BlockSort</code></strong><code>(array)</code><br/>
<code>       power_of_two = </code><strong><code>FloorPowerOfTwo</code></strong><code>(array.size)</code><br/>
<code>       scale = array.size/power_of_two </code><span style="color:green;"><code>// 1.0 ≤ scale </code></span></p>

<p><span style="color:green;">// insertion sort 16-31 items at a time</span></p>

<p><code>       </code><strong><code>for</code></strong><code> (merge = 0; merge </code><code>// the two ranges are in reverse order, so a rotation is enough to merge them</code><br/>
<code>                   </code><strong><code>Rotate</code></strong><code>(array, mid - start, [start, end))</code><br/>
<code>               </code><strong><code>else</code> <code>if</code></strong><code> (array[mid - 1] &gt; array[mid])</code><br/>
<code>                   </code><strong><code>Merge</code></strong><code>(array, A = [start, mid), B = [mid, end))</code></p>

<p><a href="Fixed-point_arithmetic" title="wikilink">Fixed-point math</a> may also be used, by representing the scale factor as a fraction:</p>

<p><code>   power_of_two = </code><strong><code>FloorPowerOfTwo</code></strong><code>(array.size)</code><br/>
<code>   denominator = power_of_two/16</code><br/>
<code>   numerator_step = array.size % denominator</code><br/>
<code>   decimal_step = </code><strong><code>floor</code></strong><code>(array.size/denominator)</code><br/>
<code>  </code><br/>
<code>   </code><span style="color:green;"><code>[insertion sort 16-31 items at a time]</code></span><br/>
<code>  </code><br/>
<code>   </code><strong><code>while</code></strong><code> (decimal_step </code><code>// get the ranges for A and B</code><br/>
<code>           start = decimal</code><br/>
<code>          </code><br/>
<code>           decimal += decimal_step</code><br/>
<code>           numerator += numerator_step</code><br/>
<code>           </code><strong><code>if</code></strong><code> (numerator ≥ denominator)</code><br/>
<code>               numerator -= denominator</code><br/>
<code>               decimal++</code><br/>
<code>          </code><br/>
<code>           mid = decimal</code><br/>
<code>          </code><br/>
<code>           decimal += decimal_step</code><br/>
<code>           numerator += numerator_step</code><br/>
<code>           </code><strong><code>if</code></strong><code> (numerator ≥ denominator)</code><br/>
<code>               numerator -= denominator</code><br/>
<code>               decimal++</code><br/>
<code>          </code><br/>
<code>           end = decimal</code><br/>
<code>          </code><br/>
<code>           </code><strong><code>if</code></strong><code> (array[end - 1] </code><code> array[mid])</code><br/>
<code>               </code><strong><code>Merge</code></strong><code>(array, A = [start, mid), B = [mid, end))</code><br/>
<code>      </code><br/>
<code>       decimal_step += decimal_step</code><br/>
<code>       numerator_step += numerator_step</code><br/>
<code>       </code><strong><code>if</code></strong><code> (numerator_step ≥ denominator)</code><br/>
<code>           numerator_step -= denominator</code><br/>
<code>           decimal_step++</code></p>
<h3 id="extract-buffers">Extract Buffers</h3>
<figure><b>(Figure)</b>
<figcaption>The buffer extraction process for block sort.</figcaption>
</figure>

<p>The two internal buffers needed for each level of the merge step are created by moving the first 2

<math display="inline" id="Block_sort:2">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 instances of each value within an A subarray to the start of A. First it iterates over the elements in A and counts off the unique values it needs, then it applies array rotations to move those unique values to the start.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> If A did not contain enough unique values to fill the two buffers (of size 

<math display="inline" id="Block_sort:3">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 each), B can be used just as well. In this case it moves the <em>last</em> instance of each value to the <em>end</em> of B, with that part of B not being included during the merges.</p>

<p><code>   </code><strong><code>while</code></strong><code> (decimal_step </code><code>$\sqrt{decimal_step}$</code><br/>
<code>       buffer_size = decimal_step/block_size + 1</code><br/>
<code>       </code><span style="color:green;"><code>[extract two buffers of size 'buffer_size' each]</code></span></p>

<p>If B does not contain enough unique values either, it pulls out the largest number of unique values it <em>could</em> find, then adjusts the size of the A and B blocks such that the number of resulting A blocks is less than or equal to the number of unique items pulled out for the buffer. Only one buffer will be used in this case – the second buffer won't exist.</p>

<p><code>   buffer_size = </code><span style="color:green;"><code>[number of unique values found]</code></span><br/>
<code>   block_size = decimal_step/buffer_size + 1</code><br/>
<code>  </code><br/>
<code>   decimal = numerator = 0</code><br/>
<code>   </code><strong><code>while</code></strong><code> (decimal </code><code>[get the ranges for A and B]</code></p>

<p><span style="color:green;">[adjust A and B to not include the ranges used by the buffers]</span></p>
<h3 id="tag-a-blocks">Tag A Blocks</h3>

<p> Once the one or two internal buffers have been created, it begins merging each A and B subarray for this level of the merge sort. To do so, it divides each A and B subarray into evenly sized blocks of the size calculated in the previous step, where the first A block and last B block are unevenly sized if needed. It then loops over each of the evenly sized A blocks and swaps the second value with a corresponding value from the first of the two internal buffers. This is known as <em>tagging</em> the blocks.</p>

<p><code>   </code><span style="color:green;"><code>// blockA is the range of the remaining A blocks,</code></span></p>

<p><span style="color:green;">// and firstA is the unevenly sized first A block</span></p>

<p><code>   blockA = [A.start, A.end)</code><br/>
<code>   firstA = [A.start, A.start + |blockA| % block_size)</code><br/>
<code>  </code><br/>
<code>   </code><span style="color:green;"><code>// swap the second value of each A block with the value in buffer1</code></span><br/>
<code>   </code><strong><code>for</code></strong><code> (index = 0, indexA = firstA.end + 1; indexA </code><code>// if there's a previous B block and the first value of the minimum A block is ≤</code></p>

<p><span style="color:green;">// the last value of the previous B block, then drop that minimum A block behind.</span> <span style="color:green;">// or if there are no B blocks left then keep dropping the remaining A blocks.</span></p>

<p><code>       </code><strong><code>if</code></strong><code> ((|lastB| &gt; 0 </code><strong><code>and</code></strong><code> array[lastB.end - 1] ≥ array[minA]) </code><strong><code>or</code></strong><code> |blockB| = 0)</code><br/>
<code>           </code><span style="color:green;"><code>// figure out where to split the previous B block, and rotate it at the split</code></span><br/>
<code>           B_split = </code><strong><code>BinaryFirst</code></strong><code>(array, array[minA], lastB)</code><br/>
<code>           B_remaining = lastB.end - B_split</code><br/>
<code>          </code><br/>
<code>           </code><span style="color:green;"><code>// swap the minimum A block to the beginning of the rolling A blocks</code></span><br/>
<code>           </code><strong><code>BlockSwap</code></strong><code>(array, blockA.start, minA, block_size)</code><br/>
<code>          </code><br/>
<code>           </code><span style="color:green;"><code>// restore the second value for the A block</code></span><br/>
<code>           </code><strong><code>Swap</code></strong><code>(array[blockA.start + 1], array[buffer1.start + indexA])</code><br/>
<code>           indexA++</code><br/>
<code>          </code><br/>
<code>           </code><span style="color:green;"><code>// rotate the A block into the previous B block</code></span><br/>
<code>           </code><strong><code>Rotate</code></strong><code>(array, blockA.start - B_split, [B_split, blockA.start + block_size))</code><br/>
<code>          </code><br/>
<code>           </code><span style="color:green;"><code>// locally merge the previous A block with the B values that follow it,</code></span></p>

<p><span style="color:green;">// using the second internal buffer as swap space (if it exists)</span></p>

<p><code>           </code><strong><code>if</code></strong><code> (|buffer2| &gt; 0)</code><br/>
<code>               </code><strong><code>MergeInternal</code></strong><code>(array, lastA, [lastA.end, B_split), buffer2)</code><br/>
<code>           </code><strong><code>else</code></strong><br/>
<code>               </code><strong><code>MergeInPlace</code></strong><code>(array, lastA, [lastA.end, B_split))</code><br/>
<code>          </code><br/>
<code>           </code><span style="color:green;"><code>// update the range for the remaining A blocks,</code></span></p>

<p><span style="color:green;">// and the range remaining from the B block after it was split</span></p>

<p><code>           lastA = [blockA.start - B_remaining, blockA.start - B_remaining + block_size)</code><br/>
<code>           lastB = [lastA.end, lastA.end + B_remaining)</code><br/>
<code>          </code><br/>
<code>           </code><span style="color:green;"><code>// if there are no more A blocks remaining, this step is finished</code></span><br/>
<code>           blockA.start = blockA.start + block_size</code><br/>
<code>           </code><strong><code>if</code></strong><code> (|blockA| = 0)</code><br/>
<code>               </code><strong><code>break</code></strong><br/>
<code>          </code><br/>
<code>           minA = </code><span style="color:green;"><code>[new minimum A block]</code></span><code> </code><em><code>(see</code> <code>below)</code></em><br/>
<code>       </code><strong><code>else</code> <code>if</code></strong><code> (|blockB| </code><code>// move the last B block, which is unevenly sized,</code></p>

<p><span style="color:green;">// to before the remaining A blocks, by using a rotation</span></p>

<p><code>           </code><strong><code>Rotate</code></strong><code>(array, blockB.start - blockA.start, [blockA.start, blockB.end))</code><br/>
<code>          </code><br/>
<code>           lastB = [blockA.start, blockA.start + |blockB|)</code><br/>
<code>           blockA.start += |blockB|</code><br/>
<code>           blockA.end += |blockB|</code><br/>
<code>           minA += |blockB|</code><br/>
<code>           blockB.end = blockB.start</code><br/>
<code>       </code><strong><code>else</code></strong><br/>
<code>           </code><span style="color:green;"><code>// roll the leftmost A block to the end by swapping it with the next B block</code></span><br/>
<code>           </code><strong><code>BlockSwap</code></strong><code>(array, blockA.start, blockB.start, block_size)</code><br/>
<code>           lastB = [blockA.start, blockA.start + block_size)</code><br/>
<code>           </code><strong><code>if</code></strong><code> (minA = blockA.start)</code><br/>
<code>               minA = blockA.end</code><br/>
<code>          </code><br/>
<code>           blockA.start += block_size</code><br/>
<code>           blockA.end += block_size</code><br/>
<code>           blockB.start += block_size</code><br/>
<code>          </code><br/>
<code>           </code><span style="color:green;"><code>// this is equivalent to </code><strong><code>minimum</code></strong><code>(blockB.end + block_size, B.end),</code></span></p>

<p><span style="color:green;">// but that has the potential to <a href="Integer_overflow" title="wikilink">overflow</a></span></p>

<p><code>           </code><strong><code>if</code></strong><code> (blockB.end &gt; B.end - block_size)</code><br/>
<code>               blockB.end = B.end</code><br/>
<code>           </code><strong><code>else</code></strong><br/>
<code>               blockB.end += block_size</code><br/>
<code>  </code><br/>
<code>   </code><span style="color:green;"><code>// merge the last A block with the remaining B values</code></span><br/>
<code>   </code><strong><code>if</code></strong><code> (|buffer2| &gt; 0)</code><br/>
<code>       </code><strong><code>MergeInternal</code></strong><code>(array, lastA, [lastA.end, B.end), buffer2)</code><br/>
<code>   </code><strong><code>else</code></strong><br/>
<code>       </code><strong><code>MergeInPlace</code></strong><code>(array, lastA, [lastA.end, B.end))</code></p>

<p>One optimization that can be applied during this step is the <em>floating-hole technique</em>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> When the minimum A block is dropped behind and needs to be rotated into the previous B block, after which its contents are swapped into the second internal buffer for the local merges, it would be faster to swap the A block to the buffer beforehand, and to take advantage of the fact that the contents of that buffer do not need to retain any order. So rather than rotating the second buffer (which used to be the A block before the block swap) into the previous B block at position <em>index</em>, the values in the B block after <em>index</em> can simply be block swapped with the last items of the buffer.</p>

<p>The <em>floating hole</em> in this case refers to the contents of the second internal buffer <em>floating</em> around the array, and acting as a <em>hole</em> in the sense that the items do not need to retain their order.</p>
<h3 id="local-merges">Local Merges</h3>

<p>Once the A block has been rotated into the B block, the previous A block is then merged with the B values that follow it, using the second buffer as swap space. When the first A block is dropped behind this refers to the unevenly sized A block at the start, when the second A block is dropped behind it means the first A block, and so forth.</p>

<p><code>   </code><strong><code>MergeInternal</code></strong><code>(array, A, B, buffer)</code><br/>
<code>       </code><span style="color:green;"><code>// block swap the values in A with those in 'buffer'</code></span><br/>
<code>       </code><strong><code>BlockSwap</code></strong><code>(array, A.start, buffer.start, |A|)</code><br/>
<code>      </code><br/>
<code>       A_count = 0, B_count = 0, insert = 0</code><br/>
<code>       </code><strong><code>while</code></strong><code> (A_count </code><code>// block swap the remaining part of the buffer with the remaining part of the array</code><br/>
<code>       </code><strong><code>BlockSwap</code></strong><code>(array, buffer.start + A_count, A.start + insert, |A| - A_count)</code></p>

<p>If the second buffer does not exist, a strictly in-place merge operation must be performed, such as a rotation-based version of the Hwang and Lin algorithm,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> the Dudzinski and Dydek algorithm,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> or a repeated binary search and rotate.</p>

<p><code>   </code><strong><code>MergeInPlace</code></strong><code>(array, A, B)</code><br/>
<code>       </code><strong><code>while</code></strong><code> (|A| &gt; 0 </code><strong><code>and</code></strong><code> |B| &gt; 0)</code><br/>
<code>           </code><span style="color:green;"><code>// find the first place in B where the first item in A needs to be inserted</code></span><br/>
<code>           mid = </code><strong><code>BinaryFirst</code></strong><code>(array, array[A.start], B)</code><br/>
<code>          </code><br/>
<code>           </code><span style="color:green;"><code>// rotate A into place</code></span><br/>
<code>           amount = mid - A.end</code><br/>
<code>           </code><strong><code>Rotate</code></strong><code>(array, amount, [A.start, mid))</code><br/>
<code>          </code><br/>
<code>           </code><span style="color:green;"><code>// calculate the new A and B ranges</code></span><br/>
<code>           B = [mid, B.end)</code><br/>
<code>           A = [A.start + amount, mid)</code><br/>
<code>           A.start = </code><strong><code>BinaryLast</code></strong><code>(array, array[A.start], A)</code></p>

<p>After dropping the minimum A block and merging the previous A block with the B values that follow it, the new minimum A block must be found within the blocks that are still being rolled through the array. This is handled by running a linear search through those A blocks and comparing the tag values to find the smallest one.</p>

<p><code>   minA = blockA.start</code><br/>
<code>   </code><strong><code>for</code></strong><code> (findA = minA + block_size; findA </code><code>$\sqrt{(count + 1)/2}$</code><code> + 1</code></p>

<p>| this will be the size of the A blocks at the largest level of merges, so block sort can skip using internal or in-place merges for anything |- ! 512 | a fixed-size buffer large enough to handle the numerous merges at the smaller levels of the merge sort |- ! 0 | if the system cannot allocate any extra memory, no memory works well |}</p>

<p>Rather than tagging the A blocks using the contents of one of the internal buffers, an indirect <em>movement-imitation buffer</em> can be used instead.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> This is an internal buffer defined as <em>s1 t s2</em>, where <em>s1</em> and <em>s2</em> are each as large as the number of A and B blocks, and <em>t</em> contains any values immediately following <em>s1</em> that are equal to the last value of <em>s1</em> (thus ensuring that no value in <em>s2</em> appears in <em>s1</em>). A second internal buffer containing 

<math display="inline" id="Block_sort:4">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 unique values is still used. The first 

<math display="inline" id="Block_sort:5">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 values of <em>s1</em> and <em>s2</em> are then swapped with each other to encode information into the buffer about which blocks are A blocks and which are B blocks. When an A block at index <em>i</em> is swapped with a B block at index <em>j</em> (where the first evenly sized A block is initially at index 0), s1[i] and s1[j] are swapped with s2[i] and s2[j], respectively. This <em>imitates the movements</em> of the A blocks through B. The unique values in the second buffer are used to determine the original order of the A blocks as they are rolled through the B blocks. Once all of the A blocks have been dropped, the movement-imitation buffer is used to decode whether a given block in the array is an A block or a B block, each A block is rotated into B, and the second internal buffer is used as swap space for the local merges.</p>

<p>The <em>second</em> value of each A block doesn't necessarily need to be tagged – the first, last, or any other element could be used instead. However, if the first value is tagged, the values will need to be read from the first internal buffer (where they were swapped) when deciding where to drop the minimum A block.</p>

<p>Many sorting algorithms can be used to sort the contents of the second internal buffer, including unstable sorts like <a class="uri" href="quicksort" title="wikilink">quicksort</a>, since the contents of the buffer are guaranteed to unique. Insertion sort is still recommended, though, for its situational performance and lack of recursion.</p>
<h2 id="analysis">Analysis</h2>

<p>Block sort is a well-defined and testable class of algorithms, with working implementations available as a merge and as a sort.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> This allows its characteristics to be measured and considered.</p>
<h3 id="complexity">Complexity</h3>

<p>Block sort begins by insertion sorting groups of 16-31 items in the array. Insertion sort is an <a href="Big_O_notation#Orders_of_common_functions" title="wikilink">O</a>(n<sup>2</sup>) operation, so this leads to anywhere from O(16<sup>2</sup> * n/16) to O(31<sup>2</sup> * n/31), which is O(n) once the <a href="Big_O_notation#Example" title="wikilink">constant factors are omitted</a>. It must also apply an insertion sort on the second internal buffer after each level of merging is completed. However, as this buffer was limited to 

<math display="inline" id="Block_sort:6">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 in size, the O(

<math display="inline" id="Block_sort:7">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

<sup>2</sup>) operation also ends up being O(n).</p>

<p>Next it must extract two internal buffers for each level of the merge sort. It does so by iterating over the items in the A and B subarrays and incrementing a counter whenever the value changes, and upon finding enough values it rotates them to the start of A or the end of B. In the worst case this will end up searching the entire array before finding 

<math display="inline" id="Block_sort:8">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 non-contiguous unique values, which requires O(n) comparisons and 

<math display="inline" id="Block_sort:9">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 rotations for 

<math display="inline" id="Block_sort:10">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 values. This resolves to O(n + 

<math display="inline" id="Block_sort:11">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

 * 

<math display="inline" id="Block_sort:12">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

), or O(n).</p>

<p>When none of the A or B subarrays contained 

<math display="inline" id="Block_sort:13">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 unique values to create the internal buffers, a normally suboptimal in-place merge operation is performed where it repeatedly binary searches and rotates A into B. However, the known lack of unique values within any of the subarrays places a hard limit on the number of binary searches and rotations that will be performed during this step, which is again 

<math display="inline" id="Block_sort:14">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 items rotated up to 

<math display="inline" id="Block_sort:15">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 times, or O(n). The size of each block is also adjusted to be smaller in the case where it found 

<math display="inline" id="Block_sort:16">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 unique values but not 2

<math display="inline" id="Block_sort:17">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

, which further limits the number of unique values contained within any A or B block.</p>

<p>Tagging the A blocks is performed 

<math display="inline" id="Block_sort:18">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 times for each A subarray, then the A blocks are rolled through and inserted into the B blocks up to 

<math display="inline" id="Block_sort:19">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 times. The local merges retain the same O(n) complexity of a standard merge, albeit with more assignments since the values must be swapped rather than copied. The linear search for finding the new minimum A block iterates over 

<math display="inline" id="Block_sort:20">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 blocks 

<math display="inline" id="Block_sort:21">
 <semantics>
  <msqrt>
   <mi>A</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{A}
  </annotation>
 </semantics>
</math>

 times. And the buffer redistribution process is identical to the buffer extraction but in reverse, and therefore has the same O(n) complexity.</p>

<p>After <a href="Big_O_notation#Example" title="wikilink">omitting all but the highest complexity</a> and considering that there are <em>log n</em> levels in the outer merge loop, this leads to a final asymptotic complexity of O(n log n) for the worst and average cases. For the best case, where the data is already in order, the merge step performs n/16 comparisons for the first level, then n/32, then n/64, n/128, etc. This is a <a href="1/2_+_1/4_+_1/8_+_1/16_+_·_·_·" title="wikilink">well-known mathematical series</a> which resolves to O(n).</p>
<h3 id="memory">Memory</h3>

<p>As block sort is <a href="Non-recursive_function" title="wikilink">non-recursive</a> and does not require the use of <a href="Memory_management#Dynamic_memory_allocation" title="wikilink">dynamic allocations</a>, this leads to constant <a href="Stack_(abstract_data_type)" title="wikilink">stack</a> and heap space. It uses O(1) auxiliary memory in a <a href="transdichotomous_model" title="wikilink">transdichotomous model</a>, which accepts that the O(log <em>n</em>) bits needed to keep track of the ranges for A and B cannot be any greater than 32 or 64 on 32-bit or 64-bit computing systems, respectively, and therefore simplifies to O(1) space for any array that can feasibly be allocated.</p>
<h3 id="stability">Stability</h3>

<p>Although items in the array are moved out of order during a block sort, each operation is fully reversible and will have restored the original order of equivalent items by its completion.</p>

<p>Stability requires the first instance of each value in an array before sorting to still be the first instance of that value after sorting. Block sort moves these first instances to the start of the array to create the two internal buffers, but when all of the merges are completed for the current level of the block sort, those values are distributed back to the first sorted position within the array. This maintains stability.</p>

<p>Before rolling the A blocks through the B blocks, each A block has its second value swapped with a value from the first buffer. At that point the A blocks are moved out of order to roll through the B blocks. However, once it finds where it should insert the smallest A block into the previous B block, that smallest A block is moved back to the start of the A blocks and its second value is restored. By the time all of the A blocks have been inserted, the A blocks will be in order again and the first buffer will contain its original values in the original order.</p>

<p>Using the second buffer as swap space when merging an A block with some B values causes the contents of that buffer to be rearranged. However, as the algorithm already ensured the buffer only contains unique values, sorting the contents of the buffer is sufficient to restore their original stable order.</p>
<h3 id="adaptivity">Adaptivity</h3>

<p>Block sort is an <a href="adaptive_sort" title="wikilink">adaptive sort</a> on two levels: first, it skips merging A and B subarrays that are already in order. Next, when A and B need to be merged and are broken into evenly sized blocks, the A blocks are only rolled through B as far as is necessary, and each block is only merged with the B values immediately following it. The more ordered the data originally was, the fewer B values there will be that need to be merged into A.</p>
<h2 id="advantages">Advantages</h2>

<p>Block sort is a stable sort that does not require additional memory, which is useful in cases where there is not enough free memory to allocate the O(n) buffer. When using the <em>external buffer</em> variant of block sort, it can scale from using O(n) memory to progressively smaller buffers as needed, and will still work efficiently within those constraints.</p>
<h2 id="disadvantages">Disadvantages</h2>

<p>Block sort does not exploit sorted ranges of data on as fine a level as some other algorithms, such as <a class="uri" href="Timsort" title="wikilink">Timsort</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> It only checks for these sorted ranges at the two predefined levels: the A and B subarrays, and the A and B blocks. It is also harder to implement and parallelize compared to a merge sort.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a> <a href="Category:Comparison_sorts" title="wikilink">Category:Comparison sorts</a> <a href="Category:Stable_sorts" title="wikilink">Category:Stable sorts</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
