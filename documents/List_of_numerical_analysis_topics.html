<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="938">List of numerical analysis topics</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>List of numerical analysis topics</h1>
<hr/>

<p>This is a <strong>list of <a href="numerical_analysis" title="wikilink">numerical analysis</a> topics</strong>.</p>
<h2 id="general">General</h2>
<ul>
<li><a href="Iterative_method" title="wikilink">Iterative method</a></li>
<li><a href="Rate_of_convergence" title="wikilink">Rate of convergence</a> — the speed at which a convergent sequence approaches its limit
<ul>
<li><a href="Order_of_accuracy" title="wikilink">Order of accuracy</a> — rate at which numerical solution of differential equation converges to exact solution</li>
</ul></li>
<li><a href="Series_acceleration" title="wikilink">Series acceleration</a> — methods to accelerate the speed of convergence of a series
<ul>
<li><a href="Aitken's_delta-squared_process" title="wikilink">Aitken's delta-squared process</a> — most useful for linearly converging sequences</li>
<li><a href="Minimum_polynomial_extrapolation" title="wikilink">Minimum polynomial extrapolation</a> — for vector sequences</li>
<li><a href="Richardson_extrapolation" title="wikilink">Richardson extrapolation</a></li>
<li><a href="Shanks_transformation" title="wikilink">Shanks transformation</a> — similar to Aitken's delta-squared process, but applied to the partial sums</li>
<li><a href="Van_Wijngaarden_transformation" title="wikilink">Van Wijngaarden transformation</a> — for accelerating the convergence of an alternating series</li>
</ul></li>
<li><a href="Abramowitz_and_Stegun" title="wikilink">Abramowitz and Stegun</a> — book containing formulas and tables of many special functions
<ul>
<li><a href="Digital_Library_of_Mathematical_Functions" title="wikilink">Digital Library of Mathematical Functions</a> — successor of book by Abramowitz and Stegun</li>
</ul></li>
<li><a href="Curse_of_dimensionality" title="wikilink">Curse of dimensionality</a></li>
<li><a href="Local_convergence" title="wikilink">Local convergence</a> and global convergence — whether you need a good initial guess to get convergence</li>
<li><a class="uri" href="Superconvergence" title="wikilink">Superconvergence</a></li>
<li><a class="uri" href="Discretization" title="wikilink">Discretization</a></li>
<li><a href="Difference_quotient" title="wikilink">Difference quotient</a></li>
<li>Complexity:
<ul>
<li><a href="Computational_complexity_of_mathematical_operations" title="wikilink">Computational complexity of mathematical operations</a></li>
<li><a href="Smoothed_analysis" title="wikilink">Smoothed analysis</a> — measuring the expected performance of algorithms under slight random perturbations of worst-case inputs</li>
</ul></li>
<li><a href="Symbolic-numeric_computation" title="wikilink">Symbolic-numeric computation</a> — combination of symbolic and numeric methods</li>
<li>Cultural and historical aspects:
<ul>
<li><a href="History_of_numerical_solution_of_differential_equations_using_computers" title="wikilink">History of numerical solution of differential equations using computers</a></li>
<li><a href="Hundred-dollar,_Hundred-digit_Challenge_problems" title="wikilink">Hundred-dollar, Hundred-digit Challenge problems</a> — list of ten problems proposed by Nick Trefethen in 2002</li>
<li><a href="International_Workshops_on_Lattice_QCD_and_Numerical_Analysis" title="wikilink">International Workshops on Lattice QCD and Numerical Analysis</a></li>
<li><a href="Timeline_of_numerical_analysis_after_1945" title="wikilink">Timeline of numerical analysis after 1945</a></li>
</ul></li>
<li>General classes of methods:
<ul>
<li><a href="Collocation_method" title="wikilink">Collocation method</a> — discretizes a continuous equation by requiring it only to hold at certain points</li>
<li><a href="Level_set_method" title="wikilink">Level set method</a>
<ul>
<li><a href="Level_set_(data_structures)" title="wikilink">Level set (data structures)</a> — data structures for representing level sets</li>
</ul></li>
<li><a href="Sinc_numerical_methods" title="wikilink">Sinc numerical methods</a> — methods based on the sinc function, sinc(<em>x</em>) = sin(<em>x</em>) / <em>x</em></li>
<li><a href="ABS_methods" title="wikilink">ABS methods</a></li>
</ul></li>
</ul>
<h2 id="error">Error</h2>

<p><a href="Error_analysis_(mathematics)" title="wikilink">Error analysis (mathematics)</a></p>
<ul>
<li><a class="uri" href="Approximation" title="wikilink">Approximation</a></li>
<li><a href="Approximation_error" title="wikilink">Approximation error</a></li>
<li><a href="Condition_number" title="wikilink">Condition number</a></li>
<li><a href="Discretization_error" title="wikilink">Discretization error</a></li>
<li><a href="Floating_point" title="wikilink">Floating point</a> number
<ul>
<li><a href="Guard_digit" title="wikilink">Guard digit</a> — extra precision introduced during a computation to reduce round-off error</li>
<li><a class="uri" href="Truncation" title="wikilink">Truncation</a> — rounding a floating-point number by discarding all digits after a certain digit</li>
<li><a href="Round-off_error" title="wikilink">Round-off error</a>
<ul>
<li><a href="Numeric_precision_in_Microsoft_Excel" title="wikilink">Numeric precision in Microsoft Excel</a></li>
</ul></li>
<li><a href="Arbitrary-precision_arithmetic" title="wikilink">Arbitrary-precision arithmetic</a></li>
</ul></li>
<li><a href="Interval_arithmetic" title="wikilink">Interval arithmetic</a> — represent every number by two floating-point numbers guaranteed to have the unknown number between them
<ul>
<li><a href="Interval_contractor" title="wikilink">Interval contractor</a> — maps interval to subinterval which still contains the unknown exact answer</li>
<li><a href="Interval_propagation" title="wikilink">Interval propagation</a> — contracting interval domains without removing any value consistent with the constraints
<ul>
<li>See also: <a href="Interval_boundary_element_method" title="wikilink">Interval boundary element method</a>, <a href="Interval_finite_element" title="wikilink">Interval finite element</a></li>
</ul></li>
</ul></li>
<li><a href="Loss_of_significance" title="wikilink">Loss of significance</a></li>
<li><a href="Numerical_error" title="wikilink">Numerical error</a></li>
<li><a href="Numerical_stability" title="wikilink">Numerical stability</a></li>
<li>Error propagation:
<ul>
<li><a href="Propagation_of_uncertainty" title="wikilink">Propagation of uncertainty</a>
<ul>
<li><a href="List_of_uncertainty_propagation_software" title="wikilink">List of uncertainty propagation software</a></li>
</ul></li>
<li><a href="Significance_arithmetic" title="wikilink">Significance arithmetic</a></li>
<li><a href="Residual_(numerical_analysis)" title="wikilink">Residual (numerical analysis)</a></li>
</ul></li>
<li><a href="Relative_change_and_difference" title="wikilink">Relative change and difference</a> — the relative difference between <em>x</em> and <em>y</em> is |<em>x</em> − <em>y</em>| / max(|<em>x</em>|, |<em>y</em>|)</li>
<li><a href="Significant_figures" title="wikilink">Significant figures</a>
<ul>
<li><a href="False_precision" title="wikilink">False precision</a> — giving more significant figures than appropriate</li>
</ul></li>
<li><a href="Truncation_error" title="wikilink">Truncation error</a> — error committed by doing only a finite numbers of steps</li>
<li><a href="Well-posed_problem" title="wikilink">Well-posed problem</a></li>
<li><a href="Affine_arithmetic" title="wikilink">Affine arithmetic</a></li>
</ul>
<h2 id="elementary-and-special-functions">Elementary and special functions</h2>
<ul>
<li>Summation:
<ul>
<li><a href="Kahan_summation_algorithm" title="wikilink">Kahan summation algorithm</a></li>
<li><a href="Pairwise_summation" title="wikilink">Pairwise summation</a> — slightly worse than Kahan summation but cheaper</li>
<li><a href="Binary_splitting" title="wikilink">Binary splitting</a></li>
</ul></li>
<li>Multiplication:
<ul>
<li><a href="Multiplication_algorithm" title="wikilink">Multiplication algorithm</a> — general discussion, simple methods</li>
<li><a href="Karatsuba_algorithm" title="wikilink">Karatsuba algorithm</a> — the first algorithm which is faster than straightforward multiplication</li>
<li><a href="Toom–Cook_multiplication" title="wikilink">Toom–Cook multiplication</a> — generalization of Karatsuba multiplication</li>
<li><a href="Schönhage–Strassen_algorithm" title="wikilink">Schönhage–Strassen algorithm</a> — based on Fourier transform, asymptotically very fast</li>
<li><a href="Fürer's_algorithm" title="wikilink">Fürer's algorithm</a> — asymptotically slightly faster than Schönhage–Strassen</li>
</ul></li>
<li><a href="Division_algorithm" title="wikilink">Division algorithm</a> — for computing quotient and/or remainder of two numbers
<ul>
<li><a href="Long_division" title="wikilink">Long division</a></li>
<li><a href="Restoring_division" title="wikilink">Restoring division</a></li>
<li><a href="Non-restoring_division" title="wikilink">Non-restoring division</a></li>
<li><a href="SRT_division" title="wikilink">SRT division</a></li>
<li><a href="Newton–Raphson_division" title="wikilink">Newton–Raphson division</a>: uses <a href="Newton's_method" title="wikilink">Newton's method</a> to find the <a href="Multiplicative_inverse" title="wikilink">reciprocal</a> of D, and multiply that reciprocal by N to find the final quotient Q.</li>
<li><a href="Goldschmidt_division" title="wikilink">Goldschmidt division</a></li>
</ul></li>
<li>Exponentiation:
<ul>
<li><a href="Exponentiation_by_squaring" title="wikilink">Exponentiation by squaring</a></li>
<li><a href="Addition-chain_exponentiation" title="wikilink">Addition-chain exponentiation</a></li>
</ul></li>
<li><a href="Multiplicative_inverse#Algorithms" title="wikilink">Multiplicative inverse Algorithms</a>: for computing a number's multiplicative inverse (reciprocal).
<ul>
<li><a href="Newton's_method#Multiplicative_inverses_of_numbers_and_power_series" title="wikilink">Newton's method</a></li>
</ul></li>
<li>Polynomials:
<ul>
<li><a href="Horner's_method" title="wikilink">Horner's method</a></li>
<li><a href="Estrin's_scheme" title="wikilink">Estrin's scheme</a> — modification of the Horner scheme with more possibilities for parallelization</li>
<li><a href="Clenshaw_algorithm" title="wikilink">Clenshaw algorithm</a></li>
<li><a href="De_Casteljau's_algorithm" title="wikilink">De Casteljau's algorithm</a></li>
</ul></li>
<li>Square roots and other roots:
<ul>
<li><a href="Integer_square_root" title="wikilink">Integer square root</a></li>
<li><a href="Methods_of_computing_square_roots" title="wikilink">Methods of computing square roots</a></li>
<li><a href="Nth_root_algorithm" title="wikilink"><em>n</em>th root algorithm</a></li>
<li><a href="Shifting_nth_root_algorithm" title="wikilink">Shifting <em>n</em>th root algorithm</a> — similar to long division</li>
<li><a class="uri" href="hypot" title="wikilink">hypot</a> — the function (<em>x</em><sup>2</sup> + <em>y</em><sup>2</sup>)<sup>1/2</sup></li>
<li><a href="Alpha_max_plus_beta_min_algorithm" title="wikilink">Alpha max plus beta min algorithm</a> — approximates hypot(x,y)</li>
<li><a href="Fast_inverse_square_root" title="wikilink">Fast inverse square root</a> — calculates 1 / √<em>x</em> using details of the IEEE floating-point system</li>
</ul></li>
<li>Elementary functions (exponential, logarithm, trigonometric functions):
<ul>
<li><a href="Trigonometric_tables" title="wikilink">Trigonometric tables</a> — different methods for generating them</li>
<li><a class="uri" href="CORDIC" title="wikilink">CORDIC</a> — shift-and-add algorithm using a table of arc tangents</li>
<li><a href="BKM_algorithm" title="wikilink">BKM algorithm</a> — shift-and-add algorithm using a table of logarithms and complex numbers</li>
</ul></li>
<li>Gamma function:
<ul>
<li><a href="Lanczos_approximation" title="wikilink">Lanczos approximation</a></li>
<li><a href="Spouge's_approximation" title="wikilink">Spouge's approximation</a> — modification of Stirling's approximation; easier to apply than Lanczos</li>
</ul></li>
<li><a href="AGM_method" title="wikilink">AGM method</a> — computes arithmetic–geometric mean; related methods compute special functions</li>
<li><a href="FEE_method" title="wikilink">FEE method</a> (Fast E-function Evaluation) — fast summation of series like the power series for e<sup><em>x</em></sup></li>
<li><a href="Gal's_accurate_tables" title="wikilink">Gal's accurate tables</a> — table of function values with unequal spacing to reduce round-off error</li>
<li><a href="Spigot_algorithm" title="wikilink">Spigot algorithm</a> — algorithms that can compute individual digits of a real number</li>
<li><a href="Approximations_of_π" title="wikilink">Approximations of 

<math display="inline" id="List_of_numerical_analysis_topics:0">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

</a>:
<ul>
<li><a href="Liu_Hui's_π_algorithm" title="wikilink">Liu Hui's π algorithm</a> — first algorithm that can compute π to arbitrary precision</li>
<li><a href="Leibniz_formula_for_π" title="wikilink">Leibniz formula for π</a> — alternating series with very slow convergence</li>
<li><a href="Wallis_product" title="wikilink">Wallis product</a> — infinite product converging slowly to π/2</li>
<li><a href="Viète's_formula" title="wikilink">Viète's formula</a> — more complicated infinite product which converges faster</li>
<li><a href="Gauss–Legendre_algorithm" title="wikilink">Gauss–Legendre algorithm</a> — iteration which converges quadratically to π, based on arithmetic–geometric mean</li>
<li><a href="Borwein's_algorithm" title="wikilink">Borwein's algorithm</a> — iteration which converges quartically to 1/π, and other algorithms</li>
<li><a href="Chudnovsky_algorithm" title="wikilink">Chudnovsky algorithm</a> — fast algorithm that calculates a hypergeometric series</li>
<li><a href="Bailey–Borwein–Plouffe_formula" title="wikilink">Bailey–Borwein–Plouffe formula</a> — can be used to compute individual hexadecimal digits of π</li>
<li><a href="Bellard's_formula" title="wikilink">Bellard's formula</a> — faster version of Bailey–Borwein–Plouffe formula</li>
<li><a href="List_of_formulae_involving_π" title="wikilink">List of formulae involving π</a></li>
</ul></li>
</ul>
<h2 id="numerical-linear-algebra">Numerical linear algebra</h2>

<p><a href="Numerical_linear_algebra" title="wikilink">Numerical linear algebra</a> — study of numerical algorithms for linear algebra problems</p>
<h3 id="basic-concepts">Basic concepts</h3>
<ul>
<li>Types of matrices appearing in numerical analysis:
<ul>
<li><a href="Sparse_matrix" title="wikilink">Sparse matrix</a>
<ul>
<li><a href="Band_matrix" title="wikilink">Band matrix</a></li>
<li><a href="Bidiagonal_matrix" title="wikilink">Bidiagonal matrix</a></li>
<li><a href="Tridiagonal_matrix" title="wikilink">Tridiagonal matrix</a></li>
<li><a href="Pentadiagonal_matrix" title="wikilink">Pentadiagonal matrix</a></li>
<li><a href="Skyline_matrix" title="wikilink">Skyline matrix</a></li>
</ul></li>
<li><a href="Circulant_matrix" title="wikilink">Circulant matrix</a></li>
<li><a href="Triangular_matrix" title="wikilink">Triangular matrix</a></li>
<li><a href="Diagonally_dominant_matrix" title="wikilink">Diagonally dominant matrix</a></li>
<li><a href="Block_matrix" title="wikilink">Block matrix</a> — matrix composed of smaller matrices</li>
<li><a href="Stieltjes_matrix" title="wikilink">Stieltjes matrix</a> — symmetric positive definite with non-positive off-diagonal entries</li>
<li><a href="Hilbert_matrix" title="wikilink">Hilbert matrix</a> — example of a matrix which is extremely ill-conditioned (and thus difficult to handle)</li>
<li><a href="Wilkinson_matrix" title="wikilink">Wilkinson matrix</a> — example of a symmetric tridiagonal matrix with pairs of nearly, but not exactly, equal eigenvalues</li>
<li><a href="Convergent_matrix" title="wikilink">Convergent matrix</a> – square matrix whose successive powers approach the zero matrix</li>
</ul></li>
<li>Algorithms for matrix multiplication:
<ul>
<li><a href="Strassen_algorithm" title="wikilink">Strassen algorithm</a></li>
<li><a href="Coppersmith–Winograd_algorithm" title="wikilink">Coppersmith–Winograd algorithm</a></li>
<li><a href="Cannon's_algorithm" title="wikilink">Cannon's algorithm</a> — a distributed algorithm, especially suitable for processors laid out in a 2d grid</li>
<li><a href="Freivalds'_algorithm" title="wikilink">Freivalds' algorithm</a> — a randomized algorithm for checking the result of a multiplication</li>
</ul></li>
<li><a href="Matrix_decomposition" title="wikilink">Matrix decompositions</a>:
<ul>
<li><a href="LU_decomposition" title="wikilink">LU decomposition</a> — lower triangular times upper triangular</li>
<li><a href="QR_decomposition" title="wikilink">QR decomposition</a> — orthogonal matrix times triangular matrix
<ul>
<li><a href="RRQR_factorization" title="wikilink">RRQR factorization</a> — rank-revealing QR factorization, can be used to compute rank of a matrix</li>
</ul></li>
<li><a href="Polar_decomposition" title="wikilink">Polar decomposition</a> — unitary matrix times positive-semidefinite Hermitian matrix</li>
<li>Decompositions by similarity:
<ul>
<li><a href="Eigendecomposition_of_a_matrix" title="wikilink">Eigendecomposition</a> — decomposition in terms of eigenvectors and eigenvalues</li>
<li><a href="Jordan_normal_form" title="wikilink">Jordan normal form</a> — bidiagonal matrix of a certain form; generalizes the eigendecomposition
<ul>
<li><a href="Weyr_canonical_form" title="wikilink">Weyr canonical form</a> — permutation of Jordan normal form</li>
</ul></li>
<li><a href="Jordan–Chevalley_decomposition" title="wikilink">Jordan–Chevalley decomposition</a> — sum of commuting nilpotent matrix and diagonalizable matrix</li>
<li><a href="Schur_decomposition" title="wikilink">Schur decomposition</a> — similarity transform bringing the matrix to a triangular matrix</li>
</ul></li>
<li><a href="Singular_value_decomposition" title="wikilink">Singular value decomposition</a> — unitary matrix times diagonal matrix times unitary matrix</li>
</ul></li>
<li><a href="Matrix_splitting" title="wikilink">Matrix splitting</a> – expressing a given matrix as a sum or difference of matrices</li>
</ul>
<h3 id="solving-systems-of-linear-equations">Solving systems of linear equations</h3>
<ul>
<li><a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>
<ul>
<li><a href="Row_echelon_form" title="wikilink">Row echelon form</a> — matrix in which all entries below a nonzero entry are zero</li>
<li><a href="Bareiss_algorithm" title="wikilink">Bareiss algorithm</a> — variant which ensures that all entries remain integers if the initial matrix has integer entries</li>
<li><a href="Tridiagonal_matrix_algorithm" title="wikilink">Tridiagonal matrix algorithm</a> — simplified form of Gaussian elimination for tridiagonal matrices</li>
</ul></li>
<li><a href="LU_decomposition" title="wikilink">LU decomposition</a> — write a matrix as a product of an upper- and a lower-triangular matrix
<ul>
<li><a href="Crout_matrix_decomposition" title="wikilink">Crout matrix decomposition</a></li>
<li><a href="LU_reduction" title="wikilink">LU reduction</a> — a special parallelized version of a LU decomposition algorithm</li>
</ul></li>
<li><a href="Block_LU_decomposition" title="wikilink">Block LU decomposition</a></li>
<li><a href="Cholesky_decomposition" title="wikilink">Cholesky decomposition</a> — for solving a system with a positive definite matrix
<ul>
<li><a href="Minimum_degree_algorithm" title="wikilink">Minimum degree algorithm</a></li>
<li><a href="Symbolic_Cholesky_decomposition" title="wikilink">Symbolic Cholesky decomposition</a></li>
</ul></li>
<li><a href="Iterative_refinement" title="wikilink">Iterative refinement</a> — procedure to turn an inaccurate solution in a more accurate one</li>
<li>Direct methods for sparse matrices:
<ul>
<li><a href="Frontal_solver" title="wikilink">Frontal solver</a> — used in finite element methods</li>
<li><a href="Nested_dissection" title="wikilink">Nested dissection</a> — for symmetric matrices, based on graph partitioning</li>
</ul></li>
<li><a href="Levinson_recursion" title="wikilink">Levinson recursion</a> — for Toeplitz matrices</li>
<li><a href="SPIKE_algorithm" title="wikilink">SPIKE algorithm</a> — hybrid parallel solver for narrow-banded matrices</li>
<li><a href="Cyclic_reduction" title="wikilink">Cyclic reduction</a> — eliminate even or odd rows or columns, repeat</li>
<li>Iterative methods:
<ul>
<li><a href="Jacobi_method" title="wikilink">Jacobi method</a></li>
<li><a href="Gauss–Seidel_method" title="wikilink">Gauss–Seidel method</a>
<ul>
<li><a href="Successive_over-relaxation" title="wikilink">Successive over-relaxation</a> (SOR) — a technique to accelerate the Gauss–Seidel method
<ul>
<li><a href="Symmetric_successive_overrelaxation" title="wikilink">Symmetric successive overrelaxation</a> (SSOR) — variant of SOR for symmetric matrices</li>
</ul></li>
<li><a href="Backfitting_algorithm" title="wikilink">Backfitting algorithm</a> — iterative procedure used to fit a generalized additive model, often equivalent to Gauss–Seidel</li>
</ul></li>
<li><a href="Modified_Richardson_iteration" title="wikilink">Modified Richardson iteration</a></li>
<li><a href="Conjugate_gradient_method" title="wikilink">Conjugate gradient method</a> (CG) — assumes that the matrix is positive definite
<ul>
<li><a href="Derivation_of_the_conjugate_gradient_method" title="wikilink">Derivation of the conjugate gradient method</a></li>
<li><a href="Nonlinear_conjugate_gradient_method" title="wikilink">Nonlinear conjugate gradient method</a> — generalization for nonlinear optimization problems</li>
</ul></li>
<li><a href="Biconjugate_gradient_method" title="wikilink">Biconjugate gradient method</a> (BiCG)
<ul>
<li><a href="Biconjugate_gradient_stabilized_method" title="wikilink">Biconjugate gradient stabilized method</a> (BiCGSTAB) — variant of BiCG with better convergence</li>
</ul></li>
<li><a href="Conjugate_residual_method" title="wikilink">Conjugate residual method</a> — similar to CG but only assumed that the matrix is symmetric</li>
<li><a href="Generalized_minimal_residual_method" title="wikilink">Generalized minimal residual method</a> (GMRES) — based on the Arnoldi iteration</li>
<li><a href="Chebyshev_iteration" title="wikilink">Chebyshev iteration</a> — avoids inner products but needs bounds on the spectrum</li>
<li><a href="Stone_method" title="wikilink">Stone's method</a> (SIP – Srongly Implicit Procedure) — uses an incomplete LU decomposition</li>
<li><a href="Kaczmarz_method" title="wikilink">Kaczmarz method</a></li>
<li><a class="uri" href="Preconditioner" title="wikilink">Preconditioner</a>
<ul>
<li><a href="Incomplete_Cholesky_factorization" title="wikilink">Incomplete Cholesky factorization</a> — sparse approximation to the Cholesky factorization</li>
<li><a href="Incomplete_LU_factorization" title="wikilink">Incomplete LU factorization</a> — sparse approximation to the LU factorization</li>
</ul></li>
<li><a href="Uzawa_iteration" title="wikilink">Uzawa iteration</a> — for saddle node problems</li>
</ul></li>
<li>Underdetermined and overdetermined systems (systems that have no or more than one solution):
<ul>
<li><a href="Kernel_(matrix)#Numerical_computation_of_null_space" title="wikilink">Numerical computation of null space</a> — find all solutions of an underdetermined system</li>
<li><a href="Moore–Penrose_pseudoinverse" title="wikilink">Moore–Penrose pseudoinverse</a> — for finding solution with smallest 2-norm (for underdetermined systems) or smallest residual</li>
<li><a href="Sparse_approximation" title="wikilink">Sparse approximation</a> — for finding the sparsest solution (i.e., the solution with as many zeros as possible)</li>
</ul></li>
</ul>
<h3 id="eigenvalue-algorithms">Eigenvalue algorithms</h3>

<p><a href="Eigenvalue_algorithm" title="wikilink">Eigenvalue algorithm</a> — a numerical algorithm for locating the eigenvalues of a matrix</p>
<ul>
<li><a href="Power_iteration" title="wikilink">Power iteration</a></li>
<li><a href="Inverse_iteration" title="wikilink">Inverse iteration</a></li>
<li><a href="Rayleigh_quotient_iteration" title="wikilink">Rayleigh quotient iteration</a></li>
<li><a href="Arnoldi_iteration" title="wikilink">Arnoldi iteration</a> — based on Krylov subspaces</li>
<li><a href="Lanczos_algorithm" title="wikilink">Lanczos algorithm</a> — Arnoldi, specialized for positive-definite matrices
<ul>
<li><a href="Block_Lanczos_algorithm" title="wikilink">Block Lanczos algorithm</a> — for when matrix is over a finite field</li>
</ul></li>
<li><a href="QR_algorithm" title="wikilink">QR algorithm</a></li>
<li><a href="Jacobi_eigenvalue_algorithm" title="wikilink">Jacobi eigenvalue algorithm</a> — select a small submatrix which can be diagonalized exactly, and repeat
<ul>
<li><a href="Jacobi_rotation" title="wikilink">Jacobi rotation</a> — the building block, almost a Givens rotation</li>
<li><a href="Jacobi_method_for_complex_Hermitian_matrices" title="wikilink">Jacobi method for complex Hermitian matrices</a></li>
</ul></li>
<li><a href="Divide-and-conquer_eigenvalue_algorithm" title="wikilink">Divide-and-conquer eigenvalue algorithm</a></li>
<li><a href="Folded_spectrum_method" title="wikilink">Folded spectrum method</a></li>
<li><a class="uri" href="LOBPCG" title="wikilink">LOBPCG</a> — Locally Optimal Block Preconditioned Conjugate Gradient Method</li>
<li><a href="Eigenvalue_perturbation" title="wikilink">Eigenvalue perturbation</a> — stability of eigenvalues under perturbations of the matrix</li>
</ul>
<h3 id="other-concepts-and-algorithms">Other concepts and algorithms</h3>
<ul>
<li><a class="uri" href="Orthogonalization" title="wikilink">Orthogonalization</a> algorithms:
<ul>
<li><a href="Gram–Schmidt_process" title="wikilink">Gram–Schmidt process</a></li>
<li><a href="Householder_transformation" title="wikilink">Householder transformation</a>
<ul>
<li><a href="Householder_operator" title="wikilink">Householder operator</a> — analogue of Householder transformation for general inner product spaces</li>
</ul></li>
<li><a href="Givens_rotation" title="wikilink">Givens rotation</a></li>
</ul></li>
<li><a href="Krylov_subspace" title="wikilink">Krylov subspace</a></li>
<li><a href="Block_matrix_pseudoinverse" title="wikilink">Block matrix pseudoinverse</a></li>
<li><a class="uri" href="Bidiagonalization" title="wikilink">Bidiagonalization</a></li>
<li><a href="Cuthill–McKee_algorithm" title="wikilink">Cuthill–McKee algorithm</a> — permutes rows/columns in sparse matrix to yield a narrow band matrix</li>
<li><a href="In-place_matrix_transposition" title="wikilink">In-place matrix transposition</a> — computing the transpose of a matrix without using much additional storage</li>
<li><a href="Pivot_element" title="wikilink">Pivot element</a> — entry in a matrix on which the algorithm concentrates</li>
<li><a href="Matrix-free_methods" title="wikilink">Matrix-free methods</a> — methods that only access the matrix by evaluating matrix-vector products</li>
</ul>
<h2 id="interpolation-and-approximation">Interpolation and approximation</h2>

<p><a class="uri" href="Interpolation" title="wikilink">Interpolation</a> — construct a function going through some given data points</p>
<ul>
<li><a href="Nearest-neighbor_interpolation" title="wikilink">Nearest-neighbor interpolation</a> — takes the value of the nearest neighbor</li>
</ul>
<h3 id="polynomial-interpolation">Polynomial interpolation</h3>

<p><a href="Polynomial_interpolation" title="wikilink">Polynomial interpolation</a> — interpolation by polynomials</p>
<ul>
<li><a href="Linear_interpolation" title="wikilink">Linear interpolation</a></li>
<li><a href="Runge's_phenomenon" title="wikilink">Runge's phenomenon</a></li>
<li><a href="Vandermonde_matrix" title="wikilink">Vandermonde matrix</a></li>
<li><a href="Chebyshev_polynomials" title="wikilink">Chebyshev polynomials</a></li>
<li><a href="Chebyshev_nodes" title="wikilink">Chebyshev nodes</a></li>
<li><a href="Lebesgue_constant_(interpolation)" title="wikilink">Lebesgue constant (interpolation)</a></li>
<li>Different forms for the interpolant:
<ul>
<li><a href="Newton_polynomial" title="wikilink">Newton polynomial</a>
<ul>
<li><a href="Divided_differences" title="wikilink">Divided differences</a></li>
<li><a href="Neville's_algorithm" title="wikilink">Neville's algorithm</a> — for evaluating the interpolant; based on the Newton form</li>
</ul></li>
<li><a href="Lagrange_polynomial" title="wikilink">Lagrange polynomial</a></li>
<li><a href="Bernstein_polynomial" title="wikilink">Bernstein polynomial</a> — especially useful for approximation</li>
<li><a href="Brahmagupta's_interpolation_formula" title="wikilink">Brahmagupta's interpolation formula</a> — seventh-century formula for quadratic interpolation</li>
</ul></li>
<li>Extensions to multiple dimensions:
<ul>
<li><a href="Bilinear_interpolation" title="wikilink">Bilinear interpolation</a></li>
<li><a href="Trilinear_interpolation" title="wikilink">Trilinear interpolation</a></li>
<li><a href="Bicubic_interpolation" title="wikilink">Bicubic interpolation</a></li>
<li><a href="Tricubic_interpolation" title="wikilink">Tricubic interpolation</a></li>
<li><a href="Padua_points" title="wikilink">Padua points</a> — set of points in <strong>R</strong><sup>2</sup> with unique polynomial interpolant and minimal growth of Lebesgue constant</li>
</ul></li>
<li><a href="Hermite_interpolation" title="wikilink">Hermite interpolation</a></li>
<li><a href="Birkhoff_interpolation" title="wikilink">Birkhoff interpolation</a></li>
<li><a href="Abel–Goncharov_interpolation" title="wikilink">Abel–Goncharov interpolation</a></li>
</ul>
<h3 id="spline-interpolation">Spline interpolation</h3>

<p><a href="Spline_interpolation" title="wikilink">Spline interpolation</a> — interpolation by piecewise polynomials</p>
<ul>
<li><a href="Spline_(mathematics)" title="wikilink">Spline (mathematics)</a> — the piecewise polynomials used as interpolants</li>
<li><a href="Perfect_spline" title="wikilink">Perfect spline</a> — polynomial spline of degree <em>m</em> whose <em>m</em>th derivate is ±1</li>
<li><a href="Cubic_Hermite_spline" title="wikilink">Cubic Hermite spline</a>
<ul>
<li><a href="Centripetal_Catmull–Rom_spline" title="wikilink">Centripetal Catmull–Rom spline</a> — special case of cubic Hermite splines without self-intersections or cusps</li>
</ul></li>
<li><a href="Monotone_cubic_interpolation" title="wikilink">Monotone cubic interpolation</a></li>
<li><a href="Hermite_spline" title="wikilink">Hermite spline</a></li>
<li><a href="Bézier_curve" title="wikilink">Bézier curve</a>
<ul>
<li><a href="De_Casteljau's_algorithm" title="wikilink">De Casteljau's algorithm</a></li>
<li><a href="composite_Bézier_curve" title="wikilink">composite Bézier curve</a></li>
<li>Generalizations to more dimensions:
<ul>
<li><a href="Bézier_triangle" title="wikilink">Bézier triangle</a> — maps a triangle to <strong>R</strong><sup>3</sup></li>
<li><a href="Bézier_surface" title="wikilink">Bézier surface</a> — maps a square to <strong>R</strong><sup>3</sup></li>
</ul></li>
</ul></li>
<li><a class="uri" href="B-spline" title="wikilink">B-spline</a>
<ul>
<li><a href="Box_spline" title="wikilink">Box spline</a> — multivariate generalization of B-splines</li>
<li><a href="Truncated_power_function" title="wikilink">Truncated power function</a></li>
<li><a href="De_Boor's_algorithm" title="wikilink">De Boor's algorithm</a> — generalizes De Casteljau's algorithm</li>
</ul></li>
<li><a href="Non-uniform_rational_B-spline" title="wikilink">Non-uniform rational B-spline</a> (NURBS)
<ul>
<li><a class="uri" href="T-spline" title="wikilink">T-spline</a> — can be thought of as a NURBS surface for which a row of control points is allowed to terminate</li>
</ul></li>
<li><a href="Kochanek–Bartels_spline" title="wikilink">Kochanek–Bartels spline</a></li>
<li><a href="Coons_patch" title="wikilink">Coons patch</a> — type of manifold parametrization used to smoothly join other surfaces together</li>
<li><a class="uri" href="M-spline" title="wikilink">M-spline</a> — a non-negative spline</li>
<li><a class="uri" href="I-spline" title="wikilink">I-spline</a> — a monotone spline, defined in terms of M-splines</li>
<li><a href="Smoothing_spline" title="wikilink">Smoothing spline</a> — a spline fitted smoothly to noisy data</li>
<li><a href="Blossom_(functional)" title="wikilink">Blossom (functional)</a> — a unique, affine, symmetric map associated to a polynomial or spline</li>
<li>See also: <a href="List_of_numerical_computational_geometry_topics" title="wikilink">List of numerical computational geometry topics</a></li>
</ul>
<h3 id="trigonometric-interpolation">Trigonometric interpolation</h3>

<p><a href="Trigonometric_interpolation" title="wikilink">Trigonometric interpolation</a> — interpolation by trigonometric polynomials</p>
<ul>
<li><a href="Discrete_Fourier_transform" title="wikilink">Discrete Fourier transform</a> — can be viewed as trigonometric interpolation at equidistant points
<ul>
<li><a href="Relations_between_Fourier_transforms_and_Fourier_series" title="wikilink">Relations between Fourier transforms and Fourier series</a></li>
</ul></li>
<li><a href="Fast_Fourier_transform" title="wikilink">Fast Fourier transform</a> (FFT) — a fast method for computing the discrete Fourier transform
<ul>
<li><a href="Bluestein's_FFT_algorithm" title="wikilink">Bluestein's FFT algorithm</a></li>
<li><a href="Bruun's_FFT_algorithm" title="wikilink">Bruun's FFT algorithm</a></li>
<li><a href="Cooley–Tukey_FFT_algorithm" title="wikilink">Cooley–Tukey FFT algorithm</a></li>
<li><a href="Split-radix_FFT_algorithm" title="wikilink">Split-radix FFT algorithm</a> — variant of Cooley–Tukey that uses a blend of radices 2 and 4</li>
<li><a href="Goertzel_algorithm" title="wikilink">Goertzel algorithm</a></li>
<li><a href="Prime-factor_FFT_algorithm" title="wikilink">Prime-factor FFT algorithm</a></li>
<li><a href="Rader's_FFT_algorithm" title="wikilink">Rader's FFT algorithm</a></li>
<li><a href="Bit-reversal_permutation" title="wikilink">Bit-reversal permutation</a> — particular permutation of vectors with 2<sup><em>m</em></sup> entries used in many FFTs.</li>
<li><a href="Butterfly_diagram" title="wikilink">Butterfly diagram</a></li>
<li><a href="Twiddle_factor" title="wikilink">Twiddle factor</a> — the trigonometric constant coefficients that are multiplied by the data</li>
<li><a href="Cyclotomic_fast_Fourier_transform" title="wikilink">Cyclotomic fast Fourier transform</a> — for FFT over finite fields</li>
<li>Methods for computing discrete convolutions with finite impulse response filters using the FFT:
<ul>
<li><a href="Overlap–add_method" title="wikilink">Overlap–add method</a></li>
<li><a href="Overlap–save_method" title="wikilink">Overlap–save method</a></li>
</ul></li>
</ul></li>
<li><a href="Sigma_approximation" title="wikilink">Sigma approximation</a></li>
<li><a href="Dirichlet_kernel" title="wikilink">Dirichlet kernel</a> — convolving any function with the Dirichlet kernel yields its trigonometric interpolant</li>
<li><a href="Gibbs_phenomenon" title="wikilink">Gibbs phenomenon</a></li>
</ul>
<h3 id="other-interpolants">Other interpolants</h3>
<ul>
<li><a href="Simple_rational_approximation" title="wikilink">Simple rational approximation</a>
<ul>
<li><a href="Polynomial_and_rational_function_modeling" title="wikilink">Polynomial and rational function modeling</a> — comparison of polynomial and rational interpolation</li>
</ul></li>
<li><a class="uri" href="Wavelet" title="wikilink">Wavelet</a>
<ul>
<li><a href="Continuous_wavelet" title="wikilink">Continuous wavelet</a></li>
<li><a href="Transfer_matrix" title="wikilink">Transfer matrix</a></li>
<li>See also: <a href="List_of_functional_analysis_topics" title="wikilink">List of functional analysis topics</a>, <a href="List_of_wavelet-related_transforms" title="wikilink">List of wavelet-related transforms</a></li>
</ul></li>
<li><a href="Inverse_distance_weighting" title="wikilink">Inverse distance weighting</a></li>
<li><a href="Radial_basis_function" title="wikilink">Radial basis function</a> (RBF) — a function of the form ƒ(<em>x</em>) = <em>φ</em>(|<em>x</em>−<em>x</em><sub>0</sub>|)
<ul>
<li><a href="Polyharmonic_spline" title="wikilink">Polyharmonic spline</a> — a commonly used radial basis function</li>
<li><a href="Thin_plate_spline" title="wikilink">Thin plate spline</a> — a specific polyharmonic spline: <em>r</em><sup>2</sup> log <em>r</em></li>
<li><a href="Hierarchical_RBF" title="wikilink">Hierarchical RBF</a></li>
</ul></li>
<li><a href="Subdivision_surface" title="wikilink">Subdivision surface</a> — constructed by recursively subdividing a piecewise linear interpolant
<ul>
<li><a href="Catmull–Clark_subdivision_surface" title="wikilink">Catmull–Clark subdivision surface</a></li>
<li><a href="Doo–Sabin_subdivision_surface" title="wikilink">Doo–Sabin subdivision surface</a></li>
<li><a href="Loop_subdivision_surface" title="wikilink">Loop subdivision surface</a></li>
</ul></li>
<li><a class="uri" href="Slerp" title="wikilink">Slerp</a> (spherical linear interpolation) — interpolation between two points on a sphere
<ul>
<li>Generalized quaternion interpolation — generalizes slerp for interpolation between more than two quaternions</li>
</ul></li>
<li><a href="Irrational_base_discrete_weighted_transform" title="wikilink">Irrational base discrete weighted transform</a></li>
<li><a href="Nevanlinna–Pick_interpolation" title="wikilink">Nevanlinna–Pick interpolation</a> — interpolation by analytic functions in the unit disc subject to a bound
<ul>
<li><a href="Pick_matrix" title="wikilink">Pick matrix</a> — the Nevanlinna–Pick interpolation has a solution if this matrix is positive semi-definite</li>
</ul></li>
<li><a href="Multivariate_interpolation" title="wikilink">Multivariate interpolation</a> — the function being interpolated depends on more than one variable
<ul>
<li><a href="Barnes_interpolation" title="wikilink">Barnes interpolation</a> — method for two-dimensional functions using Gaussians common in meteorology</li>
<li><a href="Coons_surface" title="wikilink">Coons surface</a> — combination of linear interpolation and bilinear interpolation</li>
<li><a href="Lanczos_resampling" title="wikilink">Lanczos resampling</a> — based on convolution with a sinc function</li>
<li><a href="Natural_neighbor" title="wikilink">Natural neighbor</a> interpolation</li>
<li><a href="Nearest_neighbor_value_interpolation" title="wikilink">Nearest neighbor value interpolation</a></li>
<li><a href="PDE_surface" title="wikilink">PDE surface</a></li>
<li><a href="Transfinite_interpolation" title="wikilink">Transfinite interpolation</a> — constructs function on planar domain given its values on the boundary</li>
<li><a href="Trend_surface_analysis" title="wikilink">Trend surface analysis</a> — based on low-order polynomials of spatial coordinates; uses scattered observations</li>
<li>Method based on polynomials are listed under <em>Polynomial interpolation</em></li>
</ul></li>
</ul>
<h3 id="approximation-theory">Approximation theory</h3>

<p><a href="Approximation_theory" title="wikilink">Approximation theory</a></p>
<ul>
<li><a href="Orders_of_approximation" title="wikilink">Orders of approximation</a></li>
<li><a href="Lebesgue's_lemma" title="wikilink">Lebesgue's lemma</a></li>
<li><a href="Curve_fitting" title="wikilink">Curve fitting</a>
<ul>
<li><a href="Vector_field_reconstruction" title="wikilink">Vector field reconstruction</a></li>
</ul></li>
<li><a href="Modulus_of_continuity" title="wikilink">Modulus of continuity</a> — measures smoothness of a function</li>
<li><a href="Least_squares_(function_approximation)" title="wikilink">Least squares (function approximation)</a> — minimizes the error in the L<sup>2</sup>-norm</li>
<li><a href="Minimax_approximation_algorithm" title="wikilink">Minimax approximation algorithm</a> — minimizes the maximum error over an interval (the L<sup>∞</sup>-norm)
<ul>
<li><a href="Equioscillation_theorem" title="wikilink">Equioscillation theorem</a> — characterizes the best approximation in the L<sup>∞</sup>-norm</li>
</ul></li>
<li><a href="Unisolvent_point_set" title="wikilink">Unisolvent point set</a> — function from given function space is determined uniquely by values on such a set of points</li>
<li><a href="Stone–Weierstrass_theorem" title="wikilink">Stone–Weierstrass theorem</a> — continuous functions can be approximated uniformly by polynomials, or certain other function spaces</li>
<li>Approximation by polynomials:
<ul>
<li><a href="Linear_approximation" title="wikilink">Linear approximation</a></li>
<li><a href="Bernstein_polynomial" title="wikilink">Bernstein polynomial</a> — basis of polynomials useful for approximating a function</li>
<li><a href="Bernstein's_constant" title="wikilink">Bernstein's constant</a> — error when approximating |<em>x</em>| by a polynomial</li>
<li><a href="Remez_algorithm" title="wikilink">Remez algorithm</a> — for constructing the best polynomial approximation in the L<sup>∞</sup>-norm</li>
<li><a href="Bernstein's_inequality_(mathematical_analysis)" title="wikilink">Bernstein's inequality (mathematical analysis)</a> — bound on maximum of derivative of polynomial in unit disk</li>
<li><a href="Mergelyan's_theorem" title="wikilink">Mergelyan's theorem</a> — generalization of Stone–Weierstrass theorem for polynomials</li>
<li><a href="Müntz–Szász_theorem" title="wikilink">Müntz–Szász theorem</a> — variant of Stone–Weierstrass theorem for polynomials if some coefficients have to be zero</li>
<li><a href="Bramble–Hilbert_lemma" title="wikilink">Bramble–Hilbert lemma</a> — upper bound on L<sup>p</sup> error of polynomial approximation in multiple dimensions</li>
<li><a href="Discrete_Chebyshev_polynomials" title="wikilink">Discrete Chebyshev polynomials</a> — polynomials orthogonal with respect to a discrete measure</li>
<li><a href="Favard's_theorem" title="wikilink">Favard's theorem</a> — polynomials satisfying suitable 3-term recurrence relations are orthogonal polynomials</li>
</ul></li>
<li>Approximation by Fourier series / trigonometric polynomials:
<ul>
<li><a href="Jackson's_inequality" title="wikilink">Jackson's inequality</a> — upper bound for best approximation by a trigonometric polynomial
<ul>
<li><a href="Bernstein's_theorem_(approximation_theory)" title="wikilink">Bernstein's theorem (approximation theory)</a> — a converse to Jackson's inequality</li>
</ul></li>
<li><a href="Fejér's_theorem" title="wikilink">Fejér's theorem</a> — Cesàro means of partial sums of Fourier series converge uniformly for continuous periodic functions</li>
<li><a href="Erdős–Turán_inequality" title="wikilink">Erdős–Turán inequality</a> — bounds distance between probability and Lebesgue measure in terms of Fourier coefficients</li>
</ul></li>
<li>Different approximations:
<ul>
<li><a href="Moving_least_squares" title="wikilink">Moving least squares</a></li>
<li><a href="Padé_approximant" title="wikilink">Padé approximant</a>
<ul>
<li><a href="Padé_table" title="wikilink">Padé table</a> — table of Padé approximants</li>
</ul></li>
<li><a href="Hartogs–Rosenthal_theorem" title="wikilink">Hartogs–Rosenthal theorem</a> — continuous functions can be approximated uniformly by rational functions on a set of Lebesgue measure zero</li>
<li><a href="Szász–Mirakyan_operator" title="wikilink">Szász–Mirakyan operator</a> — approximation by e<sup>−<em>n</em></sup> <em>x</em><sup><em>k</em></sup> on a semi-infinite interval</li>
<li><a href="Szász–Mirakjan–Kantorovich_operator" title="wikilink">Szász–Mirakjan–Kantorovich operator</a></li>
<li><a href="Baskakov_operator" title="wikilink">Baskakov operator</a> — generalize Bernstein polynomials, Szász–Mirakyan operators, and Lupas operators</li>
<li><a href="Favard_operator" title="wikilink">Favard operator</a> — approximation by sums of Gaussians</li>
</ul></li>
<li><a href="Surrogate_model" title="wikilink">Surrogate model</a> — application: replacing a function that is hard to evaluate by a simpler function</li>
<li><a href="Constructive_function_theory" title="wikilink">Constructive function theory</a> — field that studies connection between degree of approximation and smoothness</li>
<li><a href="Universal_differential_equation" title="wikilink">Universal differential equation</a> — differential–algebraic equation whose solutions can approximate any continuous function</li>
<li><a href="Fekete_problem" title="wikilink">Fekete problem</a> — find <em>N</em> points on a sphere that minimize some kind of energy</li>
<li><a href="Carleman's_condition" title="wikilink">Carleman's condition</a> — condition guaranteeing that a measure is uniquely determined by its moments</li>
<li><a href="Krein's_condition" title="wikilink">Krein's condition</a> — condition that exponential sums are dense in weighted L<sup>2</sup> space</li>
<li><a href="Lethargy_theorem" title="wikilink">Lethargy theorem</a> — about distance of points in a metric space from members of a sequence of subspaces</li>
<li><a href="Wirtinger's_representation_and_projection_theorem" title="wikilink">Wirtinger's representation and projection theorem</a></li>
<li>Journals:
<ul>
<li><a href="Constructive_Approximation" title="wikilink">Constructive Approximation</a></li>
<li><a href="Journal_of_Approximation_Theory" title="wikilink">Journal of Approximation Theory</a></li>
</ul></li>
</ul>
<h3 id="miscellaneous">Miscellaneous</h3>
<ul>
<li><a class="uri" href="Extrapolation" title="wikilink">Extrapolation</a>
<ul>
<li><a href="Linear_predictive_analysis" title="wikilink">Linear predictive analysis</a> — linear extrapolation</li>
</ul></li>
<li><a href="Unisolvent_functions" title="wikilink">Unisolvent functions</a> — functions for which the interpolation problem has a unique solution</li>
<li><a href="Regression_analysis" title="wikilink">Regression analysis</a>
<ul>
<li><a href="Isotonic_regression" title="wikilink">Isotonic regression</a></li>
</ul></li>
<li><a href="Curve-fitting_compaction" title="wikilink">Curve-fitting compaction</a></li>
<li><a href="Interpolation_(computer_graphics)" title="wikilink">Interpolation (computer graphics)</a></li>
</ul>
<h2 id="finding-roots-of-nonlinear-equations">Finding roots of nonlinear equations</h2>
<dl>
<dd><em>See <a href="#Numerical_linear_algebra" title="wikilink">#Numerical linear algebra</a> for linear equations</em>
</dd>
</dl>

<p><a href="Root-finding_algorithm" title="wikilink">Root-finding algorithm</a> — algorithms for solving the equation <em>f</em>(<em>x</em>) = 0</p>
<ul>
<li>General methods:
<ul>
<li><a href="Bisection_method" title="wikilink">Bisection method</a> — simple and robust; linear convergence
<ul>
<li><a href="Lehmer–Schur_algorithm" title="wikilink">Lehmer–Schur algorithm</a> — variant for complex functions</li>
</ul></li>
<li><a href="Fixed-point_iteration" title="wikilink">Fixed-point iteration</a></li>
<li><a href="Newton's_method" title="wikilink">Newton's method</a> — based on linear approximation around the current iterate; quadratic convergence
<ul>
<li><a href="Kantorovich_theorem" title="wikilink">Kantorovich theorem</a> — gives a region around solution such that Newton's method converges</li>
<li><a href="Newton_fractal" title="wikilink">Newton fractal</a> — indicates which initial condition converges to which root under Newton iteration</li>
<li><a href="Quasi-Newton_method" title="wikilink">Quasi-Newton method</a> — uses an approximation of the Jacobian:
<ul>
<li><a href="Broyden's_method" title="wikilink">Broyden's method</a> — uses a rank-one update for the Jacobian</li>
<li><a href="Symmetric_rank-one" title="wikilink">Symmetric rank-one</a> — a symmetric (but not necessarily positive definite) rank-one update of the Jacobian</li>
<li><a href="Davidon–Fletcher–Powell_formula" title="wikilink">Davidon–Fletcher–Powell formula</a> — update of the Jacobian in which the matrix remains positive definite</li>
<li><a href="Broyden–Fletcher–Goldfarb–Shanno_algorithm" title="wikilink">Broyden–Fletcher–Goldfarb–Shanno algorithm</a> — rank-two update of the Jacobian in which the matrix remains positive definite</li>
<li><a href="Limited-memory_BFGS" title="wikilink">Limited-memory BFGS</a> method — truncated, matrix-free variant of BFGS method suitable for large problems</li>
</ul></li>
<li><a href="Steffensen's_method" title="wikilink">Steffensen's method</a> — uses divided differences instead of the derivative</li>
</ul></li>
<li><a href="Secant_method" title="wikilink">Secant method</a> — based on linear interpolation at last two iterates</li>
<li><a href="False_position_method" title="wikilink">False position method</a> — secant method with ideas from the bisection method</li>
<li><a href="Muller's_method" title="wikilink">Muller's method</a> — based on quadratic interpolation at last three iterates</li>
<li><a href="Sidi's_generalized_secant_method" title="wikilink">Sidi's generalized secant method</a> — higher-order variants of secant method</li>
<li><a href="Inverse_quadratic_interpolation" title="wikilink">Inverse quadratic interpolation</a> — similar to Muller's method, but interpolates the inverse</li>
<li><a href="Brent's_method" title="wikilink">Brent's method</a> — combines bisection method, secant method and inverse quadratic interpolation</li>
<li><a href="Ridders'_method" title="wikilink">Ridders' method</a> — fits a linear function times an exponential to last two iterates and their midpoint</li>
<li><a href="Halley's_method" title="wikilink">Halley's method</a> — uses <em>f</em>, <em>f</em>' and <em>f</em>''; achieves the cubic convergence</li>
<li><a href="Householder's_method" title="wikilink">Householder's method</a> — uses first <em>d</em> derivatives to achieve order <em>d</em> + 1; generalizes Newton's and Halley's method</li>
</ul></li>
<li>Methods for polynomials:
<ul>
<li><a href="Aberth_method" title="wikilink">Aberth method</a></li>
<li><a href="Bairstow's_method" title="wikilink">Bairstow's method</a></li>
<li><a href="Durand–Kerner_method" title="wikilink">Durand–Kerner method</a></li>
<li><a href="Graeffe's_method" title="wikilink">Graeffe's method</a></li>
<li><a href="Jenkins–Traub_algorithm" title="wikilink">Jenkins–Traub algorithm</a> — fast, reliable, and widely used</li>
<li><a href="Laguerre's_method" title="wikilink">Laguerre's method</a></li>
<li><a href="Splitting_circle_method" title="wikilink">Splitting circle method</a></li>
</ul></li>
<li>Analysis:
<ul>
<li><a href="Wilkinson's_polynomial" title="wikilink">Wilkinson's polynomial</a></li>
</ul></li>
<li><a href="Numerical_continuation" title="wikilink">Numerical continuation</a> — tracking a root as one parameter in the equation changes
<ul>
<li><a href="Piecewise_linear_continuation" title="wikilink">Piecewise linear continuation</a></li>
</ul></li>
</ul>
<h2 id="optimization">Optimization</h2>

<p><a href="Mathematical_optimization" title="wikilink">Mathematical optimization</a> — algorithm for finding maxima or minima of a given function</p>
<h3 id="basic-concepts-1">Basic concepts</h3>
<ul>
<li><a href="Active_set" title="wikilink">Active set</a></li>
<li><a href="Candidate_solution" title="wikilink">Candidate solution</a></li>
<li><a href="Constraint_(mathematics)" title="wikilink">Constraint (mathematics)</a>
<ul>
<li><a href="Constrained_optimization" title="wikilink">Constrained optimization</a> — studies optimization problems with constraints</li>
<li><a href="Binary_constraint" title="wikilink">Binary constraint</a> — a constraint that involves exactly two variables</li>
</ul></li>
<li><a href="Corner_solution" title="wikilink">Corner solution</a></li>
<li><a href="Feasible_region" title="wikilink">Feasible region</a> — contains all solutions that satisfy the constraints but may not be optimal</li>
<li><a href="Global_optimum" title="wikilink">Global optimum</a> and <a href="Local_optimum" title="wikilink">Local optimum</a></li>
<li><a href="Maxima_and_minima" title="wikilink">Maxima and minima</a></li>
<li><a href="Slack_variable" title="wikilink">Slack variable</a></li>
<li><a href="Continuous_optimization" title="wikilink">Continuous optimization</a></li>
<li><a href="Discrete_optimization" title="wikilink">Discrete optimization</a></li>
</ul>
<h3 id="linear-programming">Linear programming</h3>

<p><a href="Linear_programming" title="wikilink">Linear programming</a> (also treats <em>integer programming</em>) — objective function and constraints are linear</p>
<ul>
<li>Algorithms for linear programming:
<ul>
<li><a href="Simplex_algorithm" title="wikilink">Simplex algorithm</a>
<ul>
<li><a href="Bland's_rule" title="wikilink">Bland's rule</a> — rule to avoid cycling in the simplex method</li>
<li><a href="Klee–Minty_cube" title="wikilink">Klee–Minty cube</a> — perturbed (hyper)cube; simplex method has exponential complexity on such a domain</li>
<li><a href="Criss-cross_algorithm" title="wikilink">Criss-cross algorithm</a> — similar to the simplex algorithm</li>
<li><a href="Big_M_method" title="wikilink">Big M method</a> — variation of simplex algorithm for problems with both "less than" and "greater than" constraints</li>
</ul></li>
<li><a href="Interior_point_method" title="wikilink">Interior point method</a>
<ul>
<li><a href="Ellipsoid_method" title="wikilink">Ellipsoid method</a></li>
<li><a href="Karmarkar's_algorithm" title="wikilink">Karmarkar's algorithm</a></li>
<li><a href="Mehrotra_predictor–corrector_method" title="wikilink">Mehrotra predictor–corrector method</a></li>
</ul></li>
<li><a href="Column_generation" title="wikilink">Column generation</a></li>
<li><a href="k-approximation_of_k-hitting_set" title="wikilink">k-approximation of k-hitting set</a> — algorithm for specific LP problems (to find a weighted hitting set)</li>
</ul></li>
<li><a href="Linear_complementarity_problem" title="wikilink">Linear complementarity problem</a></li>
<li>Decompositions:
<ul>
<li><a href="Benders'_decomposition" title="wikilink">Benders' decomposition</a></li>
<li><a href="Dantzig–Wolfe_decomposition" title="wikilink">Dantzig–Wolfe decomposition</a></li>
<li><a href="Theory_of_two-level_planning" title="wikilink">Theory of two-level planning</a></li>
<li><a href="Variable_splitting" title="wikilink">Variable splitting</a></li>
</ul></li>
<li><a href="Basic_solution_(linear_programming)" title="wikilink">Basic solution (linear programming)</a> — solution at vertex of feasible region</li>
<li><a href="Fourier–Motzkin_elimination" title="wikilink">Fourier–Motzkin elimination</a></li>
<li><a href="Hilbert_basis_(linear_programming)" title="wikilink">Hilbert basis (linear programming)</a> — set of integer vectors in a convex cone which generate all integer vectors in the cone</li>
<li><a href="LP-type_problem" title="wikilink">LP-type problem</a></li>
<li><a href="Linear_inequality" title="wikilink">Linear inequality</a></li>
<li><a href="Vertex_enumeration_problem" title="wikilink">Vertex enumeration problem</a> — list all vertices of the feasible set</li>
</ul>
<h3 id="convex-optimization">Convex optimization</h3>

<p><a href="Convex_optimization" title="wikilink">Convex optimization</a></p>
<ul>
<li><a href="Quadratic_programming" title="wikilink">Quadratic programming</a>
<ul>
<li><a href="Linear_least_squares_(mathematics)" title="wikilink">Linear least squares (mathematics)</a></li>
<li><a href="Total_least_squares" title="wikilink">Total least squares</a></li>
<li><a href="Frank–Wolfe_algorithm" title="wikilink">Frank–Wolfe algorithm</a></li>
<li><a href="Sequential_minimal_optimization" title="wikilink">Sequential minimal optimization</a> — breaks up large QP problems into a series of smallest possible QP problems</li>
<li><a href="Bilinear_program" title="wikilink">Bilinear program</a></li>
</ul></li>
<li><a href="Basis_pursuit" title="wikilink">Basis pursuit</a> — minimize L<sub>1</sub>-norm of vector subject to linear constraints
<ul>
<li><a href="Basis_pursuit_denoising" title="wikilink">Basis pursuit denoising</a> (BPDN) — regularized version of basis pursuit
<ul>
<li><a href="In-crowd_algorithm" title="wikilink">In-crowd algorithm</a> — algorithm for solving basis pursuit denoising</li>
</ul></li>
</ul></li>
<li><a href="Linear_matrix_inequality" title="wikilink">Linear matrix inequality</a></li>
<li><a href="Conic_optimization" title="wikilink">Conic optimization</a>
<ul>
<li><a href="Semidefinite_programming" title="wikilink">Semidefinite programming</a></li>
<li><a href="Second-order_cone_programming" title="wikilink">Second-order cone programming</a></li>
<li><a href="Sum-of-squares_optimization" title="wikilink">Sum-of-squares optimization</a></li>
<li>Quadratic programming (see above)</li>
</ul></li>
<li><a href="Bregman_method" title="wikilink">Bregman method</a> — row-action method for strictly convex optimization problems</li>
<li><a href="Proximal_gradient_method" title="wikilink">Proximal gradient method</a> — use splitting of objective function in sum of possible non-differentiable pieces</li>
<li><a href="Subgradient_method" title="wikilink">Subgradient method</a> — extension of steepest descent for problems with a non-differentiable objective function</li>
<li><a href="Biconvex_optimization" title="wikilink">Biconvex optimization</a> — generalization where objective function and constraint set can be biconvex</li>
</ul>
<h3 id="nonlinear-programming">Nonlinear programming</h3>

<p><a href="Nonlinear_programming" title="wikilink">Nonlinear programming</a> — the most general optimization problem in the usual framework</p>
<ul>
<li>Special cases of nonlinear programming:
<ul>
<li>See <em>Linear programming</em> and <em>Convex optimization</em> above</li>
<li><a href="Geometric_programming" title="wikilink">Geometric programming</a> — problems involving signomials or posynomials
<ul>
<li><a class="uri" href="Signomial" title="wikilink">Signomial</a> — similar to polynomials, but exponents need not be integers</li>
<li><a class="uri" href="Posynomial" title="wikilink">Posynomial</a> — a signomial with positive coefficients</li>
</ul></li>
<li><a href="Quadratically_constrained_quadratic_program" title="wikilink">Quadratically constrained quadratic program</a></li>
<li><a href="Linear-fractional_programming" title="wikilink">Linear-fractional programming</a> — objective is ratio of linear functions, constraints are linear
<ul>
<li><a href="Fractional_programming" title="wikilink">Fractional programming</a> — objective is ratio of nonlinear functions, constraints are linear</li>
</ul></li>
<li><a href="Nonlinear_complementarity_problem" title="wikilink">Nonlinear complementarity problem</a> (NCP) — find <em>x</em> such that <em>x</em> ≥ 0, <em>f</em>(<em>x</em>) ≥ 0 and <em>x</em><sup>T</sup> <em>f</em>(<em>x</em>) = 0</li>
<li><a href="Least_squares" title="wikilink">Least squares</a> — the objective function is a sum of squares
<ul>
<li><a href="Non-linear_least_squares" title="wikilink">Non-linear least squares</a></li>
<li><a href="Gauss–Newton_algorithm" title="wikilink">Gauss–Newton algorithm</a>
<ul>
<li><a href="BHHH_algorithm" title="wikilink">BHHH algorithm</a> — variant of Gauss–Newton in econometrics</li>
<li><a href="Generalized_Gauss–Newton_method" title="wikilink">Generalized Gauss–Newton method</a> — for constrained nonlinear least-squares problems</li>
</ul></li>
<li><a href="Levenberg–Marquardt_algorithm" title="wikilink">Levenberg–Marquardt algorithm</a></li>
<li><a href="Iteratively_reweighted_least_squares" title="wikilink">Iteratively reweighted least squares</a> (IRLS) — solves a weigted least-squares problem at every iteration</li>
<li><a href="Partial_least_squares" title="wikilink">Partial least squares</a> — statistical techniques similar to principal components analysis
<ul>
<li><a href="Non-linear_iterative_partial_least_squares" title="wikilink">Non-linear iterative partial least squares</a> (NIPLS)</li>
</ul></li>
</ul></li>
<li><a href="Mathematical_programming_with_equilibrium_constraints" title="wikilink">Mathematical programming with equilibrium constraints</a> — constraints include variational inequalities or complementarities</li>
<li>Univariate optimization:
<ul>
<li><a href="Golden_section_search" title="wikilink">Golden section search</a></li>
<li><a href="Successive_parabolic_interpolation" title="wikilink">Successive parabolic interpolation</a> — based on quadratic interpolation through the last three iterates</li>
</ul></li>
</ul></li>
<li>General algorithms:
<ul>
<li>Concepts:
<ul>
<li><a href="Descent_direction" title="wikilink">Descent direction</a></li>
<li><a href="Guess_value" title="wikilink">Guess value</a> — the initial guess for a solution with which an algorithm starts</li>
<li><a href="Line_search" title="wikilink">Line search</a>
<ul>
<li><a href="Backtracking_line_search" title="wikilink">Backtracking line search</a></li>
<li><a href="Wolfe_conditions" title="wikilink">Wolfe conditions</a></li>
</ul></li>
</ul></li>
<li><a href="Gradient_method" title="wikilink">Gradient method</a> — method that uses the gradient as the search direction
<ul>
<li><a href="Gradient_descent" title="wikilink">Gradient descent</a>
<ul>
<li><a href="Stochastic_gradient_descent" title="wikilink">Stochastic gradient descent</a></li>
</ul></li>
<li><a href="Landweber_iteration" title="wikilink">Landweber iteration</a> — mainly used for ill-posed problems</li>
</ul></li>
<li><a href="Successive_linear_programming" title="wikilink">Successive linear programming</a> (SLP) — replace problem by a linear programming problem, solve that, and repeat</li>
<li><a href="Sequential_quadratic_programming" title="wikilink">Sequential quadratic programming</a> (SQP) — replace problem by a quadratic programming problem, solve that, and repeat</li>
<li><a href="Newton's_method_in_optimization" title="wikilink">Newton's method in optimization</a>
<ul>
<li>See also under <em>Newton algorithm</em> in the <a href="#Finding_roots_of_nonlinear_equations" title="wikilink">section <em>Finding roots of nonlinear equations</em></a></li>
</ul></li>
<li><a href="Nonlinear_conjugate_gradient_method" title="wikilink">Nonlinear conjugate gradient method</a></li>
<li>Derivative-free methods
<ul>
<li><a href="Coordinate_descent" title="wikilink">Coordinate descent</a> — move in one of the coordinate directions
<ul>
<li><a href="Adaptive_coordinate_descent" title="wikilink">Adaptive coordinate descent</a> — adapt coordinate directions to objective function</li>
<li><a href="Random_coordinate_descent" title="wikilink">Random coordinate descent</a> — randomized version</li>
</ul></li>
<li><a href="Nelder–Mead_method" title="wikilink">Nelder–Mead method</a></li>
<li><a href="Pattern_search_(optimization)" title="wikilink">Pattern search (optimization)</a></li>
<li><a href="Powell's_method" title="wikilink">Powell's method</a> — based on conjugate gradient descent</li>
<li><a href="Rosenbrock_methods" title="wikilink">Rosenbrock methods</a> — derivative-free method, similar to Nelder–Mead but with guaranteed convergence</li>
</ul></li>
<li><a href="Augmented_Lagrangian_method" title="wikilink">Augmented Lagrangian method</a> — replaces constrained problems by unconstrained problems with a term added to the objective function</li>
<li><a href="Ternary_search" title="wikilink">Ternary search</a></li>
<li><a href="Tabu_search" title="wikilink">Tabu search</a></li>
<li><a href="Guided_Local_Search" title="wikilink">Guided Local Search</a> — modification of search algorithms which builds up penalties during a search</li>
<li><a href="Reactive_search_optimization" title="wikilink">Reactive search optimization</a> (RSO) — the algorithm adapts its parameters automatically</li>
<li><a href="MM_algorithm" title="wikilink">MM algorithm</a> — majorize-minimization, a wide framework of methods</li>
<li><a href="Least_absolute_deviations" title="wikilink">Least absolute deviations</a>
<ul>
<li><a href="Expectation–maximization_algorithm" title="wikilink">Expectation–maximization algorithm</a>
<ul>
<li><a href="Ordered_subset_expectation_maximization" title="wikilink">Ordered subset expectation maximization</a></li>
</ul></li>
</ul></li>
<li><a href="Adaptive_projected_subgradient_method" title="wikilink">Adaptive projected subgradient method</a></li>
<li><a href="Nearest_neighbor_search" title="wikilink">Nearest neighbor search</a></li>
<li><a href="Space_mapping" title="wikilink">Space mapping</a> — uses "coarse" (ideal or low-fidelity) and "fine" (practical or high-fidelity) models</li>
</ul></li>
</ul>
<h3 id="optimal-control-and-infinite-dimensional-optimization">Optimal control and infinite-dimensional optimization</h3>

<p><a href="Optimal_control" title="wikilink">Optimal control</a></p>
<ul>
<li><a href="Pontryagin's_minimum_principle" title="wikilink">Pontryagin's minimum principle</a> — infinite-dimensional version of Lagrange multipliers
<ul>
<li><a href="Costate_equations" title="wikilink">Costate equations</a> — equation for the "Lagrange multipliers" in Pontryagin's minimum principle</li>
<li><a href="Hamiltonian_(control_theory)" title="wikilink">Hamiltonian (control theory)</a> — minimum principle says that this function should be minimized</li>
</ul></li>
<li>Types of problems:
<ul>
<li><a href="Linear-quadratic_regulator" title="wikilink">Linear-quadratic regulator</a> — system dynamics is a linear differential equation, objective is quadratic</li>
<li><a href="Linear-quadratic-Gaussian_control" title="wikilink">Linear-quadratic-Gaussian control</a> (LQG) — system dynamics is a linear SDE with additive noise, objective is quadratic
<ul>
<li><a href="Optimal_projection_equations" title="wikilink">Optimal projection equations</a> — method for reducing dimension of LQG control problem</li>
</ul></li>
</ul></li>
<li><a href="Algebraic_Riccati_equation" title="wikilink">Algebraic Riccati equation</a> — matrix equation occurring in many optimal control problems</li>
<li><a href="Bang–bang_control" title="wikilink">Bang–bang control</a> — control that switches abruptly between two states</li>
<li><a href="Covector_mapping_principle" title="wikilink">Covector mapping principle</a></li>
<li><a href="Differential_dynamic_programming" title="wikilink">Differential dynamic programming</a> — uses locally-quadratic models of the dynamics and cost functions</li>
<li><a href="DNSS_point" title="wikilink">DNSS point</a> — initial state for certain optimal control problems with multiple optimal solutions</li>
<li><a href="Legendre–Clebsch_condition" title="wikilink">Legendre–Clebsch condition</a> — second-order condition for solution of optimal control problem</li>
<li><a href="Pseudospectral_optimal_control" title="wikilink">Pseudospectral optimal control</a>
<ul>
<li><a href="Bellman_pseudospectral_method" title="wikilink">Bellman pseudospectral method</a> — based on Bellman's principle of optimality</li>
<li><a href="Chebyshev_pseudospectral_method" title="wikilink">Chebyshev pseudospectral method</a> — uses Chebyshev polynomials (of the first kind)</li>
<li><a href="Flat_pseudospectral_method" title="wikilink">Flat pseudospectral method</a> — combines Ross–Fahroo pseudospectral method with differential flatness</li>
<li><a href="Gauss_pseudospectral_method" title="wikilink">Gauss pseudospectral method</a> — uses collocation at the Legendre–Gauss points</li>
<li><a href="Legendre_pseudospectral_method" title="wikilink">Legendre pseudospectral method</a> — uses Legendre polynomials</li>
<li><a href="Pseudospectral_knotting_method" title="wikilink">Pseudospectral knotting method</a> — generalization of pseudospectral methods in optimal control</li>
<li><a href="Ross–Fahroo_pseudospectral_method" title="wikilink">Ross–Fahroo pseudospectral method</a> — class of pseudospectral method including Chebyshev, Legendre and knotting</li>
</ul></li>
<li><a href="Ross–Fahroo_lemma" title="wikilink">Ross–Fahroo lemma</a> — condition to make discretization and duality operations commute</li>
<li><a href="Ross'_π_lemma" title="wikilink">Ross' π lemma</a> — there is fundamental time constant within which a control solution must be computed for controllability and stability</li>
<li><a href="Sethi_model" title="wikilink">Sethi model</a> — optimal control problem modelling advertising</li>
</ul>

<p><a href="Infinite-dimensional_optimization" title="wikilink">Infinite-dimensional optimization</a></p>
<ul>
<li><a href="Semi-infinite_programming" title="wikilink">Semi-infinite programming</a> — infinite number of variables and finite number of constraints, or other way around</li>
<li><a href="Shape_optimization" title="wikilink">Shape optimization</a>, <a href="Topology_optimization" title="wikilink">Topology optimization</a> — optimization over a set of regions
<ul>
<li><a href="Topological_derivative" title="wikilink">Topological derivative</a> — derivative with respect to changing in the shape</li>
</ul></li>
<li><a href="Generalized_semi-infinite_programming" title="wikilink">Generalized semi-infinite programming</a> — finite number of variables, infinite number of constraints</li>
</ul>
<h3 id="uncertainty-and-randomness">Uncertainty and randomness</h3>
<ul>
<li>Approaches to deal with uncertainty:
<ul>
<li><a href="Markov_decision_process" title="wikilink">Markov decision process</a></li>
<li><a href="Partially_observable_Markov_decision_process" title="wikilink">Partially observable Markov decision process</a></li>
<li><a href="Probabilistic-based_design_optimization" title="wikilink">Probabilistic-based design optimization</a></li>
<li><a href="Robust_optimization" title="wikilink">Robust optimization</a>
<ul>
<li><a href="Wald's_maximin_model" title="wikilink">Wald's maximin model</a></li>
</ul></li>
<li><a href="Scenario_optimization" title="wikilink">Scenario optimization</a> — constraints are uncertain</li>
<li><a href="Stochastic_approximation" title="wikilink">Stochastic approximation</a></li>
<li><a href="Stochastic_optimization" title="wikilink">Stochastic optimization</a></li>
<li><a href="Stochastic_programming" title="wikilink">Stochastic programming</a></li>
<li><a href="Stochastic_gradient_descent" title="wikilink">Stochastic gradient descent</a></li>
</ul></li>
<li><a href="Random_optimization" title="wikilink">Random optimization</a> algorithms:
<ul>
<li><a href="Random_search" title="wikilink">Random search</a> — choose a point randomly in ball around current iterate</li>
<li><a href="Simulated_annealing" title="wikilink">Simulated annealing</a>
<ul>
<li><a href="Adaptive_simulated_annealing" title="wikilink">Adaptive simulated annealing</a> — variant in which the algorithm parameters are adjusted during the computation.</li>
<li><a href="Great_Deluge_algorithm" title="wikilink">Great Deluge algorithm</a></li>
<li><a href="Mean_field_annealing" title="wikilink">Mean field annealing</a> — deterministic variant of simulated annealing</li>
</ul></li>
<li><a href="Bayesian_optimization" title="wikilink">Bayesian optimization</a> — treats objective function as a random function and places a prior over it</li>
<li><a href="Evolutionary_algorithm" title="wikilink">Evolutionary algorithm</a>
<ul>
<li><a href="Differential_evolution" title="wikilink">Differential evolution</a></li>
<li><a href="Evolutionary_programming" title="wikilink">Evolutionary programming</a></li>
<li><a href="Genetic_algorithm" title="wikilink">Genetic algorithm</a>, <a href="Genetic_programming" title="wikilink">Genetic programming</a>
<ul>
<li><a href="Genetic_algorithms_in_economics" title="wikilink">Genetic algorithms in economics</a></li>
</ul></li>
<li><a class="uri" href="MCACEA" title="wikilink">MCACEA</a> (Multiple Coordinated Agents Coevolution Evolutionary Algorithm) — uses an evolutionary algorithm for every agent</li>
<li><a href="Simultaneous_perturbation_stochastic_approximation" title="wikilink">Simultaneous perturbation stochastic approximation</a> (SPSA)</li>
</ul></li>
<li><a class="uri" href="Luus–Jaakola" title="wikilink">Luus–Jaakola</a></li>
<li><a href="Particle_swarm_optimization" title="wikilink">Particle swarm optimization</a></li>
<li><a href="Stochastic_tunneling" title="wikilink">Stochastic tunneling</a></li>
<li><a href="Harmony_search" title="wikilink">Harmony search</a> — mimicks the improvisation process of musicians</li>
<li>see also the section <em>Monte Carlo method</em></li>
</ul></li>
</ul>
<h3 id="theoretical-aspects">Theoretical aspects</h3>
<ul>
<li><a href="Convex_analysis" title="wikilink">Convex analysis</a> — function <em>f</em> such that <em>f</em>(<em>tx</em> + (1 − <em>t</em>)<em>y</em>) ≥ <em>tf</em>(<em>x</em>) + (1 − <em>t</em>)<em>f</em>(<em>y</em>) for <em>t</em> ∈ [0,1]
<ul>
<li><a href="Pseudoconvex_function" title="wikilink">Pseudoconvex function</a> — function <em>f</em> such that ∇<em>f</em> · (<em>y</em> − <em>x</em>) ≥ 0 implies <em>f</em>(<em>y</em>) ≥ <em>f</em>(<em>x</em>)</li>
<li><a href="Quasiconvex_function" title="wikilink">Quasiconvex function</a> — function <em>f</em> such that <em>f</em>(<em>tx</em> + (1 − <em>t</em>)<em>y</em>) ≤ max(<em>f</em>(<em>x</em>), <em>f</em>(<em>y</em>)) for <em>t</em> ∈ [0,1]</li>
<li><a class="uri" href="Subderivative" title="wikilink">Subderivative</a></li>
<li><a href="Geodesic_convexity" title="wikilink">Geodesic convexity</a> — convexity for functions defined on a Riemannian manifold</li>
</ul></li>
<li><a href="Duality_(optimization)" title="wikilink">Duality (optimization)</a>
<ul>
<li><a href="Weak_duality" title="wikilink">Weak duality</a> — dual solution gives a bound on the primal solution</li>
<li><a href="Strong_duality" title="wikilink">Strong duality</a> — primal and dual solutions are equivalent</li>
<li><a href="Shadow_price" title="wikilink">Shadow price</a></li>
<li><a href="Dual_cone_and_polar_cone" title="wikilink">Dual cone and polar cone</a></li>
<li><a href="Duality_gap" title="wikilink">Duality gap</a> — difference between primal and dual solution</li>
<li><a href="Fenchel's_duality_theorem" title="wikilink">Fenchel's duality theorem</a> — relates minimization problems with maximization problems of convex conjugates</li>
<li><a href="Perturbation_function" title="wikilink">Perturbation function</a> — any function which relates to primal and dual problems</li>
<li><a href="Slater's_condition" title="wikilink">Slater's condition</a> — sufficient condition for strong duality to hold in a convex optimization problem</li>
<li><a href="Total_dual_integrality" title="wikilink">Total dual integrality</a> — concept of duality for integer linear programming</li>
<li><a href="Wolfe_duality" title="wikilink">Wolfe duality</a> — for when objective function and constraints are differentiable</li>
</ul></li>
<li><a href="Farkas'_lemma" title="wikilink">Farkas' lemma</a></li>
<li><a href="Karush–Kuhn–Tucker_conditions" title="wikilink">Karush–Kuhn–Tucker conditions</a> (KKT) — sufficient conditions for a solution to be optimal
<ul>
<li><a href="Fritz_John_conditions" title="wikilink">Fritz John conditions</a> — variant of KKT conditions</li>
</ul></li>
<li><a href="Lagrange_multiplier" title="wikilink">Lagrange multiplier</a>
<ul>
<li><a href="Lagrange_multipliers_on_Banach_spaces" title="wikilink">Lagrange multipliers on Banach spaces</a></li>
</ul></li>
<li><a class="uri" href="Semi-continuity" title="wikilink">Semi-continuity</a></li>
<li><a href="Complementarity_theory" title="wikilink">Complementarity theory</a> — study of problems with constraints of the form 〈<em>u</em>, <em>v</em>〉 = 0
<ul>
<li><a href="Mixed_complementarity_problem" title="wikilink">Mixed complementarity problem</a>
<ul>
<li><a href="Mixed_linear_complementarity_problem" title="wikilink">Mixed linear complementarity problem</a></li>
<li><a href="Lemke's_algorithm" title="wikilink">Lemke's algorithm</a> — method for solving (mixed) linear complementarity problems</li>
</ul></li>
</ul></li>
<li><a href="Danskin's_theorem" title="wikilink">Danskin's theorem</a> — used in the analysis of minimax problems</li>
<li><a href="Maximum_theorem" title="wikilink">Maximum theorem</a> — the maximum and maximizer are continuous as function of parameters, under some conditions</li>
<li><a href="No_free_lunch_in_search_and_optimization" title="wikilink">No free lunch in search and optimization</a></li>
<li><a href="Relaxation_(approximation)" title="wikilink">Relaxation (approximation)</a> — approximating a given problem by an easier problem by relaxing some constraints
<ul>
<li><a href="Lagrangian_relaxation" title="wikilink">Lagrangian relaxation</a></li>
<li><a href="Linear_programming_relaxation" title="wikilink">Linear programming relaxation</a> — ignoring the integrality constraints in a linear programming problem</li>
</ul></li>
<li><a href="Self-concordant_function" title="wikilink">Self-concordant function</a></li>
<li><a href="Reduced_cost" title="wikilink">Reduced cost</a> — cost for increasing a variable by a small amount</li>
<li><a href="Hardness_of_approximation" title="wikilink">Hardness of approximation</a> — computational complexity of getting an approximate solution</li>
</ul>
<h3 id="applications">Applications</h3>
<ul>
<li>In geometry:
<ul>
<li><a href="Geometric_median" title="wikilink">Geometric median</a> — the point minimizing the sum of distances to a given set of points</li>
<li><a href="Chebyshev_center" title="wikilink">Chebyshev center</a> — the centre of the smallest ball containing a given set of points</li>
</ul></li>
<li>In statistics:
<ul>
<li><a href="Iterated_conditional_modes" title="wikilink">Iterated conditional modes</a> — maximizing joint probability of Markov random field</li>
<li><a href="Response_surface_methodology" title="wikilink">Response surface methodology</a> — used in the design of experiments</li>
</ul></li>
<li><a href="Automatic_label_placement" title="wikilink">Automatic label placement</a></li>
<li><a href="Compressed_sensing" title="wikilink">Compressed sensing</a> — reconstruct a signal from knowledge that it is sparse or compressible</li>
<li><a href="Cutting_stock_problem" title="wikilink">Cutting stock problem</a></li>
<li><a href="Demand_optimization" title="wikilink">Demand optimization</a></li>
<li><a href="Destination_dispatch" title="wikilink">Destination dispatch</a> — an optimization technique for dispatching elevators</li>
<li><a href="Energy_minimization" title="wikilink">Energy minimization</a></li>
<li><a href="Entropy_maximization" title="wikilink">Entropy maximization</a></li>
<li><a href="Highly_optimized_tolerance" title="wikilink">Highly optimized tolerance</a></li>
<li><a href="Hyperparameter_optimization" title="wikilink">Hyperparameter optimization</a></li>
<li><a href="Inventory_control_problem" title="wikilink">Inventory control problem</a>
<ul>
<li><a href="Newsvendor_model" title="wikilink">Newsvendor model</a></li>
<li><a href="Extended_newsvendor_model" title="wikilink">Extended newsvendor model</a></li>
<li><a href="Assemble-to-order_system" title="wikilink">Assemble-to-order system</a></li>
</ul></li>
<li><a href="Linear_programming_decoding" title="wikilink">Linear programming decoding</a></li>
<li><a href="Linear_search_problem" title="wikilink">Linear search problem</a> — find a point on a line by moving along the line</li>
<li><a href="Low-rank_approximation" title="wikilink">Low-rank approximation</a> — find best approximation, constraint is that rank of some matrix is smaller than a given number</li>
<li><a class="uri" href="Meta-optimization" title="wikilink">Meta-optimization</a> — optimization of the parameters in an optimization method</li>
<li><a href="Multidisciplinary_design_optimization" title="wikilink">Multidisciplinary design optimization</a></li>
<li><a href="Optimal_computing_budget_allocation" title="wikilink">Optimal computing budget allocation</a> — maximize the overall simulation efficiency for finding an optimal decision</li>
<li><a href="Paper_bag_problem" title="wikilink">Paper bag problem</a></li>
<li><a href="Process_optimization" title="wikilink">Process optimization</a></li>
<li><a href="Recursive_economics" title="wikilink">Recursive economics</a> — individuals make a series of two-period optimization decisions over time.</li>
<li><a href="Stigler_diet" title="wikilink">Stigler diet</a></li>
<li><a href="Space_allocation_problem" title="wikilink">Space allocation problem</a></li>
<li><a href="Stress_majorization" title="wikilink">Stress majorization</a></li>
<li><a href="Trajectory_optimization" title="wikilink">Trajectory optimization</a></li>
<li><a href="Transportation_theory_(mathematics)" title="wikilink">Transportation theory</a></li>
<li><a href="Wing-shape_optimization" title="wikilink">Wing-shape optimization</a></li>
</ul>
<h3 id="miscellaneous-1">Miscellaneous</h3>
<ul>
<li><a href="Combinatorial_optimization" title="wikilink">Combinatorial optimization</a></li>
<li><a href="Dynamic_programming" title="wikilink">Dynamic programming</a>
<ul>
<li><a href="Bellman_equation" title="wikilink">Bellman equation</a></li>
<li><a href="Hamilton–Jacobi–Bellman_equation" title="wikilink">Hamilton–Jacobi–Bellman equation</a> — continuous-time analogue of Bellman equation</li>
<li><a href="Backward_induction" title="wikilink">Backward induction</a> — solving dynamic programming problems by reasoning backwards in time</li>
<li><a href="Optimal_stopping" title="wikilink">Optimal stopping</a> — choosing the optimal time to take a particular action
<ul>
<li><a href="Odds_algorithm" title="wikilink">Odds algorithm</a></li>
<li><a href="Robbins'_problem" title="wikilink">Robbins' problem</a></li>
</ul></li>
</ul></li>
<li><a href="Global_optimization" title="wikilink">Global optimization</a>:
<ul>
<li><a href="BRST_algorithm" title="wikilink">BRST algorithm</a></li>
<li><a href="MCS_algorithm" title="wikilink">MCS algorithm</a></li>
</ul></li>
<li><a href="Multi-objective_optimization" title="wikilink">Multi-objective optimization</a> — there are multiple conflicting objectives
<ul>
<li><a href="Benson's_algorithm" title="wikilink">Benson's algorithm</a> — for linear <a href="vector_optimization" title="wikilink">vector optimization</a> problems</li>
</ul></li>
<li><a href="Bilevel_optimization" title="wikilink">Bilevel optimization</a> — studies problems in which one problem is embedded in another</li>
<li><a href="Optimal_substructure" title="wikilink">Optimal substructure</a></li>
<li><a href="Dykstra's_projection_algorithm" title="wikilink">Dykstra's projection algorithm</a> — finds a point in intersection of two convex sets</li>
<li>Algorithmic concepts:
<ul>
<li><a href="Barrier_function" title="wikilink">Barrier function</a></li>
<li><a href="Penalty_method" title="wikilink">Penalty method</a></li>
<li><a href="Trust_region" title="wikilink">Trust region</a></li>
</ul></li>
<li><a href="Test_functions_for_optimization" title="wikilink">Test functions for optimization</a>:
<ul>
<li><a href="Rosenbrock_function" title="wikilink">Rosenbrock function</a> — two-dimensional function with a banana-shaped valley</li>
<li><a href="Himmelblau's_function" title="wikilink">Himmelblau's function</a> — two-dimensional with four local minima, defined by 

<math display="inline" id="List_of_numerical_analysis_topics:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
        <mo>+</mo>
        <mi>y</mi>
       </mrow>
       <mo>-</mo>
       <mn>11</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <msup>
         <mi>y</mi>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo>-</mo>
       <mn>7</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>y</ci>
       </apply>
       <cn type="integer">11</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cn type="integer">7</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=(x^{2}+y-11)^{2}+(x+y^{2}-7)^{2}
  </annotation>
 </semantics>
</math>

</li>
<li><a href="Rastrigin_function" title="wikilink">Rastrigin function</a> — two-dimensional function with many local minima</li>
<li><a href="Shekel_function" title="wikilink">Shekel function</a> — multimodal and multidimensional</li>
</ul></li>
<li><a href="Mathematical_Optimization_Society" title="wikilink">Mathematical Optimization Society</a></li>
</ul>
<h2 id="numerical-quadrature-integration">Numerical quadrature (integration)</h2>

<p><a href="Numerical_integration" title="wikilink">Numerical integration</a> — the numerical evaluation of an integral</p>
<ul>
<li><a href="Rectangle_method" title="wikilink">Rectangle method</a> — first-order method, based on (piecewise) constant approximation</li>
<li><a href="Trapezoidal_rule" title="wikilink">Trapezoidal rule</a> — second-order method, based on (piecewise) linear approximation</li>
<li><a href="Simpson's_rule" title="wikilink">Simpson's rule</a> — fourth-order method, based on (piecewise) quadratic approximation
<ul>
<li><a href="Adaptive_Simpson's_method" title="wikilink">Adaptive Simpson's method</a></li>
</ul></li>
<li><a href="Boole's_rule" title="wikilink">Boole's rule</a> — sixth-order method, based on the values at five equidistant points</li>
<li><a href="Newton–Cotes_formulas" title="wikilink">Newton–Cotes formulas</a> — generalizes the above methods</li>
<li><a href="Romberg's_method" title="wikilink">Romberg's method</a> — Richardson extrapolation applied to trapezium rule</li>
<li><a href="Gaussian_quadrature" title="wikilink">Gaussian quadrature</a> — highest possible degree with given number of points
<ul>
<li><a href="Chebyshev–Gauss_quadrature" title="wikilink">Chebyshev–Gauss quadrature</a> — extension of Gaussian quadrature for integrals with weight <mtpl></mtpl> on [−1, 1]</li>
<li><a href="Gauss–Hermite_quadrature" title="wikilink">Gauss–Hermite quadrature</a> — extension of Gaussian quadrature for integrals with weight exp(−<em>x</em><sup>2</sup>) on [−∞, ∞]</li>
<li><a href="Gauss–Jacobi_quadrature" title="wikilink">Gauss–Jacobi quadrature</a> — extension of Gaussian quadrature for integrals with weight (1 − <em>x</em>)<sup><em>α</em></sup> (1 + <em>x</em>)<sup><em>β</em></sup> on [−1, 1]</li>
<li><a href="Gauss–Laguerre_quadrature" title="wikilink">Gauss–Laguerre quadrature</a> — extension of Gaussian quadrature for integrals with weight exp(−<em>x</em>) on [0, ∞]</li>
<li><a href="Gauss–Kronrod_quadrature_formula" title="wikilink">Gauss–Kronrod quadrature formula</a> — nested rule based on Gaussian quadrature</li>
<li><a href="Gaussian_quadrature" title="wikilink">Gauss–Kronrod rules</a></li>
</ul></li>
<li><a href="Tanh-sinh_quadrature" title="wikilink">Tanh-sinh quadrature</a> — variant of Gaussian quadrature which works well with singularities at the end points</li>
<li><a href="Clenshaw–Curtis_quadrature" title="wikilink">Clenshaw–Curtis quadrature</a> — based on expanding the integrand in terms of Chebyshev polynomials</li>
<li><a href="Adaptive_quadrature" title="wikilink">Adaptive quadrature</a> — adapting the subintervals in which the integration interval is divided depending on the integrand</li>
<li><a href="Monte_Carlo_integration" title="wikilink">Monte Carlo integration</a> — takes random samples of the integrand
<ul>
<li><em>See also <a href="#Monte_Carlo_method" title="wikilink">#Monte Carlo method</a></em></li>
</ul></li>
<li><a href="Quantized_state_systems_method" title="wikilink">Quantized state systems method</a> (QSS) — based on the idea of state quantization</li>
<li><a href="Lebedev_quadrature" title="wikilink">Lebedev quadrature</a> — uses a grid on a sphere with octahedral symmetry</li>
<li><a href="Sparse_grid" title="wikilink">Sparse grid</a></li>
<li><a href="Coopmans_approximation" title="wikilink">Coopmans approximation</a></li>
<li><a href="Numerical_differentiation" title="wikilink">Numerical differentiation</a> — for fractional-order integrals
<ul>
<li><a href="Numerical_smoothing_and_differentiation" title="wikilink">Numerical smoothing and differentiation</a></li>
<li><a href="Adjoint_state_method" title="wikilink">Adjoint state method</a> — approximates gradient of a function in an optimization problem</li>
</ul></li>
<li><a href="Euler–Maclaurin_formula" title="wikilink">Euler–Maclaurin formula</a></li>
</ul>
<h2 id="numerical-methods-for-ordinary-differential-equations">Numerical methods for ordinary differential equations</h2>

<p><a href="Numerical_methods_for_ordinary_differential_equations" title="wikilink">Numerical methods for ordinary differential equations</a> — the numerical solution of ordinary differential equations (ODEs)</p>
<ul>
<li><a href="Euler_method" title="wikilink">Euler method</a> — the most basic method for solving an ODE</li>
<li><a href="Explicit_and_implicit_methods" title="wikilink">Explicit and implicit methods</a> — implicit methods need to solve an equation at every step</li>
<li><a href="Backward_Euler_method" title="wikilink">Backward Euler method</a> — implicit variant of the Euler method</li>
<li><a href="Trapezoidal_rule_(differential_equations)" title="wikilink">Trapezoidal rule</a> — second-order implicit method</li>
<li><a href="Runge–Kutta_methods" title="wikilink">Runge–Kutta methods</a> — one of the two main classes of methods for initial-value problems
<ul>
<li><a href="Midpoint_method" title="wikilink">Midpoint method</a> — a second-order method with two stages</li>
<li><a href="Heun's_method" title="wikilink">Heun's method</a> — either a second-order method with two stages, or a third-order method with three stages</li>
<li><a href="Bogacki–Shampine_method" title="wikilink">Bogacki–Shampine method</a> — a third-order method with four stages (FSAL) and an embedded fourth-order method</li>
<li><a href="Cash–Karp_method" title="wikilink">Cash–Karp method</a> — a fifth-order method with six stages and an embedded fourth-order method</li>
<li><a href="Dormand–Prince_method" title="wikilink">Dormand–Prince method</a> — a fifth-order method with seven stages (FSAL) and an embedded fourth-order method</li>
<li><a href="Runge–Kutta–Fehlberg_method" title="wikilink">Runge–Kutta–Fehlberg method</a> — a fifth-order method with six stages and an embedded fourth-order method</li>
<li><a href="Gauss–Legendre_method" title="wikilink">Gauss–Legendre method</a> — family of A-stable method with optimal order based on Gaussian quadrature</li>
<li><a href="Butcher_group" title="wikilink">Butcher group</a> — algebraic formalism involving rooted trees for analysing Runge–Kutta methods</li>
<li><a href="List_of_Runge–Kutta_methods" title="wikilink">List of Runge–Kutta methods</a></li>
</ul></li>
<li><a href="Linear_multistep_method" title="wikilink">Linear multistep method</a> — the other main class of methods for initial-value problems
<ul>
<li><a href="Backward_differentiation_formula" title="wikilink">Backward differentiation formula</a> — implicit methods of order 2 to 6; especially suitable for stiff equations</li>
<li><a href="Numerov's_method" title="wikilink">Numerov's method</a> — fourth-order method for equations of the form 

<math display="inline" id="List_of_numerical_analysis_topics:2">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mi>′′</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>′′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime\prime}=f(t,y)
  </annotation>
 </semantics>
</math>

</li>
<li><a href="Predictor–corrector_method" title="wikilink">Predictor–corrector method</a> — uses one method to approximate solution and another one to increase accuracy</li>
</ul></li>
<li><a href="General_linear_methods" title="wikilink">General linear methods</a> — a class of methods encapsulating linear multistep and Runge-Kutta methods</li>
<li><a href="Bulirsch–Stoer_algorithm" title="wikilink">Bulirsch–Stoer algorithm</a> — combines the midpoint method with Richardson extrapolation to attain arbitrary order</li>
<li><a href="Exponential_integrator" title="wikilink">Exponential integrator</a> — based on splitting ODE in a linear part, which is solved exactly, and a nonlinear part</li>
<li>Methods designed for the solution of ODEs from classical physics:
<ul>
<li><a href="Newmark-beta_method" title="wikilink">Newmark-beta method</a> — based on the extended mean-value theorem</li>
<li><a href="Verlet_integration" title="wikilink">Verlet integration</a> — a popular second-order method</li>
<li><a href="Leapfrog_integration" title="wikilink">Leapfrog integration</a> — another name for Verlet integration</li>
<li><a href="Beeman's_algorithm" title="wikilink">Beeman's algorithm</a> — a two-step method extending the Verlet method</li>
<li><a href="Dynamic_relaxation" title="wikilink">Dynamic relaxation</a></li>
</ul></li>
<li><a href="Geometric_integrator" title="wikilink">Geometric integrator</a> — a method that preserves some geometric structure of the equation
<ul>
<li><a href="Symplectic_integrator" title="wikilink">Symplectic integrator</a> — a method for the solution of Hamilton's equations that preserves the symplectic structure
<ul>
<li><a href="Variational_integrator" title="wikilink">Variational integrator</a> — symplectic integrators derived using the underlying variational principle</li>
<li><a href="Semi-implicit_Euler_method" title="wikilink">Semi-implicit Euler method</a> — variant of Euler method which is symplectic when applied to separable Hamiltonians</li>
</ul></li>
<li><a href="Energy_drift" title="wikilink">Energy drift</a> — phenomenon that energy, which should be conserved, drifts away due to numerical errors</li>
</ul></li>
<li>Other methods for initial value problems (IVPs):
<ul>
<li><a href="Bi-directional_delay_line" title="wikilink">Bi-directional delay line</a></li>
<li><a href="Partial_element_equivalent_circuit" title="wikilink">Partial element equivalent circuit</a></li>
</ul></li>
<li>Methods for solving two-point boundary value problems (BVPs):
<ul>
<li><a href="Shooting_method" title="wikilink">Shooting method</a></li>
<li><a href="Direct_multiple_shooting_method" title="wikilink">Direct multiple shooting method</a> — divides interval in several subintervals and applies the shooting method on each subinterval</li>
</ul></li>
<li>Methods for solving differential-algebraic equations (DAEs), i.e., ODEs with constraints:
<ul>
<li><a href="Constraint_algorithm" title="wikilink">Constraint algorithm</a> — for solving Newton's equations with constraints</li>
<li><a href="Pantelides_algorithm" title="wikilink">Pantelides algorithm</a> — for reducing the index of a DEA</li>
</ul></li>
<li>Methods for solving stochastic differential equations (SDEs):
<ul>
<li><a href="Euler–Maruyama_method" title="wikilink">Euler–Maruyama method</a> — generalization of the Euler method for SDEs</li>
<li><a href="Milstein_method" title="wikilink">Milstein method</a> — a method with strong order one</li>
<li><a href="Runge–Kutta_method_(SDE)" title="wikilink">Runge–Kutta method (SDE)</a> — generalization of the family of Runge–Kutta methods for SDEs</li>
</ul></li>
<li>Methods for solving integral equations:
<ul>
<li><a href="Nyström_method" title="wikilink">Nyström method</a> — replaces the integral with a quadrature rule</li>
</ul></li>
<li>Analysis:
<ul>
<li><a href="Truncation_error_(numerical_integration)" title="wikilink">Truncation error (numerical integration)</a> — local and global truncation errors, and their relationships
<ul>
<li><a href="Lady_Windermere's_Fan_(mathematics)" title="wikilink">Lady Windermere's Fan (mathematics)</a> — telescopic identity relating local and global truncation errors</li>
</ul></li>
</ul></li>
<li><a href="Stiff_equation" title="wikilink">Stiff equation</a> — roughly, an ODE for which unstable methods need a very short step size, but stable methods do not
<ul>
<li><a class="uri" href="L-stability" title="wikilink">L-stability</a> — method is A-stable and stability function vanishes at infinity</li>
<li><a href="Dynamic_errors_of_numerical_methods_of_ODE_discretization" title="wikilink">Dynamic errors of numerical methods of ODE discretization</a> — logarithm of stability function</li>
</ul></li>
<li><a href="Adaptive_stepsize" title="wikilink">Adaptive stepsize</a> — automatically changing the step size when that seems advantageous</li>
</ul>
<h2 id="numerical-methods-for-partial-differential-equations">Numerical methods for partial differential equations</h2>

<p><a href="Numerical_partial_differential_equations" title="wikilink">Numerical partial differential equations</a> — the numerical solution of partial differential equations (PDEs)</p>
<h3 id="finite-difference-methods">Finite difference methods</h3>

<p><a href="Finite_difference_method" title="wikilink">Finite difference method</a> — based on approximating differential operators with difference operators</p>
<ul>
<li><a href="Finite_difference" title="wikilink">Finite difference</a> — the discrete analogue of a differential operator
<ul>
<li><a href="Finite_difference_coefficient" title="wikilink">Finite difference coefficient</a> — table of coefficients of finite-difference approximations to derivatives</li>
<li><a href="Discrete_Laplace_operator" title="wikilink">Discrete Laplace operator</a> — finite-difference approximation of the Laplace operator
<ul>
<li><a href="Eigenvalues_and_eigenvectors_of_the_second_derivative" title="wikilink">Eigenvalues and eigenvectors of the second derivative</a> — includes eigenvalues of discrete Laplace operator</li>
<li><a href="Kronecker_sum_of_discrete_Laplacians" title="wikilink">Kronecker sum of discrete Laplacians</a> — used for Laplace operator in multiple dimensions</li>
</ul></li>
<li><a href="Discrete_Poisson_equation" title="wikilink">Discrete Poisson equation</a> — discrete analogue of the Poisson equation using the discrete Laplace operator</li>
</ul></li>
<li><a href="Stencil_(numerical_analysis)" title="wikilink">Stencil (numerical analysis)</a> — the geometric arrangements of grid points affected by a basic step of the algorithm
<ul>
<li><a href="Compact_stencil" title="wikilink">Compact stencil</a> — stencil which only uses a few grid points, usually only the immediate and diagonal neighbours
<ul>
<li><a href="Higher-order_compact_finite_difference_scheme" title="wikilink">Higher-order compact finite difference scheme</a></li>
</ul></li>
<li><a href="Non-compact_stencil" title="wikilink">Non-compact stencil</a> — any stencil that is not compact</li>
<li><a href="Five-point_stencil" title="wikilink">Five-point stencil</a> — two-dimensional stencil consisting of a point and its four immediate neighbours on a rectangular grid</li>
</ul></li>
<li>Finite difference methods for heat equation and related PDEs:
<ul>
<li><a href="FTCS_scheme" title="wikilink">FTCS scheme</a> (forward-time central-space) — first-order explicit</li>
<li><a href="Crank–Nicolson_method" title="wikilink">Crank–Nicolson method</a> — second-order implicit</li>
</ul></li>
<li>Finite difference methods for hyperbolic PDEs like the wave equation:
<ul>
<li><a href="Lax–Friedrichs_method" title="wikilink">Lax–Friedrichs method</a> — first-order explicit</li>
<li><a href="Lax–Wendroff_method" title="wikilink">Lax–Wendroff method</a> — second-order explicit</li>
<li><a href="MacCormack_method" title="wikilink">MacCormack method</a> — second-order explicit</li>
<li><a href="Upwind_scheme" title="wikilink">Upwind scheme</a>
<ul>
<li><a href="Upwind_differencing_scheme_for_convection" title="wikilink">Upwind differencing scheme for convection</a> — first-order scheme for convection–diffusion problems</li>
</ul></li>
<li><a href="Lax–Wendroff_theorem" title="wikilink">Lax–Wendroff theorem</a> — conservative scheme for hyperbolic system of conservation laws converges to the weak solution</li>
</ul></li>
<li><a href="Alternating_direction_implicit_method" title="wikilink">Alternating direction implicit method</a> (ADI) — update using the flow in <em>x</em>-direction and then using flow in <em>y</em>-direction</li>
<li><a href="Nonstandard_finite_difference_scheme" title="wikilink">Nonstandard finite difference scheme</a></li>
<li>Specific applications:
<ul>
<li><a href="Finite_difference_methods_for_option_pricing" title="wikilink">Finite difference methods for option pricing</a></li>
<li><a href="Finite-difference_time-domain_method" title="wikilink">Finite-difference time-domain method</a> — a finite-difference method for electrodynamics</li>
</ul></li>
</ul>
<h3 id="finite-element-methods">Finite element methods</h3>

<p><a href="Finite_element_method" title="wikilink">Finite element method</a> — based on a discretization of the space of solutions</p>
<ul>
<li><a href="Finite_element_method_in_structural_mechanics" title="wikilink">Finite element method in structural mechanics</a> — a physical approach to finite element methods</li>
<li><a href="Galerkin_method" title="wikilink">Galerkin method</a> — a finite element method in which the residual is orthogonal to the finite element space
<ul>
<li><a href="Discontinuous_Galerkin_method" title="wikilink">Discontinuous Galerkin method</a> — a Galerkin method in which the approximate solution is not continuous</li>
</ul></li>
<li><a href="Rayleigh–Ritz_method" title="wikilink">Rayleigh–Ritz method</a> — a finite element method based on variational principles</li>
<li><a href="Spectral_element_method" title="wikilink">Spectral element method</a> — high-order finite element methods</li>
<li><a class="uri" href="hp-FEM" title="wikilink">hp-FEM</a> — variant in which both the size and the order of the elements are automatically adapted</li>
<li>Examples of finite elemets:
<ul>
<li><a href="Bilinear_quadrilateral_element" title="wikilink">Bilinear quadrilateral element</a> — also known as the Q4 element</li>
<li><a href="Constant_strain_triangle_element" title="wikilink">Constant strain triangle element</a> (CST) — also known as the T3 element</li>
<li><a href="Barsoum_elements" title="wikilink">Barsoum elements</a></li>
</ul></li>
<li><a href="Direct_stiffness_method" title="wikilink">Direct stiffness method</a> — a particular implementation of the finite element method, often used in structural analysis</li>
<li><a href="Trefftz_method" title="wikilink">Trefftz method</a></li>
<li><a href="Finite_element_updating" title="wikilink">Finite element updating</a></li>
<li><a href="Extended_finite_element_method" title="wikilink">Extended finite element method</a> — puts functions tailored to the problem in the approximation space</li>
<li><a href="Functionally_graded_element" title="wikilink">Functionally graded elements</a> — elements for describing functionally graded materials</li>
<li><a class="uri" href="Superelement" title="wikilink">Superelement</a> — particular grouping of finite elements, employed as a single element</li>
<li><a href="Interval_finite_element" title="wikilink">Interval finite element</a> method — combination of finite elements with interval arithmetic</li>
<li><a href="Discrete_exterior_calculus" title="wikilink">Discrete exterior calculus</a> — discrete form of the exterior calculus of differential geometry</li>
<li><a href="Modal_analysis_using_FEM" title="wikilink">Modal analysis using FEM</a> — solution of eigenvalue problems to find natural vibrations</li>
<li><a href="Céa's_lemma" title="wikilink">Céa's lemma</a> — solution in the finite-element space is an almost best approximation in that space of the true solution</li>
<li><a href="Patch_test_(finite_elements)" title="wikilink">Patch test (finite elements)</a> — simple test for the quality of a finite element</li>
<li><a class="uri" href="MAFELAP" title="wikilink">MAFELAP</a> (MAthematics of Finite ELements and APplications) — international conference held at Brunel University</li>
<li><a class="uri" href="NAFEMS" title="wikilink">NAFEMS</a> — not-for-profit organisation that sets and maintains standards in computer-aided engineering analysis</li>
<li><a href="Multiphase_topology_optimisation" title="wikilink">Multiphase topology optimisation</a> — technique based on finite elements for determining optimal composition of a mixture</li>
<li><a href="Interval_finite_element" title="wikilink">Interval finite element</a></li>
<li><a href="Applied_element_method" title="wikilink">Applied element method</a> — for simulation of cracks and structural collapse</li>
<li><a href="Wood–Armer_method" title="wikilink">Wood–Armer method</a> — structural analysis method based on finite elements used to design reinforcement for concrete slabs</li>
<li><a href="Isogeometric_analysis" title="wikilink">Isogeometric analysis</a> — integrates finite elements into conventional NURBS-based CAD design tools</li>
<li><a href="Stiffness_matrix" title="wikilink">Stiffness matrix</a> — finite-dimensional analogue of differential operator</li>
<li>Combination with meshfree methods:
<ul>
<li><a href="Weakened_weak_form" title="wikilink">Weakened weak form</a> — form of a PDE that is weaker than the standard weak form</li>
<li><a href="G_space" title="wikilink">G space</a> — functional space used in formulating the weakened weak form</li>
<li><a href="Smoothed_finite_element_method" title="wikilink">Smoothed finite element method</a></li>
</ul></li>
<li><a href="List_of_finite_element_software_packages" title="wikilink">List of finite element software packages</a></li>
</ul>
<h3 id="other-methods">Other methods</h3>
<ul>
<li><a href="Spectral_method" title="wikilink">Spectral method</a> — based on the Fourier transformation
<ul>
<li><a href="Pseudo-spectral_method" title="wikilink">Pseudo-spectral method</a></li>
</ul></li>
<li><a href="Method_of_lines" title="wikilink">Method of lines</a> — reduces the PDE to a large system of ordinary differential equations</li>
<li><a href="Boundary_element_method" title="wikilink">Boundary element method</a> (BEM) — based on transforming the PDE to an integral equation on the boundary of the domain
<ul>
<li><a href="Interval_boundary_element_method" title="wikilink">Interval boundary element method</a> — a version using interval arithmetics</li>
</ul></li>
<li><a href="Analytic_element_method" title="wikilink">Analytic element method</a> — similar to the boundary element method, but the integral equation is evaluated analytically</li>
<li><a href="Finite_volume_method" title="wikilink">Finite volume method</a> — based on dividing the domain in many small domains; popular in computational fluid dynamics
<ul>
<li><a href="Godunov's_scheme" title="wikilink">Godunov's scheme</a> — first-order conservative scheme for fluid flow, based on piecewise constant approximation</li>
<li><a href="MUSCL_scheme" title="wikilink">MUSCL scheme</a> — second-order variant of Godunov's scheme</li>
<li><a class="uri" href="AUSM" title="wikilink">AUSM</a> — advection upstream splitting method</li>
<li><a href="Flux_limiter" title="wikilink">Flux limiter</a> — limits spatial derivatives (fluxes) in order to avoid spurious oscillations</li>
<li><a href="Riemann_solver" title="wikilink">Riemann solver</a> — a solver for Riemann problems (a conservation law with piecewise constant data)</li>
<li><a href="Properties_of_discretization_schemes" title="wikilink">Properties of discretization schemes</a> — finite volume methods can be conservative, bounded, etc.</li>
</ul></li>
<li><a href="Discrete_element_method" title="wikilink">Discrete element method</a> — a method in which the elements can move freely relative to each other
<ul>
<li><a href="Extended_discrete_element_method" title="wikilink">Extended discrete element method</a> — adds properties such as strain to each particle</li>
<li><a href="Movable_cellular_automaton" title="wikilink">Movable cellular automaton</a> — combination of cellular automata with discrete elements</li>
</ul></li>
<li><a href="Meshfree_methods" title="wikilink">Meshfree methods</a> — does not use a mesh, but uses a particle view of the field
<ul>
<li><a href="Discrete_least_squares_meshless_method" title="wikilink">Discrete least squares meshless method</a> — based on minimization of weighted summation of the squared residual</li>
<li><a href="Diffuse_element_method" title="wikilink">Diffuse element method</a></li>
<li><a href="Finite_pointset_method" title="wikilink">Finite pointset method</a> — represent continuum by a point cloud</li>
<li><a href="Moving_Particle_Semi-implicit_Method" title="wikilink">Moving Particle Semi-implicit Method</a></li>
<li><a href="Method_of_fundamental_solutions" title="wikilink">Method of fundamental solutions</a> (MFS) — represents solution as linear combination of fundamental solutions</li>
<li>Variants of MFS with source points on the physical boundary:
<ul>
<li><a href="Boundary_knot_method" title="wikilink">Boundary knot method</a> (BKM)</li>
<li><a href="Boundary_particle_method" title="wikilink">Boundary particle method</a> (BPM)</li>
<li><a href="Regularized_meshless_method" title="wikilink">Regularized meshless method</a> (RMM)</li>
<li><a href="Singular_boundary_method" title="wikilink">Singular boundary method</a> (SBM)</li>
</ul></li>
</ul></li>
<li>Methods designed for problems from electromagnetics:
<ul>
<li><a href="Finite-difference_time-domain_method" title="wikilink">Finite-difference time-domain method</a> — a finite-difference method</li>
<li><a href="Rigorous_coupled-wave_analysis" title="wikilink">Rigorous coupled-wave analysis</a> — semi-analytical Fourier-space method based on Floquet's theorem</li>
<li><a href="Transmission-line_matrix_method" title="wikilink">Transmission-line matrix method</a> (TLM) — based on analogy between electromagnetic field and mesh of transmission lines</li>
<li><a href="Uniform_theory_of_diffraction" title="wikilink">Uniform theory of diffraction</a> — specifically designed for scattering problems</li>
</ul></li>
<li><a class="uri" href="Particle-in-cell" title="wikilink">Particle-in-cell</a> — used especially in fluid dynamics
<ul>
<li><a href="Multiphase_particle-in-cell_method" title="wikilink">Multiphase particle-in-cell method</a> — considers solid particles as both numerical particles and fluid</li>
</ul></li>
<li><a href="High-resolution_scheme" title="wikilink">High-resolution scheme</a></li>
<li><a href="Shock_capturing_method" title="wikilink">Shock capturing method</a></li>
<li><a href="Vorticity_confinement" title="wikilink">Vorticity confinement</a> — for vortex-dominated flows in fluid dynamics, similar to shock capturing</li>
<li><a href="Split-step_method" title="wikilink">Split-step method</a></li>
<li><a href="Fast_marching_method" title="wikilink">Fast marching method</a></li>
<li><a href="Orthogonal_collocation" title="wikilink">Orthogonal collocation</a></li>
<li><a href="Lattice_Boltzmann_methods" title="wikilink">Lattice Boltzmann methods</a> — for the solution of the Navier-Stokes equations</li>
<li><a href="Roe_solver" title="wikilink">Roe solver</a> — for the solution of the Euler equation</li>
<li><a href="Relaxation_(iterative_method)" title="wikilink">Relaxation (iterative method)</a> — a method for solving elliptic PDEs by converting them to evolution equations</li>
<li>Broad classes of methods:
<ul>
<li><a href="Mimesis_(mathematics)" title="wikilink">Mimetic methods</a> — methods that respect in some sense the structure of the original problem</li>
<li><a class="uri" href="Multiphysics" title="wikilink">Multiphysics</a> — models consisting of various submodels with different physics</li>
<li><a href="Immersed_boundary_method" title="wikilink">Immersed boundary method</a> — for simulating elastic structures immersed within fluids</li>
</ul></li>
<li><a href="Multisymplectic_integrator" title="wikilink">Multisymplectic integrator</a> — extension of symplectic integrators, which are for ODEs</li>
<li><a href="Stretched_grid_method" title="wikilink">Stretched grid method</a> — for problems solution that can be related to an elastic grid behavior.</li>
</ul>
<h3 id="techniques-for-improving-these-methods">Techniques for improving these methods</h3>
<ul>
<li><a href="Multigrid_method" title="wikilink">Multigrid method</a> — uses a hierarchy of nested meshes to speed up the methods</li>
<li><a href="Domain_decomposition_methods" title="wikilink">Domain decomposition methods</a> — divides the domain in a few subdomains and solves the PDE on these subdomains
<ul>
<li><a href="Additive_Schwarz_method" title="wikilink">Additive Schwarz method</a></li>
<li><a href="Abstract_additive_Schwarz_method" title="wikilink">Abstract additive Schwarz method</a> — abstract version of additive Schwarz without reference to geometric information</li>
<li><a href="Balancing_domain_decomposition_method" title="wikilink">Balancing domain decomposition method</a> (BDD) — preconditioner for symmetric positive definite matrices</li>
<li><a href="BDDC" title="wikilink">Balancing domain decomposition by constraints</a> (BDDC) — further development of BDD</li>
<li><a href="FETI" title="wikilink">Finite element tearing and interconnect</a> (FETI)</li>
<li><a class="uri" href="FETI-DP" title="wikilink">FETI-DP</a> — further development of FETI</li>
<li><a href="Fictitious_domain_method" title="wikilink">Fictitious domain method</a> — preconditioner constructed with a structured mesh on a fictitious domain of simple shape</li>
<li><a href="Mortar_methods" title="wikilink">Mortar methods</a> — meshes on subdomain do not mesh</li>
<li><a href="Neumann–Dirichlet_method" title="wikilink">Neumann–Dirichlet method</a> — combines Neumann problem on one subdomain with Dirichlet problem on other subdomain</li>
<li><a href="Neumann–Neumann_methods" title="wikilink">Neumann–Neumann methods</a> — domain decomposition methods that use Neumann problems on the subdomains</li>
<li><a href="Poincaré–Steklov_operator" title="wikilink">Poincaré–Steklov operator</a> — maps tangential electric field onto the equivalent electric current</li>
<li><a href="Schur_complement_method" title="wikilink">Schur complement method</a> — early and basic method on subdomains that do not overlap</li>
<li><a href="Schwarz_alternating_method" title="wikilink">Schwarz alternating method</a> — early and basic method on subdomains that overlap</li>
</ul></li>
<li><a href="Coarse_space_(numerical_analysis)" title="wikilink">Coarse space</a> — variant of the problem which uses a discretization with fewer degrees of freedom</li>
<li><a href="Adaptive_mesh_refinement" title="wikilink">Adaptive mesh refinement</a> — uses the computed solution to refine the mesh only where necessary</li>
<li><a href="Fast_multipole_method" title="wikilink">Fast multipole method</a> — hierarchical method for evaluating particle-particle interactions</li>
<li><a href="Perfectly_matched_layer" title="wikilink">Perfectly matched layer</a> — artificial absorbing layer for wave equations, used to implement absorbing boundary conditions</li>
</ul>
<h3 id="grids-and-meshes">Grids and meshes</h3>
<ul>
<li><a href="Grid_classification" title="wikilink">Grid classification</a> / <a href="Types_of_mesh" title="wikilink">Types of mesh</a>:
<ul>
<li><a href="Polygon_mesh" title="wikilink">Polygon mesh</a> — consists of polygons in 2D or 3D</li>
<li><a href="Triangle_mesh" title="wikilink">Triangle mesh</a> — consists of triangles in 2D or 3D
<ul>
<li><a href="Triangulation_(geometry)" title="wikilink">Triangulation (geometry)</a> — subdivision of given region in triangles, or higher-dimensional analogue</li>
<li><a href="Nonobtuse_mesh" title="wikilink">Nonobtuse mesh</a> — mesh in which all angles are less than or equal to 90°</li>
<li><a href="Point_set_triangulation" title="wikilink">Point set triangulation</a> — triangle mesh such that given set of point are all a vertex of a triangle</li>
<li><a href="Polygon_triangulation" title="wikilink">Polygon triangulation</a> — triangle mesh inside a polygon</li>
<li><a href="Delaunay_triangulation" title="wikilink">Delaunay triangulation</a> — triangulation such that no vertex is inside the circumcentre of a triangle</li>
<li><a href="Constrained_Delaunay_triangulation" title="wikilink">Constrained Delaunay triangulation</a> — generalization of the Delaunay triangulation that forces certain required segments into the triangulation</li>
<li><a href="Pitteway_triangulation" title="wikilink">Pitteway triangulation</a> — for any point, triangle containing it has nearest neighbour of the point as a vertex</li>
<li><a href="Minimum-weight_triangulation" title="wikilink">Minimum-weight triangulation</a> — triangulation of minimum total edge length</li>
<li><a href="Kinetic_triangulation" title="wikilink">Kinetic triangulation</a> — a triangulation that moves over time</li>
<li><a href="Triangulated_irregular_network" title="wikilink">Triangulated irregular network</a></li>
<li><a class="uri" href="Quasi-triangulation" title="wikilink">Quasi-triangulation</a> — subdivision into simplices, where vertiсes are not points but arbitrary sloped line segments</li>
</ul></li>
<li><a href="Volume_mesh" title="wikilink">Volume mesh</a> — consists of three-dimensional shapes</li>
<li><a href="Regular_grid" title="wikilink">Regular grid</a> — consists of congruent parallelograms, or higher-dimensional analogue</li>
<li><a href="Unstructured_grid" title="wikilink">Unstructured grid</a></li>
<li><a href="Geodesic_grid" title="wikilink">Geodesic grid</a> — isotropic grid on a sphere</li>
</ul></li>
<li><a href="Mesh_generation" title="wikilink">Mesh generation</a>
<ul>
<li><a href="Image-based_meshing" title="wikilink">Image-based meshing</a> — automatic procedure of generating meshes from 3D image data</li>
<li><a href="Marching_cubes" title="wikilink">Marching cubes</a> — extracts a polygon mesh from a scalar field</li>
<li><a href="Parallel_mesh_generation" title="wikilink">Parallel mesh generation</a></li>
<li><a href="Ruppert's_algorithm" title="wikilink">Ruppert's algorithm</a> — creates quality Delauney triangularization from piecewise linear data</li>
</ul></li>
<li>Subdivisions:</li>
<li><a href="Apollonian_network" title="wikilink">Apollonian network</a> — undirected graph formed by recursively subdividing a triangle</li>
<li><a href="Barycentric_subdivision" title="wikilink">Barycentric subdivision</a> — standard way of dividing arbitrary convex polygons into triangles, or the higher-dimensional analogue</li>
<li>Improving an existing mesh:
<ul>
<li><a href="Chew's_second_algorithm" title="wikilink">Chew's second algorithm</a> — improves Delauney triangularization by refining poor-quality triangles</li>
<li><a href="Laplacian_smoothing" title="wikilink">Laplacian smoothing</a> — improves polynomial meshes by moving the vertices</li>
</ul></li>
<li><a href="Jump-and-Walk_algorithm" title="wikilink">Jump-and-Walk algorithm</a> — for finding triangle in a mesh containing a given point</li>
<li><a href="Spatial_twist_continuum" title="wikilink">Spatial twist continuum</a> — dual representation of a mesh consisting of hexahedra</li>
<li><a class="uri" href="Pseudotriangle" title="wikilink">Pseudotriangle</a> — simply connected region between any three mutually tangent convex sets</li>
<li><a href="Simplicial_complex" title="wikilink">Simplicial complex</a> — all vertices, line segments, triangles, tetrahedra, …, making up a mesh</li>
</ul>
<h3 id="analysis">Analysis</h3>
<ul>
<li><a href="Lax_equivalence_theorem" title="wikilink">Lax equivalence theorem</a> — a consistent method is convergent if and only if it is stable</li>
<li><a href="Courant–Friedrichs–Lewy_condition" title="wikilink">Courant–Friedrichs–Lewy condition</a> — stability condition for hyperbolic PDEs</li>
<li><a href="Von_Neumann_stability_analysis" title="wikilink">Von Neumann stability analysis</a> — all Fourier components of the error should be stable</li>
<li><a href="Numerical_diffusion" title="wikilink">Numerical diffusion</a> — diffusion introduced by the numerical method, above to that which is naturally present
<ul>
<li><a href="False_diffusion" title="wikilink">False diffusion</a></li>
</ul></li>
<li><a href="Numerical_resistivity" title="wikilink">Numerical resistivity</a> — the same, with resistivity instead of diffusion</li>
<li><a href="Weak_formulation" title="wikilink">Weak formulation</a> — a functional-analytic reformulation of the PDE necessary for some methods</li>
<li><a href="Total_variation_diminishing" title="wikilink">Total variation diminishing</a> — property of schemes that do not introduce spurious oscillations</li>
<li><a href="Godunov's_theorem" title="wikilink">Godunov's theorem</a> — linear monotone schemes can only be of first order</li>
<li><a href="Motz's_problem" title="wikilink">Motz's problem</a> — benchmark problem for singularity problems</li>
</ul>
<h2 id="monte-carlo-method"><a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a></h2>
<ul>
<li>Variants of the Monte Carlo method:
<ul>
<li><a href="Direct_simulation_Monte_Carlo" title="wikilink">Direct simulation Monte Carlo</a></li>
<li><a href="Quasi-Monte_Carlo_method" title="wikilink">Quasi-Monte Carlo method</a></li>
<li><a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a>
<ul>
<li><a href="Metropolis–Hastings_algorithm" title="wikilink">Metropolis–Hastings algorithm</a>
<ul>
<li><a href="Multiple-try_Metropolis" title="wikilink">Multiple-try Metropolis</a> — modification which allows larger step sizes</li>
<li><a href="Wang_and_Landau_algorithm" title="wikilink">Wang and Landau algorithm</a> — extension of Metropolis Monte Carlo</li>
<li><a href="Equation_of_State_Calculations_by_Fast_Computing_Machines" title="wikilink">Equation of State Calculations by Fast Computing Machines</a> — 1953 article proposing the Metropolis Monte Carlo algorithm</li>
<li><a href="Multicanonical_ensemble" title="wikilink">Multicanonical ensemble</a> — sampling technique that uses Metropolis–Hastings to compute integrals</li>
</ul></li>
<li><a href="Gibbs_sampling" title="wikilink">Gibbs sampling</a></li>
<li><a href="Coupling_from_the_past" title="wikilink">Coupling from the past</a></li>
<li><a href="Reversible-jump_Markov_chain_Monte_Carlo" title="wikilink">Reversible-jump Markov chain Monte Carlo</a></li>
</ul></li>
<li><a href="Dynamic_Monte_Carlo_method" title="wikilink">Dynamic Monte Carlo method</a>
<ul>
<li><a href="Kinetic_Monte_Carlo" title="wikilink">Kinetic Monte Carlo</a></li>
<li><a href="Gillespie_algorithm" title="wikilink">Gillespie algorithm</a></li>
</ul></li>
<li><a href="Particle_filter" title="wikilink">Particle filter</a>
<ul>
<li><a href="Auxiliary_particle_filter" title="wikilink">Auxiliary particle filter</a></li>
</ul></li>
<li><a href="Reverse_Monte_Carlo" title="wikilink">Reverse Monte Carlo</a></li>
<li><a href="Demon_algorithm" title="wikilink">Demon algorithm</a></li>
</ul></li>
<li><a href="Pseudo-random_number_sampling" title="wikilink">Pseudo-random number sampling</a>
<ul>
<li><a href="Inverse_transform_sampling" title="wikilink">Inverse transform sampling</a> — general and straightforward method but computationally expensive</li>
<li><a href="Rejection_sampling" title="wikilink">Rejection sampling</a> — sample from a simpler distribution but reject some of the samples
<ul>
<li><a href="Ziggurat_algorithm" title="wikilink">Ziggurat algorithm</a> — uses a pre-computed table covering the probability distribution with rectangular segments</li>
</ul></li>
<li>For sampling from a normal distribution:
<ul>
<li><a href="Box–Muller_transform" title="wikilink">Box–Muller transform</a></li>
<li><a href="Marsaglia_polar_method" title="wikilink">Marsaglia polar method</a></li>
</ul></li>
<li><a href="Convolution_random_number_generator" title="wikilink">Convolution random number generator</a> — generates a random variable as a sum of other random variables</li>
<li><a href="Indexed_search" title="wikilink">Indexed search</a></li>
</ul></li>
<li><a href="Variance_reduction" title="wikilink">Variance reduction</a> techniques:
<ul>
<li><a href="Antithetic_variates" title="wikilink">Antithetic variates</a></li>
<li><a href="Control_variates" title="wikilink">Control variates</a></li>
<li><a href="Importance_sampling" title="wikilink">Importance sampling</a></li>
<li><a href="Stratified_sampling" title="wikilink">Stratified sampling</a></li>
<li><a href="VEGAS_algorithm" title="wikilink">VEGAS algorithm</a></li>
</ul></li>
<li><a href="Low-discrepancy_sequence" title="wikilink">Low-discrepancy sequence</a>
<ul>
<li><a href="Constructions_of_low-discrepancy_sequences" title="wikilink">Constructions of low-discrepancy sequences</a></li>
</ul></li>
<li><a href="Event_generator" title="wikilink">Event generator</a></li>
<li><a href="Parallel_tempering" title="wikilink">Parallel tempering</a></li>
<li><a href="Umbrella_sampling" title="wikilink">Umbrella sampling</a> — improves sampling in physical systems with significant energy barriers</li>
<li><a href="Hybrid_Monte_Carlo" title="wikilink">Hybrid Monte Carlo</a></li>
<li><a href="Ensemble_Kalman_filter" title="wikilink">Ensemble Kalman filter</a> — recursive filter suitable for problems with a large number of variables</li>
<li><a href="Transition_path_sampling" title="wikilink">Transition path sampling</a></li>
<li><a href="Walk-on-spheres_method" title="wikilink">Walk-on-spheres method</a> — to generate exit-points of Brownian motion from bounded domains</li>
<li>Applications:
<ul>
<li><a href="Ensemble_forecasting" title="wikilink">Ensemble forecasting</a> — produce multiple numerical predictions from slightly initial conditions or parameters</li>
<li><a href="Bond_fluctuation_model" title="wikilink">Bond fluctuation model</a> — for simulating the conformation and dynamics of polymer systems</li>
<li><a href="Iterated_filtering" title="wikilink">Iterated filtering</a></li>
<li><a href="Metropolis_light_transport" title="wikilink">Metropolis light transport</a></li>
<li><a href="Monte_Carlo_localization" title="wikilink">Monte Carlo localization</a> — estimates the position and orientation of a robot</li>
<li><a href="Monte_Carlo_methods_for_electron_transport" title="wikilink">Monte Carlo methods for electron transport</a></li>
<li><a href="Monte_Carlo_method_for_photon_transport" title="wikilink">Monte Carlo method for photon transport</a></li>
<li><a href="Monte_Carlo_methods_in_finance" title="wikilink">Monte Carlo methods in finance</a>
<ul>
<li><a href="Monte_Carlo_methods_for_option_pricing" title="wikilink">Monte Carlo methods for option pricing</a></li>
<li><a href="Quasi-Monte_Carlo_methods_in_finance" title="wikilink">Quasi-Monte Carlo methods in finance</a></li>
</ul></li>
<li><a href="Monte_Carlo_molecular_modeling" title="wikilink">Monte Carlo molecular modeling</a>
<ul>
<li><a href="Path_integral_molecular_dynamics" title="wikilink">Path integral molecular dynamics</a> — incorporates Feynman path integrals</li>
</ul></li>
<li><a href="Quantum_Monte_Carlo" title="wikilink">Quantum Monte Carlo</a>
<ul>
<li><a href="Diffusion_Monte_Carlo" title="wikilink">Diffusion Monte Carlo</a> — uses a Green function to solve the Schrödinger equation</li>
<li><a href="Gaussian_quantum_Monte_Carlo" title="wikilink">Gaussian quantum Monte Carlo</a></li>
<li><a href="Path_integral_Monte_Carlo" title="wikilink">Path integral Monte Carlo</a></li>
<li><a href="Reptation_Monte_Carlo" title="wikilink">Reptation Monte Carlo</a></li>
<li><a href="Variational_Monte_Carlo" title="wikilink">Variational Monte Carlo</a></li>
</ul></li>
<li>Methods for simulating the Ising model:
<ul>
<li><a href="Swendsen–Wang_algorithm" title="wikilink">Swendsen–Wang algorithm</a> — entire sample is divided into equal-spin clusters</li>
<li><a href="Wolff_algorithm" title="wikilink">Wolff algorithm</a> — improvement of the Swendsen–Wang algorithm</li>
<li><a href="Metropolis–Hastings_algorithm" title="wikilink">Metropolis–Hastings algorithm</a></li>
</ul></li>
<li><a href="Auxiliary_field_Monte_Carlo" title="wikilink">Auxiliary field Monte Carlo</a> — computes averages of operators in many-body quantum mechanical problems</li>
<li><a href="Cross-entropy_method" title="wikilink">Cross-entropy method</a> — for multi-extremal optimization and importance sampling</li>
</ul></li>
<li>Also see the <a href="list_of_statistics_topics" title="wikilink">list of statistics topics</a></li>
</ul>
<h2 id="applications-1">Applications</h2>
<ul>
<li><a href="Computational_physics" title="wikilink">Computational physics</a>
<ul>
<li><a href="Computational_electromagnetics" title="wikilink">Computational electromagnetics</a></li>
<li><a href="Computational_fluid_dynamics" title="wikilink">Computational fluid dynamics</a> (CFD)
<ul>
<li><a href="Numerical_methods_in_fluid_mechanics" title="wikilink">Numerical methods in fluid mechanics</a></li>
<li><a href="Large_eddy_simulation" title="wikilink">Large eddy simulation</a></li>
<li><a href="Smoothed-particle_hydrodynamics" title="wikilink">Smoothed-particle hydrodynamics</a></li>
<li><a href="Aeroacoustic_analogy" title="wikilink">Aeroacoustic analogy</a> — used in numerical aeroacoustics to reduce sound sources to simple emitter types</li>
<li><a href="Stochastic_Eulerian_Lagrangian_method" title="wikilink">Stochastic Eulerian Lagrangian method</a> — uses Eulerian description for fluids and Lagrangian for structures</li>
<li><a href="Explicit_algebraic_stress_model" title="wikilink">Explicit algebraic stress model</a></li>
</ul></li>
<li><a href="Computational_magnetohydrodynamics" title="wikilink">Computational magnetohydrodynamics</a> (CMHD) — studies electrically conducting fluids</li>
<li><a href="Climate_model" title="wikilink">Climate model</a></li>
<li><a href="Numerical_weather_prediction" title="wikilink">Numerical weather prediction</a>
<ul>
<li><a href="Geodesic_grid" title="wikilink">Geodesic grid</a></li>
</ul></li>
<li><a href="Celestial_mechanics" title="wikilink">Celestial mechanics</a>
<ul>
<li><a href="Numerical_model_of_the_Solar_System" title="wikilink">Numerical model of the Solar System</a></li>
</ul></li>
<li><a href="Quantum_jump_method" title="wikilink">Quantum jump method</a> — used for simulating open quantum systems, operates on wave function</li>
<li><a href="Dynamic_Design_Analysis_Method" title="wikilink">Dynamic Design Analysis Method</a> (DDAM) — for evaluating effect of underwater explosions on equipment</li>
</ul></li>
<li><a href="Computational_chemistry" title="wikilink">Computational chemistry</a>
<ul>
<li><a href="Cell_lists" title="wikilink">Cell lists</a></li>
<li><a href="Coupled_cluster" title="wikilink">Coupled cluster</a></li>
<li><a href="Density_functional_theory" title="wikilink">Density functional theory</a></li>
<li><a class="uri" href="DIIS" title="wikilink">DIIS</a> — direct inversion in (or of) the iterative subspace</li>
</ul></li>
<li><a href="Computational_sociology" title="wikilink">Computational sociology</a></li>
<li><a href="Computational_statistics" title="wikilink">Computational statistics</a></li>
</ul>
<h2 id="software">Software</h2>

<p>For a large list of software, see the <a href="list_of_numerical_analysis_software" title="wikilink">list of numerical analysis software</a>.</p>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">*Topics</a> <a href="Category:Mathematics-related_lists" title="wikilink">Numerical analysis topics</a> <a href="Category:Outlines" title="wikilink">Numerical analysis</a></p>
</body>
</html>
