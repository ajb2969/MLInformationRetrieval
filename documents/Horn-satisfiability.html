<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="84">Horn-satisfiability</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Horn-satisfiability</h1>
<hr/>

<p>In <a href="formal_logic" title="wikilink">formal logic</a>, <strong>Horn-satisfiability</strong>, or <strong>HORNSAT</strong>, is the problem of deciding whether a given set of propositional <a href="Horn_clause" title="wikilink">Horn clauses</a> is satisfiable or not.</p>

<p>A Horn clause is a <a href="Clause_(logic)" title="wikilink">clause</a> with at most one positive <a href="literal_(mathematical_logic)" title="wikilink">literal</a>, called the <em>head</em> of the clause, and any number of negative literals, forming the <em>body</em> of the clause. A Horn formula is a <a href="propositional_formula" title="wikilink">propositional formula</a> formed by <a href="logical_and" title="wikilink">conjunction</a> of Horn clauses.</p>

<p>The problem of Horn satisfiability is solvable in <a href="linear_time" title="wikilink">linear time</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A polynomial-time algorithm for Horn satisfiability is based on the rule of <a href="unit_propagation" title="wikilink">unit propagation</a>: if the formula contains a clause composed of a single literal 

<math display="inline" id="Horn-satisfiability:0">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 (a unit clause), then all clauses containing 

<math display="inline" id="Horn-satisfiability:1">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 (except the unit clause itself) are removed, and all clauses containing 

<math display="inline" id="Horn-satisfiability:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg l
  </annotation>
 </semantics>
</math>

 have this literal removed. The result of the second rule may itself be a unit clause, which is propagated in the same manner. If there are no unit clauses, the formula can be satisfied by simply setting all remaining variables negative. The formula is unsatisfiable if this transformation generates a pair of opposite unit clauses 

<math display="inline" id="Horn-satisfiability:3">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Horn-satisfiability:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg l
  </annotation>
 </semantics>
</math>

. Horn satisfiability is actually one of the "hardest" or "most expressive" problems which is known to be computable in polynomial time, in the sense that it is a <a href="P-complete" title="wikilink"><strong>P</strong>-complete</a> problem.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>This algorithm also allows determining a truth assignment of satisfiable Horn formulae: all variables contained in a unit clause are set to the value satisfying that unit clause; all other literals are set to false. The resulting assignment is the minimal model of the Horn formula, that is, the assignment having a minimal set of variables assigned to true, where comparison is made using set containment.</p>

<p>Using a linear algorithm for unit propagation, the algorithm is linear in the size of the formula.</p>

<p>A generalization of the class of Horn formulae is that of renamable-Horn formulae, which is the set of formulae that can be placed in Horn form by replacing some variables with their respective negation. Checking the existence of such a replacement can be done in linear time; therefore, the satisfiability of such formulae is in P as it can be solved by first performing this replacement and then checking the satisfiability of the resulting Horn formula.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The Horn satisfiability problem can also be asked for propositional <a href="many-valued_logic" title="wikilink">many-valued logics</a>. The algorithms are not usually linear, but some are polynomial; see Hähnle (2001 or 2003) for a survey.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Unit_propagation" title="wikilink">Unit propagation</a></li>
<li><a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a></li>
<li><a class="uri" href="2-satisfiability" title="wikilink">2-satisfiability</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:P-complete_problems" title="wikilink">Category:P-complete problems</a> <a href="Category:Satisfiability_problems" title="wikilink">Category:Satisfiability problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Dowling, W., and Gallier, J., (1984) "Linear-time algorithms for testing the satisfiability of propositional Horn formulae". <em><a href="Journal_of_Logic_Programming" title="wikilink">Journal of Logic Programming</a></em>, <strong>3</strong>, 267-284<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
