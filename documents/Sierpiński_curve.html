<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="369">Sierpiński curve</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sierpiński curve</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Sierpiński curves</strong> are a recursively defined sequence of <a href="Geometric_continuity" title="wikilink">continuous</a> closed plane <a class="uri" href="fractal" title="wikilink">fractal</a> <a href="curve" title="wikilink">curves</a> discovered by <a href="Wacław_Sierpiński" title="wikilink">Wacław Sierpiński</a>, which in the limit 

<math display="inline" id="Sierpiński_curve:0">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>n</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\rightarrow\infty
  </annotation>
 </semantics>
</math>

 completely fill the unit square: thus their limit curve, also called <strong>the Sierpiński curve</strong>, is an example of a <a href="space-filling_curve" title="wikilink">space-filling curve</a>.</p>

<p>Because the Sierpiński curve is space-filling, its <a href="Hausdorff_dimension" title="wikilink">Hausdorff dimension</a> (in the limit 

<math display="inline" id="Sierpiński_curve:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>n</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\rightarrow\infty
  </annotation>
 </semantics>
</math>

) is 

<math display="inline" id="Sierpiński_curve:2">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

.<br/>
The <a href="euclidean_distance" title="wikilink">Euclidean length</a> of</p>

<p>

<math display="block" id="Sierpiński_curve:3">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{n}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Sierpiński_curve:4">
 <semantics>
  <mrow>
   <msub>
    <mi>l</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>2</mn>
      <mn>3</mn>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <msqrt>
        <mn>2</mn>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>3</mn>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mo>-</mo>
       <msqrt>
        <mn>2</mn>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{n}={2\over 3}(1+\sqrt{2})2^{n}-{1\over 3}(2-\sqrt{2}){1\over 2^{n}}
  </annotation>
 </semantics>
</math>

,</p>

<p>i.e., it grows <em>exponentially</em> with 

<math display="inline" id="Sierpiński_curve:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 beyond any limit, whereas the limit for 

<math display="inline" id="Sierpiński_curve:6">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>n</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\rightarrow\infty
  </annotation>
 </semantics>
</math>

 of the area enclosed by 

<math display="inline" id="Sierpiński_curve:7">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{n}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Sierpiński_curve:8">
 <semantics>
  <mrow>
   <mn>5</mn>
   <mo>/</mo>
   <mpadded width="+1.7pt">
    <mn>12</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">5</cn>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   5/12\,
  </annotation>
 </semantics>
</math>

 that of the square (in Euclidean metric).</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Sierpiński curve of first order</figcaption>
</figure></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Sierpiński curves of orders 1 and 2</figcaption>
</figure></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Sierpiński curves of orders 1 to 3</figcaption>
</figure></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>
<h2 id="uses-of-the-curve">Uses of the curve</h2>

<p>The Sierpiński curve is useful in several practical applications because it is more symmetrical than other commonly studied space-filling curves. For example, it has been used as a basis for the rapid construction of an approximate solution to the <a href="Travelling_Salesman_Problem" title="wikilink">Travelling Salesman Problem</a> (which asks for the shortest sequence of a given set of points): The heuristic is simply to visit the points in the same sequence as they appear on the Sierpiński curve. To do this requires two steps: First compute an inverse image of each point to be visited; then sort the values. This idea has been used to build routing systems for commercial vehicles based only on Rolodex card files.</p>

<p>A space-filling curve is a continuous map of the unit interval onto a unit square and so a (pseudo) inverse maps the unit square to the unit interval. One way of constructing a pseudo-inverse is as follows. Let the lower-left corner (0, 0) of the unit square correspond to 0.0 (and 1.0). Then the upper-left corner (0, 1) must correspond to 0.25, the upper-right corner (1, 1) to 0.50, and the lower-right corner (1, 0) to 0.75. The inverse map of interior points are computed by taking advantage of the recursive structure of the curve. Here is a function coded in Java that will compute the relative position of any point on the Sierpiński curve (that is, a pseudo-inverse value). It takes as input the coordinates of the point (x,y) to be inverted, and the corners of an enclosing right isosceles triangle (ax, ay), (bx, by), and (cx, cy). (Note that the unit square is the union of two such triangles.) The remaining parameters specify the level of accuracy to which the inverse should be computed.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="dt">static</span> <span class="dt">long</span> <span class="fu">sierp_pt2code</span>( <span class="dt">double</span> ax, <span class="dt">double</span> ay, <span class="dt">double</span> bx, <span class="dt">double</span> by, <span class="dt">double</span> cx, <span class="dt">double</span> cy,
        <span class="dt">int</span> currentLevel, <span class="dt">int</span> maxLevel, <span class="dt">long</span> code, <span class="dt">double</span> x, <span class="dt">double</span> y ) 
    {
        <span class="kw">if</span> (currentLevel &lt;= maxLevel) {
            currentLevel++;
            <span class="kw">if</span> ((<span class="fu">sqr</span>(x-ax) + <span class="fu">sqr</span>(y-ay)) &lt; (<span class="fu">sqr</span>(x-cx) + <span class="fu">sqr</span>(y-cy))) {
                code = <span class="fu">sierp_pt2code</span>( ax, ay, (ax+cx)/<span class="fl">2.0</span>, (ay+cy)/<span class="fl">2.0</span>, bx, by,
                    currentLevel, maxLevel, <span class="dv">2</span> * code + <span class="dv">0</span>, x, y );
            }
            <span class="kw">else</span> {
                code = <span class="fu">sierp_pt2code</span>( bx, by, (ax+cx)/<span class="fl">2.0</span>, (ay+cy)/<span class="fl">2.0</span>, cx, cy,
                    currentLevel, maxLevel, <span class="dv">2</span> * code + <span class="dv">1</span>, x, y );
            }
        }
        <span class="kw">return</span> code;    
    }</code></pre></div>
<h2 id="drawing-the-curve">Drawing the curve</h2>

<p>The following <a href="Java_(programming_language)" title="wikilink">Java</a> <a class="uri" href="applet" title="wikilink">applet</a> draws a Sierpiński curve by means of four <a href="mutually_recursive" title="wikilink">mutually recursive</a> methods (methods that call one another):</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.applet.Applet;</span>
<span class="kw">import java.awt.Graphics;</span>
<span class="kw">import java.awt.Image;</span>

<span class="kw">public</span> <span class="kw">class</span> SierpinskyCurve <span class="kw">extends</span> Applet {

    <span class="kw">private</span> SimpleGraphics sg = <span class="kw">null</span>;
    <span class="kw">private</span> <span class="dt">int</span> dist0 = <span class="dv">128</span>, dist;
    <span class="kw">private</span> Image offscrBuf;
    <span class="kw">private</span> Graphics offscrGfx;

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">init</span>() {
        sg = <span class="kw">new</span> <span class="fu">SimpleGraphics</span>(<span class="fu">getGraphics</span>());
        dist0 = <span class="dv">100</span>;
        <span class="fu">resize</span>(<span class="dv">4</span> * dist0, <span class="dv">4</span> * dist0);
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">update</span>(Graphics g) {
        <span class="fu">paint</span>(g);
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">paint</span>(Graphics g) {

        <span class="kw">if</span> (g == <span class="kw">null</span>)
            <span class="kw">throw</span> <span class="kw">new</span> NullPointerException();

        <span class="kw">if</span> (offscrBuf == <span class="kw">null</span>) {
            offscrBuf = <span class="fu">createImage</span>(<span class="kw">this</span>.<span class="fu">getWidth</span>(), <span class="kw">this</span>.<span class="fu">getHeight</span>());
            offscrGfx = offscrBuf.<span class="fu">getGraphics</span>();
            sg.<span class="fu">setGraphics</span>(offscrGfx);
        }

        <span class="dt">int</span> level = <span class="dv">3</span>;
        dist = dist0;
        <span class="kw">for</span> (<span class="dt">int</span> i = level; i &gt; <span class="dv">0</span>; i--)
            dist /= <span class="dv">2</span>;
        sg.<span class="fu">goToXY</span>(<span class="dv">2</span> * dist, dist);
        <span class="fu">sierpA</span>(level); <span class="co">// start recursion</span>
        sg.<span class="fu">lineRel</span>('X', +dist, +dist);
        <span class="fu">sierpB</span>(level); <span class="co">// start recursion</span>
        sg.<span class="fu">lineRel</span>('X', -dist, +dist);
        <span class="fu">sierpC</span>(level); <span class="co">// start recursion</span>
        sg.<span class="fu">lineRel</span>('X', -dist, -dist);
        <span class="fu">sierpD</span>(level); <span class="co">// start recursion</span>
        sg.<span class="fu">lineRel</span>('X', +dist, -dist);

        g.<span class="fu">drawImage</span>(offscrBuf, <span class="dv">0</span>, <span class="dv">0</span>, <span class="kw">this</span>);

    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">sierpA</span>(<span class="dt">int</span> level) {
        <span class="kw">if</span> (level &gt; <span class="dv">0</span>) {
            <span class="fu">sierpA</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('A', +dist, +dist);
            <span class="fu">sierpB</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('A', +<span class="dv">2</span> * dist, <span class="dv">0</span>);
            <span class="fu">sierpD</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('A', +dist, -dist);
            <span class="fu">sierpA</span>(level - <span class="dv">1</span>);
        }
    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">sierpB</span>(<span class="dt">int</span> level) {
        <span class="kw">if</span> (level &gt; <span class="dv">0</span>) {
            <span class="fu">sierpB</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('B', -dist, +dist);
            <span class="fu">sierpC</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('B', <span class="dv">0</span>, +<span class="dv">2</span> * dist);
            <span class="fu">sierpA</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('B', +dist, +dist);
            <span class="fu">sierpB</span>(level - <span class="dv">1</span>);
        }
    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">sierpC</span>(<span class="dt">int</span> level) {
        <span class="kw">if</span> (level &gt; <span class="dv">0</span>) {
            <span class="fu">sierpC</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('C', -dist, -dist);
            <span class="fu">sierpD</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('C', -<span class="dv">2</span> * dist, <span class="dv">0</span>);
            <span class="fu">sierpB</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('C', -dist, +dist);
            <span class="fu">sierpC</span>(level - <span class="dv">1</span>);
        }
    }

    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">sierpD</span>(<span class="dt">int</span> level) {
        <span class="kw">if</span> (level &gt; <span class="dv">0</span>) {
            <span class="fu">sierpD</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('D', +dist, -dist);
            <span class="fu">sierpA</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('D', <span class="dv">0</span>, -<span class="dv">2</span> * dist);
            <span class="fu">sierpC</span>(level - <span class="dv">1</span>);
            sg.<span class="fu">lineRel</span>('D', -dist, -dist);
            <span class="fu">sierpD</span>(level - <span class="dv">1</span>);
        }
    }
}

<span class="kw">class</span> SimpleGraphics {
    <span class="kw">private</span> Graphics g = <span class="kw">null</span>;
    <span class="kw">private</span> <span class="dt">int</span> x = <span class="dv">0</span>, y = <span class="dv">0</span>;

    <span class="kw">public</span> <span class="fu">SimpleGraphics</span>(Graphics g) {
        <span class="fu">setGraphics</span>(g);
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">setGraphics</span>(Graphics g) {
        <span class="kw">this</span>.<span class="fu">g</span> = g;
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">goToXY</span>(<span class="dt">int</span> x, <span class="dt">int</span> y) {
        <span class="kw">this</span>.<span class="fu">x</span> = x;
        <span class="kw">this</span>.<span class="fu">y</span> = y;
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">lineRel</span>(<span class="dt">char</span> s, <span class="dt">int</span> deltaX, <span class="dt">int</span> deltaY) {
        g.<span class="fu">drawLine</span>(x, y, x + deltaX, y + deltaY);
        x += deltaX;
        y += deltaY;
    }
}</code></pre></div>

<p>The following <a href="Logo_(programming_language)" title="wikilink">Logo</a> program draws a Sierpiński curve by means of <a class="uri" href="recursion" title="wikilink">recursion</a>. <code>

 to half.sierpinski :size :level
  if :level = 0 [forward :size stop]
  half.sierpinski :size :level - 1
  left 45
  forward :size * sqrt 2 
  left 45
  half.sierpinski :size :level - 1
  right 90
  forward :size 
  right 90
  half.sierpinski :size :level - 1
  left 45
  forward :size * sqrt 2 
  left 45
  half.sierpinski :size :level - 1
 end

 to sierpinski :size :level
  half.sierpinski :size :level
  right 90
  forward :size
  right 90
  half.sierpinski :size :level
  right 90
  forward :size
  right 90
 end

</code></p>
<h2 id="references">References</h2>
<ol>
<li>
</li>
<li>
</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Hilbert_curve" title="wikilink">Hilbert curve</a></li>
<li><a href="Koch_snowflake" title="wikilink">Koch snowflake</a></li>
<li><a href="Moore_curve" title="wikilink">Moore curve</a></li>
<li><a href="Peano_curve" title="wikilink">Peano curve</a></li>
<li><a href="Sierpiński_arrowhead_curve" title="wikilink">Sierpiński arrowhead curve</a></li>
<li><a href="List_of_fractals_by_Hausdorff_dimension" title="wikilink">List of fractals by Hausdorff dimension</a></li>
<li><a href="Recursion_(computer_science)" title="wikilink">Recursion (computer science)</a></li>
<li><a href="Sierpinski_triangle" title="wikilink">Sierpinski triangle</a></li>
</ul>

<p>"</p>

<p><a href="Category:Fractal_curves" title="wikilink">Category:Fractal curves</a> <a href="Category:Science_and_technology_in_Poland" title="wikilink">Category:Science and technology in Poland</a> <a href="Category:Articles_with_example_Java_code" title="wikilink">Category:Articles with example Java code</a></p>
</body>

