   Exponentiation by squaring      Exponentiation by squaring  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In mathematics and computer programming , exponentiating by squaring is a general method for fast computation of large positive integer powers of a number , or more generally of an element of a semigroup , like a polynomial or a square matrix . Some variants are commonly referred to as square-and-multiply algorithms or binary exponentiation . These can be of quite general use, for example in modular arithmetic or powering of matrices. For semigroups for which additive notation is commonly used, like elliptic curves used in cryptography , this method is also referred to as double-and-add .  Basic method  The method is based on the observation that, for a positive integer n , we have       x  n   =   {        x     (   x  2   )     n  -  1   2     ,      if  n  is odd          (   x  2   )    n  2    ,       if  n  is even   .            superscript  x  n    cases    x   superscript   superscript  x  2       n  1   2       if  n  is odd    superscript   superscript  x  2     n  2      if  n  is even      x^{n}=\begin{cases}x\,(x^{2})^{\frac{n-1}{2}},&\mbox{if }n\mbox{ is odd}\\
 (x^{2})^{\frac{n}{2}},&\mbox{if }n\mbox{ is even}.\end{cases}     This may be easily implemented as the following recursive algorithm :   Function exp-by-squaring(x, n ) if n < 0  then return exp-by-squaring( 1 / x, - n ); else  if n = 0  then return 1 ; else  if n = 1  then return  x ; else  if n is even then return exp-by-squaring(x * x,  n / 2 ); else  if n is odd then return x * exp-by-squaring(x * x, (n - 1 ) / 2 ).  Although not tail-recursive , this algorithm may be rewritten into a tail recursive algorithm by introducing an auxiliary function:   Function exp-by-squaring(x, n)
     exp-by-squaring2( 1 , x, n) Function exp-by-squaring2(y, x, n) if n < 0  then return exp-by-squaring2(y, 1 / x, - n); else  if n = 0  then return  y; else  if n = 1  then return  x * y; else  if n is even then return exp-by-squaring2(y, x * x,  n / 2 ); else  if n is odd then return exp-by-squaring2(x * y, x * x, (n - 1 ) / 2 ).  The iterative version of the algorithm also uses a bounded auxiliary space, and is given by   Function exp-by-squaring-iterative(x, n) if n < 0  then x := 1 / x;
       n := -n; if n = 0  then return 1 y := 1 ; while n > 1  do  if n is even then x := x * x;
         n := n / 2 ; else y := x * y
         x := x * x;
         n := (n – 1 ) / 2 ;
     return x * y  Computational complexity  A brief analysis shows that such an algorithm uses    ⌊    log  2   n   ⌋        subscript   2   n     \lfloor\log_{2}n\rfloor   squarings and at most    ⌊    log  2   n   ⌋        subscript   2   n     \lfloor\log_{2}n\rfloor   multiplications, where    ⌊  ⌋      \lfloor\;\rfloor   denotes the floor function . More precisely, the number of multiplications is one less than the number of 1 in the binary expansion of n . For n greater than about 4 this is computationally more efficient than naively multiplying the base with itself repeatedly.  Each squaring results in approximately double the number of digits of the previous, and so, if multiplication of two d digit numbers is implemented in O( d k ) operations for some fixed k then the complexity of computing x n is given by:        ∑   i  =  0    O   (   log   (  n  )    )       (    2  i   O   (   log   (  x  )    )    )   k    =   O   (    (   n   log   (  x  )     )   k   )          superscript   subscript     i  0      O    n      superscript     superscript  2  i   O    x    k      O   superscript    n    x    k      \sum\limits_{i=0}^{O(\log(n))}(2^{i}O(\log(x)))^{k}=O((n\log(x))^{k})     2 k -ary method  This algorithm calculates the value of x n after expanding the exponent in base 2 k . It was first proposed by Brauer in 1939. In the algorithm below we make use of the following function f(0) = (k,0) and f(m) = (s,u) where m = u·2 s with u odd.  Algorithm:   Input: An element x of G, a parameter k > 0, a non-negative integer and the precomputed values     x  3   ,   x  5   ,  …  ,   x    2  k   -  1        superscript  x  3    superscript  x  5   normal-…   superscript  x     superscript  2  k   1      x^{3},x^{5},...,x^{2^{k}-1}   .    Output: The element x n in G   1. y := 1; i := l-1  2. while i>=0 do  3.    (s,u) := f(n i )  4. for j:=1 to k-s do  5.        y := y 2   6.    y := y*x u  7. for j:=1 to s do  8.        y := y 2  9.    i := i-1  10. return y  For optimal efficiency, k should be the smallest integer satisfying 1       log   (  n  )    <      k   (   k  +  1   )    ⋅   2   2  k       2   k  +  1    -  k  -  2    +  1.         n        normal-⋅    k    k  1     superscript  2    2  k        superscript  2    k  1    k  2    1.     \log(n)<\frac{k(k+1)\cdot 2^{2k}}{2^{k+1}-k-2}+1.     Sliding window method  This method is an efficient variant of the 2 k -ary method. For example, to calculate the exponent 398 which has binary expansion (110 001 110) 2 , we take a window of length 3 using the 2 k -ary method algorithm we calculate 1,x 3 ,x 6 ,x 12 ,x 24 ,x 48 ,x 49 ,x 98 ,x 99 ,x 198 ,x 199 ,x 398 . But, we can also compute 1,x 3 ,x 6 ,x 12 ,x 24 ,x 48 ,x 96 ,x 192 ,x 199 , x 398 which saves one multiplication and amounts to evaluating (110 001 110)n 2  Here is the general algorithm:  Algorithm:   Input:An element x of G ,a non negative integer , a parameter k>0 and the pre-computed values     x  3   ,   x  5   ,  …  ,   x    2  k   -  1        superscript  x  3    superscript  x  5   normal-…   superscript  x     superscript  2  k   1      x^{3},x^{5},...,x^{2^{k}-1}   .    Output: The element x n ∈ G   Algorithm:  1.  y := 1; i := l-1  2. while i > -1 do  3. if n i =0 then y:=y 2 ' i:=i-1  4. else  5.          s:=max{i-k+1,0}  6. while n s =0 do s:=s+1 2  7. for h:=1 to i-s+1 do y:=y 2  8.          u:=(n i ,n i-1 ,....,n s ) 2  9.          y:=y*x u  10.         i:=s-1  11. return y  Montgomery's ladder technique  Many algorithms for exponentiation do not provide defence against side-channel attacks . Namely, an attacker observing the sequence of squarings and multiplications can (partially) recover the exponent involved in the computation. This is a problem if the exponent should remain secret, as with many public-key cryptosystems . A technique called Montgomery's Ladder 3 addresses this concern.  Given the binary expansion of a positive, non-zero integer n=(n k-1 ...n 0 ) 2 with n k-1 =1 we can compute x n as follows:  x 1 =x; x 2 =x 2  for i=k-2 to 0 do  If n i =0 then  x 2 =x 1 *x 2 ; x 1 =x 1 2  else  x 1 =x 1 *x 2 ; x 2 =x 2 2  return x 1  The algorithm performs a fixed sequence of operations ( up to log n): a multiplication and squaring takes place for each bit in the exponent, regardless of the bit's specific value.  This specific implementation of Montgomery's ladder is not yet protected against cache timing attacks : memory access latencies might still be observable to an attacker as you access different variables depending on the value of bits of the secret exponent.  Fixed base exponent  There are several methods which can be employed to calculate x n when the base is fixed and the exponent varies. As one can see, precomputations play a key role in these algorithms.  Yao's method  Yao's method is orthogonal to the 2 k -ary method where the exponent is expanded in radix b=2 k and the computation is as performed in the algorithm above. Let "n", "n i ", "b", and "b i " be integers.  Let the exponent "n" be written as      n  =    ∑   i  =  0    w  -  1      n  i    b  i         n    superscript   subscript     i  0      w  1       subscript  n  i    subscript  b  i       n=\sum_{i=0}^{w-1}n_{i}b_{i}   where    0  ⩽   n  i   <  h        0   subscript  n  i        h     0\leqslant n_{i}   for all    i  ∈   [  0  ,   w  -  1   ]       i   0    w  1      i\in[0,w-1]     Let x i = x b i . Then the algorithm uses the equality       x  n   =    ∏   i  =  0    w  -  1     x  i     n  i     =    ∏   j  =  1    h  -  1      [    ∏    n  i   =  j     x  i    ]   j           superscript  x  n     superscript   subscript  product    i  0      w  1     superscript   subscript  x  i    subscript  n  i            superscript   subscript  product    j  1      h  1     superscript   delimited-[]    subscript  product     subscript  n  i   j     subscript  x  i     j       x^{n}=\prod_{i=0}^{w-1}{x_{i}}^{n_{i}}=\prod_{j=1}^{h-1}{\bigg[\prod_{n_{i}=j}%
 x_{i}\bigg]}^{j}     Given the element 'x' of G, and the exponent 'n' written in the above form, along with the precomputed values x b 0 ....x b w-1 the element x n is calculated using the algorithm below.  #y=1,u=1 and j=h-1
 #while j > 0 do
 ##for i=0 to w-1 do
 ###if n i =j then u=u*x b i ##y=y*u
 ##j=j-1
 #return y If we set h=2 k and b i = h i then the n i 's are simply the digits of n in base h. Yao's method collects in u first those x i which appear to the highest power h-1; in the next round those with power h-2 are collected in u as well etc. The variable y is multiplied h-1 times with the initial u, h-2 times with the next highest powers etc. The algorithm uses w+h-2 multiplications and w+1 elements must be stored to compute x n (see 4 ).  Euclidean method  The Euclidean method was first introduced in Efficient exponentiation using precomputation and vector addition chains by P.D Rooij.  This method for computing    x  n     superscript  x  n    x^{n}   in group   𝐆   𝐆   \mathbf{G}   , where   n   n   n   is a natural integer, whose algorithm is given below, is using the following equality recursively:        x  0     n  0    ⋅   x  1     n  1     =     (    x  0   ⋅   x  1    q    )    n  0    ⋅   x  1      n  1   mod   n  0           normal-⋅   superscript   subscript  x  0    subscript  n  0     superscript   subscript  x  1    subscript  n  1      normal-⋅   superscript   normal-⋅   subscript  x  0    superscript   subscript  x  1   q     subscript  n  0     superscript   subscript  x  1    modulo   subscript  n  1    subscript  n  0        {x_{0}}^{n_{0}}\cdot{x_{1}}^{n_{1}}={\left(x_{0}\cdot{x_{1}}^{q}\right)}^{n_{0%
 }}\cdot{x_{1}}^{n_{1}\mod{n_{0}}}   , where    q  =   ⌊    n  1   /   n  0    ⌋       q       subscript  n  1    subscript  n  0       q=\left\lfloor{n_{1}}/{n_{0}}\right\rfloor      (in other words a Euclidean division of the exponent by is used to return a quotient   q   q   q   and a rest     n  1   mod   n  0      modulo   subscript  n  1    subscript  n  0     n_{1}\mod n_{0}   ).   Given the base element   x   x   x   in group   𝐆   𝐆   \mathbf{G}   , and the exponent   n   n   n   written as in Yao's method, the element    x  n     superscript  x  n    x^{n}   is calculated using   l   l   l   precomputed values     x   b  0    ,  …  ,   x   b   l  i         superscript  x   subscript  b  0    normal-…   superscript  x   subscript  b   subscript  l  i       x^{b_{0}},...,x^{b_{l_{i}}}   and then the algorithm below.   Begin  loop   Find     M  ∈   [  0  ,   l  -  1   ]       M   0    l  1      M\in\left[0,l-1\right]    , such that       ∀  i   ∈   [  0  ,   l  -  1   ]    ,    n  M   ≥   n  i       formulae-sequence     for-all  i    0    l  1        subscript  n  M    subscript  n  i      \forall i\in\left[0,l-1\right],{n_{M}}\geq{n_{i}}    ;  Find     N  ∈   (    [  0  ,   l  -  1   ]   -  M   )       N     0    l  1    M     N\in\left(\left[0,l-1\right]-M\right)    , such that       ∀  i   ∈   (    [  0  ,   l  -  1   ]   -  M   )    ,    n  N   ≥   n  i       formulae-sequence     for-all  i      0    l  1    M       subscript  n  N    subscript  n  i      \forall i\in\left(\left[0,l-1\right]-M\right),{n_{N}}\geq{n_{i}}    ;   Break  loop if      n  N   =  0       subscript  n  N   0    {n_{N}}=0    ;   Let      q  =   ⌊    n  M   /   n  N    ⌋       q       subscript  n  M    subscript  n  N       q=\left\lfloor{n_{M}}/{n_{N}}\right\rfloor    , and then let       n  N   =   (    n  M   mod   n  N    )        subscript  n  N    modulo   subscript  n  M    subscript  n  N      {n_{N}}=\left({n_{M}}\mod{n_{N}}\right)    ;  Compute recursively     x  M    q     superscript   subscript  x  M   q    {x_{M}}^{q}    , and then let       x  N   =    x  N   ⋅   x  M    q         subscript  x  N    normal-⋅   subscript  x  N    superscript   subscript  x  M   q      {x_{N}}={x_{N}}\cdot{x_{M}}^{q}    ;   End  loop ;   Return       x  n   =   x  M     n  M         superscript  x  n    superscript   subscript  x  M    subscript  n  M      x^{n}={x_{M}}^{n_{M}}    .  The algorithm first finds the largest value amongst the and then the supremum within the set of  n i \ i ≠ M {{)}}}} . Then it raises to the power   q   q   q   , multiplies this value with , and then assigns the result of this computation and the value modulo .  Further applications  The same idea allows fast computation of large exponents modulo a number. Especially in cryptography , it is useful to compute powers in a ring of integers modulo q . It can also be used to compute integer powers in a group , using the rule   Power( x , − n ) = (Power( x , n )) −1 .   The method works in every semigroup and is often used to compute powers of matrices .  For example, the evaluation of   13789 722341 (mod 2345)   would take a very long time and lots of storage space if the naïve method were used: compute 13789 722341 then take the remainder when divided by 2345. Even using a more effective method will take a long time: square 13789, take the remainder when divided by 2345, multiply the result by 13789, and so on. This will take less than     2    log  2    (  722340  )     ≤  40        2    subscript   2   722340    40    2\log_{2}(722340)\leq 40   modular multiplications.  Applying above exp-by-squaring algorithm, with "*" interpreted as x * y = xy mod 2345 (that is a multiplication followed by a division with remainder) leads to only 27 multiplications and divisions of integers which may all be stored in a single machine word.  Example implementations  Computation by powers of 2  This is a non-recursive implementation of the above algorithm in Ruby .  In most statically typed languages, result=1 must be replaced with code assigning an identity matrix of the same size as x to result to get a matrix exponentiating algorithm. In Ruby, thanks to coercion, result is automatically upgraded to the appropriate type, so this function works with matrices as well as with integers and floats. Note that n=n-1 is redundant when n=n/2 implicitly rounds towards zero, as lower level languages would do. n[0] is the rightmost bit of the binary representation of n, so if it is 1, the number is odd, if it is zero, the number is even.  def power(x,n)
   result = 1  while n.nonzero? if n[ 0 ].nonzero?
       result *= x
       n -= 1  end x *= x
     n /= 2  end  return result end  Runtime example: compute 3 10  parameter x =  3  parameter n = 10  result := 1   Iteration  1  n = 10 -> n is even  x := x 2 = 3 2 = 9  n := n / 2 = 5   Iteration  2  n = 5 -> n is odd  -> result := result * x = 1 * x = 1 * 3 2 = 9  n := n - 1 = 4  x := x 2 = 9 2 = 3 4 = 81  n := n / 2 = 2   Iteration  3  n = 2 -> n is even  x := x 2 = 81 2 = 3 8 = 6561  n := n / 2 = 1   Iteration  4  n = 1 -> n is odd  -> result := result * x = 3 2 * 3 8 = 3 10 = 9 * 6561 = 59049  n := n - 1 = 0   return result  Runtime example: compute 3 10  result := 3  bin := "1010"   Iteration  for  digit  2:  result := result 2 = 3 2 = 9  1 0 10 bin - Digit equals "0"   Iteration  for  digit  3:  result := result 2 = (3 2 ) 2 = 3 4 = 81  10 1 0 bin - Digit equals "1" --> result := result*3 = (3 2 ) 2 *3 = 3 5 = 243   Iteration  for  digit  4:  result := result 2 = ((3 2 ) 2 *3) 2 = 3 10 = 59049  101 0 bin - Digit equals "0"   return result  JavaScript-Demonstration: http://home.mnet-online.de/wzwz.de/temp/ebs/en.htm  Calculation of products of powers  Exponentiation by squaring may also be used to calculate the product of 2 or more powers. If the underlying group or semigroup is commutative then it is often possible to reduce the number of multiplications by computing the product simultaneously.  Example  The formula a 7 ×b 5 may be calculated within 3 steps:   ((a) 2 × a) 2 × a (four multiplications for calculating a 7 )  ((b) 2 ) 2 × b (three multiplications for calculating b 5 )  (a 7 ) × (b 5 ) (one multiplication to calculate the product of the two)   so one gets eight multiplications in total.  A faster solution is to calculate both powers simultaneously:   ((a × b) 2 × a) 2 × a × b   which needs only 6 multiplications in total. Note that a×b is calculated twice, the result could be stored after the first calculation which reduces the count of multiplication to 5.  Example with numbers:   2 7 ×3 5 = ((2×3) 2 ×2) 2 ×2×3 = (6 2 ×2) 2 ×6 = 72 2 ×6 = 31,104   Calculating the powers simultaneously instead of calculating them separately always reduces the count of multiplications if at least two of the exponents are greater than 1.  Using transformation  The example above a 7 ×b 5 may also be calculated with only 5 multiplications if the expression is transformed before calculation:  a 7 ×b 5 = a 2 ×(ab) 5 with ab := a×b    ab := a × b (one multiplication)    a 2 ×(ab) 5 = ((ab) 2 × a) 2 × ab (four multiplications)    Generalization of transformation shows the following scheme: For calculating a A ×b B ×...×m M ×n N 1st: define ab := a×b, abc = ab×c, ... 2nd: calculate the transformed expression a A−B ×ab B−C ×...×abc..m M−N ×abc..mn N  Transformation before calculation often reduces the count of multiplications but in some cases it also increases the count (see the last one of the examples below), so it may be a good idea to check the count of multiplications before using the transformed expression for calculation.  Examples  For the following expressions the count of multiplications is shown for calculating each power separately, calculating them simultaneously without transformation and calculating them simultaneously after transformation.  Example: a 7 ×b 5 ×c 3 separate: [((a) 2 × a) 2 × a] × [((b) 2 ) 2 × b] × [(c) 2 × c] ( 11 multiplications ) simultaneous: ((a × b) 2 × a × c) 2 × a × b × c ( 8 multiplications ) transformation: a := 2   ab := a × b   abc := ab × c ( 2 multiplications ) calculation after that: (a × ab × abc) 2 × abc ( 4 multiplications ⇒ 6 in total )  Example: a 5 ×b 5 ×c 3 separate: [((a) 2 ) 2 × a] × [((b) 2 ) 2 × b] × [(c) 2 × c] ( 10 multiplications ) simultaneous: ((a × b) 2 × c) 2 × a × b × c ( 7 multiplications ) transformation: a := 2   ab := a × b   abc := ab × c ( 2 multiplications ) calculation after that: (ab × abc) 2 × abc ( 3 multiplications ⇒ 5 in total )  Example: a 7 ×b 4 ×c 1 separate: [((a) 2 × a) 2 × a] × [((b) 2 ) 2 ] × [c] ( 8 multiplications ) simultaneous: ((a × b) 2 × a) 2 × a × c ( 6 multiplications ) transformation: a := 2   ab := a × b   abc := ab × c ( 2 multiplications ) calculation after that: (a × ab) 2 × a × ab × abc ( 5 multiplications ⇒ 7 in total )  Signed-digit recoding  In certain computations it may be more efficient to allow negative coefficients and hence use the inverse of the base, provided inversion in G is 'fast' or has been precomputed. For example, when computing x 2 k −1 the binary method requires k−1 multiplications and k−1 squarings. However one could perform k squarings to get x 2 k and then multiply by x −1 to obtain x 2 k −1 .  To this end we define the signed-digit representation of an integer   n   n   n   in radix   b   b   b   as       n  i   ∈   {   -  1   ,  0  ,  1  }        subscript  n  i      1   0  1     n_{i}\in\{-1,0,1\}   and     (    n   l  -  1    …   n  0    )   s     subscript     subscript  n    l  1    normal-…   subscript  n  0    s    (n_{l-1}\dots n_{0})_{s}   . It is denoted by    n  =  478      n  478    n=478   . There are several methods for computing this representation. The representation is not unique, for example take     (   10   1  ¯   1100   1  ¯   10   )   s     subscript    10   normal-¯  1   1100   normal-¯  1   10   s    (10\bar{1}1100\bar{1}10)_{s}   . Two distinct signed-binary representations are given by     (   100   1  ¯   1000   1  ¯   0   )   s     subscript    100   normal-¯  1   1000   normal-¯  1   0   s    (100\bar{1}1000\bar{1}0)_{s}   and    1  ¯     normal-¯  1    \bar{1}   , where    -  1      1    -1   is used to denote   n   n   n   . Since the binary method computes a multiplication for every non-zero entry in the base 2 representation of      n  i    n   i  +  1     =   0  for all  i   ⩾  0           subscript  n  i    subscript  n    i  1       0  for all  i        0     n_{i}n_{i+1}=0\text{ for all }i\geqslant 0   , we are interested in finding the signed-binary representation with the smallest number of non-zero entries, that is, the one with minimal  Hamming weight . One method of doing this is to compute the representation in non-adjacent form , or NAF for short, which is one that satisfies     (    n   l  -  1    …   n  0    )   NAF     subscript     subscript  n    l  1    normal-…   subscript  n  0    NAF    (n_{l-1}\dots n_{0})_{\text{NAF}}   and denoted by     (   1000   1  ¯   000   1  ¯   0   )   NAF     subscript    1000   normal-¯  1   000   normal-¯  1   0   NAF    (1000\bar{1}000\bar{1}0)_{\text{NAF}}   . For example the NAF representation of 478 is equal to    n  =    (    n  l    n   l  -  1    …   n  0    )   2       n   subscript     subscript  n  l    subscript  n    l  1    normal-…   subscript  n  0    2     n=(n_{l}n_{l-1}\dots n_{0})_{2}   . This representation always has minimal Hamming weight. A simple algorithm to compute the NAF representation of a given integer     n  l   =   n   l  -  1    =  0         subscript  n  l    subscript  n    l  1         0     n_{l}=n_{l-1}=0   with     c  0   =  0       subscript  c  0   0    c_{0}=0   is the following:       i  =  0      i  0    i=0     for    l  -  1      l  1    l-1   to     c   i  +  1    =   ⌊    1  2    (    c  i   +   n  i   +   n   i  +  1     )    ⌋        subscript  c    i  1          1  2      subscript  c  i    subscript  n  i    subscript  n    i  1         c_{i+1}=\left\lfloor\frac{1}{2}(c_{i}+n_{i}+n_{i+1})\right\rfloor   do       n  i  ′   =     c  i   +   n  i    -   2   c   i  +  1           superscript   subscript  n  i   normal-′        subscript  c  i    subscript  n  i      2   subscript  c    i  1        n_{i}^{\prime}=c_{i}+n_{i}-2c_{i+1}          (    n   l  -  1   ′   …   n  0  ′    )   NAF     subscript     superscript   subscript  n    l  1    normal-′   normal-…   superscript   subscript  n  0   normal-′    NAF    (n_{l-1}^{\prime}\dots n_{0}^{\prime})_{\text{NAF}}     return     n  i   =   n   i  +  1    =  0         subscript  n  i    subscript  n    i  1         0     n_{i}=n_{i+1}=0      Another algorithm by Koyama and Tsuruoka does not require the condition that     a  15   =   x  ×     (   x  ×    [   x  ×   x  2    ]   2    )   2          superscript  a  15     x   superscript    x   superscript   delimited-[]    x   superscript  x  2     2    2      a^{15}=x\times(x\times[x\times x^{2}]^{2})^{2}\!   ; it still minimizes the Hamming weight.  Alternatives and generalizations  Exponentiation by squaring can be viewed as a suboptimal addition-chain exponentiation algorithm: it computes the exponent via an addition chain consisting of repeated exponent doublings (squarings) and/or incrementing exponents by one (multiplying by x ) only. More generally, if one allows any previously computed exponents to be summed (by multiplying those powers of x ), one can sometimes perform the exponentiation using fewer multiplications (but typically using more memory). The smallest power where this occurs is for n =15:       a  15   =    x  3   ×     (    [   x  3   ]   2   )   2          superscript  a  15      superscript  x  3    superscript   superscript   delimited-[]   superscript  x  3    2   2      a^{15}=x^{3}\times([x^{3}]^{2})^{2}\!   (squaring, 6 multiplies)      x    2  k   -  1      superscript  x     superscript  2  k   1     x^{2^{k}-1}   (optimal addition chain, 5 multiplies if x 3 is re-used)  In general, finding the optimal addition chain for a given exponent is a hard problem, for which no efficient algorithms are known, so optimal chains are typically only used for small exponents (e.g. in compilers where the chains for small powers have been pre-tabulated). However, there are a number of heuristic algorithms that, while not being optimal, have fewer multiplications than exponentiation by squaring at the cost of additional bookkeeping work and memory usage. Regardless, the number of multiplications never grows more slowly than Θ (log n ), so these algorithms only improve asymptotically upon exponentiation by squaring by a constant factor at best.  See also   Modular exponentiation  Vectorial addition chain  Montgomery reduction  Non-adjacent form  Addition chain   Notes  "  Category:Exponentials  Category:Computer arithmetic algorithms  Category:Computer arithmetic     Cohen, H., Frey, G. (editors): Handbook of elliptic and hyperelliptic curve cryptography. Discrete Math.Appl., Chapman & Hall/CRC (2006) ↩  In  this  line,  the  loop  finds  the  longest  string  of  length  less  than  or  equal  to  'k'  which  ends  in  a  non  zero  value.  And  not  all  odd  powers  of  2  up  to  $x^{2^k-1}$  need  be  computed  and  only  those  specifically  involved  in  the  computation  need  be  considered. ↩  Montgomery, P. L. "Speeding the Pollard and Elliptic Curve Methods of Factorization." Math. Comput. 48, 243-264, 1987. ↩     