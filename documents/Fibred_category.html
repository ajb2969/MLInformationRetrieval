<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="132">Fibred category</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Fibred category</h1>
<hr/>

<p><strong>Fibred categories</strong> are abstract entities in <a class="uri" href="mathematics" title="wikilink">mathematics</a> used to provide a general framework for <a href="descent_theory" title="wikilink">descent theory</a>. They formalise the various situations in <a class="uri" href="geometry" title="wikilink">geometry</a> and <a class="uri" href="algebra" title="wikilink">algebra</a> in which <em>inverse images</em> (or <em>pull-backs</em>) of objects such as <a href="vector_bundle" title="wikilink">vector bundles</a> can be defined. As an example, for each topological space there is the category of vector bundles on the space, and for every <a href="continuous_map" title="wikilink">continuous map</a> from a topological space <em>X</em> to another topological space <em>Y</em> is associated the <a href="pullback_bundle" title="wikilink">pullback</a> <a class="uri" href="functor" title="wikilink">functor</a> taking bundles on <em>Y</em> to bundles on <em>X</em>. Fibred categories formalise the system consisting of these categories and inverse image functors. Similar setups appear in various guises in mathematics, in particular in <a href="algebraic_geometry" title="wikilink">algebraic geometry</a>, which is the context in which fibred categories originally appeared. Fibrations also play an important role in categorical semantics of <a href="type_theory" title="wikilink">type theory</a>, and in particular that of <a href="dependent_type" title="wikilink">dependent type</a> theories.</p>

<p>Fibred categories were introduced by <a href="Alexander_Grothendieck" title="wikilink">Alexander Grothendieck</a> in Grothendieck (1959), and developed in more detail by himself and <a href="Jean_Giraud_(mathematician)" title="wikilink">Jean Giraud</a> in Grothendieck (1971) in 1960/61, Giraud (1964) and Giraud (1971).</p>
<h2 id="background-and-motivations">Background and motivations</h2>

<p>There are many examples in <a class="uri" href="topology" title="wikilink">topology</a> and <a class="uri" href="geometry" title="wikilink">geometry</a> where some types of objects are considered to exist <em>on</em> or <em>above</em> or <em>over</em> some underlying <em>base space</em>. The classical examples include vector bundles, <a href="principal_bundle" title="wikilink">principal bundles</a> and <a href="sheaf_(mathematics)" title="wikilink">sheaves</a> over topological spaces. Another example is given by "families" of <a href="algebraic_varieties" title="wikilink">algebraic varieties</a> parametrised by another variety. Typical to these situations is that to a suitable type of a <a href="map_(mathematics)" title="wikilink">map</a> <em>f</em>: <em>X</em> → <em>Y</em> between base spaces, there is a corresponding <em>inverse image</em> (also called <em>pull-back</em>) operation <em>f<sup>*</sup></em> taking the considered objects defined on <em>Y</em> to the same type of objects on <em>X</em>. This is indeed the case in the examples above: for example, the inverse image of a vector bundle <em>E</em> on <em>Y</em> is a vector bundle <em>f</em><sup>*</sup>(<em>E</em>) on <em>X</em>.</p>

<p>Moreover, it is often the case that the considered "objects on a base space" form a category, or in other words have maps (<a class="uri" href="morphisms" title="wikilink">morphisms</a>) between them. In such cases the inverse image operation is often compatible with composition of these maps between objects, or in more technical terms is a <a class="uri" href="functor" title="wikilink">functor</a>. Again, this is the case in examples listed above.</p>

<p>However, it is often the case that if <em>g</em>: <em>Y</em> → <em>Z</em> is another map, the inverse image functors are not <em>strictly</em> compatible with composed maps: if <em>z</em> is an object <em>over</em> <em>Z</em> (a vector bundle, say), it may well be that</p>

<p>

<math display="block" id="Fibred_category:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>g</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>g</mi>
        <mo>∘</mo>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <times></times>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <times></times>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <compose></compose>
       <ci>g</ci>
       <ci>f</ci>
      </apply>
      <times></times>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}(g^{*}(z))\neq(g\circ f)^{*}(z).
  </annotation>
 </semantics>
</math>

</p>

<p>Instead, these inverse images are only <a href="natural_transformation" title="wikilink">naturally</a> <a href="isomorphism" title="wikilink">isomorphic</a>. This introduction of some "slack" in the system of inverse images causes some delicate issues to appear, and it is this set-up that fibred categories formalise.</p>

<p>The main application of fibred categories is in <a href="descent_theory" title="wikilink">descent theory</a>, concerned with a vast generalisation of "glueing" techniques used in topology. In order to support descent theory of sufficient generality to be applied in non-trivial situations in algebraic geometry the definition of fibred categories is quite general and abstract. However, the underlying intuition is quite straightforward when keeping in mind the basic examples discussed above.</p>
<h2 id="formal-definitions">Formal definitions</h2>

<p>There are two essentially equivalent technical definitions of fibred categories, both of which will be described below. All discussion in this section ignores the <a href="set_theory" title="wikilink">set-theoretical</a> issues related to "large" categories. The discussion can be made completely rigorous by, for example, restricting attention to small categories or by using <a href="Grothendieck_universe" title="wikilink">universes</a>.</p>
<h3 id="cartesian-morphisms-and-functors">Cartesian morphisms and functors</h3>

<p>If φ: <em>F</em> → <em>E</em> is a <a class="uri" href="functor" title="wikilink">functor</a> between two <a href="category_(mathematics)" title="wikilink">categories</a> and <em>S</em> is an object of <em>E</em>, then the <a class="uri" href="subcategory" title="wikilink">subcategory</a> of <em>F</em> consisting of those objects <em>x</em> for which φ(<em>x</em>)=<em>S</em> and those morphisms <em>m</em> satisfying φ(<em>m</em>)=id<sub><em>S</em></sub>, is called the <em>fibre category</em> (or <em>fibre</em>) <em>over S</em>, and is denoted <em>F<sub>S</sub></em>. The morphisms of <em>F<sub>S</sub></em> are called <em>S-morphisms</em>, and for <em>x</em>,<em>y</em> objects of <em>F<sub>S</sub></em>, the set of <em>S</em>-morphisms is denoted by Hom<sub><em>S</em></sub>(<em>x</em>,<em>y</em>). The image by φ of an object or a morphism in <em>F</em> is called its <em>projection</em> (by φ). If f is a morphism of <em>E</em>, then those morphisms of <em>F</em> that project to <em>f</em> are called <em>f-morphisms</em>, and the set of <em>f</em>-morphisms between objects <em>x</em> and <em>y</em> in <em>F</em> is denoted by Hom<sub><em>f</em></sub>(<em>x</em>,<em>y</em>). A functor φ: <em>F</em> → <em>E</em> is also called an <em>E-category</em>, or said to make <em>F</em> into an <em>E</em>-category or a category <em>over</em> <em>E</em>. An <em>E</em>-functor from an <em>E</em>-category φ: <em>F</em> → <em>E</em> to an <em>E</em>-category ψ: <em>G</em> → <em>E</em> is a functor α: <em>F</em> → <em>G</em> such that ψ ∘ α = φ. <em>E</em>-categories form in a natural manner a <a class="uri" href="2-category" title="wikilink">2-category</a>, with 1-morphisms being <em>E</em>-functors, and 2-morphisms being natural transformations between <em>E</em>-functors whose components lie in some fibre.</p>

<p>A morphism <em>m</em>: <em>x</em> → <em>y</em> in <em>F</em> is called <em>φ-cartesian</em> (or simply <em>cartesian</em>) if it satisfies the following condition:</p>
<dl>
<dd>if <em>f</em>: <em>T</em> → <em>S</em> is the projection of <em>m</em>, and if n: <em>z</em> → <em>y</em> is an <em>f</em>-morphism, then there is <em>precisely one</em> <em>T</em>-morphism <em>a</em>: <em>z</em> → <em>x</em> such that <em>n</em> = <em>m ∘ a</em>.
</dd>
</dl>

<p>A cartesian morphism <em>m</em>: <em>x</em> → <em>y</em> is called an <em>inverse image</em> of its projection <em>f</em> = φ(<em>m</em>); the object <em>x</em> is called an <em>inverse image</em> of <em>y</em> <em>by f</em>.</p>

<p>The cartesian morphisms of a fibre category <em>F<sub>S</sub></em> are precisely the isomorphisms of <em>F<sub>S</sub></em>. There can in general be more than one cartesian morphism projecting to a given morphism <em>f</em>: <em>T</em> → <em>S</em>, possibly having different sources; thus there can be more than one inverse image of a given object <em>y</em> in <em>F<sub>S</sub></em> by <em>f</em>. However, it is a direct consequence of the definition that two such inverse images are isomorphic in <em>F<sub>T</sub></em>.</p>

<p>An <em>E</em>-functor between two <em>E</em>-categories is called a <em>cartesian functor</em> if it takes cartesian morphisms to cartesian morphisms. Cartesian functors between two <em>E</em>-categories <em>F</em>,<em>G</em> form a category Cart<sub><em>E</em></sub>(<em>F</em>,<em>G</em>), with <a href="natural_transformations" title="wikilink">natural transformations</a> as morphisms. A special case is provided by considering <em>E</em> as an <em>E</em>-category via the identity functor: then a cartesian functor from <em>E</em> to an <em>E</em>-category <em>F</em> is called a <em>cartesian section</em>. Thus a cartesian section consists of a choice of one object <em>x<sub>S</sub></em> in <em>F<sub>S</sub></em> for each object <em>S</em> in <em>E</em>, and for each morphism <em>f</em>: <em>T</em> → <em>S</em> a choice of an inverse image <em>m<sub>f</sub></em>: <em>x<sub>T</sub></em> → <em>x<sub>S</sub></em>. A cartesian section is thus a (strictly) compatible system of inverse images over objects of <em>E</em>. The category of cartesian sections of <em>F</em> is denoted by</p>

<p>

<math display="block" id="Fibred_category:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder accentunder="true">
      <mi>Lim</mi>
      <mo>⟵</mo>
     </munder>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mo>/</mo>
       <mi>E</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>Cart</mi>
      <mi>E</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo>,</mo>
      <mi>F</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⟵</ci>
      <ci>Lim</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>F</ci>
      <ci>E</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Cart</ci>
      <ci>E</ci>
     </apply>
     <interval closure="open">
      <ci>E</ci>
      <ci>F</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{\longleftarrow}{\mathrm{Lim}}(F/E)=\mathrm{Cart}_{E}(E,F).
  </annotation>
 </semantics>
</math>

</p>

<p>In the important case where <em>E</em> has a <a href="Initial_object" title="wikilink">terminal object</a> <em>e</em> (thus in particular when <em>E</em> is a <a class="uri" href="topos" title="wikilink">topos</a> or the category <em>E<sub>/S</sub></em> of <a href="slice_category" title="wikilink">arrows</a> with target <em>S</em> in <em>E</em>) the functor</p>

<p>

<math display="block" id="Fibred_category:2">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <munder accentunder="true">
       <mi>Lim</mi>
       <mo>⟵</mo>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>F</mi>
        <mo>/</mo>
        <mi>E</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>→</mo>
     <msub>
      <mi>F</mi>
      <mi>e</mi>
     </msub>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mi>s</mi>
     <mo>↦</mo>
     <mrow>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>e</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ϵ</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⟵</ci>
        <ci>Lim</ci>
       </apply>
       <apply>
        <divide></divide>
        <ci>F</ci>
        <ci>E</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>e</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <ci>s</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\colon\underset{\longleftarrow}{\mathrm{Lim}}(F/E)\to F_{e},\qquad s%
\mapsto s(e)
  </annotation>
 </semantics>
</math>

</p>

<p>is <a href="full_and_faithful_functors" title="wikilink">fully faithful</a> (Lemma 5.7 of Giraud (1964)).</p>
<h3 id="fibred-categories-and-cleaved-categories">Fibred categories and cleaved categories</h3>

<p>The technically most flexible and economical definition of fibred categories is based on the concept of cartesian morphisms. It is equivalent to a definition in terms of <em><a href="cleavage_(mathematics)" title="wikilink">cleavages</a></em>, the latter definition being actually the original one presented in Grothendieck (1959); the definition in terms of cartesian morphisms was introduced in Grothendieck (1971) in 1960–1961.</p>

<p>An <em>E</em> category φ: <em>F</em> → <em>E</em> is a <em>fibred category</em> (or a <em>fibred E-category</em>, or a <em>category fibred over E</em>) if each morphism <em>f</em> of <em>E</em> whose codomain is in the range of projection has at least one inverse image, and moreover the composition <em>m ∘ n</em> of any two cartesian morphisms <em>m</em>,<em>n</em> in <em>F</em> is always cartesian. In other words, an <em>E</em>-category is a fibred category if inverse images always exist (for morphisms whose codomains are in the range of projection) and are <em>transitive</em>.</p>

<p>If <em>E</em> has a terminal object <em>e</em> and if <em>F</em> is fibred over <em>E</em>, then the functor ε from cartesian sections to <em>F<sub>e</sub></em> defined at the end of the previous section is an <a href="equivalence_of_categories" title="wikilink">equivalence of categories</a> and moreover <a href="surjection" title="wikilink">surjective</a> on objects.</p>

<p>If <em>F</em> is a fibred <em>E</em>-category, it is always possible, for each morphism <em>f</em>: <em>T</em> → <em>S</em> in <em>E</em> and each object <em>y</em> in <em>F<sub>S</sub></em>, to choose (by using the <a href="axiom_of_choice" title="wikilink">axiom of choice</a>) precisely one inverse image <em>m</em>: <em>x</em> → <em>y</em>. The class of morphisms thus selected is called a <em>cleavage</em> and the selected morphisms are called the <em>transport morphisms</em> (of the cleavage). A fibred category together with a cleavage is called a <em>cleaved category</em>. A cleavage is called <em>normalised</em> if the transport morphisms include all identities in <em>F</em>; this means that the inverse images of identity morphisms are chosen to be identity morphisms. Evidently if a cleavage exists, it can be chosen to be normalised; we shall consider only normalised cleavages below.</p>

<p>The choice of a (normalised) cleavage for a fibred <em>E</em>-category <em>F</em> specifies, for each morphism <em>f</em>: <em>T</em> → <em>S</em> in <em>E</em>, a <em>functor</em> <em>f</em><sup>*</sup>: <em>F<sub>S</sub></em> → <em>F<sub>T</sub></em>: on objects <em>f</em><sup>*</sup> is simply the inverse image by the corresponding transport morphism, and on morphisms it is defined in a natural manner by the defining universal property of cartesian morphisms. The operation which associates to an object <em>S</em> of <em>E</em> the fibre category <em>F<sub>S</sub></em> and to a morphism <em>f</em> the <em>inverse image functor</em> <em>f</em><sup>*</sup> is <em>almost</em> a contravariant functor from <em>E</em> to the category of categories. However, in general it fails to commute strictly with composition of morphisms. Instead, if <em>f</em>: <em>T</em> → <em>S</em> and <em>g</em>: <em>U</em> → <em>T</em> are morphisms in <em>E</em>, then there is an isomorphism of functors</p>

<p>

<math display="block" id="Fibred_category:3">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>f</mi>
     <mo>,</mo>
     <mi>g</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <msup>
    <mi>g</mi>
    <mo>*</mo>
   </msup>
   <msup>
    <mi>f</mi>
    <mo>*</mo>
   </msup>
   <mo>→</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>∘</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <list>
      <ci>f</ci>
      <ci>g</ci>
     </list>
    </apply>
    <ci>normal-:</ci>
    <ci></ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <compose></compose>
      <csymbol cd="unknown">g</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f,g}\colon\quad g^{*}f^{*}\to(f\circ g)^{*}.
  </annotation>
 </semantics>
</math>

 These isomorphisms satisfy the following two compatibilities:</p>
<ol>
<li>

<math display="inline" id="Fibred_category:4">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>f</mi>
     <mo>,</mo>
     <msub>
      <mi>id</mi>
      <mi>T</mi>
     </msub>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mrow>
     <msub>
      <mi>id</mi>
      <mi>S</mi>
     </msub>
     <mo>,</mo>
     <mi>f</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>id</mi>
    <msup>
     <mi>f</mi>
     <mo>*</mo>
    </msup>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <list>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>T</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>S</ci>
       </apply>
       <ci>f</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>id</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f,\mathrm{id}_{T}}=c_{\mathrm{id}_{S},f}=\mathrm{id}_{f^{*}}
  </annotation>
 </semantics>
</math>

</li>
<li>for three consecutive morphisms 

<math display="inline" id="Fibred_category:5">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>,</mo>
   <mi>g</mi>
   <mo>,</mo>
   <mi>f</mi>
   <mo>:</mo>
   <mi>V</mi>
   <mo>→</mo>
   <mi>U</mi>
   <mo>→</mo>
   <mi>T</mi>
   <mo>→</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">h</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">g</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-:</ci>
    <ci></ci>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">U</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">T</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h,g,f\colon\quad V\to U\to T\to S
  </annotation>
 </semantics>
</math>

 and object 

<math display="inline" id="Fibred_category:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msub>
    <mi>F</mi>
    <mi>S</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in F_{S}
  </annotation>
 </semantics>
</math>

 the following holds

<math display="block" id="Fibred_category:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>c</mi>
       <mrow>
        <mi>f</mi>
        <mo>,</mo>
        <mrow>
         <mi>g</mi>
         <mo>∘</mo>
         <mi>h</mi>
        </mrow>
       </mrow>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>c</mi>
       <mrow>
        <mi>g</mi>
        <mo>,</mo>
        <mi>h</mi>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>c</mi>
        <mrow>
         <mrow>
          <mi>f</mi>
          <mo>∘</mo>
          <mi>g</mi>
         </mrow>
         <mo>,</mo>
         <mi>h</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mi>h</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mrow>
         <mi>f</mi>
         <mo>,</mo>
         <mi>g</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <list>
        <ci>f</ci>
        <apply>
         <compose></compose>
         <ci>g</ci>
         <ci>h</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <list>
        <ci>g</ci>
        <ci>h</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <times></times>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <list>
         <apply>
          <compose></compose>
          <ci>f</ci>
          <ci>g</ci>
         </apply>
         <ci>h</ci>
        </list>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <list>
        <ci>f</ci>
        <ci>g</ci>
       </list>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f,g\circ h}\cdot c_{g,h}(f^{*}(x))=c_{f\circ g,h}(x)\cdot h^{*}(c_{f,g}(x)).
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>It can be shown (see Grothendieck (1971) section 8) that, inversely, any collection of functors <em>f</em><sup>*</sup>: <em>F</em><sub>S</sub> → <em>F</em><sub>T</sub> together with isomorphisms <em>c</em><sub>f,g</sub> satisfying the compatibilities above, defines a cleaved category. These collections of inverse image functors provide a more intuitive view on fibred categories; and indeed, it was in terms of such compatible inverse image functors that fibred categories were introduced in Grothendieck (1959).</p>

<p>The paper by Gray referred to below makes analogies between these ideas and the notion of <a class="uri" href="fibration" title="wikilink">fibration</a> of spaces.</p>

<p>These ideas simplify in the case of <a class="uri" href="groupoids" title="wikilink">groupoids</a>, as shown in the paper of Brown referred to below, which obtains a useful family of exact sequences from a fibration of groupoids.</p>
<h3 id="splittings-and-split-fibred-categories">Splittings and split fibred categories</h3>

<p>A (normalised) cleavage such that the composition of two transport morphisms is always a transport morphisms is called a <em>splitting</em>, and a fibred category with a splitting is called a <em>split</em> (fibred) <em>category</em>. In terms of inverse image functors the condition of being a splitting means that the composition of inverse image functors corresponding to composable morphisms <em>f,g</em> in <em>E</em> <em>equals</em> the inverse image functor corresponding to <em>f ∘ g</em>. In other words, the compatibility isomorphisms <em>c<sub>f,g</sub></em> of the previous section are all identities for a split category. Thus split <em>E</em>-categories correspond exactly to true functors from <em>E</em> to the category of categories.</p>

<p>Unlike cleavages, not all fibred categories admit splittings. For an example, see <a href="#Examples" title="wikilink">below</a>.</p>
<h3 id="co-cartesian-morphisms-and-co-fibred-categories">Co-cartesian morphisms and co-fibred categories</h3>

<p>One can invert the direction of arrows in the definitions above to arrive at corresponding concepts of co-cartesian morphisms, co-fibred categories and split co-fibred categories (or co-split categories). More precisely, if φ: <em>F</em> →<em>E</em> is a functor, then a morphism <em>m</em>: <em>x</em> → <em>y</em> in <em>F</em> is called <em>co-cartesian</em> if it is cartesian for the <a href="opposite_functor" title="wikilink">opposite functor</a> φ<sup>op</sup>: <em>F</em><sup>op</sup> → <em>E</em><sup>op</sup>. Then <em>m</em> is also called a <em>direct image</em> and <em>y</em> a direct image of <em>x</em> for <em>f</em> = φ(<em>m</em>). A <em>co-fibred</em> <em>E</em>-category is an<em>E</em>-category such that direct image exists for each morphism in <em>E</em> and that the composition of direct images is a direct image. A <em>co-cleavage</em> and a <em>co-splitting</em> are defined similarly, corresponding to <em>direct image functors</em> instead of inverse image functors.</p>
<h2 id="properties">Properties</h2>
<h3 id="the-2-categories-of-fibred-categories-and-split-categories">The 2-categories of fibred categories and split categories</h3>

<p>The categories fibred over a fixed category <em>E</em> form a 2-category <strong>Fib</strong>(<em>E</em>), where the <em>category</em> of morphisms between two fibred categories <em>F</em> and <em>G</em> is defined to be the category Cart<sub><em>E</em></sub>(<em>F</em>,<em>G</em>) of cartesian functors from <em>F</em> to <em>G</em>.</p>

<p>Similarly the split categories over <em>E</em> form a 2-category <strong>Scin</strong>(<em>E</em>) (from French <em>catégorie scindée</em>), where the category of morphisms between two split categories <em>F</em> and <em>G</em> is the full sub-category Scin<sub><em>E</em></sub>(<em>F</em>,<em>G</em>) of <em>E</em>-functors from <em>F</em> to <em>G</em> consisting of those functors that transform each transport morphism of <em>F</em> into a transport morphism of <em>G</em>. Each such <em>morphism of split E-categories</em> is also a morphism of <em>E</em>-fibred categories, i.e., Scin<sub><em>E</em></sub>(<em>F</em>,<em>G</em>) ⊂ Cart<sub><em>E</em></sub>(<em>F</em>,<em>G</em>).</p>

<p>There is a natural forgetful 2-functor <em>i</em>: <strong>Scin</strong>(<em>E</em>) → <strong>Fib</strong>(<em>E</em>) that simply forgets the splitting.</p>
<h3 id="existence-of-equivalent-split-categories">Existence of equivalent split categories</h3>

<p>While not all fibred categories admit a splitting, each fibred category is in fact <em>equivalent</em> to a split category. Indeed, there are two canonical ways to construct an equivalent split category for a given fibred category <em>F</em> over <em>E</em>. More precisely, the forgetful 2-functor <em>i</em>: <strong>Scin</strong>(<em>E</em>) → <strong>Fib</strong>(<em>E</em>) admits a right 2-adjoint <em>S</em> and a left 2-adjoint <em>L</em> (Theorems 2.4.2 and 2.4.4 of Giraud 1971), and <em>S</em>(<em>F</em>) and <em>L</em>(<em>F</em>) are the two associated split categories. The adjunction functors <em>S</em>(<em>F</em>) → <em>F</em> and <em>F</em> → <em>L</em>(<em>F</em>) are both cartesian and equivalences (<em>ibid</em>.). However, while their composition <em>S</em>(<em>F</em>) → <em>L</em>(<em>F</em>) is an equivalence (of categories, and indeed of fibred categories), it is <em>not</em> in general a morphism of split categories. Thus the two constructions differ in general. The two preceding constructions of split categories are used in a critical way in the construction of the <a href="stack_(mathematics)" title="wikilink">stack</a> associated to a fibred category (and in particular stack associated to a <a class="uri" href="pre-stack" title="wikilink">pre-stack</a>).</p>
<h2 id="examples">Examples</h2>
<ol>
<li>The functor ''Ob '': <strong>Cat</strong>→<strong>Set</strong>, sending a category to its set of objects, is a fibration. For a set <em>S</em>, the fiber consists of categories <em>C</em> with <em>Ob(C)=S</em>. The cartesian arrows are the fully faithful functors.</li>
<li><strong>Categories of arrows</strong>: For any category <em>E</em> the <em>category of arrows</em> A(<em>E</em>) in <em>E</em> has as objects the morphisms in <em>E</em>, and as morphisms the commutative squares in <em>E</em> (more precisely, a morphism from (<em>f</em>: <em>X</em> → <em>T</em>) to (<em>g</em>: <em>Y</em> → <em>S</em>) consists of morphisms (<em>a</em>: <em>X</em> → <em>Y</em>) and (<em>b</em>: <em>T</em> → <em>S</em>) such that <em>bf = ga</em>). The functor which takes an arrow to its target makes A(<em>E</em>) into an <em>E</em>-category; for an object <em>S</em> of <em>E</em> the fibre <em>E<sub>S</sub></em> is the category <em>E<sub>/S</sub></em> of <em>S</em>-objects in <em>E</em>, i.e., arrows in <em>E</em> with target <em>S</em>. Cartesian morphisms in A(<em>E</em>) are precisely the <a href="Cartesian_square_(category_theory)" title="wikilink">cartesian squares</a> in <em>E</em>, and thus A(<em>E</em>) is fibred over <em>E</em> precisely when <a href="fibre_product" title="wikilink">fibre products</a> exist in <em>E</em>.</li>
<li><strong>Fibre bundles</strong>: Fibre products exist in the category <em>Top</em> of <a href="topological_space" title="wikilink">topological spaces</a> and thus by the previous example A(<em>Top</em>) is fibred over <em>Top</em>. If <em>Fib</em> is the full subcategory of A(<em>Top</em>) consisting of arrows that are projection maps of <a href="fibre_bundle" title="wikilink">fibre bundles</a>, then <em>Fib<sub>S</sub></em> is the category of fibre bundles on <em>S</em> and <em>Fib</em> is fibred over <em>Top</em>. A choice of a cleavage amounts to a choice of ordinary inverse image (or <em>pull-back</em>) functors for fibre bundles.</li>
<li><strong>Vector bundles</strong>: In a manner similar to the previous examples the projections (<em>p</em>: <em>V</em> → <em>S</em>) of real (complex) <a href="vector_bundles" title="wikilink">vector bundles</a> to their base spaces form a category <em>Vect</em><sub><strong>R</strong></sub> (<em>Vect</em><sub><strong>C</strong></sub>) over <em>Top</em> (morphisms of vector bundles respecting the <a href="vector_space" title="wikilink">vector space</a> structure of the fibres). This <em>Top</em>-category is also fibred, and the inverse image functors are the ordinary <em>pull-back</em> functors for vector bundles. These fibred categories are (non-full) subcategories of <em>Fib</em>.</li>
<li><strong>Sheaves on topological spaces</strong>: The inverse image functors of <a href="Sheaf_(mathematics)" title="wikilink">sheaves</a> make the categories Sh(<em>S</em>) of sheaves on topological spaces <em>S</em> into a (cleaved) fibred category <em>Sh</em> over <em>Top</em>. This fibred category can be described as the full sub-category of A(<em>Top</em>) consisting of <a href="etale_space" title="wikilink">etale spaces</a> of sheaves. As with vector bundles, the sheaves of <a href="group_(mathematics)" title="wikilink">groups</a> and <a href="ring_(mathematics)" title="wikilink">rings</a> also form fibred categories of <em>Top</em>.</li>
<li><strong>Sheaves on topoi</strong>: If <em>E</em> is a <a class="uri" href="topos" title="wikilink">topos</a> and <em>S</em> is an object in <em>E</em>, the category <em>E<sub>S</sub></em> of <em>S</em>-objects is also a topos, interpreted as the category of sheaves on <em>S</em>. If <em>f</em>: <em>T</em> → <em>S</em> is a morphism in <em>E</em>, the inverse image functor <em>f</em><sup>*</sup> can be described as follows: for a sheaf <em>F</em> on <em>E<sub>S</sub></em> and an object <em>p</em>: <em>U</em> → <em>T</em> in <em>E<sub>T</sub></em> one has <em>f<sup>*</sup>F</em>(<em>U</em>) = Hom<sub><em>T</em></sub>(<em>U</em>, <em>f<sup>*</sup>F</em>) equals Hom<sub><em>S</em></sub>(<em>f ∘ p</em>, <em>F</em>) = <em>F</em>(<em>U</em>). These inverse image make the categories <em>E<sub>S</sub></em> into a <em>split</em> fibred category on <em>E</em>. This can be applied in particular to the "large" topos <em>TOP</em> of topological spaces.</li>
<li><strong>Quasi-coherent sheaves on schemes</strong>: <a href="Quasi-coherent_sheaf" title="wikilink">Quasi-coherent sheaves</a> form a fibred category over the category of <a href="scheme_(mathematics)" title="wikilink">schemes</a>. This is one of the motivating examples for the definition of fibred categories.</li>
<li><strong>Fibred category admitting no splitting</strong>: A group <em>G</em> can be considered as a category with one object and the elements of <em>G</em> as the morphisms, composition of morphisms being given by the group law. A group <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> <em>f</em>: <em>G</em> → <em>H</em> can then be considered as a functor, which makes <em>G</em> into a <em>H</em>-category. It can be checked that in this set-up all morphisms in <em>G</em> are cartesian; hence <em>G</em> is fibred over <em>H</em> precisely when <em>f</em> is surjective. A splitting in this setup is a (set-theoretic) <a href="section_(category_theory)" title="wikilink">section</a> of <em>f</em> which commutes strictly with composition, or in other words a section of <em>f</em> which is also a homomorphism. But as is well known in <a href="group_theory" title="wikilink">group theory</a>, this is not always possible (one can take the projection in a non-split <a href="group_extension" title="wikilink">group extension</a>).</li>
<li><strong>Co-fibred category of sheaves</strong>: The <a href="direct_image" title="wikilink">direct image</a> functor of sheaves makes the categories of sheaves on topological spaces into a co-fibred category. The transitivity of the direct image shows that this is even naturally co-split.</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Grothendieck_construction" title="wikilink">Grothendieck construction</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
<li></li>
<li></li>
<li>Brown, R., "Fibrations of groupoids", J. Algebra 15 (1970) 103–132.</li>
<li></li>
<li></li>
<li></li>
<li>Angelo Vistoli, <em>Notes on Grothendieck topologies, fibered categories and descent theory</em>, <a href="http://arxiv.org/abs/math.AG/0412512">arXiv:math.AG/0412512</a>.</li>
<li><a href="http://www.mathematik.tu-darmstadt.de/~streicher/FIBR/FibLec.pdf">Fibred Categories à la Bénabou</a>, <a href="Thomas_Streicher" title="wikilink">Thomas Streicher</a></li>
<li><a href="http://www.lfcs.inf.ed.ac.uk/reports/92/ECS-LFCS-92-208/index.html">An introduction to fibrations, topos theory, the effective topos and modest sets</a>, Wesley Phoa</li>
<li>R. Brown and R. Sivera, <a href="http://www.tac.mta.ca/tac/volumes/22/8/22-08abs.html">"Algebraic colimit calculations in homotopy theory using fibred and cofibred categories"</a>, <em>Theory and Applications of Categories</em>, <strong>22</strong> (2009) 222–251.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://nlab.mathforge.org/nlab/show/Grothendieck+fibration"><em>n</em>lab entry on Grothendieck fibrations</a></li>
</ul>

<p>"</p>

<p><a href="Category:Category_theory" title="wikilink">Category:Category theory</a></p>
</body>
</html>
