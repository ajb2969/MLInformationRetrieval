<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1283">Turbo code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Turbo code</h1>
<hr/>

<p>In <a href="information_theory" title="wikilink">information theory</a>, <strong>turbo codes</strong> (originally in French <em>Turbocodes</em>) are a class of high-performance <a href="forward_error_correction" title="wikilink">forward error correction</a> (FEC) codes developed around 1990-91 (but first published in 1993), which were the first practical codes to closely approach the <a href="Shannon–Hartley_theorem" title="wikilink">channel capacity</a>, a theoretical maximum for the <a href="code_rate" title="wikilink">code rate</a> at which reliable communication is still possible given a specific noise level. Turbo codes are finding use in <a class="uri" href="3G" title="wikilink">3G</a>/<a class="uri" href="4G" title="wikilink">4G</a> mobile communications (e.g. in <a class="uri" href="UMTS" title="wikilink">UMTS</a> and <a href="LTE_(telecommunication)" title="wikilink">LTE</a>) and in (<a href="Deep_Space_Network" title="wikilink">deep space</a>) <a class="uri" href="satellite" title="wikilink">satellite</a> <a href="telecommunication" title="wikilink">communications</a> as well as other applications where designers seek to achieve reliable information transfer over bandwidth- or latency-constrained communication links in the presence of data-corrupting noise. Turbo codes are nowadays competing with <a href="LDPC_code" title="wikilink">LDPC codes</a>, which provide similar performance.</p>

<p>The name "turbo code" arose from the feedback loop used during normal turbo code decoding, which was analogized to the exhaust feedback used for engine turbocharging. <a href="Joachim_Hagenauer" title="wikilink">Hagenauer</a> has argued the term turbo code is a misnomer since there is no feedback involved in the encoding process. <a href="http://www.ima.umn.edu/csg/bib/bib16.0429hage.pdf">[IEEE Transactions]</a></p>
<h2 id="history">History</h2>

<p>The fundamental patent application for turbo codes was filed on 23 April 1991. The patent application lists <a href="Claude_Berrou" title="wikilink">Claude Berrou</a> as the sole inventor of turbo codes. The patent filing resulted in several patents including <a href="https://www.google.com/patents/US5446747">US Patent 5,446,747</a>, which expired 29 August 2013.</p>

<p>The first public paper on turbo codes was "<em>Near Shannon Limit Error-correcting Coding and Decoding: Turbo-codes</em>".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> This paper was published 1993 in the Proceedings of IEEE International Communications Conference. The 1993 paper was formed from three separate submissions that were combined due to space constraints. The merger caused the paper to list three authors: <a href="Claude_Berrou" title="wikilink">Berrou</a>, <a href="Alain_Glavieux" title="wikilink">Glavieux</a>, and <a href="Punya_Thitimajshima" title="wikilink">Thitimajshima</a> (from Télécom Bretagne, former <a href="École_Nationale_Supérieure_des_Télécommunications_de_Bretagne" title="wikilink">ENST Bretagne</a>, France). However, it is clear from the original patent filing that Claude Berrou is the sole inventor of turbo codes and that the other authors of the paper contributed material other than the core concepts of turbo codes.</p>

<p>Turbo codes were so revolutionary at the time of their introduction that many experts in the field of coding did not believe the reported results. When the performance was confirmed a small revolution in the world of coding took place that led to the investigation of many other types of iterative signal processing.</p>

<p>The first class of turbo code was the parallel concatenated convolutional code (PCCC). Since the introduction of the original parallel turbo codes in 1993, many other classes of turbo code have been discovered, including serial versions <a href="Serial_concatenated_convolutional_codes" title="wikilink">Serial concatenated convolutional codes</a> and <a href="Repeat-accumulate_code" title="wikilink">Repeat-accumulate codes</a>. Iterative turbo decoding methods have also been applied to more conventional FEC systems, including Reed-Solomon corrected convolutional codes, although these systems are too complex for practical implementations of iterative decoders. Turbo equalization also flowed from the concept of turbo coding.</p>

<p>In addition to the invention of Turbo Codes, Claude Berrou also invented recursive systematic convolutional (RSC) codes, which are used in the example implementation of turbo codes described in the patent. Turbo Codes that use RSC codes seems to perform better than Turbo codes that do not use RSC codes.</p>

<p>Prior to turbo codes, the best constructions were serial <a href="concatenated_code" title="wikilink">concatenated codes</a> based on an outer <a href="Reed-Solomon_error_correction" title="wikilink">Reed-Solomon error correction</a> code combined with an inner <a href="Viterbi_algorithm" title="wikilink">Viterbi-decoded</a> short constraint length <a href="convolutional_code" title="wikilink">convolutional code</a>, also known as RSV codes.</p>

<p>In a later paper, Berrou generously gave credit to the intuition of "G. Battail, <a href="Joachim_Hagenauer" title="wikilink">J. Hagenauer</a> and P. Hoeher, who, in the late 80s, highlighted the interest of probabilistic processing." He adds "<a href="Robert_G._Gallager" title="wikilink">R. Gallager</a> and M. Tanner had already imagined coding and decoding techniques whose general principles are closely related," although the necessary calculations were impractical at that time.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="an-example-encoder">An example encoder</h2>

<p>There are many different instances of turbo codes, using different component encoders, input/output ratios, interleavers, and puncturing patterns. This example encoder implementation describes a classic turbo encoder, and demonstrates the general design of parallel turbo codes.</p>

<p>This encoder implementation sends three sub-blocks of bits. The first sub-block is the <em>m</em>-bit block of payload data. The second sub-block is <em>n/2</em> parity bits for the payload data, computed using a recursive systematic <a href="convolutional_code" title="wikilink">convolutional code</a> (RSC code). The third sub-block is <em>n/2</em> parity bits for a known <a class="uri" href="permutation" title="wikilink">permutation</a> of the payload data, again computed using an RSC convolutional code. Thus, two redundant but different sub-blocks of parity bits are sent with the payload. The complete block has  bits of data with a code rate of . The <a class="uri" href="permutation" title="wikilink">permutation</a> of the payload data is carried out by a device called an <a class="uri" href="interleaver" title="wikilink">interleaver</a>.</p>

<p>Hardware-wise, this turbo-code encoder consists of two identical RSC coders, С<sub>1</sub> and C<sub>2</sub>, as depicted in the figure, which are connected to each other using a concatenation scheme, called <em>parallel concatenation</em>:</p>
<figure><b>(Figure)</b>
<figcaption>turbo encoder.svg</figcaption>
</figure>

<p>In the figure, <em>M</em> is a memory register. The delay line and interleaver force input bits d<sub>k</sub> to appear in different sequences. At first iteration, the input sequence <em>d</em><sub>k</sub> appears at both outputs of the encoder, <em>x</em><sub>k</sub> and'' y''<sub>1k</sub> or <em>y</em><sub>2k</sub> due to the encoder's systematic nature. If the encoders <em>C</em><sub>1</sub> and <em>C</em><sub>2</sub> are used respectively in <em>n</em><sub>1</sub> and <em>n</em><sub>2</sub> iterations, their rates are respectively equal to</p>

<p>

<math display="inline" id="Turbo_code:0">
 <semantics>
  <msub>
   <mpadded lspace="3.3pt" width="+3.3pt">
    <mi>R</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle~{}R_{1}
  </annotation>
 </semantics>
</math>


</p>
<h2 id="the-decoder">The decoder</h2>

<p>The decoder is built in a similar way to the above encoder. Two elementary decoders are interconnected to each other, but in serial way, not in parallel. The 

<math display="inline" id="Turbo_code:1">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{1}
  </annotation>
 </semantics>
</math>

 decoder operates on lower speed (i.e., 

<math display="inline" id="Turbo_code:2">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle R_{1}
  </annotation>
 </semantics>
</math>

), thus, it is intended for the 

<math display="inline" id="Turbo_code:3">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle C_{1}
  </annotation>
 </semantics>
</math>

 encoder, and 

<math display="inline" id="Turbo_code:4">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{2}
  </annotation>
 </semantics>
</math>

 is for 

<math display="inline" id="Turbo_code:5">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle C_{2}
  </annotation>
 </semantics>
</math>

 correspondingly. 

<math display="inline" id="Turbo_code:6">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{1}
  </annotation>
 </semantics>
</math>

 yields a <a href="Turbo_code#Soft_decision_approach" title="wikilink">soft decision</a> which causes 

<math display="inline" id="Turbo_code:7">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle L_{1}
  </annotation>
 </semantics>
</math>

 delay. The same delay is caused by the delay line in the encoder. The 

<math display="inline" id="Turbo_code:8">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{2}
  </annotation>
 </semantics>
</math>

's operation causes 

<math display="inline" id="Turbo_code:9">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle L_{2}
  </annotation>
 </semantics>
</math>

 delay.</p>
<figure><b>(Figure)</b>
<figcaption>turbo decoder.svg</figcaption>
</figure>

<p>An interleaver installed between the two decoders is used here to scatter error bursts coming from 

<math display="inline" id="Turbo_code:10">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{1}
  </annotation>
 </semantics>
</math>

 output. <em>DI</em> block is a demultiplexing and insertion module. It works as a switch, redirecting input bits to 

<math display="inline" id="Turbo_code:11">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{1}
  </annotation>
 </semantics>
</math>

 at one moment and to 

<math display="inline" id="Turbo_code:12">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{2}
  </annotation>
 </semantics>
</math>

 at another. In OFF state, it feeds both 

<math display="inline" id="Turbo_code:13">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mn>1</mn>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle y_{1k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Turbo_code:14">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mn>2</mn>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle y_{2k}
  </annotation>
 </semantics>
</math>

 inputs with padding bits (zeros).</p>

<p>Consider a memoryless <a href="additive_white_Gaussian_noise" title="wikilink">AWGN</a> channel, and assume that at <em>k</em>-th iteration, the decoder receives a pair of random variables:</p>

<p>

<math display="inline" id="Turbo_code:15">
 <semantics>
  <msub>
   <mpadded lspace="3.3pt" width="+3.3pt">
    <mi>x</mi>
   </mpadded>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle~{}x_{k}
  </annotation>
 </semantics>
</math>


</p>

<p>where 

<math display="inline" id="Turbo_code:16">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle a_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Turbo_code:17">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle b_{k}
  </annotation>
 </semantics>
</math>

 are independent noise components having the same variance 

<math display="inline" id="Turbo_code:18">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\sigma^{2}
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Turbo_code:19">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Y_{k}
  </annotation>
 </semantics>
</math>

 is a <em>k</em>-th bit from 

<math display="inline" id="Turbo_code:20">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle y_{k}
  </annotation>
 </semantics>
</math>

 encoder output.</p>

<p>Redundant information is demultiplexed and sent through <em>DI</em> to 

<math display="inline" id="Turbo_code:21">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{1}
  </annotation>
 </semantics>
</math>

 (when 

<math display="inline" id="Turbo_code:22">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
   </mpadded>
   <mo rspace="5.3pt">=</mo>
   <msub>
    <mi>y</mi>
    <mrow>
     <mn>1</mn>
     <mi>k</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle y_{k}\;=\;y_{1k}
  </annotation>
 </semantics>
</math>

) and to 

<math display="inline" id="Turbo_code:23">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{2}
  </annotation>
 </semantics>
</math>

 (when 

<math display="inline" id="Turbo_code:24">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
   </mpadded>
   <mo rspace="5.3pt">=</mo>
   <msub>
    <mi>y</mi>
    <mrow>
     <mn>2</mn>
     <mi>k</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle y_{k}\;=\;y_{2k}
  </annotation>
 </semantics>
</math>

).</p>

<p>

<math display="inline" id="Turbo_code:25">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{1}
  </annotation>
 </semantics>
</math>

 yields a soft decision; i.e.:</p>

<p>

<math display="block" id="Turbo_code:26">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>d</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>log</mi>
    <mfrac>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>d</mi>
        <mi>k</mi>
       </msub>
       <mo>=</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>d</mi>
        <mi>k</mi>
       </msub>
       <mo>=</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <log></log>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>k</ci>
        </apply>
        <eq></eq>
        <cn type="integer">1</cn>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>k</ci>
        </apply>
        <eq></eq>
        <cn type="integer">0</cn>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(d_{k})=\log\frac{p(d_{k}=1)}{p(d_{k}=0)}
  </annotation>
 </semantics>
</math>

</p>

<p>and delivers it to 

<math display="inline" id="Turbo_code:27">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{2}
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Turbo_code:28">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Λ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>d</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Λ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\Lambda(d_{k})
  </annotation>
 </semantics>
</math>

 is called the <em>logarithm of the likelihood ratio</em> (LLR). 

<math display="inline" id="Turbo_code:29">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+2.8pt">
     <msub>
      <mi>d</mi>
      <mi>k</mi>
     </msub>
    </mpadded>
    <mo rspace="5.3pt">=</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mpadded width="+1.7pt">
    <mi>i</mi>
   </mpadded>
   <mo rspace="4.2pt">∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>k</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">i</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <cn type="float">1</cn>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle p(d_{k}\;=\;i),\,i\,\in\,\{0,\,1\}
  </annotation>
 </semantics>
</math>

 is the <em>a posteriori probability</em> (APP) of the 

<math display="inline" id="Turbo_code:30">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle d_{k}
  </annotation>
 </semantics>
</math>

 data bit which shows the probability of interpreting a received 

<math display="inline" id="Turbo_code:31">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle d_{k}
  </annotation>
 </semantics>
</math>

 bit as 

<math display="inline" id="Turbo_code:32">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle i
  </annotation>
 </semantics>
</math>

. Taking the <em>LLR</em> into account, 

<math display="inline" id="Turbo_code:33">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{2}
  </annotation>
 </semantics>
</math>

 yields a hard decision; i.e., a decoded bit.</p>

<p>It is known that the <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a> is unable to calculate APP, thus it cannot be used in 

<math display="inline" id="Turbo_code:34">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{1}
  </annotation>
 </semantics>
</math>

. Instead of that, a modified <a href="BCJR_algorithm" title="wikilink">BCJR algorithm</a> is used. For 

<math display="inline" id="Turbo_code:35">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{2}
  </annotation>
 </semantics>
</math>

, the <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a> is an appropriate one.</p>

<p>However, the depicted structure is not an optimal one, because 

<math display="inline" id="Turbo_code:36">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>E</mi>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle DEC_{1}
  </annotation>
 </semantics>
</math>

 uses only a proper fraction of the available redundant information. In order to improve the structure, a feedback loop is used (see the dotted line on the figure).</p>
<h2 id="soft-decision-approach">Soft decision approach</h2>

<p>The decoder front-end produces an integer for each bit in the data stream. This integer is a measure of how likely it is that the bit is a 0 or 1 and is also called <em>soft bit</em>. The integer could be drawn from the range [−127, 127], where:</p>
<ul>
<li>−127 means "certainly 0"</li>
<li>−100 means "very likely 0"</li>
<li>0 means "it could be either 0 or 1"</li>
<li>100 means "very likely 1"</li>
<li>127 means "certainly 1"</li>
<li>etc.</li>
</ul>

<p>This introduces a probabilistic aspect to the data-stream from the front end, but it conveys more information about each bit than just 0 or 1.</p>

<p>For example, for each bit, the front end of a traditional wireless-receiver has to decide if an internal analog voltage is above or below a given threshold voltage level. For a turbo-code decoder, the front end would provide an integer measure of how far the internal voltage is from the given threshold.</p>

<p>To decode the -bit block of data, the decoder front-end creates a block of likelihood measures, with one likelihood measure for each bit in the data stream. There are two parallel decoders, one for each of the 

<math display="inline" id="Turbo_code:37">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n}/{2}
  </annotation>
 </semantics>
</math>

-bit parity sub-blocks. Both decoders use the sub-block of <em>m</em> likelihoods for the payload data. The decoder working on the second parity sub-block knows the permutation that the coder used for this sub-block.</p>
<h2 id="solving-hypotheses-to-find-bits">Solving hypotheses to find bits</h2>

<p>The key innovation of turbo codes is how they use the likelihood data to reconcile differences between the two decoders. Each of the two convolutional decoders generates a hypothesis (with derived likelihoods) for the pattern of <em>m</em> bits in the payload sub-block. The hypothesis bit-patterns are compared, and if they differ, the decoders exchange the derived likelihoods they have for each bit in the hypotheses. Each decoder incorporates the derived likelihood estimates from the other decoder to generate a new hypothesis for the bits in the payload. Then they compare these new hypotheses. This iterative process continues until the two decoders come up with the same hypothesis for the <em>m</em>-bit pattern of the payload, typically in 15 to 18 cycles.</p>

<p>An analogy can be drawn between this process and that of solving cross-reference puzzles like <a class="uri" href="crossword" title="wikilink">crossword</a> or <a class="uri" href="sudoku" title="wikilink">sudoku</a>. Consider a partially completed, possibly garbled crossword puzzle. Two puzzle solvers (decoders) are trying to solve it: one possessing only the "down" clues (parity bits), and the other possessing only the "across" clues. To start, both solvers guess the answers (hypotheses) to their own clues, noting down how confident they are in each letter (payload bit). Then, they compare notes, by exchanging answers and confidence ratings with each other, noticing where and how they differ. Based on this new knowledge, they both come up with updated answers and confidence ratings, repeating the whole process until they converge to the same solution.</p>
<h2 id="performance">Performance</h2>

<p>Turbo codes perform well due to the attractive combination of the code's random appearance on the channel together with the physically realisable decoding structure. Turbo codes are affected by an <a href="error_floor" title="wikilink">error floor</a>.</p>
<h2 id="practical-applications-using-turbo-codes">Practical applications using turbo codes</h2>

<p>Telecommunications:</p>
<ul>
<li>Turbo codes are used extensively in <a class="uri" href="3G" title="wikilink">3G</a> and <a class="uri" href="4G" title="wikilink">4G</a> mobile telephony standards; e.g., in <a href="High_Speed_Packet_Access" title="wikilink">HSPA</a>, <a class="uri" href="EV-DO" title="wikilink">EV-DO</a> and <a href="3GPP_Long_Term_Evolution" title="wikilink">LTE</a>.</li>
<li><a class="uri" href="MediaFLO" title="wikilink">MediaFLO</a>, terrestrial mobile television system from <a class="uri" href="Qualcomm" title="wikilink">Qualcomm</a>.</li>
<li>The <a href="return_link" title="wikilink">interaction channel</a> of <a href="satellite_communication" title="wikilink">satellite communication</a> systems, such as <a class="uri" href="DVB-RCS" title="wikilink">DVB-RCS</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <a href="http://www.dvb.org/standards/dvb-rcs2">DVB-RCS2</a>.</li>
<li>New <a class="uri" href="NASA" title="wikilink">NASA</a> missions such as <a href="Mars_Reconnaissance_Orbiter" title="wikilink">Mars Reconnaissance Orbiter</a> now use turbo codes, as an alternative to RS-<a href="Viterbi_decoder" title="wikilink">Viterbi</a> codes.</li>
<li>Turbo coding such as block turbo coding and convolutional turbo coding are used in <a href="IEEE_802.16" title="wikilink">IEEE 802.16</a> (<a class="uri" href="WiMAX" title="wikilink">WiMAX</a>), a wireless metropolitan network standard.</li>
</ul>
<h2 id="bayesian-formulation">Bayesian formulation</h2>

<p>From an <a href="artificial_intelligence" title="wikilink">artificial intelligence</a> viewpoint, turbo codes can be considered as an instance of loopy <a href="belief_propagation" title="wikilink">belief propagation</a> in <a href="Bayesian_network" title="wikilink">Bayesian networks</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Convolutional_code" title="wikilink">Convolutional code</a></li>
<li><a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a></li>
<li><a href="Soft-decision_decoding" title="wikilink">Soft-decision decoding</a></li>
<li><a class="uri" href="Interleaver" title="wikilink">Interleaver</a></li>
<li><a href="BCJR_algorithm" title="wikilink">BCJR algorithm</a></li>
<li><a href="Low-density_parity-check_code" title="wikilink">Low-density parity-check code</a></li>
<li><a href="Serial_concatenated_convolutional_codes" title="wikilink">Serial concatenated convolutional codes</a></li>
<li><a href="Turbo_equalizer" title="wikilink">Turbo equalizer</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.spectrum.ieee.org/computing/software/closing-in-on-the-perfect-code">"Closing In On The Perfect Code"</a>, IEEE Spectrum, March 2004</li>
<li><a href="http://www.csee.wvu.edu/~mvalenti/documents/valenti01.pdf">"The UMTS Turbo Code and an Efficient Decoder Implementation Suitable for Software-Defined Radios"</a> (<em>International Journal of Wireless Information Networks</em>)</li>
<li>

<p>(<a href="http://www.newscientist.com/article.ns?id=mg18725071.400">preview</a>, <a href="http://geilenkotten.homeunix.org/TC_NS_09072005.pdf">copy</a>)</p></li>
<li><a href="http://www.sciencenews.org/articles/20051105/bob8.asp">"Pushing the Limit"</a>, a <em><a href="Science_News" title="wikilink">Science News</a></em> feature about the development and genesis of turbo codes</li>
<li><a href="http://www-turbo.enst-bretagne.fr/">International Symposium On Turbo Codes</a></li>
<li><a href="http://www.iterativesolutions.com/Matlab.htm">Coded Modulation Library</a>, an open source library for simulating turbo codes in matlab</li>
<li><a href="http://www.ifp.uiuc.edu/~singer/journalpapers/tuchler_2002a.pdf">"Turbo Equalization: Principles and New Results"</a>, an <em><a href="IEEE_Transactions_on_Communications" title="wikilink">IEEE Transactions on Communications</a></em> article about using convolutional codes jointly with channel equalization.</li>
<li><a href="http://www.kn-s.dlr.de/turbo/Turbo%20Sim.pdf">"PDF Slideshow illustrating the decoding process"</a> A PDF Slideshow illustrating the decoding process</li>
<li><a href="http://itpp.sourceforge.net">IT++ Home Page</a> The <a class="uri" href="IT++" title="wikilink">IT++</a> is a powerful C++ library which in particular supports turbo codes</li>
<li><a href="http://www.inference.phy.cam.ac.uk/mackay/CodesTurbo.html">Turbo codes publications by David MacKay</a></li>
<li><a href="http://www.newae.com/tiki-index.php?page=Turbo">Extended CML Code including extensive Powerpoint Presentation on Turbo Codes</a></li>
</ul>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Capacity-approaching_codes" title="wikilink">Category:Capacity-approaching codes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.etsi.org/deliver/etsi_en/301700_301799/301790/01.05.01_60/en_301790v010501p.pdf">Digital Video Broadcasting (DVB); Interaction channel for Satellite Distribution Systems</a>, ETSI EN 301 790, V1.5.1, May 2009.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
