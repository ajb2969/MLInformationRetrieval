   Levenberg‚ÄìMarquardt algorithm      Levenberg‚ÄìMarquardt algorithm   In mathematics and computing, the Levenberg‚ÄìMarquardt algorithm (LMA) , also known as the damped least-squares (DLS) method, is used to solve non-linear least squares problems. These minimization problems arise especially in least squares  curve fitting .  The LMA is used in many software applications for solving generic curve-fitting problems. However, as for many fitting algorithms, the LMA finds only a local minimum , which is not necessarily the global minimum . The LMA interpolates between the Gauss‚ÄìNewton algorithm (GNA) and the method of gradient descent . The LMA is more robust than the GNA, which means that in many cases it finds a solution even if it starts very far off the final minimum. For well-behaved functions and reasonable starting parameters, the LMA tends to be a bit slower than the GNA. LMA can also be viewed as Gauss‚ÄìNewton using a trust region approach.  The algorithm was first published in 1944 by Kenneth Levenberg, while working at the Frankford Army Arsenal . It was rediscovered in 1963 by Donald Marquardt who worked as a statistician at DuPont and independently by Girard, Wynn and Morrison.  The problem  The primary application of the Levenberg‚ÄìMarquardt algorithm is in the least squares curve fitting problem: given a set of m empirical datum pairs of independent and dependent variables, ( x i , y i ), optimize the parameters Œ≤ of the model curve f ( x , Œ≤ ) so that the sum of the squares of the deviations       S   (  ùú∑  )    =    ‚àë   i  =  1   m     [    y  i   -   f   (   x  i   ,  ùú∑  )     ]   2          S  ùú∑     superscript   subscript     i  1    m    superscript   delimited-[]     subscript  y  i     f    subscript  x  i   ùú∑      2      S(\boldsymbol{\beta})=\sum_{i=1}^{m}[y_{i}-f(x_{i},\ \boldsymbol{\beta})]^{2}     becomes minimal.  The solution  Like other numeric minimization algorithms, the Levenberg‚ÄìMarquardt algorithm is an iterative procedure. To start a minimization, the user has to provide an initial guess for the parameter vector, Œ≤ . In cases with only one minimum, an uninformed standard guess like Œ≤ T =(1,1,...,1) will work fine; in cases with multiple minima , the algorithm converges to the global minimum only if the initial guess is already somewhat close to the final solution.  In each iteration step, the parameter vector, Œ≤ , is replaced by a new estimate, Œ≤ + Œ¥ . To determine Œ¥ , the functions    f   (   x  i   ,   ùú∑  +  ùúπ   )       f    subscript  x  i     ùú∑  ùúπ      f(x_{i},\boldsymbol{\beta}+\boldsymbol{\delta})   are approximated by their linearizations       f   (   x  i   ,   ùú∑  +  ùúπ   )    ‚âà    f   (   x  i   ,  ùú∑  )    +    J  i    ùúπ           f    subscript  x  i     ùú∑  ùúπ         f    subscript  x  i   ùú∑       subscript  J  i   ùúπ      f(x_{i},\boldsymbol{\beta}+\boldsymbol{\delta})\approx f(x_{i},\boldsymbol{%
 \beta})+J_{i}\boldsymbol{\delta}\!     where       J  i   =     ‚àÇ  f    (   x  i   ,  ùú∑  )     ‚àÇ  ùú∑         subscript  J  i         f     subscript  x  i   ùú∑      ùú∑      J_{i}=\frac{\partial f(x_{i},\boldsymbol{\beta})}{\partial\boldsymbol{\beta}}   is the gradient (row-vector in this case) of f with respect to Œ≤ .  At the minimum of the sum of squares,    S   (  Œ≤  )       S  Œ≤    S(\beta)   , the gradient of   S   S   S   with respect to Œ¥ will be zero. The above first-order approximation of    f   (   x  i   ,   ùú∑  +  ùúπ   )       f    subscript  x  i     ùú∑  ùúπ      f(x_{i},\boldsymbol{\beta}+\boldsymbol{\delta})   gives       S   (   ùú∑  +  ùúπ   )    ‚âà    ‚àë   i  =  1   m     (    y  i   -   f   (   x  i   ,  ùú∑  )    -    J  i   ùúπ    )   2          S    ùú∑  ùúπ      superscript   subscript     i  1    m    superscript     subscript  y  i     f    subscript  x  i   ùú∑       subscript  J  i   ùúπ    2      S(\boldsymbol{\beta}+\boldsymbol{\delta})\approx\sum_{i=1}^{m}\left(y_{i}-f(x_%
 {i},\boldsymbol{\beta})-J_{i}\boldsymbol{\delta}\right)^{2}   . Or in vector notation,       S   (   ùú∑  +  ùúπ   )    ‚âà    ‚à•   ùê≤  -   ùêü   (  ùú∑  )    -   ùêâ  ùúπ    ‚à•   2         S    ùú∑  ùúπ     superscript   norm    ùê≤    ùêü  ùú∑     ùêâ  ùúπ     2     S(\boldsymbol{\beta}+\boldsymbol{\delta})\approx\|\mathbf{y}-\mathbf{f}(%
 \boldsymbol{\beta})-\mathbf{J}\boldsymbol{\delta}\|^{2}   . Taking the derivative with respect to Œ¥ and setting the result to zero gives:        (    ùêâ  ùêì   ùêâ   )   ùúπ   =    ùêâ  ùêì    [   ùê≤  -   ùêü   (  ùú∑  )     ]             superscript  ùêâ  ùêì   ùêâ   ùúπ      superscript  ùêâ  ùêì    delimited-[]    ùê≤    ùêü  ùú∑        \mathbf{(J^{T}J)\boldsymbol{\delta}=J^{T}[y-f(\boldsymbol{\beta})]}\!     where   ùêâ   ùêâ   \mathbf{J}   is the Jacobian matrix whose i th row equals    J  i     subscript  J  i    J_{i}   , and where   ùêü   ùêü   \mathbf{f}   and   ùê≤   ùê≤   \mathbf{y}   are vectors with i th component    f   (   x  i   ,  ùú∑  )       f    subscript  x  i   ùú∑     f(x_{i},\boldsymbol{\beta})   and    y  i     subscript  y  i    y_{i}   , respectively. This is a set of linear equations which can be solved for Œ¥ .  Levenberg's contribution is to replace this equation by a "damped version",        (     ùêâ  ùêì   ùêâ   +   Œª  ùêà    )   ùúπ   =    ùêâ  ùêì    [   ùê≤  -   ùêü   (  ùú∑  )     ]               superscript  ùêâ  ùêì   ùêâ     Œª  ùêà    ùúπ      superscript  ùêâ  ùêì    delimited-[]    ùê≤    ùêü  ùú∑        \mathbf{(J^{T}J+\lambda I)\boldsymbol{\delta}=J^{T}[y-f(\boldsymbol{\beta})]}\!     where I is the identity matrix, giving as the increment, Œ¥ , to the estimated parameter vector, Œ≤ .  The (non-negative) damping factor, Œª, is adjusted at each iteration. If reduction of S is rapid, a smaller value can be used, bringing the algorithm closer to the Gauss‚ÄìNewton algorithm , whereas if an iteration gives insufficient reduction in the residual, Œª can be increased, giving a step closer to the gradient descent direction. Note that the gradient of S with respect to Œ¥ equals    -   2    (    ùêâ  T    [   ùê≤  -   ùêü   (  ùú∑  )     ]    )   T          2   superscript     superscript  ùêâ  T    delimited-[]    ùê≤    ùêü  ùú∑      T      -2(\mathbf{J}^{T}[\mathbf{y}-\mathbf{f}(\boldsymbol{\beta})])^{T}   . Therefore, for large values of Œª , the step will be taken approximately in the direction of the gradient. If either the length of the calculated step, Œ¥ , or the reduction of sum of squares from the latest parameter vector, Œ≤ + Œ¥ , fall below predefined limits, iteration stops and the last parameter vector, Œ≤ , is considered to be the solution.  Levenberg's algorithm has the disadvantage that if the value of damping factor, Œª, is large, inverting J T J +¬†Œª I is not used at all. Marquardt provided the insight that we can scale each component of the gradient according to the curvature so that there is larger movement along the directions where the gradient is smaller. This avoids slow convergence in the direction of small gradient. Therefore, Marquardt replaced the identity matrix, I , with the diagonal matrix consisting of the diagonal elements of J T J , resulting in the Levenberg‚ÄìMarquardt algorithm:        (     ùêâ  ùêì   ùêâ   +    Œª   ùêùùê¢ùêöùê†   (    ùêâ  ùêì   ùêâ   )     )   ùúπ   =    ùêâ  ùêì    [   ùê≤  -   ùêü   (  ùú∑  )     ]               superscript  ùêâ  ùêì   ùêâ     Œª  ùêùùê¢ùêöùê†     superscript  ùêâ  ùêì   ùêâ     ùúπ      superscript  ùêâ  ùêì    delimited-[]    ùê≤    ùêü  ùú∑        \mathbf{(J^{T}J+\lambda\,diag(J^{T}J))\boldsymbol{\delta}=J^{T}[y-f(%
 \boldsymbol{\beta})]}\!   .  A similar damping factor appears in Tikhonov regularization , which is used to solve linear ill-posed problems , as well as in ridge regression , an estimation technique in statistics .  Choice of damping parameter  Various more-or-less heuristic arguments have been put forward for the best choice for the damping parameter Œª. Theoretical arguments exist showing why some of these choices guaranteed local convergence of the algorithm; however these choices can make the global convergence of the algorithm suffer from the undesirable properties of steepest-descent , in particular very slow convergence close to the optimum.  The absolute values of any choice depends on how well-scaled the initial problem is. Marquardt recommended starting with a value Œª 0 and a factor ŒΩ > 1. Initially setting Œª = Œª 0 and computing the residual sum of squares S ( Œ≤ ) after one step from the starting point with the damping factor of Œª = Œª 0 and secondly with Œª 0 /ŒΩ. If both of these are worse than the initial point then the damping is increased by successive multiplication by ŒΩ until a better point is found with a new damping factor of Œª 0 ŒΩ k for some k .  If use of the damping factor Œª/ŒΩ results in a reduction in squared residual then this is taken as the new value of Œª (and the new optimum location is taken as that obtained with this damping factor) and the process continues; if using Œª/ŒΩ resulted in a worse residual, but using Œª resulted in a better residual, then Œª is left unchanged and the new optimum is taken as the value obtained with Œª as damping factor.  Example    In this example we try to fit the function    y  =    a   cos   (   b  X   )     +   b   sin   (   a  X   )          y      a      b  X       b      a  X        y=a\cos(bX)+b\sin(aX)   using the Levenberg‚ÄìMarquardt algorithm implemented in GNU Octave as the leasqr function. The 3 graphs Fig 1,2,3 show progressively better fitting for the parameters a =100, b =102 used in the initial curve. Only when the parameters in Fig 3 are chosen closest to the original, are the curves fitting exactly. This equation is an example of very sensitive initial conditions for the Levenberg‚ÄìMarquardt algorithm. One reason for this sensitivity is the existence of multiple minima ‚Äî the function    cos   (   Œ≤  x   )         Œ≤  x     \cos(\beta x)   has minima at parameter value    Œ≤  ^     normal-^  Œ≤    \hat{\beta}   and      Œ≤  ^   +   2  n  œÄ    .       normal-^  Œ≤     2  n  œÄ     \hat{\beta}+2n\pi.     See also   Trust region  Nelder‚ÄìMead method (aka simplex)   Notes  References                 External links  Descriptions   Detailed description of the algorithm can be found in Numerical Recipes in C, Chapter 15.5: Nonlinear models  C. T. Kelley, Iterative Methods for Optimization , SIAM Frontiers in Applied Mathematics, no 18, 1999, ISBN 0-89871-433-8. Online copy  History of the algorithm in SIAM news  A tutorial by Ananth Ranganathan  Methods for Non-Linear Least Squares Problems by K. Madsen, H.B. Nielsen, O. Tingleff is a tutorial discussing non-linear least-squares in general and the Levenberg-Marquardt method in particular  T. Strutz: Data Fitting and Uncertainty (A practical introduction to weighted least squares and beyond) . Vieweg+Teubner, ISBN 978-3-8348-1022-9.  H. P. Gavin, The Levenberg-Marquardt method for nonlinear least squares curve-Ô¨Åtting problems ( MATLAB implementation included)   Implementations   Levenberg-Marquardt is a built-in algorithm in Mathematica , Matlab , NeuroSolutions , GNU Octave , Origin , SciPy , Fityk , IGOR Pro and LabVIEW .  The oldest implementation still in use is lmdif , from MINPACK , in Fortran , in the public domain . See also:  lmfit , a self-contained C implementation of the MINPACK algorithm, with an easy-to-use wrapper for curve fitting, liberal licence (freeBSD).  eigen , a C++ linear algebra library, includes an adaptation of the minpack algorithm in the "NonLinearOptimization" module.  The GNU Scientific Library has a C interface to MINPACK.  C/C++ Minpack includes the Levenberg‚ÄìMarquardt algorithm.  Several high-level languages and mathematical packages have wrappers for the MINPACK routines, among them:  Python library scipy , module scipy.optimize.leastsq ,  IDL , add-on MPFIT .  R (programming language) has the minpack.lm package.    levmar is an implementation in C / C++ with support for constraints, distributed under the GNU General Public License .  levmar includes a MEX file interface for MATLAB  Perl ( PDL ), python , Haskell and .NET interfaces to levmar are available: see PDL::Fit::Levmar or [ https://metacpan.org/module/PDL ::Fit::LM PDL::Fit::LM], PyLevmar , HackageDB levmar and LevmarSharp .   sparseLM is a C implementation aimed at minimizing functions with large, arbitrarily sparse Jacobians. Includes a MATLAB MEX interface.  SMarquardt.m is a stand-alone routine for Matlab or Octave.  InMin library contains a C++ implementation of the algorithm based on the eigen C++ linear algebra library. It has a pure C-language API as well as a Python binding  ceres is a non-linear minimisation library with an implementation of the Levenberg‚ÄìMarquardt algorithm. It is written in C++ and uses eigen  ALGLIB has implementations of improved LMA in C# / C++ / Delphi / Visual Basic. Improved algorithm takes less time to converge and can use either Jacobian or exact Hessian.  NMath has an implementation for the .NET Framework .  gnuplot uses its own implementation gnuplot.info .  Java programming language implementations: 1) Javanumerics , 2) LMA-package (a small, user friendly and well documented implementation with examples and support), 3) Apache Commons Math  OOoConv implements the L-M algorithm as an OpenOffice.org Calc spreadsheet.  SAS , there are multiple ways to access SAS's implementation of the Levenberg‚ÄìMarquardt algorithm: it can be accessed via NLPLM Call in PROC IML and it can also be accessed through the LSQ statement in PROC NLP , and the METHOD=MARQUARDT option in PROC NLIN .  LMAM/OLMAM Matlab toolbox implements Levenberg-Marquardt with adaptive momentum for training feedforward neural networks.  GADfit is a Fortran implementation of global fitting based on a modified Levenberg-Marquardt. Uses automatic differentiation. Allows fitting functions of arbitrary complexity, including integrals.   "  Category:Statistical algorithms  Category:Optimization algorithms and methods  Category:Least squares   