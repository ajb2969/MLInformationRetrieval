   PatchMatch      PatchMatch   The core PatchMatch algorithm quickly finds correspondences between small square regions (or patches) of an image. The algorithm can be used in various applications such as object removal from images, reshuffling or moving contents of images, or retargeting or changing aspect ratios of images.  Algorithm  The goal of the algorithm is to find the patch correspondence by deﬁning a nearest-neighbor ﬁeld (NNF) as a function     f  :    ℝ  2   →   ℝ  2       normal-:  f   normal-→   superscript  ℝ  2    superscript  ℝ  2      f:\mathbb{R}^{2}\to\mathbb{R}^{2}   of offsets, which is over all possible matches of patch (location of patch centers) in image A, for some distance function of two patches   D   D   D   . So, for a given patch coordinate   a   a   a   in image   A   A   A   and its corresponding nearest neighbor   b   b   b   in image   B   B   B   ,    f   (  a  )       f  a    f(a)   is simply    b  -  a      b  a    b-a   . However, if we search for every point in image   B   B   B   , the work will be too hard to complete. So the following algorithm is done in a randomized approach in order to accelerate the calculation speed. The algorithm has three main components. Initially, the nearest-neighbor ﬁeld is ﬁlled with either random offsets or some prior information. Next, an iterative update process is applied to the NNF, in which good patch offsets are propagated to adjacent pixels, followed by random search in the neighborhood of the best offset found so far. Independent of these three components, the algorithm also use a coarse-to-fine approach by building an image pyramid to obtain the better result.  Initialization  When initializing with random offsets, we use independent uniform samples across the full range of image   B   B   B   . This algorithm avoids using an initial guess from the previous level of the pyramid because in this way the algorithm can avoid being trapped in local minima.  Iteration  After initialization, the algorithm attempted to perform iterative process of improving the    N  N  F      N  N  F    NNF   . The iterations examine the offsets in scan order (from left to right, top to bottom), and each undergoes propagation followed by random search .  Propagation  We attempt to improve    f   (  x  ,  y  )       f   x  y     f(x,y)   using the known offsets of    f   (   x  -  1   ,  y  )       f     x  1   y     f(x-1,y)   and    f   (  x  ,   y  -  1   )       f   x    y  1      f(x,y-1)   , assuming that the patch offsets are likely to be the same. That is, the algorithm will take new value for    f   (  x  ,  y  )       f   x  y     f(x,y)   to be      arg    min   (  x  ,  y  )    D     (   f   (  x  ,  y  )    )    ,   D   (   f   (   x  -  1   ,  y  )    )    ,   D   (   f   (  x  ,   y  -  1   )    )             subscript    x  y    D      f   x  y       D    f     x  1   y       D    f   x    y  1        \arg\min\limits_{(x,y)}{D(f(x,y)),D(f(x-1,y)),D(f(x,y-1))}   . So if    f   (  x  ,  y  )       f   x  y     f(x,y)   has a correct mapping and is in a coherent region   R   R   R   , then all of   R   R   R   below and to the right of    f   (  x  ,  y  )       f   x  y     f(x,y)   will be ﬁlled with the correct mapping. Alternatively, on even iterations, the algorithm search for different direction, fill the new value to be    arg    min   (  x  ,  y  )     {   D   (   f   (  x  ,  y  )    )    ,   D   (   f   (   x  +  1   ,  y  )    )    ,   D   (   f   (  x  ,   y  +  1   )    )    }          subscript    x  y      D    f   x  y       D    f     x  1   y       D    f   x    y  1         \arg\min\limits_{(x,y)}\{D(f(x,y)),D(f(x+1,y)),D(f(x,y+1))\}   .  Random search  Let     v  0   =   f   (  x  ,  y  )         subscript  v  0     f   x  y      v_{0}=f(x,y)   , we attempt to improve    f   (  x  ,  y  )       f   x  y     f(x,y)   by testing a sequence of candidate offsets at an exponentially decreasing distance from    v  0     subscript  v  0    v_{0}          u  i   =    v  0   +   w   α  i    R  i          subscript  u  i      subscript  v  0     w   superscript  α  i    subscript  R  i       u_{i}=v_{0}+w\alpha^{i}R_{i}     where    R  i     subscript  R  i    R_{i}   is a uniform random in     [   -  1   ,  1  ]   ×   [   -  1   ,  1  ]          1   1      1   1     [-1,1]\times[-1,1]   ,   w   w   w   is a large window search radius which will be set to maximum picture size, and   α   α   \alpha   is a fixed ratio often assigned as 1/2. This part of the algorithm allows the    f   (  x  ,  y  )       f   x  y     f(x,y)   to jump out of local minimum through random process.  Halting criteria  The often used halting criteria is set the iteration times to be about 4~5. Even with low iteration, the algorithm works well.  Conclusion  This is an efficient algorithm since it only takes a few second on a testing computer with Intel Core i5 CPU and Photoshop CS5.  See also   Nearest neighbor search   References   Connelly Barnes, Eli Shechtman, Adam Finkelstein, Dan B Goldman(2009), PatchMatch: A Randomized Correspondence Algorithm for Structural Image Editing   "  Category:Computer vision   