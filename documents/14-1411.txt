   Forney algorithm      Forney algorithm   In coding theory , the Forney algorithm (or Forney's algorithm ) calculates the error values at known error locations. It is used as one of the steps in decoding BCH codes and Reed–Solomon codes (a subclass of BCH codes). George David Forney, Jr. developed the algorithm. 1  Procedure   Need to introduce terminology and the setup...    Code words look like polynomials. By design, the generator polynomial has consecutive roots α c , α c +1 , ..., α c + d −2 .  Syndromes  Error location polynomial 2       Λ   (  x  )    =    ∏   i  =  1   ν    (   1  -    x    X  i     )    =   1  +    ∑   i  =  1   ν      λ  i     x  i              normal-Λ  x     superscript   subscript  product    i  1    ν     1    x   subscript  X  i             1    superscript   subscript     i  1    ν      subscript  λ  i    superscript  x  i         \Lambda(x)=\prod_{i=1}^{\nu}(1-x\,X_{i})=1+\sum_{i=1}^{\nu}\lambda_{i}\,x^{i}     The zeros of Λ( x ) are X 1 −1 , ..., X ν −1 . The zeros are the reciprocals of the error locations     X  j   =   α   i  j         subscript  X  j    superscript  α   subscript  i  j      X_{j}=\alpha^{i_{j}}   .  Once the error locations are known, the next step is to determine the error values at those locations. The error values are then used to correct the received values at those locations to recover the original codeword.  In the more general case, the error weights can be determined by solving the linear system       s  0   =     e  1    α    (   c  +  0   )    i  1      +    e  2    α    (   c  +  0   )    i  2      +   ⋯         subscript  s  0        subscript  e  1    superscript  α      c  0    subscript  i  1         subscript  e  2    superscript  α      c  0    subscript  i  2      normal-⋯     s_{0}=e_{1}\alpha^{(c+0)\,i_{1}}+e_{2}\alpha^{(c+0)\,i_{2}}+\cdots\,          s  1   =     e  1    α    (   c  +  1   )    i  1      +    e  2    α    (   c  +  1   )    i  2      +   ⋯         subscript  s  1        subscript  e  1    superscript  α      c  1    subscript  i  1         subscript  e  2    superscript  α      c  1    subscript  i  2      normal-⋯     s_{1}=e_{1}\alpha^{(c+1)\,i_{1}}+e_{2}\alpha^{(c+1)\,i_{2}}+\cdots\,         ⋯    normal-⋯   \cdots\,     However, there is a more efficient method known as the Forney algorithm, which is based on Lagrange interpolation . First calculate the error evaluator polynomial 3       Ω   (  x  )    =    S   (  x  )   Λ   (  x  )        (   mod   x   2  t     )           normal-Ω  x    annotated    S  x  normal-Λ  x    pmod   superscript  x    2  t        \Omega(x)=S(x)\,\Lambda(x)\;\;(\mathop{{\rm mod}}x^{2t})\,     Where    S   (  x  )       S  x    S(x)   is the partial syndrome polynomial: 4        S   (  x  )    =     s  0    x  0    +    s  1    x  1    +    s  2    x  2    +  ⋯  +    s    2  t   -  1     x    2  t   -  1       .        S  x        subscript  s  0    superscript  x  0       subscript  s  1    superscript  x  1       subscript  s  2    superscript  x  2    normal-⋯     subscript  s      2  t   1     superscript  x      2  t   1        S(x)=s_{0}x^{0}+s_{1}x^{1}+s_{2}x^{2}+\cdots+s_{2t-1}x^{2t-1}.     Then evaluate the error values: 5       e  j   =   -       X  j   1  -  c     Ω   (   X  j   -  1    )      Λ  ′    (   X  j   -  1    )            subscript  e  j          superscript   subscript  X  j     1  c    normal-Ω   superscript   subscript  X  j     1        superscript  normal-Λ  normal-′    superscript   subscript  X  j     1         e_{j}=-\frac{X_{j}^{1-c}\,\Omega(X_{j}^{-1})}{\Lambda^{\prime}(X_{j}^{-1})}\,     The value   c   c   c   is often called the "first consecutive root" or "fcr". Some codes select    c  =  1      c  1    c=1   , so the expression simplifies to:       e  j   =   -    Ω   (   X  j   -  1    )      Λ  ′    (   X  j   -  1    )           subscript  e  j         normal-Ω   superscript   subscript  X  j     1        superscript  normal-Λ  normal-′    superscript   subscript  X  j     1         e_{j}=-\frac{\Omega(X_{j}^{-1})}{\Lambda^{\prime}(X_{j}^{-1})}     Formal derivative  Λ'( x ) is the formal derivative of the error locator polynomial Λ( x ): 6        Λ  ′    (  x  )    =    ∑   i  =  1   ν      i   ⋅    λ  i      x   i  -  1             superscript  normal-Λ  normal-′   x     superscript   subscript     i  1    ν      normal-⋅  i   subscript  λ  i     superscript  x    i  1        \Lambda^{\prime}(x)=\sum_{i=1}^{\nu}i\,\cdot\,\lambda_{i}\,x^{i-1}     In the above expression, note that i is an integer, and λ i would be an element of the finite field. The operator · represents ordinary multiplication (repeated addition in the finite field) and not the finite field's multiplication operator.  Derivation  Lagrange interpolation  gives a derivation of the Forney algorithm.  Erasures  Define the erasure locator polynomial       Γ   (  x  )    =   ∏   (   1  -    x    α   j  i      )          normal-Γ  x    product    1    x   superscript  α   subscript  j  i         \Gamma(x)=\prod(1-x\,\alpha^{j_{i}})   Where the erasure locations are given by j i . Apply the procedure described above, substituting Γ for Λ.  If both errors and erasures are present, use the error-and-erasure locator polynomial       Ψ   (  x  )    =   Λ   (  x  )   Γ   (  x  )          normal-Ψ  x     normal-Λ  x  normal-Γ  x     \Psi(x)=\Lambda(x)\,\Gamma(x)     See also   BCH code  Reed–Solomon error correction   References     W. Wesley Peterson 's book   External links  "  Category:Error detection and correction  Category:Coding theory     ↩  ↩  ↩  ↩       