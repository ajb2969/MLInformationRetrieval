<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="959">Loss network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Loss network</h1>
<hr/>

<p>In <a href="queueing_theory" title="wikilink">queueing theory</a>, a <strong>loss network</strong> is a <a href="stochastic_model" title="wikilink">stochastic model</a> of a <a href="telephony_network" title="wikilink">telephony network</a> in which calls are routed around a network between nodes. The links between nodes have finite capacity and thus some calls arriving may find no route available to their destination. These calls are lost from the network, hence the name loss networks.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The loss network was first studied by <a href="Agner_Krarup_Erlang" title="wikilink">Erlang</a> for a single telephone link.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a href="Frank_Kelly_(mathematician)" title="wikilink">Frank Kelly</a> was awarded the <a href="Frederick_W._Lanchester_Prize" title="wikilink">Frederick W. Lanchester Prize</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> for his 1991 paper <em>Loss Networks</em><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> where he demonstrated the behaviour of loss networks can exhibit <a class="uri" href="hysteresis" title="wikilink">hysteresis</a>.</p>
<h2 id="model">Model</h2>
<h3 id="fixed-routing">Fixed routing</h3>

<p>Consider a network with <em>J</em> links labelled 1, 2, …, <em>J</em> and that each link <em>j</em> has <em>C</em><sub><em>j</em></sub> <a href="circuit_switching" title="wikilink">circuits</a>. Let <em>R</em> be the set of all possible routes in the network (combinations of links a call might use) and each route <em>r</em>, write <em>A</em><sub><em>jr</em></sub> for the number of circuits route <em>r</em> uses on link <em>j</em> (<em>A</em> is therefore a <em>J</em> x |<em>R</em>| matrix). Consider the case where all elements of <em>A</em> are either 0 or 1 and for each route <em>r</em> calls requiring use of the route arrive according to a <a href="Poisson_process" title="wikilink">Poisson process</a> of rate <em>v</em><sub><em>r</em></sub>. When a call arrives if there is sufficient capacity remaining on all the required links the call is accepted and occupies the network for an <a href="exponentially_distributed" title="wikilink">exponentially distributed</a> length of time with parameter 1. If there is insufficient capacity on any individual link to accept the call it is rejected (lost) from the network.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Write <em>n</em><sub><em>r</em></sub>(<em>t</em>) for the number of calls on route <em>r</em> in progress at time <em>t</em>, <em>n</em>(<em>t</em>) for the vector (<em>n</em><sub><em>r</em></sub>(<em>t</em>) : <em>r</em> in <em>R</em>) and <em>C</em> = (<em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, ... , <em>C</em><sub><em>J</em></sub>). Then the <a href="continuous-time_Markov_process" title="wikilink">continuous-time Markov process</a> <em>n</em>(<em>t</em>) has unique stationary distribution<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Loss_network:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∏</mo>
      <mrow>
       <mi>r</mi>
       <mo>∈</mo>
       <mi>R</mi>
      </mrow>
     </msub>
     <mrow>
      <mfrac>
       <msubsup>
        <mi>v</mi>
        <mi>r</mi>
        <msub>
         <mi>n</mi>
         <mi>r</mi>
        </msub>
       </msubsup>
       <mrow>
        <msub>
         <mi>n</mi>
         <mi>r</mi>
        </msub>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
      </mfrac>
      <mtext>for</mtext>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>G</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <in></in>
         <ci>r</ci>
         <ci>R</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>v</ci>
           <ci>r</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>r</ci>
          </apply>
         </apply>
         <apply>
          <factorial></factorial>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>r</ci>
          </apply>
         </apply>
        </apply>
        <mtext>for</mtext>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(n)=G(C)^{-1}\prod_{r\in R}\frac{v_{r}^{n_{r}}}{n_{r}!}\text{ for }n\in S(C)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Loss_network:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>n</mi>
     <mo>∈</mo>
     <msubsup>
      <mi>ℤ</mi>
      <mo>+</mo>
      <mi>R</mi>
     </msubsup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mi>n</mi>
     </mrow>
     <mo>≤</mo>
     <mi>C</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ℤ</ci>
        <plus></plus>
       </apply>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(C)=\{n\in\mathbb{Z}_{+}^{R}:An\leq C\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>and</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Loss_network:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>n</mi>
        <mo>∈</mo>
        <mrow>
         <mi>S</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>C</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∏</mo>
        <mrow>
         <mi>r</mi>
         <mo>∈</mo>
         <mi>R</mi>
        </mrow>
       </msub>
       <mfrac>
        <msubsup>
         <mi>v</mi>
         <mi>r</mi>
         <msub>
          <mi>n</mi>
          <mi>r</mi>
         </msub>
        </msubsup>
        <mrow>
         <msub>
          <mi>n</mi>
          <mi>r</mi>
         </msub>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
       </mfrac>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>n</ci>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>C</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <in></in>
        <ci>r</ci>
        <ci>R</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>r</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>r</ci>
        </apply>
       </apply>
       <apply>
        <factorial></factorial>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>r</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(C)=\left(\sum_{n\in S(C)}\prod_{r\in R}\frac{v_{r}^{n_{r}}}{n_{r}!}\right).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>From this result loss probabilities for calls arriving on different routes can be calculated by summing over appropriate states.</p>
<h2 id="computing-loss-probabilities">Computing loss probabilities</h2>

<p>There are common algorithms for computing the loss probabilities in loss networks<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<ol>
<li>Erlang ﬁxed-point approximation</li>
<li>Slice method</li>
<li>3-point slice method</li>
</ol>
<h2 id="notes">Notes</h2>

<p>"</p>

<p><a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a> <a href="Category:Application-specific_graphs" title="wikilink">Category:Application-specific graphs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
