   Gram–Schmidt process      Gram–Schmidt process   In mathematics , particularly linear algebra and numerical analysis , the Gram–Schmidt process is a method for orthonormalising a set of vectors in an inner product space , most commonly the Euclidean space  R n . The Gram–Schmidt process takes a finite , linearly independent set S = { v 1 , ..., v k } for  and generates an orthogonal set that spans the same k -dimensional subspace of R n as S .  The method is named after Jørgen Pedersen Gram and Erhard Schmidt but it appeared earlier in the work of Laplace and Cauchy . In the theory of Lie group decompositions it is generalized by the Iwasawa decomposition . 1  The application of the Gram–Schmidt process to the column vectors of a full column rank  matrix yields the QR decomposition (it is decomposed into an orthogonal and a triangular matrix ).  The Gram–Schmidt process  (Figure)  The Gram-Schmidt process being executed on three linearly independent, non-orthogonal vectors of a basis for R 3 . Click on image for details.   We define the projection  operator by          proj  𝐮     (  𝐯  )    =     ⟨  𝐯  ,  𝐮  ⟩    ⟨  𝐮  ,  𝐮  ⟩    𝐮    ,         subscript  proj  𝐮   𝐯        𝐯  𝐮    𝐮  𝐮    𝐮     \mathrm{proj}_{\mathbf{u}}\,(\mathbf{v})={\langle\mathbf{v},\mathbf{u}\rangle%
 \over\langle\mathbf{u},\mathbf{u}\rangle}\mathbf{u},   where    ⟨  𝐯  ,  𝐮  ⟩     𝐯  𝐮    \langle\mathbf{v},\mathbf{u}\rangle   denotes the inner product of the vectors v and u . This operator projects the vector v orthogonally onto the line spanned by vector u . If u =0, we define       proj  0     (  𝐯  )    :=  0     assign     subscript  proj  0   𝐯   0    \mathrm{proj}_{0}\,(\mathbf{v}):=0   . i.e., the projection map    proj  0     subscript  proj  0    \mathrm{proj}_{0}   is the zero map, sending every vector to the zero vector.  The Gram–Schmidt process then works as follows:      𝐮  1     subscript  𝐮  1    \displaystyle\mathbf{u}_{1}     The sequence u 1 , ..., u k is the required system of orthogonal vectors, and the normalized vectors e 1 , ..., e k form an ortho normal set. The calculation of the sequence u 1 , ..., u k is known as Gram–Schmidt orthogonalization , while the calculation of the sequence e 1 , ..., e k is known as Gram–Schmidt orthonormalization as the vectors are normalized.  To check that these formulas yield an orthogonal sequence, first compute ‹ u 1 , u 2 › by substituting the above formula for u 2 : we get zero. Then use this to compute ‹ u 1 , u 3 › again by substituting the formula for u 3 : we get zero. The general proof proceeds by mathematical induction .  Geometrically, this method proceeds as follows: to compute u i , it projects v i orthogonally onto the subspace U generated by u 1 , ..., u i −1 , which is the same as the subspace generated by v 1 , ..., v i −1 . The vector u i is then defined to be the difference between v i and this projection, guaranteed to be orthogonal to all of the vectors in the subspace U .  The Gram–Schmidt process also applies to a linearly independent countably infinite sequence { v i } i . The result is an orthogonal (or orthonormal) sequence { u i } i such that for natural number n : the algebraic span of v 1 , ..., v n is the same as that of u 1 , ..., u n .  If the Gram–Schmidt process is applied to a linearly dependent sequence, it outputs the 0 vector on the i th step, assuming that v i is a linear combination of . If an orthonormal basis is to be produced, then the algorithm should test for zero vectors in the output and discard them because no multiple of a zero vector can have a length of 1. The number of vectors output by the algorithm will then be the dimension of the space spanned by the original inputs.  A variant of the Gram–Schmidt process using transfinite recursion applied to a (possibly uncountably) infinite sequence of vectors     (   v  α   )    α  <  λ      subscript   subscript  v  α     α  λ     (v_{\alpha})_{\alpha<\lambda}   yields a set of orthonormal vectors     (   u  α   )    α  <  κ      subscript   subscript  u  α     α  κ     (u_{\alpha})_{\alpha<\kappa}   with    κ  ≤  λ      κ  λ    \kappa\leq\lambda   such that for any    α  ≤  λ      α  λ    \alpha\leq\lambda   , the completion of the span of    {   u  β   :   β  <   min   (  α  ,  κ  )     }     conditional-set   subscript  u  β     β    α  κ      \{u_{\beta}:\beta<\min(\alpha,\kappa)\}   is the same as that of    {   v  β   :   β  <  α   }     conditional-set   subscript  v  β     β  α     \{v_{\beta}:\beta<\alpha\}   . In particular, when applied to a (algebraic) basis of a Hilbert space (or, more generally, a basis of any dense subspace), it yields a (functional-analytic) orthonormal basis. Note that in the general case often the strict inequality    κ  <  λ      κ  λ    \kappa<\lambda   holds, even if the starting set was linearly independent, and the span of     (   u  α   )    α  <  κ      subscript   subscript  u  α     α  κ     (u_{\alpha})_{\alpha<\kappa}   need not be a subspace of the span of     (   v  α   )    α  <  λ      subscript   subscript  v  α     α  λ     (v_{\alpha})_{\alpha<\lambda}   (rather, it's a subspace of its completion).  Example  Consider the following set of vectors in R 2 (with the conventional inner product)      S  =   {   𝐯  1   =   (     3      1     )   ,   𝐯  2   =   (     2      2     )   }   .     fragments  S    fragments  normal-{   subscript  𝐯  1      3    1    normal-,   subscript  𝐯  2      2    2    normal-}   normal-.    S=\left\{\mathbf{v}_{1}=\begin{pmatrix}3\\
 1\end{pmatrix},\mathbf{v}_{2}=\begin{pmatrix}2\\
 2\end{pmatrix}\right\}.     Now, perform Gram–Schmidt, to obtain an orthogonal set of vectors:       𝐮  1   =   𝐯  1   =   (     3      1     )          subscript  𝐮  1    subscript  𝐯  1          3    1       \mathbf{u}_{1}=\mathbf{v}_{1}=\begin{pmatrix}3\\
 1\end{pmatrix}           𝐮  2   =    𝐯  2   -     proj   𝐮  1      (   𝐯  2   )     =    (     2      2     )   -     proj   (      3      1      )      (   (     2      2     )   )     =    (     2      2     )   -    (      4  /  5      )    (     3      1     )     =   (      -   2  /  5         6  /  5      )    .         subscript  𝐮  2      subscript  𝐯  2      subscript  proj   subscript  𝐮  1     subscript  𝐯  2              2    2       subscript  proj   STACKED  3  1      2    2               2    2          4  5       3    1                 2  5        6  5        \mathbf{u}_{2}=\mathbf{v}_{2}-\mathrm{proj}_{\mathbf{u}_{1}}\,(\mathbf{v}_{2})%
 =\begin{pmatrix}2\\
 2\end{pmatrix}-\mathrm{proj}_{({3\atop 1})}\,({\begin{pmatrix}2\\
 2\end{pmatrix})}=\begin{pmatrix}2\\
 2\end{pmatrix}-\begin{pmatrix}4/5\end{pmatrix}\begin{pmatrix}3\\
 1\end{pmatrix}=\begin{pmatrix}-2/5\\
 6/5\end{pmatrix}.     We check that the vectors u 1 and u 2 are indeed orthogonal:        ⟨   𝐮  1   ,   𝐮  2   ⟩   =   ⟨   (     3      1     )   ,   (      -   2  /  5         6  /  5      )   ⟩   =    -   6  5    +   6  5    =  0   ,          subscript  𝐮  1    subscript  𝐮  2       3    1          2  5        6  5                 6  5      6  5         0     \langle\mathbf{u}_{1},\mathbf{u}_{2}\rangle=\left\langle\begin{pmatrix}3\\
 1\end{pmatrix},\begin{pmatrix}-2/5\\
 6/5\end{pmatrix}\right\rangle=-\frac{6}{5}+\frac{6}{5}=0,   noting that if the dot product of two vectors is 0 then they are orthogonal.  For non-zero vectors, we can then normalize the vectors by dividing out their sizes as shown above:       𝐞  1   =    1   10     (     3      1     )         subscript  𝐞  1       1    10      3    1       \mathbf{e}_{1}={1\over\sqrt{10}}\begin{pmatrix}3\\
 1\end{pmatrix}           𝐞  2   =    1    40  25      (      -   2  /  5         6  /  5      )    =    1   10     (      -  1       3     )     .         subscript  𝐞  2       1      40  25           2  5        6  5               1    10        1     3        \mathbf{e}_{2}={1\over\sqrt{40\over 25}}\begin{pmatrix}-2/5\\
 6/5\end{pmatrix}={1\over\sqrt{10}}\begin{pmatrix}-1\\
 3\end{pmatrix}.     Numerical stability  When this process is implemented on a computer, the vectors    𝐮  k     subscript  𝐮  k    \mathbf{u}_{k}   are often not quite orthogonal, due to rounding errors . For the Gram–Schmidt process as described above (sometimes referred to as "classical Gram–Schmidt") this loss of orthogonality is particularly bad; therefore, it is said that the (classical) Gram–Schmidt process is numerically unstable .  The Gram–Schmidt process can be stabilized by a small modification; this version is sometimes referred to as modified Gram-Schmidt or MGS. This approach gives the same result as the original formula in exact arithmetic and introduces smaller errors in finite-precision arithmetic. Instead of computing the vector u k as        𝐮  k   =    𝐯  k   -     proj   𝐮  1      (   𝐯  k   )    -     proj   𝐮  2      (   𝐯  k   )    -  ⋯  -     proj   𝐮   k  -  1       (   𝐯  k   )      ,       subscript  𝐮  k      subscript  𝐯  k      subscript  proj   subscript  𝐮  1     subscript  𝐯  k       subscript  proj   subscript  𝐮  2     subscript  𝐯  k    normal-⋯     subscript  proj   subscript  𝐮    k  1      subscript  𝐯  k       \mathbf{u}_{k}=\mathbf{v}_{k}-\mathrm{proj}_{\mathbf{u}_{1}}\,(\mathbf{v}_{k})%
 -\mathrm{proj}_{\mathbf{u}_{2}}\,(\mathbf{v}_{k})-\cdots-\mathrm{proj}_{%
 \mathbf{u}_{k-1}}\,(\mathbf{v}_{k}),   it is computed as      𝐮  k   (  1  )      superscript   subscript  𝐮  k   1    \displaystyle\mathbf{u}_{k}^{(1)}     Each step finds a vector    𝐮  k   (  i  )      superscript   subscript  𝐮  k   i    \mathbf{u}_{k}^{(i)}   orthogonal to    𝐮  k   (   i  -  1   )      superscript   subscript  𝐮  k     i  1     \mathbf{u}_{k}^{(i-1)}   . Thus    𝐮  k   (  i  )      superscript   subscript  𝐮  k   i    \mathbf{u}_{k}^{(i)}   is also orthogonalized against any errors introduced in computation of    𝐮  k   (   i  -  1   )      superscript   subscript  𝐮  k     i  1     \mathbf{u}_{k}^{(i-1)}   .  This method is used in the previous animation, when the intermediate v' 3 vector is used when orthogonalizing the blue vector v 3 .  Algorithm  The following algorithm implements the stabilized Gram–Schmidt orthonormalization. The vectors v 1 , ..., v k are replaced by orthonormal vectors which span the same subspace.   for  i  from 1 to  k  do       𝐯  i   ←    𝐯  i    ∥   𝐯  i   ∥       normal-←   subscript  𝐯  i      subscript  𝐯  i    norm   subscript  𝐯  i       \mathbf{v}_{i}\leftarrow\frac{\mathbf{v}_{i}}{\|\mathbf{v}_{i}\|}   ( normalize )   for  j  from i+1 to k do       𝐯  j   ←    𝐯  j   -     proj   𝐯  i      (   𝐯  j   )        normal-←   subscript  𝐯  j      subscript  𝐯  j      subscript  proj   subscript  𝐯  i     subscript  𝐯  j       \mathbf{v}_{j}\leftarrow\mathbf{v}_{j}-\mathrm{proj}_{\mathbf{v}_{i}}\,(%
 \mathbf{v}_{j})   ( remove component in direction  v i )   next j       next i    The cost of this algorithm is asymptotically 2 nk 2 floating point operations, where n is the dimensionality of the vectors .  Determinant formula  The result of the Gram–Schmidt process may be expressed in a non-recursive formula using determinants .       𝐞  j   =    1     D   j  -  1     D  j       |      ⟨   𝐯  1   ,   𝐯  1   ⟩      ⟨   𝐯  2   ,   𝐯  1   ⟩     …     ⟨   𝐯  j   ,   𝐯  1   ⟩        ⟨   𝐯  1   ,   𝐯  2   ⟩      ⟨   𝐯  2   ,   𝐯  2   ⟩     …     ⟨   𝐯  j   ,   𝐯  2   ⟩       ⋮    ⋮    ⋱    ⋮       ⟨   𝐯  1   ,   𝐯   j  -  1    ⟩      ⟨   𝐯  2   ,   𝐯   j  -  1    ⟩     …     ⟨   𝐯  j   ,   𝐯   j  -  1    ⟩        𝐯  1      𝐯  2     …     𝐯  j      |         subscript  𝐞  j       1       subscript  D    j  1     subscript  D  j            subscript  𝐯  1    subscript  𝐯  1      subscript  𝐯  2    subscript  𝐯  1    normal-…    subscript  𝐯  j    subscript  𝐯  1        subscript  𝐯  1    subscript  𝐯  2      subscript  𝐯  2    subscript  𝐯  2    normal-…    subscript  𝐯  j    subscript  𝐯  2      normal-⋮  normal-⋮  normal-⋱  normal-⋮      subscript  𝐯  1    subscript  𝐯    j  1       subscript  𝐯  2    subscript  𝐯    j  1     normal-…    subscript  𝐯  j    subscript  𝐯    j  1        subscript  𝐯  1    subscript  𝐯  2   normal-…   subscript  𝐯  j         \mathbf{e}_{j}=\frac{1}{\sqrt{D_{j-1}D_{j}}}\begin{vmatrix}\langle\mathbf{v}_{%
 1},\mathbf{v}_{1}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{1}\rangle&\dots&%
 \langle\mathbf{v}_{j},\mathbf{v}_{1}\rangle\\
 \langle\mathbf{v}_{1},\mathbf{v}_{2}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{%
 2}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{2}\rangle\\
 \vdots&\vdots&\ddots&\vdots\\
 \langle\mathbf{v}_{1},\mathbf{v}_{j-1}\rangle&\langle\mathbf{v}_{2},\mathbf{v}%
 _{j-1}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{j-1}\rangle\\
 \mathbf{v}_{1}&\mathbf{v}_{2}&\dots&\mathbf{v}_{j}\end{vmatrix}          𝐮  j   =    1   D   j  -  1      |      ⟨   𝐯  1   ,   𝐯  1   ⟩      ⟨   𝐯  2   ,   𝐯  1   ⟩     …     ⟨   𝐯  j   ,   𝐯  1   ⟩        ⟨   𝐯  1   ,   𝐯  2   ⟩      ⟨   𝐯  2   ,   𝐯  2   ⟩     …     ⟨   𝐯  j   ,   𝐯  2   ⟩       ⋮    ⋮    ⋱    ⋮       ⟨   𝐯  1   ,   𝐯   j  -  1    ⟩      ⟨   𝐯  2   ,   𝐯   j  -  1    ⟩     …     ⟨   𝐯  j   ,   𝐯   j  -  1    ⟩        𝐯  1      𝐯  2     …     𝐯  j      |         subscript  𝐮  j       1   subscript  D    j  1           subscript  𝐯  1    subscript  𝐯  1      subscript  𝐯  2    subscript  𝐯  1    normal-…    subscript  𝐯  j    subscript  𝐯  1        subscript  𝐯  1    subscript  𝐯  2      subscript  𝐯  2    subscript  𝐯  2    normal-…    subscript  𝐯  j    subscript  𝐯  2      normal-⋮  normal-⋮  normal-⋱  normal-⋮      subscript  𝐯  1    subscript  𝐯    j  1       subscript  𝐯  2    subscript  𝐯    j  1     normal-…    subscript  𝐯  j    subscript  𝐯    j  1        subscript  𝐯  1    subscript  𝐯  2   normal-…   subscript  𝐯  j         \mathbf{u}_{j}=\frac{1}{D_{j-1}}\begin{vmatrix}\langle\mathbf{v}_{1},\mathbf{v%
 }_{1}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{1}\rangle&\dots&\langle\mathbf{%
 v}_{j},\mathbf{v}_{1}\rangle\\
 \langle\mathbf{v}_{1},\mathbf{v}_{2}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{%
 2}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{2}\rangle\\
 \vdots&\vdots&\ddots&\vdots\\
 \langle\mathbf{v}_{1},\mathbf{v}_{j-1}\rangle&\langle\mathbf{v}_{2},\mathbf{v}%
 _{j-1}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{j-1}\rangle\\
 \mathbf{v}_{1}&\mathbf{v}_{2}&\dots&\mathbf{v}_{j}\end{vmatrix}     where D  0 =1 and, for j ≥ 1, D j is the Gram determinant        D  j   =   |      ⟨   𝐯  1   ,   𝐯  1   ⟩      ⟨   𝐯  2   ,   𝐯  1   ⟩     …     ⟨   𝐯  j   ,   𝐯  1   ⟩        ⟨   𝐯  1   ,   𝐯  2   ⟩      ⟨   𝐯  2   ,   𝐯  2   ⟩     …     ⟨   𝐯  j   ,   𝐯  2   ⟩       ⋮    ⋮    ⋱    ⋮       ⟨   𝐯  1   ,   𝐯  j   ⟩      ⟨   𝐯  2   ,   𝐯  j   ⟩     …     ⟨   𝐯  j   ,   𝐯  j   ⟩      |    .       subscript  D  j         subscript  𝐯  1    subscript  𝐯  1      subscript  𝐯  2    subscript  𝐯  1    normal-…    subscript  𝐯  j    subscript  𝐯  1        subscript  𝐯  1    subscript  𝐯  2      subscript  𝐯  2    subscript  𝐯  2    normal-…    subscript  𝐯  j    subscript  𝐯  2      normal-⋮  normal-⋮  normal-⋱  normal-⋮      subscript  𝐯  1    subscript  𝐯  j      subscript  𝐯  2    subscript  𝐯  j    normal-…    subscript  𝐯  j    subscript  𝐯  j         D_{j}=\begin{vmatrix}\langle\mathbf{v}_{1},\mathbf{v}_{1}\rangle&\langle%
 \mathbf{v}_{2},\mathbf{v}_{1}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{1%
 }\rangle\\
 \langle\mathbf{v}_{1},\mathbf{v}_{2}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{%
 2}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{2}\rangle\\
 \vdots&\vdots&\ddots&\vdots\\
 \langle\mathbf{v}_{1},\mathbf{v}_{j}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{%
 j}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{j}\rangle\end{vmatrix}.     Note that the expression for u k is a "formal" determinant, i.e. the matrix contains both scalars and vectors; the meaning of this expression is defined to be the result of a cofactor expansion along the row of vectors.  The determinant formula for the Gram-Schmidt is computationally slower (exponentially slower) than the recursive algorithms described above; it is mainly of theoretical interest.  Alternatives  Other orthogonalization algorithms use Householder transformations or Givens rotations . The algorithms using Householder transformations are more stable than the stabilized Gram–Schmidt process. On the other hand, the Gram–Schmidt process produces the   j   j   j   th orthogonalized vector after the   j   j   j   th iteration, while orthogonalization using Householder reflections produces all the vectors only at the end. This makes only the Gram–Schmidt process applicable for iterative methods like the Arnoldi iteration .  Yet another alternative is motivated by the use of Cholesky decomposition for inverting the matrix of the normal equations in linear least squares . Let   𝐕   𝐕   \mathbf{V}   be a full column rank matrix, which columns need to be orthogonalized. The matrix     𝐕  *   𝐕       superscript  𝐕    𝐕    \mathbf{V}^{*}\mathbf{V}   is Hermitian and positive definite , so it can be written as       𝐕  *   𝐕   =   𝐋𝐋  *    ,         superscript  𝐕    𝐕    superscript  𝐋𝐋      \mathbf{V}^{*}\mathbf{V}=\mathbf{L}\mathbf{L}^{*},   using the Cholesky decomposition . The lower triangular matrix   𝐋   𝐋   \mathbf{L}   with strictly positive diagonal entries is invertible . Then columns of the matrix    𝐔  =   𝐕    (   𝐋   -  1    )   *        𝐔    𝐕   superscript   superscript  𝐋    1         \mathbf{U}=\mathbf{V}(\mathbf{L}^{-1})^{*}   are orthonormal and span the same subspace as the columns of the original matrix   𝐕   𝐕   \mathbf{V}   . The explicit use of the product     𝐕  *   𝐕       superscript  𝐕    𝐕    \mathbf{V}^{*}\mathbf{V}   makes the algorithm unstable, especially if the product's condition number is large. Nevertheless, this algorithm is used in practice and implemented in some software packages because of its high efficiency and simplicity.  In quantum mechanics there are several orthogonalization schemes with characteristics better suited for applications than the Gram–Schmidt one. The most important among them are the symmetric and the canonical orthonormalization (see Solivérez & Gagliano).  References      .   .   .   .   External links    Harvey Mudd College Math Tutorial on the Gram-Schmidt algorithm  Earliest known uses of some of the words of mathematics: G The entry "Gram-Schmidt orthogonalization" has some information and references on the origins of the method.  Demos: Gram Schmidt process in plane and Gram Schmidt process in space  Gram-Schmidt orthogonalization applet  NAG Gram–Schmidt orthogonalization of n vectors of order m routine  Proof: Raymond Puzio, Keenan Kidwell. "proof of Gram-Schmidt orthogonalization algorithm" (version 8). PlanetMath.org.   "  Category:Linear algebra  Category:Functional analysis     ↩     