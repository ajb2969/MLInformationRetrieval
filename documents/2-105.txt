   Gramâ€“Schmidt process      Gramâ€“Schmidt process   In mathematics , particularly linear algebra and numerical analysis , the Gramâ€“Schmidt process is a method for orthonormalising a set of vectors in an inner product space , most commonly the Euclidean space  R n . The Gramâ€“Schmidt process takes a finite , linearly independent set S = { v 1 , ..., v k } for  and generates an orthogonal set that spans the same k -dimensional subspace of R n as S .  The method is named after JÃ¸rgen Pedersen Gram and Erhard Schmidt but it appeared earlier in the work of Laplace and Cauchy . In the theory of Lie group decompositions it is generalized by the Iwasawa decomposition . 1  The application of the Gramâ€“Schmidt process to the column vectors of a full column rank  matrix yields the QR decomposition (it is decomposed into an orthogonal and a triangular matrix ).  The Gramâ€“Schmidt process  (Figure)  The Gram-Schmidt process being executed on three linearly independent, non-orthogonal vectors of a basis for R 3 . Click on image for details.   We define the projection  operator by          proj  ğ®     (  ğ¯  )    =     âŸ¨  ğ¯  ,  ğ®  âŸ©    âŸ¨  ğ®  ,  ğ®  âŸ©    ğ®    ,         subscript  proj  ğ®   ğ¯        ğ¯  ğ®    ğ®  ğ®    ğ®     \mathrm{proj}_{\mathbf{u}}\,(\mathbf{v})={\langle\mathbf{v},\mathbf{u}\rangle%
 \over\langle\mathbf{u},\mathbf{u}\rangle}\mathbf{u},   where    âŸ¨  ğ¯  ,  ğ®  âŸ©     ğ¯  ğ®    \langle\mathbf{v},\mathbf{u}\rangle   denotes the inner product of the vectors v and u . This operator projects the vector v orthogonally onto the line spanned by vector u . If u =0, we define       proj  0     (  ğ¯  )    :=  0     assign     subscript  proj  0   ğ¯   0    \mathrm{proj}_{0}\,(\mathbf{v}):=0   . i.e., the projection map    proj  0     subscript  proj  0    \mathrm{proj}_{0}   is the zero map, sending every vector to the zero vector.  The Gramâ€“Schmidt process then works as follows:      ğ®  1     subscript  ğ®  1    \displaystyle\mathbf{u}_{1}     The sequence u 1 , ..., u k is the required system of orthogonal vectors, and the normalized vectors e 1 , ..., e k form an ortho normal set. The calculation of the sequence u 1 , ..., u k is known as Gramâ€“Schmidt orthogonalization , while the calculation of the sequence e 1 , ..., e k is known as Gramâ€“Schmidt orthonormalization as the vectors are normalized.  To check that these formulas yield an orthogonal sequence, first compute â€¹ u 1 , u 2 â€º by substituting the above formula for u 2 : we get zero. Then use this to compute â€¹ u 1 , u 3 â€º again by substituting the formula for u 3 : we get zero. The general proof proceeds by mathematical induction .  Geometrically, this method proceeds as follows: to compute u i , it projects v i orthogonally onto the subspace U generated by u 1 , ..., u i âˆ’1 , which is the same as the subspace generated by v 1 , ..., v i âˆ’1 . The vector u i is then defined to be the difference between v i and this projection, guaranteed to be orthogonal to all of the vectors in the subspace U .  The Gramâ€“Schmidt process also applies to a linearly independent countably infinite sequence { v i } i . The result is an orthogonal (or orthonormal) sequence { u i } i such that for natural number n : the algebraic span of v 1 , ..., v n is the same as that of u 1 , ..., u n .  If the Gramâ€“Schmidt process is applied to a linearly dependent sequence, it outputs the 0 vector on the i th step, assuming that v i is a linear combination of . If an orthonormal basis is to be produced, then the algorithm should test for zero vectors in the output and discard them because no multiple of a zero vector can have a length of 1. The number of vectors output by the algorithm will then be the dimension of the space spanned by the original inputs.  A variant of the Gramâ€“Schmidt process using transfinite recursion applied to a (possibly uncountably) infinite sequence of vectors     (   v  Î±   )    Î±  <  Î»      subscript   subscript  v  Î±     Î±  Î»     (v_{\alpha})_{\alpha<\lambda}   yields a set of orthonormal vectors     (   u  Î±   )    Î±  <  Îº      subscript   subscript  u  Î±     Î±  Îº     (u_{\alpha})_{\alpha<\kappa}   with    Îº  â‰¤  Î»      Îº  Î»    \kappa\leq\lambda   such that for any    Î±  â‰¤  Î»      Î±  Î»    \alpha\leq\lambda   , the completion of the span of    {   u  Î²   :   Î²  <   min   (  Î±  ,  Îº  )     }     conditional-set   subscript  u  Î²     Î²    Î±  Îº      \{u_{\beta}:\beta<\min(\alpha,\kappa)\}   is the same as that of    {   v  Î²   :   Î²  <  Î±   }     conditional-set   subscript  v  Î²     Î²  Î±     \{v_{\beta}:\beta<\alpha\}   . In particular, when applied to a (algebraic) basis of a Hilbert space (or, more generally, a basis of any dense subspace), it yields a (functional-analytic) orthonormal basis. Note that in the general case often the strict inequality    Îº  <  Î»      Îº  Î»    \kappa<\lambda   holds, even if the starting set was linearly independent, and the span of     (   u  Î±   )    Î±  <  Îº      subscript   subscript  u  Î±     Î±  Îº     (u_{\alpha})_{\alpha<\kappa}   need not be a subspace of the span of     (   v  Î±   )    Î±  <  Î»      subscript   subscript  v  Î±     Î±  Î»     (v_{\alpha})_{\alpha<\lambda}   (rather, it's a subspace of its completion).  Example  Consider the following set of vectors in R 2 (with the conventional inner product)      S  =   {   ğ¯  1   =   (     3      1     )   ,   ğ¯  2   =   (     2      2     )   }   .     fragments  S    fragments  normal-{   subscript  ğ¯  1      3    1    normal-,   subscript  ğ¯  2      2    2    normal-}   normal-.    S=\left\{\mathbf{v}_{1}=\begin{pmatrix}3\\
 1\end{pmatrix},\mathbf{v}_{2}=\begin{pmatrix}2\\
 2\end{pmatrix}\right\}.     Now, perform Gramâ€“Schmidt, to obtain an orthogonal set of vectors:       ğ®  1   =   ğ¯  1   =   (     3      1     )          subscript  ğ®  1    subscript  ğ¯  1          3    1       \mathbf{u}_{1}=\mathbf{v}_{1}=\begin{pmatrix}3\\
 1\end{pmatrix}           ğ®  2   =    ğ¯  2   -     proj   ğ®  1      (   ğ¯  2   )     =    (     2      2     )   -     proj   (      3      1      )      (   (     2      2     )   )     =    (     2      2     )   -    (      4  /  5      )    (     3      1     )     =   (      -   2  /  5         6  /  5      )    .         subscript  ğ®  2      subscript  ğ¯  2      subscript  proj   subscript  ğ®  1     subscript  ğ¯  2              2    2       subscript  proj   STACKED  3  1      2    2               2    2          4  5       3    1                 2  5        6  5        \mathbf{u}_{2}=\mathbf{v}_{2}-\mathrm{proj}_{\mathbf{u}_{1}}\,(\mathbf{v}_{2})%
 =\begin{pmatrix}2\\
 2\end{pmatrix}-\mathrm{proj}_{({3\atop 1})}\,({\begin{pmatrix}2\\
 2\end{pmatrix})}=\begin{pmatrix}2\\
 2\end{pmatrix}-\begin{pmatrix}4/5\end{pmatrix}\begin{pmatrix}3\\
 1\end{pmatrix}=\begin{pmatrix}-2/5\\
 6/5\end{pmatrix}.     We check that the vectors u 1 and u 2 are indeed orthogonal:        âŸ¨   ğ®  1   ,   ğ®  2   âŸ©   =   âŸ¨   (     3      1     )   ,   (      -   2  /  5         6  /  5      )   âŸ©   =    -   6  5    +   6  5    =  0   ,          subscript  ğ®  1    subscript  ğ®  2       3    1          2  5        6  5                 6  5      6  5         0     \langle\mathbf{u}_{1},\mathbf{u}_{2}\rangle=\left\langle\begin{pmatrix}3\\
 1\end{pmatrix},\begin{pmatrix}-2/5\\
 6/5\end{pmatrix}\right\rangle=-\frac{6}{5}+\frac{6}{5}=0,   noting that if the dot product of two vectors is 0 then they are orthogonal.  For non-zero vectors, we can then normalize the vectors by dividing out their sizes as shown above:       ğ  1   =    1   10     (     3      1     )         subscript  ğ  1       1    10      3    1       \mathbf{e}_{1}={1\over\sqrt{10}}\begin{pmatrix}3\\
 1\end{pmatrix}           ğ  2   =    1    40  25      (      -   2  /  5         6  /  5      )    =    1   10     (      -  1       3     )     .         subscript  ğ  2       1      40  25           2  5        6  5               1    10        1     3        \mathbf{e}_{2}={1\over\sqrt{40\over 25}}\begin{pmatrix}-2/5\\
 6/5\end{pmatrix}={1\over\sqrt{10}}\begin{pmatrix}-1\\
 3\end{pmatrix}.     Numerical stability  When this process is implemented on a computer, the vectors    ğ®  k     subscript  ğ®  k    \mathbf{u}_{k}   are often not quite orthogonal, due to rounding errors . For the Gramâ€“Schmidt process as described above (sometimes referred to as "classical Gramâ€“Schmidt") this loss of orthogonality is particularly bad; therefore, it is said that the (classical) Gramâ€“Schmidt process is numerically unstable .  The Gramâ€“Schmidt process can be stabilized by a small modification; this version is sometimes referred to as modified Gram-Schmidt or MGS. This approach gives the same result as the original formula in exact arithmetic and introduces smaller errors in finite-precision arithmetic. Instead of computing the vector u k as        ğ®  k   =    ğ¯  k   -     proj   ğ®  1      (   ğ¯  k   )    -     proj   ğ®  2      (   ğ¯  k   )    -  â‹¯  -     proj   ğ®   k  -  1       (   ğ¯  k   )      ,       subscript  ğ®  k      subscript  ğ¯  k      subscript  proj   subscript  ğ®  1     subscript  ğ¯  k       subscript  proj   subscript  ğ®  2     subscript  ğ¯  k    normal-â‹¯     subscript  proj   subscript  ğ®    k  1      subscript  ğ¯  k       \mathbf{u}_{k}=\mathbf{v}_{k}-\mathrm{proj}_{\mathbf{u}_{1}}\,(\mathbf{v}_{k})%
 -\mathrm{proj}_{\mathbf{u}_{2}}\,(\mathbf{v}_{k})-\cdots-\mathrm{proj}_{%
 \mathbf{u}_{k-1}}\,(\mathbf{v}_{k}),   it is computed as      ğ®  k   (  1  )      superscript   subscript  ğ®  k   1    \displaystyle\mathbf{u}_{k}^{(1)}     Each step finds a vector    ğ®  k   (  i  )      superscript   subscript  ğ®  k   i    \mathbf{u}_{k}^{(i)}   orthogonal to    ğ®  k   (   i  -  1   )      superscript   subscript  ğ®  k     i  1     \mathbf{u}_{k}^{(i-1)}   . Thus    ğ®  k   (  i  )      superscript   subscript  ğ®  k   i    \mathbf{u}_{k}^{(i)}   is also orthogonalized against any errors introduced in computation of    ğ®  k   (   i  -  1   )      superscript   subscript  ğ®  k     i  1     \mathbf{u}_{k}^{(i-1)}   .  This method is used in the previous animation, when the intermediate v' 3 vector is used when orthogonalizing the blue vector v 3 .  Algorithm  The following algorithm implements the stabilized Gramâ€“Schmidt orthonormalization. The vectors v 1 , ..., v k are replaced by orthonormal vectors which span the same subspace.   for  i  from 1 to  k  do       ğ¯  i   â†    ğ¯  i    âˆ¥   ğ¯  i   âˆ¥       normal-â†   subscript  ğ¯  i      subscript  ğ¯  i    norm   subscript  ğ¯  i       \mathbf{v}_{i}\leftarrow\frac{\mathbf{v}_{i}}{\|\mathbf{v}_{i}\|}   ( normalize )   for  j  from i+1 to k do       ğ¯  j   â†    ğ¯  j   -     proj   ğ¯  i      (   ğ¯  j   )        normal-â†   subscript  ğ¯  j      subscript  ğ¯  j      subscript  proj   subscript  ğ¯  i     subscript  ğ¯  j       \mathbf{v}_{j}\leftarrow\mathbf{v}_{j}-\mathrm{proj}_{\mathbf{v}_{i}}\,(%
 \mathbf{v}_{j})   ( remove component in direction  v i )   next j       next i    The cost of this algorithm is asymptotically 2 nk 2 floating point operations, where n is the dimensionality of the vectors .  Determinant formula  The result of the Gramâ€“Schmidt process may be expressed in a non-recursive formula using determinants .       ğ  j   =    1     D   j  -  1     D  j       |      âŸ¨   ğ¯  1   ,   ğ¯  1   âŸ©      âŸ¨   ğ¯  2   ,   ğ¯  1   âŸ©     â€¦     âŸ¨   ğ¯  j   ,   ğ¯  1   âŸ©        âŸ¨   ğ¯  1   ,   ğ¯  2   âŸ©      âŸ¨   ğ¯  2   ,   ğ¯  2   âŸ©     â€¦     âŸ¨   ğ¯  j   ,   ğ¯  2   âŸ©       â‹®    â‹®    â‹±    â‹®       âŸ¨   ğ¯  1   ,   ğ¯   j  -  1    âŸ©      âŸ¨   ğ¯  2   ,   ğ¯   j  -  1    âŸ©     â€¦     âŸ¨   ğ¯  j   ,   ğ¯   j  -  1    âŸ©        ğ¯  1      ğ¯  2     â€¦     ğ¯  j      |         subscript  ğ  j       1       subscript  D    j  1     subscript  D  j            subscript  ğ¯  1    subscript  ğ¯  1      subscript  ğ¯  2    subscript  ğ¯  1    normal-â€¦    subscript  ğ¯  j    subscript  ğ¯  1        subscript  ğ¯  1    subscript  ğ¯  2      subscript  ğ¯  2    subscript  ğ¯  2    normal-â€¦    subscript  ğ¯  j    subscript  ğ¯  2      normal-â‹®  normal-â‹®  normal-â‹±  normal-â‹®      subscript  ğ¯  1    subscript  ğ¯    j  1       subscript  ğ¯  2    subscript  ğ¯    j  1     normal-â€¦    subscript  ğ¯  j    subscript  ğ¯    j  1        subscript  ğ¯  1    subscript  ğ¯  2   normal-â€¦   subscript  ğ¯  j         \mathbf{e}_{j}=\frac{1}{\sqrt{D_{j-1}D_{j}}}\begin{vmatrix}\langle\mathbf{v}_{%
 1},\mathbf{v}_{1}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{1}\rangle&\dots&%
 \langle\mathbf{v}_{j},\mathbf{v}_{1}\rangle\\
 \langle\mathbf{v}_{1},\mathbf{v}_{2}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{%
 2}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{2}\rangle\\
 \vdots&\vdots&\ddots&\vdots\\
 \langle\mathbf{v}_{1},\mathbf{v}_{j-1}\rangle&\langle\mathbf{v}_{2},\mathbf{v}%
 _{j-1}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{j-1}\rangle\\
 \mathbf{v}_{1}&\mathbf{v}_{2}&\dots&\mathbf{v}_{j}\end{vmatrix}          ğ®  j   =    1   D   j  -  1      |      âŸ¨   ğ¯  1   ,   ğ¯  1   âŸ©      âŸ¨   ğ¯  2   ,   ğ¯  1   âŸ©     â€¦     âŸ¨   ğ¯  j   ,   ğ¯  1   âŸ©        âŸ¨   ğ¯  1   ,   ğ¯  2   âŸ©      âŸ¨   ğ¯  2   ,   ğ¯  2   âŸ©     â€¦     âŸ¨   ğ¯  j   ,   ğ¯  2   âŸ©       â‹®    â‹®    â‹±    â‹®       âŸ¨   ğ¯  1   ,   ğ¯   j  -  1    âŸ©      âŸ¨   ğ¯  2   ,   ğ¯   j  -  1    âŸ©     â€¦     âŸ¨   ğ¯  j   ,   ğ¯   j  -  1    âŸ©        ğ¯  1      ğ¯  2     â€¦     ğ¯  j      |         subscript  ğ®  j       1   subscript  D    j  1           subscript  ğ¯  1    subscript  ğ¯  1      subscript  ğ¯  2    subscript  ğ¯  1    normal-â€¦    subscript  ğ¯  j    subscript  ğ¯  1        subscript  ğ¯  1    subscript  ğ¯  2      subscript  ğ¯  2    subscript  ğ¯  2    normal-â€¦    subscript  ğ¯  j    subscript  ğ¯  2      normal-â‹®  normal-â‹®  normal-â‹±  normal-â‹®      subscript  ğ¯  1    subscript  ğ¯    j  1       subscript  ğ¯  2    subscript  ğ¯    j  1     normal-â€¦    subscript  ğ¯  j    subscript  ğ¯    j  1        subscript  ğ¯  1    subscript  ğ¯  2   normal-â€¦   subscript  ğ¯  j         \mathbf{u}_{j}=\frac{1}{D_{j-1}}\begin{vmatrix}\langle\mathbf{v}_{1},\mathbf{v%
 }_{1}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{1}\rangle&\dots&\langle\mathbf{%
 v}_{j},\mathbf{v}_{1}\rangle\\
 \langle\mathbf{v}_{1},\mathbf{v}_{2}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{%
 2}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{2}\rangle\\
 \vdots&\vdots&\ddots&\vdots\\
 \langle\mathbf{v}_{1},\mathbf{v}_{j-1}\rangle&\langle\mathbf{v}_{2},\mathbf{v}%
 _{j-1}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{j-1}\rangle\\
 \mathbf{v}_{1}&\mathbf{v}_{2}&\dots&\mathbf{v}_{j}\end{vmatrix}     where D  0 =1 and, for j â‰¥ 1, D j is the Gram determinant        D  j   =   |      âŸ¨   ğ¯  1   ,   ğ¯  1   âŸ©      âŸ¨   ğ¯  2   ,   ğ¯  1   âŸ©     â€¦     âŸ¨   ğ¯  j   ,   ğ¯  1   âŸ©        âŸ¨   ğ¯  1   ,   ğ¯  2   âŸ©      âŸ¨   ğ¯  2   ,   ğ¯  2   âŸ©     â€¦     âŸ¨   ğ¯  j   ,   ğ¯  2   âŸ©       â‹®    â‹®    â‹±    â‹®       âŸ¨   ğ¯  1   ,   ğ¯  j   âŸ©      âŸ¨   ğ¯  2   ,   ğ¯  j   âŸ©     â€¦     âŸ¨   ğ¯  j   ,   ğ¯  j   âŸ©      |    .       subscript  D  j         subscript  ğ¯  1    subscript  ğ¯  1      subscript  ğ¯  2    subscript  ğ¯  1    normal-â€¦    subscript  ğ¯  j    subscript  ğ¯  1        subscript  ğ¯  1    subscript  ğ¯  2      subscript  ğ¯  2    subscript  ğ¯  2    normal-â€¦    subscript  ğ¯  j    subscript  ğ¯  2      normal-â‹®  normal-â‹®  normal-â‹±  normal-â‹®      subscript  ğ¯  1    subscript  ğ¯  j      subscript  ğ¯  2    subscript  ğ¯  j    normal-â€¦    subscript  ğ¯  j    subscript  ğ¯  j         D_{j}=\begin{vmatrix}\langle\mathbf{v}_{1},\mathbf{v}_{1}\rangle&\langle%
 \mathbf{v}_{2},\mathbf{v}_{1}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{1%
 }\rangle\\
 \langle\mathbf{v}_{1},\mathbf{v}_{2}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{%
 2}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{2}\rangle\\
 \vdots&\vdots&\ddots&\vdots\\
 \langle\mathbf{v}_{1},\mathbf{v}_{j}\rangle&\langle\mathbf{v}_{2},\mathbf{v}_{%
 j}\rangle&\dots&\langle\mathbf{v}_{j},\mathbf{v}_{j}\rangle\end{vmatrix}.     Note that the expression for u k is a "formal" determinant, i.e. the matrix contains both scalars and vectors; the meaning of this expression is defined to be the result of a cofactor expansion along the row of vectors.  The determinant formula for the Gram-Schmidt is computationally slower (exponentially slower) than the recursive algorithms described above; it is mainly of theoretical interest.  Alternatives  Other orthogonalization algorithms use Householder transformations or Givens rotations . The algorithms using Householder transformations are more stable than the stabilized Gramâ€“Schmidt process. On the other hand, the Gramâ€“Schmidt process produces the   j   j   j   th orthogonalized vector after the   j   j   j   th iteration, while orthogonalization using Householder reflections produces all the vectors only at the end. This makes only the Gramâ€“Schmidt process applicable for iterative methods like the Arnoldi iteration .  Yet another alternative is motivated by the use of Cholesky decomposition for inverting the matrix of the normal equations in linear least squares . Let   ğ•   ğ•   \mathbf{V}   be a full column rank matrix, which columns need to be orthogonalized. The matrix     ğ•  *   ğ•       superscript  ğ•    ğ•    \mathbf{V}^{*}\mathbf{V}   is Hermitian and positive definite , so it can be written as       ğ•  *   ğ•   =   ğ‹ğ‹  *    ,         superscript  ğ•    ğ•    superscript  ğ‹ğ‹      \mathbf{V}^{*}\mathbf{V}=\mathbf{L}\mathbf{L}^{*},   using the Cholesky decomposition . The lower triangular matrix   ğ‹   ğ‹   \mathbf{L}   with strictly positive diagonal entries is invertible . Then columns of the matrix    ğ”  =   ğ•    (   ğ‹   -  1    )   *        ğ”    ğ•   superscript   superscript  ğ‹    1         \mathbf{U}=\mathbf{V}(\mathbf{L}^{-1})^{*}   are orthonormal and span the same subspace as the columns of the original matrix   ğ•   ğ•   \mathbf{V}   . The explicit use of the product     ğ•  *   ğ•       superscript  ğ•    ğ•    \mathbf{V}^{*}\mathbf{V}   makes the algorithm unstable, especially if the product's condition number is large. Nevertheless, this algorithm is used in practice and implemented in some software packages because of its high efficiency and simplicity.  In quantum mechanics there are several orthogonalization schemes with characteristics better suited for applications than the Gramâ€“Schmidt one. The most important among them are the symmetric and the canonical orthonormalization (see SolivÃ©rez & Gagliano).  References      .   .   .   .   External links    Harvey Mudd College Math Tutorial on the Gram-Schmidt algorithm  Earliest known uses of some of the words of mathematics: G The entry "Gram-Schmidt orthogonalization" has some information and references on the origins of the method.  Demos: Gram Schmidt process in plane and Gram Schmidt process in space  Gram-Schmidt orthogonalization applet  NAG Gramâ€“Schmidt orthogonalization of n vectors of order m routine  Proof: Raymond Puzio, Keenan Kidwell. "proof of Gram-Schmidt orthogonalization algorithm" (version 8). PlanetMath.org.   "  Category:Linear algebra  Category:Functional analysis     â†©     