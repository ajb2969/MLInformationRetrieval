<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="804">Self-adjoint operator</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Self-adjoint operator</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>self-adjoint operator</strong> on a complex vector space <em>V</em> with <a href="inner_product" title="wikilink">inner product</a> 

<math display="inline" id="Self-adjoint_operator:0">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mo>⋅</mo>
   <mo>,</mo>
   <mo>⋅</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-⋅</ci>
    <ci>normal-⋅</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle
  </annotation>
 </semantics>
</math>

 is an <a href="operator_(mathematics)" title="wikilink">operator</a> (a linear map <em>A</em> from <em>V</em> to itself) that is its own <a href="Adjoint_of_an_operator" title="wikilink">adjoint</a>

<math display="block" id="Self-adjoint_operator:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>A</mi>
     <mi>v</mi>
    </mrow>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi>w</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>v</ci>
     </apply>
     <ci>w</ci>
    </list>
    <list>
     <ci>v</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>w</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Av,w\rangle=\langle v,Aw\rangle
  </annotation>
 </semantics>
</math>

. If <em>V</em> is finite-dimensional with a given <a href="orthonormal_basis" title="wikilink">orthonormal basis</a>, this is equivalent to the condition that the <a href="matrix_(mathematics)" title="wikilink">matrix</a> of <em>A</em> is <a href="Hermitian_matrix" title="wikilink">Hermitian</a>, i.e., equal to its <a href="conjugate_transpose" title="wikilink">conjugate transpose</a> <em>A</em>*. By the finite-dimensional <a href="spectral_theorem" title="wikilink">spectral theorem</a>, <em>V</em> has an <a href="orthonormal_basis" title="wikilink">orthonormal basis</a> such that the matrix of <em>A</em> relative to this basis is a <a href="diagonal_matrix" title="wikilink">diagonal matrix</a> with entries in the <a href="real_number" title="wikilink">real numbers</a>. In this article, <a href="generalization" title="wikilink">generalizations</a> of this <a class="uri" href="concept" title="wikilink">concept</a> are considered to operators on <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> of arbitrary dimension.</p>

<p>Self-adjoint operators are used in <a href="functional_analysis" title="wikilink">functional analysis</a> and <a href="quantum_mechanics" title="wikilink">quantum mechanics</a>. In quantum mechanics their importance lies in the <a href="Dirac–von_Neumann_axioms" title="wikilink">Dirac–von Neumann formulation</a> of quantum mechanics, in which physical <a href="observable" title="wikilink">observables</a> such as position, <a class="uri" href="momentum" title="wikilink">momentum</a>, <a href="angular_momentum" title="wikilink">angular momentum</a> and <a href="spin_(physics)" title="wikilink">spin</a> are represented by self-adjoint operators on a Hilbert space. Of particular significance is the <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a></p>

<p>

<math display="block" id="Self-adjoint_operator:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mi>ψ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mi>ψ</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <msup>
        <mi mathvariant="normal">ℏ</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mn>2</mn>
        <mi>m</mi>
       </mrow>
      </mfrac>
      <mrow>
       <msup>
        <mo>∇</mo>
        <mn>2</mn>
       </msup>
       <mi>ψ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>ψ</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>ψ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-∇</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>ψ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H\psi=V\psi-\frac{\hbar^{2}}{2m}\nabla^{2}\psi,
  </annotation>
 </semantics>
</math>

</p>

<p>which as an observable corresponds to the total energy of a particle of mass <em>m</em> in a real potential field <em>V</em>. Differential operators are an important class of <a href="unbounded_operator" title="wikilink">unbounded operators</a>.</p>

<p>The structure of self-adjoint operators on infinite-dimensional Hilbert spaces essentially resembles the finite-dimensional case. That is to say, operators are self-adjoint if and only if they are unitarily equivalent to real-valued multiplication operators. With suitable modifications, this result can be extended to possibly unbounded operators on infinite-dimensional spaces. Since an everywhere-defined self-adjoint operator is necessarily bounded, one needs be more attentive to the domain issue in the unbounded case. This is explained below in more detail.</p>
<h2 id="symmetric-operators">Symmetric operators</h2>

<p>A <a href="linear_operator" title="wikilink">linear operator</a> <em>A</em> on a <a href="Hilbert_space" title="wikilink">Hilbert space</a> <em>H</em> is called <strong>symmetric</strong> if (<a href="bracket_notation" title="wikilink">bracket notation</a>)</p>

<p>

<math display="block" id="Self-adjoint_operator:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mi>x</mi>
    <mo>∣</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\lang</mtext>
   </merror>
   <mi>x</mi>
   <mo>∣</mo>
   <mi>A</mi>
   <mi>y</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <eq></eq>
    <mtext>\lang</mtext>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">A</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Ax\mid y\rangle=\lang x\mid Ay\rang
  </annotation>
 </semantics>
</math>

</p>

<p>for all elements <em>x</em> and <em>y</em> in the domain of <em>A</em>. Sometimes, such an operator is only called symmetric if it is also <a href="Densely_defined_operator" title="wikilink">densely defined</a>.</p>

<p>More generally, a partially defined linear operator <em>A</em> from a <a href="topological_vector_space" title="wikilink">topological vector space</a> <em>E</em> into its <a href="continuous_dual_space" title="wikilink">continuous dual space</a> <em>E</em><sup>∗</sup> is said to be <strong>symmetric</strong> if</p>

<p>

<math display="block" id="Self-adjoint_operator:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mi>x</mi>
    <mo>∣</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\lang</mtext>
   </merror>
   <mi>x</mi>
   <mo>∣</mo>
   <mi>A</mi>
   <mi>y</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\rang</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <eq></eq>
    <mtext>\lang</mtext>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">A</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <mtext>\rang</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Ax\mid y\rangle=\lang x\mid Ay\rang
  </annotation>
 </semantics>
</math>

 for all elements <em>x</em> and <em>y</em> in the domain of <em>A</em>. This usage is fairly standard in the functional analysis literature.</p>

<p>A symmetric <em>everywhere-defined</em> operator is <a class="uri" href="self-adjoint" title="wikilink">self-adjoint</a>. By the <a href="Hellinger-Toeplitz_theorem" title="wikilink">Hellinger-Toeplitz theorem</a>, a symmetric <em>everywhere-defined</em> operator is also <a href="operator_norm" title="wikilink">bounded</a>.</p>

<p>In the physics literature, the term <strong>Hermitian</strong> is used in place of the term symmetric. It should be noted, however, that the physics literature generally glosses over the distinction between operators that are merely symmetric and operators that are actually self-adjoint (as defined in the next section).</p>

<p>The previous definition agrees with the one for matrices given in the introduction to this article, if we take as <em>H</em> the Hilbert space <strong>C</strong><sup><em>n</em></sup> with the standard dot product and interpret a square matrix as a linear operator on this Hilbert space. It is however much more general as there are important infinite-dimensional Hilbert spaces.</p>

<p>The <a href="spectrum_of_an_operator" title="wikilink">spectrum</a> of any bounded symmetric operator is real; in particular all its eigenvalues are real, although a symmetric operator may have no eigenvalues.</p>

<p>A general version of the <a href="spectral_theorem" title="wikilink">spectral theorem</a> which also applies to bounded symmetric operators (see Reed and Simon, vol. 1, chapter VII, or other books cited) is stated below. If the set of eigenvalues for a symmetric operator is non empty, and the eigenvalues are nondegenerate, then it follows from the definition that eigenvectors corresponding to distinct eigenvalues are orthogonal. Contrary to what is sometimes claimed in introductory physics textbooks, it is possible for symmetric operators to have no eigenvalues at all (although the <a href="spectrum_(functional_analysis)" title="wikilink">spectrum</a> of any self-adjoint operator is nonempty). The example below illustrates a special case when an (unbounded) symmetric operator does have a set of eigenvectors which constitute a Hilbert space basis. The operator <em>A</em> below can be seen to have a <a href="compact_operator_on_Hilbert_space" title="wikilink">compact</a> inverse, meaning that the corresponding differential equation <em>Af</em> = <em>g</em> is solved by some integral, therefore compact, operator <em>G</em>. The compact symmetric operator <em>G</em> then has a countable family of eigenvectors which are complete in <mtpl></mtpl>. The same can then be said for <em>A</em>.</p>

<p><strong>Example</strong>. Consider the complex Hilbert space L<sup>2</sup>[0,1] and the <a href="differential_operator" title="wikilink">differential operator</a></p>

<p>

<math display="block" id="Self-adjoint_operator:5">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <msup>
      <mi>d</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>d</mi>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=-\frac{d^{2}}{dx^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>defined on the subspace consisting of all complex-valued infinitely <a class="uri" href="differentiable" title="wikilink">differentiable</a> functions <em>f</em> on [0, 1] with the boundary conditions <em>f</em>(0) = <em>f</em>(1) = 0. Then <a href="integration_by_parts" title="wikilink">integration by parts</a> shows that <em>A</em> is symmetric. Its eigenfunctions are the sinusoids</p>

<p>

<math display="block" id="Self-adjoint_operator:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>sin</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mi>π</mi>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <sin></sin>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>π</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{n}(x)=\sin(n\pi x)\qquad n=1,2,\ldots
  </annotation>
 </semantics>
</math>

</p>

<p>with the real eigenvalues <em>n</em><sup>2</sup>π<sup>2</sup>; the well-known orthogonality of the sine functions follows as a consequence of the property of being symmetric.</p>

<p>We consider generalizations of this operator below.</p>
<h2 id="self-adjoint-operators">Self-adjoint operators</h2>

<p>Given a densely defined linear operator <em>A</em> on <em>H</em>, its adjoint <em>A</em>* is defined as follows:</p>
<ul>
<li>The domain of <em>A</em>* consists of vectors <em>x</em> in <em>H</em> such that</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Self-adjoint_operator:7">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>∣</mo>
    <mrow>
     <mi>A</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">inner-product</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\mapsto\langle x\mid Ay\rangle
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>(which is a densely defined <em>linear</em> map) is a continuous linear functional. By continuity and density of the domain of <em>A</em>, it extends to a unique continuous linear functional on all of <em>H</em>.
</dd>
</dl>
<ul>
<li>By the <a href="Riesz_representation_theorem" title="wikilink">Riesz representation theorem</a> for linear functionals, if <em>x</em> is in the domain of <em>A</em>*, there is a unique vector <em>z</em> in <em>H</em> such that</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Self-adjoint_operator:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>∣</mo>
     <mrow>
      <mi>A</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>z</mi>
     <mo>∣</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>y</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo>dom</mo>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <ci>z</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>y</ci>
     </apply>
     <apply>
      <ci>dom</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x\mid Ay\rangle=\langle z\mid y\rangle\qquad\forall y\in\operatorname{%
dom}A
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>This vector <em>z</em> is defined to be <em>A</em>* <em>x</em>. It can be shown that the dependence of <em>z</em> on <em>x</em> is linear.
</dd>
</dl>

<p>Notice that it is the denseness of the domain of the operator, along with the uniqueness part of Riesz representation, that ensures the adjoint operator is well defined.</p>

<p>A result of Hellinger-Toeplitz type says that an operator having an everywhere-defined bounded adjoint is bounded.</p>

<p>The condition for a linear operator on a Hilbert space to be <em>self-adjoint</em> is stronger than to be <em>symmetric</em>. Although this distinction is technical, it is very important; the spectral theorem applies only to operators that are self-adjoint and not to operators that are merely symmetric. For an extensive discussion of the distinction, see Chapter 9 of Hall (2013).</p>

<p>For any densely defined operator <em>A</em> on Hilbert space one can define its adjoint operator <em>A</em>*. For a symmetric operator <em>A</em>, the domain of the operator <em>A</em>* contains the domain of the operator <em>A</em>, and the restriction of the operator <em>A</em>* on the domain of <em>A</em> coincides with the operator <em>A</em>, i.e. <em>A</em> ⊆ <em>A</em>*, in other words <em>A</em>* is extension of <em>A</em>. For a self-adjoint operator <em>A</em> the domain of <em>A</em>* is the same as the domain of <em>A</em>, and <em>A</em>=<em>A</em>*. See also <a href="Extensions_of_symmetric_operators" title="wikilink">Extensions of symmetric operators</a> and <a href="unbounded_operator" title="wikilink">unbounded operator</a>.</p>
<h3 id="geometric-interpretation">Geometric interpretation</h3>

<p>There is a useful <a class="uri" href="geometric" title="wikilink">geometric</a> way of looking at the adjoint of an operator <em>A</em> on <em>H</em> as follows: we consider the graph G(<em>A</em>) of <em>A</em> defined by</p>

<p>

<math display="block" id="Self-adjoint_operator:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>G</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ξ</mi>
      <mo>,</mo>
      <mrow>
       <mi>A</mi>
       <mi>ξ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mi>ξ</mi>
      <mo>∈</mo>
      <mrow>
       <mo>dom</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>⊆</mo>
    <mrow>
     <mi>H</mi>
     <mo>⊕</mo>
     <mi>H</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-G</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <interval closure="open">
       <ci>ξ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>ξ</ci>
       </apply>
      </interval>
      <apply>
       <in></in>
       <ci>ξ</ci>
       <apply>
        <ci>dom</ci>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>H</ci>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{G}(A)=\{(\xi,A\xi):\xi\in\operatorname{dom}(A)\}\subseteq H%
\oplus H.
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><strong>Theorem</strong>. Let J be the <a href="symplectic_matrix" title="wikilink">symplectic mapping</a>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Self-adjoint_operator:10">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>H</mi>
        <mo>⊕</mo>
        <mi>H</mi>
       </mrow>
       <mo>→</mo>
       <mrow>
        <mi>H</mi>
        <mo>⊕</mo>
        <mi>H</mi>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mo>J</mo>
       <mo>:</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ξ</mi>
         <mo>,</mo>
         <mi>η</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>↦</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mi>η</mi>
         </mrow>
         <mo>,</mo>
         <mi>ξ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>H</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>H</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <ci>normal-:</ci>
     <ci>normal-J</ci>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <interval closure="open">
       <ci>ξ</ci>
       <ci>η</ci>
      </interval>
      <interval closure="open">
       <apply>
        <minus></minus>
        <ci>η</ci>
       </apply>
       <ci>ξ</ci>
      </interval>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}H\oplus H\to H\oplus H\\
\operatorname{J}:(\xi,\eta)\mapsto(-\eta,\xi)\end{cases}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>Then the graph of <em>A</em>* is the <a href="orthogonal_complement" title="wikilink">orthogonal complement</a> of JG(<em>A</em>):
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Self-adjoint_operator:11">
 <semantics>
  <mrow>
   <mrow>
    <mo>G</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>A</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>J</mo>
      <mrow>
       <mo>G</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⟂</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mi>H</mi>
      <mo>⊕</mo>
      <mi>H</mi>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>A</mi>
         <mi>ξ</mi>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>ξ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mpadded width="+5.6pt">
       <mn>0</mn>
      </mpadded>
      <mrow>
       <mo>∀</mo>
       <mi>ξ</mi>
      </mrow>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mo>dom</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-G</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-J</ci>
       <apply>
        <ci>normal-G</ci>
        <ci>A</ci>
       </apply>
      </apply>
      <csymbol cd="latexml">perpendicular-to</csymbol>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
       <apply>
        <csymbol cd="latexml">direct-sum</csymbol>
        <ci>H</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="latexml">inner-product</csymbol>
         <interval closure="open">
          <ci>x</ci>
          <ci>y</ci>
         </interval>
         <interval closure="open">
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>A</ci>
            <ci>ξ</ci>
           </apply>
          </apply>
          <ci>ξ</ci>
         </interval>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">0</cn>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <ci>ξ</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <apply>
         <ci>dom</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{G}(A^{*})=(\operatorname{J}\operatorname{G}(A))^{\perp}=\{(x,y)%
\in H\oplus H:\langle(x,y)|(-A\xi,\xi)\rangle=0\;\;\forall\xi\in\operatorname{%
dom}(A)\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>A densely defined operator <em>A</em> is symmetric <a href="if_and_only_if" title="wikilink">if and only if</a> <em>A</em> ⊆ <em>A</em>*, where the subset notation <em>A</em> ⊆ <em>A</em>* is understood to mean G(<em>A</em>) ⊆ G(<em>A</em>*). An operator <em>A</em> is <strong>self-adjoint</strong> if and only if <em>A</em> = <em>A</em>*; that is, if and only if G(<em>A</em>) = G(<em>A</em>*).</p>

<p><strong>Example</strong>. Consider the complex Hilbert space <em>L</em><sup>2</sup>(<strong>R</strong>), and the operator which multiplies a given function by <em>x</em>:</p>

<p>

<math display="block" id="Self-adjoint_operator:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Af(x)=xf(x)
  </annotation>
 </semantics>
</math>

</p>

<p>The domain of <em>A</em> is the space of all <em>L</em><sup>2</sup> functions for which the right-hand-side is square-integrable. <em>A</em> is a symmetric operator without any eigenvalues and eigenfunctions. In fact it turns out that the operator is self-adjoint, as follows from the theory outlined below.</p>

<p>As we will see later, self-adjoint operators have very important spectral properties; they are in fact multiplication operators on general measure spaces.</p>
<h2 id="spectral-theorem">Spectral theorem</h2>

<p>Partially defined operators <em>A</em>, <em>B</em> on Hilbert spaces <em>H</em>, <em>K</em> are <strong>unitarily equivalent</strong> if and only if there is a <a href="unitary_transformation" title="wikilink">unitary transformation</a> <em>U</em> : <em>H</em> → <em>K</em> such that</p>
<ul>
<li><em>U</em> maps dom <em>A</em> <a href="bijective" title="wikilink">bijectively</a> onto dom <em>B</em>,</li>
</ul>
<ul>
<li>

<math display="inline" id="Self-adjoint_operator:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>B</mi>
      <mi>U</mi>
      <mi>ξ</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>U</mi>
      <mi>A</mi>
      <mi>ξ</mi>
     </mrow>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>ξ</mi>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mo>dom</mo>
      <mi>A</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>U</ci>
      <ci>ξ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>A</ci>
      <ci>ξ</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>ξ</ci>
     </apply>
     <apply>
      <ci>dom</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BU\xi=UA\xi,\qquad\forall\xi\in\operatorname{dom}A.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>A <a href="multiplication_operator" title="wikilink">multiplication operator</a> is defined as follows: Let (<em>X</em>, Σ, μ) be a countably additive <a href="measure_space" title="wikilink">measure space</a> and <em>f</em> a real-valued measurable function on <em>X</em>. An operator <em>T</em> of the form</p>

<p>

<math display="block" id="Self-adjoint_operator:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>T</mi>
      <mi>ψ</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>ψ</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
     <ci>ψ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [T\psi](x)=f(x)\psi(x)
  </annotation>
 </semantics>
</math>

</p>

<p>whose domain is the space of ψ for which the right-hand side above is in <em>L</em><sup>2</sup> is called a multiplication operator.</p>
<dl>
<dd><strong>Theorem.</strong> Any multiplication operator is a (densely defined) self-adjoint operator. Any self-adjoint operator is unitarily equivalent to a multiplication operator.
</dd>
</dl>

<p>This version of the spectral theorem for self-adjoint operators can be proved by reduction to the spectral theorem for unitary operators. This reduction uses the <em>Cayley transform</em> for self-adjoint operators which is defined in the next section. We might note that if T is multiplication by f, then the spectrum of T is just the <a href="essential_range" title="wikilink">essential range</a> of f.</p>
<h3 id="borel-functional-calculus">Borel functional calculus</h3>

<p>Given the representation of <em>T</em> as a multiplication operator, it is easy to characterize the <strong><a href="Borel_functional_calculus" title="wikilink">Borel functional calculus</a></strong>: If <em>h</em> is a bounded real-valued Borel function on <strong>R</strong>, then <em>h</em>(<em>T</em>) is the operator of multiplication by the composition <em>h</em> ∘ <em>f</em>. In order for this to be well-defined, we must show that it is the unique operation on bounded real-valued Borel functions satisfying a number of conditions.</p>
<h3 id="resolution-of-the-identity">Resolution of the identity</h3>

<p>It has been customary to introduce the following notation</p>

<p>

<math display="block" id="Self-adjoint_operator:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>E</mo>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mn>𝟏</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mo>,</mo>
      <mi>λ</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-E</ci>
      <ci>T</ci>
     </apply>
     <ci>λ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <interval closure="open-closed">
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
       <ci>λ</ci>
      </interval>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{E}_{T}(\lambda)=\mathbf{1}_{(-\infty,\lambda]}(T)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Self-adjoint_operator:16">
 <semantics>
  <msub>
   <mn>𝟏</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mo>,</mo>
    <mi>λ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <interval closure="open-closed">
     <apply>
      <minus></minus>
      <infinity></infinity>
     </apply>
     <ci>λ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{1}_{(-\infty,\lambda]}
  </annotation>
 </semantics>
</math>

 is the characteristic function of the interval 

<math display="inline" id="Self-adjoint_operator:17">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>-</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>,</mo>
   <mi>λ</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open-closed">
    <apply>
     <minus></minus>
     <infinity></infinity>
    </apply>
    <ci>λ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-\infty,\lambda]
  </annotation>
 </semantics>
</math>

. The family of projection operators E<sub><em>T</em></sub>(λ) is called <strong>resolution of the identity</strong> for <em>T</em>. Moreover, the following <a href="Stieltjes_integral" title="wikilink">Stieltjes integral</a> representation for <em>T</em> can be proved:</p>

<p>

<math display="block" id="Self-adjoint_operator:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mrow>
       <mo>+</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </msubsup>
     <mrow>
      <mi>λ</mi>
      <mi>d</mi>
      <mrow>
       <msub>
        <mo>E</mo>
        <mi>T</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>λ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>d</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-E</ci>
        <ci>T</ci>
       </apply>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\int_{-\infty}^{+\infty}\lambda d\operatorname{E}_{T}(\lambda).
  </annotation>
 </semantics>
</math>

</p>

<p>The definition of the operator integral above can be reduced to that that of a scalar valued Stieltjes integral using the weak operator topology. In more modern treatments however, this representation is usually avoided, since most technical problems can be dealt with by the functional calculus.</p>
<h3 id="formulation-in-the-physics-literature">Formulation in the physics literature</h3>

<p>In physics, particularly in quantum mechanics, the spectral theorem is expressed in a way which combines the spectral theorem as stated above and the <a href="Borel_functional_calculus" title="wikilink">Borel functional calculus</a> using <a href="Dirac_notation" title="wikilink">Dirac notation</a> as follows:</p>

<p>If <em>H</em> is self-adjoint and <em>f</em> is a <a href="Borel_function" title="wikilink">Borel function</a>,</p>

<p>

<math display="block" id="Self-adjoint_operator:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>d</mi>
     <mi>E</mi>
     <mrow>
      <mo fence="true">|</mo>
      <msub>
       <mi mathvariant="normal">Ψ</mi>
       <mi>E</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi mathvariant="normal">Ψ</mi>
       <mi>E</mi>
      </msub>
      <mo fence="true">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>H</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <ci>E</ci>
       </apply>
      </apply>
      <ci>f</ci>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(H)=\int dE\left|\Psi_{E}\rangle f(E)\langle\Psi_{E}\right|
  </annotation>
 </semantics>
</math>

</p>

<p>with</p>

<p>

<math display="block" id="Self-adjoint_operator:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi mathvariant="normal">Ψ</mi>
      <mi>E</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi mathvariant="normal">Ψ</mi>
      <mi>E</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ψ</ci>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ψ</ci>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H|\Psi_{E}\rangle=E|\Psi_{E}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>where the integral runs over the whole spectrum of <em>H</em>. The notation suggests that <em>H</em> is diagonalized by the eigenvectors Ψ<sub><em>E</em></sub>. Such a notation is purely <a href="Formal_calculation" title="wikilink">formal</a>. One can see the similarity between Dirac's notation and the previous section. The resolution of the identity (sometimes called projection valued measures) formally resembles the rank-1 projections 

<math display="inline" id="Self-adjoint_operator:21">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi mathvariant="normal">Ψ</mi>
     <mi>E</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi mathvariant="normal">Ψ</mi>
     <mi>E</mi>
    </msub>
    <mo fence="true" stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ψ</ci>
      <ci>E</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">bra</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ψ</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Psi_{E}\rangle\langle\Psi_{E}|
  </annotation>
 </semantics>
</math>

. In the Dirac notation, (projective) measurements are described via <a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a> and <a class="uri" href="eigenstates" title="wikilink">eigenstates</a>, both purely formal objects. As one would expect, this does not survive passage to the resolution of the identity. In the latter formulation, measurements are described using the <a href="spectral_measure" title="wikilink">spectral measure</a> of 

<math display="inline" id="Self-adjoint_operator:22">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi mathvariant="normal">Ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>normal-Ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Psi\rangle
  </annotation>
 </semantics>
</math>

, if the system is prepared in 

<math display="inline" id="Self-adjoint_operator:23">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi mathvariant="normal">Ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>normal-Ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Psi\rangle
  </annotation>
 </semantics>
</math>

 prior to the measurement. Alternatively, if one would like to preserve the notion of eigenstates and make it rigorous, rather than merely formal, one can replace the state space by a suitable <a href="rigged_Hilbert_space" title="wikilink">rigged Hilbert space</a>.</p>

<p>If , the theorem is referred to as resolution of unity:</p>

<p>

<math display="block" id="Self-adjoint_operator:24">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>d</mi>
     <mi>E</mi>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi mathvariant="normal">Ψ</mi>
       <mi>E</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi mathvariant="normal">Ψ</mi>
       <mi>E</mi>
      </msub>
      <mo fence="true" stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <ci>E</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=\int dE|\Psi_{E}\rangle\langle\Psi_{E}|
  </annotation>
 </semantics>
</math>

</p>

<p>In the case 

<math display="inline" id="Self-adjoint_operator:25">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mtext>eff</mtext>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>H</mi>
    <mo>-</mo>
    <mrow>
     <mi>i</mi>
     <mi mathvariant="normal">Γ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <mtext>eff</mtext>
    </apply>
    <apply>
     <minus></minus>
     <ci>H</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>normal-Γ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\text{eff}}=H-i\Gamma
  </annotation>
 </semantics>
</math>

 is the sum of an Hermitian <em>H</em> and a skew-Hermitian (see <a href="skew-Hermitian_matrix" title="wikilink">skew-Hermitian matrix</a>) operator 

<math display="inline" id="Self-adjoint_operator:26">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mi>i</mi>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -i\Gamma
  </annotation>
 </semantics>
</math>

, one defines the <a href="biorthogonal_system" title="wikilink">biorthogonal</a> basis set</p>

<p>

<math display="block" id="Self-adjoint_operator:27">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>H</mi>
     <mtext>eff</mtext>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msubsup>
      <mi mathvariant="normal">Ψ</mi>
      <mi>E</mi>
      <mo>*</mo>
     </msubsup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>E</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msubsup>
      <mi mathvariant="normal">Ψ</mi>
      <mi>E</mi>
      <mo>*</mo>
     </msubsup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <times></times>
      </apply>
      <mtext>eff</mtext>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <ci>E</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <ci>E</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{*}_{\text{eff}}|\Psi_{E}^{*}\rangle=E^{*}|\Psi_{E}^{*}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>and write the spectral theorem as:</p>

<p>

<math display="block" id="Self-adjoint_operator:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>H</mi>
      <mtext>eff</mtext>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>d</mi>
     <mi>E</mi>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi mathvariant="normal">Ψ</mi>
       <mi>E</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msubsup>
       <mi mathvariant="normal">Ψ</mi>
       <mi>E</mi>
       <mo>*</mo>
      </msubsup>
      <mo fence="true" stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <mtext>eff</mtext>
     </apply>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <ci>E</ci>
       </apply>
      </apply>
      <ci>f</ci>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">bra</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Ψ</ci>
         <ci>E</ci>
        </apply>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(H_{\text{eff}})=\int dE|\Psi_{E}\rangle f(E)\langle\Psi_{E}^{*}|
  </annotation>
 </semantics>
</math>

</p>

<p>(See <a href="Feshbach–Fano_partitioning" title="wikilink">Feshbach–Fano partitioning</a> method for the context where such operators appear in <a href="scattering_theory" title="wikilink">scattering theory</a>).</p>
<h2 id="extensions-of-symmetric-operators">Extensions of symmetric operators</h2>

<p>The following question arises in several contexts: if an operator <em>A</em> on the Hilbert space <em>H</em> is symmetric, when does it have self-adjoint extensions? One answer is provided by the <strong><a href="Cayley_transform" title="wikilink">Cayley transform</a></strong> of a self-adjoint operator and the deficiency indices. (We should note here that it is often of technical convenience to deal with <a href="closed_operator" title="wikilink">closed operators</a>. In the symmetric case, the closedness requirement poses no obstacles, since it is known that all symmetric operators are <a href="closable_operator" title="wikilink">closable</a>.)</p>
<dl>
<dd><strong>Theorem</strong>. Suppose <em>A</em> is a symmetric operator. Then there is a unique partially defined linear operator

<p>

<math display="block" id="Self-adjoint_operator:29">
 <semantics>
  <mrow>
   <mrow>
    <mo>W</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo>ran</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>+</mo>
       <mi>i</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo>ran</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <ci>normal-W</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <ci>ran</ci>
      <apply>
       <plus></plus>
       <ci>A</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <ci>ran</ci>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{W}(A):\operatorname{ran}(A+i)\to\operatorname{ran}(A-i)
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>such that

<p>

<math display="block" id="Self-adjoint_operator:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>W</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mi>x</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>i</mi>
         <mi>x</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>x</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>i</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mrow>
      <mo>dom</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <ci>normal-W</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <apply>
      <ci>dom</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{W}(A)(Ax+ix)=Ax-ix,\qquad x\in\operatorname{dom}(A).
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>Here, <em>ran</em> and <em>dom</em> denote the <a href="image_(mathematics)" title="wikilink">image</a> (in other words, range) and the <a href="domain_(mathematics)" title="wikilink">domain</a>, respectively. W(<em>A</em>) is <a href="isometry" title="wikilink">isometric</a> on its domain. Moreover, the range of 1 − W(<em>A</em>) is <a href="dense_set" title="wikilink">dense</a> in <em>H</em>.</p>

<p>Conversely, given any partially defined operator <em>U</em> which is isometric on its domain (which is not necessarily closed) and such that 1 − <em>U</em> is dense, there is a (unique) operator S(<em>U</em>)</p>

<p>

<math display="block" id="Self-adjoint_operator:31">
 <semantics>
  <mrow>
   <mrow>
    <mo>S</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo>ran</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>U</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo>ran</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>U</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <ci>normal-S</ci>
     <ci>U</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <ci>ran</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>U</ci>
      </apply>
     </apply>
     <apply>
      <ci>ran</ci>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>U</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{S}(U):\operatorname{ran}(1-U)\to\operatorname{ran}(1+U)
  </annotation>
 </semantics>
</math>

</p>

<p>such that</p>

<p>

<math display="block" id="Self-adjoint_operator:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>S</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>U</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mrow>
         <mi>U</mi>
         <mi>x</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>i</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mrow>
         <mi>U</mi>
         <mi>x</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mrow>
      <mo>dom</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>U</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <ci>normal-S</ci>
       <ci>U</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>U</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>U</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <apply>
      <ci>dom</ci>
      <ci>U</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{S}(U)(x-Ux)=i(x+Ux)\qquad x\in\operatorname{dom}(U).
  </annotation>
 </semantics>
</math>

</p>

<p>The operator S(<em>U</em>) is densely defined and symmetric.</p>

<p>The mappings W and S are inverses of each other.</p>

<p>The mapping W is called the <strong>Cayley transform</strong>. It associates a <a href="partial_isometry" title="wikilink">partially defined isometry</a> to any symmetric densely defined operator. Note that the mappings W and S are <a href="monotone_convergence_theorem" title="wikilink">monotone</a>: This means that if <em>B</em> is a symmetric operator that extends the densely defined symmetric operator <em>A</em>, then W(<em>B</em>) extends W(<em>A</em>), and similarly for S.</p>
<dl>
<dd><strong>Theorem</strong>. A necessary and sufficient condition for <em>A</em> to be self-adjoint is that its Cayley transform W(<em>A</em>) be unitary.
</dd>
</dl>

<p>This immediately gives us a necessary and sufficient condition for <em>A</em> to have a self-adjoint extension, as follows:</p>
<dl>
<dd><strong>Theorem</strong>. A necessary and sufficient condition for <em>A</em> to have a self-adjoint extension is that W(<em>A</em>) have a unitary extension.
</dd>
</dl>

<p>A partially defined isometric operator <em>V</em> on a Hilbert space <em>H</em> has a unique isometric extension to the norm closure of dom(<em>V</em>). A partially defined isometric operator with closed domain is called a <a href="partial_isometry" title="wikilink">partial isometry</a>.</p>

<p>Given a partial isometry <em>V</em>, the <strong>deficiency indices</strong> of <em>V</em> are defined as the dimension of the <a href="orthogonal_complement" title="wikilink">orthogonal complements</a> of the domain and range:</p>

<p>

<math display="block" id="Self-adjoint_operator:33">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mo>+</mo>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo rspace="7.5pt">dim</mo>
   <mo>dom</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⟂</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <plus></plus>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <ci>dim</ci>
    <ci>dom</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{+}(V)=\operatorname{dim}\ \operatorname{dom}(V)^{\perp}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Self-adjoint_operator:34">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mo>-</mo>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo rspace="7.5pt">dim</mo>
   <mo>ran</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⟂</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <minus></minus>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <ci>dim</ci>
    <ci>ran</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{-}(V)=\operatorname{dim}\ \operatorname{ran}(V)^{\perp}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><strong>Theorem</strong>. A partial isometry <em>V</em> has a unitary extension if and only if the deficiency indices are identical. Moreover, <em>V</em> has a <em>unique</em> unitary extension if and only if the both deficiency indices are zero.
</dd>
</dl>

<p>We see that there is a bijection between symmetric extensions of an operator and isometric extensions of its Cayley transform. An operator which has a unique self-adjoint extension is said to be <strong>essentially self-adjoint</strong>. Such operators have a well-defined <a href="Borel_functional_calculus" title="wikilink">Borel functional calculus</a>. Symmetric operators which are not essentially self-adjoint may still have a <a href="canonical_form" title="wikilink">canonical</a> self-adjoint extension. Such is the case for <em>non-negative</em> symmetric operators (or more generally, operators which are bounded below). These operators always have a canonically defined <a href="Friedrichs_extension" title="wikilink">Friedrichs extension</a> and for these operators we can define a canonical functional calculus. Many operators that occur in analysis are bounded below (such as the negative of the <a class="uri" href="Laplacian" title="wikilink">Laplacian</a> operator), so the issue of essential adjointness for these operators is less critical.</p>
<h3 id="self-adjoint-extensions-in-quantum-mechanics">Self-adjoint extensions in quantum mechanics</h3>

<p>In quantum mechanics, observables correspond to self-adjoint operators. By <a href="Stone's_theorem_on_one-parameter_unitary_groups" title="wikilink">Stone's theorem on one-parameter unitary groups</a>, self-adjoint operators are precisely the infinitesimal generators of unitary groups of <a href="time_evolution" title="wikilink">time evolution</a> operators. However, many physical problems are formulated as a time-evolution equation involving differential operators for which the Hamiltonian is only symmetric. In such cases, either the Hamiltonian is essentially self-adjoint, in which case the physical problem has unique solutions or one attempts to find self-adjoint extensions of the Hamiltonian corresponding to different types of boundary conditions or conditions at infinity.</p>

<p><strong>Example.</strong> The one-dimensional Schrödinger operator with the potential 

<math display="inline" id="Self-adjoint_operator:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>α</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <abs></abs>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x)=-(1+|x|)^{\alpha}
  </annotation>
 </semantics>
</math>

, defined initially on smooth compactly supported functions, is essentially self-adjoint (that is, has a self-adjoint closure) for 

<math display="inline" id="Self-adjoint_operator:36">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>></mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>α</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   α>2
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Example.</strong> There is no self-adjoint momentum operator <em>p</em> for a particle moving on a half-line. Nevertheless, the Hamiltonian 

<math display="block" id="Self-adjoint_operator:38">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mo>±</mo>
   </msub>
   <mo>=</mo>
   <mo>ran</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>±</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⟂</mo>
   </msup>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <csymbol cd="latexml">plus-or-minus</csymbol>
    </apply>
    <eq></eq>
    <ci>ran</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <csymbol cd="unknown">i</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{\pm}=\operatorname{ran}(A\pm i)^{\perp},
  </annotation>
 </semantics>
</math>

 of a "free" particle on a half-line has several self-adjoint extensions corresponding to different types of boundary conditions. Physically, these boundary conditions are related to reflections of the particle at the origin (see Reed and Simon, vol.2).</p>
<h2 id="von-neumanns-formulas">Von Neumann's formulas</h2>

<p>Suppose <em>A</em> is symmetric densely defined. Then any symmetric extension of <em>A</em> is a restriction of <em>A</em>*. Indeed, if <em>B</em> is symmetric, then <em>A</em> ⊆ <em>B</em> implies <em>B</em>* ⊆ <em>A</em>*.</p>
<dl>
<dd><strong>Theorem.</strong> Suppose <em>A</em> is a densely defined symmetric operator. Let

<p>

<math display="block" id="Self-adjoint_operator:39">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>N</mi>
     <mo>±</mo>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>ker</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mo>*</mo>
       </msup>
       <mo>∓</mo>
       <mi>i</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <csymbol cd="latexml">plus-or-minus</csymbol>
    </apply>
    <apply>
     <ci>ker</ci>
     <apply>
      <csymbol cd="latexml">minus-or-plus</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <times></times>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{\pm}=\operatorname{ker}(A^{*}\mp i),
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>Then

<p>

<math display="block" id="Self-adjoint_operator:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>dom</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>A</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>dom</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>A</mi>
        <mo>¯</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊕</mo>
     <msub>
      <mi>N</mi>
      <mo>+</mo>
     </msub>
     <mo>⊕</mo>
     <msub>
      <mi>N</mi>
      <mo>-</mo>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>dom</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <ci>dom</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <minus></minus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dom}(A^{*})=\operatorname{dom}(\overline{A})\oplus N_{+}\oplus N%
_{-},
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>and

<p>

<math display="block" id="Self-adjoint_operator:41">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>ξ</mi>
     <mo stretchy="false">|</mo>
     <mi>η</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>graph</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>ξ</mi>
     <mo stretchy="false">|</mo>
     <mi>η</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <msup>
       <mi>A</mi>
       <mo>*</mo>
      </msup>
      <mi>ξ</mi>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msup>
       <mi>A</mi>
       <mo>*</mo>
      </msup>
      <mi>η</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <ci>ξ</ci>
      <ci>η</ci>
     </apply>
     <ci>graph</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <ci>ξ</ci>
      <ci>η</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <ci>ξ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <ci>η</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\xi|\eta\rangle_{\mathrm{graph}}=\langle\xi|\eta\rangle+\langle A^{*}%
\xi|A^{*}\eta\rangle
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>where the decomposition is orthogonal relative to the graph inner product of dom(<em>A</em>*):

<p>

<math display="block" id="Self-adjoint_operator:42">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>:</mo>
   <mrow>
    <mi>ϕ</mi>
    <mo>↦</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>i</mi>
     </mfrac>
     <msup>
      <mi>ϕ</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>D</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>ϕ</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ϕ</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D:\phi\mapsto\frac{1}{i}\phi^{\prime}
  </annotation>
 </semantics>
</math>

.</p>
</dd>
</dl>

<p>These are referred to as von Neumann's formulas in the Akhiezer and Glazman reference.</p>
<h2 id="examples">Examples</h2>

<p>We first consider the differential operator</p>

<p>

<math display="block" id="Self-adjoint_operator:43">
 <semantics>
  <mrow>
   <msup>
    <mi>u</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>i</mi>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>u</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{\prime}=iu
  </annotation>
 </semantics>
</math>

</p>

<p>defined on the space of complex-valued C<sup>∞</sup> functions on [0,1] vanishing near 0 and 1. <em>D</em> is a symmetric operator as can be shown by <a href="integration_by_parts" title="wikilink">integration by parts</a>. The spaces <em>N</em><sub>+</sub>, <em>N</em><sub>−</sub> are given respectively by the <a href="distribution_(mathematics)" title="wikilink">distributional</a> solutions to the equation</p>

<p>

<math display="block" id="Self-adjoint_operator:44">
 <semantics>
  <mrow>
   <msup>
    <mi>u</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>i</mi>
     <mi>u</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>u</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>u</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{\prime}=-iu
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Self-adjoint_operator:45">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mo>±</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>u</mi>
     <mo>∈</mo>
     <mrow>
      <msup>
       <mi>L</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>P</mi>
       <mo>dist</mo>
      </msub>
      <mi>u</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>±</mo>
      <mrow>
       <mi>i</mi>
       <mi>u</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <csymbol cd="latexml">plus-or-minus</csymbol>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>u</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>dist</ci>
       </apply>
       <ci>u</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{\pm}=\left\{u\in L^{2}(M):P_{\operatorname{dist}}u=\pm iu\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>which are in <em>L</em><sup>2</sup>[0, 1]. One can show that each one of these solution spaces is 1-dimensional, generated by the functions <em>x</em> → <em>e</em><sup><em>ix</em></sup> and <em>x</em> → <em>e</em><sup>−<em>ix</em></sup> respectively. This shows that <em>D</em> is not essentially self-adjoint, but does have self-adjoint extensions. These self-adjoint extensions are parametrized by the space of unitary mappings <em>N</em><sub>+</sub> → <em>N</em><sub>−</sub>, which in this case happens to be the unit circle <strong>T</strong>.</p>

<p>This simple example illustrates a general fact about self-adjoint extensions of symmetric differential operators <em>P</em> on an open set <em>M</em>. They are determined by the unitary maps between the eigenvalue spaces</p>

<p>

<math display="block" id="Self-adjoint_operator:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>α</mi>
    </munder>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>α</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mi>α</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>α</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\vec{x})=\sum_{\alpha}c_{\alpha}x^{\alpha}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>P</em><sub>dist</sub> is the distributional extension of <em>P</em>.</p>

<p>We next give the example of differential operators with <a href="constant_coefficient" title="wikilink">constant coefficients</a>. Let</p>

<p>

<math display="block" id="Self-adjoint_operator:47">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>α</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>α</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=(\alpha_{1},\alpha_{2},\ldots,\alpha_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>be a polynomial on <strong>R</strong><sup><em>n</em></sup> with <em>real</em> coefficients, where α ranges over a (finite) set of <a href="multi-index" title="wikilink">multi-indices</a>. Thus</p>

<p>

<math display="block" id="Self-adjoint_operator:48">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mi>α</mi>
    </msup>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>x</mi>
      <mn>1</mn>
      <msub>
       <mi>α</mi>
       <mn>1</mn>
      </msub>
     </msubsup>
     <msubsup>
      <mi>x</mi>
      <mn>2</mn>
      <msub>
       <mi>α</mi>
       <mn>2</mn>
      </msub>
     </msubsup>
     <mi mathvariant="normal">⋯</mi>
     <msubsup>
      <mi>x</mi>
      <mi>n</mi>
      <msub>
       <mi>α</mi>
       <mi>n</mi>
      </msub>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\alpha}=x_{1}^{\alpha_{1}}x_{2}^{\alpha_{2}}\cdots x_{n}^{\alpha_{n}}.
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Self-adjoint_operator:49">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>D</mi>
     <mi>α</mi>
    </msup>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>α</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </msup>
     </mfrac>
     <mrow>
      <mrow>
       <msubsup>
        <mo>∂</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <msub>
         <mi>α</mi>
         <mn>1</mn>
        </msub>
       </msubsup>
       <msubsup>
        <mo>∂</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <msub>
         <mi>α</mi>
         <mn>2</mn>
        </msub>
       </msubsup>
      </mrow>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
     <msubsup>
      <mo>∂</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>α</mi>
       <mi>n</mi>
      </msub>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>i</ci>
       <apply>
        <abs></abs>
        <ci>α</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{\alpha}=\frac{1}{i^{|\alpha|}}\partial_{x_{1}}^{\alpha_{1}}\partial_{x_{2}}%
^{\alpha_{2}}\cdots\partial_{x_{n}}^{\alpha_{n}}.
  </annotation>
 </semantics>
</math>

</p>

<p>We also use the notation</p>

<p>

<math display="block" id="Self-adjoint_operator:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>D</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ϕ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>α</mi>
    </munder>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>α</mi>
     </msub>
     <mrow>
      <msup>
       <mo>D</mo>
       <mi>α</mi>
      </msup>
      <mi>ϕ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>normal-D</ci>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>α</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-D</ci>
        <ci>α</ci>
       </apply>
       <ci>ϕ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\operatorname{D})\phi=\sum_{\alpha}c_{\alpha}\operatorname{D}^{\alpha}\phi
  </annotation>
 </semantics>
</math>

</p>

<p>Then the operator <em>P</em>(D) defined on the space of infinitely differentiable functions of compact support on <strong>R</strong><sup><em>n</em></sup> by</p>

<p>

<math display="block" id="Self-adjoint_operator:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>α</mi>
    </munder>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>α</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msup>
        <mi>D</mi>
        <mi>α</mi>
       </msup>
       <mi>ϕ</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>α</ci>
      </apply>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>D</ci>
         <ci>α</ci>
        </apply>
        <ci>ϕ</ci>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\phi(x)=\sum_{\alpha}a_{\alpha}(x)[D^{\alpha}\phi](x)
  </annotation>
 </semantics>
</math>

</p>

<p>is essentially self-adjoint on <em>L</em><sup>2</sup>(<strong>R</strong><sup><em>n</em></sup>).</p>
<dl>
<dd><strong>Theorem</strong>. Let <em>P</em> a polynomial function on <strong>R</strong><sup><em>n</em></sup> with real coefficients, <strong>F</strong> the Fourier transform considered as a unitary map <em>L</em><sup>2</sup>(<strong>R</strong><sup><em>n</em></sup>) → <em>L</em><sup>2</sup>(<strong>R</strong><sup><em>n</em></sup>). Then <strong>F</strong>*<em>P</em>(D)<strong>F</strong> is essentially self-adjoint and its unique self-adjoint extension is the operator of multiplication by the function <em>P</em>.
</dd>
</dl>

<p>More generally, consider linear differential operators acting on infinitely differentiable complex-valued functions of compact support. If <em>M</em> is an open subset of <strong>R</strong><sup><em>n</em></sup></p>

<p>

<math display="block" id="Self-adjoint_operator:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>C</mi>
      <mn>0</mn>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msubsup>
      <mi>C</mi>
      <mn>0</mn>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <cn type="integer">0</cn>
      </apply>
      <infinity></infinity>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <cn type="integer">0</cn>
      </apply>
      <infinity></infinity>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{0}^{\infty}(M)\to C_{0}^{\infty}(M).
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>a</em><sub>α</sub> are (not necessarily constant) infinitely differentiable functions. <em>P</em> is a linear operator</p>

<p>

<math display="block" id="Self-adjoint_operator:53">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mrow>
      <mi></mi>
      <mo>*</mo>
      <mi>form</mi>
     </mrow>
    </msup>
    <mi>ϕ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>α</mi>
    </munder>
    <mrow>
     <msup>
      <mi>D</mi>
      <mi>α</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <msub>
         <mi>a</mi>
         <mi>α</mi>
        </msub>
        <mo>¯</mo>
       </mover>
       <mi>ϕ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <csymbol cd="latexml">absent</csymbol>
       <ci>form</ci>
      </apply>
     </apply>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <ci>α</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-¯</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>α</ci>
        </apply>
       </apply>
       <ci>ϕ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\mathrm{*form}}\phi=\sum_{\alpha}D^{\alpha}(\overline{a_{\alpha}}\phi)
  </annotation>
 </semantics>
</math>

</p>

<p>Corresponding to <em>P</em> there is another differential operator, the <strong><a href="formal_adjoint" title="wikilink">formal adjoint</a></strong> of <em>P</em></p>

<p>

<math display="block" id="Self-adjoint_operator:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>dom</mo>
     <msup>
      <mi>P</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mi>u</mi>
      <mo>∈</mo>
      <mrow>
       <msup>
        <mi>L</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>P</mi>
        <mrow>
         <mi></mi>
         <mo>*</mo>
         <mi>form</mi>
        </mrow>
       </msup>
       <mi>u</mi>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <msup>
        <mi>L</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>dom</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>u</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <apply>
         <times></times>
         <csymbol cd="latexml">absent</csymbol>
         <ci>form</ci>
        </apply>
       </apply>
       <ci>u</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dom}P^{*}=\left\{u\in L^{2}(M):P^{\mathrm{*form}}u\in L^{2}(M)%
\right\}.
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><strong>Theorem</strong>. The operator theoretic adjoint <em>P</em>* of <em>P</em> is a restriction of the distributional extension of the formal adjoint. Specifically:

<p>

<math display="block" id="Self-adjoint_operator:55">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>L</mi>
     <mi>μ</mi>
     <mn>2</mn>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐑</mi>
     <mo>,</mo>
     <msub>
      <mi>𝐇</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>ψ</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>𝐑</mi>
      <mo>→</mo>
      <msub>
       <mi>𝐇</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mi>ψ</mi>
       <mtext>measurable and</mtext>
       <mrow>
        <msub>
         <mo largeop="true" symmetric="true">∫</mo>
         <mi>𝐑</mi>
        </msub>
        <mrow>
         <msup>
          <mrow>
           <mo>∥</mo>
           <mrow>
            <mi>ψ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>t</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>∥</mo>
          </mrow>
          <mn>2</mn>
         </msup>
         <mi>d</mi>
         <mi>μ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo><</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>μ</ci>
     </apply>
     <interval closure="open">
      <ci>𝐑</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐇</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>ψ</ci>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>𝐑</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐇</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <lt></lt>
       <apply>
        <times></times>
        <ci>ψ</ci>
        <mtext>measurable and</mtext>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <int></int>
          <ci>𝐑</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="latexml">norm</csymbol>
            <apply>
             <times></times>
             <ci>ψ</ci>
             <ci>t</ci>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <ci>d</ci>
          <ci>μ</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}_{\mu}(\mathbf{R},\mathbf{H}_{n})=\{\psi:\mathbf{R}\to\mathbf{H}_{n}:\psi%
\mbox{ measurable and }\int_{\mathbf{R}}\|\psi(t)\|^{2}d\mu(t)<\infty\}
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>
<h2 id="spectral-multiplicity-theory">Spectral multiplicity theory</h2>

<p>The multiplication representation of a self-adjoint operator, though extremely useful, is not a canonical representation. This suggests that it is not easy to extract from this representation a criterion to determine when self-adjoint operators <em>A</em> and <em>B</em> are unitarily equivalent. The finest grained representation which we now discuss involves spectral multiplicity. This circle of results is called the <em><a href="Hans_Hahn_(mathematician)" title="wikilink">Hahn</a>-<a href="Ernst_Hellinger" title="wikilink">Hellinger</a> theory of spectral multiplicity</em>.</p>

<p>We first define <em>uniform multiplicity</em>:</p>

<p><strong>Definition</strong>. A self-adjoint operator <em>A</em> has uniform multiplicity <em>n</em> where <em>n</em> is such that 1 ≤ <em>n</em> ≤ ω if and only if <em>A</em> is unitarily equivalent to the operator M<sub><em>f</em></sub> of multiplication by the function <em>f</em>(λ) = λ on</p>

<p>

<math display="block" id="Self-adjoint_operator:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>𝐑</mi>
     </msub>
     <mrow>
      <mpadded width="+5pt">
       <msup>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>λ</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mpadded>
      <mpadded width="+1.7pt">
       <msup>
        <mrow>
         <mo>∥</mo>
         <mrow>
          <mi>ψ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>λ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mpadded>
      <mi>d</mi>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>𝐑</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <ci>λ</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <times></times>
         <ci>ψ</ci>
         <ci>λ</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>d</ci>
      <ci>μ</ci>
      <ci>λ</ci>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\mathbf{R}}|\lambda|^{2}\ \|\psi(\lambda)\|^{2}\,d\mu(\lambda)<\infty.
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>H</strong><sub><em>n</em></sub> is a Hilbert space of dimension <em>n</em>. The domain of M<sub><em>f</em></sub> consists of vector-valued functions ψ on <strong>R</strong> such that</p>

<p>

<math display="block" id="Self-adjoint_operator:57">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>μ</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>≤</mo>
    <mi mathvariant="normal">ℓ</mi>
    <mo>≤</mo>
    <mi>ω</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>normal-ℓ</ci>
     </apply>
    </set>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <cn type="integer">1</cn>
      <ci>normal-ℓ</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\mu_{\ell}\}_{1\leq\ell\leq\omega}
  </annotation>
 </semantics>
</math>

</p>

<p>Non-negative countably additive measures μ, ν are <strong>mutually singular</strong> if and only if they are supported on disjoint Borel sets.</p>
<dl>
<dd><strong>Theorem</strong>. Let <em>A</em> be a self-adjoint operator on a <em>separable</em> Hilbert space <em>H</em>. Then there is an ω sequence of countably additive finite measures on <strong>R</strong> (some of which may be identically 0)

<p>

<math display="block" id="Self-adjoint_operator:58">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mrow>
      <mn>1</mn>
      <mo>≤</mo>
      <mi mathvariant="normal">ℓ</mi>
      <mo>≤</mo>
      <mi>ω</mi>
     </mrow>
    </munder>
    <mrow>
     <msubsup>
      <mi>L</mi>
      <msub>
       <mi>μ</mi>
       <mi mathvariant="normal">ℓ</mi>
      </msub>
      <mn>2</mn>
     </msubsup>
     <mrow>
      <mo>(</mo>
      <mi>𝐑</mi>
      <mo>,</mo>
      <msub>
       <mi>𝐇</mi>
       <mi mathvariant="normal">ℓ</mi>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <cn type="integer">1</cn>
       <ci>normal-ℓ</ci>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>𝐑</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐇</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigoplus_{1\leq\ell\leq\omega}L^{2}_{\mu_{\ell}}\left(\mathbf{R},\mathbf{H}_{%
\ell}\right).
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>such that the measures are pairwise singular and <em>A</em> is unitarily equivalent to the operator of multiplication by the function <em>f</em>(λ) = λ on

<p>

<math display="block" id="Self-adjoint_operator:59">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>𝐑</mi>
     <mo>⊕</mo>
    </msubsup>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>x</mi>
     </msub>
     <mi>d</mi>
     <mi>μ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>𝐑</ci>
     </apply>
     <csymbol cd="latexml">direct-sum</csymbol>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>x</ci>
     </apply>
     <ci>d</ci>
     <ci>μ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\mathbf{R}}^{\oplus}H_{x}d\mu(x).
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>This representation is unique in the following sense: For any two such representations of the same <em>A</em>, the corresponding measures are equivalent in the sense that they have the same sets of measure 0.</p>

<p>The spectral multiplicity theorem can be reformulated using the language of <a href="direct_integral" title="wikilink">direct integrals</a> of Hilbert spaces:</p>
<dl>
<dd><strong>Theorem</strong>. Any self-adjoint operator on a separable Hilbert space is unitarily equivalent to multiplication by the function λ ↦ λ on

<p>

<math display="block" id="Self-adjoint_operator:60">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msubsup>
      <mo>∂</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Δ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=\sum_{i=1}^{n}\partial_{x_{i}}^{2}.
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>The measure equivalence class of μ (or equivalently its sets of measure 0) is uniquely determined and the measurable family {<em>H<sub>x</sub></em>}<sub><em>x</em></sub> is determined almost everywhere with respect to μ.</p>
<h3 id="example-structure-of-the-laplacian">Example: structure of the Laplacian</h3>

<p>The Laplacian on <strong>R</strong><sup><em>n</em></sup> is the operator</p>

<p>

<math display="block" id="Self-adjoint_operator:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">Δ</mi>
    </mrow>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <ci>normal-Δ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\Delta+|x|^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>As remarked above, the Laplacian is diagonalized by the Fourier transform. Actually it is more natural to consider the <em>negative</em> of the Laplacian −Δ since as an operator it is non-negative; (see <a href="elliptic_operator" title="wikilink">elliptic operator</a>).</p>

<p><strong>Theorem</strong>. If <em>n</em>=1, then −Δ has uniform multiplicity <strong>mult</strong>=2, otherwise −Δ has uniform multiplicity <strong>mult</strong>=ω. Moreover, the measure μ<sub><strong>mult</strong></sub> is Borel measure on [0, ∞).</p>
<h2 id="pure-point-spectrum">Pure point spectrum</h2>

<p>A self-adjoint operator <em>A</em> on <em>H</em> has pure point spectrum if and only if <em>H</em> has an orthonormal basis {<em>e<sub>i</sub></em>}<sub><em>i</em> ∈ I</sub> consisting of eigenvectors for <em>A</em>.</p>

<p><strong>Example</strong>. The Hamiltonian for the harmonic oscillator has a quadratic potential <em>V</em>, that is</p>

<p><span class="LaTeX">$$-\Delta  + |x|^2.$$</span></p>

<p>This Hamiltonian has pure point spectrum; this is typical for bound state <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonians</a> in quantum mechanics. As was pointed out in a previous example, a sufficient condition that an unbounded symmetric operator has eigenvectors which form a Hilbert space basis is that it has a compact inverse.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Compact_operator_on_Hilbert_space" title="wikilink">Compact operator on Hilbert space</a></li>
<li><a href="Theoretical_and_experimental_justification_for_the_Schrödinger_equation" title="wikilink">Theoretical and experimental justification for the Schrödinger equation</a></li>
<li><a href="Unbounded_operator" title="wikilink">Unbounded operator</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a> <a href="Category:Hilbert_space" title="wikilink">Category:Hilbert space</a></p>
</body>
</html>
