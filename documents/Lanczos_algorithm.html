<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="931">Lanczos algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lanczos algorithm</h1>
<hr/>

<p>The <strong>Lanczos algorithm</strong> is an <a href="iterative_algorithm" title="wikilink">iterative algorithm</a> devised by <a href="Cornelius_Lanczos" title="wikilink">Cornelius Lanczos</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> that is an adaptation of <a href="power_iteration" title="wikilink">power methods</a> to find the most useful eigenvalues and <a class="uri" href="eigenvectors" title="wikilink">eigenvectors</a> of an 

<math display="inline" id="Lanczos_algorithm:0">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{th}
  </annotation>
 </semantics>
</math>

 order linear system with a limited number of operations, 

<math display="inline" id="Lanczos_algorithm:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Lanczos_algorithm:2">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is much smaller than 

<math display="inline" id="Lanczos_algorithm:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


. Although computationally efficient in principle, the method as initially formulated was not useful, due to its numerical instability. In 1970, Ojalvo and Newman <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> showed how to make the method <a href="numerically_stable" title="wikilink">numerically stable</a> and applied it to the solution of very large engineering structures subjected to dynamic loading. This was achieved using a method for purifying the vectors to any degree of accuracy, which when not performed, produced a series of vectors that were highly contaminated by those associated with the lowest natural frequencies. In their original work, these authors also suggested how to select a starting vector (i.e. use a random number generator to select each element of the starting vector) and suggested an empirically determined method for determining 

<math display="inline" id="Lanczos_algorithm:4">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

, the reduced number of vectors (i.e. it should be selected to be approximately 1 ½ times the number of accurate eigenvalues desired). Soon thereafter their work was followed by Paige <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> who also provided an error analysis. In 1988, Ojalvo <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> produced a more detailed history of this algorithm and an efficient eigenvalue error test. Currently, the method is widely used in a variety of technical fields and has seen a number of variations.</p>
<h2 id="power-method-for-finding-eigenvalues">Power method for finding eigenvalues</h2>

<p>The power method for finding the largest eigenvalue of a matrix 

<math display="inline" id="Lanczos_algorithm:5">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,
  </annotation>
 </semantics>
</math>

 can be summarized by noting that if 

<math display="inline" id="Lanczos_algorithm:6">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}\,
  </annotation>
 </semantics>
</math>

 is a random vector and 

<math display="inline" id="Lanczos_algorithm:7">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mpadded width="+1.7pt">
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=Ax_{n}\,
  </annotation>
 </semantics>
</math>

, then in the large 

<math display="inline" id="Lanczos_algorithm:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 limit, 

<math display="inline" id="Lanczos_algorithm:9">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>/</mo>
   <mrow>
    <mo>∥</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>∥</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}/\|x_{n}\|
  </annotation>
 </semantics>
</math>

 approaches the normed eigenvector corresponding to the largest magnitude eigenvalue.</p>

<p>If 

<math display="inline" id="Lanczos_algorithm:10">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mrow>
      <mo>diag</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>σ</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mi>U</mi>
       <mo>′</mo>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <apply>
       <ci>diag</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>U</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=U\operatorname{diag}(\sigma_{i})U^{\prime}\,
  </annotation>
 </semantics>
</math>

 is the <a href="Eigendecomposition_of_a_matrix" title="wikilink">eigendecomposition</a> of 

<math display="inline" id="Lanczos_algorithm:11">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Lanczos_algorithm:12">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mrow>
      <mo>diag</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>σ</mi>
        <mi>i</mi>
        <mi>n</mi>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msup>
      <mi>U</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <apply>
       <ci>diag</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>i</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>U</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{n}=U\operatorname{diag}(\sigma_{i}^{n})U^{\prime}
  </annotation>
 </semantics>
</math>

. As 

<math display="inline" id="Lanczos_algorithm:13">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>n</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,
  </annotation>
 </semantics>
</math>


 gets very large, the diagonal matrix of eigenvalues will be dominated by whichever eigenvalue is largest (neglecting the case of two or more equally large eigenvalues, of course). As this happens, 

<math display="inline" id="Lanczos_algorithm:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>x</mi>
      <mi>n</mi>
      <mo>*</mo>
     </msubsup>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>/</mo>
    <msubsup>
     <mi>x</mi>
     <mi>n</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <times></times>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}^{*}x_{n+1}/{x_{n}^{*}x_{n}}\,
  </annotation>
 </semantics>
</math>

 will converge to the largest eigenvalue and 

<math display="inline" id="Lanczos_algorithm:15">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>/</mo>
   <mrow>
    <mo>∥</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="4.2pt">∥</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}/\|x_{n}\|\,
  </annotation>
 </semantics>
</math>

 to the associated eigenvector. If the largest eigenvalue is multiple, then 

<math display="inline" id="Lanczos_algorithm:16">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}\,
  </annotation>
 </semantics>
</math>

 will converge to a vector in the subspace spanned by the eigenvectors associated with those largest eigenvalues. Having found the first eigenvector/value, one can then successively restrict the algorithm to the null space of the known eigenvectors to get the second largest eigenvector/values and so on.</p>

<p>In practice, this simple algorithm does not work very well for computing very many of the eigenvectors because any <a href="round-off_error" title="wikilink">round-off error</a> will tend to introduce slight components of the more significant eigenvectors back into the computation, degrading the accuracy of the computation. Pure power methods also can converge slowly, even for the first eigenvector.</p>
<h2 id="lanczos-method">Lanczos method</h2>

<p>During the procedure of applying the power method, while getting the ultimate eigenvector 

<math display="inline" id="Lanczos_algorithm:17">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{n-1}v
  </annotation>
 </semantics>
</math>

, we also got a series of vectors 

<math display="inline" id="Lanczos_algorithm:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>A</mi>
       <mi>j</mi>
      </msup>
      <mi>v</mi>
     </mrow>
     <mo rspace="4.2pt">,</mo>
     <mi>j</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>j</ci>
       </apply>
       <ci>v</ci>
      </apply>
      <ci>j</ci>
     </list>
     <cn type="integer">0</cn>
    </apply>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-⋯</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{j}v,\,j=0,1,\cdots,n-2
  </annotation>
 </semantics>
</math>


 which were eventually discarded. As 

<math display="inline" id="Lanczos_algorithm:19">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is often taken to be quite large, this can result in a large amount of disregarded information. More advanced algorithms, such as <a href="Arnoldi's_algorithm" title="wikilink">Arnoldi's algorithm</a> and the Lanczos algorithm, save this information and use the <a href="Gram–Schmidt_process" title="wikilink">Gram–Schmidt process</a> or <a href="Householder_algorithm" title="wikilink">Householder algorithm</a> to reorthogonalize them into a basis spanning the <a href="Krylov_subspace" title="wikilink">Krylov subspace</a> corresponding to the matrix 

<math display="inline" id="Lanczos_algorithm:20">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="the-algorithm">The algorithm</h3>

<p>The Lanczos algorithm can be viewed as a simplified <a href="Arnoldi's_algorithm" title="wikilink">Arnoldi's algorithm</a> in that it applies to <a href="Hermitian_matrices" title="wikilink">Hermitian matrices</a>. The 

<math display="inline" id="Lanczos_algorithm:21">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

'th step of the algorithm transforms the matrix 

<math display="inline" id="Lanczos_algorithm:22">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 into a <a href="tridiagonal_matrix" title="wikilink">tridiagonal matrix</a> 

<math display="inline" id="Lanczos_algorithm:23">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>m</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{mm}
  </annotation>
 </semantics>
</math>


; when 

<math display="inline" id="Lanczos_algorithm:24">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is equal to the dimension of 

<math display="inline" id="Lanczos_algorithm:25">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Lanczos_algorithm:26">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>m</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{mm}
  </annotation>
 </semantics>
</math>

 is <a href="similar_(linear_algebra)" title="wikilink">similar</a> to 

<math display="inline" id="Lanczos_algorithm:27">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="definitions">Definitions</h4>

<p>We hope to calculate the tridiagonal and symmetric matrix 

<math display="inline" id="Lanczos_algorithm:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>m</mi>
      <mi>m</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>V</mi>
      <mi>m</mi>
      <mo>*</mo>
     </msubsup>
     <mi>A</mi>
     <msub>
      <mi>V</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>m</ci>
      </apply>
      <times></times>
     </apply>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{mm}=V_{m}^{*}AV_{m}.
  </annotation>
 </semantics>
</math>


</p>

<p>The diagonal elements are denoted by 

<math display="inline" id="Lanczos_algorithm:29">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>j</mi>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{j}=t_{jj}
  </annotation>
 </semantics>
</math>

, and the off-diagonal elements are denoted by 

<math display="inline" id="Lanczos_algorithm:30">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mrow>
     <mrow>
      <mi>j</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <list>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>j</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{j}=t_{j-1,j}
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that 

<math display="inline" id="Lanczos_algorithm:31">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mrow>
     <mrow>
      <mi>j</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>j</mi>
     <mo>,</mo>
     <mrow>
      <mi>j</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <list>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>j</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <list>
      <ci>j</ci>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{j-1,j}=t_{j,j-1}
  </annotation>
 </semantics>
</math>

, due to its symmetry.</p>
<h4 id="iteration">Iteration</h4>

<p>(Note: Following these steps alone will <strong>not</strong> give you the correct eigenvalue and eigenvectors. More consideration must be applied to correct for the numerical errors. See the section <a href="#Numerical_stability" title="wikilink">Numerical stability</a> in the following.)</p>

<p>There are in principle four ways to write the iteration procedure. Paige[1972] and other works show that the following procedure is the most numerically stable.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> 

<math display="inline" id="Lanczos_algorithm:32">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">←</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1}\leftarrow\,
  </annotation>
 </semantics>
</math>

 random vector with norm 1.</p>

<p><code> </code>

<math display="inline" id="Lanczos_algorithm:33">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>0</mn>
   </msub>
   <mo>←</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{0}\leftarrow 0\,
  </annotation>
 </semantics>
</math>


</p>

<p>

<math display="inline" id="Lanczos_algorithm:34">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>←</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}\leftarrow 0\,
  </annotation>
 </semantics>
</math>

</p>

<p><code> </code><strong><code>for</code></strong><code> </code>

<math display="inline" id="Lanczos_algorithm:35">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mpadded width="+1.7pt">
      <mn>1</mn>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-⋯</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1,2,\cdots,m-1\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Lanczos_algorithm:36">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>j</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <mi>A</mi>
    <mpadded width="+1.7pt">
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}\leftarrow Av_{j}\,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Lanczos_algorithm:37">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>j</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>j</mi>
    </msub>
    <mo>⋅</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{j}\leftarrow w_{j}\cdot v_{j}\,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Lanczos_algorithm:38">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>j</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>j</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
     <mpadded width="+1.7pt">
      <msub>
       <mi>v</mi>
       <mrow>
        <mi>j</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <minus></minus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}\leftarrow w_{j}-\alpha_{j}v_{j}-\beta_{j}v_{j-1}\,
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Lanczos_algorithm:39">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>←</mo>
   <mrow>
    <mo>∥</mo>
    <msub>
     <mi>w</mi>
     <mi>j</mi>
    </msub>
    <mo rspace="4.2pt">∥</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{j+1}\leftarrow\left\|w_{j}\right\|\,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Lanczos_algorithm:40">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>←</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>j</mi>
    </msub>
    <mo>/</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>β</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{j+1}\leftarrow w_{j}/\beta_{j+1}\,
  </annotation>
 </semantics>
</math>

</p>

<p><code> </code><strong><code>endfor</code></strong><br/>
<code> </code><br/>
<code> </code>

<math display="inline" id="Lanczos_algorithm:41">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>m</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <mi>A</mi>
    <mpadded width="+1.7pt">
     <msub>
      <mi>v</mi>
      <mi>m</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{m}\leftarrow Av_{m}\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Lanczos_algorithm:42">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>m</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>m</mi>
    </msub>
    <mo>⋅</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>v</mi>
      <mi>m</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{m}\leftarrow w_{m}\cdot v_{m}\,
  </annotation>
 </semantics>
</math>

</p>

<p><code> </code><strong><code>return</code></strong></p>

<p>Here, 

<math display="inline" id="Lanczos_algorithm:43">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>⋅</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\cdot y
  </annotation>
 </semantics>
</math>


 represents the dot product of vectors 

<math display="inline" id="Lanczos_algorithm:44">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lanczos_algorithm:45">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

.</p>

<p>After the iteration, we get the 

<math display="inline" id="Lanczos_algorithm:46">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{j}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lanczos_algorithm:47">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{j}
  </annotation>
 </semantics>
</math>

 which construct a tridiagonal matrix</p>

<p>

<math display="inline" id="Lanczos_algorithm:48">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mrow>
     <mi>m</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>β</mi>
        <mn>2</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>β</mi>
        <mn>2</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mn>2</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>β</mi>
        <mn>3</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>β</mi>
        <mn>3</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mn>3</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋱</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋱</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋱</mi>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>β</mi>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>β</mi>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>β</mi>
        <mi>m</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>β</mi>
        <mi>m</mi>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>α</mi>
        <mi>m</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">2</cn>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">3</cn>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-⋱</ci>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-⋱</ci>
      <ci>normal-⋱</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>m</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>m</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{mm}=\begin{pmatrix}\alpha_{1}&\beta_{2}&&&&0\\
\beta_{2}&\alpha_{2}&\beta_{3}&&&\\
&\beta_{3}&\alpha_{3}&\ddots&&\\
&&\ddots&\ddots&\beta_{m-1}&\\
&&&\beta_{m-1}&\alpha_{m-1}&\beta_{m}\\
0&&&&\beta_{m}&\alpha_{m}\\
\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The vectors 

<math display="inline" id="Lanczos_algorithm:49">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{j}
  </annotation>
 </semantics>
</math>

 (<strong>Lanczos vectors</strong>) generated on the fly construct the transformation matrix</p>

<p>

<math display="inline" id="Lanczos_algorithm:50">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>m</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>m</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>m</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{m}=\left(v_{1},v_{2},\cdots,v_{m}\right)
  </annotation>
 </semantics>
</math>

,</p>

<p>which is useful for calculating the eigenvectors (see below). In practice, it could be saved after generation (but takes a lot of memory), or could be regenerated when needed, as long as one keeps the first vector 

<math display="inline" id="Lanczos_algorithm:51">
 <semantics>
  <msub>
   <mi>v</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1}
  </annotation>
 </semantics>
</math>

. At each iteration the algorithm executes a matrix-vector multiplication and 7n further ﬂoating point operations.</p>
<h4 id="solve-for-eigenvalues-and-eigenvectors">Solve for eigenvalues and eigenvectors</h4>

<p>After the matrix 

<math display="inline" id="Lanczos_algorithm:52">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>m</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{mm}
  </annotation>
 </semantics>
</math>

 is calculated, one can solve its eigenvalues 

<math display="inline" id="Lanczos_algorithm:53">
 <semantics>
  <msubsup>
   <mi>λ</mi>
   <mi>i</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>i</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}^{(m)}
  </annotation>
 </semantics>
</math>

 and their corresponding eigenvectors 

<math display="inline" id="Lanczos_algorithm:54">
 <semantics>
  <msubsup>
   <mi>u</mi>
   <mi>i</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}^{(m)}
  </annotation>
 </semantics>
</math>

 (for example, using the <a href="QR_algorithm" title="wikilink">QR algorithm</a> or Multiple Relatively Robust Representations (MRRR)). The eigenvalues and eigenvectors of 

<math display="inline" id="Lanczos_algorithm:55">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 can be obtained in as little as 

<math display="inline" id="Lanczos_algorithm:56">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(m^{2})
  </annotation>
 </semantics>
</math>

 work with MRRR; obtaining just the eigenvalues is much simpler and can be done in 

<math display="inline" id="Lanczos_algorithm:57">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(m^{2})
  </annotation>
 </semantics>
</math>

 work with spectral bisection.</p>

<p>It can be proved that the eigenvalues are approximate eigenvalues of the original matrix 

<math display="inline" id="Lanczos_algorithm:58">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</p>

<p>The Ritz eigenvectors 

<math display="inline" id="Lanczos_algorithm:59">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Lanczos_algorithm:60">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 can be calculated by 

<math display="inline" id="Lanczos_algorithm:61">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>m</mi>
    </msub>
    <msubsup>
     <mi>u</mi>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>i</ci>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}=V_{m}u_{i}^{(m)}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Lanczos_algorithm:62">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{m}
  </annotation>
 </semantics>
</math>

 is the transformation matrix whose column vectors are 

<math display="inline" id="Lanczos_algorithm:63">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1},v_{2},\cdots,v_{m}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="numerical-stability">Numerical stability</h3>

<p>Stability means how much the algorithm will be affected (i.e. will it produce the approximate result close to the original one) if there are small numerical errors introduced and accumulated. Numerical stability is the central criterion for judging the usefulness of implementing an algorithm on a computer with roundoff.</p>

<p>For the Lanczos algorithm, it can be proved that with <em>exact arithmetic</em>, the set of vectors 

<math display="inline" id="Lanczos_algorithm:64">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mrow>
     <mi>m</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1},v_{2},\cdots,v_{m+1}
  </annotation>
 </semantics>
</math>

 constructs an <em>orthonormal</em> basis, and the eigenvalues/vectors solved are good approximations to those of the original matrix. However, in practice (as the calculations are performed in floating point arithmetic where inaccuracy is inevitable), the orthogonality is quickly lost and in some cases the new vector could even be linearly dependent on the set that is already constructed. As a result, some of the eigenvalues of the resultant tridiagonal matrix may not be approximations to the original matrix. Therefore, the Lanczos algorithm is not very stable.</p>

<p>Users of this algorithm must be able to find and remove those "spurious" eigenvalues. Practical implementations of the Lanczos algorithm go in three directions to fight this stability issue:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<ol>
<li>Prevent the loss of orthogonality</li>
<li>Recover the orthogonality after the basis is generated</li>
<li>After the good and "spurious" eigenvalues are all identified, remove the spurious ones.</li>
</ol>
<h2 id="variations">Variations</h2>

<p>Variations on the Lanczos algorithm exist where the vectors involved are tall, narrow matrices instead of vectors and the normalizing constants are small square matrices. These are called "block" Lanczos algorithms and can be much faster on computers with large numbers of registers and long memory-fetch times.</p>

<p>Many implementations of the Lanczos algorithm restart after a certain number of iterations. One of the most influential restarted variations is the implicitly restarted Lanczos method,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> which is implemented in <a class="uri" href="ARPACK" title="wikilink">ARPACK</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> This has led into a number of other restarted variations such as restarted Lanczos bidiagonalization.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Another successful restarted variation is the Thick-Restart Lanczos method,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> which has been implemented in a software package called TRLan.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="nullspace-over-a-finite-field">Nullspace over a finite field</h3>

<p>In 1995, <a href="Peter_Montgomery_(mathematician)" title="wikilink">Peter Montgomery</a> published an algorithm, based on the Lanczos algorithm, for finding elements of the <a href="kernel_(matrix)" title="wikilink">nullspace</a> of a large sparse matrix over <a class="uri" href="GF(2)" title="wikilink">GF(2)</a>; since the set of people interested in large sparse matrices over finite fields and the set of people interested in large eigenvalue problems scarcely overlap, this is often also called the <em>block Lanczos algorithm</em> without causing unreasonable confusion.</p>
<h2 id="applications">Applications</h2>

<p>Lanczos algorithms are very attractive because the multiplication by 

<math display="inline" id="Lanczos_algorithm:65">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,
  </annotation>
 </semantics>
</math>

 is the only large-scale linear operation. Since weighted-term text retrieval engines implement just this operation, the Lanczos algorithm can be applied efficiently to text documents (see <a href="Latent_Semantic_Indexing" title="wikilink">Latent Semantic Indexing</a>). Eigenvectors are also important for large-scale ranking methods such as the <a href="HITS_algorithm" title="wikilink">HITS algorithm</a> developed by <a href="Jon_Kleinberg" title="wikilink">Jon Kleinberg</a>, or the <a class="uri" href="PageRank" title="wikilink">PageRank</a> algorithm used by Google.</p>

<p>Lanczos algorithms are also used in <a href="Condensed_Matter_Physics" title="wikilink">Condensed Matter Physics</a> as a method for solving <a href="Hamiltonian_matrix" title="wikilink">Hamiltonians</a> of <a href="Strongly_correlated_material" title="wikilink">strongly correlated electron systems</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>Lanczos algorithm has also been used in the formulation of the Levenberg-Marquardt or the Gauss-Newton optimization for solving nonlinear inverse problems (such as generating computational models of oil and gas reservoirs given observed production data).<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="implementations">Implementations</h2>

<p>The <a href="NAG_Numerical_Library" title="wikilink">NAG Library</a> contains several routines<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> for the solution of large scale linear systems and eigenproblems which use the Lanczos algorithm.</p>

<p><a class="uri" href="MATLAB" title="wikilink">MATLAB</a> and <a href="GNU_Octave" title="wikilink">GNU Octave</a> come with ARPACK built-in. Both stored and implicit matrices can be analyzed through the <em>eigs()</em> function (<a href="http://www.mathworks.com/help/techdoc/ref/eigs.html">Matlab</a>/<a href="http://www.gnu.org/software/octave/doc/interpreter/Sparse-Linear-Algebra.html#doc_002deigs">Octave</a>).</p>

<p>A Matlab implementation of the Lanczos algorithm (note precision issues) is available as a part of the <a href="http://www.cs.cmu.edu/~bickson/gabp/#download">Gaussian Belief Propagation Matlab Package</a>. The <a class="uri" href="GraphLab" title="wikilink">GraphLab</a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> collaborative filtering library incorporates a large scale parallel implementation of the Lanczos algorithm (in C++) for multicore.</p>

<p>The <a href="http://www.cs.wm.edu/~andreas/software/">PRIMME</a> library also implements a Lanczos like algorithm.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://books.google.com/books?vid=ISBN0801854148">Golub and van Loan give very good descriptions of the various forms of Lanczos algorithms in their book <em>Matrix Computations</em></a></li>
<li><a href="http://ai.stanford.edu/~ang/papers/ijcai01-linkanalysis.pdf">Andrew Ng et al., an analysis of PageRank</a></li>
<li><a href="http://www.farcaster.com/papers/crypto-solve/node3.html">Lanczos and conjugate gradient methods</a> B. A. LaMacchia and A. M. Odlyzko, Solving Large Sparse Linear Systems Over Finite Fields.</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Lanczos, C. "An iteration method for the solution of the eigenvalue problem of linear differential and integral operators", J. Res. Nat’l Bur. Std. 45, 225-282 (1950).<a href="#fnref1">↩</a></li>
<li id="fn2">Ojalvo, I.U. and Newman, M.,"Vibration modes of large structures by an automatic matrix-reduction method", AIAA J., 8 (7), 1234-1239 (1970).<a href="#fnref2">↩</a></li>
<li id="fn3">Paige, C.C., "The computation of eigenvalues and eigenvectors of very large sparse matrices", the U. of London Ph.D. thesis (1971).<a href="#fnref3">↩</a></li>
<li id="fn4">Paige, C.C., "Computational variants of the Lanczos method for the eigenproblem", J. Inst. Maths Applics 10, 373-381 (1972).<a href="#fnref4">↩</a></li>
<li id="fn5">Ojalvo, I.U., "Origins and advantages of Lanczos vectors for large dynamic systems", Proc. 6th Modal Analysis Conference (IMAC), Kissimmee, FL, 489-494 (1988).<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16">History matching production data and uncertainty assessment with an efficient TSVD parameterization algorithm, Journal of Petroleum Science and Engineering <a class="uri" href="http://www.sciencedirect.com/science/article/pii/S0920410513003227">http://www.sciencedirect.com/science/article/pii/S0920410513003227</a><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="http://www.graphlab.ml.cmu.edu/pmf.html">GraphLab</a><a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
