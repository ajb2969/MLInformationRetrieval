<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1557">Movable cellular automaton</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Movable cellular automaton</h1>
<hr/>

<p>The <strong>Movable cellular automaton (MCA)</strong> method is a method in <a href="Computational_mechanics" title="wikilink">computational solid mechanics</a> based on the discrete concept. It provides advantages both of classical <a href="cellular_automaton" title="wikilink">cellular automaton</a> and <a href="discrete_element_method" title="wikilink">discrete element</a> methods. Important advantage of the МСА method is a possibility of direct <a href="Computer_simulation" title="wikilink">simulation</a> of materials fracture including damage generation, crack propagation, fragmentation and mass mixing. It is difficult to simulate these processes by means of <a href="continuum_mechanics" title="wikilink">continuum mechanics</a> methods (For example: <a href="finite_element_method" title="wikilink">finite element method</a>, <a href="finite_difference_method" title="wikilink">finite difference method</a>, etc.), so some new concepts like <a class="uri" href="peridynamics" title="wikilink">peridynamics</a> are required. <a href="Discrete_element_method" title="wikilink">Discrete element method</a> is very effective to simulate granular materials, but mutual forces among movable cellular automata provides simulating solids behavior. If size of automaton will be close to zero then MCA behavior becomes like classical <a href="continuum_mechanics" title="wikilink">continuum mechanics</a> methods.</p>
<h2 id="keystone-of-the-movable-cellular-automaton-method">Keystone of the movable cellular automaton method</h2>

<p>[[<a class="uri" href="File:MCA">File:MCA</a> elements.png|thumb|left|</p>
<center>

<p>Object (at left) is described as set of interacted automata (at center). At right is shown velocity field of automata.</p>
</center>

<p>]] In framework of the <strong>MCA</strong> approach an object under modeling is considered as a set of interacting elements/automata. The dynamics of the set of automata are defined by their mutual forces and rules for their relationships. This system exists and operates in time and space. Its evolution in time and space is governed by the equations of motion. The mutual forces and rules for inter-elements relationships are defined by the function of the automaton response. This function has to be specified for each automaton. Due to mobility of automata the following new parameters of cellular automata have to be included into consideration: <em>R<sup>i</sup></em> – radius-vector of automaton; <em>V<sup>i</sup></em> – velocity of automaton; <strong>ω<sup>i</sup></strong> – rotation velocity of automaton; <em>θ<sup>i</sup></em> – rotation vector of automaton; <em>m<sup>i</sup></em> – mass of automaton; <em>J<sup>i</sup></em> – moment of inertia of automaton.</p>
<h2 id="new-concept-neighbours">New concept: neighbours</h2>

<p>[[<a class="uri" href="File:MCA">File:MCA</a> neighbors.gif|thumb|</p>
<center>

<p>Each automaton has some neighbors</p>
</center>

<p>]] The new concept of the MCA method is based on the introducing of the <strong>state of the pair of automata</strong> (relation of interacting pairs of automata) in addition to the conventional one – the state of a separate automaton. Note that the introduction of this definition allows to go from the static net concept to the <strong>concept of neighbours</strong>. As a result of this, the automata have the ability to change their neighbors by switching the states (relationships) of the pairs.</p>
<h2 id="definition-of-the-parameter-of-pair-state">Definition of the parameter of pair state</h2>

<p>The introducing of new type of states leads to new parameter to use it as criteria for <strong>switching relationships</strong>. It is defined as an automaton overlapping parameters <em>h<sup>ij</sup></em>. So the relationship of the cellular automata is characterised by the value of their <strong>overlapping</strong>.</p>

<p> </p>

<p>The initial structure is formed by setting up certain relationships among each pair of neighboring elements.</p>
<h2 id="criterion-of-switching-of-the-state-of-pair-relationships">Criterion of switching of the state of pair relationships</h2>

<p>[[<a class="uri" href="File:MCA">File:MCA</a> switch.gif|thumb|</p>
<center>

<p>At left pair of automata ij is linked. At right pair of automata ij is unlinked.</p>
</center>

<p>]] In contrast to the classical cellular automaton method in the MCA method not only a single automaton but also a <strong>relationship of pair of automata can be switched</strong>. According with the bistable automata concept there are two types of the pair states (relationships):</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>linked</strong></p></td>
<td style="text-align: left;">
<p>– both automata belong to a solid</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>unlinked</strong></p></td>
<td style="text-align: left;">
<p>– each automaton of the pair belongs to different bodies or parts of damaged body.</p></td>
</tr>
</tbody>
</table>

<p>So the <strong>changing of the state of pair relationships</strong> is controlled by relative movements of the automata and the media formed by such pairs can be considered as bistable media.</p>
<h2 id="equations-of-mca-motion">Equations of MCA motion</h2>

<p>The evolution of MCA media is described by the following <strong>equations of motion for translation</strong>:</p>

<p>

<math display="block" id="Movable_cellular_automaton:0">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msup>
      <mi>d</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>h</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msup>
    </mrow>
    <mrow>
     <mi>d</mi>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <msup>
         <mi>m</mi>
         <mi>i</mi>
        </msup>
       </mfrac>
       <mo>+</mo>
       <mfrac>
        <mn>1</mn>
        <msup>
         <mi>m</mi>
         <mi>j</mi>
        </msup>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msup>
      <mi>p</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>≠</mo>
       <mi>j</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>i</mi>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ψ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>α</mi>
        <mrow>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>i</mi>
          <mi>k</mi>
         </mrow>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <msup>
        <mi>m</mi>
        <mi>i</mi>
       </msup>
      </mfrac>
      <msup>
       <mi>p</mi>
       <mrow>
        <mi>i</mi>
        <mi>k</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>l</mi>
       <mo>≠</mo>
       <mi>i</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>j</mi>
        <mi>l</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ψ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>α</mi>
        <mrow>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mi>l</mi>
         </mrow>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <msup>
        <mi>m</mi>
        <mi>j</mi>
       </msup>
      </mfrac>
      <msup>
       <mi>p</mi>
       <mrow>
        <mi>j</mi>
        <mi>l</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>m</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>m</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>k</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
       </interval>
       <ci>ψ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <list>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>k</ci>
         </apply>
        </list>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>m</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>l</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>l</ci>
        </apply>
       </interval>
       <ci>ψ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <list>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>l</ci>
         </apply>
        </list>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>m</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {d^{2}h^{ij}\over dt^{2}}=\left({1\over m^{i}}+{1\over m^{j}}\right)p^{ij}+%
\sum_{k\neq j}C(ij,ik)\psi(\alpha_{ij,ik}){1\over m^{i}}p^{ik}+\sum_{l\neq i}C%
(ij,jl)\psi(\alpha_{ij,jl}){1\over m^{j}}p^{jl}
  </annotation>
 </semantics>
</math>

</p>

<p>[[<a class="uri" href="File:MCA">File:MCA</a> neighbour in pair.png|thumb|</p>
<center>

<p>Forces between automata ij coming from their neighbors.</p>
</center>

<p>]] Here m<sup>i</sup> is the mass of automaton i, p<sup>ij</sup> is central force acting between automata i and j, C(ij,ik) is certain coefficient associated with transferring the h parameter from pair <strong>ij</strong> to pair <strong>ik</strong>, ψ(α<sub>ij,ik</sub>) is angle between directions <strong>ij</strong> and <strong>ik</strong>.</p>

<p>Due to finite size of movable automata the rotation effects have to be taken into account. The <strong>equations of motion for rotation</strong> can be written as follows:</p>

<p>

<math display="block" id="Movable_cellular_automaton:1">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msup>
      <mi>d</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>θ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msup>
    </mrow>
    <mrow>
     <mi>d</mi>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mfrac>
        <msup>
         <mi>q</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msup>
        <msup>
         <mi>J</mi>
         <mi>i</mi>
        </msup>
       </mfrac>
       <mo>+</mo>
       <mfrac>
        <msup>
         <mi>q</mi>
         <mrow>
          <mi>j</mi>
          <mi>i</mi>
         </mrow>
        </msup>
        <msup>
         <mi>J</mi>
         <mi>j</mi>
        </msup>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msup>
      <mi>τ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>≠</mo>
       <mi>j</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>i</mi>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <msup>
        <mi>q</mi>
        <mrow>
         <mi>i</mi>
         <mi>k</mi>
        </mrow>
       </msup>
       <msup>
        <mi>J</mi>
        <mi>i</mi>
       </msup>
      </mfrac>
      <msup>
       <mi>τ</mi>
       <mrow>
        <mi>i</mi>
        <mi>k</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>l</mi>
       <mo>≠</mo>
       <mi>j</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>j</mi>
        <mi>l</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <msup>
        <mi>q</mi>
        <mrow>
         <mi>j</mi>
         <mi>l</mi>
        </mrow>
       </msup>
       <msup>
        <mi>J</mi>
        <mi>j</mi>
       </msup>
      </mfrac>
      <msup>
       <mi>τ</mi>
       <mrow>
        <mi>j</mi>
        <mi>l</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>θ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>q</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>J</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>q</ci>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>J</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>τ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>k</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>S</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
       </interval>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>q</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>J</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>τ</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>l</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>S</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>l</ci>
        </apply>
       </interval>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>q</ci>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>l</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>J</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>τ</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {d^{2}\theta^{ij}\over dt^{2}}=\left({q^{ij}\over J^{i}}+{q^{ji}\over J^{j}}%
\right)\tau^{ij}+\sum_{k\neq j}S(ij,ik){q^{ik}\over J^{i}}\tau^{ik}+\sum_{l%
\neq j}S(ij,jl){q^{jl}\over J^{j}}\tau^{jl}
  </annotation>
 </semantics>
</math>

</p>

<p>Here Θ<sup>ij</sup> is the angle of relative rotation (it is a switching parameter like h<sup>ij</sup> for translation), q<sup>ij</sup> is the distance from center of automaton <strong>i</strong> to contact point of automaton <strong>j</strong> (moment arm), τ<sup>ij</sup> is the pair tangential interaction, S(ij,ik) is certain coefficient associated with transferring the Θ parameter from one pair to other (it is similar to C(ij,ik) from the equation for translation).</p>

<p>It should be noted that these equations are completely similar to the equations of motion for the many–particle approach.</p>
<h2 id="definition-of-deformation-in-pair-of-automata">Definition of deformation in pair of automata</h2>

<p>[[<a class="uri" href="File:MCA">File:MCA</a> Deformation in Pair of Automata.gif|thumb|left|</p>
<center>

<p>Rotation of body as whole not caused to deformation in pair of automata</p>
</center>

<p>]] <strong>Translation of the pair automata</strong> The dimensionless deformation parameter for translation of the <strong>i j</strong> automata pair can be presented as:</p>

<p>

<math display="block" id="Movable_cellular_automaton:2">
 <semantics>
  <mrow>
   <msup>
    <mi>ε</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mi>h</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msup>
    <msubsup>
     <mi>r</mi>
     <mn>0</mn>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msubsup>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>q</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msup>
       <mo>+</mo>
       <msup>
        <mi>q</mi>
        <mrow>
         <mi>j</mi>
         <mi>i</mi>
        </mrow>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msup>
         <mi>d</mi>
         <mi>i</mi>
        </msup>
        <mo>+</mo>
        <msup>
         <mi>d</mi>
         <mi>j</mi>
        </msup>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mo mathsize="120%" stretchy="false">/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>d</mi>
        <mi>i</mi>
       </msup>
       <mo>+</mo>
       <msup>
        <mi>d</mi>
        <mi>j</mi>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo mathsize="120%" stretchy="false">/</mo>
     <mn>2</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ε</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>q</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>q</ci>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>d</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>d</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>d</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>d</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon^{ij}={h^{ij}\over r_{0}^{ij}}={\left(q^{ij}+q^{ji}\right)-\left(d^%
{i}+d^{j}\right)\big/2\over\left(d^{i}+d^{j}\right)\big/2}
  </annotation>
 </semantics>
</math>

</p>

<p>In this case:</p>

<p>

<math display="block" id="Movable_cellular_automaton:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <msup>
        <mi>ε</mi>
        <mrow>
         <mi>i</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <msup>
        <mi>ε</mi>
        <mrow>
         <mi>j</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mfrac>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>d</mi>
        <mi>i</mi>
       </msup>
       <mo>+</mo>
       <msup>
        <mi>d</mi>
        <mi>j</mi>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>V</mi>
     <mi>n</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msubsup>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ε</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ε</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>d</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>d</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\Delta{\varepsilon^{i(j)}}+\Delta{\varepsilon^{j(i)}}\right){\left(d^{i}%
+d^{j}\right)\over 2}=V_{n}^{ij}\Delta{t}
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>Δt</strong> time step, <strong>V<sub>n</sub><sup>ij</sup></strong> – relative velocity.</p>

<p>Rotation of the pair automata can be calculated by analogy with the last translation relationships.</p>
<h2 id="modeling-of-irreversible-deformation-in-the-mca-method">Modeling of irreversible deformation in the MCA method</h2>

<p>[[<a class="uri" href="File:MCA">File:MCA</a> Irreversible Deformation.gif|thumb|</p>
<center>

<p>Deformation is determine by value of distance from the center of automaton</p>
</center>

<p>]] [[<a class="uri" href="File:MCA">File:MCA</a> response function of automata.gif|thumb|</p>
<center>

<p>There are two types of the response function of automata</p>
</center>

<p>]]</p>

<p>The <strong>ε<sup>ij</sup></strong> parameter is used as a measure of deformation of automaton <strong>i</strong> under its interaction with automaton <strong>j</strong>. Where <strong>q<sup>ij</sup></strong> – is a distance from the center of automaton <strong>i</strong> to its contact point with automaton <strong>j</strong>; <strong>R<sup>i</sup> = d<sup>i</sup>/2</strong> (<strong>d<sup>i</sup></strong> – is the size of automaton <strong>i</strong>).</p>

<p><strong>As an example</strong> the titanium specimen under cyclic loading (tension – compression) is considered. The loading diagram is shown in the next figure:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Scheme of loading</p></th>
<th style="text-align: left;">
<p>Loading diagram</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>MCA cyclic schem.gif</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>MCA cyclic diag.gif</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>(<strong>Red marks</strong> are the experimental data)</p></td>
</tr>
</tbody>
</table>
<h2 id="advantages-of-mca-method">Advantages of MCA method</h2>

<p>Due to mobility of each automaton the MCA method allows to take into account directly such actions as:</p>
<ul>
<li>mass mixing</li>
<li>penetration effects</li>
<li>chemical reactions</li>
<li>intensive deformation</li>
<li>phase transformations</li>
<li>accumulation of damages</li>
<li>fragmentation and fracture</li>
<li>cracks generation and development</li>
</ul>

<p>Using boundary conditions of different types (fixed, elastic, viscous-elastic, etc.) it is possible to imitate different properties of surrounding medium, containing the simulated system. It is possible to model different modes of mechanical loading (tension, compression, shear strain, etc.) by setting up additional conditions at the boundaries.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Continuum_mechanics" title="wikilink">Continuum mechanics</a></li>
<li><a href="Solid_mechanics" title="wikilink">Solid mechanics</a></li>
<li><a href="Fracture_mechanics" title="wikilink">Fracture mechanics</a></li>
<li><a class="uri" href="Peridynamics" title="wikilink">Peridynamics</a></li>
<li><a href="Computer_simulation" title="wikilink">Computer simulation</a></li>
<li><a href="Discrete_element_method" title="wikilink">Discrete element method</a></li>
<li><a href="Cellular_automaton" title="wikilink">Cellular automaton</a></li>
<li><a href="Finite_element_method" title="wikilink">Finite element method</a></li>
<li><a href="Finite_difference_method" title="wikilink">Finite difference method</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>()</p></li>
<li>

<p>()</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>()</p></li>
<li></li>
<li></li>
<li>

<p>()</p></li>
<li>

<p>()</p></li>
</ul>
<h2 id="software">Software</h2>
<ul>
<li><a href="http://mechanik.tu-berlin.de/popov/software/mca/mca.htm">MCA software package</a></li>
<li>Software for simulation of materials in discrete-continuous approach «FEM+MCA»: Number of state registration in Applied Research Foundation of Algorithms and Software (AFAS): 50208802297 / Smolin A.Y., Zelepugin S.A., Dobrynin S.A.; applicant and development center is Tomsk State University. – register date 28.11.2008; <a href="http://serg-dobrinin.narod.ru/mydiploms/reg_program.jpg">certificate AFAS N 11826 date 01.12.2008.</a></li>
</ul>

<p>"</p>

<p><a href="Category:Solid_mechanics" title="wikilink">Category:Solid mechanics</a> <a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Cellular_automata" title="wikilink">Category:Cellular automata</a> <a href="Category:Condensed_matter_physics" title="wikilink">Category:Condensed matter physics</a> <a href="Category:Mathematical_modeling" title="wikilink">Category:Mathematical modeling</a></p>
</body>
</html>
