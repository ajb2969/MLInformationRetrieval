<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1055">Locally decodable code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Locally decodable code</h1>
<hr/>

<p>A <strong>locally decodable code</strong> (LDC) is an <a href="error-correcting_code" title="wikilink">error-correcting code</a> that allows a single bit of the original message to be decoded with high probability by only examining (or querying) a small number of bits of a possibly corrupted <a class="uri" href="codeword" title="wikilink">codeword</a>. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This property could be useful, say, in a context where information is being transmitted over a noisy channel, and only a small subset of the data is required at a particular time and there is no need to decode the entire message at once. Note that locally decodable codes are not a subset of <a href="locally_testable_code" title="wikilink">locally testable codes</a>, though there is some overlap between the two.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Codewords are generated from the original message using an algorithm that introduces a certain amount of redundancy into the codeword; thus, the codeword is always longer than the original message. This redundancy is distributed across the codeword and allows the original message to be recovered with good probability even in the presence of errors. The more redundant the codeword, the more resilient it is against errors, and the fewer queries required to recover a bit of the original message.</p>
<h2 id="overview">Overview</h2>

<p>More formally, a 

<math display="inline" id="Locally_decodable_code:0">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>q</mi>
<mo>,</mo>
<mi>δ</mi>
<mo>,</mo>
<mi>ϵ</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<vector>
<ci>q</ci>
<ci>δ</ci>
<ci>ϵ</ci>
</vector>
</annotation-xml>
<annotation encoding="application/x-tex">
   (q,\delta,\epsilon)
  </annotation>
</semantics>
</math>

-locally decodable code encodes an 

<math display="inline" id="Locally_decodable_code:1">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

-bit message 

<math display="inline" id="Locally_decodable_code:2">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 to an 

<math display="inline" id="Locally_decodable_code:3">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

-bit codeword 

<math display="inline" id="Locally_decodable_code:4">
<semantics>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>C</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C(x)
  </annotation>
</semantics>
</math>

 such that any bit 

<math display="inline" id="Locally_decodable_code:5">
<semantics>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}
  </annotation>
</semantics>
</math>

 of the message can be recovered with probability 

<math display="inline" id="Locally_decodable_code:6">
<semantics>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>ϵ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>ϵ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1-\epsilon
  </annotation>
</semantics>
</math>

 by using a randomized decoding algorithm that queries only 

<math display="inline" id="Locally_decodable_code:7">
<semantics>
<mi>q</mi>
<annotation-xml encoding="MathML-Content">
<ci>q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   q
  </annotation>
</semantics>
</math>

 bits of the codeword 

<math display="inline" id="Locally_decodable_code:8">
<semantics>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>C</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C(x)
  </annotation>
</semantics>
</math>

, even if up to 

<math display="inline" id="Locally_decodable_code:9">
<semantics>
<mrow>
<mi>δ</mi>
<mi>N</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>δ</ci>
<ci>N</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta N
  </annotation>
</semantics>
</math>

 locations of the codeword have been corrupted.</p>

<p>Furthermore, a perfectly smooth local decoder is a decoder such that, in addition to always generating the correct output given access to an uncorrupted codeword, for every 

<math display="inline" id="Locally_decodable_code:10">
<semantics>
<mrow>
<mi>j</mi>
<mo>∈</mo>
<mrow>
<mo stretchy="false">[</mo>
<mi>q</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>j</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>q</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j\in[q]
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Locally_decodable_code:11">
<semantics>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>i</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i\in[n]
  </annotation>
</semantics>
</math>

 the 

<math display="inline" id="Locally_decodable_code:12">
<semantics>
<msup>
<mi>j</mi>
<mrow>
<mi>t</mi>
<mi>h</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<apply>
<times></times>
<ci>t</ci>
<ci>h</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j^{th}
  </annotation>
</semantics>
</math>

 query to recover the 

<math display="inline" id="Locally_decodable_code:13">
<semantics>
<msup>
<mi>i</mi>
<mrow>
<mi>t</mi>
<mi>h</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>i</ci>
<apply>
<times></times>
<ci>t</ci>
<ci>h</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i^{th}
  </annotation>
</semantics>
</math>

 bit is uniform over 

<math display="inline" id="Locally_decodable_code:14">
<semantics>
<mrow>
<mo stretchy="false">[</mo>
<mi>N</mi>
<mo stretchy="false">]</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>N</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [N]
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> (The notation 

<math display="inline" id="Locally_decodable_code:15">
<semantics>
<mrow>
<mo stretchy="false">[</mo>
<mi>y</mi>
<mo stretchy="false">]</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>y</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [y]
  </annotation>
</semantics>
</math>

 denotes the set 

<math display="inline" id="Locally_decodable_code:16">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<mn>1</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<cn type="integer">1</cn>
<ci>normal-…</ci>
<ci>y</ci>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{1,\ldots,y\}
  </annotation>
</semantics>
</math>

). Informally, this means that the set of queries required to decode any given bit are uniformly distributed over the codeword.</p>

<p>Local list decoders are another interesting subset of local decoders. List decoding is useful when a codeword is corrupted in more than 

<math display="inline" id="Locally_decodable_code:17">
<semantics>
<mrow>
<mi>δ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>δ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta/2
  </annotation>
</semantics>
</math>

 places, where 

<math display="inline" id="Locally_decodable_code:18">
<semantics>
<mi>δ</mi>
<annotation-xml encoding="MathML-Content">
<ci>δ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta
  </annotation>
</semantics>
</math>

 is the minimum <a href="Hamming_distance" title="wikilink">Hamming distance</a> between two codewords. In this case, it is no longer possible to identify exactly which original message has been encoded, since there could be multiple codewords within 

<math display="inline" id="Locally_decodable_code:19">
<semantics>
<mi>δ</mi>
<annotation-xml encoding="MathML-Content">
<ci>δ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta
  </annotation>
</semantics>
</math>

 distance of the corrupted codeword. However, given a radius 

<math display="inline" id="Locally_decodable_code:20">
<semantics>
<mi>ϵ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ϵ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \epsilon
  </annotation>
</semantics>
</math>

, it is possible to identify the set of messages that encode to codewords that are within 

<math display="inline" id="Locally_decodable_code:21">
<semantics>
<mi>ϵ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ϵ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \epsilon
  </annotation>
</semantics>
</math>

 of the corrupted codeword. An upper bound on the size of the set of messages can be determined by 

<math display="inline" id="Locally_decodable_code:22">
<semantics>
<mi>δ</mi>
<annotation-xml encoding="MathML-Content">
<ci>δ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Locally_decodable_code:23">
<semantics>
<mi>ϵ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ϵ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \epsilon
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Locally decodable codes can also be concatenated, where a message is encoded first using one scheme, and the resulting codeword is encoded again using a different scheme. (Note that, in this context, <a class="uri" href="concatenation" title="wikilink">concatenation</a> is the term used by scholars to refer to what is usually called <a href="function_composition" title="wikilink">composition</a>; see <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>). This might be useful if, for example, the first code has some desirable properties with respect to rate, but it has some undesirable property, such as producing a codeword over a non-binary alphabet. The second code can then transform the result of the first encoding over a non-binary alphabet to a binary alphabet. The final encoding is still locally decodable, and requires additional steps to decode both layers of encoding.<ref></ref></p>
<h2 id="length-of-codeword-and-query-complexity">Length of Codeword and Query Complexity</h2>

<p>The rate of a code refers to the ratio between its message length and codeword length

<math display="block" id="Locally_decodable_code:24">
<semantics>
<mfrac>
<mrow>
<mo stretchy="false">|</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
</mrow>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
</mfrac>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<apply>
<abs></abs>
<ci>x</ci>
</apply>
<apply>
<abs></abs>
<apply>
<times></times>
<ci>C</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{|x|}{|C(x)|}
  </annotation>
</semantics>
</math>

, and the number of queries required to recover 1 bit of the message is called the query complexity of a code.</p>

<p>The rate of a code is inversely related to the query complexity, but the exact shape of this tradeoff is a major open problem.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> It is known that there are no LDCs that query the codeword in only one position, and that the optimal codeword size for query complexity 2 is exponential in the size of the original message.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> However, there are no known tight lower bounds for codes with query complexity greater than 2. Approaching the tradeoff from the side of codeword length, the only known codes with codeword length proportional to message length have query complexity 

<math display="inline" id="Locally_decodable_code:25">
<semantics>
<msup>
<mi>k</mi>
<mi>ϵ</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>k</ci>
<ci>ϵ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k^{\epsilon}
  </annotation>
</semantics>
</math>

 for 

<math display="inline" id="Locally_decodable_code:26">
<semantics>
<mrow>
<mi>ϵ</mi>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gt></gt>
<ci>ϵ</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \epsilon&gt;0
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> There are also codes in between, that have codewords polynomial in the size of the original message and polylogarithmic query complexity.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Locally decodable codes have applications to data transmission and storage, complexity theory, data structures, derandomization, theory of fault tolerant computation, and private information retrieval schemes.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="data-transmission-and-storage">Data Transmission and Storage</h3>

<p>Locally decodable codes are especially useful for data transmission over noisy channels. The Hadamard code (a special case of Reed Muller codes) was used in 1971 by <a href="Mariner_9" title="wikilink">Mariner 9</a> to transmit pictures of Mars back to Earth. It was chosen over a 5-repeat code (where each bit is repeated 5 times) because, for roughly the same number of bits transmitted per pixel, it had a higher capacity for error correction. (The Hadamard code falls under the general umbrella of <a href="forward_error_correction" title="wikilink">forward error correction</a>, and just happens to be locally decodable; the actual algorithm used to decode the transmission from Mars was a generic error-correction scheme.)<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>LDCs are also useful for data storage, where the medium may become partially corrupted over time, or the reading device is subject to errors. In both cases, an LDC will allow for the recovery of information despite errors, provided that there are relatively few. In addition, LDCs do not require that the entire original message be decoded; a user can decode a specific portion of the original message without needing to decode the entire thing.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="complexity-theory">Complexity Theory</h3>

<p>One of the applications of locally decodable codes in <a href="Computational_complexity_theory" title="wikilink">complexity theory</a> is hardness amplification. Using LDCs with polynomial codeword length and polylogarithmic query complexity, one can take a function 

<math display="inline" id="Locally_decodable_code:27">
<semantics>
<mrow>
<mi>L</mi>
<mo>:</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>n</mi>
</msup>
<mo>→</mo>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>L</ci>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>n</ci>
</apply>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L:\{0,1\}^{n}\rightarrow\{0,1\}
  </annotation>
</semantics>
</math>

 that is hard to solve on worst case inputs and design a function 

<math display="inline" id="Locally_decodable_code:28">
<semantics>
<mrow>
<msup>
<mi>L</mi>
<mo>′</mo>
</msup>
<mo>:</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>N</mi>
</msup>
<mo>→</mo>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>L</ci>
<ci>normal-′</ci>
</apply>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>N</ci>
</apply>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L^{\prime}:\{0,1\}^{N}\rightarrow\{0,1\}
  </annotation>
</semantics>
</math>

 that is hard to compute on average case inputs.</p>

<p>Consider 

<math display="inline" id="Locally_decodable_code:29">
<semantics>
<mi>L</mi>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L
  </annotation>
</semantics>
</math>

 limited to only length 

<math display="inline" id="Locally_decodable_code:30">
<semantics>
<mi>t</mi>
<annotation-xml encoding="MathML-Content">
<ci>t</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   t
  </annotation>
</semantics>
</math>

 inputs. Then we can see 

<math display="inline" id="Locally_decodable_code:31">
<semantics>
<mi>L</mi>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L
  </annotation>
</semantics>
</math>

 as a binary string of length 

<math display="inline" id="Locally_decodable_code:32">
<semantics>
<msup>
<mn>2</mn>
<mi>t</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{t}
  </annotation>
</semantics>
</math>

, where each bit is 

<math display="inline" id="Locally_decodable_code:33">
<semantics>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>L</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L(x)
  </annotation>
</semantics>
</math>

 for each 

<math display="inline" id="Locally_decodable_code:34">
<semantics>
<mrow>
<mi>x</mi>
<mo>∈</mo>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>t</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>t</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x\in\{0,1\}^{t}
  </annotation>
</semantics>
</math>

. We can use a polynomial length locally decodable code 

<math display="inline" id="Locally_decodable_code:35">
<semantics>
<mi>C</mi>
<annotation-xml encoding="MathML-Content">
<ci>C</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   C
  </annotation>
</semantics>
</math>

 with polylogarithmic query complexity that tolerates some constant fraction of errors to encode the string that represents 

<math display="inline" id="Locally_decodable_code:36">
<semantics>
<mi>L</mi>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L
  </annotation>
</semantics>
</math>

 to create a new string of length 

<math display="inline" id="Locally_decodable_code:37">
<semantics>
<mrow>
<msup>
<mn>2</mn>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</msup>
<mo>=</mo>
<msup>
<mn>2</mn>
<msup>
<mi>t</mi>
<mo>′</mo>
</msup>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<times></times>
<ci>O</ci>
<ci>t</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<ci>normal-′</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{O(t)}=2^{t^{\prime}}
  </annotation>
</semantics>
</math>

. We think of this new string as defining a new problem 

<math display="inline" id="Locally_decodable_code:38">
<semantics>
<msup>
<mi>L</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>L</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L^{\prime}
  </annotation>
</semantics>
</math>

 on length 

<math display="inline" id="Locally_decodable_code:39">
<semantics>
<msup>
<mi>t</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t^{\prime}
  </annotation>
</semantics>
</math>

 inputs. If 

<math display="inline" id="Locally_decodable_code:40">
<semantics>
<msup>
<mi>L</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>L</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L^{\prime}
  </annotation>
</semantics>
</math>

 is easy to solve on average, that is, we can solve 

<math display="inline" id="Locally_decodable_code:41">
<semantics>
<msup>
<mi>L</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>L</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L^{\prime}
  </annotation>
</semantics>
</math>

 correctly on a large fraction 

<math display="inline" id="Locally_decodable_code:42">
<semantics>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>ϵ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>ϵ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1-\epsilon
  </annotation>
</semantics>
</math>

 of inputs, then by the properties of the LDC used to encode it, we can use 

<math display="inline" id="Locally_decodable_code:43">
<semantics>
<msup>
<mi>L</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>L</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L^{\prime}
  </annotation>
</semantics>
</math>

 to probabilistically compute 

<math display="inline" id="Locally_decodable_code:44">
<semantics>
<mi>L</mi>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L
  </annotation>
</semantics>
</math>

 on all inputs. Thus, a solution to 

<math display="inline" id="Locally_decodable_code:45">
<semantics>
<msup>
<mi>L</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>L</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L^{\prime}
  </annotation>
</semantics>
</math>

 for most inputs would allow us to solve 

<math display="inline" id="Locally_decodable_code:46">
<semantics>
<mi>L</mi>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L
  </annotation>
</semantics>
</math>

 on all inputs, contradicting our assumption that 

<math display="inline" id="Locally_decodable_code:47">
<semantics>
<mi>L</mi>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L
  </annotation>
</semantics>
</math>

 is hard on worst case inputs.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="private-information-retrieval-schemes">Private Information Retrieval Schemes</h3>

<p>A <a href="private_information_retrieval" title="wikilink">private information retrieval</a> scheme allows a user to retrieve an item from a server in possession of a database without revealing which item is retrieved. One common way of ensuring privacy is to have 

<math display="inline" id="Locally_decodable_code:48">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

 separate, non-communicating servers, each with a copy of the database. Given an appropriate scheme, the user can make queries to each server that individually do not reveal which bit the user is looking for, but which together provide enough information that the user can determine the particular bit of interest in the database.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>One can easily see that locally decodable codes have applications in this setting. A general procedure to produce a 

<math display="inline" id="Locally_decodable_code:49">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

-server private information scheme from a perfectly smooth 

<math display="inline" id="Locally_decodable_code:50">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

-query locally decodable code is as follows:</p>

<p>Let 

<math display="inline" id="Locally_decodable_code:51">
<semantics>
<mi>C</mi>
<annotation-xml encoding="MathML-Content">
<ci>C</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   C
  </annotation>
</semantics>
</math>

 be a perfectly smooth LDC that encodes 

<math display="inline" id="Locally_decodable_code:52">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

-bit messages to 

<math display="inline" id="Locally_decodable_code:53">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

-bit codewords. As a preprocessing step, each of the 

<math display="inline" id="Locally_decodable_code:54">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

 servers 

<math display="inline" id="Locally_decodable_code:55">
<semantics>
<mrow>
<msub>
<mi>S</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>S</mi>
<mi>k</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>S</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>S</ci>
<ci>k</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   S_{1},\ldots,S_{k}
  </annotation>
</semantics>
</math>

 encodes the 

<math display="inline" id="Locally_decodable_code:56">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

-bit database 

<math display="inline" id="Locally_decodable_code:57">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 with the code 

<math display="inline" id="Locally_decodable_code:58">
<semantics>
<mi>C</mi>
<annotation-xml encoding="MathML-Content">
<ci>C</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   C
  </annotation>
</semantics>
</math>

, so each server now stores the 

<math display="inline" id="Locally_decodable_code:59">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

-bit codeword 

<math display="inline" id="Locally_decodable_code:60">
<semantics>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>C</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C(x)
  </annotation>
</semantics>
</math>

. A user interested in obtaining the 

<math display="inline" id="Locally_decodable_code:61">
<semantics>
<msup>
<mi>i</mi>
<mrow>
<mi>t</mi>
<mi>h</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>i</ci>
<apply>
<times></times>
<ci>t</ci>
<ci>h</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i^{th}
  </annotation>
</semantics>
</math>

 bit of 

<math display="inline" id="Locally_decodable_code:62">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 randomly generates a set of 

<math display="inline" id="Locally_decodable_code:63">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

 queries 

<math display="inline" id="Locally_decodable_code:64">
<semantics>
<mrow>
<msub>
<mi>q</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mrow>
<mi mathvariant="normal">…</mi>
<msub>
<mi>q</mi>
<mi>k</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<ci>k</ci>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   q_{1},\ldots q_{k}
  </annotation>
</semantics>
</math>

 such that 

<math display="inline" id="Locally_decodable_code:65">
<semantics>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}
  </annotation>
</semantics>
</math>

 can be computed from 

<math display="inline" id="Locally_decodable_code:66">
<semantics>
<mrow>
<mrow>
<mi>C</mi>
<msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>q</mi>
<mn>1</mn>
</msub>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mi mathvariant="normal">…</mi>
<mi>C</mi>
<msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>q</mi>
<mi>k</mi>
</msub>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<times></times>
<ci>C</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>normal-…</ci>
<ci>C</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   C(x)_{q_{1}},\ldots C(x)_{q_{k}}
  </annotation>
</semantics>
</math>

 using the local decoding algorithm 

<math display="inline" id="Locally_decodable_code:67">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 for 

<math display="inline" id="Locally_decodable_code:68">
<semantics>
<mi>C</mi>
<annotation-xml encoding="MathML-Content">
<ci>C</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   C
  </annotation>
</semantics>
</math>

. The user sends each query to a different server, and each server responds with the bit requested. The user then uses 

<math display="inline" id="Locally_decodable_code:69">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 to compute 

<math display="inline" id="Locally_decodable_code:70">
<semantics>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}
  </annotation>
</semantics>
</math>

 from the responses.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Because the decoding algorithm is perfectly smooth, each query 

<math display="inline" id="Locally_decodable_code:71">
<semantics>
<msub>
<mi>q</mi>
<mi>j</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   q_{j}
  </annotation>
</semantics>
</math>

 is uniformly distributed over the codeword; thus, no individual server can gain any information about the user's intentions, so the protocol is private as long as the servers do not communicate.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h2 id="examples">Examples</h2>
<h3 id="the-hadamard-code">The Hadamard code</h3>

<p>The <a class="uri" href="Hadamard" title="wikilink">Hadamard</a> (or Walsh-Hadamard) code is an example of a simple locally decodable code that maps a string of length 

<math display="inline" id="Locally_decodable_code:72">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

 to a codeword of length 

<math display="inline" id="Locally_decodable_code:73">
<semantics>
<msup>
<mn>2</mn>
<mi>k</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{k}
  </annotation>
</semantics>
</math>

. The codeword for a string 

<math display="inline" id="Locally_decodable_code:74">
<semantics>
<mrow>
<mi>x</mi>
<mo>∈</mo>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>k</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x\in\{0,1\}^{k}
  </annotation>
</semantics>
</math>

 is constructed as follows: for every 

<math display="inline" id="Locally_decodable_code:75">
<semantics>
<mrow>
<msub>
<mi>a</mi>
<mi>j</mi>
</msub>
<mo>∈</mo>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>k</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>j</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a_{j}\in\{0,1\}^{k}
  </annotation>
</semantics>
</math>

, the 

<math display="inline" id="Locally_decodable_code:76">
<semantics>
<msup>
<mi>j</mi>
<mrow>
<mi>t</mi>
<mi>h</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<apply>
<times></times>
<ci>t</ci>
<ci>h</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j^{th}
  </annotation>
</semantics>
</math>

 bit of the codeword is equal to 

<math display="inline" id="Locally_decodable_code:77">
<semantics>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<msub>
<mi>a</mi>
<mi>j</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x\odot a_{j}
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Locally_decodable_code:78">
<semantics>
<mrow>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<mi>y</mi>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>k</mi>
</munderover>
<mrow>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<ci>y</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x\odot y=\sum\limits_{i=1}^{k}x_{i}y_{i}
  </annotation>
</semantics>
</math>

 (mod 2). It is easy to see that every codeword has a <a href="Hamming_distance" title="wikilink">Hamming distance</a> of 

<math display="inline" id="Locally_decodable_code:79">
<semantics>
<mfrac>
<mi>n</mi>
<mn>2</mn>
</mfrac>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{n}{2}
  </annotation>
</semantics>
</math>

 from every other codeword.</p>

<p>The local decoding algorithm has query complexity 2, and the entire original message can be decoded with good probability if the codeword is corrupted in less than 

<math display="inline" id="Locally_decodable_code:80">
<semantics>
<mfrac>
<mn>1</mn>
<mn>4</mn>
</mfrac>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{1}{4}
  </annotation>
</semantics>
</math>

 of its bits. For 

<math display="inline" id="Locally_decodable_code:81">
<semantics>
<mrow>
<mi>ρ</mi>
<mo>&lt;</mo>
<mfrac>
<mn>1</mn>
<mn>4</mn>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<lt></lt>
<ci>ρ</ci>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">4</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \rho&lt;\frac{1}{4}
  </annotation>
</semantics>
</math>

, if the codeword is corrupted in a 

<math display="inline" id="Locally_decodable_code:82">
<semantics>
<mi>ρ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ρ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \rho
  </annotation>
</semantics>
</math>

 fraction of places, a local decoding algorithm can recover the 

<math display="inline" id="Locally_decodable_code:83">
<semantics>
<msup>
<mi>i</mi>
<mrow>
<mi>t</mi>
<mi>h</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>i</ci>
<apply>
<times></times>
<ci>t</ci>
<ci>h</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i^{th}
  </annotation>
</semantics>
</math>

 bit of the original message with probability 

<math display="inline" id="Locally_decodable_code:84">
<semantics>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>ρ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>ρ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1-2\rho
  </annotation>
</semantics>
</math>

.</p>

<p>Proof: Given a codeword 

<math display="inline" id="Locally_decodable_code:85">
<semantics>
<mi>H</mi>
<annotation-xml encoding="MathML-Content">
<ci>H</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   H
  </annotation>
</semantics>
</math>

 and an index 

<math display="inline" id="Locally_decodable_code:86">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

, the algorithm to recover the 

<math display="inline" id="Locally_decodable_code:87">
<semantics>
<msup>
<mi>i</mi>
<mrow>
<mi>t</mi>
<mi>h</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>i</ci>
<apply>
<times></times>
<ci>t</ci>
<ci>h</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i^{th}
  </annotation>
</semantics>
</math>

 bit of the original message 

<math display="inline" id="Locally_decodable_code:88">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 works as follows:</p>

<p>Let 

<math display="inline" id="Locally_decodable_code:89">
<semantics>
<msup>
<mi>e</mi>
<mi>j</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   e^{j}
  </annotation>
</semantics>
</math>

 refer to the vector in 

<math display="inline" id="Locally_decodable_code:90">
<semantics>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>k</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{0,1\}^{k}
  </annotation>
</semantics>
</math>

 that has 1 in the 

<math display="inline" id="Locally_decodable_code:91">
<semantics>
<msup>
<mi>j</mi>
<mrow>
<mi>t</mi>
<mi>h</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<apply>
<times></times>
<ci>t</ci>
<ci>h</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j^{th}
  </annotation>
</semantics>
</math>

 position and 0s elsewhere. For 

<math display="inline" id="Locally_decodable_code:92">
<semantics>
<mrow>
<mi>y</mi>
<mo>∈</mo>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>k</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y\in\{0,1\}^{k}
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Locally_decodable_code:93">
<semantics>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>f</ci>
<ci>y</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(y)
  </annotation>
</semantics>
</math>

 denotes the single bit in 

<math display="inline" id="Locally_decodable_code:94">
<semantics>
<mi>H</mi>
<annotation-xml encoding="MathML-Content">
<ci>H</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   H
  </annotation>
</semantics>
</math>

 that corresponds to 

<math display="inline" id="Locally_decodable_code:95">
<semantics>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<mi>y</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<ci>y</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x\odot y
  </annotation>
</semantics>
</math>

. The algorithm chooses a random vector 

<math display="inline" id="Locally_decodable_code:96">
<semantics>
<mrow>
<mi>y</mi>
<mo>∈</mo>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>k</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y\in\{0,1\}^{k}
  </annotation>
</semantics>
</math>

 and the vector 

<math display="inline" id="Locally_decodable_code:97">
<semantics>
<mrow>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo>=</mo>
<mrow>
<mi>y</mi>
<mo>⊗</mo>
<msup>
<mi>e</mi>
<mi>i</mi>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="latexml">tensor-product</csymbol>
<ci>y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y^{\prime}=y\otimes e^{i}
  </annotation>
</semantics>
</math>

 (where 

<math display="inline" id="Locally_decodable_code:98">
<semantics>
<mo>⊗</mo>
<annotation-xml encoding="MathML-Content">
<csymbol cd="latexml">tensor-product</csymbol>
</annotation-xml>
<annotation encoding="application/x-tex">
   \otimes
  </annotation>
</semantics>
</math>

 denotes <a href="bitwise_XOR" title="wikilink">bitwise XOR</a>). The algorithm outputs 

<math display="inline" id="Locally_decodable_code:99">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>⊗</mo>
<mi>f</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="latexml">tensor-product</csymbol>
<apply>
<times></times>
<ci>f</ci>
<ci>y</ci>
</apply>
<ci>f</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(y)\otimes f(y^{\prime})
  </annotation>
</semantics>
</math>

 (mod 2).</p>

<p>Correctness: By linearity,</p>

<p>
<math display="inline" id="Locally_decodable_code:100">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⊗</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⊗</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>y</mi>
<mo>⊗</mo>
<msup>
<mi>e</mi>
<mi>i</mi>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⊗</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⊗</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<msup>
<mi>e</mi>
<mi>i</mi>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<msup>
<mi>e</mi>
<mi>i</mi>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">tensor-product</csymbol>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<ci>y</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="latexml">tensor-product</csymbol>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<ci>y</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="latexml">tensor-product</csymbol>
<ci>y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<csymbol cd="latexml">tensor-product</csymbol>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<ci>y</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<ci>y</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (x\odot y)\otimes(x\odot y^{\prime})=(x\odot y)\otimes(x\odot(y\otimes e^{i}))%
=(x\odot y)\otimes(x\odot y)\otimes(x\odot e^{i})=x\odot e^{i}
  </annotation>
</semantics>
</math>
</p>

<p>But 

<math display="inline" id="Locally_decodable_code:101">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<msup>
<mi>e</mi>
<mi>i</mi>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (x\odot e^{i})=x_{i}
  </annotation>
</semantics>
</math>

, so we just need to show that 

<math display="inline" id="Locally_decodable_code:102">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<mi>y</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<ci>y</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<ci>y</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(y)=x\odot y
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Locally_decodable_code:103">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(y^{\prime})=x\odot y^{\prime}
  </annotation>
</semantics>
</math>

 with good probability.</p>

<p>Since 

<math display="inline" id="Locally_decodable_code:104">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Locally_decodable_code:105">
<semantics>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y^{\prime}
  </annotation>
</semantics>
</math>

 are uniformly distributed (even though they are dependent), the <a href="union_bound" title="wikilink">union bound</a> implies that 

<math display="inline" id="Locally_decodable_code:106">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<mi>y</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<ci>y</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<ci>y</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(y)=x\odot y
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Locally_decodable_code:107">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>x</mi>
<mo>⊙</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">direct-product</csymbol>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(y^{\prime})=x\odot y^{\prime}
  </annotation>
</semantics>
</math>

 with probability at least 

<math display="inline" id="Locally_decodable_code:108">
<semantics>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>ρ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>ρ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1-2\rho
  </annotation>
</semantics>
</math>

. Note: to amplify the probability of success, one can repeat the procedure with different random vectors and take the majority answer. <a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h3 id="the-reedmuller-code">The Reed–Muller code</h3>

<p>The main idea behind local decoding of <a href="Reed-Muller_codes" title="wikilink">Reed-Muller codes</a> is <a href="polynomial_interpolation" title="wikilink">polynomial interpolation</a>. The key concept behind a Reed-Muller code is a multivariate polynomial of degree 

<math display="inline" id="Locally_decodable_code:109">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 on 

<math display="inline" id="Locally_decodable_code:110">
<semantics>
<mi>l</mi>
<annotation-xml encoding="MathML-Content">
<ci>l</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   l
  </annotation>
</semantics>
</math>

 variables. The message is treated as the evaluation of a polynomial at a set of predefined points. To encode these values, a polynomial is extrapolated from them, and the codeword is the evaluation of that polynomial on all possible points. At a high level, to decode a point of this polynomial, the decoding algorithm chooses a set 

<math display="inline" id="Locally_decodable_code:111">
<semantics>
<mi>S</mi>
<annotation-xml encoding="MathML-Content">
<ci>S</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   S
  </annotation>
</semantics>
</math>

 of points on a line that passes through the point of interest 

<math display="inline" id="Locally_decodable_code:112">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

. It then queries the codeword for the evaluation of the polynomial on points in 

<math display="inline" id="Locally_decodable_code:113">
<semantics>
<mi>S</mi>
<annotation-xml encoding="MathML-Content">
<ci>S</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   S
  </annotation>
</semantics>
</math>

 and interpolates that polynomial. Then it is simple to evaluate the polynomial at the point that will yield 

<math display="inline" id="Locally_decodable_code:114">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

. This roundabout way of evaluating 

<math display="inline" id="Locally_decodable_code:115">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 is useful because (a) the algorithm can be repeated using different lines through the same point to improve the probability of correctness, and (b) the queries are uniformly distributed over the codeword.</p>

<p>More formally, let 

<math display="inline" id="Locally_decodable_code:116">
<semantics>
<mi>𝔽</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝔽</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}
  </annotation>
</semantics>
</math>

 be a finite field, and let 

<math display="inline" id="Locally_decodable_code:117">
<semantics>
<mrow>
<mi>l</mi>
<mo>,</mo>
<mi>d</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>l</ci>
<ci>d</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   l,d
  </annotation>
</semantics>
</math>

 be numbers with 

<math display="inline" id="Locally_decodable_code:118">
<semantics>
<mrow>
<mi>d</mi>
<mo>&lt;</mo>
<mrow>
<mo stretchy="false">|</mo>
<mi>𝔽</mi>
<mo stretchy="false">|</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<lt></lt>
<ci>d</ci>
<apply>
<abs></abs>
<ci>𝔽</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d&lt;|\mathbb{F}|
  </annotation>
</semantics>
</math>

. The Reed-Muller code with parameters 

<math display="inline" id="Locally_decodable_code:119">
<semantics>
<mrow>
<mi>𝔽</mi>
<mo>,</mo>
<mi>l</mi>
<mo>,</mo>
<mi>d</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>𝔽</ci>
<ci>l</ci>
<ci>d</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F},l,d
  </annotation>
</semantics>
</math>

 is the function RM 

<math display="block" id="Locally_decodable_code:120">
<semantics>
<mrow>
<msup>
<mi>𝔽</mi>
<mrow>
<mo>(</mo>
<mstyle scriptlevel="+1">
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mrow>
<mi>l</mi>
<mo>+</mo>
<mi>d</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>d</mi>
</mtd>
</mtr>
</mtable>
</mstyle>
<mo>)</mo>
</mrow>
</msup>
<mo>→</mo>
<msup>
<mi>𝔽</mi>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mi>𝔽</mi>
<mo stretchy="false">|</mo>
</mrow>
<mi>l</mi>
</msup>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝔽</ci>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<apply>
<plus></plus>
<ci>l</ci>
<ci>d</ci>
</apply>
<ci>d</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝔽</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<ci>𝔽</ci>
</apply>
<ci>l</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}^{{\left({{l+d}\atop{d}}\right)}}\rightarrow\mathbb{F}^{|\mathbb{F}|%
^{l}}
  </annotation>
</semantics>
</math>

 that maps every 

<math display="inline" id="Locally_decodable_code:121">
<semantics>
<mi>l</mi>
<annotation-xml encoding="MathML-Content">
<ci>l</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   l
  </annotation>
</semantics>
</math>

-variable polynomial 

<math display="inline" id="Locally_decodable_code:122">
<semantics>
<mi>P</mi>
<annotation-xml encoding="MathML-Content">
<ci>P</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   P
  </annotation>
</semantics>
</math>

 over 

<math display="inline" id="Locally_decodable_code:123">
<semantics>
<mi>𝔽</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝔽</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}
  </annotation>
</semantics>
</math>

 of total degree 

<math display="inline" id="Locally_decodable_code:124">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 to the values of 

<math display="inline" id="Locally_decodable_code:125">
<semantics>
<mi>P</mi>
<annotation-xml encoding="MathML-Content">
<ci>P</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   P
  </annotation>
</semantics>
</math>

 on all the inputs in 

<math display="inline" id="Locally_decodable_code:126">
<semantics>
<msup>
<mi>𝔽</mi>
<mi>l</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝔽</ci>
<ci>l</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}^{l}
  </annotation>
</semantics>
</math>

. That is, the input is a polynomial of the form 

<math display="inline" id="Locally_decodable_code:127">
<semantics>
<mrow>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mi>l</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mrow>
<msub>
<mi>i</mi>
<mn>1</mn>
</msub>
<mo>+</mo>
<mi mathvariant="normal">…</mi>
<mo>+</mo>
<msub>
<mi>i</mi>
<mi>l</mi>
</msub>
</mrow>
<mo>≤</mo>
<mi>d</mi>
</mrow>
</munder>
<mrow>
<msub>
<mi>c</mi>
<mrow>
<msub>
<mi>i</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>i</mi>
<mi>l</mi>
</msub>
</mrow>
</msub>
<msubsup>
<mi>x</mi>
<mn>1</mn>
<msub>
<mi>i</mi>
<mn>1</mn>
</msub>
</msubsup>
<msubsup>
<mi>x</mi>
<mn>2</mn>
<msub>
<mi>i</mi>
<mn>2</mn>
</msub>
</msubsup>
<mi mathvariant="normal">⋯</mi>
<msubsup>
<mi>x</mi>
<mi>l</mi>
<msub>
<mi>i</mi>
<mi>l</mi>
</msub>
</msubsup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>P</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>l</ci>
</apply>
</vector>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<leq></leq>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<ci>l</ci>
</apply>
</apply>
<ci>d</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<ci>l</ci>
</apply>
</list>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>normal-⋯</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>l</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<ci>l</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(x_{1},\ldots,x_{l})=\sum\limits_{i_{1}+\ldots+i_{l}\leq d}c_{i_{1},\ldots,i_%
{l}}x_{1}^{i_{1}}x_{2}^{i_{2}}\cdots x_{l}^{i_{l}}
  </annotation>
</semantics>
</math>

 specified by the interpolation of the 

<math display="inline" id="Locally_decodable_code:128">
<semantics>
<mrow>
<mo>(</mo>
<mstyle scriptlevel="+1">
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mrow>
<mi>l</mi>
<mo>+</mo>
<mi>d</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>d</mi>
</mtd>
</mtr>
</mtable>
</mstyle>
<mo>)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">binomial</csymbol>
<apply>
<plus></plus>
<ci>l</ci>
<ci>d</ci>
</apply>
<ci>d</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   {\left({{l+d}\atop{d}}\right)}
  </annotation>
</semantics>
</math>

 values of the predefined points and the output is the sequence 

<math display="inline" id="Locally_decodable_code:129">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mi>l</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<apply>
<times></times>
<ci>P</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>l</ci>
</apply>
</vector>
</apply>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{P(x_{1},\ldots,x_{l})\}
  </annotation>
</semantics>
</math>

 for every 

<math display="inline" id="Locally_decodable_code:130">
<semantics>
<mrow>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mi>l</mi>
</msub>
</mrow>
<mo>∈</mo>
<mi>𝔽</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>l</ci>
</apply>
</list>
<ci>𝔽</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{1},\ldots,x_{l}\in\mathbb{F}
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>

<p>To recover the value of a degree 

<math display="inline" id="Locally_decodable_code:131">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 polynomial at a point 

<math display="inline" id="Locally_decodable_code:132">
<semantics>
<mrow>
<mi>w</mi>
<mo>∈</mo>
<msup>
<mi>𝔽</mi>
<mi>n</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>w</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝔽</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w\in\mathbb{F}^{n}
  </annotation>
</semantics>
</math>

, the local decoder shoots a random <a href="affine_geometry" title="wikilink">affine</a> line through 

<math display="inline" id="Locally_decodable_code:133">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

. Then it picks 

<math display="inline" id="Locally_decodable_code:134">
<semantics>
<mrow>
<mi>d</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>d</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d+1
  </annotation>
</semantics>
</math>

 points on that line, which it uses to interpolate the polynomial and then evaluate it at the point where the result is 

<math display="inline" id="Locally_decodable_code:135">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

. To do so, the algorithm picks a vector 

<math display="inline" id="Locally_decodable_code:136">
<semantics>
<mrow>
<mi>v</mi>
<mo>∈</mo>
<msup>
<mi>𝔽</mi>
<mi>n</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>v</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝔽</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   v\in\mathbb{F}^{n}
  </annotation>
</semantics>
</math>

 uniformly at random and considers the line 

<math display="inline" id="Locally_decodable_code:137">
<semantics>
<mrow>
<mi>L</mi>
<mo>=</mo>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mi>w</mi>
<mo>+</mo>
<mrow>
<mi>λ</mi>
<mi>v</mi>
</mrow>
</mrow>
<mo>∣</mo>
<mrow>
<mi>λ</mi>
<mo>∈</mo>
<mi>𝔽</mi>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>L</ci>
<apply>
<csymbol cd="latexml">conditional-set</csymbol>
<apply>
<plus></plus>
<ci>w</ci>
<apply>
<times></times>
<ci>λ</ci>
<ci>v</ci>
</apply>
</apply>
<apply>
<in></in>
<ci>λ</ci>
<ci>𝔽</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L=\{w+\lambda v\mid\lambda\in\mathbb{F}\}
  </annotation>
</semantics>
</math>

 through 

<math display="inline" id="Locally_decodable_code:138">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

. The algorithm picks an arbitrary subset 

<math display="inline" id="Locally_decodable_code:139">
<semantics>
<mi>S</mi>
<annotation-xml encoding="MathML-Content">
<ci>S</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   S
  </annotation>
</semantics>
</math>

 of 

<math display="inline" id="Locally_decodable_code:140">
<semantics>
<mi>𝔽</mi>
<annotation-xml encoding="MathML-Content">
<ci>𝔽</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{F}
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Locally_decodable_code:141">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mi>S</mi>
<mo stretchy="false">|</mo>
</mrow>
<mo>=</mo>
<mrow>
<mi>d</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<abs></abs>
<ci>S</ci>
</apply>
<apply>
<plus></plus>
<ci>d</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |S|=d+1
  </annotation>
</semantics>
</math>

, and queries coordinates of the codeword that correspond to points 

<math display="inline" id="Locally_decodable_code:142">
<semantics>
<mrow>
<mi>w</mi>
<mo>+</mo>
<mrow>
<mi>λ</mi>
<mi>v</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>w</ci>
<apply>
<times></times>
<ci>λ</ci>
<ci>v</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w+\lambda v
  </annotation>
</semantics>
</math>

 for all 

<math display="inline" id="Locally_decodable_code:143">
<semantics>
<mrow>
<mi>λ</mi>
<mo>∈</mo>
<mi>S</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>λ</ci>
<ci>S</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda\in S
  </annotation>
</semantics>
</math>

 and obtains values 

<math display="inline" id="Locally_decodable_code:144">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<msub>
<mi>e</mi>
<mi>λ</mi>
</msub>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>λ</ci>
</apply>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{e_{\lambda}\}
  </annotation>
</semantics>
</math>

. Then it uses polynomial interpolation to recover the unique univariate polynomial 

<math display="inline" id="Locally_decodable_code:145">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

 with degree less than or equal to 

<math display="inline" id="Locally_decodable_code:146">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 such that 

<math display="inline" id="Locally_decodable_code:147">
<semantics>
<mrow>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>λ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<msub>
<mi>e</mi>
<mi>λ</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>h</ci>
<ci>λ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>λ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h(\lambda)=e_{\lambda}
  </annotation>
</semantics>
</math>

 for all 

<math display="inline" id="Locally_decodable_code:148">
<semantics>
<mrow>
<mi>λ</mi>
<mo>∈</mo>
<mi>S</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>λ</ci>
<ci>S</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda\in S
  </annotation>
</semantics>
</math>

. Then, to get the value of 

<math display="inline" id="Locally_decodable_code:149">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

, it just evaluates 

<math display="inline" id="Locally_decodable_code:150">
<semantics>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>h</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h(0)
  </annotation>
</semantics>
</math>

. To recover a single value of the original message, one chooses 

<math display="inline" id="Locally_decodable_code:151">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

 to be one of the points that defines the polynomial.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>Each individual query is distributed uniformly at random over the codeword. Thus, if the codeword is corrupted in at most a 

<math display="inline" id="Locally_decodable_code:152">
<semantics>
<mi>δ</mi>
<annotation-xml encoding="MathML-Content">
<ci>δ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta
  </annotation>
</semantics>
</math>

 fraction of locations, by the union bound, the probability that the algorithm samples only uncorrupted coordinates (and thus correctly recovers the bit) is at least 

<math display="inline" id="Locally_decodable_code:153">
<semantics>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>d</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>δ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<apply>
<plus></plus>
<ci>d</ci>
<cn type="integer">1</cn>
</apply>
<ci>δ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1-(d+1)\delta
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> For other decoding algorithms, see.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Private_information_retrieval" title="wikilink">Private information retrieval</a></li>
<li><a href="Linear_cryptanalysis" title="wikilink">Linear cryptanalysis</a></li>
</ul>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Sergey Yekhanin. New locally decodable codes and private information retrieval schemes, <a href="http://www.eccc.hpi-web.de/eccc-reports/2006/TR06-127/index.html">Technical Report ECCC TR06-127</a>, 2006.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
</ol>
</section>
</body>
</html>
