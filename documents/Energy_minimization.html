<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1890">Energy minimization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Energy minimization</h1>
<hr/>

<p></p>

<p>In the field of <a href="computational_chemistry" title="wikilink">computational chemistry</a>, <strong>energy minimization</strong> (also called <strong>energy optimization</strong>, <strong>geometry minimization</strong>, or <strong>geometry optimization</strong>) is the process of finding an arrangement in space of a collection of atoms where, according to some computational model of chemical bonding, the net inter-atomic force on each atom is acceptably close to zero and the position on the <a href="potential_energy_surface" title="wikilink">potential energy surface</a> (PES) is a stationary point (described later). The collection of atoms might be a single <a class="uri" href="molecule" title="wikilink">molecule</a>, an <a class="uri" href="ion" title="wikilink">ion</a>, a <a href="condensed_phase" title="wikilink">condensed phase</a>, a <a href="transition_state" title="wikilink">transition state</a> or even a collection of any of these. The computational model of chemical bonding might, for example, be quantum mechanics.</p>

<p>As an example, when optimizing the geometry of a <a href="Water_(molecule)" title="wikilink">water molecule</a>, one aims to obtain the hydrogen-oxygen bond lengths and the hydrogen-oxygen-hydrogen bond angle which minimize the forces that would otherwise be pulling atoms together or pushing them apart.</p>

<p>The motivation for performing a geometry optimization is the physical significance of the obtained structure: optimized structures often correspond to a substance as it is found in nature and the geometry of such a structure can be used in a variety of experimental and theoretical investigations in the fields of <a href="chemical_structure" title="wikilink">chemical structure</a>, <a class="uri" href="thermodynamics" title="wikilink">thermodynamics</a>, <a href="chemical_kinetics" title="wikilink">chemical kinetics</a>, <a class="uri" href="spectroscopy" title="wikilink">spectroscopy</a> and others.</p>

<p>Typically, but not always, the process seeks to find the geometry of a particular arrangement of the atoms that represents a local or global energy minimum. Instead of searching for global energy minimum, it might be desirable to optimize to a <a href="transition_state" title="wikilink">transition state</a>, that is, a saddle point on the potential energy surface.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Additionally, certain coordinates (such as a chemical bond length) might be fixed during the optimization.</p>
<h2 id="molecular-geometry-and-mathematical-interpretation">Molecular geometry and mathematical interpretation</h2>

<p>The geometry of a set of atoms can be described by a vector of the atoms' positions. This could be the set of the Cartesian coordinates of the atoms or, when considering molecules, might be so called <em>internal coordinates</em> formed from a set of bond lengths, bond angles and dihedral angles.</p>

<p>Given a set of atoms and a vector, 

<math display="inline" id="Energy_minimization:0">
 <semantics>
  <mi>𝐫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}
  </annotation>
 </semantics>
</math>

, describing the atoms' positions, one can introduce the concept of the energy as a function of the positions, 

<math display="inline" id="Energy_minimization:1">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐫</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbf{r})
  </annotation>
 </semantics>
</math>

. Geometry optimization is then a <a href="mathematical_optimization" title="wikilink">mathematical optimization</a> problem, in which it is desired to find the value of 

<math display="inline" id="Energy_minimization:2">
 <semantics>
  <mi>𝐫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}
  </annotation>
 </semantics>
</math>

 for which 

<math display="inline" id="Energy_minimization:3">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐫</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbf{r})
  </annotation>
 </semantics>
</math>

 is at a <a href="local_minimum" title="wikilink">local minimum</a>, that is, the derivative of the energy with respect to the position of the atoms, 

<math display="inline" id="Energy_minimization:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">∂</mi>
     <mi>E</mi>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">∂</mi>
   </mrow>
   <mi>𝐫</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-∂</ci>
      <ci>E</ci>
     </apply>
     <ci>normal-∂</ci>
    </apply>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∂E/∂\mathbf{r}
  </annotation>
 </semantics>
</math>

, is the zero vector and the second derivative matrix of the system, <mtpl></mtpl>, also known as the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a>, which describes the curvature of the PES at 

<math display="inline" id="Energy_minimization:5">
 <semantics>
  <mi>𝐫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}
  </annotation>
 </semantics>
</math>

, has all positive <a href="Eigen_values" title="wikilink">Eigen values</a> (is <a href="Positive-definite_matrix" title="wikilink">positive definite</a>).</p>

<p>A special case of a geometry optimization is a search for the geometry of a <a href="transition_state" title="wikilink">transition state</a>, and this is discussed in a dedicated section below.</p>

<p>The computational model that provides an approximate 

<math display="inline" id="Energy_minimization:6">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐫</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbf{r})
  </annotation>
 </semantics>
</math>

 could be based on <a href="Quantum_chemistry" title="wikilink">quantum mechanics</a> (using either <a href="density_functional_theory" title="wikilink">density functional theory</a> or <a href="Semi-empirical_quantum_chemistry_method" title="wikilink">semi-empirical methods</a>), <a href="Force_field_(chemistry)" title="wikilink">force fields</a>, or a combination of those in case of <a class="uri" href="QM/MM" title="wikilink">QM/MM</a>. Using this computational model and an initial guess (or <a class="uri" href="ansatz" title="wikilink">ansatz</a>) of the correct geometry, an iterative optimization procedure is followed, for example:</p>
<ol>
<li>calculate the force on each atom (that is, 

<math display="inline" id="Energy_minimization:7">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">∂</mi>
      <mi>E</mi>
     </mrow>
     <mo>/</mo>
     <mi mathvariant="normal">∂</mi>
    </mrow>
    <mi>𝐫</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>normal-∂</ci>
       <ci>E</ci>
      </apply>
      <ci>normal-∂</ci>
     </apply>
     <ci>𝐫</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -∂E/∂\mathbf{r}
  </annotation>
 </semantics>
</math>

)</li>
<li>if the force is less than some threshold, <strong>finish</strong></li>
<li>otherwise, move the atoms by some computed step 

<math display="inline" id="Energy_minimization:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">∆</mi>
   <mi>𝐫</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-∆</ci>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∆\mathbf{r}
  </annotation>
 </semantics>
</math>

 that is predicted to reduce the force</li>
<li>'''repeat '''from the start</li>
</ol>
<h2 id="practical-aspects-of-optimization">Practical aspects of optimization</h2>

<p>As described above, some method such as quantum mechanics can be used to calculate the energy, 

<math display="inline" id="Energy_minimization:9">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐫</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbf{r})
  </annotation>
 </semantics>
</math>

, the gradient of the PES, that is, the derivative of the energy with respect to the position of the atoms, 

<math display="inline" id="Energy_minimization:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">∂</mi>
     <mi>E</mi>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">∂</mi>
   </mrow>
   <mi>𝐫</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-∂</ci>
      <ci>E</ci>
     </apply>
     <ci>normal-∂</ci>
    </apply>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∂E/∂\mathbf{r}
  </annotation>
 </semantics>
</math>

 and the second derivative matrix of the system, <mtpl></mtpl>, also known as the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a>, which describes the curvature of the PES at 

<math display="inline" id="Energy_minimization:11">
 <semantics>
  <mi>𝐫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}
  </annotation>
 </semantics>
</math>

.</p>

<p>An <a href="Optimization_(mathematics)" title="wikilink">optimization</a> algorithm can use some or all of 

<math display="inline" id="Energy_minimization:12">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐫</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbf{r})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Energy_minimization:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">∂</mi>
     <mi>E</mi>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">∂</mi>
   </mrow>
   <mi>𝐫</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-∂</ci>
      <ci>E</ci>
     </apply>
     <ci>normal-∂</ci>
    </apply>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∂E/∂\mathbf{r}
  </annotation>
 </semantics>
</math>

 and <mtpl></mtpl> to try to minimize the forces and this could in theory be any method such as gradient descent, conjugate gradient or Newton's method, but in practice, algorithms which use knowledge of the PES curvature, that is the Hessian matrix, are found to be superior. For most systems of practical interest, however, it may be prohibitively expensive to compute the second derivative matrix, and it is estimated from successive values of the gradient, as is typical in a <a href="Quasi-Newton_method" title="wikilink">Quasi-Newton</a> optimization.</p>

<p>The choice of the coordinate system can be crucial for performing a successful optimization. Cartesian coordinates, for example, are redundant since a non-linear molecule with 

<math display="inline" id="Energy_minimization:14">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 atoms has 

<math display="inline" id="Energy_minimization:15">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mi>N</mi>
   <mi mathvariant="normal">–</mi>
   <mn>6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">3</cn>
    <ci>N</ci>
    <ci>normal-–</ci>
    <cn type="integer">6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3N–6
  </annotation>
 </semantics>
</math>

 vibrational <a href="Degrees_of_freedom_(physics_and_chemistry)" title="wikilink">degrees of freedom</a> whereas the set of Cartesian coordinates has 

<math display="inline" id="Energy_minimization:16">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">3</cn>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3N
  </annotation>
 </semantics>
</math>

 dimensions. Additionally, Cartesian coordinates are highly correlated, that is, the Hessian matrix has many non-diagonal terms that are not close to zero. This can lead to numerical problems in the optimization, because, for example, it is difficult to obtain a good approximation to the Hessian matrix and calculating it precisely is too computationally expensive. Internal coordinates tend to be less correlated but are more difficult to set-up and it can be difficult to describe some systems, such as ones with symmetry or large condensed phases.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Many modern computational chemistry software packages contain automatic procedures for the automatic generation of reasonable coordinate systems for optimization.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="degree-of-freedom-restriction">Degree of freedom restriction</h3>

<p>Some degrees of freedom can be eliminated from an optimization, for example, positions of atoms or bond lengths and angles can be given fixed values. Sometimes these are referred to as being <em>frozen</em> degrees of freedom.</p>

<p>Figure 1 depicts a geometry optimization of the atoms in a carbon nanotube in the presence of an external electrostatic field. In this optimization, the atoms on the left have their positions frozen. Their interaction with the other atoms in the system are still calculated, but alteration the atoms' position during the optimization is prevented.</p>
<figure><b>(Figure)</b>
<figcaption>Figure 1: <a href="Electrostatic_deflection_(structural_element)" title="wikilink">Electrostatic deflections</a> of a <a href="carbon_nanotube" title="wikilink">carbon nanotube</a> in an <a href="electric_field" title="wikilink">electric field</a>. </figcaption>
</figure>
<h2 id="transition-state-optimization">Transition state optimization</h2>

<p><a href="Transition_state" title="wikilink">Transition state</a> structures can be determined by searching for <a href="saddle_points" title="wikilink">saddle points</a> on the PES of the chemical species of interest.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A first-order saddle point is a position on the PES corresponding to a minimum in all directions except one; a second-order saddle point is a minimum in all directions except two, and so on. Defined mathematically, an <em>n</em>th order saddle point is characterized by the following: 

<math display="inline" id="Energy_minimization:17">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">∂</mi>
      <mi>E</mi>
     </mrow>
     <mo>/</mo>
     <mi mathvariant="normal">∂</mi>
    </mrow>
    <mi>𝐫</mi>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-∂</ci>
        <ci>E</ci>
       </apply>
       <ci>normal-∂</ci>
      </apply>
      <ci>𝐫</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1=∂E/∂\mathbf{r}=\mathbf{0}
  </annotation>
 </semantics>
</math>

 and the Hessian matrix, <mtpl></mtpl>, has exactly <em>n</em> negative Eigenvalues.</p>

<p>Algorithms to locate transition state geometries fall into two main categories: local methods and semi-global methods. Local methods are suitable when the starting point for the optimization is very close to the true transition state (<em>very close</em> will be defined shortly) and semi-global methods find application when it is sought to locate the transition state with very little <em>a priori</em> knowledge of its geometry. Some methods, such as the Dimer method (see below), fall into both categories.</p>
<h3 id="local-searches">Local searches</h3>

<p>A so-called local optimization requires an initial guess of the transition state that is very close to the true transition state. <em>Very close</em> typically means that the initial guess must have a corresponding Hessian matrix with one negative Eigenvalue, or, the negative Eigenvalue corresponding to the reaction coordinate must be greater in magnitude than the other negative Eigenvalues. Further, the Eigenvector with the most negative Eigenvalue must correspond to the reaction coordinate, that is, it must represent the geometric transformation relating to the process whose transition state is sought.</p>

<p>Given the above pre-requisites, a local optimization algorithm can then move "uphill" along the Eigenvector with the most negative Eigenvalue and "downhill" along all other degrees of freedom, using something similar to a quasi-Newton method.</p>
<h3 id="dimer-method">Dimer method</h3>

<p>The dimer method<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> can be used to find possible transition states without knowledge of the final structure or to refine a good guess of a transition structure. The “dimer” is formed by two images very close to each other on the PES. The method works by moving the dimer uphill from the starting position whilst rotating the dimer to find the direction of lowest curvature (ultimately negative).</p>
<h3 id="activation-relaxation-technique-art">Activation Relaxation Technique (ART)</h3>

<p>The Activation Relaxation Technique (ART)<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> is also an open-ended method to find new transition states or to refine known saddle points on the PES. The method follows the direction of lowest negative curvature (computed using the <a href="Lanczos_algorithm" title="wikilink">Lanczos algorithm</a>) on the PES to reach the saddle point, relaxing in the perpendicular hyperplane between each "jump" (activation) in this direction.</p>
<h3 id="chain-of-state-methods">Chain-of-state methods</h3>

<p>Chain-of-state<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> methods can be used to find the <em>approximate</em> geometry of the transition state based on the geometries of the reactant and product. The generated approximate geometry can then serve as a starting point for refinement via a local search, which was described above.</p>

<p>Chain-of-state methods use a series of vectors, that is points on the PES, connecting the reactant and product of the reaction of interest, <mtpl></mtpl> and <mtpl></mtpl>, thus discretizing the reaction pathway. Very commonly, these points are referred to as ''beads ''due to an analogy of a set of beads connected by strings or springs, which connect the reactant and products. The series of beads is often initially created by interpolating between <mtpl></mtpl> and <mtpl></mtpl>, for example, for a series of 

<math display="inline" id="Energy_minimization:18">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+1
  </annotation>
 </semantics>
</math>

 beads, bead 

<math display="inline" id="Energy_minimization:19">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 might be given by</p>

<p>

<math display="inline" id="Energy_minimization:20">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐫</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mi>i</mi>
      <mi>N</mi>
     </mfrac>
     <msub>
      <mi>𝐫</mi>
      <mi>product</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mfrac>
        <mi>i</mi>
        <mi>N</mi>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msub>
      <mi>𝐫</mi>
      <mi>reactant</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐫</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>i</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <ci>product</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <ci>i</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <ci>reactant</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{i}=\frac{i}{N}\mathbf{r}_{\mathrm{product}}+\left(1-\frac{i}{N}%
\right)\mathbf{r}_{\mathrm{reactant}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Energy_minimization:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mi mathvariant="normal">∈</mi>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>normal-∈</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>N</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i∈0,1,...,N
  </annotation>
 </semantics>
</math>

. Each of the beads <mtpl></mtpl> has an energy, <mtpl></mtpl>, and forces, <mtpl></mtpl> and these are treated with a constrained optimization process that seeks to get an as accurate as possible representation of the reaction pathway. For this to be achieved, spacing constraints must be applied so that each bead <mtpl></mtpl> does not simply get optimized to the reactant and product geometry.</p>

<p>Often this constraint is achieved by <a href="Vector_projection" title="wikilink">projecting</a> out components of the force on each bead <mtpl></mtpl>, or alternatively the movement of each bead during optimization, that are tangential to the reaction path. For example, if for convenience, it is defined that <mtpl></mtpl>, then the energy gradient at each bead minus the component of the energy gradient that is tangential to the reaction pathway is given by</p>

<p>

<math display="inline" id="Energy_minimization:22">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐠</mi>
    <mi>i</mi>
    <mo>⟂</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐠</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>τ</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>τ</mi>
        <mi>i</mi>
       </msub>
       <mo>⋅</mo>
       <msub>
        <mi>𝐠</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>τ</mi>
        <mi>i</mi>
       </msub>
       <msubsup>
        <mi>τ</mi>
        <mi>i</mi>
        <mi>T</mi>
       </msubsup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
    <msub>
     <mi>𝐠</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐠</ci>
       <ci>i</ci>
      </apply>
      <csymbol cd="latexml">perpendicular-to</csymbol>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐠</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐠</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>I</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <ci>i</ci>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐠</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{g}_{i}^{\perp}=\mathbf{g}_{i}-\mathbf{\tau}_{i}(\mathbf{\tau}_{i}\cdot%
\mathbf{g}_{i})=\left(I-\mathbf{\tau}_{i}\mathbf{\tau}_{i}^{T}\right)\mathbf{g%
}_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Energy_minimization:23">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is the identity matrix and <mtpl></mtpl> is a unit vector representing the reaction path tangent at <mtpl></mtpl>. By projecting out components of the energy gradient or the optimization step that are parallel to the reaction path, an optimization algorithm significantly reduces the tendency of each of the beads to be optimized directly to a minimum.</p>
<h4 id="synchronous-transit">Synchronous transit</h4>

<p>The simplest chain-of-state method is the linear synchronous transit (LST) method. It operates by taking interpolated points between the reactant and product geometries and choosing the one with the highest energy for subsequent refinement via a local search. The quadratic synchronous transit (QST) method extends LST by allowing a parabolic reaction path, with optimization of the highest energy point orthogonally to the parabola.</p>
<h4 id="nudged-elastic-band">Nudged elastic band</h4>

<p>In Nudged elastic band<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> method, the beads along the reaction pathway have simulated spring forces in addition to the chemical forces, <mtpl></mtpl>, to cause the optimizer to maintain the spacing constraint. Specifically, the force <mtpl></mtpl> on each point <em>i</em> is given by</p>

<p>

<math display="inline" id="Energy_minimization:24">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐟</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>𝐟</mi>
     <mi>i</mi>
     <mo>∥</mo>
    </msubsup>
    <mo>-</mo>
    <msubsup>
     <mi>𝐠</mi>
     <mi>i</mi>
     <mo>⟂</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐟</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐟</ci>
       <ci>i</ci>
      </apply>
      <csymbol cd="latexml">parallel-to</csymbol>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐠</ci>
       <ci>i</ci>
      </apply>
      <csymbol cd="latexml">perpendicular-to</csymbol>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{f}_{i}=\mathbf{f}_{i}^{\parallel}-\mathbf{g}_{i}^{\perp}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="inline" id="Energy_minimization:25">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐟</mi>
    <mi>i</mi>
    <mo>∥</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mo>(</mo>
         <mrow>
          <msub>
           <mi>𝐫</mi>
           <mrow>
            <mi>i</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>𝐫</mi>
           <mi>i</mi>
          </msub>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mo>(</mo>
         <mrow>
          <msub>
           <mi>𝐫</mi>
           <mi>i</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>𝐫</mi>
           <mrow>
            <mi>i</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mo>⋅</mo>
      <msub>
       <mi>τ</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>]</mo>
    </mrow>
    <msub>
     <mi>τ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐟</ci>
      <ci>i</ci>
     </apply>
     <csymbol cd="latexml">parallel-to</csymbol>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <minus></minus>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐫</ci>
          <apply>
           <plus></plus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐫</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐫</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐫</ci>
          <apply>
           <minus></minus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{f}_{i}^{\parallel}=k\left[\left(\left(\mathbf{r}_{i+1}-\mathbf{r}_{i}%
\right)-\left(\mathbf{r}_{i}-\mathbf{r}_{i-1}\right)\right)\cdot\tau_{i}\right%
]\tau_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>is the spring force parallel to the pathway at each point <mtpl></mtpl> (<em>k</em> is a spring constant and <mtpl></mtpl>, as before, is a unit vector representing the reaction path tangent at <mtpl></mtpl>).</p>

<p>In a traditional implementation, the point with the highest energy is used for subsequent refinement in a local search.There are many variations on the NEB (nudged elastic band) method,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> such including the climbing image NEB, in which the point with the highest energy is pushed upwards during the optimization procedure so as to (hopefully) give a geometry which is even closer to that of the transition state.</p>
<h4 id="string-method">String method</h4>

<p>The string method<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> uses splines connecting the points, <mtpl></mtpl>, to measure and enforce distance constraints between the points and to calculate the tangent at each point. In each step of an optimization procedure, the points might be moved according to the force acting on them perpendicular to the path, and then, if the equidistance constraint between the points is no-longer satisfied, the points can be redistributed, using the spline representation of the path to generate new vectors with the required spacing.</p>

<p>Variations on the string method include the growing string method,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> in which the guess of the pathway is grown in from the end points (that is the reactant and products) as the optimization progresses.</p>
<h2 id="comparison-with-other-techniques">Comparison with other techniques</h2>

<p>Geometry optimization is fundamentally different from a <a href="molecular_dynamics" title="wikilink">molecular dynamics</a> simulation. The latter simulates the motion of molecules with respect to time, subject to temperature, chemical forces, initial velocities, <a href="Brownian_motion" title="wikilink">Brownian motion</a> of a solvent, and so on, via the application of <a href="Newton's_laws_of_motion" title="wikilink">Newton's laws of Motion</a>. This means that the trajectories of the atoms which get computed, have some physical meaning. Geometry optimization, by contrast, does not produced a "trajectory" with any physical meaning – it is concerned with minimization of the forces acting on each atom in a collection of atoms, and the pathway via which it achieves this is lacks meaning. Different optimization algorithms could give the same result for the minimum energy structure, but arrive at it via a different pathway.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Graph_cuts_in_computer_vision" title="wikilink">Graph cuts in computer vision</a> – apparatus for solving <a href="computer_vision" title="wikilink">computer vision</a> problems that can be formulated in terms of energy minimization</li>
<li><a href="Energy_principles_in_structural_mechanics" title="wikilink">Energy principles in structural mechanics</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.nrbook.com/a/bookfpdf.php">Numerical Recipes in Fortran 77</a></li>
</ul>
<h2 id="additional-references">Additional references</h2>
<ul>
<li>Payne et al., "Iterative minimization techniques for ab initio total-energy calculations: Molecular dynamics and conjugate gradients", <em>Reviews of Modern Physics</em> 64 (4), pp. 1045–1097. (1992) <a href="http://dx.doi.org/10.1103/RevModPhys.64.1045">(abstract)</a></li>
<li>Atich et al., "Conjugate gradient minimization of the energy functional: A new method for electronic structure calculation", <em>Physical Review B</em> 39 (8), pp. 4997–5004, (1989)</li>
<li>Chadi, "Energy-minimization approach to the atomic geometry of semiconductor surfaces", <em>Physical Review Letters</em> 41 (15), pp. 1062–1065 (1978)</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink"> </a> <a href="Category:Computational_chemistry" title="wikilink">Category:Computational chemistry</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://www.gaussian.com">http://www.gaussian.com</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">Jensen, F. Introduction to Computational Chemistry; Wiley: 2 ed.; 2006<a href="#fnref9">↩</a></li>
<li id="fn10">(a) G. Mills and H. Jónsson, Phys. Rev. Lett. 72, 1124 (1994) (b) Graeme Henkelman and Hannes Jónsson, Improved tangent estimate in the nudged elastic band method for finding minimum energy paths and saddle points, J. Chem. Phys. 113, 9978 - 9985 (2000)<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"> and <a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
