   Chien search      Chien search   In abstract algebra , the Chien search , named after Robert T. Chien, is a fast algorithm for determining roots of polynomials defined over a finite field . The most typical use of the Chien search is in finding the roots of error-locator polynomials encountered in decoding Reed-Solomon codes and BCH codes .  Algorithm  We denote the polynomial (over the finite field GF(   q   q   q   )) whose roots we wish to determine as:        Λ    (  x  )    =    λ  0   +    λ  1   x   +    λ  2    x  2    +  ⋯  +    λ  t    x  t           normal-Λ  x      subscript  λ  0      subscript  λ  1   x      subscript  λ  2    superscript  x  2    normal-⋯     subscript  λ  t    superscript  x  t       \ \Lambda(x)=\lambda_{0}+\lambda_{1}x+\lambda_{2}x^{2}+\cdots+\lambda_{t}x^{t}     Conceptually, we may evaluate    Λ   (  β  )       normal-Λ  β    \Lambda(\beta)   for each non-zero   β   β   \beta   in GF(   q   q   q   ). Those resulting in 0 are roots of the polynomial.  The Chien search is based on two observations:   Each non-zero   β   β   \beta   may be expressed as    α   i  β      superscript  α   subscript  i  β     \alpha^{i_{\beta}}   for some    i  β     subscript  i  β    i_{\beta}   , where   α   α   \alpha   is a primitive element of    GF   (  q  )       GF  q    \mathrm{GF}(q)   ,    i  β     subscript  i  β    i_{\beta}   is the power number of primitive element   α   α   \alpha   . Thus the powers    α  i     superscript  α  i    \alpha^{i}   for    0  ≤  i  <   (   q  -  1   )         0  i         q  1      0\leq i<(q-1)   cover the entire field (excluding the zero element).    The following relationship exists:          Λ   (   α  i   )      =     λ  0     +      λ  1    (   α  i   )      +      λ  2     (   α  i   )   2      +    ⋯    +      λ  t     (   α  i   )   t         ≜     γ   0  ,  i      +     γ   1  ,  i      +     γ   2  ,  i      +    ⋯    +     γ   t  ,  i            normal-Λ   superscript  α  i      subscript  λ  0       subscript  λ  1    superscript  α  i        subscript  λ  2    superscript   superscript  α  i   2     normal-⋯      subscript  λ  t    superscript   superscript  α  i   t       missing-subexpression   normal-≜   subscript  γ   0  i      subscript  γ   1  i      subscript  γ   2  i     normal-⋯    subscript  γ   t  i       \begin{array}[]{lllllllllll}\Lambda(\alpha^{i})&=&\lambda_{0}&+&\lambda_{1}(%
 \alpha^{i})&+&\lambda_{2}(\alpha^{i})^{2}&+&\cdots&+&\lambda_{t}(\alpha^{i})^{%
 t}\\
 &\triangleq&\gamma_{0,i}&+&\gamma_{1,i}&+&\gamma_{2,i}&+&\cdots&+&\gamma_{t,i}%
 \end{array}            Λ   (   α   i  +  1    )      =     λ  0     +      λ  1    (   α   i  +  1    )      +      λ  2     (   α   i  +  1    )   2      +    ⋯    +      λ  t     (   α   i  +  1    )   t         =     λ  0     +      λ  1    (   α  i   )   α     +      λ  2      (   α  i   )   2     α  2      +    ⋯    +      λ  t      (   α  i   )   t     α  t         =     γ   0  ,  i      +       γ   1  ,  i     α     +       γ   2  ,  i      α  2      +    ⋯    +       γ   t  ,  i      α  t         ≜     γ   0  ,   i  +  1       +     γ   1  ,   i  +  1       +     γ   2  ,   i  +  1       +    ⋯    +     γ   t  ,   i  +  1             normal-Λ   superscript  α    i  1       subscript  λ  0       subscript  λ  1    superscript  α    i  1         subscript  λ  2    superscript   superscript  α    i  1    2     normal-⋯      subscript  λ  t    superscript   superscript  α    i  1    t       missing-subexpression     subscript  λ  0       subscript  λ  1    superscript  α  i   α       subscript  λ  2    superscript   superscript  α  i   2    superscript  α  2     normal-⋯      subscript  λ  t    superscript   superscript  α  i   t    superscript  α  t       missing-subexpression     subscript  γ   0  i        subscript  γ   1  i    α       subscript  γ   2  i     superscript  α  2     normal-⋯      subscript  γ   t  i     superscript  α  t       missing-subexpression   normal-≜   subscript  γ   0    i  1       subscript  γ   1    i  1       subscript  γ   2    i  1      normal-⋯    subscript  γ   t    i  1        \begin{array}[]{lllllllllll}\Lambda(\alpha^{i+1})&=&\lambda_{0}&+&\lambda_{1}(%
 \alpha^{i+1})&+&\lambda_{2}(\alpha^{i+1})^{2}&+&\cdots&+&\lambda_{t}(\alpha^{i%
 +1})^{t}\\
 &=&\lambda_{0}&+&\lambda_{1}(\alpha^{i})\,\alpha&+&\lambda_{2}(\alpha^{i})^{2}%
 \,\alpha^{2}&+&\cdots&+&\lambda_{t}(\alpha^{i})^{t}\,\alpha^{t}\\
 &=&\gamma_{0,i}&+&\gamma_{1,i}\,\alpha&+&\gamma_{2,i}\,\alpha^{2}&+&\cdots&+&%
 \gamma_{t,i}\,\alpha^{t}\\
 &\triangleq&\gamma_{0,i+1}&+&\gamma_{1,i+1}&+&\gamma_{2,i+1}&+&\cdots&+&\gamma%
 _{t,i+1}\end{array}     In other words, we may define each    Λ   (   α  i   )       normal-Λ   superscript  α  i     \Lambda(\alpha^{i})   as the sum of a set of terms    {   γ   j  ,  i    |   0  ≤  j  ≤  t   }     conditional-set   subscript  γ   j  i        0  j       t      \{\gamma_{j,i}|0\leq j\leq t\}   , from which the next set of coefficients may be derived thus:        γ    j  ,   i  +  1     =     γ   j  ,  i      α  j         subscript  γ   j    i  1        subscript  γ   j  i     superscript  α  j      \ \gamma_{j,i+1}=\gamma_{j,i}\,\alpha^{j}     In this way, we may start at    i  =  0      i  0    i=0   with     γ   j  ,  0    =   λ  j        subscript  γ   j  0     subscript  λ  j     \gamma_{j,0}=\lambda_{j}   , and iterate through each value of   i   i   i   up to    (   q  -  1   )      q  1    (q-1)   . If at any stage the resultant summation is zero, i.e.         ∑   j  =  0   t    γ   j  ,  i     =  0   ,        superscript   subscript     j  0    t    subscript  γ   j  i     0    \ \sum_{j=0}^{t}\gamma_{j,i}=0,     then     Λ   (   α  i   )    =  0        normal-Λ   superscript  α  i    0    \Lambda(\alpha^{i})=0   also, so    α  i     subscript  α  i    \alpha_{i}   is a root. In this way, we check every element in the field.  When implemented in hardware, this approach significantly reduces the complexity, as all multiplications consist of one variable and one constant, rather than two variables as in the brute-force approach.  References       "  Category:Error detection and correction  Category:Finite fields   