<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="136">Material conditional</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Material conditional</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption><a href="Venn_diagram" title="wikilink">Venn diagram</a> of 

<math display="inline" id="Material_conditional:0">
<semantics>
<mrow>
<mi>A</mi>
<mo>→</mo>
<mi>B</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\rightarrow B
  </annotation>
</semantics>
</math>

.<br/>
If a member of the set described by this diagram (the red areas) is a member of 

<math display="inline" id="Material_conditional:1">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

, it is in the intersection of 

<math display="inline" id="Material_conditional:2">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Material_conditional:3">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

, and it therefore is also in 

<math display="inline" id="Material_conditional:4">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

.</figcaption>
</figure>

<p>The <strong>material conditional</strong> (also known as "<strong>material implication</strong>", "<strong>material consequence</strong>", or simply "<strong>implication</strong>", "<strong>implies</strong>" or "<strong>conditional</strong>") is a <a href="logical_connective" title="wikilink">logical connective</a> (or a <a href="binary_operator" title="wikilink">binary operator</a>) that is often symbolized by a forward arrow "→". The material conditional is used to form <a href="statement_(logic)" title="wikilink">statements</a> of the form  (termed a conditional statement) which is read as "if p then q" or "p only if q" and conventionally compared to the English construction "If...then...". But unlike the English construction, the material conditional statement  does not specify a causal relationship between <em>p</em> and <em>q</em> and is to be understood to mean "if <em>p</em> is true, then <em>q</em> is also true" such that the statement  is false only when <em>p</em> is true and <em>q</em> is false.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Intuitively, consider that a given p being true and q being false would prove an "if p is true, q is always also true" statement false, even when the "if p then q" does not represent a causal relationship between p and q. Instead, the statement describes p and q as each only being true when the other is true, and makes no claims that p causes q. However, note that such a general and informal way of thinking about the material conditional is not always acceptable, as will be discussed. As such, the material conditional is also to be distinguished from <a href="logical_consequence" title="wikilink">logical consequence</a>.</p>

<p>The material conditional is also symbolized using:</p>
<ol>
<li>
<math display="inline" id="Material_conditional:5">
<semantics>
<mrow>
<mi>p</mi>
<mo>⊃</mo>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>q</ci>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\supset q
  </annotation>
</semantics>
</math>

 (Although this symbol may be used for the superset symbol in <a href="set_theory" title="wikilink">set theory</a>.);</li>
<li>
<math display="inline" id="Material_conditional:6">
<semantics>
<mrow>
<mi>p</mi>
<mo>⇒</mo>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-⇒</ci>
<ci>p</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\Rightarrow q
  </annotation>
</semantics>
</math>

 (Although this symbol is often used for <a href="logical_consequence" title="wikilink">logical consequence</a> (i.e. logical implication) rather than for material conditional.)</li>
</ol>

<p>With respect to the material conditionals above, <em>p</em> is termed the <em><a href="antecedent_(logic)" title="wikilink">antecedent</a></em>, and <em>q</em> the <em><a class="uri" href="consequent" title="wikilink">consequent</a></em> of the conditional. Conditional statements may be nested such that either or both of the antecedent or the consequent may themselves be conditional statements. In the example  both the antecedent and the consequent are conditional statements.</p>

<p>In <a href="classical_logic" title="wikilink">classical logic</a>
<math display="inline" id="Material_conditional:7">
<semantics>
<mrow>
<mi>p</mi>
<mo>→</mo>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>p</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\rightarrow q
  </annotation>
</semantics>
</math>

 is <a href="Logical_equivalence" title="wikilink">logically equivalent</a> to 

<math display="inline" id="Material_conditional:8">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>p</mi>
<mi mathvariant="italic">and</mi>
<mi mathvariant="normal">¬</mi>
<mi>q</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<not></not>
<apply>
<times></times>
<ci>p</ci>
<ci>italic- and</ci>
<not></not>
<ci>q</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg(p\and\neg q)
  </annotation>
</semantics>
</math>

 and by <a href="De_Morgan's_Law" title="wikilink">De Morgan's Law</a> logically equivalent to 

<math display="inline" id="Material_conditional:9">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>p</mi>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<not></not>
<ci>p</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg pq
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Whereas, in <a href="minimal_logic" title="wikilink">minimal logic</a> (and therefore also intuitionistic logic) 

<math display="inline" id="Material_conditional:10">
<semantics>
<mrow>
<mi>p</mi>
<mo>→</mo>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>p</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\rightarrow q
  </annotation>
</semantics>
</math>

 only <a href="Logical_consequence" title="wikilink">logically entails</a>
<math display="inline" id="Material_conditional:11">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>p</mi>
<mi mathvariant="italic">and</mi>
<mi mathvariant="normal">¬</mi>
<mi>q</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<not></not>
<apply>
<times></times>
<ci>p</ci>
<ci>italic- and</ci>
<not></not>
<ci>q</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg(p\and\neg q)
  </annotation>
</semantics>
</math>

; and in <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a> (but not minimal logic) 

<math display="inline" id="Material_conditional:12">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>p</mi>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<not></not>
<ci>p</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg pq
  </annotation>
</semantics>
</math>

 entails 

<math display="inline" id="Material_conditional:13">
<semantics>
<mrow>
<mi>p</mi>
<mo>→</mo>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>p</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\rightarrow q
  </annotation>
</semantics>
</math>

.</p>
<h2 id="definitions-of-the-material-conditional">Definitions of the material conditional</h2>

<p>Logicians have many different views on the nature of material implication and approaches to explain its sense.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="as-a-truth-function">As a truth function</h3>

<p>In <a href="classical_logic" title="wikilink">classical logic</a>, the compound  is logically equivalent to the negative compound: not both <em>p</em> and not <em>q</em>. Thus the compound  is <em>false</em> <a href="if_and_only_if" title="wikilink">if and only if</a> both <em>p</em> is true and <em>q</em> is false. By the same stroke,  is <em>true</em> if and only if either <em>p</em> is false or <em>q</em> is true (or both). Thus → is a function from pairs of <a href="truth_value" title="wikilink">truth values</a> of the components <em>p</em>, <em>q</em> to truth values of the compound , whose truth value is entirely a function of the truth values of the components. Hence, this interpretation is called <em><a href="Truth_function" title="wikilink">truth-functional</a></em>. The compound  is logically equivalent also to  (either not <em>p</em>, or <em>q</em> (or both)), and to  (if not <em>q</em> then not <em>p</em>). But it is not equivalent to , which is equivalent to .</p>
<h4 id="truth-table">Truth table</h4>

<p>The <a href="truth_table" title="wikilink">truth table</a> associated with the material conditional  is identical to that of  and is also denoted by <strong>Cpq</strong>. It is as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>
<math display="inline" id="Material_conditional:14">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>
</p></th>
<th style="text-align: left;">

<p>
<math display="inline" id="Material_conditional:15">
<semantics>
<mi>q</mi>
<annotation-xml encoding="MathML-Content">
<ci>q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   q
  </annotation>
</semantics>
</math>
</p></th>
<th style="text-align: left;">

<p>
<math display="inline" id="Material_conditional:16">
<semantics>
<mrow>
<mi>p</mi>
<mo>→</mo>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>p</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\rightarrow q
  </annotation>
</semantics>
</math>
</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>T</p></td>
<td style="text-align: left;">

<p>T</p></td>
<td style="text-align: left;">

<p>T</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>T</p></td>
<td style="text-align: left;">

<p>F</p></td>
<td style="text-align: left;">

<p>F</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>F</p></td>
<td style="text-align: left;">

<p>T</p></td>
<td style="text-align: left;">

<p>T</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>F</p></td>
<td style="text-align: left;">

<p>F</p></td>
<td style="text-align: left;">

<p>T</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>It may also be useful to note that in <a href="Boolean_algebra" title="wikilink">Boolean algebra</a>, true and false can be denoted as 1 and 0 respectively with an equivalent table.</p>
<h3 id="as-a-formal-connective">As a formal connective</h3>

<p>The material conditional can be considered as a symbol of a <a href="theory_(mathematical_logic)" title="wikilink">formal theory</a>, taken as a set of sentences, satisfying all the classical inferences involving →, in particular the following characteristic rules:</p>
<ol>
<li><a href="Modus_ponens" title="wikilink">Modus ponens</a>;</li>
<li><a href="Conditional_proof" title="wikilink">Conditional proof</a>;</li>
<li><a href="contraposition" title="wikilink">Classical contraposition</a>;</li>
<li><a href="reductio_ad_absurdum" title="wikilink">Classical reductio ad absurdum</a>.</li>
</ol>

<p>Unlike the truth-functional one, this approach to logical connectives permits the examination of structurally identical propositional forms in various <a href="Formal_system" title="wikilink">logical systems</a>, where somewhat different properties may be demonstrated. For example, in <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a> which rejects proofs by contraposition as valid rules of inference, 

<math display="inline" id="Material_conditional:17">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>p</mi>
<mi mathvariant="normal">→</mi>
<mi>q</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">⇒</mi>
<mi mathvariant="normal">¬</mi>
<mi>p</mi>
<mi mathvariant="normal">∨</mi>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<times></times>
<ci>p</ci>
<ci>normal-→</ci>
<ci>q</ci>
</apply>
<ci>normal-⇒</ci>
<ci>normal-¬</ci>
<ci>p</ci>
<ci>normal-∨</ci>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (p→q)⇒¬p∨q
  </annotation>
</semantics>
</math>

 is not a propositional theorem, but <a href="False_(logic)#False,_negation_and_contradiction" title="wikilink">the material conditional is used to define negation</a>.</p>
<h2 id="formal-properties">Formal properties</h2>

<p>When studying logic formally, the material conditional is distinguished from the <a href="Logical_consequence#Semantic_consequence" title="wikilink">semantic consequence</a> relation 

<math display="inline" id="Material_conditional:18">
<semantics>
<mo>⊧</mo>
<annotation-xml encoding="MathML-Content">
<csymbol cd="latexml">models</csymbol>
</annotation-xml>
<annotation encoding="application/x-tex">
   \models
  </annotation>
</semantics>
</math>

. We say 

<math display="inline" id="Material_conditional:19">
<semantics>
<mrow>
<mi>A</mi>
<mo>⊧</mo>
<mi>B</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">models</csymbol>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\models B
  </annotation>
</semantics>
</math>

 if every interpretation that makes <em>A</em> true also makes <em>B</em> true. However, there is a close relationship between the two in most logics, including <a href="classical_logic" title="wikilink">classical logic</a>. For example, the following principles hold:</p>
<ul>
<li>If 

<math display="inline" id="Material_conditional:20">
<semantics>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mo>⊧</mo>
<mi>ψ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">models</csymbol>
<ci>normal-Γ</ci>
<ci>ψ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Gamma\models\psi
  </annotation>
</semantics>
</math>

 then 

<math display="inline" id="Material_conditional:21">
<semantics>
<mrow>
<mi mathvariant="normal">∅</mi>
<mo>⊧</mo>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>φ</mi>
<mn>1</mn>
</msub>
<mo>∧</mo>
<mi mathvariant="normal">…</mi>
<mo>∧</mo>
<msub>
<mi>φ</mi>
<mi>n</mi>
</msub>
<mo>→</mo>
<mi>ψ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<emptyset></emptyset>
<csymbol cd="latexml">models</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>φ</ci>
<cn type="integer">1</cn>
</apply>
<and></and>
<ci>normal-…</ci>
<and></and>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>φ</ci>
<ci>n</ci>
</apply>
<ci>normal-→</ci>
<csymbol cd="unknown">ψ</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \varnothing\models(\varphi_{1}\land\dots\land\varphi_{n}\rightarrow\psi)
  </annotation>
</semantics>
</math>

 for some 

<math display="inline" id="Material_conditional:22">
<semantics>
<mrow>
<mrow>
<msub>
<mi>φ</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>φ</mi>
<mi>n</mi>
</msub>
</mrow>
<mo>∈</mo>
<mi mathvariant="normal">Γ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>φ</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>φ</ci>
<ci>n</ci>
</apply>
</list>
<ci>normal-Γ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \varphi_{1},\dots,\varphi_{n}\in\Gamma
  </annotation>
</semantics>
</math>

. (This is a particular form of the <a href="deduction_theorem" title="wikilink">deduction theorem</a>. In words, it says that if Γ models <em>ψ</em> this means that <em>ψ</em> can be deduced just from some subset of the theorems in Γ.)</li>
</ul>
<ul>
<li>The converse of the above</li>
</ul>
<ul>
<li>Both 

<math display="inline" id="Material_conditional:23">
<semantics>
<mo>→</mo>
<annotation-xml encoding="MathML-Content">
<ci>normal-→</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Material_conditional:24">
<semantics>
<mo>⊧</mo>
<annotation-xml encoding="MathML-Content">
<csymbol cd="latexml">models</csymbol>
</annotation-xml>
<annotation encoding="application/x-tex">
   \models
  </annotation>
</semantics>
</math>

 are <a href="Monotonic_function" title="wikilink">monotonic</a>; i.e., if 

<math display="inline" id="Material_conditional:25">
<semantics>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mo>⊧</mo>
<mi>ψ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">models</csymbol>
<ci>normal-Γ</ci>
<ci>ψ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Gamma\models\psi
  </annotation>
</semantics>
</math>

 then 

<math display="inline" id="Material_conditional:26">
<semantics>
<mrow>
<mrow>
<mi mathvariant="normal">Δ</mi>
<mo>∪</mo>
<mi mathvariant="normal">Γ</mi>
</mrow>
<mo>⊧</mo>
<mi>ψ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">models</csymbol>
<apply>
<union></union>
<ci>normal-Δ</ci>
<ci>normal-Γ</ci>
</apply>
<ci>ψ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Delta\cup\Gamma\models\psi
  </annotation>
</semantics>
</math>

, and if 

<math display="inline" id="Material_conditional:27">
<semantics>
<mrow>
<mi>φ</mi>
<mo>→</mo>
<mi>ψ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>φ</ci>
<ci>ψ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \varphi\rightarrow\psi
  </annotation>
</semantics>
</math>

 then 

<math display="inline" id="Material_conditional:28">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>φ</mi>
<mo>∧</mo>
<mi>α</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>→</mo>
<mi>ψ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<apply>
<and></and>
<ci>φ</ci>
<ci>α</ci>
</apply>
<ci>ψ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\varphi\land\alpha)\rightarrow\psi
  </annotation>
</semantics>
</math>

 for any <em>α</em>, Δ. (In terms of structural rules, this is often referred to as <a class="uri" href="weakening" title="wikilink">weakening</a> or <em>thinning</em>.)</li>
</ul>

<p>These principles do not hold in all logics, however. Obviously they do not hold in <a href="non-monotonic_logic" title="wikilink">non-monotonic logics</a>, nor do they hold in <a href="relevance_logic" title="wikilink">relevance logics</a>.</p>

<p>Other properties of implication (the following expressions are always true, for any logical values of variables):</p>
<ul>
<li><a class="uri" href="distributivity" title="wikilink">distributivity</a>
<math display="block" id="Material_conditional:29">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo>→</mo>
<mi>q</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>→</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>→</mo>
<mi>q</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">s</csymbol>
<ci>normal-→</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">p</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">q</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
<ci>normal-→</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">s</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">p</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-→</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">s</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">q</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   (s\rightarrow(p\rightarrow q))\rightarrow((s\rightarrow p)\rightarrow(s%
\rightarrow q))
  </annotation>
</semantics>
</math>
</li>
</ul>
<ul>
<li><a href="transitive_relation" title="wikilink">transitivity</a>
<math display="block" id="Material_conditional:30">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>→</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo>→</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>→</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-→</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">c</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-→</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">c</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   (a\rightarrow b)\rightarrow((b\rightarrow c)\rightarrow(a\rightarrow c))
  </annotation>
</semantics>
</math>
</li>
</ul>
<ul>
<li><a href="reflexive_relation" title="wikilink">reflexivity</a>
<math display="block" id="Material_conditional:31">
<semantics>
<mrow>
<mi>a</mi>
<mo>→</mo>
<mi>a</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>a</ci>
<ci>a</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a\rightarrow a
  </annotation>
</semantics>
</math>
</li>
</ul>
<ul>
<li><a href="total_relation" title="wikilink">totality</a>
<math display="block" id="Material_conditional:32">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>→</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>∨</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo>→</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-)</ci>
</cerror>
<or></or>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   (a\rightarrow b)\vee(b\rightarrow a)
  </annotation>
</semantics>
</math>
</li>
</ul>
<ul>
<li>truth preserving: The interpretation under which all variables are assigned a truth value of 'true' produces a truth value of 'true' as a result of material implication.</li>
</ul>
<ul>
<li>commutativity of antecedents

<math display="block" id="Material_conditional:33">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo>→</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>≡</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>→</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-→</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">c</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
<equivalent></equivalent>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-→</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">c</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   (a\rightarrow(b\rightarrow c))\equiv(b\rightarrow(a\rightarrow c))
  </annotation>
</semantics>
</math>
</li>
</ul>

<p>Note that 

<math display="inline" id="Material_conditional:34">
<semantics>
<mrow>
<mi>a</mi>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo>→</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-→</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">c</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   a\rightarrow(b\rightarrow c)
  </annotation>
</semantics>
</math>

 is <a href="Logical_equivalence" title="wikilink">logically equivalent</a> to 

<math display="inline" id="Material_conditional:35">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>a</mi>
<mi mathvariant="italic">and</mi>
<mi>b</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>→</mo>
<mi>c</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>a</ci>
<ci>italic- and</ci>
<ci>b</ci>
</apply>
<ci>c</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (a\and b)\rightarrow c
  </annotation>
</semantics>
</math>

; this property is sometimes called <a href="currying" title="wikilink">un/currying</a>. Because of these properties, it is convenient to adopt a <a class="uri" href="right-associative" title="wikilink">right-associative</a> notation for → where 

<math display="inline" id="Material_conditional:36">
<semantics>
<mrow>
<mi>a</mi>
<mo>→</mo>
<mi>b</mi>
<mo>→</mo>
<mi>c</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<ci>normal-→</ci>
<ci>a</ci>
<ci>b</ci>
</apply>
<apply>
<ci>normal-→</ci>
<share href="#.cmml">
</share>
<ci>c</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a\rightarrow b\rightarrow c
  </annotation>
</semantics>
</math>

 denotes 

<math display="inline" id="Material_conditional:37">
<semantics>
<mrow>
<mi>a</mi>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo>→</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-→</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">c</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   a\rightarrow(b\rightarrow c)
  </annotation>
</semantics>
</math>

.</p>

<p>Comparison of Boolean truth tables shows that 

<math display="inline" id="Material_conditional:38">
<semantics>
<mrow>
<mi>a</mi>
<mo>→</mo>
<mi>b</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>a</ci>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a\rightarrow b
  </annotation>
</semantics>
</math>

 is equivalent to 

<math display="inline" id="Material_conditional:39">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>a</mi>
<mi>b</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<not></not>
<ci>a</ci>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg ab
  </annotation>
</semantics>
</math>

, and one is an equivalent replacement for the other in classical logic. See <a href="material_implication_(rule_of_inference)" title="wikilink">material implication (rule of inference)</a>.</p>
<h2 id="philosophical-problems-with-material-conditional">Philosophical problems with material conditional</h2>

<p>Outside of mathematics, it is a matter of some controversy as to whether the <a href="truth_function" title="wikilink">truth function</a> for <a href="material_implication_(rule_of_inference)" title="wikilink">material implication</a> provides an adequate treatment of conditional statements in English (a <a href="sentence_(mathematical_logic)" title="wikilink">sentence</a> in the <a href="indicative_mood" title="wikilink">indicative mood</a> with a <a href="conditional_clause" title="wikilink">conditional clause</a> attached, i.e., an <a href="indicative_conditional" title="wikilink">indicative conditional</a>, or false-to-fact sentences in the <a href="subjunctive_mood" title="wikilink">subjunctive mood</a>, i.e., a <a href="counterfactual_conditional" title="wikilink">counterfactual conditional</a>).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> That is to say, critics argue that in some non-mathematical cases, the truth value of a compound statement, "if <em>p</em> then <em>q</em>", is not adequately determined by the truth values of <em>p</em> and <em>q</em>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Examples of non-truth-functional statements include: "<em>q</em> because <em>p</em>", "<em>p</em> before <em>q</em>" and "it is possible that <em>p</em>".<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> “[Of] the sixteen possible truth-functions of <em>A</em> and <em>B</em>, material implication is the only serious candidate. First, it is uncontroversial that when <em>A</em> is true and <em>B</em> is false, "If <em>A</em>, <em>B</em>" is false. A basic rule of inference is <a href="modus_ponens" title="wikilink">modus ponens</a>: from "If <em>A</em>, <em>B</em>" and <em>A</em>, we can infer <em>B</em>. If it were possible to have <em>A</em> true, <em>B</em> false and "If <em>A</em>, <em>B</em>" true, this inference would be invalid. Second, it is uncontroversial that "If <em>A</em>, <em>B</em>" is sometimes true when <em>A</em> and <em>B</em> are respectively (true, true), or (false, true), or (false, false)… Non-truth-functional accounts agree that "If <em>A</em>, <em>B</em>" is false when <em>A</em> is true and <em>B</em> is false; and they agree that the conditional is sometimes true for the other three combinations of truth-values for the components; but they deny that the conditional is always true in each of these three cases. Some agree with the truth-functionalist that when <em>A</em> and <em>B</em> are both true, "If <em>A</em>, <em>B</em>" must be true. Some do not, demanding a further relation between the facts that <em>A</em> and that <em>B</em>.”<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <mtpl></mtpl></p>

<p>The meaning of the material conditional can sometimes be used in the <a href="natural_language" title="wikilink">natural language</a> English "if <em>condition</em> then <em>consequence</em>" construction (a kind of <a href="conditional_sentence" title="wikilink">conditional sentence</a>), where <em>condition</em> and <em>consequence</em> are to be filled with English sentences. However, this construction also implies a "reasonable" connection between the condition (<a href="Protasis_(linguistics)" title="wikilink">protasis</a>) and consequence (<a href="Consequent" title="wikilink">apodosis</a>) (see <a href="Connexive_logic" title="wikilink">Connexive logic</a>).</p>

<p>The material conditional can yield some unexpected truths when expressed in natural language. For example, any material conditional statement with a false antecedent is true (see <a href="vacuous_truth" title="wikilink">vacuous truth</a>). So the statement "if 2 is odd then 2 is even" is true. Similarly, any material conditional with a true consequent is true. So the statement "if I have a penny in my pocket then Paris is in France" is always true, regardless of whether or not there is a penny in my pocket. These problems are known as the <a href="paradoxes_of_material_implication" title="wikilink">paradoxes of material implication</a>, though they are not really paradoxes in the strict sense; that is, they do not elicit logical contradictions. These unexpected truths arise because speakers of English (and other natural languages) are tempted to <a href="equivocation" title="wikilink">equivocate</a> between the material conditional and the <a href="indicative_conditional" title="wikilink">indicative conditional</a>, or other conditional statements, like the <a href="counterfactual_conditional" title="wikilink">counterfactual conditional</a> and the <a href="logical_biconditional" title="wikilink">material biconditional</a>. It is not surprising that a rigorously defined truth-functional operator does not correspond exactly to all notions of implication or otherwise expressed by 'if...then...' sentences in English (or their equivalents in other natural languages). For an overview of some the various analyses, formal and informal, of conditionals, see the "References" section below.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a></li>
<li><a href="Boolean_domain" title="wikilink">Boolean domain</a></li>
<li><a href="Boolean_function" title="wikilink">Boolean function</a></li>
<li><a href="Boolean_logic" title="wikilink">Boolean logic</a></li>
</ul>
<ul>
<li><a href="Conditional_quantifier" title="wikilink">Conditional quantifier</a></li>
<li><a href="Implicational_propositional_calculus" title="wikilink">Implicational propositional calculus</a></li>
<li><a href="Laws_of_Form" title="wikilink">Laws of Form</a></li>
<li><a href="Logic_gate" title="wikilink">Logic gate</a></li>
<li><a href="Logical_graph" title="wikilink">Logical graph</a></li>
</ul>
<ul>
<li><a href="Paradoxes_of_material_implication" title="wikilink">Paradoxes of material implication</a></li>
<li><a href="Peirce's_law" title="wikilink">Peirce's law</a></li>
<li><a href="Propositional_logic" title="wikilink">Propositional logic</a></li>
<li><a href="Sole_sufficient_operator" title="wikilink">Sole sufficient operator</a></li>
</ul>
<h3 id="conditionals">Conditionals</h3>
<ul>
<li><a href="Counterfactual_conditional" title="wikilink">Counterfactual conditional</a></li>
<li><a href="Indicative_conditional" title="wikilink">Indicative conditional</a></li>
<li><a href="Corresponding_conditional" title="wikilink">Corresponding conditional</a></li>
<li><a href="Strict_conditional" title="wikilink">Strict conditional</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Brown, Frank Markham (2003), <em>Boolean Reasoning: The Logic of Boolean Equations</em>, 1st edition, <a class="uri" href="Kluwer" title="wikilink">Kluwer</a> Academic Publishers, <a href="Norwell,_Massachusetts" title="wikilink">Norwell</a>, MA. 2nd edition, <a href="Dover_Publications" title="wikilink">Dover Publications</a>, <a href="Mineola,_New_York" title="wikilink">Mineola</a>, NY, 2003.</li>
<li><a href="Dorothy_Edgington" title="wikilink">Edgington, Dorothy</a> (2001), "Conditionals", in Lou Goble (ed.), <em>The Blackwell Guide to Philosophical Logic</em>, <a href="Wiley-Blackwell" title="wikilink">Blackwell</a>.</li>
<li><a href="W._V._Quine" title="wikilink">Quine, W.V.</a> (1982), <em>Methods of Logic</em>, (1st ed. 1950), (2nd ed. 1959), (3rd ed. 1972), 4th edition, <a href="Harvard_University_Press" title="wikilink">Harvard University Press</a>, <a class="uri" href="Cambridge" title="wikilink">Cambridge</a>, MA.</li>
<li><a href="Robert_Stalnaker" title="wikilink">Stalnaker, Robert</a>, "Indicative Conditionals", <em><a href="Philosophia_(journal)" title="wikilink">Philosophia</a></em>, <strong>5</strong> (1975): 269–286.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Logical_connectives" title="wikilink">Category:Logical connectives</a> <a class="uri" href="Category:Conditionals" title="wikilink">Category:Conditionals</a> <a href="Category:Logical_consequence" title="wikilink">Category:Logical consequence</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
