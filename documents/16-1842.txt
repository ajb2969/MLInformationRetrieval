   Zassenhaus algorithm      Zassenhaus algorithm   In mathematics, the Zassenhaus algorithm 1 is a method to calculate a basis for the intersection and sum of two subspaces of a vector space . It is named after Hans Zassenhaus , but no publication of this algorithm by him is known. 2 It is used in computer algebra systems . 3  Algorithm  Input  Let   V   V   V   be a vector space and   U   U   U   ,   W   W   W   two finite-dimensional subspaces of   V   V   V   with the following spanning sets :      U  =   ⟨   u  1   ,  …  ,   u  n   ⟩       U    subscript  u  1   normal-…   subscript  u  n      U=\langle u_{1},\ldots,u_{n}\rangle   and       W  =   ⟨   w  1   ,  …  ,   w  k   ⟩    .      W    subscript  w  1   normal-…   subscript  w  k      W=\langle w_{1},\ldots,w_{k}\rangle.   Finally, let     B  1   ,  …  ,   B  m       subscript  B  1   normal-…   subscript  B  m     B_{1},\ldots,B_{m}   be linearly independent vectors so that    u  i     subscript  u  i    u_{i}   and    w  i     subscript  w  i    w_{i}   can be written as       u  i   =    ∑   j  =  1   m     a   i  ,  j     B  j          subscript  u  i     superscript   subscript     j  1    m      subscript  a   i  j     subscript  B  j       u_{i}=\sum_{j=1}^{m}a_{i,j}B_{j}   and        w  i   =    ∑   j  =  1   m     b   i  ,  j     B  j      .       subscript  w  i     superscript   subscript     j  1    m      subscript  b   i  j     subscript  B  j       w_{i}=\sum_{j=1}^{m}b_{i,j}B_{j}.     Output  The algorithm computes the base of the sum     U  +  W      U  W    U+W   and a base of the intersection     U  ∩  W      U  W    U\cap W   .  Algorithm  The algorithm creates the following block matrix of size    (    (   n  +  k   )   ×   (   2  m   )    )        n  k     2  m     ((n+k)\times(2m))   :      (      a   1  ,  1       a   ;   1  ,  2       ⋯     a   ;   1  ,  m        a   ;   1  ,  1        a   ;   1  ,  2       ⋯     a   ;   1  ,  m         ⋮    ⋮       ⋮    ⋮    ⋮       ⋮       a   n  ,  1       a   ;   n  ,  2       ⋯     a   ;   n  ,  m        a   ;   n  ,  1        a   ;   n  ,  2       ⋯     a   ;   n  ,  m          b   1  ,  1       b   ;   1  ,  2       ⋯     b   ;   1  ,  m       0    0    ⋯    0      ⋮    ⋮       ⋮    ⋮    ⋮       ⋮       b   k  ,  1       b   ;   k  ,  2       ⋯     b   ;   k  ,  m       0    0    ⋯    0     )       subscript  a   1  1     fragments  a   subscript  normal-;   1  2     normal-⋯   fragments  a   subscript  normal-;   1  m      fragments  a   subscript  normal-;   1  1      fragments  a   subscript  normal-;   1  2     normal-⋯   fragments  a   subscript  normal-;   1  m       normal-⋮  normal-⋮  absent  normal-⋮  normal-⋮  normal-⋮  absent  normal-⋮     subscript  a   n  1     fragments  a   subscript  normal-;   n  2     normal-⋯   fragments  a   subscript  normal-;   n  m      fragments  a   subscript  normal-;   n  1      fragments  a   subscript  normal-;   n  2     normal-⋯   fragments  a   subscript  normal-;   n  m        subscript  b   1  1     fragments  b   subscript  normal-;   1  2     normal-⋯   fragments  b   subscript  normal-;   1  m     0  0  normal-⋯  0    normal-⋮  normal-⋮  absent  normal-⋮  normal-⋮  normal-⋮  absent  normal-⋮     subscript  b   k  1     fragments  b   subscript  normal-;   k  2     normal-⋯   fragments  b   subscript  normal-;   k  m     0  0  normal-⋯  0     \begin{pmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,m}&a_{1,1}&a_{1,2}&\cdots&a_{1%
 ,m}\\
 \vdots&\vdots&&\vdots&\vdots&\vdots&&\vdots\\
 a_{n,1}&a_{n,2}&\cdots&a_{n,m}&a_{n,1}&a_{n,2}&\cdots&a_{n,m}\\
 b_{1,1}&b_{1,2}&\cdots&b_{1,m}&0&0&\cdots&0\\
 \vdots&\vdots&&\vdots&\vdots&\vdots&&\vdots\\
 b_{k,1}&b_{k,2}&\cdots&b_{k,m}&0&0&\cdots&0\end{pmatrix}     Using elementary row operations , this matrix is transformed to the row echelon form . Then, it has the following shape:      (      c   1  ,  1       c   ;   1  ,  2       ⋯     c   ;   1  ,  m       *    *    ⋯    *      ⋮    ⋮       ⋮    ⋮    ⋮       ⋮       c   q  ,  1       c   ;   q  ,  2       ⋯     c   ;   q  ,  m       *    *    ⋯    *      0    0    ⋯    0     d   ;   1  ,  1        d   ;   1  ,  2       ⋯     d   ;   1  ,  m         ⋮    ⋮       ⋮    ⋮    ⋮       ⋮      0    0    ⋯    0     d   ;   l  ,  1        d   ;   l  ,  2       ⋯     d   ;   l  ,  m         0    0    ⋯    0    0    0    ⋯    0      ⋮    ⋮       ⋮    ⋮    ⋮       ⋮      0    0    ⋯    0    0    0    ⋯    0     )       subscript  c   1  1     fragments  c   subscript  normal-;   1  2     normal-⋯   fragments  c   subscript  normal-;   1  m       normal-⋯     normal-⋮  normal-⋮  absent  normal-⋮  normal-⋮  normal-⋮  absent  normal-⋮     subscript  c   q  1     fragments  c   subscript  normal-;   q  2     normal-⋯   fragments  c   subscript  normal-;   q  m       normal-⋯     0  0  normal-⋯  0   fragments  d   subscript  normal-;   1  1      fragments  d   subscript  normal-;   1  2     normal-⋯   fragments  d   subscript  normal-;   1  m       normal-⋮  normal-⋮  absent  normal-⋮  normal-⋮  normal-⋮  absent  normal-⋮    0  0  normal-⋯  0   fragments  d   subscript  normal-;   l  1      fragments  d   subscript  normal-;   l  2     normal-⋯   fragments  d   subscript  normal-;   l  m       0  0  normal-⋯  0  0  0  normal-⋯  0    normal-⋮  normal-⋮  absent  normal-⋮  normal-⋮  normal-⋮  absent  normal-⋮    0  0  normal-⋯  0  0  0  normal-⋯  0     \begin{pmatrix}c_{1,1}&c_{1,2}&\cdots&c_{1,m}&*&*&\cdots&*\\
 \vdots&\vdots&&\vdots&\vdots&\vdots&&\vdots\\
 c_{q,1}&c_{q,2}&\cdots&c_{q,m}&*&*&\cdots&*\\
 0&0&\cdots&0&d_{1,1}&d_{1,2}&\cdots&d_{1,m}\\
 \vdots&\vdots&&\vdots&\vdots&\vdots&&\vdots\\
 0&0&\cdots&0&d_{l,1}&d_{l,2}&\cdots&d_{l,m}\\
 0&0&\cdots&0&0&0&\cdots&0\\
 \vdots&\vdots&&\vdots&\vdots&\vdots&&\vdots\\
 0&0&\cdots&0&0&0&\cdots&0\end{pmatrix}   Here,   *     *   stands for arbitrary numbers, and the vectors    (   c   p  ,  1    ,   c   p  ,  2    ,  …  ,   c   p  ,  m    )      subscript  c   p  1     subscript  c   p  2    normal-…   subscript  c   p  m      (c_{p,1},c_{p,2},\ldots,c_{p,m})   for every    p  ∈   {  1  ,  …  ,  q  }       p   1  normal-…  q     p\in\{1,\ldots,q\}   and    (   d   p  ,  1    ,  …  ,   d   p  ,  m    )      subscript  d   p  1    normal-…   subscript  d   p  m      (d_{p,1},\ldots,d_{p,m})   for every    p  ∈   {  1  ,  …  ,  l  }       p   1  normal-…  l     p\in\{1,\ldots,l\}   are nonzero.  Then    (   y  1   ,  …  ,   y  q   )      subscript  y  1   normal-…   subscript  y  q     (y_{1},\ldots,y_{q})   with       y  i   :=    ∑   j  =  1   m     c   i  ,  j     B  j        assign   subscript  y  i     superscript   subscript     j  1    m      subscript  c   i  j     subscript  B  j       y_{i}:=\sum_{j=1}^{m}c_{i,j}B_{j}   is a basis of    U  +  W      U  W    U+W   and    (   z  1   ,  …  ,   z  l   )      subscript  z  1   normal-…   subscript  z  l     (z_{1},\ldots,z_{l})   with       z  i   :=    ∑   j  =  1   m     d   i  ,  j     B  j        assign   subscript  z  i     superscript   subscript     j  1    m      subscript  d   i  j     subscript  B  j       z_{i}:=\sum_{j=1}^{m}d_{i,j}B_{j}   is a basis of    U  ∩  W      U  W    U\cap W   .  Proof of correctness  First, we define     π  1   :     V  ×  V   →  V   ,    (  a  ,  b  )   ↦  a       normal-:   subscript  π  1    formulae-sequence   normal-→    V  V   V    maps-to   a  b   a      \pi_{1}:V\times V\to V,(a,b)\mapsto a   to be the projection to the first component.  Let     H  :=    {   (  u  ,  u  )   ∣   u  ∈  U   }   +   {   (  w  ,  0  )   ∣   w  ∈  W   }    ≤   V  ×  V    .       assign  H     conditional-set   u  u     u  U     conditional-set   w  0     w  W            V  V      H:=\{(u,u)\mid u\in U\}+\{(w,0)\mid w\in W\}\leq V\times V.   Then      π  1    (  H  )    =   U  +  W          subscript  π  1   H     U  W     \pi_{1}(H)=U+W   and     H  ∩   (   0  ×  V   )    =   0  ×   (   U  ∩  W   )          H    0  V      0    U  W      H\cap(0\times V)=0\times(U\cap W)   .  Also,    H  ∩   (   0  ×  V   )       H    0  V     H\cap(0\times V)   is the kernel of      π  1   |   H     evaluated-at   subscript  π  1   H    {\pi_{1}|}_{H}   , the projection restricted to   H   H   H   . Therefore,     dim   (  H  )    =    dim   (   U  +  W   )    +   dim   (   U  ∩  W   )          dimension  H      dimension    U  W     dimension    U  W       \dim(H)=\dim(U+W)+\dim(U\cap W)   .  The Zassenhaus Algorithm calculates a basis of   H   H   H   . In the first   m   m   m   columns of this matrix, there is a basis    y  i     subscript  y  i    y_{i}   of    U  +  W      U  W    U+W   .  The rows of the form    (  0  ,   z  i   )     0   subscript  z  i     (0,z_{i})   (with     z  i   ≠  0       subscript  z  i   0    z_{i}\neq 0   ) are obviously in    H  ∩   (   0  ×  V   )       H    0  V     H\cap(0\times V)   . Because the matrix is in row echelon form , they also linearly independent. All rows which are different from zero (    (   y  i   ,  *  )      subscript  y  i      (y_{i},*)   and    (  0  ,   z  i   )     0   subscript  z  i     (0,z_{i})   ) are a basis of   H   H   H   , so there are    dim   (   U  ∩  W   )      dimension    U  W     \dim(U\cap W)   such    z  i     subscript  z  i    z_{i}   s. Therefore, the    z  i     subscript  z  i    z_{i}   s form a basis of    U  ∩  W      U  W    U\cap W   .  Example  Consider the two subspaces    U  =   ⟨   (     1       -  1       0      1     )   ,   (     0      0      1       -  1      )   ⟩       U     1      1     0    1      0    0    1      1        U=\left\langle\begin{pmatrix}1\\
 -1\\
 0\\
 1\end{pmatrix},\begin{pmatrix}0\\
 0\\
 1\\
 -1\end{pmatrix}\right\rangle   and    W  =   ⟨   (     5      0       -  3       3     )   ,   (     0      5       -  3        -  2      )   ⟩       W     5    0      3     3      0    5      3       2        W=\left\langle\begin{pmatrix}5\\
 0\\
 -3\\
 3\end{pmatrix},\begin{pmatrix}0\\
 5\\
 -3\\
 -2\end{pmatrix}\right\rangle   of the vector space    ℝ  4     superscript  ℝ  4    \mathbb{R}^{4}   .  Using the standard basis , we create the following matrix of dimension     (   2  +  2   )   ×   (   2  ⋅  4   )         2  2    normal-⋅  2  4     (2+2)\times(2\cdot 4)   :       (     1     -  1     0    1       1     -  1     0    1      0    0    1     -  1        0    0    1     -  1            5    0     -  3     3       0    0    0    0      0    5     -  3      -  2        0    0    0    0     )   .      1    1   0  1  absent  1    1   0  1    0  0  1    1   absent  0  0  1    1     absent    5  0    3   3  absent  0  0  0  0    0  5    3     2   absent  0  0  0  0     \begin{pmatrix}1&-1&0&1&&1&-1&0&1\\
 0&0&1&-1&&0&0&1&-1\\
 \\
 5&0&-3&3&&0&0&0&0\\
 0&5&-3&-2&&0&0&0&0\end{pmatrix}.     Using elementary row operations , we transform this matrix into the following matrix:      (     1    0    0    0       *    *    *    *      0    1    0     -  1        *    *    *    *      0    0    1     -  1        *    *    *    *           0    0    0    0       1     -  1     0    1     )      1  0  0  0  absent        0  1  0    1   absent        0  0  1    1   absent        absent    0  0  0  0  absent  1    1   0  1     \begin{pmatrix}1&0&0&0&&*&*&*&*\\
 0&1&0&-1&&*&*&*&*\\
 0&0&1&-1&&*&*&*&*\\
 \\
 0&0&0&0&&1&-1&0&1\end{pmatrix}   (some entries have been replaced by "   *     *   " because they are irrelevant to the result).  Therefore,    (   (     1      0      0      0     )   ,   (     0      1      0       -  1      )   ,   (     0      0      1       -  1      )   )       1    0    0    0      0    1    0      1       0    0    1      1       \left(\begin{pmatrix}1\\
 0\\
 0\\
 0\end{pmatrix},\begin{pmatrix}0\\
 1\\
 0\\
 -1\end{pmatrix},\begin{pmatrix}0\\
 0\\
 1\\
 -1\end{pmatrix}\right)   is a basis of    U  +  W      U  W    U+W   , and    (   (     1       -  1       0      1     )   )      1      1     0    1     \left(\begin{pmatrix}1\\
 -1\\
 0\\
 1\end{pmatrix}\right)   is a basis of    U  ∩  W      U  W    U\cap W   .  References  External links     de:Zassenhaus-Algorithmus "  Category:Algorithms  Category:Linear algebra     . ↩  ↩  ↩     