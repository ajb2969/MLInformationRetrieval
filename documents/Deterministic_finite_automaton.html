<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="110">Deterministic finite automaton</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Deterministic finite automaton</h1>
<hr/>

<p><a href="File:DFA_example_multiplies_of_3.svg" title="wikilink">thumb |250px |right|An example of a deterministic finite automaton that accepts only binary numbers that are multiples of 3. The state <em>S</em><sub>0</sub> is both the start state and an accept state.</a></p>

<p>In <a href="theory_of_computation" title="wikilink">theory of computation</a>, a branch of <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, a <strong>deterministic finite automaton</strong> (<strong>DFA</strong>)—also known as <strong>deterministic finite state machine</strong>—is a <a href="finite_state_machine" title="wikilink">finite state machine</a> that accepts/rejects finite strings of symbols and only produces a unique computation (or run) of the automaton for each input string.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> 'Deterministic' refers to the uniqueness of the computation. In search of simplest models to capture the finite state machines, McCulloch and Pitts were among the first researchers to introduce a concept similar to finite automaton in 1943.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The figure on the right illustrates a deterministic finite automaton using a <a href="state_diagram" title="wikilink">state diagram</a>. In the automaton, there are three states: S0, S1, and S2 (denoted graphically by circles). The automaton takes a finite sequence of 0s and 1s as input. For each state, there is a transition arrow leading out to a next state for both 0 and 1. Upon reading a symbol, a DFA jumps <em>deterministically</em> from a state to another by following the transition arrow. For example, if the automaton is currently in state S0 and current input symbol is 1 then it deterministically jumps to state S1. A DFA has a <em>start state</em> (denoted graphically by an arrow coming in from nowhere) where computations begin, and a <a href="set_(mathematics)" title="wikilink">set</a> of <em>accept states</em> (denoted graphically by a double circle) which help define when a computation is successful.</p>

<p>A DFA is defined as an abstract mathematical concept, but due to the deterministic nature of a DFA, it is implementable in hardware and software for solving various specific problems. For example, a DFA can model software that decides whether or not online user-input such as email addresses are valid.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (see: <a href="finite_state_machine" title="wikilink">finite state machine</a> for more practical examples).</p>

<p>DFAs recognize exactly the set of <a href="regular_language" title="wikilink">regular languages</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> which are, among other things, useful for doing <a href="lexical_analysis" title="wikilink">lexical analysis</a> and pattern matching. DFAs can be built from <a href="nondeterministic_finite_automata" title="wikilink">nondeterministic finite automata</a> (NFAs) using the <a href="powerset_construction" title="wikilink">powerset construction</a> method.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>A <strong>deterministic finite automaton</strong> <em>M</em> is a 5-<a href="n-tuple" title="wikilink">tuple</a>, (<em>Q</em>, Σ, δ, <em>q</em><sub><em>0</em></sub>, <em>F</em>), consisting of</p>
<ul>
<li>a finite set of <a href="State_(computer_science)" title="wikilink">states</a> (<em>Q</em>)</li>
<li>a finite set of input symbols called the <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> (Σ)</li>
<li>a transition <a href="function_(mathematics)" title="wikilink">function</a> (δ : <em>Q</em> × Σ → <em>Q</em>)</li>
<li>a <a href="Finite_state_machine#Start_state" title="wikilink">start state</a> (<em>q</em><sub><em>0</em></sub> ∈ <em>Q</em>)</li>
<li>a set of <a href="Finite_state_machine#Accept_.28or_final.29_states" title="wikilink">accept states</a> (<em>F</em> ⊆ <em>Q</em>)</li>
</ul>

<p>Let <em>w = a<sub>1</sub>a<sub>2</sub> ... a<sub>n</sub></em> be a string over the alphabet Σ. The automaton <em>M</em> accepts the string <em>w</em> if a sequence of states, <em>r<sub>0</sub>,r<sub>1</sub>, ..., r<sub>n</sub></em>, exists in <em>Q</em> with the following conditions:</p>
<ol>
<li><em>r<sub>0</sub></em> = <em>q</em><sub><em>0</em></sub></li>
<li><em>r<sub>i+1</sub></em> = δ(<em>r<sub>i</sub></em>, <em>a<sub>i+1</sub></em>), for <em>i</em> = <em>0, ..., n−1</em></li>
<li><em>r<sub>n</sub></em> ∈ <em>F</em>.</li>
</ol>

<p>In words, the first condition says that the machine starts in the start state <em>q</em><sub>0</sub>. The second condition says that given each character of string <em>w</em>, the machine will transition from state to state according to the transition function δ. The last condition says that the machine accepts <em>w</em> if the last input of <em>w</em> causes the machine to halt in one of the accepting states. Otherwise, it is said that the automaton <em>rejects</em> the string. The set of strings that <em>M</em> accepts is the <a href="Formal_language" title="wikilink">language</a> <em>recognized</em> by <em>M</em> and this language is denoted by <em>L(M)</em>.</p>

<p>A deterministic finite automaton without accept states and without a starting state is known as a <a href="transition_system" title="wikilink">transition system</a> or <a class="uri" href="semiautomaton" title="wikilink">semiautomaton</a>.</p>

<p>For more comprehensive introduction of the formal definition see <a href="automata_theory" title="wikilink">automata theory</a>.</p>
<h2 id="example">Example</h2>

<p>The following example is of a DFA <em>M</em>, with a binary alphabet, which requires that the input contains an even number of 0s.</p>

<p> <em>M</em> = (<em>Q</em>, Σ, δ, <em>q<sub>0</sub></em>, <em>F</em>) where</p>
<ul>
<li><em>Q</em> = {<em>S</em><sub>1</sub>, <em>S</em><sub>2</sub>},</li>
<li>Σ = {0, 1},</li>
<li><em>q<sub>0</sub></em> = <em>S</em><sub>1</sub>,</li>
<li><em>F</em> = {<em>S</em><sub>1</sub>}, and</li>
<li>δ is defined by the following <a href="state_transition_table" title="wikilink">state transition table</a>:</li>
</ul>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><center>

<p><strong>0</strong></p>
</center></td>
<td style="text-align: left;"><center>

<p><strong>1</strong></p>
</center></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong><em>S</em><sub>1</sub></strong></p></td>
<td style="text-align: left;">
<p><em>S</em><sub>2</sub></p></td>
<td style="text-align: left;">
<p><em>S</em><sub>1</sub></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong><em>S</em><sub>2</sub></strong></p></td>
<td style="text-align: left;">
<p><em>S</em><sub>1</sub></p></td>
<td style="text-align: left;">
<p><em>S</em><sub>2</sub></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>The state <em>S</em><sub>1</sub> represents that there has been an even number of 0s in the input so far, while <em>S</em><sub>2</sub> signifies an odd number. A 1 in the input does not change the state of the automaton. When the input ends, the state will show whether the input contained an even number of 0s or not. If the input did contain an even number of 0s, <em>M</em> will finish in state <em>S</em><sub>1</sub>, an accepting state, so the input string will be accepted.</p>

<p>The language recognized by <em>M</em> is the <a href="regular_language" title="wikilink">regular language</a> given by the <a href="regular_expression" title="wikilink">regular expression</a> (1 + 0 (1*) 0)*, where "*" is the <a href="Kleene_star" title="wikilink">Kleene star</a>, e.g., 1* denotes any non-negative number (possibly zero) of symbols "1".</p>
<h2 id="closure-properties">Closure properties</h2>

<p>If DFAs recognize the languages that are obtained by applying an operation on the DFA recognizable languages then DFAs are said to be <a href="closed_under" title="wikilink">closed under</a> the operation. The DFAs are closed under the following operations.</p>
<ul>
<li>Union</li>
<li>Intersection</li>
<li>Concatenation</li>
<li>Negation</li>
<li><a href="Kleene_closure" title="wikilink">Kleene closure</a></li>
<li>Reversal</li>
<li>Init</li>
<li>Quotient</li>
<li>Substitution</li>
<li>Homomorphism</li>
</ul>

<p>Since DFAs are <a href="Powerset_construction" title="wikilink">equivalent</a> to <a href="nondeterministic_finite_automaton" title="wikilink">nondeterministic finite automata</a> (NFA), these closures may be proved using closure properties of NFA.</p>
<h2 id="dfa-as-a-transition-monoid">DFA as a transition monoid</h2>

<p>Alternatively a run can be seen as a sequence of compositions of transition function with itself. Given an input symbol 

<math display="inline" id="Deterministic_finite_automaton:0">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in\Sigma
  </annotation>
 </semantics>
</math>

, one may write the transition function as 

<math display="inline" id="Deterministic_finite_automaton:1">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mi>a</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>Q</mi>
    <mo>→</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>Q</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{a}:Q\rightarrow Q
  </annotation>
 </semantics>
</math>

, using the simple trick of <a class="uri" href="currying" title="wikilink">currying</a>, that is, writing 

<math display="inline" id="Deterministic_finite_automaton:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>δ</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <ci>q</ci>
      <ci>a</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <ci>a</ci>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(q,a)=\delta_{a}(q)
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Deterministic_finite_automaton:3">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>q</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\in Q
  </annotation>
 </semantics>
</math>

. This way, the transition function can be seen in simpler terms: it's just something that "acts" on a state in Q, yielding another state. One may then consider the result of <a href="function_composition" title="wikilink">function composition</a> repeatedly applied to the various functions 

<math display="inline" id="Deterministic_finite_automaton:4">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>a</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{a}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Deterministic_finite_automaton:5">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>b</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{b}
  </annotation>
 </semantics>
</math>

, and so on. Using this notion we define 

<math display="inline" id="Deterministic_finite_automaton:6">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>δ</mi>
    <mo>^</mo>
   </mover>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mo>×</mo>
     <msup>
      <mi mathvariant="normal">Σ</mi>
      <mo>⋆</mo>
     </msup>
    </mrow>
    <mo>→</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <ci>normal-^</ci>
     <ci>δ</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Σ</ci>
       <ci>normal-⋆</ci>
      </apply>
     </apply>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\delta}:Q\times\Sigma^{\star}\rightarrow Q
  </annotation>
 </semantics>
</math>

. Given a pair of letters 

<math display="inline" id="Deterministic_finite_automaton:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>a</ci>
     <ci>b</ci>
    </list>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b\in\Sigma
  </annotation>
 </semantics>
</math>

, one may define a new function 

<math display="inline" id="Deterministic_finite_automaton:8">
 <semantics>
  <mover accent="true">
   <mi>δ</mi>
   <mo>^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\delta}
  </annotation>
 </semantics>
</math>

, by insisting that 

<math display="inline" id="Deterministic_finite_automaton:9">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>δ</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>δ</mi>
     <mi>a</mi>
    </msub>
    <mo>∘</mo>
    <msub>
     <mi>δ</mi>
     <mi>b</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>δ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\delta}_{ab}=\delta_{a}\circ\delta_{b}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Deterministic_finite_automaton:10">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 denotes function composition. Clearly, this process can be recursively continued. So, we have the following recursive definition</p>

<p>

<math display="block" id="Deterministic_finite_automaton:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>δ</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>q</mi>
      <mo>,</mo>
      <mi>ϵ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>q</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>δ</ci>
     </apply>
     <interval closure="open">
      <ci>q</ci>
      <ci>ϵ</ci>
     </interval>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\delta}(q,\epsilon)=q.
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Deterministic_finite_automaton:12">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 is empty string and</p>

<p>

<math display="block" id="Deterministic_finite_automaton:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>δ</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>q</mi>
      <mo>,</mo>
      <mrow>
       <mi>w</mi>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>δ</mi>
      <mi>a</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <mi>δ</mi>
        <mo>^</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>q</mi>
        <mo>,</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>δ</ci>
     </apply>
     <interval closure="open">
      <ci>q</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>a</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>δ</ci>
      </apply>
      <interval closure="open">
       <ci>q</ci>
       <ci>w</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\delta}(q,wa)=\delta_{a}(\widehat{\delta}(q,w)).
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Deterministic_finite_automaton:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mo>∈</mo>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mo>∈</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>a</ci>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\Sigma^{*},a\in\Sigma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Deterministic_finite_automaton:15">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>q</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\in Q
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Deterministic_finite_automaton:16">
 <semantics>
  <mover accent="true">
   <mi>δ</mi>
   <mo>^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\delta}
  </annotation>
 </semantics>
</math>

 is defined for all words 

<math display="inline" id="Deterministic_finite_automaton:17">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Σ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\Sigma^{*}
  </annotation>
 </semantics>
</math>

. Repeated function composition forms a <a class="uri" href="monoid" title="wikilink">monoid</a>. For the transition functions, this monoid is known as the <a href="transition_monoid" title="wikilink">transition monoid</a>, or sometimes the <em>transformation semigroup</em>. The construction can also be reversed: given a 

<math display="inline" id="Deterministic_finite_automaton:18">
 <semantics>
  <mover accent="true">
   <mi>δ</mi>
   <mo>^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\delta}
  </annotation>
 </semantics>
</math>

, one can reconstruct a 

<math display="inline" id="Deterministic_finite_automaton:19">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

, and so the two descriptions are equivalent.</p>
<h2 id="local-automata">Local automata</h2>

<p>A <strong>local automaton</strong> is a DFA for which all edges with the same label lead to a single vertex. Local automata accept the class of <a href="Local_language_(formal_language)" title="wikilink">local languages</a>, those for which membership of a word in the language is determined by a "sliding window" of length two on the word.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>A <strong>Myhill graph</strong> over an alphabet <em>A</em> is a <a href="directed_graph" title="wikilink">directed graph</a> with <a href="Vertex_(graph_theory)" title="wikilink">vertex set</a> <em>A</em> and subsets of vertices labelled "start" and "finish". The language accepted by a Myhill graph is the set of directed paths from a start vertex to a finish vertex: the graph thus acts as an automaton.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The class of languages accepted by Myhill graphs is the class of local languages.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="random-dfa">Random DFA</h2>

<p>When the start state and accept states are ignored, a DFA of 

<math display="inline" id="Deterministic_finite_automaton:20">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-states and an alphabet of size 

<math display="inline" id="Deterministic_finite_automaton:21">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 can be seen as a <a href="Directed_graph" title="wikilink">digraph</a> of 

<math display="inline" id="Deterministic_finite_automaton:22">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices in which all vertices have 

<math display="inline" id="Deterministic_finite_automaton:23">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 out-arcs labeled 

<math display="inline" id="Deterministic_finite_automaton:24">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>k</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1,\ldots,k
  </annotation>
 </semantics>
</math>

 (a 

<math display="inline" id="Deterministic_finite_automaton:25">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-out digraph). It is known that when 

<math display="inline" id="Deterministic_finite_automaton:26">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\geq 2
  </annotation>
 </semantics>
</math>

 is a fixed integer, with high probability, the largest <a href="strongly_connected_component" title="wikilink">strongly connected component</a> (SCC) in such a 

<math display="inline" id="Deterministic_finite_automaton:27">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-out digraph chosen uniformly at random is of linear size and it can be reached by all vertices.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> It has also been prove that if 

<math display="inline" id="Deterministic_finite_automaton:28">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is allowed to increase as 

<math display="inline" id="Deterministic_finite_automaton:29">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 increases, then the whole digraph has a phase transition for strong connectivity similar to <a href="Erdős–Rényi_model" title="wikilink">Erdős–Rényi model</a> for connectivity.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>In a random DFA, the maximum number of vertices reachable from one vertex is very close to the number of vertices in the largest <a href="strongly_connected_component" title="wikilink">SCC</a> with high probably.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> This is also true for the largest <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">induced sub-digraph</a> of minimum in-degree one, which can be seen as a directed version of <a href="Degeneracy_(graph_theory)#k-Cores" title="wikilink">

<math display="inline" id="Deterministic_finite_automaton:30">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

-core</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="advantages-and-disadvantages">Advantages and disadvantages</h2>

<p>DFAs were invented to model <em>real world</em> finite state machines in contrast to the concept of a <a href="Turing_machine" title="wikilink">Turing machine</a>, which was too general to study properties of real world machines.</p>

<p>DFAs are one of the most practical models of computation, since there is a trivial linear time, constant-space, <a href="online_algorithm" title="wikilink">online algorithm</a> to simulate a DFA on a stream of input. Also, there are efficient algorithms to find a DFA recognizing:</p>
<ul>
<li>the complement of the language recognized by a given DFA.</li>
<li>the union/intersection of the languages recognized by two given DFAs.</li>
</ul>

<p>Because DFAs can be reduced to a <em>canonical form</em> (<a href="Dfa_minimization" title="wikilink">minimal DFAs</a>), there are also efficient algorithms to determine:</p>
<ul>
<li>whether a DFA accepts any strings</li>
<li>whether a DFA accepts all strings</li>
<li>whether two DFAs recognize the same language</li>
<li>the DFA with a minimum number of states for a particular regular language</li>
</ul>

<p>DFAs are equivalent in computing power to <a href="nondeterministic_finite_automata" title="wikilink">nondeterministic finite automata</a> (NFAs). This is because, firstly any DFA is also an NFA, so an NFA can do what a DFA can do. Also, given an NFA, using the <a href="powerset_construction" title="wikilink">powerset construction</a> one can build a DFA that recognizes the same language as the NFA, although the DFA could have exponentially larger number of states than the NFA.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>On the other hand, finite state automata are of strictly limited power in the languages they can recognize; many simple languages, including any problem that requires more than constant space to solve, cannot be recognized by a DFA. The classical example of a simply described language that no DFA can recognize is bracket or <a href="Dyck_language" title="wikilink">Dyck language</a>, i.e., the language that consists of properly paired brackets such as word "(()())". Intuitively, no DFA can recognize the bracket language because there is no limit to <a class="uri" href="recursion" title="wikilink">recursion</a>, i.e., one can always embed another pair of brackets inside, and hence would require an infinite number of states to recognize. Another simpler example is the language consisting of strings of the form ''a<sup>n</sup>b<sup>n</sup> for some finite but arbitrary number of <em>a</em>'s, followed by an equal number of <em>b</em>'s.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Acyclic_deterministic_finite_automata" title="wikilink">Acyclic deterministic finite automata</a></li>
<li><a href="DFA_minimization" title="wikilink">DFA minimization</a></li>
<li><a href="Monadic_second-order_logic" title="wikilink">Monadic second-order logic</a></li>
<li><a href="Quantum_finite_automata" title="wikilink">Quantum finite automata</a></li>
<li><a href="Read-only_right_moving_Turing_Machines" title="wikilink">Read-only right moving Turing Machines</a></li>
<li><a href="Turing_machine" title="wikilink">Turing machine</a></li>
<li><a href="Two-way_deterministic_finite_automaton" title="wikilink">Two-way deterministic finite automaton</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<ul>
<li></li>
<li></li>
<li>

<p>. Section 1.1: Finite Automata, pp. 31–47. Subsection "Decidable Problems Concerning Regular Languages" of section 4.1: Decidable Languages, pp. 152–155.4.4 DFA can accept only regular language</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://home.arcor.de/kai.w1986/dfasimulator/">DFA Simulator - an open source graphical editor and simulator of DFA</a></li>
</ul>

<p>"</p>

<p><a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#HMU" title="wikilink">Hopcroft 2001</a>:<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#MP43" title="wikilink">McCulloch and Pitts (1943)</a>:<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#RS59" title="wikilink">Rabin and Scott (1959)</a>:<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Lawson (2004) p.129<a href="#fnref6">↩</a></li>
<li id="fn7">Sakarovitch (2009) p.228<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9">Lawson (2004) p.128<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">Sakarovitch (2009) p.105<a href="#fnref15">↩</a></li>
<li id="fn16">Lawson (2004) p.63<a href="#fnref16">↩</a></li>
<li id="fn17">Lawson (2004) p.46<a href="#fnref17">↩</a></li>
</ol>
</section>
</body>
</html>
