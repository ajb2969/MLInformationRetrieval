<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="637">Principles of grid generation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Principles of grid generation</h1>
<hr/>

<p>A <strong>grid</strong> is a small-sized geometrical shape that covers the physical domain, whose objective is to identify the <a href="discrete_space" title="wikilink">discrete</a> volumes or elements where <a href="Conservation_law_(physics)" title="wikilink">conservation laws</a> can be applied. Grid generation is the first process involved in computing <a href="numerical_analysis" title="wikilink">numerical</a> solutions to the equations that describe a physical process. The result of the <a class="uri" href="solution" title="wikilink">solution</a> depends upon the quality of grid. A well-constructed grid can improve the quality of solution whereas, deviations from the numerical solution can be observed with poorly constructed grid. <a href="Scientific_technique" title="wikilink">Techniques</a> for creating the cell forms the basis of grid generation. Various methods to generate grids are discussed below.</p>
<h2 id="algebraic-methods">Algebraic methods</h2>

<p>  The grid generation by algebraic methods is done by using known functions in one, two or three <a class="uri" href="dimensions" title="wikilink">dimensions</a> taking arbitrary shaped regions. The computational domain might not be rectangular one, but for the sake of simplicity, the domain is taken to be rectangular. The simplest procedure that may be used to produce boundary fitted computational mesh is the normalization transformation.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><br/>
For a nozzle, with the describing function 

<math display="inline" id="Principles_of_grid_generation:0">
<semantics>
<mrow>
<mi>y</mi>
<mo>=</mo>
<msup>
<mi>x</mi>
<mn>2</mn>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y=x^{2}
  </annotation>
</semantics>
</math>

 the grid can easily be generated using uniform division in y-direction with equally spaced increments in x-direction, which are described by</p>

<p>
<math display="block" id="Principles_of_grid_generation:1">
<semantics>
<mrow>
<mi>ξ</mi>
<mo>=</mo>
<mpadded width="+1.7pt">
<mi>x</mi>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>ξ</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \xi=x\,
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Principles_of_grid_generation:2">
<semantics>
<mrow>
<mi>η</mi>
<mo>=</mo>
<mpadded width="+1.7pt">
<mfrac>
<mi>y</mi>
<msub>
<mi>y</mi>
<mi>max</mi>
</msub>
</mfrac>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>η</ci>
<apply>
<divide></divide>
<ci>y</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<max></max>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \eta=\frac{y}{y_{\max}}\,
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Principles_of_grid_generation:3">
<semantics>
<msub>
<mi>y</mi>
<mi>max</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<max></max>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y_{\max}
  </annotation>
</semantics>
</math>

 denotes the y-coordinate of the nozzle wall. For given values of (

<math display="inline" id="Principles_of_grid_generation:4">
<semantics>
<mi>ξ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ξ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \xi
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Principles_of_grid_generation:5">
<semantics>
<mi>η</mi>
<annotation-xml encoding="MathML-Content">
<ci>η</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \eta
  </annotation>
</semantics>
</math>

) the values of (

<math display="inline" id="Principles_of_grid_generation:6">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Principles_of_grid_generation:7">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

) can be easily recovered.</p>
<h2 id="differential-equation-methods">Differential equation methods</h2>

<p>Like algebraic methods, differential equation methods are also used to generate grids. The advantage of using the <a href="partial_differential_equations" title="wikilink">partial differential equations</a> (PDEs) is that the solution of grid generating equations can be exploited to generate the mesh. Grid construction can be done using all three classes of partial differential equations.</p>
<h3 id="elliptic-schemes">Elliptic schemes</h3>

<p>Elliptic <a href="Partial_differential_equation" title="wikilink">PDEs</a> generally have very smooth solutions leading to smooth contours. Using its smoothness as an advantage <a href="Laplace's_equation" title="wikilink">Laplace Equations</a> can preferably be used because the <a href="Jacobian_matrix_and_determinant" title="wikilink">Jacobian</a> found out to be positive as a result of maximum principle for <a href="harmonic_function" title="wikilink">harmonic functions</a>. After extensive work done by Crowley (1962) and Winslow (1966)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> on PDEs by transforming physical domain into computational plane while mapping using <a href="Poisson's_equation" title="wikilink">Poisson’s equation</a>, Thompson et al. (1974)<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> have worked extensively on elliptic <a href="Partial_differential_equation" title="wikilink">PDEs</a> to generate grids. In Poisson grid generators, the mapping is accomplished by marking the desired grid points (x, y) on the boundary of the physical domain, with the interior point distribution determined through the solution of equations written below</p>

<p>
<math display="block" id="Principles_of_grid_generation:8">
<semantics>
<mrow>
<mrow>
<msub>
<mi>ξ</mi>
<mrow>
<mi>x</mi>
<mi>x</mi>
</mrow>
</msub>
<mo>+</mo>
<msub>
<mi>ξ</mi>
<mrow>
<mi>y</mi>
<mi>y</mi>
</mrow>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ξ</mi>
<mo>,</mo>
<mi>η</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ξ</ci>
<apply>
<times></times>
<ci>x</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ξ</ci>
<apply>
<times></times>
<ci>y</ci>
<ci>y</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>P</ci>
<interval closure="open">
<ci>ξ</ci>
<ci>η</ci>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \xi_{xx}+\xi_{yy}=P(\xi,\eta)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Principles_of_grid_generation:9">
<semantics>
<mrow>
<mrow>
<msub>
<mi>η</mi>
<mrow>
<mi>x</mi>
<mi>x</mi>
</mrow>
</msub>
<mo>+</mo>
<msub>
<mi>η</mi>
<mrow>
<mi>y</mi>
<mi>y</mi>
</mrow>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<mi>Q</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ξ</mi>
<mo>,</mo>
<mi>η</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>η</ci>
<apply>
<times></times>
<ci>x</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>η</ci>
<apply>
<times></times>
<ci>y</ci>
<ci>y</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>Q</ci>
<interval closure="open">
<ci>ξ</ci>
<ci>η</ci>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \eta_{xx}+\eta_{yy}=Q(\xi,\eta)
  </annotation>
</semantics>
</math>
</p>

<p>where (<em>ξ</em>, <em>η</em>) are the co-ordiantes in the computational domain, while P and Q are responsible for point spacing within D. Transforming above equations in computational space yields a set of two elliptical PDEs of the form,</p>

<p>
<math display="block" id="Principles_of_grid_generation:10">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mi>α</mi>
<msub>
<mi>x</mi>
<mrow>
<mi>ξ</mi>
<mi>ξ</mi>
</mrow>
</msub>
</mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>β</mi>
<msub>
<mi>x</mi>
<mrow>
<mi>ξ</mi>
<mi>η</mi>
</mrow>
</msub>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mi>γ</mi>
<msub>
<mi>x</mi>
<mrow>
<mi>η</mi>
<mi>η</mi>
</mrow>
</msub>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<msup>
<mi>I</mi>
<mn>2</mn>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>P</mi>
<msub>
<mi>x</mi>
<mi>ξ</mi>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>Q</mi>
<msub>
<mi>x</mi>
<mi>η</mi>
</msub>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>α</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<times></times>
<ci>ξ</ci>
<ci>ξ</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>β</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<times></times>
<ci>ξ</ci>
<ci>η</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>γ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<times></times>
<ci>η</ci>
<ci>η</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>I</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>ξ</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>η</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha x_{\xi\xi}-2\beta x_{\xi\eta}+\gamma x_{\eta\eta}=-I^{2}(Px_{\xi}+Qx_{%
\eta})
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Principles_of_grid_generation:11">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mi>α</mi>
<msub>
<mi>y</mi>
<mrow>
<mi>ξ</mi>
<mi>ξ</mi>
</mrow>
</msub>
</mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>β</mi>
<msub>
<mi>y</mi>
<mrow>
<mi>ξ</mi>
<mi>η</mi>
</mrow>
</msub>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mi>γ</mi>
<msub>
<mi>y</mi>
<mrow>
<mi>η</mi>
<mi>η</mi>
</mrow>
</msub>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<msup>
<mi>I</mi>
<mn>2</mn>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>P</mi>
<msub>
<mi>y</mi>
<mi>ξ</mi>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>Q</mi>
<msub>
<mi>y</mi>
<mi>η</mi>
</msub>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>α</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<apply>
<times></times>
<ci>ξ</ci>
<ci>ξ</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>β</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<apply>
<times></times>
<ci>ξ</ci>
<ci>η</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>γ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<apply>
<times></times>
<ci>η</ci>
<ci>η</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>I</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>ξ</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>η</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha y_{\xi\xi}-2\beta y_{\xi\eta}+\gamma y_{\eta\eta}=-I^{2}(Py_{\xi}+Qy_{%
\eta})
  </annotation>
</semantics>
</math>
</p>

<p>where</p>

<p>
<math display="inline" id="Principles_of_grid_generation:12">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \displaystyle\alpha
  </annotation>
</semantics>
</math>
</p>

<p>These systems of equations are solved in the computational plane on uniformly spaced grid which provides us with the (<em>x</em>, <em>y</em>) co-ordinates of each point in physical space. The advantage of using Elliptical PDEs is the solution linked to them is smooth and the resulting grid is smooth. But, specification of P and Q becomes a difficult task thus adding it to its disadvantages. Moreover, the grid has to be computed after each time step which adds up to computational time.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="hyperbolic-schemes">Hyperbolic schemes</h3>

<p>This grid generation scheme is generally applicable to problems with open domains consistent with the type of <a href="Partial_differential_equation" title="wikilink">PDE</a> describing the physical problem. The advantage associated with Hyperbolic PDEs is that the governing equations need to be solved only once for generating grid. The initial point distribution along with the approximate boundary conditions forms the required input and the solution is the then marched outward. Steger and Sorenson (1980)<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> proposed a volume orthogonality method that uses Hyperbolic PDEs for mesh generation. For a 2-D problem, Considering computational space to be given by 

<math display="inline" id="Principles_of_grid_generation:13">
<semantics>
<mrow>
<mrow>
<mi mathvariant="normal">Δ</mi>
<mi>ξ</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi mathvariant="normal">Δ</mi>
<mi>η</mi>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>normal-Δ</ci>
<ci>ξ</ci>
</apply>
<apply>
<times></times>
<ci>normal-Δ</ci>
<ci>η</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Delta\xi=\Delta\eta=1
  </annotation>
</semantics>
</math>

, the inverse of the <a href="Jacobian_matrix_and_determinant" title="wikilink">Jacobian</a> is given by,</p>

<p>
<math display="block" id="Principles_of_grid_generation:14">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>x</mi>
<mi>ξ</mi>
</msub>
<msub>
<mi>y</mi>
<mi>η</mi>
</msub>
</mrow>
<mo>-</mo>
<mrow>
<msub>
<mi>x</mi>
<mi>η</mi>
</msub>
<msub>
<mi>y</mi>
<mi>ξ</mi>
</msub>
</mrow>
</mrow>
<mo>=</mo>
<mi>I</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>ξ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>η</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>η</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>ξ</ci>
</apply>
</apply>
</apply>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{\xi}y_{\eta}-x_{\eta}y_{\xi}=I
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Principles_of_grid_generation:15">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

 represents the area in physical space for a given area in computational space. The second equation links the orthogonality of grid lines at the boundary in physical space which can be written as</p>

<p>
<math display="block" id="Principles_of_grid_generation:16">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>d</mi>
<mi>ξ</mi>
</mrow>
<mo>=</mo>
<mn>0</mn>
<mo>=</mo>
<mrow>
<mrow>
<mpadded width="+1.7pt">
<msub>
<mi>ξ</mi>
<mi>x</mi>
</msub>
</mpadded>
<mi>d</mi>
<mi>x</mi>
</mrow>
<mo>+</mo>
<mrow>
<mpadded width="+1.7pt">
<msub>
<mi>ξ</mi>
<mi>y</mi>
</msub>
</mpadded>
<mi>d</mi>
<mi>y</mi>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>d</ci>
<ci>ξ</ci>
</apply>
<cn type="integer">0</cn>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ξ</ci>
<ci>x</ci>
</apply>
<ci>d</ci>
<ci>x</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ξ</ci>
<ci>y</ci>
</apply>
<ci>d</ci>
<ci>y</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d\xi=0=\xi_{x}\,dx+\xi_{y}\,dy.
  </annotation>
</semantics>
</math>
</p>

<p>For 

<math display="inline" id="Principles_of_grid_generation:17">
<semantics>
<mi>ξ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ξ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \xi
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Principles_of_grid_generation:18">
<semantics>
<mi>η</mi>
<annotation-xml encoding="MathML-Content">
<ci>η</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \eta
  </annotation>
</semantics>
</math>

 surfaces to be perpendicular the equation becomes</p>

<p>
<math display="block" id="Principles_of_grid_generation:19">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>x</mi>
<mi>ξ</mi>
</msub>
<msub>
<mi>x</mi>
<mi>η</mi>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>y</mi>
<mi>ξ</mi>
</msub>
<msub>
<mi>y</mi>
<mi>η</mi>
</msub>
</mrow>
</mrow>
<mo>=</mo>
<mn>0.</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>ξ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>η</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>ξ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>η</ci>
</apply>
</apply>
</apply>
<cn type="float">0.</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{\xi}x_{\eta}+y_{\xi}y_{\eta}=0.
  </annotation>
</semantics>
</math>
</p>

<p>The problem associated with such system of equations is the specification of 

<math display="inline" id="Principles_of_grid_generation:20">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

. Poor selection of 

<math display="inline" id="Principles_of_grid_generation:21">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

 may lead to shock and discontinuous propagation of this information throughout the mesh. While mesh being orthogonal is generated very rapidly which comes out as an advantage with this method.</p>
<h3 id="parabolic-schemes">Parabolic schemes</h3>

<p>The solving technique is similar to that of hyperbolic <a class="uri" href="PDEs" title="wikilink">PDEs</a> by advancing the solution away from the initial data surface satisfying the boundary conditions at the end. Nakamura (1982) and Edwards (1985) developed the basic ideas for parabolic grid generation. The idea uses either of <a class="uri" href="Laplace" title="wikilink">Laplace</a> or the <a href="Poisson's_equation" title="wikilink">Poisson's equation</a> and especially treating the parts which controls elliptic behavior. The initial values are given as the coordinates of the point along the surface 

<math display="inline" id="Principles_of_grid_generation:22">
<semantics>
<mrow>
<mi>η</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>η</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \eta=0
  </annotation>
</semantics>
</math>

 and the advancing the solutions to the outer surface of the object satisfying the boundary conditions along 

<math display="inline" id="Principles_of_grid_generation:23">
<semantics>
<mi>ξ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ξ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \xi
  </annotation>
</semantics>
</math>

 edges.</p>

<p>The control of the grid spacing has not been suggested till now. Nakamura and Edwards, grid control was accomplished using non uniform spacing. The parabolic grid generation shows an advantage over the hyperbolic grid generation that, no shocks or discontinuities occur and the grid is relatively smooth. The specifications of initial values and selection of step size to control the grid points is however time consuming, but these techniques can be effective when familiarity and experience is gained.</p>
<h2 id="variational-method">Variational method</h2>

<p>This method includes a technique that minimizes <a href="Grid_(spatial_index)" title="wikilink">grid</a> smoothness, <a class="uri" href="orthogonality" title="wikilink">orthogonality</a> and volume variation. This method forms mathematical platform to solve grid generation problems. In this method an alternative grid is generated by a new <a class="uri" href="mesh" title="wikilink">mesh</a> after each iteration and computing the grid speed using <a href="backward_difference_method" title="wikilink">backward difference method</a>. This technique is a powerful one with a disadvantage that effort is required to solve the equations related to grid. Further work needed to be done to minimize the <a class="uri" href="integrals" title="wikilink">integrals</a> that will reduce the CPU time.</p>
<h2 id="unstructured-grid-generation">Unstructured grid generation</h2>

<p>The main importance of this scheme is that it provides a method that will generate the grid automatically. Using this method, grids are segmented into blocks according to the surface of the element and a structure is provided to ensure appropriate connectivity. To interpret the data <a href="Fluid_dynamics" title="wikilink">flow</a> solver is used. When an unstructured scheme is employed, the main interest is to fulfill the demand of the user and a grid generator is used to accomplish this task. The information storage in structured scheme is <a href="cell_(geometry)" title="wikilink">cell</a> to cell instead of grid to grid and hence the more memory space is needed. Due to random cell location, the solver <a class="uri" href="efficiency" title="wikilink">efficiency</a> in unstructured is less as compared to the structured scheme.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Some points are needed to be kept in mind at the time of grid <a class="uri" href="construction" title="wikilink">construction</a>. The grid point with high resolution creates difficulty for both structured and unstructured. For example, in case of <a href="boundary_layer" title="wikilink">boundary layer</a>, structured scheme produces elongated grid in the direction of flow. On the other hand unstructured grids require a higher cell <a class="uri" href="density" title="wikilink">density</a> in the boundary layer because the cell needs to be as <a class="uri" href="equilateral" title="wikilink">equilateral</a> as possible to avoid errors.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="connectivity-information">Connectivity information</h2>

<p>We must identify what information is required to identify the cell and all the neighbors of the cell in the <a href="computational_grid" title="wikilink">computational</a> mesh. We can choose to locate the <a class="uri" href="arbitrary" title="wikilink">arbitrary</a> points anywhere we want for the unstructured grid. A point insertion scheme is used to insert the points independently and the cell connectivity is determined. This suggests that the point be identified as they are inserted. <a class="uri" href="Logic" title="wikilink">Logic</a> for establishing new connectivity is determined once the points are inserted. Data that form grid point that identifies grid cell are needed. As each cell is formed it is numbered and the points are sorted. In addition the neighbor cell information is needed.</p>
<h2 id="adaptive-grid">Adaptive grid</h2>

<p>A problem in solving <a href="partial_differential_equation" title="wikilink">partial differential equations</a> using previous methods is that the grid is constructed and the points are distributed in the physical domain before details of the solution is known. So the grid may or may not be the best for the given problem.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Adaptive methods are used to improve the <a class="uri" href="accuracy" title="wikilink">accuracy</a> of the solutions. The adaptive method is referred to as ‘h’ method if mesh refinement is used, ‘r’ method if the number of grid point is fixed and not redistributed and ‘p’ if the order of solution scheme is increased in finite-element theory. The multi diemensional problems using the equi-distribution scheme can be accomplished in several ways. The simplest to understand are the Poisson Grid Generators with control function based on the equidistribution of the weight function with the <a class="uri" href="diffusion" title="wikilink">diffusion</a> set as a multiple of desired cell volume. The equidistribution scheme can also be applied to the unstructured problem. The problem is the connectivity hampers if mesh point movement is very large.</p>

<p><a href="Steady_flow" title="wikilink">Steady flow</a> and the time-accurate flow calculation can be solved through this adaptive method. The grid is refined and after a predetermined number of iteration in order to adapt it in a steady flow problem. The grid will stop adjusting to the changes once the solution converges. In time accurate case coupling of the Partial Differential Equations of the physical problem and those describing the grid movement is required.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
