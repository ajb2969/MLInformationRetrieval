<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="18">Ugly duckling theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ugly duckling theorem</h1>
<hr/>

<p>The <strong>Ugly Duckling theorem</strong> is an <a class="uri" href="argument" title="wikilink">argument</a> asserting that classification is impossible without some sort of <a href="bias_(statistics)" title="wikilink">bias</a>. It is named for <a href="Hans_Christian_Andersen" title="wikilink">Hans Christian Andersen</a>'s story "<a href="The_Ugly_Duckling" title="wikilink">The Ugly Duckling</a>." It gets its name because it shows that, all things being equal, an ugly duckling is just as similar to a <a class="uri" href="swan" title="wikilink">swan</a> as two swans are to each other, although it is only a <a class="uri" href="theorem" title="wikilink">theorem</a> in a very informal sense. It was proposed by <a href="Satosi_Watanabe" title="wikilink">Satosi Watanabe</a> in 1969.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="basic-idea">Basic idea</h2>

<p>Watanabe came to realize there is a unquantifiable number of shared properties between all objects, making any classification biased. Murphy and Medin (1985) give an example of two putative classified things, plums and lawnmowers:</p>

<p><mtpl></mtpl></p>

<p>Unless some properties are considered more salient, or ‘weighted’ more important than others, everything will appear equally similar, hence Watanabe (1986) wrote: “any objects, in so far as they are distinguishable, are equally similar".<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> However since there is an unlimited number of properties to choose from, it remains an arbitrary choice what properties to select/deselect. This makes classification biased. Watanabe named this the "Ugly Duckling theorem" because a swan is as similar to a duckling as to another swan (there are no constraints or fixes on what constitutes similarity).</p>
<h2 id="mathematical-formula">Mathematical formula</h2>

<p>Suppose there are <var>n</var> things in the universe, and one wants to put them into classes or categories. One has no preconceived ideas or <a href="bias" title="wikilink">biases</a> about what sorts of categories are "natural" or "normal" and what are not. So one has to consider all the possible classes that could be, all the possible ways of making sets out of the <var>n</var> objects. There are 

<math display="inline" id="Ugly_duckling_theorem:0">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 such ways, the size of the <a href="power_set" title="wikilink">power set</a> of <var>n</var> objects. One can use that to measure the similarity between two objects: and one would see how many sets they have in common. However one can not. Any two objects have exactly the same number of classes in common if we can form any possible class, namely 

<math display="inline" id="Ugly_duckling_theorem:1">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n-1}
  </annotation>
 </semantics>
</math>

 (half the total number of classes there are). To see this is so, one may imagine each class is a represented by an <var>n</var>-bit <a href="bit_array" title="wikilink">string</a> (or <a href="binary_numeral_system" title="wikilink">binary encoded</a> integer), with a zero for each element not in the class and a one for each element in the class. As one finds, there are 

<math display="inline" id="Ugly_duckling_theorem:2">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 such strings.</p>

<p>As all possible choices of zeros and ones are there, any two bit-positions will agree exactly half the time. One may pick two elements and reorder the bits so they are the first two, and imagine the numbers sorted lexicographically. The first 

<math display="inline" id="Ugly_duckling_theorem:3">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}/2
  </annotation>
 </semantics>
</math>

 numbers will have bit #1 set to zero, and the second 

<math display="inline" id="Ugly_duckling_theorem:4">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}/2
  </annotation>
 </semantics>
</math>

 will have it set to one. Within each of those blocks, the top 

<math display="inline" id="Ugly_duckling_theorem:5">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>/</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}/4
  </annotation>
 </semantics>
</math>

 will have bit #2 set to zero and the other 

<math display="inline" id="Ugly_duckling_theorem:6">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>/</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}/4
  </annotation>
 </semantics>
</math>

 will have it as one, so they agree on two blocks of 

<math display="inline" id="Ugly_duckling_theorem:7">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>/</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}/4
  </annotation>
 </semantics>
</math>

 or on half of all the cases. No matter which two elements one picks. So if we have no preconceived bias about which categories are better, everything is then equally similar (or equally dissimilar). The number of <a href="propositional_function" title="wikilink">predicates</a> simultaneously satisfied by two non-identical elements is constant over all such pairs and is the same as the number of those satisfied by one. Thus, some kind of inductive bias is needed to make judgements; i.e. to prefer certain categories over others.</p>
<h3 id="boolean-functions">Boolean functions</h3>

<p>Let 

<math display="inline" id="Ugly_duckling_theorem:8">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},x_{2},\dots,x_{n}
  </annotation>
 </semantics>
</math>

 be a set of vectors of 

<math display="inline" id="Ugly_duckling_theorem:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 booleans each. The ugly duckling is the vector which is least like the others. Given the booleans, this can be computed using <a href="Hamming_distance" title="wikilink">Hamming distance</a>.</p>

<p>However, the choice of boolean features to consider could have been somewhat arbitrary. Perhaps there were features derivable from the original features that were important for identifying the ugly duckling. The set of booleans in the vector can be extended with new features computed as boolean functions of the 

<math display="inline" id="Ugly_duckling_theorem:10">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 original features. The only canonical way to do this is to extend it with <em>all</em> possible Boolean functions. The resulting completed vectors have 

<math display="inline" id="Ugly_duckling_theorem:11">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

 features. The Ugly Duckling Theorem states that there is no ugly duckling because any two completed vectors will either be equal or differ in exactly half of the features.</p>

<p>Proof. Let x and y be two vectors. If they are the same, then their completed vectors must also be the same because any Boolean function of x will agree with the same Boolean function of y. If x and y are different, then there exists a coordinate 

<math display="inline" id="Ugly_duckling_theorem:12">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 where the 

<math display="inline" id="Ugly_duckling_theorem:13">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th coordinate of 

<math display="inline" id="Ugly_duckling_theorem:14">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 differs from the 

<math display="inline" id="Ugly_duckling_theorem:15">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th coordinate of 

<math display="inline" id="Ugly_duckling_theorem:16">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. Now the completed features contain every Boolean function on 

<math display="inline" id="Ugly_duckling_theorem:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 Boolean variables, with each one exactly once. Viewing these Boolean functions as polynomials in 

<math display="inline" id="Ugly_duckling_theorem:18">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 variables over GF(2), segregate the functions into pairs 

<math display="inline" id="Ugly_duckling_theorem:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>f</mi>
   <mo>,</mo>
   <mi>g</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>f</ci>
    <ci>g</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f,g)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Ugly_duckling_theorem:20">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 contains the 

<math display="inline" id="Ugly_duckling_theorem:21">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th coordinate as a linear term and 

<math display="inline" id="Ugly_duckling_theorem:22">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Ugly_duckling_theorem:23">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 without that linear term. Now, for every such pair 

<math display="inline" id="Ugly_duckling_theorem:24">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>f</mi>
   <mo>,</mo>
   <mi>g</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>f</ci>
    <ci>g</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f,g)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ugly_duckling_theorem:25">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ugly_duckling_theorem:26">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 will agree on exactly one of the two functions. If they agree on one, they must disagree on the other and vice versa. (This proof is believed to be due to Watanabe.)</p>
<h2 id="solutions">Solutions</h2>

<p>A solution to the Ugly Ducking Theorem would be to introduce a constraint on how similarity is measured by limiting the properties involved in classification, say between A and B. However Medin et al. (1993) point out that this does not actually resolve the arbitrariness or bias problem since in what respects A is similar to B: “varies with the stimulus context and task, so that there is no unique answer, to the question of how similar is one object to another”.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> For example "a barberpole and a zebra would be more similar than a horse and a zebra if the feature <em>striped</em> had sufficient weight. Of course, if these feature weights were fixed, then these similarity relations would be constrained". Yet the property "striped" as a weight 'fix' or constraint is arbitrary itself, meaning: "unless one can specify such criteria, then the claim that categorization is based on attribute matching is almost entirely vacuous".</p>

<p>Stamos (2003) has attempted to solve the Ugly Ducking Theorem by showing some judgments of overall similarity are non-arbitrary in the sense they are useful:</p>

<p><mtpl></mtpl></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="No_free_lunch_in_search_and_optimization" title="wikilink">No free lunch in search and optimization</a></li>
<li><a href="No_free_lunch_theorem" title="wikilink">No free lunch theorem</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>

<p>"</p>

<p><a class="uri" href="Category:Theorems" title="wikilink">Category:Theorems</a> <a class="uri" href="Category:Arguments" title="wikilink">Category:Arguments</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a> <a class="uri" href="Category:Ontology" title="wikilink">Category:Ontology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Watanabe, S. (1986). “Epistemological Relativity”. <em>Annals of the Japan Association for Philosophy of Science</em>. 7(1): 1-14.<a href="#fnref2">↩</a></li>
<li id="fn3">Medin, D. L., Goldstone, R. L., Gentner, D. (1993). “Respects for similarity”. <em>Psychological Review</em>. 100(2): 254-278.<a href="#fnref3">↩</a></li>
<li id="fn4">The philosopher <a href="Nelson_Goodman" title="wikilink">Nelson Goodman</a> (1972) came to the same conclusion: "But importance is a highly volatile matter, varying with every shift of context and interest, and quite incapable of supporting the fixed distinctions that philosophers so often seek to rest upon it".<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
