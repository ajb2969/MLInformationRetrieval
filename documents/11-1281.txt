   Kernelization      Kernelization   In computer science , a kernelization is a technique for designing efficient algorithms that achieve their efficiency by a preprocessing stage in which inputs to the algorithm are replaced by a smaller input, called a "kernel". The result of solving the problem on the kernel should either be the same as on the original input, or it should be easy to transform the output on the kernel to the desired output for the original problem.  Kernelization is often achieved by applying a set of reduction rules that cut away parts of the instance that are easy to handle. In parameterized complexity theory , it is often possible to prove that a kernel with guaranteed bounds on the size of a kernel (as a function of some parameter associated to the problem) can be found in polynomial time . When this is possible, it results in a fixed-parameter tractable algorithm whose running time is the sum of the (polynomial time) kernelization step and the (non-polynomial but bounded by the parameter) time to solve the kernel. Indeed, every problem that can be solved by a fixed-parameter tractable algorithm can be solved by a kernelization algorithm of this type.  Example: vertex cover  A standard example for a kernelization algorithm is the kernelization of the vertex cover problem by S. Buss. 1 In this problem, the input is an undirected graph    G   G   G   together with a number   k   k   k   . The output is a set of at most   k   k   k   vertices that includes the endpoint of every edge in the graph, if such a set exists, or a failure exception if no such set exists. This problem is NP-hard . However, the following reduction rules may be used to kernelize it:   If    k  >  0      k  0    k>0   and   v   v   v   is a vertex of degree greater than   k   k   k   , remove   v   v   v   from the graph and decrease   k   k   k   by one. Every vertex cover of size   k   k   k   must contain   v   v   v   since otherwise too many of its neighbors would have to be picked to cover the incident edges. Thus, an optimal vertex cover for the original graph may be formed from a cover of the reduced problem by adding   v   v   v   back to the cover.  If   v   v   v   is an isolated vertex, remove it. An isolated vertex cannot cover any edges, so in this case   v   v   v   cannot be part of any minimal cover.  If more than    k  2     superscript  k  2    k^{2}   edges remain in the graph, and neither of the previous two rules can be applied, then the graph cannot contain a vertex cover of size   k   k   k   . For, after eliminating all vertices of degree greater than   k   k   k   , each remaining vertex can only cover at most   k   k   k   edges and a set of   k   k   k   vertices could only cover at most    k  2     superscript  k  2    k^{2}   edges. In this case, the instance may be replaced by an instance with two vertices, one edge, and    k  =  0      k  0    k=0   , which also has no solution.   An algorithm that applies these rules repeatedly until no more reductions can be made necessarily terminates with a kernel that has at most    k  2     superscript  k  2    k^{2}   edges and (because each edge has at most two endpoints and there are no isolated vertices) at most    2   k  2       2   superscript  k  2     2k^{2}   vertices. This kernelization may be implemented in linear time . Once the kernel has been constructed, the vertex cover problem may be solved by a brute force search algorithm that tests whether each subset of the kernel is a cover of the kernel. Thus, the vertex cover problem can be solved in time    O   (    2   2   k  2     +  n  +  m   )       O     superscript  2    2   superscript  k  2     n  m     O(2^{2k^{2}}+n+m)   for a graph with   n   n   n   vertices and   m   m   m   edges, allowing it to be solved efficiently when   k   k   k   is small even if   n   n   n   and   m   m   m   are both large.  Although this bound is fixed-parameter tractable, its dependence on the parameter is higher than might be desired. More complex kernelization procedures can improve this bound, by finding smaller kernels, at the expense of greater running time in the kernelization step. In the vertex cover example, kernelization algorithms are known that produce kernels with at most    2  k      2  k    2k   vertices. One algorithm that achieves this improved bound exploits the half-integrality of the linear program relaxation of vertex cover due to Nemhauser and Trotter. 2 Another kernelization algorithm achieving that bound is based on what is known as the crown reduction rule and uses alternating path arguments. 3 The currently best known kernelization algorithm in terms of the number of vertices is due to  and achieves     2  k   -   c   log  k          2  k     c    k      2k-c\log k   vertices for any fixed constant   c   c   c   .  It is not possible, in this problem, to find a kernel of size    O   (   log  k   )       O    k     O(\log k)   , unless P = NP, for such a kernel would lead to a polynomial-time algorithm for the NP-hard vertex cover problem. However, much stronger bounds on the kernel size can be proven in this case: unless coNP    ‚äÜ     \subseteq    NP/poly (believed unlikely by complexity theorists ), for every    œµ  >  0      œµ  0    \epsilon>0   it is impossible in polynomial time to find kernels with    O   (   k   2  -  œµ    )       O   superscript  k    2  œµ      O(k^{2-\epsilon})   edges. 4 It is unknown for vertex cover whether kernels with     (   2  -  œµ   )   k        2  œµ   k    (2-\epsilon)k   vertices for some    œµ  >  0      œµ  0    \epsilon>0   would have any unlikely complexity-theoretic consequences.  Definition  In the literature, there is no clear consensus on how kernelization should be formally defined and there are subtle differences in the uses of that expression.  Downey-Fellows Notation  In the Notation of , a parameterized problem is a subset    L  ‚äÜ    Œ£  *   √ó  ùí©       L     superscript  normal-Œ£    ùí©     L\subseteq\Sigma^{*}\times\mathcal{N}   describing a decision problem .  A kernelization for a parameterized problem   L   L   L   is an algorithm that takes an instance    (  x  ,  k  )     x  k    (x,k)   and maps it in time polynomial in    |  x  |      x    |x|   and   k   k   k   to an instance    (   x  ‚Ä≤   ,   k  ‚Ä≤   )      superscript  x  normal-‚Ä≤    superscript  k  normal-‚Ä≤     (x^{\prime},k^{\prime})   such that       (  x  ,  k  )     x  k    (x,k)   is in   L   L   L   if and only if    (   x  ‚Ä≤   ,   k  ‚Ä≤   )      superscript  x  normal-‚Ä≤    superscript  k  normal-‚Ä≤     (x^{\prime},k^{\prime})   is in   L   L   L   ,  the size of    x  ‚Ä≤     superscript  x  normal-‚Ä≤    x^{\prime}   is bounded by a computable function   f   f   f   in   k   k   k   , and      k  ‚Ä≤     superscript  k  normal-‚Ä≤    k^{\prime}   is bounded by a function in   k   k   k   .   The output    (   x  ‚Ä≤   ,   k  ‚Ä≤   )      superscript  x  normal-‚Ä≤    superscript  k  normal-‚Ä≤     (x^{\prime},k^{\prime})   of kernelization is called a kernel. In this general context, the size of the string    x  ‚Ä≤     superscript  x  normal-‚Ä≤    x^{\prime}   just refers to its length. Some authors prefer to use the number of vertices or the number of edges as the size measure in the context of graph problems.  Flum-Grohe Notation  In the Notation of , a parameterized problem consists of a decision problem    L  ‚äÜ   Œ£  *       L   superscript  normal-Œ£      L\subseteq\Sigma^{*}   and a function    Œ∫  :    Œ£  *   ‚Üí  ùí©      normal-:  Œ∫   normal-‚Üí   superscript  normal-Œ£    ùí©     \kappa:\Sigma^{*}\to\mathcal{N}   , the parameterization. The parameter of an instance   x   x   x   is the number    Œ∫   (  x  )       Œ∫  x    \kappa(x)   .  A kernelization for a parameterized problem   L   L   L   is an algorithm that takes an instance   x   x   x   with parameter   k   k   k   and maps it in polynomial time to an instance   y   y   y   such that      x   x   x   is in   L   L   L   if and only if   y   y   y   is in   L   L   L   and  the size of   y   y   y   is bounded by a computable function   f   f   f   in   k   k   k   .   Note that in this notation, the bound on the size of   y   y   y   implies that the parameter of   y   y   y   is also bounded by a function in   k   k   k   .  The function   f   f   f   is often referred to as the size of the kernel. If    f  =   k   O   (  1  )         f   superscript  k    O  1      f=k^{O(1)}   , it is said that   L   L   L   admits a polynomial kernel. Similarly, for    f  =   O   (  k  )        f    O  k     f={O(k)}   , the problem admits linear kernel.  Kernelizability and fixed-parameter tractability are equivalent  A problem is fixed-parameter tractable if and only if it is kernelizable and decidable .  That a kernelizable and decidable problem is fixed-parameter tractable can be seen from the definition above: First the kernelization algorithm, which runs in time    O   (    |  x  |   c   )       O   superscript    x   c     O(|x|^{c})   for some c, is invoked to generate a kernel of size    f   (  k  )       f  k    f(k)   . The kernel is then solved by the algorithm that proves that the problem is decidable. The total running time of this procedure is     g   (   f   (  k  )    )    +   O   (    |  x  |   c   )          g    f  k      O   superscript    x   c      g(f(k))+O(|x|^{c})   , where    g   (  n  )       g  n    g(n)   is the running time for the algorithm used to solve the kernels. Since    g   (   f   (  k  )    )       g    f  k     g(f(k))   is computable, e.g. by using the assumption that    f   (  k  )       f  k    f(k)   is computable and testing all possible inputs of length    f   (  k  )       f  k    f(k)   , this implies that the problem is fixed-parameter tractable.  The other direction, that a fixed-parameter tractable problem is kernelizable and decidable is a bit more involved. Assume that the question is non-trivial, meaning that there is at least one instance that is in the language, called    I   y  e  s      subscript  I    y  e  s     I_{yes}   , and at least one instance that is not in the language, called    I   n  o      subscript  I    n  o     I_{no}   ; otherwise, replacing any instance by the empty string is a valid kernelization. Assume also that the problem is fixed-parameter tractable, ie., it has an algorithm that runs in at most     f   (  k  )    ‚ãÖ    |  x  |   c      normal-‚ãÖ    f  k    superscript    x   c     f(k)\cdot|x|^{c}   steps on instances    (  x  ,  k  )     x  k    (x,k)   , for some constant   c   c   c   and some function    f   (  k  )       f  k    f(k)   . To kernelize an input, run this algorithm on the given input for at most     |  x  |    c  +  1      superscript    x     c  1     |x|^{c+1}   steps. If it terminates with an answer, use that answer to select either    I   y  e  s      subscript  I    y  e  s     I_{yes}   or    I   n  o      subscript  I    n  o     I_{no}   as the kernel. If, instead, it exceeds the     |  x  |    c  +  1      superscript    x     c  1     |x|^{c+1}   bound on the number of steps without terminating, then return    (  x  ,  k  )     x  k    (x,k)   itself as the kernel. Because    (  x  ,  k  )     x  k    (x,k)   is only returned as a kernel for inputs with      f   (  k  )    ‚ãÖ    |  x  |   c    >    |  x  |    c  +  1         normal-‚ãÖ    f  k    superscript    x   c     superscript    x     c  1      f(k)\cdot|x|^{c}>|x|^{c+1}   , it follows that the size of the kernel produced in this way is at most    max   {   |   I   y  e  s    |   ,   |   I   n  o    |   ,   f   (  k  )    }          subscript  I    y  e  s        subscript  I    n  o       f  k     \max\{|I_{yes}|,|I_{no}|,f(k)\}   . This size bound is computable, by the assumption from fixed-parameter tractability that    f   (  k  )       f  k    f(k)   is computable.  More Examples   Vertex Cover: The vertex cover problem has kernels with at most    2  k      2  k    2k   vertices and    O   (   k  2   )       O   superscript  k  2     O(k^{2})   edges. 5 Furthermore, for any    Œµ  >  0      Œµ  0    \varepsilon>0   , vertex cover does not have kernels with    O   (   k   2  -  Œµ    )       O   superscript  k    2  Œµ      O(k^{2-\varepsilon})   edges unless    coNP  ‚äÜ  NP/poly      coNP  NP/poly    \text{coNP}\subseteq\text{NP/poly}   . 6 The vertex cover problems in   d   d   d   -uniform hypergraphs has kernels with    O   (   k  d   )       O   superscript  k  d     O(k^{d})   edges using the sunflower lemma , and it does not have kernels of size    O   (   k   d  -  Œµ    )       O   superscript  k    d  Œµ      O(k^{d-\varepsilon})   unless    coNP  ‚äÜ  NP/poly      coNP  NP/poly    \text{coNP}\subseteq\text{NP/poly}   . 7  Feedback Vertex Set: The feedback vertex set problem has kernels with    4   k  2       4   superscript  k  2     4k^{2}   vertices and    O   (   k  2   )       O   superscript  k  2     O(k^{2})   edges. 8 Furthermore, it does not have kernels with    O   (   k   2  -  Œµ    )       O   superscript  k    2  Œµ      O(k^{2-\varepsilon})   edges unless    coNP  ‚äÜ  NP/poly      coNP  NP/poly    \text{coNP}\subseteq\text{NP/poly}   . 9  k-Path: The k-path problem is to decide whether a given graph has a path of length at least   k   k   k   . This problem has kernels of size exponential in   k   k   k   , and it does not have kernels of size polynomial in   k   k   k   unless    coNP  ‚äÜ  NP/poly      coNP  NP/poly    \text{coNP}\subseteq\text{NP/poly}   . 10  Bidimensional problems: Many parameterized versions of bidimensional problems have linear kernels on planar graphs, and more generally, on graphs excluding some fixed graph as a minor . 11   Notes  References    .   .   .   .   .   .   .   .   .   .   .   "  Category:Parameterized complexity  Category:Analysis of algorithms     This unpublished observation is acknowledged in a paper of ‚Ü©  ‚Ü©  give a kernel based on the crown reduction that has    3  k      3  k    3k   vertices. The    2  k      2  k    2k   vertex bound is a bit more involved and folklore. ‚Ü©  ‚Ü©  ‚Ü©    ‚Ü©   ‚Ü©  ‚Ü©     