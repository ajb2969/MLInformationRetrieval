<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1558">PEPA</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>PEPA</h1>
<hr/>
<dl>
<dd><em>For the drug see <a href="PEPA_(drug)" title="wikilink">PEPA (drug)</a></em>
</dd>
</dl>

<p><strong>Performance Evaluation Process Algebra</strong> (<strong>PEPA</strong>) is a <a class="uri" href="stochastic" title="wikilink">stochastic</a> <a href="process_algebra" title="wikilink">process algebra</a> designed for modelling computer and communication systems introduced by <a href="Jane_Hillston" title="wikilink">Jane Hillston</a> in the 1990s.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The language extends classical process algebras such as <a href="Robin_Milner" title="wikilink">Milner</a>'s <a href="Calculus_of_Communicating_Systems" title="wikilink">CCS</a> and <a href="C.A.R._Hoare" title="wikilink">Hoare</a>'s <a href="Communicating_Sequential_Processes" title="wikilink">CSP</a> by introducing probabilistic branching and timing of transitions.</p>

<p>Rates are drawn from the <a href="exponential_distribution" title="wikilink">exponential distribution</a> and PEPA models are finite-state and so give rise to a <a href="stochastic_process" title="wikilink">stochastic process</a>, specifically a <a href="continuous-time_Markov_process" title="wikilink">continuous-time Markov process</a> (CTMC). Thus the language can be used to study quantitative properties of models of computer and communication systems such as <a class="uri" href="throughput" title="wikilink">throughput</a>, <a class="uri" href="utilisation" title="wikilink">utilisation</a> and <a href="Response_time_(technology)" title="wikilink">response time</a> as well as qualitative properties such as freedom from <a class="uri" href="deadlock" title="wikilink">deadlock</a>. The language is formally defined using a structured <a href="operational_semantics" title="wikilink">operational semantics</a> in the style invented by <a href="Gordon_Plotkin" title="wikilink">Gordon Plotkin</a>.</p>

<p>As with most process algebras, PEPA is a parsimonious language. It has only four combinators, <em>prefix</em>, <em>choice</em>, <em>co-operation</em> and <em>hiding</em>. Prefix is the basic building block of a sequential component: the process (<em>a</em>, <em>r</em>).<em>P</em> performs activity <em>a</em> at rate <em>r</em> before evolving to behave as component <em>P</em>. Choice sets up a competition between two possible alternatives: in the process (<em>a</em>, <em>r</em>).<em>P</em> + (<em>b</em>, <em>s</em>).<em>Q</em> either <em>a</em> wins the race (and the process subsequently behaves as <em>P</em>) or <em>b</em> wins the race (and the process subsequently behaves as <em>Q</em>).</p>

<p>The co-operation operator requires the two "co-operands" to join for those activities which are specified in the co-operation set: in the process <em>P</em> <em>Q</em> the processes <em>P</em> and <em>Q</em> must co-operate on activities <em>a</em> and <em>b</em>, but any other activities may be performed independently. The <a href="reversed_compound_agent_theorem" title="wikilink">reversed compound agent theorem</a> gives a set of sufficient conditions for a co-operation to have a <a href="product_form_stationary_distribution" title="wikilink">product form stationary distribution</a>.</p>

<p>Finally, the process <em>P</em>/{<em>a</em>} hides the activity <em>a</em> from view (and prevents other processes from joining with it).</p>
<h2 id="syntax">Syntax</h2>

<p>Given a set of action names, the set of CCS processes is defined by the following <a href="BNF_grammar" title="wikilink">BNF grammar</a>:</p>

<p>

<math display="block" id="PEPA:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mpadded width="+5.1pt">
    <mi>P</mi>
   </mpadded>
   <mo rspace="7.6pt" stretchy="false">|</mo>
   <mi>P</mi>
   <mo>+</mo>
   <mpadded width="+5.1pt">
    <mi>Q</mi>
   </mpadded>
   <mo rspace="7.6pt" stretchy="false">|</mo>
   <mi>P</mi>
   <mover>
    <mi>L</mi>
    <mrow>
     <mo rspace="0pt">▷</mo>
     <mo>◁</mo>
    </mrow>
   </mover>
   <mpadded width="+5.1pt">
    <mi>Q</mi>
   </mpadded>
   <mo rspace="7.6pt" stretchy="false">|</mo>
   <mi>P</mi>
   <mo>/</mo>
   <mpadded width="+5.1pt">
    <mi>L</mi>
   </mpadded>
   <mo rspace="7.6pt" stretchy="false">|</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">λ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
    <plus></plus>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <list>
      <ci>normal-▷</ci>
      <ci>normal-◁</ci>
     </list>
    </apply>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
    <divide></divide>
    <csymbol cd="unknown">L</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P::=(a,\lambda).P\,\,\,|\,\,\,P+Q\,\,\,|\,\,\,P\stackrel{\triangleright\!\!%
\triangleleft}{\scriptstyle{L}}Q\,\,\,|\,\,\,P/L\,\,\,|\,\,\,A
  </annotation>
 </semantics>
</math>

</p>

<p>The parts of the syntax are, in the order given above</p>
<dl>
<dt>action : the process 

<math display="inline" id="PEPA:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <interval closure="open">
     <ci>a</ci>
     <ci>λ</ci>
    </interval>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,\lambda).P
  </annotation>
 </semantics>
</math>

 can perform an action <em>a</em> at rate 

<math display="inline" id="PEPA:2">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 and continue as the process <em>P</em>.<br/>
choice : the process <em>P+Q</em> may behave as either the process <em>P</em> or the process <em>Q</em>.<br/>
cooperation : processes <em>P</em> and <em>Q</em> exist simultaneously and behave indepdendently for actions whose names do not appear in <em>L</em>. For actions whose names appear in <em>L</em>, the action must be carried out jointly and a race condition determines the time this takes.<br/>
hiding : the process <em>P</em> behaves as usual for action names not in <em>L</em>, and performs a silent action 

<math display="inline" id="PEPA:3">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 for action names that appear in <em>L</em>.<br/>
process identifier : write 

<math display="inline" id="PEPA:4">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mover accent="true">
    <mo>=</mo>
    <munder accentunder="true">
     <mi></mi>
     <mo>def</mo>
    </munder>
   </mover>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <apply>
      <ci>def</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <eq></eq>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\overset{\underset{\mathrm{def}}{}}{=}P
  </annotation>
 </semantics>
</math>

 to use the identifier <em>A</em> to refer to the process <em>P</em>.</dt>
</dl>
<h2 id="tools">Tools</h2>
<ul>
<li><a href="http://www.dcs.ed.ac.uk/pepa/tools/plugin/index.html">PEPA Plug-in</a> for <a href="Eclipse_(software)" title="wikilink">Eclipse</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li><a href="http://www.doc.ic.ac.uk/ipc/">ipc: the imperial PEPA compiler</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li><a href="http://code.google.com/p/gpanalyser/">GPAnalyser</a> for fluid analysis of massively parallel systems<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.dcs.ed.ac.uk/pepa">PEPA: Performance Evaluation Process Algebra</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Process_calculi" title="wikilink">Category:Process calculi</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
