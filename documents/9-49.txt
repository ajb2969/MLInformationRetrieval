   Gödel numbering for sequences      Gödel numbering for sequences   In mathematics , a Gödel numbering for sequences provides us an effective way to represent each finite sequence of natural numbers as a single natural number. Of course, the embedding is surely possible set theoretically, but the emphasis is on the effectiveness of the functions manipulating such representations of sequences: the operations on sequences (accessing individual members, concatenation) can be "implemented" using total recursive functions , and in fact by primitive recursive functions .  It is usually used to build sequential “ data types ” in the realm of arithmetic-based formalizations of some fundamental notions of mathematics. It is a specific case of the more general idea of Gödel numbering .  E.g. recursive function theory can be regarded as a formalization of notion “ algorithm ”, and if we regard it as a programming language , we can mimic arrays, lists by encoding a sequence of natural numbers in a single natural number — to achieve this, we can use various number theoretic ideas. Using the fundamental theorem of arithmetic is a straightforward way, but there are also more economic approaches, e.g. using pairing function combined with Chinese remainder theorem in a sophisticated way. 1 2  Gödel numbering  Besides using Gödel numbering to encode unique sequences of symbols into unique natural numbers (i.e. place numbers into mutually exclusive or one-to-one correspondence with the sequences), we can use it to encode whole “architectures” of sophisticated “machines”. For example we can encode Markov algorithms , 3 or Turing machines 4 into natural numbers and thereby prove that the expressing power of recursive function theory is no less than that of the former machine-like formalizations of algorithms.  Accessing members  Any such representation of sequences should contain all the information as in the original sequence: most importantly, to access each individual member. However, the length does not have to match directly: even if we want to handle sequences of different length, we can store length data as a surplus member, 5 or as the other member of an ordered pair by using a pairing function .  Anyway, we expect that there is an effective way for this information retrieval process in form of an appropriate total recursive function.  We want to find a totally recursive function f that satisfies: For all n and for any n -length sequence of natural numbers    ⟨   a  0   ,   …   a   n  -  1     ⟩      subscript  a  0     normal-…   subscript  a    n  1       \langle a_{0},\dots a_{n-1}\rangle   , there exists an appropriate natural number a , called the Gödel number of the sequence such that for all i in the range of 0, …, n - 1,       f   (  a  ,  i  )    =   a  i         f   a  i     subscript  a  i     f(a,i)=a_{i}   .  There are effective functions which can retrieve each member of the original sequence from a Gödel number of the sequence. Moreover, we can define some of them in a constructive way, so we can go well beyond mere proofs of existence .  Gödel's β-function lemma  By an ingenious use of Chinese remainder theorem , we can define constructively such a recursive function   β   β   \beta   (using simple number-theoretical functions, all of which can be defined in a total recursive way) fulfilling the " specifications " given above. Also Gödel defined the   β   β   \beta   function using the Chinese remainder theorem in his article written in 1931. This is a primitive recursive function . 6  Thus, for all n and for any n -length sequence of natural numbers    ⟨   a  0   ,   …   a   n  -  1     ⟩      subscript  a  0     normal-…   subscript  a    n  1       \langle a_{0},\dots a_{n-1}\rangle   , there exists an appropriate natural number a , called the Gödel number of the sequence such that 7       β   (  a  ,  i  )    =   a  i         β   a  i     subscript  a  i     \beta(a,i)=a_{i}     Using a pairing function  Our specific solution will depend on a pairing function — there are several ways to implement the latter, let us select one. Now, we can abstract from the details of the “ implementation ” of the pairing function, we need only to know its “ interface ”: let   π   π   \pi   , K , L denote the pairing function and its two projection functions, respectively, satisying specification       K   (   π   (  x  ,  y  )    )    =  x        K    π   x  y     x    K\left(\pi\left(x,y\right)\right)=x          L   (   π   (  x  ,  y  )    )    =  y        L    π   x  y     y    L\left(\pi\left(x,y\right)\right)=y   we shall not discuss and formalize the axiom for excluding alien objects here, it is now not so important.  Remainder for natural numbers  We shall use another auxiliary function: it will compute the remainder for natural numbers . Examples:        rem   (  5  ,  3  )    =  2        rem   5  3    2    \mathrm{rem}(5,3)=2          rem   (  7  ,  2  )    =  1        rem   7  2    1    \mathrm{rem}(7,2)=1      It can be proven that this function can be "implemented" as a recursive function.  Using the Chinese remainder theorem  Implementation of the β function  Using the Chinese remainder theorem , we can prove that implementing   β   β   \beta   as       β   (  s  ,  i  )    =   rem   (   K   (  s  )    ,      (   i  +  1   )   ⋅  L    (  s  )    +  1   )          β   s  i      rem     K  s        normal-⋅    i  1   L   s   1       \beta(s,i)=\mathrm{rem}\left(K\left(s\right),\left(i+1\right)\cdot L\left(s%
 \right)+1\right)   will work, according to the specification we expect   β   β   \beta   to satisfy. We can use a more concise form by an abuse of notation (sort of pattern matching ):       β   (   π   (   x  0   ,  m  )    ,  i  )    =   rem   (   x  0   ,     (   i  +  1   )   ⋅  m   +  1   )          β     π    subscript  x  0   m    i      rem    subscript  x  0      normal-⋅    i  1   m   1       \beta\left(\pi\left(x_{0},m\right),i\right)=\mathrm{rem}\left(x_{0},\left(i+1%
 \right)\cdot m+1\right)   Let us achieve even more readability by more modularity and reuse (as these notions are used in computer science 8 ): defining     β   (   π   (   x  0   ,  m  )    ,  i  )    =   rem   (   x  0   ,   m  i   )          β     π    subscript  x  0   m    i      rem    subscript  x  0    subscript  m  i       \beta\left(\pi\left(x_{0},m\right),i\right)=\mathrm{rem}\left(x_{0},m_{i}\right)   , enables us to write      m  i     subscript  m  i    m_{i}   We shall use this   β   β   \beta   notation also in the proof.  Hand-tuned assumptions  For proving the correctness of the above definition of     a  0   ,   …   a   n  -  1         subscript  a  0     normal-…   subscript  a    n  1       a_{0},\dots a_{n-1}   function, we shall use (and prove) several auxiliary theorems, lemmas. These have their own assumptions. Now we try to find out these assumptions, calibrating and tuning their strength carefully: they should not be said in an either superfluously sharp, or unsatisfactorily weak form.  Let    ∀  i  ∈   n  ¯   ∖   {  0  }    (  i  ∣  m  )      fragments  for-all  i    normal-¯  n     fragments  normal-{  0  normal-}    fragments  normal-(  i  normal-∣  m  normal-)     \forall i\in\overline{n}\setminus\left\{0\right\}\left(i\mid m\right)   be a sequence of natural numbers. Let m be chosen to satisfy      ∀  i  <  n   (   a  i   <   m  i   )      fragments  for-all  i   n   fragments  normal-(   subscript  a  i     subscript  m  i   normal-)     \forall i         1   ∣    m  ∧  …  ∧  n   -  1   ∣   m      1   delimited-∣∣      m  normal-…  n   1    m    1\mid m\land\dots\land n-1\mid m   The first assumption is meant as     β   β   \beta   It is needed to meet an assumption of the Chinese remainder theorem (that of being pairwise coprime ). In the literature, sometimes this requirement is replaced with a stronger one, e.g. constructively built with the factorial function, 9 but the proof uses just as much strength as formulated here. 10  The second assumption does not concern the Chinese remainder theorem in any way. It will have importance in proving that the specification for    x  ~     normal-~  x    \tilde{x}   is met eventually. It ensures that an    x  ≡    a  i      (   mod   m  i    )        x   annotated   subscript  a  i    pmod   subscript  m  i       x\equiv a_{i}\;\;(\mathop{{\rm mod}}m_{i})   solution of the simultaneous congruence system       a  i   =   rem   (   x  ~   ,   m  i   )         subscript  a  i     rem    normal-~  x    subscript  m  i       a_{i}=\mathrm{rem}(\tilde{x},m_{i})   for each i ranging 0,… , n-1 also satisfies      ∀  i  <   n    (   a  i   <  m  )      fragments  for-all  i   n   fragments  normal-(   subscript  a  i    m  normal-)     \forall i    11 12 A stronger assumption for m requiring    m  i     subscript  m  i    m_{i}   automatically satisfies it (if we define the notation    ∀  i  ∈   n  ¯   ∖   {  0  }    (  i  ∣  m  )      fragments  for-all  i    normal-¯  n     fragments  normal-{  0  normal-}    fragments  normal-(  i  normal-∣  m  normal-)     \forall i\in\overline{n}\setminus\left\{0\right\}\left(i\mid m\right)   as above).  Proof that (coprimality) assumption for Chinese remainder theorem is met  We shall prove that the (coprimality) assumption for Chinese remainder theorem is met.  As mentioned in section Hand-tuned assumptions , we prescribed that      p  ∣   m  i   -   m  j      fragments  p  normal-∣   subscript  m  i     subscript  m  j     p\mid m_{i}-m_{j}   thus we can use it.  What we want to prove is that we can produce a sequence of pairwise coprime numbers in a way that will turn out to correspond to the Implementation of the β function in a sense.  In details:      m  k     subscript  m  k    m_{k}   .  Let us use reductio ad absurdum !  Negation of the original statement:        m  i   -   m  j    =    (   i  -  j   )   ⋅  m          subscript  m  i    subscript  m  j     normal-⋅    i  j   m     m_{i}-m_{j}=(i-j)\cdot m   allows us to say also      p  ∣   (  i  -  j  )   ⋅  m     fragments  p  normal-∣   fragments  normal-(  i   j  normal-)   normal-⋅  m    p\mid(i-j)\cdot m     Substituting the definens of    p   ∣    i  -  j   ∨  p   ∣   m      p   delimited-∣∣      i  j   p    m    p\mid i-j\lor p\mid m   -sequence notation, we get    ∀  i  ∈   n  ¯   ∖   {  0  }    (  i  ∣  m  )      fragments  for-all  i    normal-¯  n     fragments  normal-{  0  normal-}    fragments  normal-(  i  normal-∣  m  normal-)     \forall i\in\overline{n}\setminus\left\{0\right\}\left(i\mid m\right)   , thus (as equality axioms postulate identity to be a congruence relation  13 ) we get      i  -  j  ∣  m     fragments  i   j  normal-∣  m    i-j\mid m   Using that p is a prime element (note: not the irreducible element property is used!), we get       (  A  ∧   (  A  →  B  )   )   →  B     fragments   fragments  normal-(  A    fragments  normal-(  A  normal-→  B  normal-)   normal-)   normal-→  B    \left(A\land\left(A\rightarrow B\right)\right)\rightarrow B     Resorting to the first hand-tuned assumption  Now this is the point in the proof where we must resort to our assumption      i  -  j  ∣  m     fragments  i   j  normal-∣  m    i-j\mid m   let us remember, we have planned this assumption calibrated carefully to be as weak as possible, but strong enough to enable us to use it now.  The assumed negation of the original statement (let us remember, we use reductio ad absurdum) contains an appropriate existential statement using indices    p  ∣  i  -  j  →  p  ∣  m     fragments  p  normal-∣  i   j  normal-→  p  normal-∣  m    p\mid i-j\rightarrow p\mid m   , thus the mentioned assumption can be applied, so    p  ∣  m     fragments  p  normal-∣  m    p\mid m   holds.  Using an (object) theorem of the propositional calculus as a lemma  We can prove by several means 14 known in propositional calculus , that      p  ∣   m  i      fragments  p  normal-∣   subscript  m  i     p\mid m_{i}   holds.  Because    p  ∣  m     fragments  p  normal-∣  m    p\mid m   entails (by the transitivity property of the divisibility relation) that    p  ∣   m  i   -   (  i  +  1  )   ⋅  m     fragments  p  normal-∣   subscript  m  i     fragments  normal-(  i   1  normal-)   normal-⋅  m    p\mid m_{i}-\left(i+1\right)\cdot m   , thus (as equality axioms postulate identity to be a congruence relation 15 )      m  i     subscript  m  i    m_{i}   can be proven.  Reaching the contradiction  The negation of original statement contained        m  i   -    (   i  +  1   )   ⋅  m    =  1         subscript  m  i    normal-⋅    i  1   m    1    m_{i}-\left(i+1\right)\cdot m=1   and we have just proved      p  ∣  1     fragments  p  normal-∣  1    p\mid 1   thus also       ∃  p   ∈  Prime        p   Prime    \exists p\in\mathrm{Prime}   should hold. But, after substituting the definiens for   ⋮   normal-⋮   \vdots   , we shall see      x  ≡    a   n  -  1       (   mod   m   n  -  1     )        x   annotated   subscript  a    n  1     pmod   subscript  m    n  1        x\equiv a_{n-1}\;\;(\mathop{{\rm mod}}m_{n-1})   Thus, summarizing the above three statements, by transitivity of the equality , also      ∀  i  <   n    (  x  ≡   a  i    (   mod   m  i    )   )      fragments  for-all  i   n   fragments  normal-(  x    subscript  a  i    pmod   subscript  m  i    normal-)     \forall i   should hold. But let us look up the quantification of p in the negation of the original statement: p is existentially quantified and restricted to primes     ∀  i   <    n    (  …  )         for-all  i     n  normal-…     \forall i     The above statement together with the above quantification of p establish the contradiction we wanted to reach.  End of reductio ad absurdum  By reaching contradiction with its negation, we have just proven the original statement:       ∀  i   <    n    (  …  )         for-all  i     n  normal-…     \forall i           ∀  i  <  n  (     fragments  for-all  i   n  normal-(    \forall i           x  0     subscript  x  0    x_{0}      We can write it in a more concise way:       m  0   ,   …   m   n  -  1         subscript  m  0     normal-…   subscript  m    n  1       m_{0},\dots m_{n-1}     In the followings, many statements will be said, all beginning with    x  0     subscript  x  0    x_{0}   . To achieve a more ergonomic treatment, from now on all statements will be regarded in the scope of an     x  0   ≡    a  i      (   mod   m  i    )         subscript  x  0    annotated   subscript  a  i    pmod   subscript  m  i       x_{0}\equiv a_{i}\;\;(\mathop{{\rm mod}}m_{i})   quantification. Thus     rem   (   x  0   ,   m  i   )    =   rem   (   a  i   ,   m  i   )          rem    subscript  x  0    subscript  m  i       rem    subscript  a  i    subscript  m  i       \mathrm{rem}\left(x_{0},m_{i}\right)=\mathrm{rem}\left(a_{i},m_{i}\right)   begins!  Let us chose a solution    ∀  i  <   n    (   a  i   <   m  i   )      fragments  for-all  i   n   fragments  normal-(   subscript  a  i     subscript  m  i   normal-)     \forall i   for the system of simultaneous congruences. At least one solution must exist, because     a  i   <   m  i        subscript  a  i    subscript  m  i     a_{i}   are pairwise comprime (that's what we have been proving so long in the previous sections!), thus we can refer to the Chinese remainder theorem's ensuring solution. Thus, from now on, we can regard     rem   (   a  i   ,   m  i   )    =   a  i         rem    subscript  a  i    subscript  m  i      subscript  a  i     \mathrm{rem}\left(a_{i},m_{i}\right)=a_{i}   satisfying       rem   (   x  0   ,   m  i   )    =   a  i         rem    subscript  x  0    subscript  m  i      subscript  a  i     \mathrm{rem}\left(x_{0},m_{i}\right)=a_{i}   it means (by definition of modular arithmetic ) that       β   (   π   (   x  0   ,  m  )    ,  i  )    =   rem   (   x  0   ,   m  i   )          β     π    subscript  x  0   m    i      rem    subscript  x  0    subscript  m  i       \beta\left(\pi\left(x_{0},m\right),i\right)=\mathrm{rem}\left(x_{0},m_{i}\right)     Resorting to the second hand-tuned assumption  Again, we must resort to the assumptions whose strength we specifically “tuned” for using in the proof. But now, it is the second assumption (which does not concern the Chinese remainder theorem in any way) that we need: “   β   β   \beta   ”. Let us remember: we are now in the scope of a “big” quantification for i , thus we don't repeat its quantification for each statement.  The second hand-tuned assumption     β   (   π   (   x  0   ,  m  )    ,  i  )    =   a  i         β     π    subscript  x  0   m    i     subscript  a  i     \beta\left(\pi\left(x_{0},m\right),i\right)=a_{i}   will join in at this point, because it entails that     β   β   \beta   Now by transitivity of equality we get        ∀   a  0    ,  …  ,     a   n  -  1      ∃    s    ∀  i       <    n   β   (  s  ,  i  )    =   a  i           for-all   subscript  a  0    normal-…     subscript  a    n  1        s   for-all  i         n  β   s  i          subscript  a  i      \forall a_{0},\dots,a_{n-1}\;\exists s\;\forall i     QED  Our original goal was to prove that the definition      ⟨   a  0   ,  …  ,   a   n  -  1    ⟩      subscript  a  0   normal-…   subscript  a    n  1      \left\langle a_{0},\dots,a_{n-1}\right\rangle   is good for achieving what we declared in the specification of   β   β   \beta   : we want      ∀   a  0    ,  …  ,     a   n  -  1      ∃    s    ∀  i       <    n   β   (  s  ,  i  )    =   a  i           for-all   subscript  a  0    normal-…     subscript  a    n  1        s   for-all  i         n  β   s  i          subscript  a  i      \forall a_{0},\dots,a_{n-1}\;\exists s\;\forall i   to hold.  That's it, it can be seen now by transitivity of equality , looking at the above three equations.  Scope of i ends here.  Existence and uniqueness  We have just proven the correctness of the definition of    f  :    ℕ   n  +  1    →  ℕ      normal-:  f   normal-→   superscript  ℕ    n  1    ℕ     f:\mathbb{N}^{n+1}\to\mathbb{N}   : its specification requiring       f   (   a  0   ,  …  ,   a   n  -  1    ,  s  )    =   {     0      if   ∀  i  <   n    (  β   (  s  ,  i  )   =   a  i   )        1      if   ∃  i  <   n    (  β   (  s  ,  i  )   ≠   a  i   )              f    subscript  a  0   normal-…   subscript  a    n  1    s     cases  0   fragments  if  for-all  i   n   fragments  normal-(  β   fragments  normal-(  s  normal-,  i  normal-)     subscript  a  i   normal-)    1   fragments  if   i   n   fragments  normal-(  β   fragments  normal-(  s  normal-,  i  normal-)     subscript  a  i   normal-)       f\left(a_{0},\dots,a_{n-1},s\right)=\begin{cases}0&\mathrm{if}\;\forall i   is met. Although proving this was the most important, if we want to establish an encoding scheme for sequences, but we have to fill in some gaps yet. These are related notions similar to existence and uniqueness (although on uniqueness, “at most one” should be meant here, and the conjunction of both is delayed as a final result).  Uniqueness of encoding, achieved by minimalization  Because let us remember, our ultimate question is: what number should stand for the encoding of sequence    f   (   a  0   ,  …  ,   a   n  -  1    ,  s  )   =  0  ↔  ∀  i  <   n    (  β   (  s  ,  i  )   =   a  i   )      fragments  f   fragments  normal-(   subscript  a  0   normal-,  normal-…  normal-,   subscript  a    n  1    normal-,  s  normal-)    0  normal-↔  for-all  i   n   fragments  normal-(  β   fragments  normal-(  s  normal-,  i  normal-)     subscript  a  i   normal-)     f\left(a_{0},\dots,a_{n-1},s\right)=0\leftrightarrow\forall i   ? The specification declares only an existential quantification, not yet a functional connection. We want a constructive and algorithmic way, even more, a (total) recursive function for the encoding.  Totality, because minimalization is restricted to special functions  This gap can be filled in in a straightforward way: we shall use minimalization , and the totality of the resulting function is ensured by everything we have proven till now (i.e. the correctness of the definition of    ∀   a  0   ,  …  ,    a   n  -  1     ∃   s    (  f   (   a  0   ,  …  ,   a   n  -  1    ,  s  )   =  0  )      fragments  for-all   subscript  a  0   normal-,  normal-…  normal-,   subscript  a    n  1     s   fragments  normal-(  f   fragments  normal-(   subscript  a  0   normal-,  normal-…  normal-,   subscript  a    n  1    normal-,  s  normal-)    0  normal-)     \forall a_{0},\dots,a_{n-1}\;\exists s\;\left(f\left(a_{0},\dots,a_{n-1},s%
 \right)=0\right)   by meeting its specification). In fact, the specification     β   β   \beta   plays a role here of a more general notion (“special function” 16 ). The importance of this notion is that it enables us to split off the (sub)class of (total) recursive functions from the (super)class of partial recursive functions. In brief, the specification says exactly: a function f  E.g. defined by      g  :    ℕ  n   →  ℕ      normal-:  g   normal-→   superscript  ℕ  n   ℕ     g:\mathbb{N}^{n}\to\mathbb{N}          ⟨   a  0   ,  …  ,   a   n  -  1    ⟩   ⟼  μ  a  .   [  ∀  i  <   n    (  β   (  a  ,  i  )   =   a  i   )   ]      fragments   fragments  normal-⟨   subscript  a  0   normal-,  normal-…  normal-,   subscript  a    n  1    normal-⟩   normal-⟼  μ  a  normal-.   fragments  normal-[  for-all  i   n   fragments  normal-(  β   fragments  normal-(  a  normal-,  i  normal-)     subscript  a  i   normal-)   normal-]     \left\langle a_{0},\dots,a_{n-1}\right\rangle\longmapsto\mu a.\left[\forall i<%
 n\;\left(\beta\left(a,i\right)=a_{i}\right)\right]   satisfying specification      g  :    ℕ  *   →  ℕ      normal-:  g   normal-→   superscript  ℕ    ℕ     g:\mathbb{N}^{*}\to\mathbb{N}   is a special function, i.e. for each fixed combination of all-but-last arguments, the function f has root in its last argument:       ⟨   a  0   ,  …  ,   a   n  -  1    ,   a  n   ⟩   ⟼  μ  a  .   [   a  0   =  n  ∧  ∀  i  <   n    (  β   (  a  ,  i  +  1  )   =   a  i   )   ]      fragments   fragments  normal-⟨   subscript  a  0   normal-,  normal-…  normal-,   subscript  a    n  1    normal-,   subscript  a  n   normal-⟩   normal-⟼  μ  a  normal-.   fragments  normal-[   subscript  a  0    n   for-all  i   n   fragments  normal-(  β   fragments  normal-(  a  normal-,  i   1  normal-)     subscript  a  i   normal-)   normal-]     \left\langle a_{0},\dots,a_{n-1},a_{n}\right\rangle\longmapsto\mu a.\left[a_{0%
 }=n\land\forall i     The Gödel numbering function g can be chosen to be total recursive  Thus, let us choose the minimal possible number that fits well in the specification of the    x  ≡   n     (   mod   m  0    )        x   annotated  n   pmod   subscript  m  0       x\equiv n\;\;(\mathop{{\rm mod}}m_{0})   function: 17  $$g : \mathbb N^n \to \mathbb N$$  $$\left\langle a_0,\dots,a_{n-1}\right\rangle \longmapsto \mu a . \left[ \forall i < n \; \left(\beta\left(a,i\right) = a_i\right)\right]$$ and it can be proven (using the notions of the previous section ) that g is (total) recursive.  Access of length  If we use the above scheme for encoding sequences only in contexts where the length of the sequences is fixed, then no problem arises. In other words, we can use them in an analogous way as arrays are used in programming.  But sometimes we need dynamically stretching sequences, or we need to deal with sequences whose length cannot be typed in a static way. In other words, we may encode sequences in an analogous way as we use lists in programming.  An example for both cases: if we make the Gödel numbering of a Turing machine, then the each row in matrix of the “program” can be represented with tuples, sequences of fixed length (thus, without storing the length), because the number of the columns is fixed. 18 But if we want to reason about configuration-like things (of Turing-machines), and specially, we want to encode the significant part of the tape of a running Turing machine, then we have to represent sequences together with their length. Moreover, we can mimic dynamically stretching sequences by representing sequence concatenation (or at least, augmenting a sequence with one more element) with a [totally] recursive function. 19  Length can be stored simply as a surplus member: 20  $$g : \mathbb N^* \to \mathbb N$$  $$\left\langle a_0,\dots,a_{n-1}, a_n\right\rangle \longmapsto \mu a . \left[ a_0 = n \land \forall i < n \; \left(\beta\left(a,i+1\right) = a_i\right)\right]$$  The corresponding modification of the proof is straightforward, by adding a surplus  $$x \equiv n \pmod{m_0}$$ to the system of simultaneous congruences (provided that the surplus member index is chosen to be 0). Also the assumptions etc. have to be modified accordingly.  Notes    References     Each chapter is downloadable verbatim on author's page .       Translation of Smullyan 1992 .   External links     "  Category:Computability theory  Category:Articles containing proofs     Monk 1976 : 56–58 ↩  Csirmaz 1994 : 99–100 (see online ) ↩  Monk 1976 : 72–74 ↩  Monk 1976 : 52–55 ↩   Smullyan 2003 : 56 (= Chpt IV, § 5, note 1) ↩  Monk 1976 : 58 (= Thm 3.46) ↩  Hughes 1989 (see online ) ↩    Csirmaz 1994 : 100 (see online ) ↩  Burris 1998 : Supplementary Text, Arithmetic I , Lemma 4 ↩  see also related notions, e.g. “equals for equals” ( referential transparency ), and another related notion Leibniz's law / identity of indiscernibles ↩  either proof theoretic (algebraic steps); or semantic ( truth table , method of analytic tableaux , Venn diagram , Veitch diagram / Karnaugh map ) ↩  see also related notions Referential transparency, and also a dual notion Leibniz's law / identity of indiscernibles ↩  Monk 1976 : 45 (= Def 3.1.) ↩   Monk 1976 : 53 (= Def 3.20, Lem 3.21) ↩  Csirmaz 1994 : 101 (=Thm 10.7, Conseq 10.8), see online ↩      