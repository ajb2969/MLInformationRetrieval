<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="361">Algorithmic Lovász local lemma</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Algorithmic Lovász local lemma</h1>
<hr/>

<p>In <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, the <strong>algorithmic Lovász local lemma</strong> gives an algorithmic way of constructing objects that obey a system of constraints with limited dependence.</p>

<p>Given a finite set of <em>bad</em> events {<em>A</em><sub>1</sub>, ..., <em>A<sub>n</sub></em>} in a probability space with limited dependence amongst the <em>A<sub>i</sub></em>s and with specific bounds on their respective probabilities, the <a href="Lovász_local_lemma" title="wikilink">Lovász local lemma</a> proves that with non-zero probability all of these events can be avoided. However, the lemma is non-constructive in that it does not provide any insight on <em>how</em> to avoid the bad events.</p>

<p>If the events {<em>A</em><sub>1</sub>, ..., <em>A<sub>n</sub></em>} are determined by a finite collection of mutually independent random variables, a simple <a href="Las_Vegas_algorithm" title="wikilink">Las Vegas algorithm</a> with <a href="ZPP_(complexity)" title="wikilink">expected polynomial runtime</a> proposed by <a href="Robin_Moser" title="wikilink">Robin Moser</a> and <a href="Gábor_Tardos" title="wikilink">Gábor Tardos</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> can compute an assignment to the random variables such that all events are avoided.</p>
<h2 id="review-of-lovász-local-lemma">Review of Lovász local lemma</h2>

<p>The Lovász Local Lemma is a powerful tool commonly used in the <a href="probabilistic_method" title="wikilink">probabilistic method</a> to prove the existence of certain complex mathematical objects with a set of prescribed features. A typical proof proceeds by operating on the complex object in a random manner and uses the Lovász Local Lemma to bound the probability that any of the features is missing. The absence of a feature is considered a <em>bad event</em> and if it can be shown that all such bad events can be avoided simultaneously with non-zero probability, the existence follows. The lemma itself reads as follows:</p>
<blockquote>

<p>Let 

<math display="inline" id="Algorithmic_Lovász_local_lemma:0">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}=\{A_{1},\ldots,A_{n}\}
  </annotation>
 </semantics>
</math>

 be a finite set of events in the probability space Ω. For 

<math display="inline" id="Algorithmic_Lovász_local_lemma:1">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\mathcal{A}
  </annotation>
 </semantics>
</math>

 let 

<math display="inline" id="Algorithmic_Lovász_local_lemma:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Γ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma(A)
  </annotation>
 </semantics>
</math>

 denote a subset of 

<math display="inline" id="Algorithmic_Lovász_local_lemma:3">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Algorithmic_Lovász_local_lemma:4">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is independent from the collection of events 

<math display="inline" id="Algorithmic_Lovász_local_lemma:5">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>∖</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>A</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>∪</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>𝒜</ci>
    <apply>
     <union></union>
     <set>
      <ci>A</ci>
     </set>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\setminus(\{A\}\cup\Gamma(A))
  </annotation>
 </semantics>
</math>

. If there exists an assignment of reals 

<math display="inline" id="Algorithmic_Lovász_local_lemma:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>x</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒜</ci>
     <interval closure="open">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:\mathcal{A}\rightarrow(0,1)
  </annotation>
 </semantics>
</math>

 to the events such that</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>A</mi>
    </mrow>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>A</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>B</mi>
        <mo>∈</mo>
        <mrow>
         <mi mathvariant="normal">Γ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>A</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>B</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>A</ci>
     </apply>
     <ci>𝒜</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <ci>Pr</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>A</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <in></in>
         <ci>B</ci>
         <apply>
          <times></times>
          <ci>normal-Γ</ci>
          <ci>A</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\in\mathcal{A}:\Pr[A]\leq x(A)\prod_{B\in\Gamma(A)}(1-x(B))
  </annotation>
 </semantics>
</math>

</p>

<p>then the probability of avoiding all events in 

<math display="inline" id="Algorithmic_Lovász_local_lemma:8">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 is positive, in particular</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo rspace="4.2pt">[</mo>
      <mrow>
       <mover accent="true">
        <msub>
         <mi>A</mi>
         <mn>1</mn>
        </msub>
        <mo>¯</mo>
       </mover>
       <mo>∧</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>∧</mo>
       <mpadded width="+1.7pt">
        <mover accent="true">
         <msub>
          <mi>A</mi>
          <mi>n</mi>
         </msub>
         <mo>¯</mo>
        </mover>
       </mpadded>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>A</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">𝒜</mi>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <and></and>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <ci>A</ci>
       <ci>𝒜</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\left[\,\overline{A_{1}}\wedge\cdots\wedge\overline{A_{n}}\,\right]\geq%
\prod_{A\in\mathcal{A}}(1-x(A)).
  </annotation>
 </semantics>
</math>

</p>
</blockquote>
<h2 id="algorithmic-version-of-the-lovász-local-lemma">Algorithmic version of the Lovász local lemma</h2>

<p>The Lovász Local Lemma is non-constructive because it only allows us to conclude the existence of structural properties or complex objects but does not indicate how these can be found or constructed efficiently in practice. Note that random sampling from the probability space Ω is likely to be inefficient, since the probability of the event of interest</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:10">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mover accent="true">
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
      <mo>¯</mo>
     </mover>
     <mo>∧</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>∧</mo>
     <mover accent="true">
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
      <mo>¯</mo>
     </mover>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Pr</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\left[\overline{A_{1}}\wedge\cdots\wedge\overline{A_{n}}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>is only bounded by a product of small numbers</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:11">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>A</mi>
     <mo>∈</mo>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    </mrow>
   </munder>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <in></in>
      <ci>A</ci>
      <ci>𝒜</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{A\in\mathcal{A}}(1-x(A))
  </annotation>
 </semantics>
</math>

</p>

<p>and therefore likely to be very small.</p>

<p>Under the assumption that all of the events in 

<math display="inline" id="Algorithmic_Lovász_local_lemma:12">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 are determined by a finite collection of mutually independent <a href="Random_Variable" title="wikilink">random variables</a> 

<math display="inline" id="Algorithmic_Lovász_local_lemma:13">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 in Ω, <a href="Robin_Moser" title="wikilink">Robin Moser</a> and <a href="Gábor_Tardos" title="wikilink">Gábor Tardos</a> proposed an efficient randomized algorithm that computes an assignment to the random variables in 

<math display="inline" id="Algorithmic_Lovász_local_lemma:14">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 such that all events in 

<math display="inline" id="Algorithmic_Lovász_local_lemma:15">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 are avoided.</p>

<p>Hence, this algorithm can be used to efficiently construct witnesses of complex objects with prescribed features for most problems to which the Lovász Local Lemma applies.</p>
<h3 id="history">History</h3>

<p><mtpl></mtpl> Prior to the recent work of Moser and Tardos, earlier work had also made progress in developing algorithmic versions of the Lovász Local Lemma. <a href="József_Beck" title="wikilink">József Beck</a> in 1991 first gave proof that an algorithmic version was possible.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In this breakthrough result, a stricter requirement was imposed upon the problem formulation than in the original non-constructive definition. Beck's approach required that for each 

<math display="inline" id="Algorithmic_Lovász_local_lemma:16">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\mathcal{A}
  </annotation>
 </semantics>
</math>

, the number of dependencies of <em>A</em> was bounded above with 

<math display="inline" id="Algorithmic_Lovász_local_lemma:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <msup>
    <mn>2</mn>
    <mfrac>
     <mi>k</mi>
     <mn>48</mn>
    </mfrac>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <divide></divide>
      <ci>k</ci>
      <cn type="integer">48</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Gamma(A)|<2^{\frac{k}{48}}
  </annotation>
 </semantics>
</math>

 (approximately). The existential version of the Local Lemma permits a larger upper bound on dependencies:</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo><</mo>
    <mfrac>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>e</mi>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Gamma(A)|<\frac{2^{k}}{e},
  </annotation>
 </semantics>
</math>

</p>

<p>This bound is known to be tight. Since the initial algorithm, work has been done to push algorithmic versions of the Local Lemma closer to this tight value. Moser and Tardos's recent work are the most recent in this chain, and provide an algorithm that achieves this tight bound.</p>
<h3 id="algorithm">Algorithm</h3>

<p>Let us first introduce some concepts that are used in the algorithm.</p>

<p>For any random variable 

<math display="inline" id="Algorithmic_Lovász_local_lemma:19">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∈</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒫</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>P</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>P</ci>
    <list>
     <ci>𝒫</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>P</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\in\mathcal{P},v_{P}
  </annotation>
 </semantics>
</math>

 denotes the current assignment (evaluation) of <em>P</em>. An assignment (evaluation) to all random variables is denoted 

<math display="inline" id="Algorithmic_Lovász_local_lemma:20">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>P</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>P</ci>
    </apply>
    <ci>𝒫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{P})_{\mathcal{P}}
  </annotation>
 </semantics>
</math>

.</p>

<p>The unique minimal subset of random variables in 

<math display="inline" id="Algorithmic_Lovász_local_lemma:21">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 that determine the event <em>A</em> is denoted by vbl(<em>A</em>).</p>

<p>If the event <em>A</em> is true under an evaluation 

<math display="inline" id="Algorithmic_Lovász_local_lemma:22">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>P</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>P</ci>
    </apply>
    <ci>𝒫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{P})_{\mathcal{P}}
  </annotation>
 </semantics>
</math>

, we say that 

<math display="inline" id="Algorithmic_Lovász_local_lemma:23">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>P</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>P</ci>
    </apply>
    <ci>𝒫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{P})_{\mathcal{P}}
  </annotation>
 </semantics>
</math>

 <strong>satisfies</strong> <em>A</em>, otherwise it <strong>avoids</strong> <em>A</em>.</p>

<p>Given a set of bad events 

<math display="inline" id="Algorithmic_Lovász_local_lemma:24">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 we wish to avoid that is determined by a collection of mutually independent random variables 

<math display="inline" id="Algorithmic_Lovász_local_lemma:25">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

, the algorithm proceeds as follows:</p>
<ol>
<li>

<math display="inline" id="Algorithmic_Lovász_local_lemma:26">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>P</mi>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>P</ci>
    </apply>
    <ci>𝒫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall P\in\mathcal{P}
  </annotation>
 </semantics>
</math>



<math display="block" id="Algorithmic_Lovász_local_lemma:27">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>P</mi>
   </msub>
   <mo>←</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>P</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{P}\leftarrow
  </annotation>
 </semantics>
</math>

 a random evaluation of P</li>
<li><strong>while</strong> 

<math display="inline" id="Algorithmic_Lovász_local_lemma:28">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>A</mi>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <ci>A</ci>
    </apply>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists A\in\mathcal{A}
  </annotation>
 </semantics>
</math>

 such that A is satisfied by 

<math display="inline" id="Algorithmic_Lovász_local_lemma:29">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>P</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>P</ci>
    </apply>
    <ci>𝒫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{P})_{\mathcal{P}}
  </annotation>
 </semantics>
</math>


<ul>
<li>pick an arbitrary satisfied event 

<math display="inline" id="Algorithmic_Lovász_local_lemma:30">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\mathcal{A}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Algorithmic_Lovász_local_lemma:31">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>P</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mtext>vbl</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>vbl</mtext>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall P\in\text{vbl}(A)
  </annotation>
 </semantics>
</math>



<math display="block" id="Algorithmic_Lovász_local_lemma:32">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>P</mi>
   </msub>
   <mo>←</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>P</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{P}\leftarrow
  </annotation>
 </semantics>
</math>

 a new random evaluation of P</li>
</ul></li>
<li><strong>return</strong> 

<math display="inline" id="Algorithmic_Lovász_local_lemma:33">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>P</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>P</ci>
    </apply>
    <ci>𝒫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{P})_{\mathcal{P}}
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>In the first step, the algorithm randomly initializes the current assignment <em>v<sub>P</sub></em> for each random variable 

<math display="inline" id="Algorithmic_Lovász_local_lemma:34">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>P</ci>
    <ci>𝒫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\in\mathcal{P}
  </annotation>
 </semantics>
</math>

. This means that an assignment <em>v<sub>P</sub></em> is sampled randomly and independently according to the distribution of the random variable <em>P</em>.</p>

<p>The algorithm then enters the main loop which is executed until all events in 

<math display="inline" id="Algorithmic_Lovász_local_lemma:35">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 are avoided and which point the algorithm returns the current assignment. At each iteration of the main loop, the algorithm picks an arbitrary satisfied event <em>A</em> (either randomly or deterministically) and resamples all the random variables that determine <em>A</em>.</p>
<h3 id="main-theorem">Main theorem</h3>

<p>Let 

<math display="inline" id="Algorithmic_Lovász_local_lemma:36">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 be a finite set of mutually independent random variables in the probability space Ω. Let 

<math display="inline" id="Algorithmic_Lovász_local_lemma:37">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 be a finite set of events determined by these variables. If there exists an assignment of reals 

<math display="inline" id="Algorithmic_Lovász_local_lemma:38">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>x</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>𝒜</ci>
     <interval closure="open">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:\mathcal{A}\to(0,1)
  </annotation>
 </semantics>
</math>

 to the events such that</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>A</mi>
    </mrow>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>A</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>B</mi>
        <mo>∈</mo>
        <mrow>
         <mi mathvariant="normal">Γ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>A</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>B</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>A</ci>
     </apply>
     <ci>𝒜</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <ci>Pr</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>A</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <in></in>
         <ci>B</ci>
         <apply>
          <times></times>
          <ci>normal-Γ</ci>
          <ci>A</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\in\mathcal{A}:\Pr[A]\leq x(A)\prod_{B\in\Gamma(A)}(1-x(B))
  </annotation>
 </semantics>
</math>

</p>

<p>then there exists an assignment of values to the variables 

<math display="inline" id="Algorithmic_Lovász_local_lemma:40">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 avoiding all of the events in 

<math display="inline" id="Algorithmic_Lovász_local_lemma:41">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

.</p>

<p>Moreover, the randomized algorithm described above resamples an event 

<math display="inline" id="Algorithmic_Lovász_local_lemma:42">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\mathcal{A}
  </annotation>
 </semantics>
</math>

 at most an expected</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:43">
 <semantics>
  <mfrac>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{x(A)}{1-x(A)}
  </annotation>
 </semantics>
</math>

</p>

<p>times before it finds such an evaluation. Thus the expected total number of resampling steps and therefore the expected runtime of the algorithm is at most</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:44">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>A</mi>
      <mo>∈</mo>
      <mi class="ltx_font_mathcaligraphic">𝒜</mi>
     </mrow>
    </munder>
    <mfrac>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>A</ci>
      <ci>𝒜</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{A\in\mathcal{A}}\frac{x(A)}{1-x(A)}.
  </annotation>
 </semantics>
</math>

</p>

<p>The proof of this theorem using the method of <a href="entropy_compression" title="wikilink">entropy compression</a> can be found in the paper by Moser and Tardos <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="symmetric-version">Symmetric version</h3>

<p>The requirement of an assignment function <em>x</em> satisfying a set of inequalities in the theorem above is complex and not intuitive. But this requirement can be replaced by three simple conditions:</p>
<ul>
<li>

<math display="inline" id="Algorithmic_Lovász_local_lemma:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>A</mi>
    </mrow>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>A</ci>
     </apply>
     <ci>𝒜</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\in\mathcal{A}:|\Gamma(A)|\leq D
  </annotation>
 </semantics>
</math>

, i.e. each event <em>A</em> depends on at most <em>D</em> other events,</li>
<li>

<math display="inline" id="Algorithmic_Lovász_local_lemma:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>A</mi>
    </mrow>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>A</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>A</ci>
     </apply>
     <ci>𝒜</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <ci>Pr</ci>
      <ci>A</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\in\mathcal{A}:\Pr[A]\leq p
  </annotation>
 </semantics>
</math>

, i.e. the probability of each event <em>A</em> is at most <em>p</em>,</li>
<li>

<math display="inline" id="Algorithmic_Lovász_local_lemma:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>D</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>p</ci>
     <apply>
      <plus></plus>
      <ci>D</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ep(D+1)\leq 1
  </annotation>
 </semantics>
</math>

, where <em>e</em> is the <a href="e_(mathematical_constant)" title="wikilink">base of the natural logarithm</a>.</li>
</ul>

<p>The version of the Lovász Local Lemma with these three conditions instead of the assignment function <em>x</em> is called the <em>Symmetric Lovász Local Lemma</em>. We can also state the <em>Symmetric Algorithmic Lovász Local Lemma</em>:</p>

<p>Let 

<math display="inline" id="Algorithmic_Lovász_local_lemma:48">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 be a finite set of mutually independent random variables and 

<math display="inline" id="Algorithmic_Lovász_local_lemma:49">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 be a finite set of events determined by these variables as before. If the above three conditions hold then there exists an assignment of values to the variables 

<math display="inline" id="Algorithmic_Lovász_local_lemma:50">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 avoiding all of the events in 

<math display="inline" id="Algorithmic_Lovász_local_lemma:51">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

.</p>

<p>Moreover, the randomized algorithm described above resamples an event 

<math display="inline" id="Algorithmic_Lovász_local_lemma:52">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in\mathcal{A}
  </annotation>
 </semantics>
</math>

 at most an expected 

<math display="inline" id="Algorithmic_Lovász_local_lemma:53">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mi>D</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{D}
  </annotation>
 </semantics>
</math>

 times before it finds such an evaluation. Thus the expected total number of resampling steps and therefore the expected runtime of the algorithm is at most 

<math display="inline" id="Algorithmic_Lovász_local_lemma:54">
 <semantics>
  <mfrac>
   <mi>n</mi>
   <mi>D</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{n}{D}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="example">Example</h2>

<p>The following example illustrates how the algorithmic version of the Lovász Local Lemma can be applied to a simple problem.</p>

<p>Let Φ be a <a href="Conjunctive_normal_form" title="wikilink">CNF</a> formula over variables <em>X</em><sub>1</sub>, ..., <em>X<sub>n</sub></em>, containing <em>n</em> clauses, and with at least <em>k</em> <a href="Literal_(mathematical_logic)" title="wikilink">literals</a> in each clause, and with each variable <em>X<sub>i</sub></em> appearing in at most 

<math display="inline" id="Algorithmic_Lovász_local_lemma:55">
 <semantics>
  <mfrac>
   <msup>
    <mn>2</mn>
    <mi>k</mi>
   </msup>
   <mrow>
    <mi>k</mi>
    <mi>e</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{2^{k}}{ke}
  </annotation>
 </semantics>
</math>

 clauses. Then, Φ is satisfiable.</p>

<p>This statement can be proven easily using the symmetric version of the Algorithmic Lovász Local Lemma. Let <em>X</em><sub>1</sub>, ..., <em>X<sub>n</sub></em> be the set of mutually independent random variables 

<math display="inline" id="Algorithmic_Lovász_local_lemma:56">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 which are sampled <a href="Uniform_distribution_(discrete)" title="wikilink">uniformly at random</a>.</p>

<p>Firstly, we truncate each clause in Φ to contain exactly <em>k</em> literals. Since each clause is a disjunction, this does not harm satisfiability, for if we can find a satisfying assignment for the truncated formula, it can easily be extended to a satisfying assignment for the original formula by reinserting the truncated literals.</p>

<p>Now, define a bad event <em>A<sub>j</sub></em> for each clause in Φ, where <em>A<sub>j</sub></em> is the event that clause <em>j</em> in Φ is unsatisfied by the current assignment. Since each clause contains <em>k</em> literals (and therefore <em>k</em> variables) and since all variables are sampled uniformly at random, we can bound the probability of each bad event by</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>A</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>p</mi>
    <mo>=</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mi>k</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr[A_{j}]=p=2^{-k}.
  </annotation>
 </semantics>
</math>

</p>

<p>Since each variable can appear in at most 

<math display="inline" id="Algorithmic_Lovász_local_lemma:58">
 <semantics>
  <mfrac>
   <msup>
    <mn>2</mn>
    <mi>k</mi>
   </msup>
   <mrow>
    <mi>k</mi>
    <mi>e</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{2^{k}}{ke}
  </annotation>
 </semantics>
</math>

 clauses and there are <em>k</em> variables in each clause, each bad event <em>A<sub>j</sub></em> can depend on at most</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:59">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mfrac>
       <msup>
        <mn>2</mn>
        <mi>k</mi>
       </msup>
       <mrow>
        <mi>k</mi>
        <mi>e</mi>
       </mrow>
      </mfrac>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mfrac>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>e</mi>
    </mfrac>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>k</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>k</ci>
        </apply>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>e</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>k</ci>
       </apply>
       <ci>e</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=k\left(\frac{2^{k}}{ke}-1\right)\leq\frac{2^{k}}{e}-1
  </annotation>
 </semantics>
</math>

</p>

<p>other events. Therefore:</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>≤</mo>
    <mfrac>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>e</mi>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <ci>D</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D+1\leq\frac{2^{k}}{e},
  </annotation>
 </semantics>
</math>

</p>

<p>multiplying both sides by <em>ep</em> we get:</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>D</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>e</mi>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mi>k</mi>
     </mrow>
    </msup>
    <mfrac>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>e</mi>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>p</ci>
      <apply>
       <plus></plus>
       <ci>D</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>k</ci>
       </apply>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ep(D+1)\leq e2^{-k}\frac{2^{k}}{e}=1
  </annotation>
 </semantics>
</math>

</p>

<p>it follows by the symmetric Lovász Local Lemma that the probability of a random assignment to <em>X</em><sub>1</sub>, ..., <em>X<sub>n</sub></em> satisfying all clauses in Φ is non-zero and hence such an assignment must exist.</p>

<p>Now, the Algorithmic Lovász Local Lemma actually allows us to efficiently compute such an assignment by applying the algorithm described above. The algorithm proceeds as follows:</p>

<p>It starts with a random <a href="truth_value" title="wikilink">truth value</a> assignment to the variables <em>X</em><sub>1</sub>, ..., <em>X<sub>n</sub></em> sampled uniformly at random. While there exists a clause in Φ that is unsatisfied, it randomly picks an unsatisfied clause <em>C</em> in Φ and assigns a new truth value to all variables that appear in <em>C</em> chosen uniformly at random. Once all clauses in Φ are satisfied, the algorithm returns the current assignment. Hence, the Algorithmic Lovász Local Lemma proves that this algorithm has an expected runtime of at most</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:62">
 <semantics>
  <mfrac>
   <mi>n</mi>
   <mrow>
    <mfrac>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>e</mi>
    </mfrac>
    <mo>-</mo>
    <mi>k</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <ci>e</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{n}{\frac{2^{k}}{e}-k}
  </annotation>
 </semantics>
</math>

</p>

<p>steps on CNF formulas that satisfy the two conditions above. A stronger version of the above statement is proven by Moser,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> see also Berman, Karpinski and Scott.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The algorithm is similar to <a class="uri" href="WalkSAT" title="wikilink">WalkSAT</a> which is used to solve general <a href="boolean_satisfiability_problem" title="wikilink">boolean satisfiability problems</a>. The main difference is that in <a class="uri" href="WalkSAT" title="wikilink">WalkSAT</a>, after the unsatisfied clause <em>C</em> is selected, a <em>single</em> variable in <em>C</em> is selected at random and has its value flipped (which can be viewed as selecting uniformly among only 

<math display="inline" id="Algorithmic_Lovász_local_lemma:63">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 rather than all 

<math display="inline" id="Algorithmic_Lovász_local_lemma:64">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

 value assignments to <em>C</em>).</p>
<h2 id="applications">Applications</h2>

<p>As mentioned before, the Algorithmic Version of the Lovász Local Lemma applies to most problems for which the general Lovász Local Lemma is used as a proof technique. Some of these problems are discussed in the following articles:</p>
<ul>
<li><a href="Probabilistic_proofs_of_non-probabilistic_theorems" title="wikilink">Probabilistic proofs of non-probabilistic theorems</a></li>
<li><a href="Random_graph" title="wikilink">Random graph</a></li>
</ul>
<h2 id="parallel-version">Parallel version</h2>

<p>The algorithm described above lends itself well to parallelization, since resampling two independent events 

<math display="inline" id="Algorithmic_Lovász_local_lemma:65">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>A</ci>
     <ci>B</ci>
    </list>
    <ci>𝒜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,B\in\mathcal{A}
  </annotation>
 </semantics>
</math>

, i.e. 

<math display="inline" id="Algorithmic_Lovász_local_lemma:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>vbl</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∩</mo>
    <mrow>
     <mtext>vbl</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <mtext>vbl</mtext>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <mtext>vbl</mtext>
      <ci>B</ci>
     </apply>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{vbl}(A)\cap\text{vbl}(B)=\emptyset
  </annotation>
 </semantics>
</math>

, in parallel is equivalent to resampling <em>A</em>, <em>B</em> sequentially. Hence, at each iteration of the main loop one can determine the maximal set of independent and satisfied events <em>S</em> and resample all events in <em>S</em> in parallel.</p>

<p>Under the assumption that the assignment function <em>x</em> satisfies the slightly stronger conditions:</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:67">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>A</mi>
    </mrow>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>A</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>ε</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>B</mi>
        <mo>∈</mo>
        <mrow>
         <mi mathvariant="normal">Γ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>A</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>B</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>A</ci>
     </apply>
     <ci>𝒜</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <ci>Pr</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ε</ci>
      </apply>
      <ci>x</ci>
      <ci>A</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <in></in>
         <ci>B</ci>
         <apply>
          <times></times>
          <ci>normal-Γ</ci>
          <ci>A</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\in\mathcal{A}:\Pr[A]\leq(1-\varepsilon)x(A)\prod_{B\in\Gamma(A)}(1-x%
(B))
  </annotation>
 </semantics>
</math>

</p>

<p>for some ε &gt; 0 Moser and Tardos proved that the parallel algorithm achieves a better runtime complexity. In this case, the parallel version of the algorithm takes an expected</p>

<p>

<math display="block" id="Algorithmic_Lovász_local_lemma:68">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>ε</mi>
     </mfrac>
     <mi>log</mi>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>A</mi>
        <mo>∈</mo>
        <mi class="ltx_font_mathcaligraphic">𝒜</mi>
       </mrow>
      </munder>
      <mfrac>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>A</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>ε</ci>
     </apply>
     <log></log>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>A</ci>
        <ci>𝒜</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>A</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{1}{\varepsilon}\log\sum_{A\in\mathcal{A}}\frac{x(A)}{1-x(A)}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>steps before it terminates. The parallel version of the algorithm can be seen as a special case of the sequential algorithm shown above, and so this result also holds for the sequential case.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Probability_theorems" title="wikilink">Category:Probability theorems</a> <a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a class="uri" href="Category:Lemmas" title="wikilink">Category:Lemmas</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">Piotr Berman, Marek Karpinski and Alexander D. Scott, Approximation Hardness and Satisfiability of Bounded Occurrence Instances of SAT ], <a href="http://eccc.hpi-web.de/report/2003/022/">ECCC TR 03-022(2003)</a>.<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
