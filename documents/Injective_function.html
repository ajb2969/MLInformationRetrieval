<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1464">Injective function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Injective function</h1>
<hr/>

<p> </p>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, an <strong>injective function</strong> or <strong>injection</strong> or <strong>one-to-one function</strong> is a <a href="function_(mathematics)" title="wikilink">function</a> that preserves <a href="distinct" title="wikilink">distinctness</a>: it never maps distinct elements of its <a href="Domain_of_a_function" title="wikilink">domain</a> to the same element of its <a class="uri" href="codomain" title="wikilink">codomain</a>. In other words, every element of the function's codomain is the <a href="image_(mathematics)" title="wikilink">image</a> of <em>at most</em> one element of its domain. The term <em>one-to-one function</em> must not be confused with <em>one-to-one correspondence</em> (aka <a href="bijective_function" title="wikilink">bijective function</a>), which uniquely maps all elements in both domain and codomain to each other, (see figures).</p>

<p>Occasionally, an injective function from <em>X</em> to <em>Y</em> is denoted , using an arrow with a barbed tail ().<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The <a href="set_(mathematics)" title="wikilink">set</a> of injective functions from <em>X</em> to <em>Y</em> may be denoted <em>Y</em><sup><u><em>X</em></u></sup> using a notation derived from that used for <a href="falling_factorial_power" title="wikilink">falling factorial powers</a>, since if <em>X</em> and <em>Y</em> are finite sets with respectively <em>m</em> and <em>n</em> elements, the number of injections from <em>X</em> to <em>Y</em> is <em>n</em><sup><u><em>m</em></u></sup> (see the <a href="Twelvefold_way#case_i" title="wikilink">twelvefold way</a>).</p>

<p>A function <em>f</em> that is not injective is sometimes called many-to-one. However, this terminology is also sometimes used to mean "single-valued", i.e., each argument is mapped to at most one value.</p>

<p>A <a class="uri" href="monomorphism" title="wikilink">monomorphism</a> is a generalization of an injective function in <a href="category_theory" title="wikilink">category theory</a>.</p>
<h2 id="definition">Definition</h2>

<p>Let <em>f</em> be a <a href="Function_(mathematics)" title="wikilink">function</a> whose <a href="Domain_of_a_function" title="wikilink">domain</a> is a set <em>A</em>. The function <em>f</em> is <strong>injective</strong> if and only if for all <em>a</em> and <em>b</em> in <em>A</em>, if <em>f</em>(<em>a</em>) = <em>f</em>(<em>b</em>), then <em>a</em> = <em>b</em>; that is, <em>f</em>(<em>a</em>) = <em>f</em>(<em>b</em>) implies <em>a</em> = <em>b</em>.  Equivalently, if <em>a</em> ≠ <em>b</em>, then <em>f</em>(<em>a</em>) ≠ <em>f</em>(<em>b</em>).</p>

<p>Symbolically,</p>

<p>
<math display="block" id="Injective_function:0">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mo>∀</mo>
<mi>a</mi>
</mrow>
<mo>,</mo>
<mi>b</mi>
</mrow>
<mo>∈</mo>
<mi>A</mi>
</mrow>
<mo rspace="8.1pt">,</mo>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>⇒</mo>
<mi>a</mi>
<mo>=</mo>
<mi>b</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<in></in>
<list>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>a</ci>
</apply>
<ci>b</ci>
</list>
<ci>A</ci>
</apply>
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<ci>a</ci>
</apply>
<apply>
<times></times>
<ci>f</ci>
<ci>b</ci>
</apply>
</apply>
<apply>
<ci>normal-⇒</ci>
<share href="#.cmml">
</share>
<ci>a</ci>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<ci>b</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall a,b\in A,\;\;f(a)=f(b)\Rightarrow a=b
  </annotation>
</semantics>
</math>
</p>

<p>which is logically equivalent to the <a class="uri" href="contrapositive" title="wikilink">contrapositive</a>,</p>

<p>
<math display="block" id="Injective_function:1">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mo>∀</mo>
<mi>a</mi>
</mrow>
<mo>,</mo>
<mi>b</mi>
</mrow>
<mo>∈</mo>
<mi>A</mi>
</mrow>
<mo rspace="8.1pt">,</mo>
<mrow>
<mi>a</mi>
<mo>≠</mo>
<mi>b</mi>
<mo>⇒</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≠</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<in></in>
<list>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>a</ci>
</apply>
<ci>b</ci>
</list>
<ci>A</ci>
</apply>
<apply>
<and></and>
<apply>
<neq></neq>
<ci>a</ci>
<ci>b</ci>
</apply>
<apply>
<ci>normal-⇒</ci>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>f</ci>
<ci>a</ci>
</apply>
</apply>
<apply>
<neq></neq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>f</ci>
<ci>b</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall a,b\in A,\;\;a\neq b\Rightarrow f(a)\neq f(b)
  </annotation>
</semantics>
</math>
</p>
<h2 id="examples">Examples</h2>
<ul>
<li>For any set <em>X</em> and any subset <em>S</em> of <em>X</em> the <a href="inclusion_map" title="wikilink">inclusion map</a>  (which sends any element <em>s</em> of <em>S</em> to itself) is injective. In particular the <a href="identity_function" title="wikilink">identity function</a>  is always injective (and in fact bijective).</li>
<li>If the domain <em>X</em> = <a class="uri" href="∅" title="wikilink">∅</a> or <em>X</em> has only one element, the function  is always injective.</li>
<li>The function <em>f</em> : <strong>R</strong> → <strong>R</strong> defined by <em>f</em>(<em>x</em>) = 2<em>x</em> + 1 is injective.</li>
<li>The function <em>g</em> : <strong>R</strong> → <strong>R</strong> defined by <em>g</em>(<em>x</em>) = <em>x</em><sup>2</sup> is <em>not</em> injective, because (for example) <em>g</em>(1) = 1 = <em>g</em>(−1). However, if <em>g</em> is redefined so that its domain is the non-negative real numbers [0,+∞), then <em>g</em> is injective.</li>
<li>The <a href="exponential_function" title="wikilink">exponential function</a> exp : <strong>R</strong> → <strong>R</strong> defined by exp(<em>x</em>) = <em>e</em><sup><em>x</em></sup> is injective (but not <a class="uri" href="surjective" title="wikilink">surjective</a> as no real value maps to a negative number).</li>
<li>The <a href="natural_logarithm" title="wikilink">natural logarithm</a> function ln : (0, ∞) → <strong>R</strong> defined by <em>x</em> ↦ ln <em>x</em> is injective.</li>
<li>The function <em>g</em> : <strong>R</strong> → <strong>R</strong> defined by <em>g</em>(<em>x</em>) = <em>x</em><sup><em>n</em></sup> − <em>x</em> is not injective, since, for example, <em>g</em>(0) = <em>g</em>(1).</li>
</ul>

<p>More generally, when <em>X</em> and <em>Y</em> are both the <a href="real_line" title="wikilink">real line</a> <strong>R</strong>, then an injective function <em>f</em> : <strong>R</strong> → <strong>R</strong> is one whose graph is never intersected by any horizontal line more than once. This principle is referred to as the <em><a href="horizontal_line_test" title="wikilink">horizontal line test</a></em>.</p>
<figure><b>(Figure)</b>
<figcaption>"310px"|left|thumb|Injective functions. Diagramatic interpretation in the <a href="Cartesian_plane" title="wikilink">Cartesian plane</a>, defined by the <a href="Map_(mathematics)" title="wikilink">mapping</a> <em>f</em> : <em>X</em> → <em>Y</em>, where <em>y</em> = <em>f</em>(<em>x</em>), <em>X</em> = <a href="Domain_of_a_function" title="wikilink">domain of function</a>, <em>Y</em> = <a href="range_(mathematics)" title="wikilink">range of function</a>, and im(<em>f</em>) denotes <a href="Image_(mathematics)" title="wikilink">image</a> of <em>f</em>. Every one <em>x</em> in <em>X</em> maps to exactly one unique <em>y</em> in <em>Y</em>. The circled parts of the axes represent domain and range sets – in accordance with the standard diagrams above.</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>"400px"|right|thumb|Not an injective function. Here <em>X</em><sub>1</sub> and <em>X</em><sub>2</sub> are subsets of <em>X</em>, <em>Y</em><sub>1</sub> and <em>Y</em><sub>2</sub> are subsets of <em>Y</em>: for two regions where the function is not injective because more than one domain <a href="Element_(mathematics)" title="wikilink">element</a> can map to a single range element. That is, it is possible for <em>more than one</em> <em>x</em> in <em>X</em> to map to the <em>same</em> <em>y</em> in <em>Y</em>.</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>"550px"|right|thumb|Making functions injective. The previous function <em>f</em> : <em>X</em> → <em>Y</em> can be reduced to one or more injective functions (say) <em>f</em> : <em>X</em><sub>1</sub> → <em>Y</em><sub>1</sub> and <em>f</em> : <em>X</em><sub>2</sub> → <em>Y</em><sub>2</sub>, shown by solid curves (long-dash parts of initial curve are not mapped to anymore). Notice how the rule <em>f</em> has not changed – only the domain and range. <em>X</em><sub>1</sub> and <em>X</em><sub>2</sub> are subsets of <em>X</em>, <em>Y</em><sub>1</sub> and <em>Y</em><sub>2</sub> are subsets of <em>R</em>: for two regions where the initial function can be made injective so that one domain element can map to a single range element. That is, only one <em>x</em> in <em>X</em> maps to one <em>y</em> in <em>Y</em>.</figcaption>
</figure>

<p>{{-}}</p>
<h2 id="injections-can-be-undone">Injections can be undone</h2>

<p>Functions with <a href="Inverse_function#Left_and_right_inverses" title="wikilink">left inverses</a> are always injections. That is, given <em>f</em> : <em>X</em> → <em>Y</em>, if there is a function <em>g</em> : <em>Y</em> → <em>X</em> such that, for every <em>x</em> ∈ <em>X</em></p>
<dl>
<dd><em>g</em>(<em>f</em>(<em>x</em>)) = <em>x</em> (<em>f</em> can be undone by <em>g</em>)
</dd>
</dl>

<p>then <em>f</em> is injective. In this case, <em>g</em> is called a <a href="Retract_(category_theory)" title="wikilink">retraction</a> of <em>f</em>. Conversely, <em>f</em> is called a <a href="Retract_(category_theory)" title="wikilink">section</a> of <em>g</em>.</p>

<p>Conversely, every injection <em>f</em> with non-empty domain has a left inverse <em>g</em> (in conventional mathematics<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>). Note that <em>g</em> may not be a complete <a href="inverse_function" title="wikilink">inverse</a> of <em>f</em> because the composition in the other order, <mtpl></mtpl>, may not be the identity on <em>Y</em>. In other words, a function that can be undone or "<em>reversed</em>", such as <em>f</em>, is not necessarily <a href="inverse_function" title="wikilink">invertible</a> (<a class="uri" href="bijective" title="wikilink">bijective</a>). Injections are "<em>reversible</em>" but not always invertible.</p>

<p>Although it is impossible to reverse a non-injective (and therefore information-losing) function, one can at least obtain a "quasi-inverse" of it, that is a <a href="multivalued_function" title="wikilink">multiple-valued</a> function.</p>
<h2 id="injections-may-be-made-invertible">Injections may be made invertible</h2>

<p>In fact, to turn an injective function <em>f</em> : <em>X</em> → <em>Y</em> into a <a href="bijective_function" title="wikilink">bijective</a> (hence <a href="Inverse_function" title="wikilink">invertible</a>) function, it suffices to replace its codomain <em>Y</em> by its actual range <em>J</em> = <em>f</em>(<em>X</em>). That is, let <em>g</em> : <em>X</em> → <em>J</em> such that <em>g</em>(<em>x</em>) = <em>f</em>(<em>x</em>) for all <em>x</em> in <em>X</em>; then <em>g</em> is bijective. Indeed, <em>f</em> can be factored as <mtpl></mtpl>, where incl<sub><em>J</em>,<em>Y</em></sub> is the <a href="inclusion_function" title="wikilink">inclusion function</a> from <em>J</em> into <em>Y</em>.</p>

<p>More generally, injective <a href="partial_function" title="wikilink">partial functions</a> are called <a href="partial_bijection" title="wikilink">partial bijections</a>.</p>
<h2 id="other-properties">Other properties</h2>
<ul>
<li>If <em>f</em> and <em>g</em> are both injective, then <mtpl></mtpl> is injective.</li>
</ul>
<figure><b>(Figure)</b>
<figcaption>The composition of two injective functions is injective.</figcaption>
</figure>
<ul>
<li>If <mtpl></mtpl> is injective, then <em>f</em> is injective (but <em>g</em> need not be).</li>
<li><em>f</em> : <em>X</em> → <em>Y</em> is injective if and only if, given any functions <em>g</em>, <em>h</em> : <em>W</em> → <em>X</em>, whenever <mtpl></mtpl> = <mtpl></mtpl>, then <em>g</em> = <em>h</em>. In other words, injective functions are precisely the <a href="monomorphism" title="wikilink">monomorphisms</a> in the <a href="category_theory" title="wikilink">category</a> <strong><a href="Category_of_sets" title="wikilink">Set</a></strong> of sets.</li>
<li>If <em>f</em> : <em>X</em> → <em>Y</em> is injective and <em>A</em> is a <a class="uri" href="subset" title="wikilink">subset</a> of <em>X</em>, then <em>f</em><sup> −1</sup>(<em>f</em>(<em>A</em>)) = <em>A</em>. Thus, <em>A</em> can be recovered from its <a href="image_(function)" title="wikilink">image</a> <em>f</em>(<em>A</em>).</li>
<li>If <em>f</em> : <em>X</em> → <em>Y</em> is injective and <em>A</em> and <em>B</em> are both subsets of <em>X</em>, then <em>f</em>(<em>A</em> ∩ <em>B</em>) = <em>f</em>(<em>A</em>) ∩ <em>f</em>(<em>B</em>).</li>
<li>Every function <em>h</em> : <em>W</em> → <em>Y</em> can be decomposed as <em>h</em> = <mtpl></mtpl> for a suitable injection <em>f</em> and surjection <em>g</em>. This decomposition is unique <a href="up_to_isomorphism" title="wikilink">up to isomorphism</a>, and <em>f</em> may be thought of as the <a href="inclusion_function" title="wikilink">inclusion function</a> of the range <em>h</em>(<em>W</em>) of <em>h</em> as a subset of the codomain <em>Y</em> of <em>h</em>.</li>
<li>If <em>f</em> : <em>X</em> → <em>Y</em> is an injective function, then <em>Y</em> has at least as many elements as <em>X</em>, in the sense of <a href="cardinal_number" title="wikilink">cardinal numbers</a>. In particular, if, in addition, there is an injection from 

<math display="inline" id="Injective_function:2">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>

 to 

<math display="inline" id="Injective_function:3">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>


, then 

<math display="inline" id="Injective_function:4">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Injective_function:5">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>

 have the same cardinal number. (This is known as the <a href="Cantor–Bernstein–Schroeder_theorem" title="wikilink">Cantor–Bernstein–Schroeder theorem</a>.)</li>
<li>If both <em>X</em> and <em>Y</em> are <a href="finite_set" title="wikilink">finite</a> with the same number of elements, then <em>f</em> : <em>X</em> → <em>Y</em> is injective if and only if <em>f</em> is <a class="uri" href="surjective" title="wikilink">surjective</a> (in which case <em>f</em> is <a class="uri" href="bijective" title="wikilink">bijective</a>).</li>
<li>An injective function which is a <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> between two algebraic structures is an <a class="uri" href="embedding" title="wikilink">embedding</a>.</li>
<li>Unlike surjectivity, which is a relation between the graph of a function and its codomain, injectivity is a property of the graph of the function alone; that is, whether a function f is injective can be decided by only considering the graph (and not the codomain) of f.</li>
</ul>
<h2 id="proving-that-functions-are-injective">Proving that functions are injective</h2>

<p>A proof that a function <em>ƒ</em> is injective depends on how the function is presented and what properties the function holds. For functions that are given by some formula there is a basic idea. We use the contrapositive of the definition of injectivity, namely that if <em>ƒ</em>(<em>x</em>) = <em>ƒ</em>(<em>y</em>), then <em>x</em> = <em>y</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Here is an example:</p>
<dl>
<dd><em>ƒ</em> = 2<em>x</em> + 3
</dd>
</dl>

<p>Proof: Let <em>ƒ</em> : <em>X</em> → <em>Y</em>. Suppose <em>ƒ</em>(<em>x</em>) = <em>ƒ</em>(<em>y</em>). So 2<em>x</em> + 3 = 2<em>y</em> + 3 =&gt; 2<em>x</em> = 2<em>y</em> =&gt; <em>x</em> = <em>y</em>. Therefore it follows from the definition that <em>ƒ</em> is injective.</p>

<p>There are multiple other methods of proving that a function is injective. For example, in calculus if <em>ƒ</em> is differentiable on some interval, then it is sufficient to show that the derivative is always positive or always negative on that interval. In linear algebra, if <em>ƒ</em> is a linear transformation it is sufficient to show that the kernel of <em>ƒ</em> contains only the zero vector. If <em>ƒ</em> is a function with finite domain it is sufficient to look through the list of images of each domain element and check that no image occurs twice on the list.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Surjective_function" title="wikilink">Surjective function</a></li>
<li><a href="Bijective_function" title="wikilink">Bijective function</a></li>
<li><a href="Partial_function" title="wikilink">Partial function</a></li>
<li><a href="Injective_module" title="wikilink">Injective module</a></li>
<li><a href="Bijection,_injection_and_surjection" title="wikilink">Bijection, injection and surjection</a></li>
<li><a href="Horizontal_line_test" title="wikilink">Horizontal line test</a></li>
<li><a href="Injective_metric_space" title="wikilink">Injective metric space</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>

<p>, p. 17 <em>ff</em>.</p></li>
<li>

<p>, p. 38 <em>ff</em>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://jeff560.tripod.com/i.html">Earliest Uses of Some of the Words of Mathematics: entry on Injection, Surjection and Bijection has the history of Injection and related terms.</a></li>
<li><a href="http://www.khanacademy.org/math/linear-algebra/v/surjective--onto--and-injective--one-to-one--functions">Khan Academy – Surjective (onto) and Injective (one-to-one) functions: Introduction to surjective and injective functions</a></li>
</ul>

<p>"</p>

<p><a href="Category:Functions_and_mappings" title="wikilink">Category:Functions and mappings</a> <a href="Category:Basic_concepts_in_set_theory" title="wikilink">Category:Basic concepts in set theory</a> <a href="Category:Types_of_functions" title="wikilink">Category:Types of functions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">This principle is valid in conventional mathematics, but may fail in <a href="constructive_mathematics" title="wikilink">constructive mathematics</a>. For instance, a left inverse of the inclusion {0,1} → <strong>R</strong> of the two-element set in the reals violates <a class="uri" href="indecomposability" title="wikilink">indecomposability</a> by giving a <a href="Retract_(category_theory)" title="wikilink">retraction</a> of the real line to the set {0,1}.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
