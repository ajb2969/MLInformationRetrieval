   FO (complexity)      FO (complexity)   In descriptive complexity , a branch of computational complexity , FO is a complexity class of structures which can be recognized by formulas of first-order logic , and also equals the complexity class AC 0 . Descriptive complexity uses the formalism of logic, but does not use several key notions associated with logic such as proof theory or axiomatization.  Restricting predicates to be from a set X yields a smaller class FO[X] . For instance, ''FO[ This allows the complexity of some problems to be established without reference to algorithms .  Definition and examples  The idea  When we use the logic formalism to describe a computational problem, the input is a finite structure, and the elements of that structure are the domain of discourse . Usually the input is either a string (of bits or over an alphabet) and the elements of the logical structure represent positions of the string, or the input is a graph and the elements of the logical structure represent its vertices. The length of the input will be measured by the size of the respective structure. Whatever the structure is, we can assume that there are relations that can be tested, for example "    E   (  x  ,  y  )       E   x  y     E(x,y)   is true iff there is an edge from   x   x   x   to   y   y   y   " (in case of the structure being a graph), or "    P   (  n  )       P  n    P(n)   is true iff the   n   n   n   th letter of the string is 1." These relations are the predicates for the first-order logic system. We also have constants, which are special elements of the respective structure, for example if we want to check reachability in a graph, we will have to choose two constants s (start) and t (terminal).  In descriptive complexity theory we almost always suppose that there is a total order over the elements and that we can check equality between elements. This lets us consider elements as numbers: the element   x   x   x   represents the number   n   n   n   iff there are    (   n  -  1   )      n  1    (n-1)   elements   y   y   y   with   k   k   k   is true if only the   x   x   x   th bit of    p  l  u  s   (  x  ,  y  ,  z  )       p  l  u  s   x  y  z     plus(x,y,z)   is 1. (We can replace addition and multiplication by ternary relations such that     x  +  y   =  z        x  y   z    x+y=z   is true iff    t  i  m  e  s   (  x  ,  y  ,  z  )       t  i  m  e  s   x  y  z     times(x,y,z)   and     x  *  y   =  z        x  y   z    x*y=z   is true iff   ∧     \wedge   ).  Formally  Let X be a set of predicate. The language FO[X] is defined as the closure by conjunction (   ¬     \neg   ), negation (   ∀   for-all   \forall   ) and universal quantification (   ∃     \exists   ) over elements of the structures. Existential quantification (   ∨     \vee   ) and disjunction (     P  a    (  x  )        subscript  P  a   x    P_{a}(x)   ) are also often used but those can be defined by means of the first three symbols. The base case is the predicates of X applied to some variables. One always implicitly has a predicate   a   a   a   for each letter   x   x   x   of an alphabet, stating that the letter at position   a   a   a   is an    ¬  A       A    \neg A   .  The semantics of the formulae in FO is straightforward,   A   A   A   is true iff    A  ∧  B      A  B    A\wedge B   is false,   A   A   A   is true iff   B   B   B   is true and    ∀   x  P   (  x  )       for-all    x  P  x     \forall xP(x)   is true, and    P   (  v  )       P  v    P(v)   is true iff   v   v   v   is true for all values   x   x   x   that    P   (   x  1   ,  …  ,   x  c   )       P    subscript  x  1   normal-…   subscript  x  c      P(x_{1},\dots,x_{c})   may take in the underlying universe. For P a c -ary predicate,    x  i     subscript  x  i    x_{i}   is true if and only if when    n  i     subscript  n  i    n_{i}   is interpreted as    P   (   n  1   ,  …  ,   n  c   )       P    subscript  n  1   normal-…   subscript  n  c      P(n_{1},\dots,n_{c})       ∀  ,  ∃     for-all     \forall,\exists   is true.  Property  Warning  A query in FO will then be to check if a first-order formula is true over a given structure representing the input to the problem. One should not confuse this kind of problem with checking if a quantified boolean formula is true, which is the definition of QBF , which is PSPACE-complete . The difference between those two problems is that in QBF the size of the problem is the size of the formula and elements are just boolean values, whereas in FO the size of the problem is the size of the structure and the formula is fixed.  This is similar to Parameterized complexity but the size of the formula is not a fixed parameter.  Normal form  Every formula is equivalent to a formula in prenex normal form (where all quantifiers are written first, followed a quantifier-free formula).  Operators  FO without any operators  In circuit complexity , FO(ARB) where ARB is the set of every predicates, the logic where we can use arbitrary predicates, can be shown to be equal to AC 0 , the first class in the AC hierarchy. Indeed, there is a natural translation from FO's symbols to nodes of circuits, with   ∧     \land   being   ∨     \lor   and   n   n   n   of size    x  ,  y     x  y    x,y   .  FO(BIT) is the restriction of AC 0 family of circuit constructible in alternative logarithmic time . ''FO(k be an integer,   k   k   k   be vectors of   P   P   P   variables,   k   k   k   be a second-order variable of arity   ϕ   ϕ   \phi   , and   x   x   x   be a FO(PFP,X) function using   P   P   P   and     (   P  i   )    i  ∈  N      subscript   subscript  P  i     i  N     (P_{i})_{i\in N}   as variables. We can iteratively define      P  0    (  x  )    =   f  a  l  s  e          subscript  P  0   x     f  a  l  s  e     P_{0}(x)=false   such that      P  i    (  x  )    =   ϕ   (   P   i  -  1    ,  x  )           subscript  P  i   x     ϕ    subscript  P    i  1    x      P_{i}(x)=\phi(P_{i-1},x)   and   ϕ   ϕ   \phi   (meaning    P   i  -  1      subscript  P    i  1     P_{i-1}   with   P   P   P   substituted for the second-order variable    (   P  i   )     subscript  P  i    (P_{i})   ). Then, either there is a fixed point, or the list of     (   ϕ   P  ,  x    )    (  y  )        subscript  ϕ   P  x    y    (\phi_{P,x})(y)   s is cyclic.  PFP    (   P  i   )     subscript  P  i    (P_{i})   is defined as the value of the fixed point of   y   y   y   on   P   P   P   if there is a fixed point, else as false. Since   k   k   k   s are properties of arity    2   n  k      superscript  2   superscript  n  k     2^{n^{k}}   , there are at most    P  i     subscript  P  i    P_{i}   values for the    2   n   O   (  1  )        superscript  2   superscript  n    O  1      2^{n^{O(1)}}   s, so with a polynomial-space counter we can check if there is a loop or not.  It has been proven that FO(PFP,BIT) is equal to PSPACE . This definition is equivalent to FO(   P   P   P   ).  Least Fixed Point is P  FO(LFP,X) is the set of boolean queries definable in FO(PFP,X) where the partial fixed point is limited to be monotone. That is, if the second order variable is     P  i    (  x  )        subscript  P  i   x    P_{i}(x)   , then     P   i  +  1     (  x  )        subscript  P    i  1    x    P_{i+1}(x)   always implies   ϕ   ϕ   \phi   .  We can guarantee monotonicity by restricting the formula   P   P   P   to only contain positive occurrences of    ϕ   P  ,  x      subscript  ϕ   P  x     \phi_{P,x}   (that is, occurrences preceded by an even number of negations). We can alternatively describe LFP(    ψ   P  ,  x      subscript  ψ   P  x     \psi_{P,x}   ) as PFP(     ψ   (  P  ,  x  )    =    ϕ   (  P  ,  x  )    ∨   P   (  x  )           ψ   P  x        ϕ   P  x      P  x      \psi(P,x)=\phi(P,x)\vee P(x)   ) where   P   P   P   .  Due to monotonicity, we only add vectors to the truth table of    n  k     superscript  n  k    n^{k}   , and since there are only    n  k     superscript  n  k    n^{k}   possible vectors we will always find a fixed point before    n   O   (  1  )       superscript  n    O  1     n^{O(1)}   iterations. Hence it can be shown that FO(LFP,BIT)= P . This definition is equivalent to FO(   k   k   k   ).  Transitive closure is NL  FO(TC,X) is the set of boolean queries definable in FO(X) with a transitive closure (TC) operator.  TC is defined this way: let    u  ,  v  ,  x  ,  y     u  v  x  y    u,v,x,y   be a positive integer and   k   k   k   be vector of     (   ϕ   u  ,  v    )    (  x  ,  y  )        subscript  ϕ   u  v     x  y     (\phi_{u,v})(x,y)   variables. Then TC   n   n   n   is true if there exist    (   z  i   )     subscript  z  i    (z_{i})   vectors of variables      z  1   =  x   ,    z  n   =  y      formulae-sequence     subscript  z  1   x      subscript  z  n   y     z_{1}=x,z_{n}=y   such that   ϕ   ϕ   \phi   , and for all    ϕ   (  x  ,  y  )       ϕ   x  y     \phi(x,y)   is true. Here,   u   u   u   is a formula written in FO(TC) and   v   v   v   means that the variables   x   x   x   and   y   y   y   are replaced by    ϕ   u  ,  v      subscript  ϕ   u  v     \phi_{u,v}   and   u   u   u   .  FO(TC,BIT) is equal to NL .  Deterministic transitive closure is L  FO(DTC,X) is defined as FO(TC,X) where the transitive closure operator is deterministic. This means that when we apply DTC(   v   v   v   ), we know that for all    ϕ   (  u  ,  v  )       ϕ   u  v     \phi(u,v)   , there exists at most one    ϕ   u  ,  v      subscript  ϕ   u  v     \phi_{u,v}   such that    ψ   u  ,  v      subscript  ψ   u  v     \psi_{u,v}   .  We can suppose that DTC(    ψ   (  u  ,  v  )   =  ϕ   (  u  ,  v  )   ∧  ∀  x   (  x  =  v  ∨  ¬  ϕ   (  u  ,  x  )   )      fragments  ψ   fragments  normal-(  u  normal-,  v  normal-)    ϕ   fragments  normal-(  u  normal-,  v  normal-)    for-all  x   fragments  normal-(  x   v    ϕ   fragments  normal-(  u  normal-,  x  normal-)   normal-)     \psi(u,v)=\phi(u,v)\wedge\forall x(x=v\vee\neg\phi(u,x))   ) is syntactic sugar for TC(    0  ,   (   n  -  1   )      0    n  1     0,(n-1)   ) where    t   (  n  )       t  n    t(n)   .  It has been shown that FO(DTC,BIT) is equal to L .  Normal form  Any formula with a fixed point (resp. transitive cosure) operator can without loss of generality be written with exactly one application of the operators applied to 0 (resp.    t   (  n  )       t  n    t(n)   )  Iterating  We will define first-order with iteration, 'FO[    t   (  n  )       t  n    t(n)   ] '; here    t   (  n  )       t  n    t(n)   is a (class of) functions from integers to integers, and for different classes of functions     (   ∀   x  P    )   Q       for-all    x  P    Q    (\forall xP)Q   we will obtain different complexity classes FO[    (  ∀  x   (  P  ⇒  Q  )   )     fragments  normal-(  for-all  x   fragments  normal-(  P  normal-⇒  Q  normal-)   normal-)    (\forall x(P\Rightarrow Q))   ].  In this section we will write     (   ∃   x  P    )   Q          x  P    Q    (\exists xP)Q   to mean    (   ∃   x   (   P  ∨  Q   )     )        x    P  Q      (\exists x(P\vee Q))   and     (    Q  1    x  1    ,   ϕ  1   )   …   (    Q  k    x  k    ,   ϕ  k   )           subscript  Q  1    subscript  x  1     subscript  ϕ  1    normal-…      subscript  Q  k    subscript  x  k     subscript  ϕ  k      (Q_{1}x_{1},\phi_{1})...(Q_{k}x_{k},\phi_{k})   to mean    ϕ  i     subscript  ϕ  i    \phi_{i}   . We first need to define quantifier blocks (QB), a quantifier block is a list    Q  i     subscript  Q  i    Q_{i}   where the   ∀   for-all   \forall   s are quantifier-free FO -formulae and   ∃     \exists   s are either   Q   Q   Q   or     [  Q  ]    t   (  n  )       superscript   delimited-[]  Q     t  n     [Q]^{t(n)}   . If   Q   Q   Q   is a quantifiers block then we will call    t   (  n  )       t  n    t(n)   the iteration operator, which is defined as     k  *  t    (  n  )         k  t   n    k*t(n)   written   k   k   k   time. One should pay attention that here there are    t   (  n  )       t  n    t(n)   quantifiers in the list, but only    t   (  n  )       t  n    t(n)   variables and each of those variable are used    t   (  n  )       t  n    t(n)   times.  We can now define FO[     (   log  n   )   i     superscript    n   i    (\log n)^{i}   ] to be the FO-formulae with an iteration operator whose exponent is in the class    t   (  n  )       t  n    t(n)   , and we obtain those equalities:   FO[    t   (  n  )       t  n    t(n)   ] is equal to FO-uniform AC i , and in fact FO[     (   log  n   )    O   (  1  )       superscript    n     O  1     (\log n)^{O(1)}   ] is FO-uniform AC of depth    n   O   (  1  )       superscript  n    O  1     n^{O(1)}   .  FO[    2   n   O   (  1  )        superscript  2   superscript  n    O  1      2^{n^{O(1)}}   ] is equal to NC .  FO[    succ   (  x  ,  y  )       succ   normal-x  normal-y     \rm{succ}(x,y)   ] is equal to PTIME , it is also another way to write |FO(LFP).  FO[     x  +  1   =  y        x  1   y    x+1=y   ] is equal to PSPACE , it is also another way to write FO(PFP) .   Logic without arithmetical relations  Let the successor relation, succ , be a binary relation such that     plus   (  a  ,  b  ,  c  )    =    (     DTC   v  ,  x  ,  y  ,  z    succ   (  v  ,  y  )    ∧   succ   (  z  ,  x  )     )    (  a  ,  b  ,  c  ,  0  )          plus   normal-a  normal-b  normal-c           subscript  DTC   normal-v  normal-x  normal-y  normal-z    succ   normal-v  normal-y      succ   normal-z  normal-x      normal-a  normal-b  normal-c  0      \rm{plus}(a,b,c)=(\rm{DTC}_{v,x,y,z}\rm{succ}(v,y)\land\rm{succ}(z,x))(a,b,c,0)   is true if and only if     bit   (  a  ,  b  )    =    (    DTC   a  ,  b  ,   a  ′   ,   b  ′     ψ   )    (  a  ,  b  ,  1  ,  0  )          bit   normal-a  normal-b         subscript  DTC   normal-a  normal-b   superscript  normal-a  normal-′    superscript  normal-b  normal-′     ψ    normal-a  normal-b  1  0      \rm{bit}(a,b)=(\rm{DTC}_{a,b,a^{\prime},b^{\prime}}\psi)(a,b,1,0)   .  Over first order logic, succ is strictly less expressive than \times are as expressive as bit .  Using successor to define bit  It is possible to define the plus and then the bit relations with a deterministic transitive closure.      ψ  =  if  b  =  0  then   (  if  ∃  m   (  a  =  m  +  m  +  1  )   then   (   a  ′   =  1  ∧   b  ′   =  0  )   else  ⊥  )   else   (  succ   (   b  ′   ,  b  )   ∧   (  a  +  a  =   a  ′   ∨  a  +  a  +  1  =   a  ′   )       fragments  ψ   if  b   0  then   fragments  normal-(  if   m   fragments  normal-(  a   m   m   1  normal-)   then   fragments  normal-(   superscript  a  normal-′    1    superscript  b  normal-′    0  normal-)   else  bottom  normal-)   else   fragments  normal-(  succ   fragments  normal-(   superscript  normal-b  normal-′   normal-,  b  normal-)     fragments  normal-(  a   a    superscript  normal-a  normal-′    a   a   1    superscript  normal-a  normal-′   normal-)      \psi=\text{if }b=0\text{ then }(\text{if }\exists m(a=m+m+1)\text{ then }(a^{%
 \prime}=1\land b^{\prime}=0)\text{ else }\bot)\text{ else }(\rm{succ}(b^{%
 \prime},b)\land(a+a=a^{\prime}\lor a+a+1=a^{\prime})   and     a   a   a   with      b  >  0      b  0    b>0     This just means that when we query for bit 0 we check the parity, and go to (1,0) if   a   a   a   is odd(which is an accepting state), else we reject. If we check a bit    b  -  1      b  1    b-1   , we divide $a$ by 2 and check bit $b-1$ .  Hence it makes no sense to speak of operators with successor alone, without the other predicates.  Logics without successor  FO[LFP] and FO[PFP] are two logics without any predicates, apart from the equality predicates between variables and the letters predicates. They are equal respectively to relational-P and FO(PFP) is relational-PSPACE , the classes P and PSPACE over relational machines . 1  The Abiteboul-Vianu Theorem states that FO(LFP)=FO(PFP) if and only if FO( This shows that the order problem in first order is more a technical problem than a fundamental one.  References   Ronald Fagin , Generalized First-Order Spectra and Polynomial-Time Recognizable Sets . Complexity of Computation , ed. R. Karp, SIAM-AMS Proceedings 7, pp. 27–41. 1974.  Ronald Fagin, Finite model theory-a personal perspective . Theoretical Computer Science 116, 1993, pp. 3–31.  Neil Immerman. Languages Which Capture Complexity Classes . 15th ACM STOC Symposium , pp. 347–354. 1983.   External links   Neil Immerman's descriptive complexity page , including a diagram  Complexity zoo about FO , see also the following classes   "    Category:Finite model theory  Category:Complexity classes     Serge Abiteboul, Moshe Y. Vardi , Victor Vianu : Fixpoint logics, relational machines, and computational complexity Journal of the ACM (JACM) archive, Volume 44 , Issue 1 (January 1997), Pages: 30-56, ISSN:0004-5411 ↩     