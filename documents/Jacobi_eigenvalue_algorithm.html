<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1852">Jacobi eigenvalue algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Jacobi eigenvalue algorithm</h1>
<hr/>

<p>In <a href="numerical_linear_algebra" title="wikilink">numerical linear algebra</a>, the <strong>Jacobi eigenvalue algorithm</strong> is an <a href="iterative_method" title="wikilink">iterative method</a> for the calculation of the <a href="eigenvalue" title="wikilink">eigenvalues</a> and <a href="eigenvector" title="wikilink">eigenvectors</a> of a <a href="real_number" title="wikilink">real</a> <a href="symmetric_matrix" title="wikilink">symmetric matrix</a> (a process known as <a href="Matrix_diagonalization#Diagonalization" title="wikilink">diagonalization</a>). It is named after <a href="Carl_Gustav_Jacob_Jacobi" title="wikilink">Carl Gustav Jacob Jacobi</a>, who first proposed the method in 1846,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> but only became widely used in the 1950s with the advent of computers.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="description">Description</h2>

<p>Let <em>S</em> be a symmetric matrix, and <em>G</em> = <em>G</em>(<em>i</em>,<em>j</em>,<em>θ</em>) be a <a href="Givens_rotation" title="wikilink">Givens rotation matrix</a>. Then:</p>

<p>

<math display="block" id="Jacobi_eigenvalue_algorithm:0">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mi>S</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>G</mi>
      <mo>⊤</mo>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <csymbol cd="latexml">top</csymbol>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}=GSG^{\top}\,
  </annotation>
 </semantics>
</math>

</p>

<p>is symmetric and <a href="similar_(linear_algebra)" title="wikilink">similar</a> to <em>S</em>.</p>

<p>Furthermore, <em>S′</em> has entries:</p>

<p>

<math display="inline" id="Jacobi_eigenvalue_algorithm:1">
 <semantics>
  <msubsup>
   <mi>S</mi>
   <mrow>
    <mi>i</mi>
    <mi>i</mi>
   </mrow>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle S^{\prime}_{ii}
  </annotation>
 </semantics>
</math>


</p>

<p>where <em>s</em> = sin(<em>θ</em>) and <em>c</em> = cos(<em>θ</em>).</p>

<p>Since <em>G</em> is orthogonal, <em>S</em> and <em>S</em>′ have the same <a href="Frobenius_norm" title="wikilink">Frobenius norm</a> ||·||<sub>F</sub> (the square-root sum of squares of all components), however we can choose <em>θ</em> such that <em>S</em>′<sub><em>ij</em></sub> = 0, in which case <em>S</em>′ has a larger sum of squares on the diagonal:</p>

<p>

<math display="block" id="Jacobi_eigenvalue_algorithm:2">
 <semantics>
  <mrow>
   <msubsup>
    <mi>S</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>θ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mstyle>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>θ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>S</mi>
        <mrow>
         <mi>i</mi>
         <mi>i</mi>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>S</mi>
        <mrow>
         <mi>j</mi>
         <mi>j</mi>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>θ</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <sin></sin>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>θ</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}_{ij}=\cos(2\theta)S_{ij}+\tfrac{1}{2}\sin(2\theta)(S_{ii}-S_{jj})
  </annotation>
 </semantics>
</math>

</p>

<p>Set this equal to 0, and rearrange:</p>

<p>

<math display="block" id="Jacobi_eigenvalue_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>tan</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mi>θ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>j</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mi>i</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <tan></tan>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>θ</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tan(2\theta)=\frac{2S_{ij}}{S_{jj}-S_{ii}}
  </annotation>
 </semantics>
</math>

</p>

<p>if 

<math display="inline" id="Jacobi_eigenvalue_algorithm:4">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>j</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>i</mi>
     <mi>i</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{jj}=S_{ii}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Jacobi_eigenvalue_algorithm:5">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>=</mo>
   <mfrac>
    <mi>π</mi>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <apply>
     <divide></divide>
     <ci>π</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=\frac{\pi}{4}
  </annotation>
 </semantics>
</math>

</p>

<p>In order to optimize this effect, <em>S</em><sub><em>ij</em></sub> should be the off-diagonal component with the largest absolute value, called the <em>pivot</em>.</p>

<p>The Jacobi eigenvalue method repeatedly <a href="Jacobi_rotation" title="wikilink">performs rotations</a> until the matrix becomes almost diagonal. Then the elements in the diagonal are approximations of the (real) eigenvalues of <em>S</em>.</p>
<h2 id="convergence">Convergence</h2>

<p>If 

<math display="inline" id="Jacobi_eigenvalue_algorithm:6">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>k</mi>
     <mi>l</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=S_{kl}
  </annotation>
 </semantics>
</math>

 is a pivot element, then by definition 

<math display="inline" id="Jacobi_eigenvalue_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>p</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S_{ij}|\leq|p|
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Jacobi_eigenvalue_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>≤</mo>
    <mi>i</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>j</mi>
     <mo>≤</mo>
     <mi>n</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>i</mi>
     <mo>≠</mo>
     <mi>j</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <leq></leq>
      <ci>j</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <neq></neq>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i,j\leq n,i\neq j
  </annotation>
 </semantics>
</math>

 . Since ''S '' has exactly 2'' N '':= ''n ''( ''n '' - 1) off-diag elements, we have 

<math display="inline" id="Jacobi_eigenvalue_algorithm:9">
 <semantics>
  <mrow>
   <msup>
    <mi>p</mi>
    <mn>2</mn>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>2</mn>
    <mi>N</mi>
    <msup>
     <mi>p</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{2}\leq\Gamma(S)^{2}\leq 2Np^{2}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Jacobi_eigenvalue_algorithm:10">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <msup>
     <mi>p</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2p^{2}\geq\Gamma(S)^{2}/N
  </annotation>
 </semantics>
</math>

 . This implies</p>

<p><code>   </code>

<math display="inline" id="Jacobi_eigenvalue_algorithm:11">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>S</mi>
       <mi>J</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mi>N</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">Γ</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <ci>J</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>N</ci>
      </apply>
     </apply>
     <ci>normal-Γ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma(S^{J})^{2}\leq(1-1/N)\Gamma(S)^{2}
  </annotation>
 </semantics>
</math>

<code>   or  </code>

<math display="inline" id="Jacobi_eigenvalue_algorithm:12">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mi>J</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mi>N</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>J</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-Γ</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma(S^{J})\leq(1-1/N)^{1/2}\Gamma(S)
  </annotation>
 </semantics>
</math>

<code>,</code></p>

<p>i.e. the sequence of Jacobi rotations converges at least linearly by a factor 

<math display="inline" id="Jacobi_eigenvalue_algorithm:13">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1-1/N)^{1/2}
  </annotation>
 </semantics>
</math>

 to a diagonal matrix.</p>

<p>A number of ''N '' Jacobi rotations is called a sweep; let 

<math display="inline" id="Jacobi_eigenvalue_algorithm:14">
 <semantics>
  <msup>
   <mi>S</mi>
   <mi>σ</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\sigma}
  </annotation>
 </semantics>
</math>

 denote the result. The previous estimate yields</p>

<p>

<math display="block" id="Jacobi_eigenvalue_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mi>σ</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mi>N</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>N</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>N</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-Γ</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma(S^{\sigma})\leq(1-1/N)^{N/2}\Gamma(S)
  </annotation>
 </semantics>
</math>

, i.e. the sequence of sweeps converges at least linearly with a factor ≈ 

<math display="inline" id="Jacobi_eigenvalue_algorithm:16">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{1/2}
  </annotation>
 </semantics>
</math>

 .</p>

<p>However the following result of <a href="Arnold_Schönhage" title="wikilink">Schönhage</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> yields locally quadratic convergence. To this end let <em>S</em> have <em>m</em> distinct eigenvalues 

<math display="inline" id="Jacobi_eigenvalue_algorithm:17">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>λ</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{1},...,\lambda_{m}
  </annotation>
 </semantics>
</math>

 with multiplicities 

<math display="inline" id="Jacobi_eigenvalue_algorithm:18">
 <semantics>
  <mrow>
   <msub>
    <mi>ν</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>ν</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ν</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ν</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu_{1},...,\nu_{m}
  </annotation>
 </semantics>
</math>

 and let <em>d</em> &gt; 0 be the smallest distance of two different eigenvalues. Let us call a number of</p>

<p>

<math display="block" id="Jacobi_eigenvalue_algorithm:19">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mi>S</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>μ</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <msub>
       <mi>ν</mi>
       <mi>μ</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>ν</mi>
         <mi>μ</mi>
        </msub>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>μ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ν</ci>
         <ci>μ</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ν</ci>
          <ci>μ</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{S}:=\frac{1}{2}n(n-1)-\sum_{\mu=1}^{m}\frac{1}{2}\nu_{\mu}(\nu_{\mu}-1)\leq
N
  </annotation>
 </semantics>
</math>

</p>

<p>Jacobi rotations a Schönhage-sweep. If 

<math display="inline" id="Jacobi_eigenvalue_algorithm:20">
 <semantics>
  <msup>
   <mi>S</mi>
   <mi>s</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{s}
  </annotation>
 </semantics>
</math>

 denotes the result then</p>

<p>

<math display="block" id="Jacobi_eigenvalue_algorithm:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>S</mi>
       <mi>s</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msqrt>
      <mrow>
       <mfrac>
        <mi>n</mi>
        <mn>2</mn>
       </mfrac>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msqrt>
     <mfrac>
      <msup>
       <mi>γ</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mi>d</mi>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mi>γ</mi>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>γ</mi>
    <mo>:=</mo>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>γ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <ci>d</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>γ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <ci>γ</ci>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma(S^{s})\leq\sqrt{\frac{n}{2}-1}\frac{\gamma^{2}}{d-2\gamma},\quad\gamma:%
=\Gamma(S)
  </annotation>
 </semantics>
</math>

 .</p>

<p>Thus convergence becomes quadratic as soon as 

<math display="inline" id="Jacobi_eigenvalue_algorithm:22">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>d</mi>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mo>+</mo>
      <msqrt>
       <mrow>
        <mfrac>
         <mi>n</mi>
         <mn>2</mn>
        </mfrac>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>d</ci>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma(S)<d/(2+\sqrt{\frac{n}{2}-1})
  </annotation>
 </semantics>
</math>

</p>
<h2 id="cost">Cost</h2>

<p>Each Jacobi rotation can be done in <em>n</em> steps when the pivot element <em>p</em> is known. However the search for <em>p</em> requires inspection of all <em>N</em> ≈ ½ <em>n</em><sup>2</sup> off-diag elements. We can reduce this to <em>n</em> steps too if we introduce an additional index array 

<math display="inline" id="Jacobi_eigenvalue_algorithm:23">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">…</mi>
   </mpadded>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1},\,\dots\,,\,m_{n-1}
  </annotation>
 </semantics>
</math>

 with the property that 

<math display="inline" id="Jacobi_eigenvalue_algorithm:24">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 is the index of the largest element in row <em>i</em>, (<em>i</em> = 1, …, <em>n</em> − 1) of the current <em>S</em>. Then (<em>k</em>, <em>l</em>) must be one of the pairs 

<math display="inline" id="Jacobi_eigenvalue_algorithm:25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,m_{i})
  </annotation>
 </semantics>
</math>

 . Since only columns <em>k</em> and <em>l</em> change, only 

<math display="inline" id="Jacobi_eigenvalue_algorithm:26">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>k</mi>
   </msub>
   <mtext>and</mtext>
   <msub>
    <mi>m</mi>
    <mi>l</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>k</ci>
    </apply>
    <mtext>and</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}\mbox{ and }m_{l}
  </annotation>
 </semantics>
</math>

 must be updated, which again can be done in <em>n</em> steps. Thus each rotation has O(<em>n</em>) cost and one sweep has O(<em>n</em><sup>3</sup>) cost which is equivalent to one matrix multiplication. Additionally the 

<math display="inline" id="Jacobi_eigenvalue_algorithm:27">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 must be initialized before the process starts, this can be done in <em>n</em><sup>2</sup> steps.</p>

<p>Typically the Jacobi method converges within numerical precision after a small number of sweeps. Note that multiple eigenvalues reduce the number of iterations since 

<math display="inline" id="Jacobi_eigenvalue_algorithm:28">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mi>S</mi>
   </msub>
   <mo><</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>S</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{S}<N
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="algorithm">Algorithm</h2>

<p>The following algorithm is a description of the Jacobi method in math-like notation. It calculates a vector <em>e</em> which contains the eigenvalues and a matrix <em>E</em> which contains the corresponding eigenvectors, i.e. 

<math display="inline" id="Jacobi_eigenvalue_algorithm:29">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}
  </annotation>
 </semantics>
</math>

 is an eigenvalue and the column 

<math display="inline" id="Jacobi_eigenvalue_algorithm:30">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}
  </annotation>
 </semantics>
</math>

 an orthonormal eigenvector for 

<math display="inline" id="Jacobi_eigenvalue_algorithm:31">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}
  </annotation>
 </semantics>
</math>

, <em>i</em> = 1, …, <em>n</em>.</p>

<p><strong><code>procedure</code></strong><code> jacobi(</code><em><code>S</code></em><code> ∈ </code><strong><code>R</code></strong><sup><em><code>n</code></em><code>×</code><em><code>n</code></em></sup><code>; </code><strong><code>out</code></strong><code> </code><em><code>e</code></em><code> ∈ </code><strong><code>R</code></strong><sup><em><code>n</code></em></sup><code>; </code><strong><code>out</code></strong><code> </code><em><code>E</code></em><code> ∈ </code><strong><code>R</code></strong><sup><em><code>n</code></em><code>×</code><em><code>n</code></em></sup><code>)</code><br/>
<code>  </code><strong><code>var</code></strong><br/>
<code>    </code><em><code>i</code></em><code>, </code><em><code>k</code></em><code>, </code><em><code>l</code></em><code>, </code><em><code>m</code></em><code>, </code><em><code>state</code></em><code> ∈ </code><strong><code>N</code></strong><br/>
<code>    </code><em><code>s</code></em><code>, </code><em><code>c</code></em><code>, </code><em><code>t</code></em><code>, </code><em><code>p</code></em><code>, </code><em><code>y</code></em><code>, </code><em><code>d</code></em><code>, </code><em><code>r</code></em><code> ∈ </code><strong><code>R</code></strong><br/>
<code>    </code><em><code>ind</code></em><code> ∈ </code><strong><code>N</code></strong><sup><em><code>n</code></em></sup><br/>
<code>    </code><em><code>changed</code></em><code> ∈ </code><strong><code>L</code></strong><sup><em><code>n</code></em></sup><br/>
<br/>
<code>  </code><strong><code>function</code></strong><code> maxind(</code><em><code>k</code></em><code> ∈ </code><strong><code>N</code></strong><code>) ∈ </code><strong><code>N</code></strong><code> ! </code><em><code>index</code> <code>of</code> <code>largest</code> <code>off-diagonal</code> <code>element</code> <code>in</code> <code>row</code> <code>k</code></em><br/>
<code>    </code><em><code>m</code></em><code> := </code><em><code>k</code></em><code>+1</code><br/>
<code>    </code><strong><code>for</code></strong><code> </code><em><code>i</code></em><code> := </code><em><code>k</code></em><code>+2 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code> </code><strong><code>do</code></strong><br/>
<code>      </code><strong><code>if</code></strong><code> │</code><em><code>S</code></em><sub><em><code>ki</code></em></sub><code>│ &gt; │</code><em><code>S</code></em><sub><em><code>km</code></em></sub><code>│ </code><strong><code>then</code></strong><code> </code><em><code>m</code></em><code> := </code><em><code>i</code></em><code> </code><strong><code>endif</code></strong><br/>
<code>    </code><strong><code>endfor</code></strong><br/>
<code>    </code><strong><code>return</code></strong><code> </code><em><code>m</code></em><br/>
<code>  </code><strong><code>endfunc</code></strong><br/>
<br/>
<code>  </code><strong><code>procedure</code></strong><code> update(</code><em><code>k</code></em><code> ∈ </code><strong><code>N</code></strong><code>; </code><em><code>t</code></em><code> ∈ </code><strong><code>R</code></strong><code>) ! </code><em><code>update</code> <code>e</code><sub><code>k</code></sub> <code>and</code> <code>its</code> <code>status</code></em><br/>
<code>    </code><em><code>y</code></em><code> := </code><em><code>e</code></em><sub><em><code>k</code></em></sub><code>; </code><em><code>e</code></em><sub><em><code>k</code></em></sub><code> := </code><em><code>y</code></em><code>+</code><em><code>t</code></em><br/>
<code>    </code><strong><code>if</code></strong><code> </code><em><code>changed</code></em><sub><em><code>k</code></em></sub><code> and (</code><em><code>y</code></em><code>=</code><em><code>e</code></em><sub><em><code>k</code></em></sub><code>) </code><strong><code>then</code></strong><code> </code><em><code>changed</code></em><sub><em><code>k</code></em></sub><code> := false; </code><em><code>state</code></em><code> := </code><em><code>state</code></em><code>−1</code><br/>
<code>    </code><strong><code>elsif</code></strong><code> (not </code><em><code>changed</code></em><sub><em><code>k</code></em></sub><code>) and (</code><em><code>y</code></em><code>≠</code><em><code>e</code></em><sub><em><code>k</code></em></sub><code>) </code><strong><code>then</code></strong><code> </code><em><code>changed</code></em><sub><em><code>k</code></em></sub><code> := true; </code><em><code>state</code></em><code> := </code><em><code>state</code></em><code>+1</code><br/>
<code>    </code><strong><code>endif</code></strong><br/>
<code>  </code><strong><code>endproc</code></strong><br/>
<br/>
<code>  </code><strong><code>procedure</code></strong><code> rotate(</code><em><code>k</code></em><code>,</code><em><code>l</code></em><code>,</code><em><code>i</code></em><code>,</code><em><code>j</code></em><code> ∈ </code><strong><code>N</code></strong><code>) ! </code><em><code>perform</code> <code>rotation</code> <code>of</code> <code>S</code><sub><code>ij</code></sub><code>,</code> <code>S</code><sub><code>kl</code></sub></em><br/>
<code>    ┌ </code><sub></sub><code>┐    ┌     ┐┌ </code><sub></sub><code>┐</code><br/>
<code>    │</code><em><code>S</code></em><sub><em><code>kl</code></em></sub><code>│    │</code><em><code>c</code></em><code>  −</code><em><code>s</code></em><code>││</code><em><code>S</code></em><sub><em><code>kl</code></em></sub><code>│</code><br/>
<code>    │ </code><sub></sub><code>│ := │     ││ </code><sub></sub><code>│</code><br/>
<code>    │</code><em><code>S</code></em><sub><em><code>ij</code></em></sub><code>│    │</code><em><code>s</code></em><code>   </code><em><code>c</code></em><code>││</code><em><code>S</code></em><sub><em><code>ij</code></em></sub><code>│</code><br/>
<code>    └ </code><sub></sub><code>┘    └     ┘└ </code><sub></sub><code>┘</code><br/>
<code>  </code><strong><code>endproc</code></strong><br/>
<br/>
<code>  ! </code><em><code>init</code> <code>e,</code> <code>E,</code> <code>and</code> <code>arrays</code> <code>ind,</code> <code>changed</code></em><br/>
<code>  </code><em><code>E</code></em><code> := </code><em><code>I</code></em><code>; </code><em><code>state</code></em><code> := </code><em><code>n</code></em><br/>
<code>  </code><strong><code>for</code></strong><code> </code><em><code>k</code></em><code> := 1 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code> </code><strong><code>do</code></strong><code> </code><em><code>ind</code></em><sub><em><code>k</code></em></sub><code> := maxind(</code><em><code>k</code></em><code>); </code><em><code>e</code></em><sub><em><code>k</code></em></sub><code> := </code><em><code>S</code></em><sub><em><code>kk</code></em></sub><code>; </code><em><code>changed</code></em><sub><em><code>k</code></em></sub><code> := true </code><strong><code>endfor</code></strong><br/>
<code>  </code><strong><code>while</code></strong><code> </code><em><code>state</code></em><code>≠0 </code><strong><code>do</code></strong><code> ! </code><em><code>next</code> <code>rotation</code></em><br/>
<code>    </code><em><code>m</code></em><code> := 1 ! </code><em><code>find</code> <code>index</code> <code>(k,l)</code> <code>of</code> <code>pivot</code> <code>p</code></em><br/>
<code>    </code><strong><code>for</code></strong><code> </code><em><code>k</code></em><code> := 2 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code>−1 </code><strong><code>do</code></strong><br/>
<code>      </code><strong><code>if</code></strong><code> │</code><em><code>S</code></em><sub><em><code>k</code></em><code> </code><em><code>ind</code></em><sub><em><code>k</code></em></sub></sub><code>│ &gt; │</code><em><code>S</code></em><sub><em><code>m</code></em><code> </code><em><code>ind</code></em><sub><em><code>m</code></em></sub></sub><code>│ </code><strong><code>then</code></strong><code> </code><em><code>m</code></em><code> := </code><em><code>k</code></em><code> </code><strong><code>endif</code></strong><br/>
<code>    </code><strong><code>endfor</code></strong><br/>
<code>    </code><em><code>k</code></em><code> := </code><em><code>m</code></em><code>; </code><em><code>l</code></em><code> := </code><em><code>ind</code></em><sub><em><code>m</code></em></sub><code>; </code><em><code>p</code></em><code> := </code><em><code>S</code></em><sub><em><code>kl</code></em></sub><br/>
<code>    ! </code><em><code>calculate</code> <code>c</code> <code>=</code> <code>cos</code> <code>φ,</code> <code>s</code> <code>=</code> <code>sin</code> <code>φ</code></em><br/>
<code>    </code><em><code>y</code></em><code> := (</code><em><code>e</code></em><sub><em><code>l</code></em></sub><code>−</code><em><code>e</code></em><sub><em><code>k</code></em></sub><code>)/2; </code><em><code>d</code></em><code> := │</code><em><code>y</code></em><code>│+√(</code><em><code>p</code></em><sup><code>2</code></sup><code>+</code><em><code>y</code></em><sup><code>2</code></sup><code>)</code><br/>
<code>    </code><em><code>r</code></em><code> := √(</code><em><code>p</code></em><sup><code>2</code></sup><code>+</code><em><code>d</code></em><sup><code>2</code></sup><code>); </code><em><code>c</code></em><code> := </code><em><code>d</code></em><code>/</code><em><code>r</code></em><code>; </code><em><code>s</code></em><code> := </code><em><code>p</code></em><code>/</code><em><code>r</code></em><code>; </code><em><code>t</code></em><code> := </code><em><code>p</code></em><sup><code>2</code></sup><code>/</code><em><code>d</code></em><br/>
<code>    </code><strong><code>if</code></strong><code> </code><em><code>y</code></em><em><code>kl</code></em><code> := 0.0; update(</code><em><code>k</code></em><code>,−</code><em><code>t</code></em><code>); update(</code><em><code>l</code></em><code>,</code><em><code>t</code></em><code>)</code><br/>
<code>    ! ''rotate rows and columns k and l</code><br/>
<code>    </code><strong><code>for</code></strong><code> </code><em><code>i</code></em><code> := 1 </code><strong><code>to</code></strong><code> </code><em><code>k</code></em><code>−1 </code><strong><code>do</code></strong><code> rotate(</code><em><code>i</code></em><code>,</code><em><code>k</code></em><code>,</code><em><code>i</code></em><code>,</code><em><code>l</code></em><code>) </code><strong><code>endfor</code></strong><br/>
<code>    </code><strong><code>for</code></strong><code> </code><em><code>i</code></em><code> := </code><em><code>k</code></em><code>+1 </code><strong><code>to</code></strong><code> </code><em><code>l</code></em><code>−1 </code><strong><code>do</code></strong><code> rotate(</code><em><code>k</code></em><code>,</code><em><code>i</code></em><code>,</code><em><code>i</code></em><code>,</code><em><code>l</code></em><code>) </code><strong><code>endfor</code></strong><br/>
<code>    </code><strong><code>for</code></strong><code> </code><em><code>i</code></em><code> := </code><em><code>l</code></em><code>+1 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code> </code><strong><code>do</code></strong><code> rotate(</code><em><code>k</code></em><code>,</code><em><code>i</code></em><code>,</code><em><code>l</code></em><code>,</code><em><code>i</code></em><code>) </code><strong><code>endfor</code></strong><br/>
<code>    ! </code><em><code>rotate</code> <code>eigenvectors</code></em><br/>
<code>    </code><strong><code>for</code></strong><code> </code><em><code>i</code></em><code> := 1 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code> </code><strong><code>do</code></strong><br/>
<code>      ┌ </code><sub></sub><code>┐    ┌     ┐┌ </code><sub></sub><code>┐</code><br/>
<code>      │</code><em><code>E</code></em><sub><em><code>ki</code></em></sub><code>│    │</code><em><code>c</code></em><code>  −</code><em><code>s</code></em><code>││</code><em><code>E</code></em><sub><em><code>ki</code></em></sub><code>│</code><br/>
<code>      │ </code><sub></sub><code>│ := │     ││ </code><sub></sub><code>│</code><br/>
<code>      │</code><em><code>E</code></em><sub><em><code>li</code></em></sub><code>│    │</code><em><code>s</code></em><code>   </code><em><code>c</code></em><code>││</code><em><code>E</code></em><sub><em><code>li</code></em></sub><code>│</code><br/>
<code>      └ </code><sub></sub><code>┘    └     ┘└ </code><sub></sub><code>┘</code><br/>
<code>    </code><strong><code>endfor</code></strong><br/>
<code>    ! </code><em><code>rows</code> <code>k,</code> <code>l</code> <code>have</code> <code>changed,</code> <code>update</code> <code>rows</code> <code>ind</code><sub><code>k</code></sub><code>,</code> <code>ind</code><sub><code>l</code></sub></em><br/>
<code>    </code><em><code>ind</code></em><sub><em><code>k</code></em></sub><code> := maxind(</code><em><code>k</code></em><code>); </code><em><code>ind</code></em><sub><em><code>l</code></em></sub><code> := maxind(</code><em><code>l</code></em><code>)</code><br/>
<code>  </code><strong><code>loop</code></strong><br/>
<strong><code>endproc</code></strong></p>
<h3 id="notes">Notes</h3>

<p>1. The logical array <em>changed</em> holds the status of each eigenvalue. If the numerical value of 

<math display="inline" id="Jacobi_eigenvalue_algorithm:32">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{k}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Jacobi_eigenvalue_algorithm:33">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{l}
  </annotation>
 </semantics>
</math>

 changes during an iteration, the corresponding component of <em>changed</em> is set to <em>true</em>, otherwise to <em>false</em>. The integer <em>state</em> counts the number of components of <em>changed</em> which have the value <em>true</em>. Iteration stops as soon as <em>state</em> = 0. This means that none of the approximations 

<math display="inline" id="Jacobi_eigenvalue_algorithm:34">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">…</mi>
   </mpadded>
   <mo>,</mo>
   <msub>
    <mi>e</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1},\,...\,,e_{n}
  </annotation>
 </semantics>
</math>

 has recently changed its value and thus it is not very likely that this will happen if iteration continues. Here it is assumed that floating point operations are optimally rounded to the nearest floating point number.</p>

<p>2. The upper triangle of the matrix <em>S</em> is destroyed while the lower triangle and the diagonal are unchanged. Thus it is possible to restore <em>S</em> if necessary according to</p>

<p><strong><code>for</code></strong><code> </code><em><code>k</code></em><code> := 1 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code>−1 </code><strong><code>do</code></strong><code> ! </code><em><code>restore</code> <code>matrix</code> <code>S</code></em><br/>
<code>  </code><strong><code>for</code></strong><code> </code><em><code>l</code></em><code> := </code><em><code>k</code></em><code>+1 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code> </code><strong><code>do</code></strong><code> </code><em><code>S</code></em><sub><em><code>kl</code></em></sub><code> := </code><em><code>S</code></em><sub><em><code>lk</code></em></sub><code> </code><strong><code>endfor</code></strong><br/>
<strong><code>endfor</code></strong></p>

<p>3. The eigenvalues are not necessarily in descending order. This can be achieved by a simple sorting algorithm.</p>

<p><strong><code>for</code></strong><code> </code><em><code>k</code></em><code> := 1 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code>−1 </code><strong><code>do</code></strong><br/>
<code>  </code><em><code>m</code></em><code> := </code><em><code>k</code></em><br/>
<code>  </code><strong><code>for</code></strong><code> </code><em><code>l</code></em><code> := </code><em><code>k</code></em><code>+1 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code> </code><strong><code>do</code></strong><br/>
<code>    </code><strong><code>if</code></strong><code> </code><em><code>e</code></em><sub><em><code>l</code></em></sub><code> &gt; </code><em><code>e</code></em><sub><em><code>m</code></em></sub><code> </code><strong><code>then</code></strong><code> </code><em><code>m</code></em><code> := </code><em><code>l</code></em><code> </code><strong><code>endif</code></strong><br/>
<code>  </code><strong><code>endfor</code></strong><br/>
<code>  </code><strong><code>if</code></strong><code> </code><em><code>k</code></em><code> ≠ </code><em><code>m</code></em><code> </code><strong><code>then</code></strong><code> swap </code><em><code>e</code></em><sub><em><code>m</code></em></sub><code>,</code><em><code>e</code></em><sub><em><code>k</code></em></sub><code>; swap </code><em><code>E</code></em><sub><em><code>m</code></em></sub><code>,</code><em><code>E</code></em><sub><em><code>k</code></em></sub><code> </code><strong><code>endif</code></strong><br/>
<strong><code>endfor</code></strong></p>

<p>4. The algorithm is written using matrix notation (1 based arrays instead of 0 based).</p>

<p>5. When implementing the algorithm, the part specified using matrix notation must be performed simultaneously.</p>

<p>6. This implementation does not correctly account for the case in which one dimension is an independent subspace. For example, if given a diagonal matrix, the above implementation will never terminate, as none of the eigenvalues will change. Hence, in real implementations, extra logic must be added to account for this case.</p>
<h3 id="example">Example</h3>

<p>Let 

<math display="inline" id="Jacobi_eigenvalue_algorithm:35">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>4</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>30</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>60</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>35</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>30</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>300</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>675</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>420</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>60</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>675</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>1620</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1050</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>35</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>420</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1050</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>700</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">4</cn>
      <apply>
       <minus></minus>
       <cn type="integer">30</cn>
      </apply>
      <cn type="integer">60</cn>
      <apply>
       <minus></minus>
       <cn type="integer">35</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">30</cn>
      </apply>
      <cn type="integer">300</cn>
      <apply>
       <minus></minus>
       <cn type="integer">675</cn>
      </apply>
      <cn type="integer">420</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">60</cn>
      <apply>
       <minus></minus>
       <cn type="integer">675</cn>
      </apply>
      <cn type="integer">1620</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1050</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">35</cn>
      </apply>
      <cn type="integer">420</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1050</cn>
      </apply>
      <cn type="integer">700</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\begin{pmatrix}4&-30&60&-35\\
-30&300&-675&420\\
60&-675&1620&-1050\\
-35&420&-1050&700\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Then <em>jacobi</em> produces the following eigenvalues and eigenvectors after 3 sweeps (19 iterations) :</p>

<p>

<math display="inline" id="Jacobi_eigenvalue_algorithm:36">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>2585.25381092892231</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="float">2585.25381092892231</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}=2585.25381092892231
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Jacobi_eigenvalue_algorithm:37">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>0.0291933231647860588</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>0.328712055763188997</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0.791411145833126331</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>0.514552749997152907</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">1</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="float">0.0291933231647860588</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="float">0.328712055763188997</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="float">0.791411145833126331</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="float">0.514552749997152907</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{1}=\begin{pmatrix}0.0291933231647860588\\
-0.328712055763188997\\
0.791411145833126331\\
-0.514552749997152907\end{pmatrix}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Jacobi_eigenvalue_algorithm:38">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>37.1014913651276582</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="float">37.1014913651276582</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}=37.1014913651276582
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Jacobi_eigenvalue_algorithm:39">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>0.179186290535454826</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0.741917790628453435</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>0.100228136947192199</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>0.638282528193614892</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">2</cn>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="float">0.179186290535454826</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="float">0.741917790628453435</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="float">0.100228136947192199</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="float">0.638282528193614892</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{2}=\begin{pmatrix}-0.179186290535454826\\
0.741917790628453435\\
-0.100228136947192199\\
-0.638282528193614892\end{pmatrix}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Jacobi_eigenvalue_algorithm:40">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mn>1.4780548447781369</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">3</cn>
    </apply>
    <cn type="float">1.4780548447781369</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{3}=1.4780548447781369
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Jacobi_eigenvalue_algorithm:41">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>0.582075699497237650</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0.370502185067093058</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0.509578634501799626</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0.514048272222164294</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">3</cn>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="float">0.582075699497237650</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="float">0.370502185067093058</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0.509578634501799626</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0.514048272222164294</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{3}=\begin{pmatrix}-0.582075699497237650\\
0.370502185067093058\\
0.509578634501799626\\
0.514048272222164294\end{pmatrix}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Jacobi_eigenvalue_algorithm:42">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mn>0.1666428611718905</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">4</cn>
    </apply>
    <cn type="float">0.1666428611718905</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{4}=0.1666428611718905
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Jacobi_eigenvalue_algorithm:43">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>0.792608291163763585</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0.451923120901599794</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0.322416398581824992</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0.252161169688241933</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <cn type="integer">4</cn>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="float">0.792608291163763585</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0.451923120901599794</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0.322416398581824992</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0.252161169688241933</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{4}=\begin{pmatrix}0.792608291163763585\\
0.451923120901599794\\
0.322416398581824992\\
0.252161169688241933\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="applications-for-real-symmetric-matrices">Applications for real symmetric matrices</h2>

<p>When the eigenvalues (and eigenvectors) of a symmetric matrix are known, the following values are easily calculated.</p>
<dl>
<dt>Singular values</dt>
<dd>The singular values of a (square) matrix <em>A</em> are the square roots of the (non-negative) eigenvalues of 

<math display="inline" id="Jacobi_eigenvalue_algorithm:44">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mi>T</mi>
   </msup>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{T}A
  </annotation>
 </semantics>
</math>

. In case of a symmetric matrix <em>S</em> we have of 

<math display="inline" id="Jacobi_eigenvalue_algorithm:45">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>S</mi>
     <mi>T</mi>
    </msup>
    <mi>S</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>S</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>T</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{T}S=S^{2}
  </annotation>
 </semantics>
</math>

, hence the singular values of <em>S</em> are the absolute values of the eigenvalues of <em>S</em>
</dd>
</dl>
<dl>
<dt>2-norm and spectral radius</dt>
<dd>The 2-norm of a matrix <em>A</em> is the norm based on the Euclidean vectornorm, i.e. the largest value 

<math display="inline" id="Jacobi_eigenvalue_algorithm:46">
 <semantics>
  <msub>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|Ax\|_{2}
  </annotation>
 </semantics>
</math>

 when x runs through all vectors with 

<math display="inline" id="Jacobi_eigenvalue_algorithm:47">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>∥</mo>
     <mi>x</mi>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x\|_{2}=1
  </annotation>
 </semantics>
</math>

. It is the largest singular value of <em>A</em>. In case of a symmetric matrix it is largest absolute value of its eigenvectors and thus equal to its spectral radius.
</dd>
</dl>
<dl>
<dt>Condition number</dt>
<dd>The condition number of a nonsingular matrix <em>A</em> is defined as 

<math display="inline" id="Jacobi_eigenvalue_algorithm:48">
 <semantics>
  <mrow>
   <mrow>
    <mtext>cond</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mi>A</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msub>
    <msub>
     <mrow>
      <mo>∥</mo>
      <msup>
       <mi>A</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>cond</mtext>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>A</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{cond}(A)=\|A\|_{2}\|A^{-1}\|_{2}
  </annotation>
 </semantics>
</math>

. In case of a symmetric matrix it is the absolute value of the quotient of the largest and smallest eigenvalue. Matrices with large condition numbers can cause numerically unstable results: small perturbation can result in large errors. <a href="Hilbert_matrix" title="wikilink">Hilbert matrices</a> are the most famous ill-conditioned matrices. For example, the fourth-order Hilbert matrix has a condition of 15514, while for order 8 it is 2.7 × 10<sup>8</sup>.
</dd>
</dl>
<dl>
<dt>Rank</dt>
<dd>A matrix <em>A</em> has rank <em>r</em> if it has <em>r</em> columns that are linearly independent while the remaining columns are linearly dependent on these. Equivalently, <em>r</em> is the dimension of the range of <em>A</em>. Furthermore it is the number of nonzero singular values.
</dd>
<dd>In case of a symmetric matrix r is the number of nonzero eigenvalues. Unfortunately because of rounding errors numerical approximations of zero eigenvalues may not be zero (it may also happen that a numerical approximation is zero while the true value is not). Thus one can only calculate the <em>numerical</em> rank by making a decision which of the eigenvalues are close enough to zero.
</dd>
</dl>
<dl>
<dt>Pseudo-inverse</dt>
<dd>The pseudo inverse of a matrix <em>A</em> is the unique matrix 

<math display="inline" id="Jacobi_eigenvalue_algorithm:49">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <msup>
    <mi>A</mi>
    <mo>+</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=A^{+}
  </annotation>
 </semantics>
</math>

 for which <em>AX</em> and <em>XA</em> are symmetric and for which <em>AXA = A, XAX = X</em> holds. If <em>A</em> is nonsingular, then '

<math display="inline" id="Jacobi_eigenvalue_algorithm:50">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mo>+</mo>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>A</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <plus></plus>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{+}=A^{-1}
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>When procedure jacobi (S, e, E) is called, then the relation 

<math display="inline" id="Jacobi_eigenvalue_algorithm:51">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>E</mi>
     <mi>T</mi>
    </msup>
    <mtext>Diag</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <ci>T</ci>
     </apply>
     <mtext>Diag</mtext>
     <ci>e</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=E^{T}\mbox{Diag}(e)E
  </annotation>
 </semantics>
</math>

 holds where Diag(<em>e</em>) denotes the diagonal matrix with vector <em>e</em> on the diagonal. Let 

<math display="inline" id="Jacobi_eigenvalue_algorithm:52">
 <semantics>
  <msup>
   <mi>e</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{+}
  </annotation>
 </semantics>
</math>

 denote the vector where 

<math display="inline" id="Jacobi_eigenvalue_algorithm:53">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Jacobi_eigenvalue_algorithm:54">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msub>
    <mi>e</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/e_{i}
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Jacobi_eigenvalue_algorithm:55">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mi>i</mi>
   </msub>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}\leq 0
  </annotation>
 </semantics>
</math>

 and by 0 if 

<math display="inline" id="Jacobi_eigenvalue_algorithm:56">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}
  </annotation>
 </semantics>
</math>

 is (numerically close to) zero. Since matrix <em>E</em> is orthogonal, it follows that the pseudo-inverse of S is given by 

<math display="inline" id="Jacobi_eigenvalue_algorithm:57">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>+</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>E</mi>
     <mi>T</mi>
    </msup>
    <mtext>Diag</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>e</mi>
      <mo>+</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <plus></plus>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <ci>T</ci>
     </apply>
     <mtext>Diag</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <plus></plus>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{+}=E^{T}\mbox{Diag}(e^{+})E
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dt>Least squares solution</dt>
<dd>If matrix <em>A</em> does not have full rank, there may not be a solution of the linear system <em>Ax = b</em>. However one can look for a vector x for which 

<math display="inline" id="Jacobi_eigenvalue_algorithm:58">
 <semantics>
  <msub>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mi>x</mi>
     </mrow>
     <mo>-</mo>
     <mi>b</mi>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|Ax-b\|_{2}
  </annotation>
 </semantics>
</math>

 is minimal. The solution is 

<math display="inline" id="Jacobi_eigenvalue_algorithm:59">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mo>+</mo>
    </msup>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <plus></plus>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=A^{+}b
  </annotation>
 </semantics>
</math>

. In case of a symmetric matrix <em>S</em> as before, one has 

<math display="inline" id="Jacobi_eigenvalue_algorithm:60">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>S</mi>
     <mo>+</mo>
    </msup>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>E</mi>
     <mi>T</mi>
    </msup>
    <mtext>Diag</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>e</mi>
      <mo>+</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <plus></plus>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <ci>T</ci>
      </apply>
      <mtext>Diag</mtext>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <plus></plus>
      </apply>
      <ci>E</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=S^{+}b=E^{T}\mbox{Diag}(e^{+})Eb
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dt>Matrix exponential</dt>
<dd>From 

<math display="inline" id="Jacobi_eigenvalue_algorithm:61">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>E</mi>
     <mi>T</mi>
    </msup>
    <mtext>Diag</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <ci>T</ci>
     </apply>
     <mtext>Diag</mtext>
     <ci>e</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=E^{T}\mbox{Diag}(e)E
  </annotation>
 </semantics>
</math>

 one finds 

<math display="inline" id="Jacobi_eigenvalue_algorithm:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>exp</mi>
    <mi>S</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>E</mi>
     <mi>T</mi>
    </msup>
    <mtext>Diag</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>exp</mi>
      <mi>e</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <exp></exp>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <ci>T</ci>
     </apply>
     <mtext>Diag</mtext>
     <apply>
      <exp></exp>
      <ci>e</ci>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp S=E^{T}\mbox{Diag}(\exp e)E
  </annotation>
 </semantics>
</math>

 where exp <em>e</em> is the vector where 

<math display="inline" id="Jacobi_eigenvalue_algorithm:63">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Jacobi_eigenvalue_algorithm:64">
 <semantics>
  <mrow>
   <mi>exp</mi>
   <msub>
    <mi>e</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exp></exp>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp e_{i}
  </annotation>
 </semantics>
</math>

. In the same way, <em>f</em>(<em>S</em>) can be calculated in an obvious way for any (analytic) function <em>f</em>.
</dd>
</dl>
<dl>
<dt>Linear differential equations</dt>
<dd>The differential equation <em>x' </em> = <em>Ax</em>, <em>x</em>(0) = <em>a</em> has the solution <em>x</em>(<em>t</em>) = exp(<em>t A</em>) <em>a</em>. For a symmetric matrix <em>S</em>, it follows that 

<math display="inline" id="Jacobi_eigenvalue_algorithm:65">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>E</mi>
     <mi>T</mi>
    </msup>
    <mtext>Diag</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mi>t</mi>
       <mi>e</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>E</mi>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <ci>T</ci>
     </apply>
     <mtext>Diag</mtext>
     <apply>
      <exp></exp>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>e</ci>
      </apply>
     </apply>
     <ci>E</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=E^{T}\mbox{Diag}(\exp te)Ea
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Jacobi_eigenvalue_algorithm:66">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>E</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=\sum_{i=1}^{n}a_{i}E_{i}
  </annotation>
 </semantics>
</math>

 is the expansion of <em>a</em> by the eigenvectors of <em>S</em>, then 

<math display="inline" id="Jacobi_eigenvalue_algorithm:67">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <msub>
         <mi>e</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msub>
      <mi>E</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <exp></exp>
       <apply>
        <times></times>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=\sum_{i=1}^{n}a_{i}\exp(te_{i})E_{i}
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>Let 

<math display="inline" id="Jacobi_eigenvalue_algorithm:68">
 <semantics>
  <msup>
   <mi>W</mi>
   <mi>s</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>W</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{s}
  </annotation>
 </semantics>
</math>

 be the vector space spanned by the eigenvectors of <em>S</em> which correspond to a negative eigenvalue and 

<math display="inline" id="Jacobi_eigenvalue_algorithm:69">
 <semantics>
  <msup>
   <mi>W</mi>
   <mi>u</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>W</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{u}
  </annotation>
 </semantics>
</math>

 analogously for the positive eigenvalues. If 

<math display="inline" id="Jacobi_eigenvalue_algorithm:70">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <msup>
    <mi>W</mi>
    <mi>s</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in W^{s}
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Jacobi_eigenvalue_algorithm:71">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mtext>lim</mtext>
     <mrow>
      <mpadded width="+5pt">
       <mi>t</mi>
      </mpadded>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>lim</mtext>
      <apply>
       <times></times>
       <ci>t</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{lim}_{t\ \infty}x(t)=0
  </annotation>
 </semantics>
</math>

 i.e. the equilibrium point 0 is attractive to <em>x</em>(<em>t</em>). If 

<math display="inline" id="Jacobi_eigenvalue_algorithm:72">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <msup>
    <mi>W</mi>
    <mi>u</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in W^{u}
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Jacobi_eigenvalue_algorithm:73">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mtext>lim</mtext>
     <mrow>
      <mpadded width="+5pt">
       <mi>t</mi>
      </mpadded>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>lim</mtext>
      <apply>
       <times></times>
       <ci>t</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{lim}_{t\ \infty}x(t)=\infty
  </annotation>
 </semantics>
</math>

, i.e. 0 is repulsive to <em>x</em>(<em>t</em>). 

<math display="inline" id="Jacobi_eigenvalue_algorithm:74">
 <semantics>
  <msup>
   <mi>W</mi>
   <mi>s</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>W</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{s}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Jacobi_eigenvalue_algorithm:75">
 <semantics>
  <msup>
   <mi>W</mi>
   <mi>u</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>W</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{u}
  </annotation>
 </semantics>
</math>

 are called <em>stable</em> and <em>unstable</em> manifolds for <em>S</em>. If <em>a</em> has components in both manifolds, then one component is attracted and one component is repelled. Hence <em>x</em>(<em>t</em>) approaches 

<math display="inline" id="Jacobi_eigenvalue_algorithm:76">
 <semantics>
  <msup>
   <mi>W</mi>
   <mi>u</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>W</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{u}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Jacobi_eigenvalue_algorithm:77">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>t</mi>
   </mpadded>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\ \infty
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<h2 id="generalizations">Generalizations</h2>

<p>The Jacobi Method has been generalized to <a href="Jacobi_method_for_complex_Hermitian_matrices" title="wikilink">complex Hermitian matrices</a>, general nonsymmetric real and complex matrices as well as block matrices.</p>

<p>Since singular values of a real matrix are the square roots of the eigenvalues of the symmetric matrix 

<math display="inline" id="Jacobi_eigenvalue_algorithm:78">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>T</mi>
    </msup>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>T</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=A^{T}A
  </annotation>
 </semantics>
</math>

 it can also be used for the calculation of these values. For this case, the method is modified in such a way that <em>S</em> must not be explicitly calculated which reduces the danger of <a href="round-off_error" title="wikilink">round-off errors</a>. Note that 

<math display="inline" id="Jacobi_eigenvalue_algorithm:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mi>S</mi>
    <msup>
     <mi>J</mi>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>J</mi>
    <msup>
     <mi>A</mi>
     <mi>T</mi>
    </msup>
    <mi>A</mi>
    <msup>
     <mi>J</mi>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>J</mi>
    <msup>
     <mi>A</mi>
     <mi>T</mi>
    </msup>
    <msup>
     <mi>J</mi>
     <mi>T</mi>
    </msup>
    <mi>J</mi>
    <mi>A</mi>
    <msup>
     <mi>J</mi>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>B</mi>
     <mi>T</mi>
    </msup>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>J</ci>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>J</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>J</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>T</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>J</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>J</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>J</ci>
       <ci>T</ci>
      </apply>
      <ci>J</ci>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>J</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>T</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   JSJ^{T}=JA^{T}AJ^{T}=JA^{T}J^{T}JAJ^{T}=B^{T}B
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Jacobi_eigenvalue_algorithm:80">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>B</mi>
   </mpadded>
   <mo>:=</mo>
   <mrow>
    <mi>J</mi>
    <mi>A</mi>
    <msup>
     <mi>J</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>J</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\,:=JAJ^{T}
  </annotation>
 </semantics>
</math>

 .</p>

<p>The Jacobi Method is also well suited for parallelism.</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://math.fullerton.edu/mathews/n2003/JacobiMethodMod.html">Jacobi Iteration for Eigenvectors</a></li>
<li><a href="http://groups.google.com/group/sci.math.num-analysis/msg/8282d0d412f72d2e">Matlab implementation of Jacobi algorithm that avoids trigonometric functions</a></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
