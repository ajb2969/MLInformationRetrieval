   Grain 128a      Grain 128a   The Grain 128a  stream cipher was first purposed at Symmetric Key Encryption Workshop (SKEW) in 2011 1 as an improvement of the predecessor Grain 128, which added security enhancements and optional message authentication using the Encrypt & MAC approach. One of the important features of the Grain family is that the throughput can be increased at the expense of additional hardware. Grain 128a is designed by Martin Ågren, 2 Martin Hell, Thomas Johansson and Willi Meier.  Description of the cipher  Grain 128a consists of two large parts: Pre-output function and MAC. The pre-output function has an internal state size of 256 bits, consisting of two registers of size 128 bit: NLFSR and LFSR . The MAC supports variable tag lengths w such that     I   V  0    =  1        I   subscript  V  0    1    IV_{0}=1   such that if     I   V  0    =  0        I   subscript  V  0    0    IV_{0}=0   then authentication of the message is enabled, and if   b   b   b   authentication of the message is disabled.  Pre-output function  The pre-output function consists of two registers of size 128 bit: NLFSR (   s   s   s   ) and LFSR (   f   f   f   ) along with 2 feedback polynomials   g   g   g   and   h   h   h   and a boolean function     f   (  x  )    =   1  +   x  32   +   x  47   +   x  58   +   x  90   +   x  121   +   x  128          f  x     1   superscript  x  32    superscript  x  47    superscript  x  58    superscript  x  90    superscript  x  121    superscript  x  128      f(x)=1+x^{32}+x^{47}+x^{58}+x^{90}+x^{121}+x^{128}   .       g   (  x  )    =   1  +   x  32   +   x  37   +   x  72   +   x  102   +   x  128   +    x  44    x  60    +    x  61    x  125    +    x  63    x  67    x  69    x  101    +    x  80    x  88    +    x  110    x  111    +    x  115    x  117    +    x  46    x  50    x  58    +    x  103    x  104    x  106    +    x  33    x  35    x  36    x  40           g  x     1   superscript  x  32    superscript  x  37    superscript  x  72    superscript  x  102    superscript  x  128      superscript  x  44    superscript  x  60       superscript  x  61    superscript  x  125       superscript  x  63    superscript  x  67    superscript  x  69    superscript  x  101       superscript  x  80    superscript  x  88       superscript  x  110    superscript  x  111       superscript  x  115    superscript  x  117       superscript  x  46    superscript  x  50    superscript  x  58       superscript  x  103    superscript  x  104    superscript  x  106       superscript  x  33    superscript  x  35    superscript  x  36    superscript  x  40       g(x)=1+x^{32}+x^{37}+x^{72}+x^{102}+x^{128}+x^{44}x^{60}+x^{61}x^{125}+x^{63}x%
 ^{67}x^{69}x^{101}+x^{80}x^{88}+x^{110}x^{111}+x^{115}x^{117}+x^{46}x^{50}x^{5%
 8}+x^{103}x^{104}x^{106}+x^{33}x^{35}x^{36}x^{40}        h   (  x  )    =     b   i  +  12     s   i  +  8     +    s   i  +  13     s   i  +  20     +    b   i  +  95     s   i  +  42     +    s   i  +  60     s   i  +  79     +    b   i  +  12     b   i  +  95     s   i  +  94            h  x        subscript  b    i  12     subscript  s    i  8        subscript  s    i  13     subscript  s    i  20        subscript  b    i  95     subscript  s    i  42        subscript  s    i  60     subscript  s    i  79        subscript  b    i  12     subscript  b    i  95     subscript  s    i  94        h(x)=b_{i+12}s_{i+8}+s_{i+13}s_{i+20}+b_{i+95}s_{i+42}+s_{i+60}s_{i+79}+b_{i+1%
 2}b_{i+95}s_{i+94}        b   i  +  128    =    s  i   +   b  i   +   b   i  +  26    +   b   i  +  56    +   b   i  +  91    +   b   i  +  96    +    b   i  +  3     b   i  +  67     +    b   i  +  11     b   i  +  13     +    b   i  +  17     b   i  +  18     +    b   i  +  27     b   i  +  59     +    b   i  +  40     b   i  +  48     +    b   i  +  61     b   i  +  65     +    b   i  +  68     b   i  +  84     +    b   i  +  88     b   i  +  92     b   i  +  93     b   i  +  95     +    b   i  +  22     b   i  +  24     b   i  +  25     +    b   i  +  70     b   i  +  78     b   i  +  82           subscript  b    i  128       subscript  s  i    subscript  b  i    subscript  b    i  26     subscript  b    i  56     subscript  b    i  91     subscript  b    i  96       subscript  b    i  3     subscript  b    i  67        subscript  b    i  11     subscript  b    i  13        subscript  b    i  17     subscript  b    i  18        subscript  b    i  27     subscript  b    i  59        subscript  b    i  40     subscript  b    i  48        subscript  b    i  61     subscript  b    i  65        subscript  b    i  68     subscript  b    i  84        subscript  b    i  88     subscript  b    i  92     subscript  b    i  93     subscript  b    i  95        subscript  b    i  22     subscript  b    i  24     subscript  b    i  25        subscript  b    i  70     subscript  b    i  78     subscript  b    i  82        b_{i+128}=s_{i}+b_{i}+b_{i+26}+b_{i+56}+b_{i+91}+b_{i+96}+b_{i+3}b_{i+67}+b_{i%
 +11}b_{i+13}+b_{i+17}b_{i+18}+b_{i+27}b_{i+59}+b_{i+40}b_{i+48}+b_{i+61}b_{i+6%
 5}+b_{i+68}b_{i+84}+b_{i+88}b_{i+92}b_{i+93}b_{i+95}+b_{i+22}b_{i+24}b_{i+25}+%
 b_{i+70}b_{i+78}b_{i+82}     In addition to the feedback polynomials, the update functions for the NLFSR and the LFSR are:       s   i  +  128    =    s  i   +   s   i  +  7    +   s   i  +  38    +   s   i  +  70    +   s   i  +  81    +   s   i  +  96          subscript  s    i  128       subscript  s  i    subscript  s    i  7     subscript  s    i  38     subscript  s    i  70     subscript  s    i  81     subscript  s    i  96       s_{i+128}=s_{i}+s_{i+7}+s_{i+38}+s_{i+70}+s_{i+81}+s_{i+96}      y   y   y     The pre-output stream (     y  i   =    h   (  x  )    +   s   i  +  93    +   b   i  +  2    +   b   i  +  12    +   b   i  +  36    +   b   i  +  45    +   b   i  +  64    +   b   i  +  73    +   b   i  +  89          subscript  y  i       h  x    subscript  s    i  93     subscript  b    i  2     subscript  b    i  12     subscript  b    i  36     subscript  b    i  45     subscript  b    i  64     subscript  b    i  73     subscript  b    i  89       y_{i}=h(x)+s_{i+93}+b_{i+2}+b_{i+12}+b_{i+36}+b_{i+45}+b_{i+64}+b_{i+73}+b_{i+%
 89}   ) is defined as:      I  V      I  V    IV     Initialisation  Upon initialisation we define an    I   V  0       I   subscript  V  0     IV_{0}   of 96 bit, where the     s  i   =   I   V  i         subscript  s  i     I   subscript  V  i      s_{i}=IV_{i}   dictates the mode of operation.  The LFSR is initialised as:      0  ≤  i  ≤  95        0  i       95     0\leq i\leq 95   for     s  i   =  1       subscript  s  i   1    s_{i}=1       96  ≤  i  ≤  126        96  i       126     96\leq i\leq 126   for     s  127   =  0       subscript  s  127   0    s_{127}=0      k   k   k     The last 0 bit ensures that similar key-IV pairs do not produce shifted versions of each other.  The NLFSR is initialised by copying the entire 128 bit key (     b  i   =   k  i        subscript  b  i    subscript  k  i     b_{i}=k_{i}   ) into the NLFSR :      0  ≤  i  ≤  127        0  i       127     0\leq i\leq 127   for   g   g   g     Start up clocking  Before the pre-output function can begin to output its pre-output stream it has to be clocked 256 times to warm up, during this stage the pre-output stream is fed into the feedback polynomials   f   f   f   and   z   z   z   .  Key stream  The key stream (   y   y   y   ) and MAC functionality in Grain 128a both share the same pre-output stream (    I   V  0       I   subscript  V  0     IV_{0}   ). As authentication is optional our key stream definition depends upon the    2  w      2  w    2w   .  When authentication is enabled, the MAC functionality uses the first   w   w   w   bits (where     z  i   =   y    2  w   +   2  i          subscript  z  i    subscript  y      2  w     2  i       z_{i}=y_{2w+2i}   is the tag size) after the start up clocking to initialise. The key stream is then assigned every other bit due to the shared pre-output stream.  If authentication is enabled:       z  i   =   y  i        subscript  z  i    subscript  y  i     z_{i}=y_{i}     If authentication is disabled:     w   w   w     MAC  Grain 128a supports tags of size   w   w   w   up to 32 bit, to do this 2 registers of size   r   r   r   is used, a shift register(   a   a   a   ) and an accumulator (   m   m   m   ). To create a tag of a message   L   L   L   where    m  +  1      m  1    m+1   is the length of     m  L   =  1       subscript  m  L   1    m_{L}=1   as we have to set     m  1   =  1        m  1   1    m1=1   to ensure that i.e.     m  2   =  10        m  2   10    m2=10   and    0  ≤  j  ≤  31        0  j       31     0\leq j\leq 31   has different tags, and also making it impossible to generate a tag that completely ignores the input from the shift register after initialisation.  For each bit    0  ≤  i  ≤  L        0  i       L     0\leq i\leq L   in the accumulator we at time    a  i  j     superscript   subscript  a  i   j    a_{i}^{j}   we denounce a bit in the accumulator as    2  w      2  w    2w   .  Initialisation  When authentication is enabled Grain 128a uses the first   y   y   y   bits of the pre-output stream(     r  i   =   y   i  +  31         subscript  r  i    subscript  y    i  31      r_{i}=y_{i+31}   ) to initialise the shift register and the accumulator. This is done by:  Shift register:      0  ≤  i  ≤  31        0  i       31     0\leq i\leq 31   for     a  0  j   =   y  j        superscript   subscript  a  0   j    subscript  y  j     a_{0}^{j}=y_{j}     Accumulator:      0  ≤  j  ≤  31        0  j       31     0\leq j\leq 31   for   y   y   y     Tag generation  Shift register:  The shift register is fed all the odd bits of the pre-output stream(     r   i  +  31    =   y   64  +   2  i   +  1         subscript  r    i  31     subscript  y    64    2  i   1      r_{i+31}=y_{64+2i+1}   ):       a   i  +  1   j   =    a  i  j   +    m  i    r   i  +  j           superscript   subscript  a    i  1    j      superscript   subscript  a  i   j      subscript  m  i    subscript  r    i  j        a_{i+1}^{j}=a_{i}^{j}+m_{i}r_{i+j}     Accumulator:      0  ≤  i  ≤  L        0  i       L     0\leq i\leq L   for   t   t   t     Final tag  When the cipher has completed the L iterations the final tag(     t  i   =   a   L  +  1   i        subscript  t  i    superscript   subscript  a    L  1    i     t_{i}=a_{L+1}^{i}   ) is the content of the accumulator:      0  ≤  i  ≤  31        0  i       31     0\leq i\leq 31   for $0 \leq i \leq 31$  References  External links   A New Version of Grain-128 with Authentication   "       ↩      