<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="234">Resource bounded measure</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Resource bounded measure</h1>
<hr/>

<p><strong>Lutz's resource bounded measure</strong> is a generalisation of <a href="Lebesgue_measure" title="wikilink">Lebesgue measure</a> to <a href="complexity_class" title="wikilink">complexity classes</a>. It was originally developed by <a href="Jack_Lutz" title="wikilink">Jack Lutz</a>. Just as Lebesgue measure gives a method to quantify the size of subsets of the <a href="Euclidean_space" title="wikilink">Euclidean space</a> 

<math display="inline" id="Resource_bounded_measure:0">
 <semantics>
  <msup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <mtext>\R</mtext>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \R^{n}
  </annotation>
 </semantics>
</math>

, resource bounded measure gives a method to classify the size of subsets of complexity classes.</p>

<p>For instance, computer scientists generally believe that the complexity class <a class="uri" href="P" title="wikilink">P</a> (the set of all <a href="decision_problem" title="wikilink">decision problems</a> solvable in <a href="polynomial_time" title="wikilink">polynomial time</a>) is not equal to the complexity class <a href="NP_(complexity)" title="wikilink">NP</a> (the set of all decision problems checkable, but not necessarily solvable, in polynomial time). Since P is a <a class="uri" href="subset" title="wikilink">subset</a> of NP, this would mean that NP contains more problems than P. A stronger hypothesis than "<a href="P_is_not_NP" title="wikilink">P is not NP</a>" is the statement "NP does not have p-measure 0". Here, p-measure is a generalization of Lebesgue measure to subsets of the complexity class <a href="E_(complexity)" title="wikilink">E</a>, in which P is contained. P is known to have p-measure 0, and so the hypothesis "NP does not have p-measure 0" would imply not only that NP and P are unequal, but that NP is, in a <a href="measure_theory" title="wikilink">measure-theoretic</a> sense, "much bigger than P".</p>
<h2 id="definition">Definition</h2>

<p>

<math display="inline" id="Resource_bounded_measure:1">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
   <mi mathvariant="normal">∞</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1\}^{\infty}
  </annotation>
 </semantics>
</math>

 is the set of all <a href="Infinite_set" title="wikilink">infinite</a>, <a href="binary_numeral_system" title="wikilink">binary</a> <a href="Sequence#Infinite_sequences_in_theoretical_computer_science" title="wikilink">sequences</a>. We can view a <a href="real_number" title="wikilink">real number</a> in the <a href="unit_interval" title="wikilink">unit interval</a> as an infinite binary sequence, by considering its <a href="Binary_numeral_system#Representing_real_numbers" title="wikilink">binary expansion</a>. We may also view a <a href="formal_language" title="wikilink">language</a> (a set of binary <a href="String_(computer_science)" title="wikilink">strings</a>) as an infinite binary sequence, by setting the <em>n</em>th <a class="uri" href="bit" title="wikilink">bit</a> of the sequence to 1 if and only if the <em>n</em>th binary string (in <a href="lexicographical_order" title="wikilink">lexicographical order</a>) is contained in the language. Thus, sets of real numbers in the unit interval and complexity classes (which are sets of languages) may both be viewed as sets of infinite binary sequences, and thus the techniques of <a href="measure_theory" title="wikilink">measure theory</a> used to measure the size of sets of real numbers may be applied to measure complexity classes. However, since each computable complexity class contains only a <a class="uri" href="countable" title="wikilink">countable</a> number of elements(because the number of computable languages is countable), each complexity class has <a href="Lebesgue_measure" title="wikilink">Lebesgue measure</a> 0. Thus, to do measure theory inside of complexity classes, we must define an alternative <a href="Measure_(mathematics)" title="wikilink">measure</a> that works meaningfully on countable sets of infinite sequences. For this measure to be meaningful, it should reflect something about the underlying definition of each complexity class; namely, that they are defined by <a href="computational_problem" title="wikilink">computational problems</a> that can be solved within a given resource bound.</p>

<p>The foundation of resource-bounded measure is Ville's formulation of <a href="Martingale_(probability_theory)" title="wikilink">martingales</a>. A <strong>martingale</strong> is a function 

<math display="inline" id="Resource_bounded_measure:2">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>*</mo>
    </msup>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">∞</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>d</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <times></times>
     </apply>
     <interval closure="closed-open">
      <cn type="integer">0</cn>
      <infinity></infinity>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d:\{0,1\}^{*}\to[0,\infty)
  </annotation>
 </semantics>
</math>

 such that, for all finite strings <em>w</em>,</p>

<p>

<math display="block" id="Resource_bounded_measure:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>w</mi>
        <mn>0</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>w</mi>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>w</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(w)=\frac{d(w0)+d(w1)}{2}
  </annotation>
 </semantics>
</math>

. (This is Ville's original definition of a martingale, later extended by <a href="Joseph_Leo_Doob" title="wikilink">Joseph Leo Doob</a>.) A martingale <em>d</em> is said to <strong>succeed</strong> on a sequence 

<math display="inline" id="Resource_bounded_measure:4">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in\{0,1\}^{\infty}
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Resource_bounded_measure:5">
 <semantics>
  <mrow>
   <msub>
    <mo>lim sup</mo>
    <mrow>
     <mi>n</mi>
     <mo>→</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </msub>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>↾</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">limit-supremum</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>n</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-↾</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <infinity></infinity>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \limsup_{n\to\infty}d(S\upharpoonright n)=\infty,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Resource_bounded_measure:6">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>↾</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↾</ci>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\upharpoonright n
  </annotation>
 </semantics>
</math>

 is the first <em>n</em> bits of <em>S</em>. A martingale <strong>succeeds</strong> on a set of sequences 

<math display="inline" id="Resource_bounded_measure:7">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq\{0,1\}^{\infty}
  </annotation>
 </semantics>
</math>

 if it succeeds on every sequence in <em>X</em>.</p>

<p>Intuitively, a martingale is a gambler that starts with some finite amount of money (say, one dollar). It reads a sequence of bits indefinitely. After reading the finite prefix 

<math display="inline" id="Resource_bounded_measure:8">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\{0,1\}^{*}
  </annotation>
 </semantics>
</math>

, it bets some of its current money that the next bit will be a 0, and the remainder of its money that the next bit will be a 1. It doubles whatever money was placed on the bit that appears next, and it loses the money placed on the bit that did not appear. It must bet all of its money, but it may "bet nothing" by placing half of its money on each bit. For a martingale <em>d</em>, <em>d</em>(<em>w</em>) represents the amount of money <em>d</em> has after reading the string <em>w</em>. Although the definition of a martingale has the martingale calculating how much money it will have, rather than calculating what bets to place, because of the constrained nature of the game, knowledge the values <em>d</em>(<em>w</em>), <em>d</em>(<em>w</em>0), and <em>d</em>(<em>w</em>1) suffices to calculate the bets that <em>d</em> placed on 0 and 1 after seeing the string <em>w</em>. The fact that the martingale is a function that takes as input the string seen so far means that the bets placed are solely a function of the bits already read; no other information may affect the bets (other information being the so-called <em>filtration</em> in the <a href="Martingale_(probability_theory)" title="wikilink">generalized theory of martingales</a>).</p>

<p>The key result relating measure to martingales is Ville's observation that a set 

<math display="inline" id="Resource_bounded_measure:9">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq\{0,1\}^{\infty}
  </annotation>
 </semantics>
</math>

 has Lebesgue measure 0 if and only if there is martingale that succeeds on <em>X</em>. Thus, we can define a measure 0 set to be one for which there exists a martingale that succeeds on all elements of the set.</p>

<p>To extend this type of measure to complexity classes, Lutz considered restricting the computational power of the martingale. For instance, if instead of allowing any martingale, we require the martingale to be <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a> computable, then we obtain a definition of p-measure: a set of sequences has p-measure 0 if there is a <em>polynomial-time computable</em> martingale that succeeds on the set. We define a set to have p-measure 1 if its complement has p-measure 0. For example, proving the above-mentioned conjecture, that NP does not have p-measure 0, amounts to proving that no polynomial-time martingale succeeds on all of NP.</p>
<h2 id="almost-complete">Almost complete</h2>

<p>A problem is <strong>almost complete</strong> for a <a href="complexity_class" title="wikilink">complexity class</a> C if it is in C and "many" other problems in C reduce to it. More specifically, the subset of problems of C which reduce to the problem is a measure one set, in terms of the resource bounded measure. This is a weaker requirement than the problem being <a href="complete_(complexity)" title="wikilink">complete</a> for the class.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.uwyo.edu/~jhitchco/bib/rbm.shtml">Resource-Bounded Measure Bibliography</a></li>
</ul>

<p>"</p>

<p><a href="Category:Structural_complexity_theory" title="wikilink">Category:Structural complexity theory</a> <a href="Category:Measures_(measure_theory)" title="wikilink">Category:Measures (measure theory)</a></p>
</body>
</html>
