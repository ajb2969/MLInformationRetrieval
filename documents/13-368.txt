   Simulation algorithms for atomic DEVS      Simulation algorithms for atomic DEVS   Given an atomic DEVS model, simulation algorithms are methods to generate the model's legal behaviors which are trajectories not to reach to illegal states. (see Behavior of DEVS ). [Zeigler84 ] originally introduced the algorithms that handle time variables related to lifespan      t  s   ∈   [  0  ,  ∞  ]        subscript  t  s    0      t_{s}\in[0,\infty]   and elapsed time      t  e   ∈   [  0  ,  ∞  )        subscript  t  e    0      t_{e}\in[0,\infty)   by introducing two other time variables, last event time ,     t  l   ∈   [  0  ,  ∞  )        subscript  t  l    0      t_{l}\in[0,\infty)   , and next event time      t  n   ∈   [  0  ,  ∞  ]        subscript  t  n    0      t_{n}\in[0,\infty]   with the following relations:         t   e   =   t  -   t  l         subscript  t  e     t   subscript  t  l      \,t_{e}=t-t_{l}      and         t   s   =    t  n   -   t  l         subscript  t  s      subscript  t  n    subscript  t  l      \,t_{s}=t_{n}-t_{l}      where    t  ∈   [  0  ,  ∞  )       t   0      t\in[0,\infty)   denotes the current time . And the remaining time ,         t   r   =    t  s   -   t  e         subscript  t  r      subscript  t  s    subscript  t  e      \,t_{r}=t_{s}-t_{e}      is equivalently computed as         t   r   =    t  n   -  t        subscript  t  r      subscript  t  n   t     \,t_{r}=t_{n}-t      , apparently     t  r   ∈   [  0  ,  ∞  ]        subscript  t  r    0      t_{r}\in[0,\infty]   .  Since the behavior of a given atomic DEVS model can be defined in two different views depending on the total state and the external transition function (refer to Behavior of DEVS ), the simulation algorithms are also introduced in two different views as below.  Common parts  Regardless of two different views of total states, algorithms for initialization and internal transition cases are commonly defined as below.  DEVS-simulator  variables:  parent // parent coordinator       t  l     subscript  t  l    t_{l}    // time of last event       t  n     subscript  t  n    t_{n}    // time of next event       A  =   (  X  ,  Y  ,  S  ,   t  a   ,   δ   e  x  t    ,   δ   i  n  t    ,  λ  )       A   X  Y  S    t  a    subscript  δ    e  x  t     subscript  δ    i  n  t    λ     A=(X,Y,S,ta,\delta_{ext},\delta_{int},\lambda)    // the associated Atomic  DEVS model  when receive init-message(Time    t   t   t    )         t  l   ←  t   ;     normal-←   subscript  t  l   t    t_{l}\leftarrow t;           t  n   ←    t  l   +   t  a   (  s  )      ;     normal-←   subscript  t  n      subscript  t  l     t  a  s      t_{n}\leftarrow t_{l}+ta(s);     when receive star-message(Time    t   t   t    )  if     t  ≠   t  n       t   subscript  t  n     t\neq t_{n}    then  error: bad synchronization;        y  ←   λ   (  s  )     ;     normal-←  y    λ  s     y\leftarrow\lambda(s);     send y-message(     y  ,  t     y  t    y,t    ) to parent;       s  ←    δ   i  n  t     (  s  )       normal-←  s     subscript  δ    i  n  t    s     s\leftarrow\delta_{int}(s)           t  l   ←  t   ;     normal-←   subscript  t  l   t    t_{l}\leftarrow t;         t  n   ←    t  l   +   t  a   (  s  )      ;     normal-←   subscript  t  n      subscript  t  l     t  a  s      t_{n}\leftarrow t_{l}+ta(s);     == View 1: total states = states * elapsed times == As addressed in Behavior of Atomic DEVS , when DEVS receives an input event, right calling    δ   e  x  t      subscript  δ    e  x  t     \delta_{ext}   , the last event time,    t  l     subscript  t  l    t_{l}   is set by the current time,   t   t   t   , thus the elapsed time    t  e     subscript  t  e    t_{e}   becomes zero because     t  e   =   t  -   t  l         subscript  t  e     t   subscript  t  l      t_{e}=t-t_{l}   .  when receive x-message(     x  ∈  X      x  X    x\in X    , Time    t   t   t    )  if     (   t  l   ≤  t     fragments  normal-(   subscript  t  l    t    (t_{l}\leq t    and     t  ≤   t  n   )     fragments  t    subscript  t  n   normal-)    t\leq t_{n})    == false then  error: bad synchronization;       s  ←    δ   e  x  t     (  s  ,   t  -   t  l    ,  x  )       normal-←  s     subscript  δ    e  x  t     s    t   subscript  t  l    x      s\leftarrow\delta_{ext}(s,t-t_{l},x)           t  l   ←  t   ;     normal-←   subscript  t  l   t    t_{l}\leftarrow t;         t  n   ←    t  l   +   t  a   (  s  )      ;     normal-←   subscript  t  n      subscript  t  l     t  a  s      t_{n}\leftarrow t_{l}+ta(s);     ==View 2: total states = states * lifespans * elapsed times== Notice that as addressed in Behavior of Atomic DEVS , depending on the value of   b   b   b   return by    δ   e  x  t      subscript  δ    e  x  t     \delta_{ext}   , last event time,    t  l     subscript  t  l    t_{l}   , and next event time,    t  n     subscript  t  n    t_{n}   ,consequently, elapsed time,    t  e     subscript  t  e    t_{e}   , and lifespan    t  n     subscript  t  n    t_{n}   , are updated (if    b  =  1      b  1    b=1   ) or preserved (if    b  =  0      b  0    b=0   ).  when receive x-message(     x  ∈  X      x  X    x\in X    , Time    t   t   t    )  if     (   t  l   ≤  t     fragments  normal-(   subscript  t  l    t    (t_{l}\leq t    and     t  ≤   t  n   )     fragments  t    subscript  t  n   normal-)    t\leq t_{n})    == false then  error: bad synchronization;        (  s  ,  b  )   ←    δ   e  x  t     (  s  ,   t  -   t  l    ,  x  )       normal-←   s  b      subscript  δ    e  x  t     s    t   subscript  t  l    x      (s,b)\leftarrow\delta_{ext}(s,t-t_{l},x)     if     b  =  1      b  1    b=1    then         t  l   ←  t   ;     normal-←   subscript  t  l   t    t_{l}\leftarrow t;           t  n   ←    t  l   +   t  a   (  s  )      ;     normal-←   subscript  t  n      subscript  t  l     t  a  s      t_{n}\leftarrow t_{l}+ta(s);     See also   Atomic DEVS  Behavior of atomic DEVS  Simulation algorithms for coupled DEVS   References   [Zeigler84]  [ZKP00]   "  Category:Algorithms   