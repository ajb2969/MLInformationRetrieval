<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1329">Ellipsoid method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ellipsoid method</h1>
<hr/>

<p> In <a href="mathematical_optimization" title="wikilink">mathematical optimization</a>, the <strong>ellipsoid method</strong> is an <a href="iterative_method" title="wikilink">iterative method</a> for <a href="convex_optimization" title="wikilink">minimizing</a> <a href="convex_function" title="wikilink">convex functions</a>. When specialized to solving feasible <a href="linear_optimization" title="wikilink">linear optimization</a> problems with rational data, the ellipsoid method is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> which finds an optimal solution in a finite number of steps.</p>

<p>The ellipsoid method generates a sequence of <a href="ellipsoid" title="wikilink">ellipsoids</a> whose volume uniformly decreases at every step, thus enclosing a minimizer of a <a href="convex_function" title="wikilink">convex function</a>.</p>
<h2 id="history">History</h2>

<p>The ellipsoid method has a long history. As an <a href="iterative_method" title="wikilink">iterative method</a>, a preliminary version was introduced by <a href="Naum_Z._Shor" title="wikilink">Naum Z. Shor</a>. In 1972, an <a href="approximation_algorithm" title="wikilink">approximation algorithm</a> for real <a href="convex_optimization" title="wikilink">convex minimization</a> was studied by <a href="Arkadi_Nemirovski" title="wikilink">Arkadi Nemirovski</a> and David B. Yudin (Judin). As an algorithm for solving <a href="linear_programming" title="wikilink">linear programming</a> problems with rational data, the ellipsoid algorithm was studied by <a href="Leonid_Khachiyan" title="wikilink">Leonid Khachiyan</a>: Khachiyan's achievement was to prove the <a href="Polynomial_time" title="wikilink">polynomial-time</a> solvability of linear programs.</p>

<p>Following Khachiyan's work, the ellipsoid method was the only algorithm for solving linear programs whose runtime had been proved to be polynomial until <a href="Karmarkar's_algorithm" title="wikilink">Karmarkar's algorithm</a>. However, the <a href="interior-point_method" title="wikilink">interior-point method</a> and variants of the <a href="simplex_algorithm" title="wikilink">simplex algorithm</a> are much faster than the ellipsoid method in practice. Karmarkar's algorithm is also faster in the worst case.</p>

<p>However, the ellipsoidal algorithm allows <a href="computational_complexity_theory" title="wikilink">complexity theorists</a> to achieve (worst-case) bounds that depend on the dimension of the problem and on the size of the data, but not on the number of rows, so it remained important in <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a> theory for many decades.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Only in the 21st century have interior-point algorithms with similar complexity properties appeared.</p>
<h2 id="description">Description</h2>

<p>A convex minimization problem consists of a <a href="convex_function" title="wikilink">convex function</a> 

<math display="inline" id="Ellipsoid_method:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0}(x):\mathbb{R}^{n}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 to be minimized over the variable 

<math display="inline" id="Ellipsoid_method:1">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, convex inequality constraints of the form 

<math display="inline" id="Ellipsoid_method:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(x)\leq 0
  </annotation>
 </semantics>
</math>

, where the functions 

<math display="inline" id="Ellipsoid_method:3">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f_{i}
  </annotation>
 </semantics>
</math>

 are convex, and linear equality constraints of the form 

<math display="inline" id="Ellipsoid_method:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="5pt" width="+5pt">
      <mi>h</mi>
     </mpadded>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ h_{i}(x)=0
  </annotation>
 </semantics>
</math>

. We are also given an initial <a class="uri" href="ellipsoid" title="wikilink">ellipsoid</a> 

<math display="inline" id="Ellipsoid_method:5">
 <semantics>
  <mrow>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>⊂</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℰ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}^{(0)}\subset\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 defined as</p>

<p>

<math display="block" id="Ellipsoid_method:6">
 <semantics>
  <mrow>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>z</mi>
     <mo>∈</mo>
     <msup>
      <mi>ℝ</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>z</mi>
         <mo>-</mo>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
      <msubsup>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>z</mi>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≤</mo>
     <mn>1</mn>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℰ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>z</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>z</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}^{(0)}=\left\{z\in\mathbb{R}^{n}:(z-x_{0})^{T}P_{(0)}^{-1}(z-x_{0})%
\leq 1\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>containing a minimizer 

<math display="inline" id="Ellipsoid_method:7">
 <semantics>
  <msup>
   <mpadded lspace="5pt" width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ x^{*}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Ellipsoid_method:8">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>≻</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">succeeds</csymbol>
    <ci>P</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\succ 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ellipsoid_method:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 is the center of 

<math display="inline" id="Ellipsoid_method:10">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℰ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℰ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}
  </annotation>
 </semantics>
</math>

. Finally, we require the existence of a <a class="uri" href="cutting-plane" title="wikilink">cutting-plane</a> oracle for the function 

<math display="inline" id="Ellipsoid_method:11">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. One example of a cutting-plane is given by a <a class="uri" href="subgradient" title="wikilink">subgradient</a> 

<math display="inline" id="Ellipsoid_method:12">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Ellipsoid_method:13">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="unconstrained-minimization">Unconstrained minimization</h2>

<p>At the 

<math display="inline" id="Ellipsoid_method:14">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-th iteration of the algorithm, we have a point 

<math display="inline" id="Ellipsoid_method:15">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(k)}
  </annotation>
 </semantics>
</math>

 at the center of an ellipsoid 

<math display="inline" id="Ellipsoid_method:16">
 <semantics>
  <mrow>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <msup>
      <mi>ℝ</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <msup>
          <mi>x</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>k</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msup>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
      <msubsup>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <msup>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>k</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≤</mo>
     <mn>1</mn>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℰ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}^{(k)}=\left\{x\in\mathbb{R}^{n}:(x-x^{(k)})^{T}P_{(k)}^{-1}(x-x^{(%
k)})\leq 1\right\}
  </annotation>
 </semantics>
</math>

. We query the cutting-plane oracle to obtain a vector 

<math display="inline" id="Ellipsoid_method:17">
 <semantics>
  <mrow>
   <msup>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{(k+1)}\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Ellipsoid_method:18">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{(k+1)T}(x^{*}-x^{(k)})\leq 0
  </annotation>
 </semantics>
</math>

. We therefore conclude that</p>

<p>

<math display="block" id="Ellipsoid_method:19">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
    <mo>∈</mo>
    <mrow>
     <msup>
      <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo>∩</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>z</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>g</mi>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>T</mi>
         </mrow>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>z</mi>
          <mo>-</mo>
          <msup>
           <mi>x</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>k</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </msup>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>≤</mo>
       <mn>0</mn>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℰ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>z</ci>
      <apply>
       <leq></leq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>g</ci>
         <apply>
          <times></times>
          <apply>
           <plus></plus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>T</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>z</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}\in\mathcal{E}^{(k)}\cap\{z:g^{(k+1)T}(z-x^{(k)})\leq 0\}.
  </annotation>
 </semantics>
</math>

</p>

<p>We set 

<math display="inline" id="Ellipsoid_method:20">
 <semantics>
  <msup>
   <mi class="ltx_font_mathcaligraphic">ℰ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℰ</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}^{(k+1)}
  </annotation>
 </semantics>
</math>

 to be the ellipsoid of minimal volume containing the half-ellipsoid described above and compute 

<math display="inline" id="Ellipsoid_method:21">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(k+1)}
  </annotation>
 </semantics>
</math>

. The update is given by</p>

<p>

<math display="block" id="Ellipsoid_method:22">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
     <msub>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <msup>
      <mover accent="true">
       <mi>g</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>g</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(k+1)}=x^{(k)}-\frac{1}{n+1}P_{(k)}\tilde{g}^{(k+1)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ellipsoid_method:23">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <msup>
       <mi>n</mi>
       <mn>2</mn>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <mo>-</mo>
      <mrow>
       <mfrac>
        <mn>2</mn>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mfrac>
       <msub>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <msup>
        <mover accent="true">
         <mi>g</mi>
         <mo stretchy="false">~</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>k</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
       <msup>
        <mover accent="true">
         <mi>g</mi>
         <mo stretchy="false">~</mo>
        </mover>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>k</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>T</mi>
        </mrow>
       </msup>
       <msub>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-~</ci>
         <ci>g</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-~</ci>
         <ci>g</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{(k+1)}=\frac{n^{2}}{n^{2}-1}\left(P_{(k)}-\frac{2}{n+1}P_{(k)}\tilde{g}^{(k%
+1)}\tilde{g}^{(k+1)T}P_{(k)}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Ellipsoid_method:24">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <msqrt>
       <mrow>
        <msup>
         <mi>g</mi>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>T</mi>
         </mrow>
        </msup>
        <mi>P</mi>
        <msup>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>k</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
       </mrow>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>g</ci>
         <apply>
          <times></times>
          <apply>
           <plus></plus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>T</ci>
         </apply>
        </apply>
        <ci>P</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>g</ci>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{g}^{(k+1)}=(1/\sqrt{g^{(k+1)T}Pg^{(k+1)}})g^{(k+1)}
  </annotation>
 </semantics>
</math>

. The stopping criterion is given by the property that</p>

<p>

<math display="inline" id="Ellipsoid_method:25">
 <semantics>
  <mrow>
   <mrow>
    <msqrt>
     <mrow>
      <msup>
       <mi>g</mi>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>T</mi>
       </mrow>
      </msup>
      <msub>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <msup>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
     </mrow>
    </msqrt>
    <mo>≤</mo>
    <mi>ϵ</mi>
    <mo>⇒</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>*</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{g^{(k)T}P_{(k)}g^{(k)}}\leq\epsilon\Rightarrow f(x^{(k)})-f(x^{*})\leq\epsilon.
  </annotation>
 </semantics>
</math>

</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Sample sequence of iterates</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>

<math display="inline" id="Ellipsoid_method:26">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0
  </annotation>
 </semantics>
</math>

</figcaption>
</figure></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>

<math display="inline" id="Ellipsoid_method:27">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=3
  </annotation>
 </semantics>
</math>

</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h2 id="inequality-constrained-minimization">Inequality-constrained minimization</h2>

<p>At the 

<math display="inline" id="Ellipsoid_method:28">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-th iteration of the algorithm for constrained minimization, we have a point 

<math display="inline" id="Ellipsoid_method:29">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(k)}
  </annotation>
 </semantics>
</math>

 at the center of an ellipsoid 

<math display="inline" id="Ellipsoid_method:30">
 <semantics>
  <msup>
   <mi class="ltx_font_mathcaligraphic">ℰ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℰ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}^{(k)}
  </annotation>
 </semantics>
</math>

 as before. We also must maintain a list of values 

<math display="inline" id="Ellipsoid_method:31">
 <semantics>
  <msubsup>
   <mi>f</mi>
   <mi>best</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>best</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{\rm{best}}^{(k)}
  </annotation>
 </semantics>
</math>

 recording the smallest objective value of feasible iterates so far. Depending on whether or not the point 

<math display="inline" id="Ellipsoid_method:32">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(k)}
  </annotation>
 </semantics>
</math>

 is feasible, we perform one of two tasks:</p>
<ul>
<li>If 

<math display="inline" id="Ellipsoid_method:33">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(k)}
  </annotation>
 </semantics>
</math>

 is feasible, perform essentially the same update as in the unconstrained case, by choosing a subgradient 

<math display="inline" id="Ellipsoid_method:34">
 <semantics>
  <msub>
   <mi>g</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{0}
  </annotation>
 </semantics>
</math>

 that satisfies</li>
</ul>

<p>

<math display="block" id="Ellipsoid_method:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msubsup>
       <mi>g</mi>
       <mn>0</mn>
       <mi>T</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>x</mi>
         <mo>*</mo>
        </msup>
        <mo>-</mo>
        <msup>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>k</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <msubsup>
     <mi>f</mi>
     <mi>best</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
   </mrow>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>best</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{0}^{T}(x^{*}-x^{(k)})+f_{0}(x^{(k)})-f_{\rm{best}}^{(k)}\leq 0
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>If 

<math display="inline" id="Ellipsoid_method:36">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(k)}
  </annotation>
 </semantics>
</math>

 is infeasible and violates the 

<math display="inline" id="Ellipsoid_method:37">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

-th constraint, update the ellipsoid with a feasibility cut. Our feasibility cut may be a subgradient 

<math display="inline" id="Ellipsoid_method:38">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{j}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Ellipsoid_method:39">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}
  </annotation>
 </semantics>
</math>

 which must satisfy</li>
</ul>

<p>

<math display="block" id="Ellipsoid_method:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>g</mi>
      <mi>j</mi>
      <mi>T</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <msup>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>j</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{j}^{T}(z-x^{(k)})+f_{j}(x^{(k)})\leq 0
  </annotation>
 </semantics>
</math>

</p>

<p>for all feasible 

<math display="inline" id="Ellipsoid_method:41">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="application-to-linear-programming">Application to linear programming</h3>

<p>Inequality-constrained minimization of a function that is zero everywhere corresponds to the problem of simply identifying any feasible point. It turns out that any linear programming problem can be reduced to a linear feasibility problem (e.g. minimize the zero function subject to some linear inequality and equality constraints). One way to do this is by combining the primal and dual linear programs together into one program, and adding the additional (linear) constraint that the value of the primal solution is <a href="weak_duality" title="wikilink">no worse than</a> the value of the dual solution. Another way is to treat the objective of the linear program as an additional constraint, and use binary search to find the optimum value.</p>
<h2 id="performance">Performance</h2>

<p>The ellipsoid method is used on low-dimensional problems, such as planar location problems, where it is <a href="numerically_stable" title="wikilink">numerically stable</a>. On even "small"-sized problems, it suffers from numerical instability and poor performance in practice.</p>

<p>However, the ellipsoid method is an important theoretical technique in <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a>. In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the ellipsoid algorithm is attractive because its complexity depends on the number of columns and the digital size of the coefficients, but not on the number of rows. In the 21st century, interior-point algorithms with similar properties have appeared .</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Dmitris Alevras and Manfred W. Padberg, <em>Linear Optimization and Extensions: Problems and Extensions</em>, Universitext, Springer-Verlag, 2001. (Problems from Padberg with solutions.)</li>
<li>V. Chandru and M.R.Rao, Linear Programming, Chapter 31 in <em>Algorithms and Theory of Computation Handbook</em>, edited by M.J.Atallah, CRC Press 1999, 31-1 to 31-37.</li>
<li>V. Chandru and M.R.Rao, Integer Programming, Chapter 32 in '' Algorithms and Theory of Computation Handbook'', edited by M.J.Atallah, CRC Press 1999, 32-1 to 32-45.</li>
<li><a href="George_B._Dantzig" title="wikilink">George B. Dantzig</a> and Mukund N. Thapa. 1997. <em>Linear programming 1: Introduction</em>. Springer-Verlag.</li>
<li><a href="George_B._Dantzig" title="wikilink">George B. Dantzig</a> and Mukund N. Thapa. 2003. <em>Linear Programming 2: Theory and Extensions</em>. Springer-Verlag.</li>
<li>M. Grötschel, <a href="László_Lovász" title="wikilink">L. Lovász</a>, <a href="Alexander_Schrijver" title="wikilink">A. Schrijver</a>: <em>Geometric Algorithms and Combinatorial Optimization</em>, Springer, 1988</li>
</ul>
<ul>
<li><a href="László_Lovász" title="wikilink">L. Lovász</a>: <em>An Algorithmic Theory of Numbers, Graphs, and Convexity</em>, CBMS-NSF Regional Conference Series in Applied Mathematics 50, SIAM, Philadelphia, Pennsylvania, 1986</li>
<li>Kattta G. Murty, <em>Linear Programming</em>, Wiley, 1983.</li>
<li>M. Padberg, <em>Linear Optimization and Extensions</em>, Second Edition, Springer-Verlag, 1999.</li>
<li><a href="Christos_H._Papadimitriou" title="wikilink">Christos H. Papadimitriou</a> and Kenneth Steiglitz, <em>Combinatorial Optimization: Algorithms and Complexity</em>, Corrected republication with a new preface, Dover.</li>
<li><a href="Alexander_Schrijver" title="wikilink">Alexander Schrijver</a>, <em>Theory of Linear and Integer Programming</em>. John Wiley &amp; sons, 1998, ISBN 0-471-98232-6</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.stanford.edu/class/ee364b/">EE364b</a>, a Stanford course homepage</li>
</ul>

<p>"</p>

<p><a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Convex_optimization" title="wikilink">Category:Convex optimization</a> <a href="Category:Linear_programming" title="wikilink">Category:Linear programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. Grötschel, <a href="László_Lovász" title="wikilink">L. Lovász</a>, <a href="Alexander_Schrijver" title="wikilink">A. Schrijver</a>: <em>Geometric Algorithms and Combinatorial Optimization</em>, Springer, 1988.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Lovasz" title="wikilink">L. Lovász</a>: <em>An Algorithmic Theory of Numbers, Graphs, and Convexity</em>, CBMS-NSF Regional Conference Series in Applied Mathematics 50, SIAM, Philadelphia, Pennsylvania, 1986.<a href="#fnref2">↩</a></li>
<li id="fn3">V. Chandru and M.R.Rao, Linear Programming, Chapter 31 in <em>Algorithms and Theory of Computation Handbook</em>, edited by <a href="Mikhail_Atallah" title="wikilink">M. J. Atallah</a>, CRC Press 1999, 31-1 to 31-37.<a href="#fnref3">↩</a></li>
<li id="fn4">V. Chandru and M.R.Rao, Integer Programming, Chapter 32 in '' Algorithms and Theory of Computation Handbook'', edited by M.J.Atallah, CRC Press 1999, 32-1 to 32-45.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
