   Calculus of constructions      Calculus of constructions   The Calculus of Constructions ( CoC ) is a type theory created by Thierry Coquand . It can serve as both a typed programming language and as constructive  foundation for mathematics . For this second reason, the CoC and its variants have been the basis for Coq and other proof assistants .  Some of its variants include the calculus of inductive constructions (which adds inductive types ), the calculus of (co)inductive constructions (which adds coinduction ), and the predicative calculus of inductive constructions (which removes some impredicativity ).  General traits  The CoC is a higher-order typed lambda calculus , initially developed by Thierry Coquand . It is well known for being at the top of Barendregt 's lambda cube . It is possible within CoC to define functions from, say, integers to types, types to types as well as functions from integers to integers.  The CoC is strongly normalizing , although, by Gödel's incompleteness theorem , it is impossible to prove this property within the CoC since it implies inconsistency.  Usage  The CoC has developed alongside the Coq  proof assistant . As features were added (or possible liabilities removed) to the theory, they became available in Coq.  Variants of the CoC are used in other proof assistants, such as Matita .  The basics of the calculus of constructions  The Calculus of Constructions can be considered an extension of the Curry–Howard isomorphism . The Curry–Howard isomorphism associates a term in the simply typed lambda calculus with each natural-deduction proof in intuitionistic propositional logic . The Calculus of Constructions extends this isomorphism to proofs in the full intuitionistic predicate calculus, which includes proofs of quantified statements (which we will also call "propositions").  Terms  A term in the calculus of constructions is constructed using the following rules:   T is a term (also called Type )  P is a term (also called Prop , the type of all propositions)  Variables ( x , y , ...) are terms  If   A   A   A   and   B   B   B   are terms, then so are      (    A   B   )      A  B    (A~{}B)         (  λ  x  :  A  .  B  )     fragments  normal-(  λ  x  normal-:  A  normal-.  B  normal-)    (\mathbf{\lambda}x:A.B)         (  ∀  x  :  A  .  B  )     fragments  normal-(  for-all  x  normal-:  A  normal-.  B  normal-)    (\forall x:A.B)       The calculus of constructions has five kinds of objects:   proofs , which are terms whose types are propositions  propositions , which are also known as small types  predicates , which are functions that return propositions  large types , which are the types of predicates. ( P is an example of a large type)  T itself, which is the type of large types.   Judgments  The calculus of constructions allows proving typing judgments :       x  1   :    A  1   ,   x  2    :    A  2   ,  …   ⊢  t  :  B       normal-:   subscript  x  1     subscript  A  1    subscript  x  2      normal-:      subscript  A  2   normal-…     proves    t    normal-:    B     x_{1}:A_{1},x_{2}:A_{2},\ldots\vdash t:B     Which can be read as the implication   If variables     x  1   ,   x  2   ,  …      subscript  x  1    subscript  x  2   normal-…    x_{1},x_{2},\ldots   have types     A  1   ,   A  2   ,  …      subscript  A  1    subscript  A  2   normal-…    A_{1},A_{2},\ldots   , then term   t   t   t   has type   B   B   B   .   The valid judgments for the calculus of constructions are derivable from a set of inference rules. In the following, we use   Γ   normal-Γ   \Gamma   to mean a sequence of type assignments     x  1   :    A  1   ,   x  2    :    A  2   ,  …        normal-:   subscript  x  1     subscript  A  1    subscript  x  2      normal-:      subscript  A  2   normal-…      x_{1}:A_{1},x_{2}:A_{2},\ldots   , and we use K to mean either P or T . We shall write    A  :  B  :  C       normal-:  A  B    normal-:    C     A:B:C   to mean "   A   A   A   has type   B   B   B   , and   B   B   B   has type   C   C   C   ". We shall write    B   (  x  :=  N  )      fragments  B   fragments  normal-(  x  assign  N  normal-)     B(x:=N)   to mean the result of substituting the term   N   N   N   for the variable   x   x   x   in the term   B   B   B   .  An inference rule is written in the form       Γ  ⊢  A  :  B     Γ  ′   ⊢  C  :  D          proves  normal-Γ  A    normal-:    B       proves   superscript  normal-Γ  normal-′   C    normal-:    D      {\Gamma\vdash A:B}\over{\Gamma^{\prime}\vdash C:D}     which means   If    Γ  ⊢  A  :  B       proves  normal-Γ  A    normal-:    B     \Gamma\vdash A:B   is a valid judgment, then so is     Γ  ′   ⊢  C  :  D       proves   superscript  normal-Γ  normal-′   C    normal-:    D     \Gamma^{\prime}\vdash C:D      Inference rules for the calculus of constructions  1 .      Γ  ⊢  P  :  T       absent     proves  normal-Γ  P    normal-:    T      {{}\over{}\Gamma\vdash P:T}     2 .     Γ  ⊢  A  :  K     Γ  ,  x   :  A  ⊢  x  :  A          proves  normal-Γ  A    normal-:    K       normal-:   normal-Γ  x   A    proves    x    normal-:    A      {\Gamma\vdash A:K\over{\Gamma,x:A\vdash x:A}}     3 .      Γ  ,  x   :  A  ⊢  t  :  B  :  K    Γ  ⊢   (  λ  x  :  A  .  t  )   :   (  ∀  x  :  A  .  B  )   :  K          normal-:   normal-Γ  x   A    proves    t    normal-:    B    normal-:    K     fragments  Γ  proves   fragments  normal-(  λ  x  normal-:  A  normal-.  t  normal-)   normal-:   fragments  normal-(  for-all  x  normal-:  A  normal-.  B  normal-)   normal-:  K     {\Gamma,x:A\vdash t:B:K\over{\Gamma\vdash(\lambda x:A.t):(\forall x:A.B):K}}     4 .     Γ  ⊢  M  :   (  ∀  x  :  A  .  B  )   Γ  ⊢  N  :  A    Γ  ⊢  M  N  :  B   (  x  :=  N  )         fragments  Γ  proves  M  normal-:   fragments  normal-(  for-all  x  normal-:  A  normal-.  B  normal-)   italic-  Γ  proves  N  normal-:  A    fragments  Γ  proves  M  N  normal-:  B   fragments  normal-(  x  assign  N  normal-)      {\Gamma\vdash M:(\forall x:A.B)\qquad\qquad\Gamma\vdash N:A\over{\Gamma\vdash
 MN%
 :B(x:=N)}}     5 .     Γ  ⊢  M  :  A  A   =  β   B  B  :  K    Γ  ⊢  M  :  B        fragments  Γ  proves  M  normal-:  A  italic-  A   subscript   β   B  italic-  B  normal-:  K      proves  normal-Γ  M    normal-:    B      {\Gamma\vdash M:A\qquad\qquad A=_{\beta}B\qquad\qquad B:K\over{\Gamma\vdash M:%
 B}}     Defining logical operators  The calculus of constructions has very few basic operators: the only logical operator for forming propositions is   ∀   for-all   \forall   . However, this one operator is sufficient to define all the other logical operators:         A  ⇒  B     ≡     ∀  x  :  A  .  B      (   x  ∉  B   )        A  ∧  B     ≡     ∀  C  :  P  .   (  A  ⇒  B  ⇒  C  )   ⇒  C           A  ∨  B     ≡     ∀  C  :  P  .   (  A  ⇒  C  )   ⇒   (  B  ⇒  C  )   ⇒  C           ¬  A     ≡     ∀  C  :  P  .   (  A  ⇒  C  )            ∃  x  :  A  .  B     ≡     ∀  C  :  P  .   (  ∀  x  :  A  .   (  B  ⇒  C  )   )   ⇒  C             normal-⇒  A  B     fragments  for-all  x  normal-:  A  normal-.  B     x  B       A  B     fragments  for-all  C  normal-:  P  normal-.   fragments  normal-(  A  normal-⇒  B  normal-⇒  C  normal-)   normal-⇒  C   absent      A  B     fragments  for-all  C  normal-:  P  normal-.   fragments  normal-(  A  normal-⇒  C  normal-)   normal-⇒   fragments  normal-(  B  normal-⇒  C  normal-)   normal-⇒  C   absent       A     fragments  for-all  C  normal-:  P  normal-.   fragments  normal-(  A  normal-⇒  C  normal-)    absent     fragments   x  normal-:  A  normal-.  B     fragments  for-all  C  normal-:  P  normal-.   fragments  normal-(  for-all  x  normal-:  A  normal-.   fragments  normal-(  B  normal-⇒  C  normal-)   normal-)   normal-⇒  C   absent     \begin{matrix}A\Rightarrow B&\equiv&\forall x:A.B&(x\notin B)\\
 A\wedge B&\equiv&\forall C:P.(A\Rightarrow B\Rightarrow C)\Rightarrow C&\\
 A\vee B&\equiv&\forall C:P.(A\Rightarrow C)\Rightarrow(B\Rightarrow C)%
 \Rightarrow C&\\
 \neg A&\equiv&\forall C:P.(A\Rightarrow C)&\\
 \exists x:A.B&\equiv&\forall C:P.(\forall x:A.(B\Rightarrow C))\Rightarrow C&%
 \end{matrix}     Defining data types  The basic data types used in computer science can be defined within the Calculus of Constructions:   Booleans    ∀  A  :  P  .  A  ⇒  A  ⇒  A     fragments  for-all  A  normal-:  P  normal-.  A  normal-⇒  A  normal-⇒  A    \forall A:P.A\Rightarrow A\Rightarrow A    Naturals : \forall A:P .   (A \Rightarrow A) \Rightarrow (A \Rightarrow A)   Product    A  ×  B      A  B    A\times B       A  ∧  B      A  B    A\wedge B    Disjoint union    A  +  B      A  B    A+B       A  ∨  B      A  B    A\vee B      Note that Booleans and Naturals are defined in the same way as in Church encoding . However additional problems raise from propositional extensionality and proof irrelevance 1 .  See also   Lambda calculus  Typed lambda calculus  Lambda cube  System F  Curry–Howard isomorphism  Intuitionistic logic  Intuitionistic type theory  Homotopy type theory   Theorists   Coquand, Thierry  Girard, Jean-Yves   References    Also available freely accessible online:  Note terminology is rather different. For instance, (    ∀  x  :  A  .  B     fragments  for-all  x  normal-:  A  normal-.  B    \forall x:A.B   ) is written [ x : A ] B .     — An application of the CoC   "  Category:Dependently typed programming  Category:Lambda calculus  Category:Type theory   