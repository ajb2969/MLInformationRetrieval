<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="1962">PID controller</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>PID controller</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>A <a href="block_diagram" title="wikilink">block diagram</a> of a PID controller in a feedback loop</figcaption>
</figure>
<p>A '''proportional-integral-derivative controller ''' (<strong>PID controller</strong>) is a <a href="control_loop" title="wikilink">control loop</a> <a href="feedback_mechanism" title="wikilink">feedback mechanism</a> (<a href="controller_(control_theory)" title="wikilink">controller</a>) widely used in <a href="industrial_control_system" title="wikilink">industrial control systems</a>. A PID controller calculates an <em>error</em> value as the difference between a measured <a href="process_variable" title="wikilink">process variable</a> and a desired <a href="Setpoint_(control_system)" title="wikilink">setpoint</a>. The controller attempts to minimize the <em>error</em> by adjusting the process through use of a manipulated variable.</p>
<p>The PID controller <a class="uri" href="algorithm" title="wikilink">algorithm</a> involves three separate constant parameters, and is accordingly sometimes called <strong>three-term control</strong>: the <a href="Proportionality_(mathematics)" title="wikilink">proportional</a>, the <a class="uri" href="integral" title="wikilink">integral</a> and <a class="uri" href="derivative" title="wikilink">derivative</a> values, denoted <em>P,</em> <em>I,</em> and <em>D.</em> Simply put, these values can be interpreted in terms of time: <em>P</em> depends on the <em>present</em> error, <em>I</em> on the accumulation of <em>past</em> errors, and <em>D</em> is a prediction of <em>future</em> errors, based on current rate of change.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The weighted sum of these three actions is used to adjust the process via a control element such as the position of a <a href="control_valve" title="wikilink">control valve</a>, a <a href="damper_(flow)" title="wikilink">damper</a>, or the power supplied to a heating element. For a discrete time case, the term PSD, for proportional-summation-derivative, is often used.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<p>A PID controller relies only on the measured process variable, not on knowledge of the underlying process, making it a broadly useful controller.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> By tuning the three parameters in the PID controller algorithm, the controller can provide control action designed for specific process requirements. The response of the controller can be described in terms of the responsiveness of the controller to an error, the degree to which the controller <a href="overshoot_(signal)" title="wikilink">overshoots</a> the setpoint, and the degree of system oscillation. Note that the use of the PID algorithm for control does not guarantee <a href="optimal_control" title="wikilink">optimal control</a> of the system or system stability.</p>
<p>Some applications may require using only one or two terms to provide the appropriate system control. This is achieved by setting the other parameters to zero. A PID controller will be called a PI, PD, P or I controller in the absence of the respective control actions. PI controllers are fairly common, since derivative action is sensitive to measurement noise, whereas the absence of an integral term may prevent the system from reaching its target value due to the control action.</p>
<h2 id="history-and-applications">History and applications</h2>
<figure><b>(Figure)</b>
<figcaption>PID theory developed by observing the action of <a class="uri" href="helmsmen" title="wikilink">helmsmen</a>.</figcaption>
</figure>
<p>PID controllers date to 1890s <a href="Governor_(device)" title="wikilink">governor</a> design.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> PID controllers were subsequently developed in automatic ship steering. One of the earliest examples of a PID-type controller was developed by <a href="Elmer_Sperry" title="wikilink">Elmer Sperry</a> in 1911,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> while the first published theoretical analysis of a PID controller was by <a href="Russian_American" title="wikilink">Russian American</a> engineer <a href="Nicolas_Minorsky" title="wikilink">Nicolas Minorsky</a>, . Minorsky was designing automatic steering systems for the US Navy, and based his analysis on observations of a <a class="uri" href="helmsman" title="wikilink">helmsman</a>, noting the helmsman controlled the ship based not only on the current error, but also on past error as well as the current rate of change;<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> this was then made mathematical by Minorsky.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> His goal was stability, not general control, which simplified the problem significantly. While proportional control provides stability against small disturbances, it was insufficient for dealing with a steady disturbance, notably a stiff gale (due to <a href="#Droop" title="wikilink">droop</a>), which required adding the integral term. Finally, the derivative term was added to improve stability and control.</p>
<p>Trials were carried out on the <a href="USS_New_Mexico_(BB-40)" title="wikilink">USS <em>New Mexico</em></a>, with the controller controlling the <em><a href="angular_velocity" title="wikilink">angular velocity</a></em> (not angle) of the rudder. PI control yielded sustained yaw (angular error) of ±2°. Adding the D element yielded a yaw error of ±1/6°, better than most helmsmen could achieve.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<p>The Navy ultimately did not adopt the system, due to resistance by personnel. Similar work was carried out and published by several others in the 1930s.</p>
<p>In the early history of automatic process control the PID controller was implemented as a mechanical device. These mechanical controllers used a <a class="uri" href="lever" title="wikilink">lever</a>, <a href="spring_(device)" title="wikilink">spring</a> and a <a class="uri" href="mass" title="wikilink">mass</a> and were often energized by compressed air. These <a class="uri" href="pneumatic" title="wikilink">pneumatic</a> controllers were once the industry standard.</p>
<p>Electronic <a href="analog_circuit" title="wikilink">analog</a> controllers can be made from a <a href="transistor" title="wikilink">solid-state</a> or <a href="Valve_amplifier" title="wikilink">tube amplifier</a>, a <a class="uri" href="capacitor" title="wikilink">capacitor</a> and a <a class="uri" href="resistor" title="wikilink">resistor</a>. Electronic analog PID control loops were often found within more complex electronic systems, for example, the head positioning of a <a href="disk_drive" title="wikilink">disk drive</a>, the power conditioning of a <a href="power_supply" title="wikilink">power supply</a>, or even the movement-detection circuit of a modern <a class="uri" href="seismometer" title="wikilink">seismometer</a>. Nowadays, electronic controllers have largely been replaced by digital controllers implemented with <a class="uri" href="microcontrollers" title="wikilink">microcontrollers</a> or <a href="FPGA" title="wikilink">FPGAs</a>. However, analog PID controllers are still used in niche applications requiring high-bandwidth and low noise performance, such as laser diode controllers.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<p>Most modern PID controllers in industry are implemented in <a href="programmable_logic_controller" title="wikilink">programmable logic controllers</a> (PLCs) or as a panel-mounted digital controller. Software implementations have the advantages that they are relatively cheap and are flexible with respect to the implementation of the PID algorithm. PID temperature controllers are applied in industrial ovens, plastics injection machinery, hot stamping machines and packing industry.</p>
<h2 id="control-loop-basics">Control loop basics</h2>
<p>A familiar example of a control loop is the action taken when adjusting hot and cold <a href="faucet" title="wikilink">faucets</a> to fill a container with water at a desired temperature by mixing hot and cold water. The person touches the water in the container as it fills to sense its temperature. Based on this feedback they perform a control action by adjusting the hot and cold faucets until the temperature stabilizes as desired.</p>
<p>The sensed water temperature is the <a href="process_variable" title="wikilink">process variable</a> (PV). The desired temperature is called the setpoint (SP). The input to the process (the water valve position), and the output of the PID controller, is called the manipulated variable (MV) or the control variable (CV). The difference between the temperature measurement and the setpoint is the error (e) and quantifies whether the water in the container is too hot or too cold and by how much.</p>
<p>After measuring the temperature (PV), and then calculating the error, the controller decides how to set the tap position (MV). The obvious method is <strong>proportional</strong> control: the tap position is set in proportion to the current error. A more complex control may include another term: <strong>derivative</strong> action. This considers the rate of change of error, adding more or less hot water depending on how fast the error is approaching zero. Finally, <strong>integral</strong> action adds a third term, using the accumulated temperature error in the past to detect whether the temperature of the container is settling out too low or too high and set the tap proportional to the past errors. An alternative formulation of integral action is to change the current tap position in steps proportional to the current error. Over time the steps add up (which is the discrete time equivalent to integration) the past errors.</p>
<p>Making a change that is too large when the error is small will lead to overshoot. If the controller were to repeatedly make changes that were too large and repeatedly overshoot the target, the output would <a class="uri" href="oscillate" title="wikilink">oscillate</a> around the setpoint in either a constant, growing, or decaying <a href="Sine_wave" title="wikilink">sinusoid</a>. If the amplitude of the oscillations increase with time, the system is unstable. If they decrease, the system is stable. If the oscillations remain at a constant magnitude, the system is <a href="Marginal_stability" title="wikilink">marginally stable</a>.</p>
<p>In the interest of achieving a gradual convergence to the desired temperature (SP), the controller may <a href="damping" title="wikilink">damp</a> the anticipated future oscillations by tempering its adjustments, or reducing the <a href="loop_gain" title="wikilink">loop gain</a>.</p>
<p>If a controller starts from a stable state with zero error (PV = SP), then further changes by the controller will be in response to changes in other measured or unmeasured inputs to the process that affect the process, and hence the PV. Variables that affect the process other than the MV are known as disturbances. Generally controllers are used to reject disturbances and to implement setpoint changes. Changes in feedwater temperature constitute a disturbance to the faucet temperature control process.</p>
<p>In theory, a controller can be used to control any process which has a measurable output (PV), a known ideal value for that output (SP) and an input to the process (MV) that will affect the relevant PV. Controllers are used in industry to regulate <a class="uri" href="temperature" title="wikilink">temperature</a>, <a class="uri" href="pressure" title="wikilink">pressure</a>, <a class="uri" href="force" title="wikilink">force</a>, <a class="uri" href="feed" title="wikilink">feed</a>,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> <a href="flow_rate" title="wikilink">flow rate</a>, <a class="uri" href="chemical" title="wikilink">chemical</a> composition, <a class="uri" href="weight" title="wikilink">weight</a>, <a href="position_(vector)" title="wikilink">position</a>, <a class="uri" href="speed" title="wikilink">speed</a> and practically every other variable for which a measurement exists.</p>
<h2 id="pid-controller-theory">PID controller theory</h2>
<dl>
<dd><em>This section describes the parallel or non-interacting form of the PID controller. For other forms please see the section <a href="#Alternative_nomenclature_and_PID_forms" title="wikilink">Alternative nomenclature and PID forms</a>.</em>
</dd>
</dl>
<p>The PID control scheme is named after its three correcting terms, whose sum constitutes the manipulated variable (MV). The proportional, integral, and derivative terms are summed to calculate the output of the PID controller. Defining <span class="LaTeX">$u(t)$</span> as the controller output, the final form of the PID algorithm is:</p>
<p><span class="LaTeX">$$\mathrm{u}(t)=\mathrm{MV}(t)=K_p{e(t)} + K_{i}\int_{0}^{t}{e(\tau)}\,{d\tau} + K_{d}\frac{d}{dt}e(t)$$</span></p>
<p>where</p>
<p><span class="LaTeX">$$K_p$$</span>: Proportional gain, a tuning parameter</p>
<p><span class="LaTeX">$$K_i$$</span>: Integral gain, a tuning parameter</p>
<p><span class="LaTeX">$$K_d$$</span>: Derivative gain, a tuning parameter</p>
<p><span class="LaTeX">$$e$$</span>: Error <span class="LaTeX">$= SP - PV$</span></p>
<p><span class="LaTeX">$$t$$</span>: Time or instantaneous time (the present)</p>
<p><span class="LaTeX">$$\tau$$</span>: Variable of integration; takes on values from time 0 to the present <span class="LaTeX">$t$</span>.</p>
<p>Equivalently, the transfer function in the <a href="Laplace_Transform" title="wikilink">Laplace Domain</a> of the PID controller is</p>
<p><span class="LaTeX">$$L(s)=K_p + K_{i}/s + K_{d}s$$</span></p>
<p>where</p>
<p><span class="LaTeX">$$s$$</span>: complex number frequency</p>
<h3 id="proportional-term">Proportional term</h3>
<figure><b>(Figure)</b>
<figcaption>Plot of PV vs time, for three values of K<sub>p</sub> (K<sub>i</sub> and K<sub>d</sub> held constant)</figcaption>
</figure>
<p>The proportional term produces an output value that is proportional to the current error value. The proportional response can be adjusted by multiplying the error by a constant <em>K<sub>p</sub></em>, called the proportional gain constant.</p>
<p>The proportional term is given by:</p>
<p><span class="LaTeX">$$P_{\mathrm{out}}=K_p\,{e(t)}$$</span></p>
<p>A high proportional gain results in a large change in the output for a given change in the error. If the proportional gain is too high, the system can become unstable (see <a href="#Loop_tuning" title="wikilink">the section on loop tuning</a>). In contrast, a small gain results in a small output response to a large input error, and a less responsive or less sensitive controller. If the proportional gain is too low, the control action may be too small when responding to system disturbances. Tuning theory and industrial practice indicate that the proportional term should contribute the bulk of the output change.</p>
<h3 id="integral-term">Integral term</h3>
<figure><b>(Figure)</b>
<figcaption>Plot of PV vs time, for three values of K<sub>i</sub> (K<sub>p</sub> and K<sub>d</sub> held constant)</figcaption>
</figure>
<p>The contribution from the integral term is proportional to both the magnitude of the error and the duration of the error. The <a class="uri" href="integral" title="wikilink">integral</a> in a PID controller is the sum of the instantaneous error over time and gives the accumulated offset that should have been corrected previously. The accumulated error is then multiplied by the integral gain (<span class="LaTeX">$K_i$</span>) and added to the controller output.</p>
<p>The integral term is given by:</p>
<p><span class="LaTeX">$$I_{\mathrm{out}}=K_{i}\int_{0}^{t}{e(\tau)}\,{d\tau}$$</span></p>
<p>The integral term accelerates the movement of the process towards setpoint and eliminates the residual steady-state error that occurs with a pure proportional controller. However, since the integral term responds to accumulated errors from the past, it can cause the present value to <a href="Overshoot_(signal)" title="wikilink">overshoot</a> the setpoint value (see <a href="#Loop_tuning" title="wikilink">the section on loop tuning</a>).</p>
<h3 id="derivative-term">Derivative term</h3>
<figure><b>(Figure)</b>
<figcaption>Plot of PV vs time, for three values of K<sub>d</sub> (K<sub>p</sub> and K<sub>i</sub> held constant)</figcaption>
</figure>
<p>The <a class="uri" href="derivative" title="wikilink">derivative</a> of the process error is calculated by determining the slope of the error over time and multiplying this rate of change by the derivative gain <em>K<sub>d</sub></em>. The magnitude of the contribution of the derivative term to the overall control action is termed the derivative gain, <em>K<sub>d</sub></em>.</p>
<p>The derivative term is given by:</p>
<p><span class="LaTeX">$$D_{\mathrm{out}}=K_d\frac{d}{dt}e(t)$$</span></p>
<p>Derivative action predicts system behavior and thus improves settling time and stability of the system.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> An ideal derivative is not <a href="causal_system" title="wikilink">causal</a>, so that implementations of PID controllers include an additional low pass filtering for the derivative term, to limit the high frequency gain and noise.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Derivative action is seldom used in practice though - by one estimate in only 25% of deployed controllers<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> - because of its variable impact on system stability in real-world applications.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="loop-tuning">Loop tuning</h2>
<p><em>Tuning</em> a control loop is the adjustment of its control parameters (proportional band/gain, integral gain/reset, derivative gain/rate) to the optimum values for the desired control response. Stability (no unbounded oscillation) is a basic requirement, but beyond that, different systems have different behavior, different applications have different requirements, and requirements may conflict with one another.</p>
<p>PID tuning is a difficult problem, even though there are only three parameters and in principle is simple to describe, because it must satisfy complex criteria within the <a href="#Limitations_of_PID_control" title="wikilink">limitations of PID control</a>. There are accordingly various methods for loop tuning, and more sophisticated techniques are the subject of patents; this section describes some traditional manual methods for loop tuning.</p>
<p>Designing and tuning a PID controller appears to be conceptually intuitive, but can be hard in practice, if multiple (and often conflicting) objectives such as short transient and high stability are to be achieved. PID controllers often provide acceptable control using default tunings, but performance can generally be improved by careful tuning, and performance may be unacceptable with poor tuning. Usually, initial designs need to be adjusted repeatedly through computer simulations until the closed-loop system performs or compromises as desired.</p>
<p>Some processes have a degree of <a href="Nonlinear_system" title="wikilink">nonlinearity</a> and so parameters that work well at full-load conditions don't work when the process is starting up from no-load; this can be corrected by <a href="gain_scheduling" title="wikilink">gain scheduling</a> (using different parameters in different operating regions).</p>
<h3 id="stability">Stability</h3>
<p>If the PID controller parameters (the gains of the proportional, integral and derivative terms) are chosen incorrectly, the controlled process input can be unstable, i.e., its output <a href="Divergence_(computer_science)" title="wikilink">diverges</a>, with or without <a class="uri" href="oscillation" title="wikilink">oscillation</a>, and is limited only by saturation or mechanical breakage. Instability is caused by <em>excess</em> gain, particularly in the presence of significant lag.</p>
<p>Generally, stabilization of response is required and the process must not oscillate for any combination of process conditions and setpoints, though sometimes <a href="marginal_stability" title="wikilink">marginal stability</a> (bounded oscillation) is acceptable or desired.</p>
<p>Mathematically, the origins of instability can be seen in the Laplace domain.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The total loop transfer function is:</p>
<p><span class="LaTeX">$$H(s)=\frac{K(s)G(s)}{1+K(s)G(s)}$$</span> where</p>
<p><span class="LaTeX">$$K(s)$$</span>: PID transfer function</p>
<p><span class="LaTeX">$$G(s)$$</span>: Plant transfer function</p>
<p>The system is called unstable where the closed loop transfer function diverges for some <span class="LaTeX">$s$</span>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> This happens for situations where <span class="LaTeX">$K(s)G(s)=-1$</span>. Typically, this happens when <span class="LaTeX">$|K(s)G(s)|=1$</span> with a 180 degree phase shift. Stability is guaranteed when <span class="LaTeX">$K(s)G(s)<1$</span> for frequencies that suffer high phase shifts. A more general formalism of this effect is known as the <a href="Nyquist_stability_criterion" title="wikilink">Nyquist stability criterion</a>.</p>
<h3 id="optimum-behavior">Optimum behavior</h3>
<p>The optimum behavior on a process change or setpoint change varies depending on the application.</p>
<p>Two basic requirements are <em>regulation</em> (disturbance rejection – staying at a given setpoint) and <em>command tracking</em> (implementing setpoint changes) – these refer to how well the controlled variable tracks the desired value. Specific criteria for command tracking include <a href="rise_time" title="wikilink">rise time</a> and <a href="settling_time" title="wikilink">settling time</a>. Some processes must not allow an overshoot of the process variable beyond the setpoint if, for example, this would be unsafe. Other processes must minimize the energy expended in reaching a new setpoint.</p>
<h3 id="overview-of-methods">Overview of methods</h3>
<p>There are several methods for tuning a PID loop. The most effective methods generally involve the development of some form of process model, then choosing P, I, and D based on the dynamic model parameters. Manual tuning methods can be relatively inefficient, particularly if the loops have response times on the order of minutes or longer. </p>
<p>The choice of method will depend largely on whether or not the loop can be taken "offline" for tuning, and on the response time of the system. If the system can be taken offline, the best tuning method often involves subjecting the system to a step change in input, measuring the output as a function of time, and using this response to determine the control parameters. </p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Choosing a tuning method</p></td>
<td style="text-align: left;"><p>Method</p></td>
<td style="text-align: left;"><p>Advantages</p></td>
<td style="text-align: left;"><p>Disadvantages</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Manual tuning</p></td>
<td style="text-align: left;"><p>No math required; online.</p></td>
<td style="text-align: left;"><p>Requires experienced personnel. </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Ziegler–Nichols<mtpl></mtpl></p></td>
<td style="text-align: left;"><p>Proven method; online.</p></td>
<td style="text-align: left;"><p>Process upset, some trial-and-error, very aggressive tuning. </p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Tyreus Luyben</p></td>
<td style="text-align: left;"><p>Proven method; online.</p></td>
<td style="text-align: left;"><p>Process upset, some trial-and-error, very aggressive tuning. </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Software tools</p></td>
<td style="text-align: left;"><p>Consistent tuning; online or offline - can employ computer-automated control system design (<em><a class="uri" href="CAutoD" title="wikilink">CAutoD</a></em>) techniques; may include valve and sensor analysis; allows simulation before downloading; can support non-steady-state (NSS) tuning.</p></td>
<td style="text-align: left;"><p>Some cost or training involved.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Cohen–Coon</p></td>
<td style="text-align: left;"><p>Good process models.</p></td>
<td style="text-align: left;"><p>Some math; offline; only good for first-order processes. </p></td>
</tr>
</tbody>
</table>
<h3 id="manual-tuning">Manual tuning</h3>
<p>If the system must remain online, one tuning method is to first set <span class="LaTeX">$K_i$</span> and <span class="LaTeX">$K_d$</span> values to zero. Increase the <span class="LaTeX">$K_p$</span> until the output of the loop oscillates, then the <span class="LaTeX">$K_p$</span> should be set to approximately half of that value for a "quarter amplitude decay" type response. Then increase <span class="LaTeX">$K_i$</span> until any offset is corrected in sufficient time for the process. However, too much <span class="LaTeX">$K_i$</span> will cause instability. Finally, increase <span class="LaTeX">$K_d$</span>, if required, until the loop is acceptably quick to reach its reference after a load disturbance. However, too much <span class="LaTeX">$K_d$</span> will cause excessive response and overshoot. A fast PID loop tuning usually overshoots slightly to reach the setpoint more quickly; however, some systems cannot accept overshoot, in which case an <em><a href="overdamping" title="wikilink">over-damped</a></em> closed-loop system is required, which will require a <span class="LaTeX">$K_p$</span> setting significantly less than half that of the <span class="LaTeX">$K_p$</span> setting that was causing oscillation. </p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Effects of <em>increasing</em> a parameter independently<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p></td>
<td style="text-align: left;"><p>Parameter</p></td>
<td style="text-align: left;"><p>Rise time</p></td>
<td style="text-align: left;"><p>Overshoot</p></td>
<td style="text-align: left;"><p>Settling time</p></td>
<td style="text-align: left;"><p>Steady-state error</p></td>
<td style="text-align: left;"><p>Stability<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$K_p$</span></p></td>
<td style="text-align: left;"><p>Decrease</p></td>
<td style="text-align: left;"><p>Increase</p></td>
<td style="text-align: left;"><p>Small change</p></td>
<td style="text-align: left;"><p>Decrease</p></td>
<td style="text-align: left;"><p>Degrade</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$K_i$</span></p></td>
<td style="text-align: left;"><p>Decrease</p></td>
<td style="text-align: left;"><p>Increase</p></td>
<td style="text-align: left;"><p>Increase</p></td>
<td style="text-align: left;"><p>Eliminate</p></td>
<td style="text-align: left;"><p>Degrade</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$K_d$</span></p></td>
<td style="text-align: left;"><p>Minor change</p></td>
<td style="text-align: left;"><p>Decrease</p></td>
<td style="text-align: left;"><p>Decrease</p></td>
<td style="text-align: left;"><p>No effect in theory</p></td>
<td style="text-align: left;"><p>Improve if <span class="LaTeX">$K_d$</span> small</p></td>
</tr>
</tbody>
</table>
<h3 id="zieglernichols-method">Ziegler–Nichols method</h3>
<p>Another heuristic tuning method is formally known as the <a href="Ziegler–Nichols_method" title="wikilink">Ziegler–Nichols method</a>, introduced by <a href="John_G._Ziegler" title="wikilink">John G. Ziegler</a> and <a href="Nathaniel_B._Nichols" title="wikilink">Nathaniel B. Nichols</a> in the 1940s. As in the method above, the <span class="LaTeX">$K_i$</span> and <span class="LaTeX">$K_d$</span> gains are first set to zero. The proportional gain is increased until it reaches the ultimate gain, <span class="LaTeX">$K_u$</span>, at which the output of the loop starts to oscillate. <span class="LaTeX">$K_u$</span> and the oscillation period <span class="LaTeX">$T_u$</span> are used to set the gains as shown:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Ziegler–Nichols method</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Control Type</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><em>P</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><em>PI</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><em>PID</em></p></td>
</tr>
</tbody>
</table>
<p>These gains apply to the ideal, parallel form of the PID controller. When applied to the standard PID form, the integral and derivative time parameters <span class="LaTeX">$T_i$</span> and <span class="LaTeX">$T_d$</span> are only dependent on the oscillation period <span class="LaTeX">$T_u$</span>. Please see the section "<a href="#Alternative_nomenclature_and_PID_forms" title="wikilink">Alternative nomenclature and PID forms</a>".</p>
<h3 id="pid-tuning-software">PID tuning software</h3>
<p>Most modern industrial facilities no longer tune loops using the manual calculation methods shown above. Instead, PID tuning and loop optimization software are used to ensure consistent results. These software packages will gather the data, develop process models, and suggest optimal tuning. Some software packages can even develop tuning by gathering data from reference changes.</p>
<p>Mathematical PID loop tuning induces an impulse in the system, and then uses the controlled system's frequency response to design the PID loop values. In loops with response times of several minutes, mathematical loop tuning is recommended, because trial and error can take days just to find a stable set of loop values. Optimal values are harder to find. Some digital loop controllers offer a self-tuning feature in which very small setpoint changes are sent to the process, allowing the controller itself to calculate optimal tuning values.</p>
<p>Other formulas are available to tune the loop according to different performance criteria. Many patented formulas are now embedded within PID tuning software and hardware modules.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<p>Advances in automated PID Loop Tuning software also deliver algorithms for tuning PID Loops in a dynamic or Non-Steady State (NSS) scenario. The software will model the dynamics of a process, through a disturbance, and calculate PID control parameters in response.</p>
<h2 id="limitations-of-pid-control">Limitations of PID control</h2>
<p>While PID controllers are applicable to many control problems, and often perform satisfactorily without any improvements or only coarse tuning, they can perform poorly in some applications, and do not in general provide <a href="optimal_control" title="wikilink"><em>optimal</em> control</a>. The fundamental difficulty with PID control is that it is a feed<em>back</em> system, with <em>constant</em> parameters, and no direct knowledge of the process, and thus overall performance is reactive and a compromise. While PID control is the best controller in an observer without a model of the process,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> better performance can be obtained by overtly modeling the actor of the process without resorting to an observer.</p>
<p>PID controllers, when used alone, can give poor performance when the PID loop gains must be reduced so that the control system does not overshoot, oscillate or <a href="Hunting_oscillation" title="wikilink">hunt</a> about the control setpoint value. They also have difficulties in the presence of non-linearities, may trade-off regulation versus response time, do not react to changing process behavior (say, the process changes after it has warmed up), and have lag in responding to large disturbances.</p>
<p>The most significant improvement is to incorporate <a href="feed-forward_control" title="wikilink">feed-forward control</a> with knowledge about the system, and using the PID only to control error. Alternatively, PIDs can be modified in more minor ways, such as by changing the parameters (either <a href="gain_scheduling" title="wikilink">gain scheduling</a> in different use cases or adaptively modifying them based on performance), improving measurement (higher sampling rate, precision, and accuracy, and low-pass filtering if necessary), or cascading multiple PID controllers.</p>
<h3 id="linearity">Linearity</h3>
<p>Another problem faced with PID controllers is that they are linear, and in particular symmetric. Thus, performance of PID controllers in non-linear systems (such as <a href="HVAC_control_system" title="wikilink">HVAC systems</a>) is variable. For example, in temperature control, a common use case is active heating (via a heating element) but passive cooling (heating off, but no cooling), so overshoot can only be corrected slowly – it cannot be forced downward. In this case the PID should be tuned to be overdamped, to prevent or reduce overshoot, though this reduces performance (it increases settling time).</p>
<h3 id="noise-in-derivative">Noise in derivative</h3>
<p>A problem with the derivative term is that it amplifies higher frequency measurement or process <a class="uri" href="noise" title="wikilink">noise</a> that can cause large amounts of change in the output. It does this so much, that a physical controller cannot have a true derivative term, but only an approximation with limited bandwidth. It is often helpful to filter the measurements with a <a href="low-pass_filter" title="wikilink">low-pass filter</a> in order to remove higher-frequency noise components. As low-pass filtering and derivative control can cancel each other out, the amount of filtering is limited. So low noise instrumentation can be important. A nonlinear <a href="median_filter" title="wikilink">median filter</a> may be used, which improves the filtering efficiency and practical performance.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> In some cases, the differential band can be turned off with little loss of control. This is equivalent to using the PID controller as a <a href="#PI_controller" title="wikilink">PI controller</a>.</p>
<h2 id="modifications-to-the-pid-algorithm">Modifications to the PID algorithm</h2>
<p>The basic PID algorithm presents some challenges in control applications that have been addressed by minor modifications to the PID form.</p>
<h3 id="integral-windup">Integral windup</h3>
<p>One common problem resulting from the ideal PID implementations is <a href="integral_windup" title="wikilink">integral windup</a>. Following a large change in setpoint the integral term can accumulate an error larger than the maximal value for the regulation variable (windup), thus the system overshoots and continues to increase until this accumulated error is unwound. This problem can be addressed by:</p>
<ul>
<li>Disabling the integration until the PV has entered the controllable region</li>
<li>Preventing the integral term from accumulating above or below pre-determined bounds</li>
<li>Back-calculating the integral term to constrain the regulator output within feasible bounds.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></li>
</ul>
<h3 id="overshooting-from-known-disturbances">Overshooting from known disturbances</h3>
<p>For example, a PID loop is used to control the temperature of an electric resistance furnace where the system has stabilized. Now when the door is opened and something cold is put into the furnace the temperature drops below the setpoint. The integral function of the controller tends to compensate for error by introducing another error in the positive direction. This overshoot can be avoided by freezing of the integral function after the opening of the door for the time the control loop typically needs to reheat the furnace.</p>
<h3 id="pi-controller">PI controller</h3>
<figure><b>(Figure)</b>
<figcaption>Basic block of a PI controller</figcaption>
</figure>
<p>A <strong>PI Controller</strong> (proportional-integral controller) is a special case of the PID controller in which the derivative (D) of the error is not used.</p>
<p>The controller output is given by</p>
<p><span class="LaTeX">$$K_P \Delta + K_I \int \Delta\,dt$$</span> where <span class="LaTeX">$\Delta$</span> is the error or deviation of actual measured value (<strong><em>PV<strong><em>) from the setpoint (</em></strong>SP</em></strong>).</p>
<p><span class="LaTeX">$$\Delta = SP - PV$$</span>.</p>
<p>A PI controller can be modelled easily in software such as <a class="uri" href="Simulink" title="wikilink">Simulink</a> or <a class="uri" href="Xcos" title="wikilink">Xcos</a> using a "flow chart" box involving <a href="Laplace_transform" title="wikilink">Laplace</a> operators:</p>
<p><span class="LaTeX">$$C=\frac{G(1+\tau s)}{\tau s}$$</span> where</p>
<p><span class="LaTeX">$$G = K_P$$</span> = proportional gain</p>
<p><span class="LaTeX">$$G/\tau = K_I$$</span> = integral gain</p>
<p>Setting a value for <span class="LaTeX">$G$</span> is often a trade off between decreasing overshoot and increasing settling time.</p>
<p>The lack of derivative action may make the system more steady in the steady state in the case of noisy data. This is because derivative action is more sensitive to higher-frequency terms in the inputs.</p>
<p>Without derivative action, a PI-controlled system is less responsive to real (non-noise) and relatively fast alterations in state and so the system will be slower to reach setpoint and slower to respond to perturbations than a well-tuned PID system may be.</p>
<h3 id="deadband">Deadband</h3>
<p>Many PID loops control a mechanical device (for example, a valve). Mechanical maintenance can be a major cost and wear leads to control degradation in the form of either <a class="uri" href="stiction" title="wikilink">stiction</a> or a <a class="uri" href="deadband" title="wikilink">deadband</a> in the mechanical response to an input signal. The rate of mechanical wear is mainly a function of how often a device is activated to make a change. Where wear is a significant concern, the PID loop may have an output <a class="uri" href="deadband" title="wikilink">deadband</a> to reduce the frequency of activation of the output (valve). This is accomplished by modifying the controller to hold its output steady if the change would be small (within the defined deadband range). The calculated output must leave the deadband before the actual output will change.</p>
<h3 id="setpoint-step-change">Setpoint step change</h3>
<p>The proportional and derivative terms can produce excessive movement in the output when a system is subjected to an instantaneous step increase in the error, such as a large setpoint change. In the case of the derivative term, this is due to taking the derivative of the error, which is very large in the case of an instantaneous step change. As a result, some PID algorithms incorporate some of the following modifications:</p>
<dl>
<dt>Setpoint ramping</dt>
<dd>In this modification, the setpoint is gradually moved from its old value to a newly specified value using a linear or first order differential ramp function. This avoids the <a href="discontinuity_(mathematics)" title="wikilink">discontinuity</a> present in a simple step change.
</dd>
<dt>Derivative of the process variable</dt>
<dd>In this case the PID controller measures the derivative of the measured <a href="process_variable" title="wikilink">process variable</a> (PV), rather than the derivative of the error. This quantity is always continuous (i.e., never has a step change as a result of changed setpoint). This modification is a simple case of setpoint weighting.
</dd>
<dt>Setpoint weighting</dt>
<dd>Setpoint weighting adds adjustable factors (usually between 0 and 1) to the setpoint in the error in the proportional and derivative element of the controller. The error in the integral term must be the true control error to avoid steady-state control errors. These two extra parameters do not affect the response to load disturbances and measurement noise and can be tuned to improve the controller's setpoint response.
</dd>
</dl>
<h3 id="feed-forward">Feed-forward</h3>
<p>The control system performance can be improved by combining the <a class="uri" href="feedback" title="wikilink">feedback</a> (or closed-loop) control of a PID controller with <a href="Feed_forward_(control)" title="wikilink">feed-forward</a> (or open-loop) control. Knowledge about the system (such as the desired acceleration and inertia) can be fed forward and combined with the PID output to improve the overall system performance. The feed-forward value alone can often provide the major portion of the controller output. The PID controller primarily has to compensate whatever difference or <em>error</em> remains between the setpoint (SP) and the system response to the open loop control. Since the feed-forward output is not affected by the process feedback, it can never cause the control system to oscillate, thus improving the system response without affecting stability. Feed forward can be based on the setpoint and on extra measured disturbances. Setpoint weighting is a simple form of feed forward.</p>
<p>For example, in most motion control systems, in order to accelerate a mechanical load under control, more force is required from the actuator. If a velocity loop PID controller is being used to control the speed of the load and command the force being applied by the actuator, then it is beneficial to take the desired instantaneous acceleration, scale that value appropriately and add it to the output of the PID velocity loop controller. This means that whenever the load is being accelerated or decelerated, a proportional amount of force is commanded from the actuator regardless of the feedback value. The PID loop in this situation uses the feedback information to change the combined output to reduce the remaining difference between the process setpoint and the feedback value. Working together, the combined open-loop feed-forward controller and closed-loop PID controller can provide a more responsive control system.</p>
<h3 id="bumpless-operation">Bumpless operation</h3>
<p>PID controllers are often implemented with a "bumpless" initialization feature that recalculates the integral accumulator term to maintain a consistent process output through parameter changes.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> A partial implementation is to store the integral of the integral gain times the error rather than storing the integral of the error and postmultiplying by the integral gain, which prevents discontinuous output when the I gain is changed, but not the P or D gains.</p>
<h3 id="other-improvements">Other improvements</h3>
<p>In addition to feed-forward, PID controllers are often enhanced through methods such as PID <a href="gain_scheduling" title="wikilink">gain scheduling</a> (changing parameters in different operating conditions), <a href="fuzzy_logic" title="wikilink">fuzzy logic</a> or <a href="computational_verb_logic" title="wikilink">computational verb logic</a>. <a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> <a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Further practical application issues can arise from instrumentation connected to the controller. A high enough sampling rate, measurement precision, and measurement accuracy are required to achieve adequate control performance. Another new method for improvement of PID controller is to increase the degree of freedom by using fractional order. The order of the integrator and differentiator add increased flexibility to the controller.</p>
<h2 id="cascade-control">Cascade control</h2>
<p>One distinctive advantage of PID controllers is that two PID controllers can be used together to yield better dynamic performance. This is called cascaded PID control. In cascade control there are two PIDs arranged with one PID controlling the setpoint of another. A PID controller acts as outer loop controller, which controls the primary physical parameter, such as fluid level or velocity. The other controller acts as inner loop controller, which reads the output of outer loop controller as setpoint, usually controlling a more rapid changing parameter, flowrate or acceleration. It can be mathematically proven that the working frequency of the controller is increased and the time constant of the object is reduced by using cascaded PID controllers..</p>
<p>For example, a temperature-controlled circulating bath has two PID controllers in cascade, each with its own thermocouple temperature sensor. The outer controller controls the temperature of the water using a thermocouple located far from the heater where it accurately reads the temperature of the bulk of the water. The error term of this PID controller is the difference between the desired bath temperature and measured temperature. Instead of controlling the heater directly, the outer PID controller sets a heater temperature goal for the inner PID controller. The inner PID controller controls the temperature of the heater using a thermocouple attached to the heater. The inner controller's error term is the difference between this heater temperature setpoint and the measured temperature of the heater. Its output controls the actual heater to stay near this setpoint.</p>
<p>The proportional, integral and differential terms of the two controllers will be very different. The outer PID controller has a long time constant – all the water in the tank needs to heat up or cool down. The inner loop responds much more quickly. Each controller can be tuned to match the physics of the system <em>it</em> controls – heat transfer and thermal mass of the whole tank or of just the heater – giving better total response.</p>
<h2 id="alternative-nomenclature-and-pid-forms">Alternative nomenclature and PID forms</h2>
<h3 id="ideal-versus-standard-pid-form">Ideal versus standard PID form</h3>
<p>The form of the PID controller most often encountered in industry, and the one most relevant to tuning algorithms is the <em>standard form</em>. In this form the <span class="LaTeX">$K_p$</span> gain is applied to the <span class="LaTeX">$I_{\mathrm{out}}$</span>, and <span class="LaTeX">$D_{\mathrm{out}}$</span> terms, yielding:</p>
<p><span class="LaTeX">$$\mathrm{MV(t)}=K_p\left(\,{e(t)} + \frac{1}{T_i}\int_{0}^{t}{e(\tau)}\,{d\tau} + T_d\frac{d}{dt}e(t)\right)$$</span> where</p>
<p><span class="LaTeX">$$T_i$$</span> is the <em>integral time</em></p>
<p><span class="LaTeX">$$T_d$$</span> is the <em>derivative time</em></p>
<p>In this standard form, the parameters have a clear physical meaning. In particular, the inner summation produces a new single error value which is compensated for future and past errors. The addition of the proportional and derivative components effectively predicts the error value at <span class="LaTeX">$T_d$</span> seconds (or samples) in the future, assuming that the loop control remains unchanged. The integral component adjusts the error value to compensate for the sum of all past errors, with the intention of completely eliminating them in <span class="LaTeX">$T_i$</span> seconds (or samples). The resulting compensated single error value is scaled by the single gain <span class="LaTeX">$K_p$</span>.</p>
<p>In the ideal parallel form, shown in the controller theory section</p>
<p><span class="LaTeX">$$\mathrm{MV(t)}=K_p{e(t)} + K_i\int_{0}^{t}{e(\tau)}\,{d\tau} + K_d\frac{d}{dt}e(t)$$</span></p>
<p>the gain parameters are related to the parameters of the standard form through <span class="LaTeX">$K_i = \frac{K_p}{T_i}$</span> and <span class="LaTeX">$K_d = K_p T_d \,$</span>. This parallel form, where the parameters are treated as simple gains, is the most general and flexible form. However, it is also the form where the parameters have the least physical interpretation and is generally reserved for theoretical treatment of the PID controller. The standard form, despite being slightly more complex mathematically, is more common in industry.</p>
<h3 id="reciprocal-gain">Reciprocal gain</h3>
<p>In many cases, the manipulated variable output by the PID controller is a dimensionless fraction between 0 and 100% of some maximum possible value, and the translation into real units (such as pumping rate or watts of heater power) is outside the PID controller. The process variable, however, is in dimensioned units such as temperature. It is common in this case to express the gain <span class="LaTeX">$K_p$</span> not as "output per degree", but rather in the form of a temperature <span class="LaTeX">$1/K_p$</span> which is "degrees per full output". This is the range over which the output changes from 0 to 1 (0% to 100%).</p>
<h3 id="basing-derivative-action-on-pv">Basing derivative action on PV</h3>
<p>In most commercial control systems, derivative action is based on PV rather than error. This is because the digitized version of the algorithm produces a large unwanted spike when the SP is changed. If the SP is constant then changes in PV will be the same as changes in error. Therefore this modification makes no difference to the way the controller responds to process disturbances.</p>
<p><span class="LaTeX">$$\mathrm{MV(t)}=K_p\left(\,{e(t)} + \frac{1}{T_i}\int_{0}^{t}{e(\tau)}\,{d\tau} - T_d\frac{d}{dt}PV(t)\right)$$</span></p>
<h3 id="basing-proportional-action-on-pv">Basing proportional action on PV</h3>
<p>Most commercial control systems offer the option of also basing the proportional action on PV. This means that only the integral action responds to changes in SP. The modification to the algorithm does not affect the way the controller responds to process disturbances. The change to proportional action on PV eliminates the instant and possibly very large change in output on a fast change in SP. Depending on the process and tuning this may be beneficial to the response to a SP step.</p>
<p><span class="LaTeX">$$\mathrm{MV(t)}=K_p\left(\,{-PV(t)} + \frac{1}{T_i}\int_{0}^{t}{e(\tau)}\,{d\tau} - T_d\frac{d}{dt}PV(t)\right)$$</span></p>
<p>King<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> describes an effective chart-based method.</p>
<h3 id="laplace-form-of-the-pid-controller">Laplace form of the PID controller</h3>
<p>Sometimes it is useful to write the PID regulator in <a href="Laplace_transform" title="wikilink">Laplace transform</a> form:</p>
<p><span class="LaTeX">$$G(s)=K_p + \frac{K_i}{s} + K_d{s}=\frac{K_d{s^2} + K_p{s} + K_i}{s}$$</span></p>
<p>Having the PID controller written in Laplace form and having the <a href="transfer_function" title="wikilink">transfer function</a> of the controlled system makes it easy to determine the closed-loop transfer function of the system.</p>
<h3 id="pid-pole-zero-cancellation">PID pole zero cancellation</h3>
<p>The PID equation can be written in this form:</p>
<p><span class="LaTeX">$$G(s)=K_d \frac{s^2 + \frac{K_p}{K_d}s + \frac{K_i}{K_d}}{s}$$</span> When this form is used it is easy to determine the closed loop transfer function.</p>
<p><span class="LaTeX">$$H(s)=\frac{1}{s^2 + 2\zeta \omega_0 s + \omega_0^2}$$</span></p>
<p>If</p>
<p><span class="LaTeX">$$\frac{K_i}{K_d}=\omega_0^2$$</span></p>
<p><span class="LaTeX">$$\frac{K_p}{K_d}=2\zeta \omega_0$$</span> Then</p>
<p><span class="LaTeX">$$G(s) H(s)=\frac{K_d}{s}$$</span> While this appears to be very useful to remove unstable poles, it is in reality not the case. The closed loop transfer function from disturbance to output still contains the unstable poles.</p>
<h3 id="seriesinteracting-form">Series/interacting form</h3>
<p>Another representation of the PID controller is the series, or <em>interacting</em> form</p>
<p><span class="LaTeX">$$G(s) = K_c \frac{(\tau_i{s}+1)}{\tau_i{s}} (\tau_d{s}+1)$$</span> where the parameters are related to the parameters of the standard form through</p>
<p><span class="LaTeX">$$K_p = K_c \cdot \alpha$$</span>, <span class="LaTeX">$T_i = \tau_i \cdot \alpha$</span>, and</p>
<p><span class="LaTeX">$$T_d = \frac{\tau_d}{\alpha}$$</span> with</p>
<p><span class="LaTeX">$$\alpha = 1 + \frac{\tau_d}{\tau_i}$$</span>.</p>
<p>This form essentially consists of a PD and PI controller in series, and it made early (analog) controllers easier to build. When the controllers later became digital, many kept using the interacting form.</p>
<h3 id="discrete-implementation">Discrete implementation</h3>
<p>The analysis for designing a digital implementation of a PID controller in a <a class="uri" href="microcontroller" title="wikilink">microcontroller</a> (MCU) or <a class="uri" href="FPGA" title="wikilink">FPGA</a> device requires the standard form of the PID controller to be <em>discretized</em>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> Approximations for first-order derivatives are made by backward <a href="finite_difference" title="wikilink">finite differences</a>. The integral term is discretised, with a sampling time <span class="LaTeX">$\Delta t$</span>,as follows,</p>
<p><span class="LaTeX">$$\int_{0}^{t_k}{e(\tau)}\,{d\tau} = \sum_{i=1}^k e(t_i)\Delta t$$</span></p>
<p>The derivative term is approximated as,</p>
<p><span class="LaTeX">$$\dfrac{de(t_k)}{dt}=\dfrac{e(t_k)-e(t_{k-1})}{\Delta t}$$</span></p>
<p>Thus, a <em>velocity algorithm</em> for implementation of the discretized PID controller in a MCU is obtained by differentiating <span class="LaTeX">$u(t)$</span>, using the numerical definitions of the first and second derivative and solving for <span class="LaTeX">$u(t_k)$</span> and finally obtaining:</p>
<p><span class="LaTeX">$$u(t_k)=u(t_{k-1})+K_p\left[\left(1+\dfrac{\Delta t}{T_i}+\dfrac{T_d}{\Delta t}\right)e(t_k)+\left(-1-\dfrac{2T_d}{\Delta t}\right)e(t_{k-1})+\dfrac{T_d}{\Delta t}e(t_{k-2})\right]$$</span></p>
<p>s.t. <span class="LaTeX">$T_i = K_p/K_i, T_d = K_d/K_p$</span></p>
<h2 id="pseudocode">Pseudocode</h2>
<p>Here is a simple software loop that implements a PID algorithm:<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<p><code>previous_error = 0</code><br/>
<code>integral = 0 </code><br/>
<code>start:</code><br/>
<code>  error = setpoint - measured_value</code><br/>
<code>  integral = integral + error*dt</code><br/>
<code>  derivative = (error - previous_error)/dt</code><br/>
<code>  output = Kp*error + Ki*integral + Kd*derivative</code><br/>
<code>  previous_error = error</code><br/>
<code>  wait(dt)</code><br/>
<code>  goto start</code></p>
<p>In this example, two variables that will be maintained within the loop are <a href="Initialization_(programming)" title="wikilink">initialized</a> to zero, then the loop begins. The current <em>error</em> is calculated by subtracting the <em>measured_value</em> (the process variable or PV) from the current <em>setpoint</em> (SP). Then, <em><a class="uri" href="integral" title="wikilink">integral</a></em> and <em><a class="uri" href="derivative" title="wikilink">derivative</a></em> values are calculated and these and the <em>error</em> are combined with three preset gain terms – the proportional gain, the integral gain and the derivative gain – to derive an <em>output</em> value. In the real world, this is <a href="Digital-to-analog_converter" title="wikilink">D to A converted</a> and passed into the process under control as the manipulated variable (or MV). The current error is stored elsewhere for re-use in the next differentiation, the program then waits until dt seconds have passed since start, and the loop begins again, <a href="Analog-to-digital_converter" title="wikilink">reading in</a> new values for the PV and the setpoint and calculating a new value for the error.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Control_theory" title="wikilink">Control theory</a></li>
<li><a class="uri" href="Feedback" title="wikilink">Feedback</a></li>
<li><a class="uri" href="Instability" title="wikilink">Instability</a></li>
<li><a class="uri" href="Oscillation" title="wikilink">Oscillation</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<ul>
<li></li>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://reference.wolfram.com/mathematica/ref/PIDTune.html">PID tuning using Mathematica</a></li>
</ul>
<h3 id="pid-tutorials">PID tutorials</h3>
<ul>
<li><a href="http://www.pidlab.com/">PID tutorial, free PID tuning tools, advanced PID control schemes, on-line PID simulators</a></li>
<li><a href="http://electronicdesign.com/analog/whats-all-p-i-d-stuff-anyhow">What's All This P-I-D Stuff, Anyhow?</a> Article in Electronic Design</li>
<li>[<a class="uri" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.154.240&rep">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.154.240&rep</a>;=rep1&type;=pdf Shows how to build a PID controller with basic electronic components] (pg. 22)</li>
<li><a href="http://www.che.utexas.edu/course/che360/Process_Tuner.html">Online PID Tuning applet from University of Texas Control Group</a></li>
<li><a href="http://www.mathworks.com/discovery/pid-control.html">PID Control with MATLAB and Simulink</a></li>
<li><a href="http://www.postreh.com/vmichal/papers/PID-Radio.pdf">PID with single Operational Amplifier</a></li>
<li><a href="http://www.controlguru.com/pages/table.html">Proven Methods and Best Practices for PID Control</a></li>
<li></li>
<li></li>
</ul>
<p><a class="uri" href="de:Regler#PID-Regler" title="wikilink">de:Regler#PID-Regler</a>"</p>
<p><a href="Category:Control_theory" title="wikilink">Category:Control theory</a> <a href="Category:Control_engineering" title="wikilink">Category:Control engineering</a> <a href="Category:Control_devices" title="wikilink">Category:Control devices</a> <a href="Category:Classical_control" title="wikilink">Category:Classical control</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="https://www.kirp.chtf.stuba.sk/pc11/data/papers/077.pdf">Veselý, V., Rosinová, D.: Robust PSD Controller Design, Editors: Fikar, M., Kvasnica, M., In Proceedings of the 18th International Conference on Process Control, Tatranská Lomnica, Slovakia, 565–570, 2011</a><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19">Li, Y., et al. (2004) CAutoCSD - Evolutionary search and optimisation enabled computer automated control system design, Int J Automation and Computing, vol. 1, No. 1, pp. 76-88. ISSN 1751-8520. <a class="uri" href="http://userweb.eng.gla.ac.uk/yun.li/ga_demo/">http://userweb.eng.gla.ac.uk/yun.li/ga_demo/</a><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21">Ang, K.H., Chong, G.C.Y., and Li, Y. (2005). PID control system analysis, design, and technology, <em>IEEE Trans Control Systems Tech</em>, 13(4), pp.559-576. <a class="uri" href="http://eprints.gla.ac.uk/3817/1/IEEE3.pdf">http://eprints.gla.ac.uk/3817/1/IEEE3.pdf</a><a href="#fnref21">↩</a></li>
<li id="fn22">Y Li, KH Ang, GCY Chong, Patents, software, and hardware for PID control: An overview and analysis of the current art, Control Systems, IEEE, 26 (1), 42-54. <a class="uri" href="http://eprints.gla.ac.uk/3816/1/IEEE2pdf.pdf">http://eprints.gla.ac.uk/3816/1/IEEE2pdf.pdf</a><a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24"><a href="http://eprints.gla.ac.uk/3815/1/IEEE_CS_PID_01580152.pdf">Li, Y. and Ang, K.H. and Chong, G.C.Y. (2006) PID control system analysis and design - Problems, remedies, and future directions. IEEE Control Systems Magazine, 26 (1). pp. 32-41. ISSN 0272-1708</a><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><mtpl></mtpl><a href="#fnref28">↩</a></li>
<li id="fn29">King, Myke. <em>Process Control: A Practical Approach</em>. Wiley, 2010, p. 52-78<a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"></li>
</ol>
</section>
</body>
</html>
