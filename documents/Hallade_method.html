<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="37">Hallade method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hallade method</h1>
<hr/>

<p> The <strong>Hallade method</strong>, devised by Frenchman Emile Hallade, is a method used in <a href="track_geometry" title="wikilink">track geometry</a> for surveying, designing and setting out curves in <a href="Rail_transport" title="wikilink">railway</a> track.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>It involves measuring the offset of a string line from the outside of a curve at the central point of a <a href="Chord_(geometry)" title="wikilink">chord</a>. A standard chord length is used: in the UK this is conventionally one <a href="Chain_(length)" title="wikilink">chain</a>, i.e. 22 <a class="uri" href="yards" title="wikilink">yards</a>. Half chords, i.e. half a chain intervals, are marked on the datum rail using chalk. The string, which is one chain long, is then held taut with one end on two marks at each end of a chord, and the offset at the half chord mark measured. The <a class="uri" href="versine" title="wikilink">versine</a> of the chord, which is equal to this measured offset value can be calculated using the approximation of:</p>

<p>

<math display="inline" id="Hallade_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mi>e</mi>
    <mi>r</mi>
    <mi>s</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>c</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>e</ci>
     <ci>r</ci>
     <ci>s</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>o</ci>
      <ci>s</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   versin(\theta)=1-cos(\theta)
  </annotation>
 </semantics>
</math>

</p>

<p>which is:</p>

<p>

<math display="inline" id="Hallade_method:1">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mi>L</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mn>8</mn>
     <mi>r</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>v</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">8</cn>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\approx\frac{L^{2}}{8r}
  </annotation>
 </semantics>
</math>

</p>

<p>where v = versine (m) L = chord length (m) r = radius of curve (m)</p>

<p>This formula is also true for other units of measurement such as in feet. The relationship of versine, chord and radius is derived from the <a href="Pythagorean_theorem" title="wikilink">Pythagorean theorem</a>. Based on the diagram on the right:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hallade_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mi>C</mi>
   </mrow>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mrow>
      <mi>O</mi>
      <msup>
       <mi>A</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>A</mi>
      <msup>
       <mi>C</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>C</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   OC=\sqrt{OA^{2}-AC^{2}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>We can replace OC with r (radius) minus v, OA with r and AC with L/2 (half a chord). Then the rearrange formula to:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hallade_method:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mo>-</mo>
     <mi>v</mi>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <msup>
       <mi>r</mi>
       <mn>2</mn>
      </msup>
      <mo>-</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mfrac>
         <mi>L</mi>
         <mn>2</mn>
        </mfrac>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </msqrt>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>r</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r-v=\sqrt{r^{2}-(\frac{L}{2})^{2}},
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Hallade_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>r</mi>
       <mn>2</mn>
      </msup>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>r</mi>
       <mi>v</mi>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>v</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>r</mi>
      <mn>2</mn>
     </msup>
     <mo>-</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mfrac>
        <mi>L</mi>
        <mn>2</mn>
       </mfrac>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>r</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}-2rv+v^{2}=r^{2}-(\frac{L}{2})^{2},
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Hallade_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>r</mi>
     </mrow>
     <mo>-</mo>
     <mi>v</mi>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <msup>
      <mi>L</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mn>4</mn>
      <mi>v</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>r</ci>
     </apply>
     <ci>v</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2r-v=\frac{L^{2}}{4v},
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Hallade_method:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <msup>
       <mi>L</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mn>8</mn>
       <mi>v</mi>
      </mrow>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mi>v</mi>
      <mn>2</mn>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">8</cn>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\frac{L^{2}}{8v}+\frac{v}{2}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Since the curved tracks are usually large, the result of v/2 is very small. To simplify the formula, the approximation is:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hallade_method:7">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mi>L</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mn>8</mn>
     <mi>v</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">8</cn>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\approx\frac{L^{2}}{8v}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Or to find versine of a given constant radius curve, we can use:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hallade_method:8">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mi>L</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mn>8</mn>
     <mi>r</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>v</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">8</cn>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\approx\frac{L^{2}}{8r}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The Hallade method is to use the chord to continuously measure the versine in an overlapping pattern along the curve. The versine values for the perfect circular curve would have the same number.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> By comparing the surveyed versine figures to the design versines, this can then be used to determine what slues should be applied to the track in order to make the curve correctly aligned. This is often done using pegs which are driven into the ground in the cess beside the track to be aligned. The process of putting the pegs in the correct positions is known as 'setting out'. If the curve needs to be of a desired constant radius, which will usually be determined by physical obstructions and the degree of cant which is permitted, the versine can be calculated for the desired radius using this approximation. In practice, many track curves are transition curves and so have changing radii. In order to maintain a smooth transition, the differences in versines between consecutive half chords are measured and minimised.</p>

<p>The <strong>Hallade survey</strong> is a survey method that uses the same principle to measure the versines along an existing curve. Based on the versine values, the radius of that circular curved track can be approximated to:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hallade_method:9">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mi>L</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mn>8</mn>
     <mi>v</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">8</cn>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\approx\frac{L^{2}}{8v}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>This method can be done manually, and this method is still used in the UK. However, due to the complexity of the calculations over long lengths of track, it is now often done by computer,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> with the track geometry data being loaded straight onto a computer controlled <a href="Ballast_tamper" title="wikilink">tamping and lining machine</a> for implementation.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Track_geometry" title="wikilink">Track geometry</a></li>
<li><a href="Track_geometry_car" title="wikilink">Track geometry car</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://home.btconnect.com/Enhance-Ecosse/Hallade1.htm">The Hallade System</a></li>
<li><a href="http://www.steamindex.com/people/civils.htm#surnha">Railway engineers</a></li>
</ul>

<p>"</p>

<p><a href="Category:Track_geometry" title="wikilink">Category:Track geometry</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">:<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
