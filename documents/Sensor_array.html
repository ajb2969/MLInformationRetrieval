<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1065">Sensor array</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sensor array</h1>
<hr/>

<p>A <strong>sensor array</strong> is a group of sensors, usually deployed in a certain geometry pattern, used for collecting and processing electromagnetic or acoustic signals. The advantage of using a sensor array over using a single sensor lies in the fact that an array adds new dimensions to the observation, helping to estimate more parameters and improve the estimation performance. For example an array of radio antenna elements used for beamforming can increase <a href="antenna_gain" title="wikilink">antenna gain</a> in the direction of the signal while decreasing the gain in other directions, i.e., increasing <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a> (<strong>SNR</strong>) by amplifying the signal coherently. Another example of sensor array application is to estimate the <a href="direction_of_arrival" title="wikilink">direction of arrival</a> of impinging electromagnetic waves. The related processing method is called <strong>Array Signal Processing</strong>. Application examples of array signal processing include <a class="uri" href="radar" title="wikilink">radar</a>/<a class="uri" href="sonar" title="wikilink">sonar</a>, wireless communications, <a class="uri" href="seismology" title="wikilink">seismology</a>, machine condition monitoring, astronomical observations <a href="fault_diagnosis" title="wikilink">fault diagnosis</a>, etc.</p>

<p>Using array signal processing, the temporal and spatial properties (or parameters) of the impinging signals interfered by noise and hidden in the data collected by the sensor array can be estimated and revealed. This is known as <a href="parameter_estimation" title="wikilink">parameter estimation</a>.</p>
<figure><b>(Figure)</b>
<figcaption>Figure 1: Linear array and incident angle</figcaption>
</figure>
<h2 id="principles">Principles</h2>

<p>Figure 1 illustrates a six-element uniform linear array (ULA). In this example, the sensor array is assumed to be in the far-field of a signal source so that it can be treated as planar wave.</p>

<p>Parameter estimation takes advantage of the fact that the distance from the source to each antenna in the array is different, which means that the input data at each antenna will be phase-shifted replicas of each other. Eq. (1) shows the calculation for the extra time</p>

<p>

<math display="inline" id="Sensor_array:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Î”</mi>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mrow>
       <mi>cos</mi>
       <mi>Î¸</mi>
      </mrow>
     </mrow>
     <mi>c</mi>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">â€¦</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Î”</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>d</ci>
       <apply>
        <cos></cos>
        <ci>Î¸</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-â€¦</ci>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t_{i}=\frac{(i-1)d\cos\theta}{c},i=1,2,...,M\ \ (1)
  </annotation>
 </semantics>
</math>

</p>

<p>it takes to reach each antenna in the array relative to the first one, where c is the velocity of light. Each sensor is associated with a different delay. Although the delays are small but not trivial. In frequency domain, the delays display as phase shift among the signals received by the sensors. The delays are closely related to the incident angle and the geometry of the sensor array. Given the geometry of the array, the delays or phase differences can be used to estimate the incident angle. Eq. (1) is the mathematical basis behind array signal processing. Simply summing the signals received by the sensors and calculating the mean value give the result</p>

<p>

<math display="inline" id="Sensor_array:1">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>M</mi>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">âˆ‘</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>ğ’™</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mrow>
          <mi mathvariant="normal">Î”</mi>
          <msub>
           <mi>t</mi>
           <mi>i</mi>
          </msub>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <list>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>M</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğ’™</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <apply>
          <times></times>
          <ci>normal-Î”</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\frac{1}{M}\sum_{i=1}^{M}\boldsymbol{x}_{i}(t-\Delta t_{i})\ \ (2)
  </annotation>
 </semantics>
</math>

 .</p>

<p>Because the received signals are out of phase, this mean value does not give an enhanced signal compared with the original source. Heuristically, if we can find weights multiplying to the received signals to set them in phase prior to the summation, the mean value</p>

<p>

<math display="inline" id="Sensor_array:2">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>M</mi>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">âˆ‘</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>ğ’˜</mi>
         <mi>i</mi>
        </msub>
        <msub>
         <mi>ğ’™</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mrow>
           <mi mathvariant="normal">Î”</mi>
           <msub>
            <mi>t</mi>
            <mi>i</mi>
           </msub>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <list>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>M</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ğ’˜</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ğ’™</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <apply>
           <times></times>
           <ci>normal-Î”</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>t</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">3</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\frac{1}{M}\sum_{i=1}^{M}[\boldsymbol{w}_{i}\boldsymbol{x}_{i}(t-\Delta t_{i%
})]\ \ (3)
  </annotation>
 </semantics>
</math>

</p>

<p>will result in an enhanced signal. The process of multiplying a well selected set of weights to the signals received by the sensor array so that the signal is added constructively while suppressing the noise is called <strong><a class="uri" href="beamforming" title="wikilink">beamforming</a></strong>. There are a variety of beamforming algorithms for sensor arrays, such as the delay-and-sum approach, spectral based (non-parametric) approaches and parametric approaches. These beamforming algorithms are briefly described as follows.</p>
<h2 id="array-design">Array Design</h2>

<p>Sensor arrays have different geometrical designs, including linear, circular, planar, cylindrical and spherical arrays. There are sensor arrays with arbitrary array configuration, which require more complex signal processing techniques for parameter estimation. In uniform linear array (ULA) the phase of the incoming signal 

<math display="inline" id="Sensor_array:3">
 <semantics>
  <mrow>
   <mi>Ï‰</mi>
   <mi>Ï„</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Ï‰</ci>
    <ci>Ï„</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega\tau
  </annotation>
 </semantics>
</math>


 should be limited to 

<math display="inline" id="Sensor_array:4">
 <semantics>
  <mrow>
   <mo>Â±</mo>
   <mi>Ï€</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <ci>Ï€</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm\pi
  </annotation>
 </semantics>
</math>

 to avoid grating waves. It means that for angle of arrival 

<math display="inline" id="Sensor_array:5">
 <semantics>
  <mi>Î¸</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Î¸</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 in the interval 

<math display="inline" id="Sensor_array:6">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mi>Ï€</mi>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mfrac>
    <mi>Ï€</mi>
    <mn>2</mn>
   </mfrac>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <ci>Ï€</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>Ï€</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [-\frac{\pi}{2},\frac{\pi}{2}]
  </annotation>
 </semantics>
</math>

 sensor spacing sould be smaller than half the wavelength 

<math display="inline" id="Sensor_array:7">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>â‰¤</mo>
   <mrow>
    <mi>Î»</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>d</ci>
    <apply>
     <divide></divide>
     <ci>Î»</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\leq\lambda/2
  </annotation>
 </semantics>
</math>

. However, the width of the main beam, i.e., the resolution or directivity of the array, is determined by the length of the array compared to the wavelength. In order to have a decent directional resolution the length of the array should be several times larger than the radio wavelength.</p>
<h2 id="types-of-sensor-arrays">Types of sensor arrays</h2>
<h3 id="antenna-array">Antenna array</h3>
<ul>
<li><a href="Antenna_array_(electromagnetic)" title="wikilink">Antenna array (electromagnetic)</a>, a geometrical arrangement of antenna elements with a deliberate relationship between their currents, forming a single antenna usually to achieve a desired radiation pattern</li>
<li><a href="Directional_array" title="wikilink">Directional array</a>, an antenna array optimized for directionality</li>
<li><a href="Phased_array" title="wikilink">Phased array</a>, An antenna array where the phase shifts (and amplitudes) applied to the elements are modified electronically, typically in order to steer the antenna system's directional pattern, without the use of moving parts</li>
<li><a href="Smart_antenna" title="wikilink">Smart antenna</a>, a phased array in which a signal processor computes phase shifts to optimize reception and/or transmission to a receiver on the fly, such as is performed by cellular telephone towers</li>
<li><a href="Interferometry" title="wikilink">Interferometric array</a> of radio telescopes or optical telescopes, used to achieve high resolution through interferometric correlation</li>
<li><a href="Direction_finding#Watson-Watt_.2F_Adcock_antenna_array" title="wikilink">Watson-Watt / Adcock antenna array</a>, using the Watson-Watt technique whereby two Adcock antenna pairs are used to perform an amplitude comparison on the incoming signal</li>
</ul>
<h3 id="acoustic-arrays">Acoustic arrays</h3>
<ul>
<li><a href="Microphone_array" title="wikilink">Microphone array</a> is used in acoustic measurement and beamforming</li>
<li><a href="Line_array" title="wikilink">Loudspeaker array</a> is used in acoustic measurement and beamforming</li>
</ul>
<h3 id="other-arrays">Other arrays</h3>
<ul>
<li><a href="Geophone" title="wikilink">Geophone array</a> used in <a href="Reflection_seismology" title="wikilink">Reflection seismology</a></li>
<li><a href="Towed_array_sonar" title="wikilink">Sonar array</a> is an array of hydrophones used in underwater imaging</li>
</ul>
<h2 id="delay-and-sum-beamforming">Delay-and-sum beamforming</h2>

<p>If a time delay is added to the recorded signal from each microphone that is equal and opposite of the delay caused by the additional travel time, it will result in signals that are perfectly in-phase with each other. Summing these in-phase signals will result in constructive interference that will amplify the SNR by the number of antennas in the array. This is known as delay-and-sum beamforming. For direction of arrival (DOA) estimation, one can iteratively test time delays for all possible directions. If the guess is wrong, the signal will be interfered destructively, resulting in a diminished output signal, but the correct guess will result in the signal amplification described above.</p>

<p>The problem is, before the incident angle is estimated, how could it be possible to know the time delay that is 'equal' and opposite of the delay caused by the extra travel time? It is impossible. The solution is to try a series of angles 

<math display="inline" id="Sensor_array:8">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>Î¸</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>âˆˆ</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi>Ï€</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>normal-^</ci>
     <ci>Î¸</ci>
    </apply>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <ci>Ï€</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\theta}\in[0,\pi]
  </annotation>
 </semantics>
</math>


 at sufficiently high resolution, and calculate the resulting mean output signal of the array using Eq. (3). The trial angle that maximizes the mean output is an estimation of DOA given by the delay-and-sum beamformer. Adding an opposite delay to the input signals is equivalent to rotating the sensor array physically. Therefore, it is also known as <strong>beam steering</strong>.</p>
<h2 id="spectrum-based-beamforming">Spectrum-based beamforming</h2>

<p>Delay and sum beamforming is a time domain approach. It is simple to implement, but it may poorly estimate direction of arrival (DOA): if the signal is contaminated with strong noise, it might be difficult to implement the algorithm. The solution to this is a frequency domain approach. The <a href="Fourier_transform" title="wikilink">Fourier transform</a> transforms the signal from the time domain to the frequency domain. This converts the time delay between adjacent sensors into a phase shift. Thus, the array output vector at any time <em>t</em> can be denoted as 

<math display="inline" id="Sensor_array:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ’™</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mrow>
      <mo>[</mo>
      <mtable>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mi>j</mi>
            <mi>Ï‰</mi>
            <mi mathvariant="normal">Î”</mi>
            <mi>t</mi>
           </mrow>
          </mrow>
         </msup>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">â‹¯</mi>
        </mtd>
        <mtd columnalign="center">
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mi>j</mi>
            <mi>Ï‰</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>M</mi>
              <mo>-</mo>
              <mn>1</mn>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
            <mi mathvariant="normal">Î”</mi>
            <mi>t</mi>
           </mrow>
          </mrow>
         </msup>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğ’™</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>j</ci>
           <ci>Ï‰</ci>
           <ci>normal-Î”</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <ci>normal-â‹¯</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>j</ci>
           <ci>Ï‰</ci>
           <apply>
            <minus></minus>
            <ci>M</ci>
            <cn type="integer">1</cn>
           </apply>
           <ci>normal-Î”</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </matrixrow>
      </matrix>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{x}(t)=x_{1}(t)\begin{bmatrix}1&e^{-j\omega\Delta t}&\cdots&e^{-j%
\omega(M-1)\Delta t}\end{bmatrix}^{T}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Sensor_array:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}(t)
  </annotation>
 </semantics>
</math>

 stands for the signal received by the first sensor. Frequency domain beamforming algorithms use the spatial covariance matrix, represented by 

<math display="inline" id="Sensor_array:11">
 <semantics>
  <mrow>
   <mi>ğ‘¹</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>ğ’™</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>ğ’™</mi>
       <mi>T</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ‘¹</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <set>
      <apply>
       <times></times>
       <ci>ğ’™</ci>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ’™</ci>
        <ci>T</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{R}=E\{\boldsymbol{x}(t)\boldsymbol{x}^{T}(t)\}
  </annotation>
 </semantics>
</math>

. This <em>M</em> by <em>M</em> matrix carries the spatial and spectral information of the incoming signals. Assuming zero-mean Gaussian <a href="white_noise" title="wikilink">white noise</a>, the basic model of the spatial covariance matrix is given by</p>

<p>

<math display="inline" id="Sensor_array:12">
 <semantics>
  <mrow>
   <mi>ğ‘¹</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>ğ‘½</mi>
      <mi>ğ‘º</mi>
      <msup>
       <mi>ğ‘½</mi>
       <mi>H</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>Ïƒ</mi>
       <mn>2</mn>
      </msup>
      <mi>ğ‘°</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>4</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ‘¹</ci>
    <list>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>ğ‘½</ci>
       <ci>ğ‘º</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ‘½</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Ïƒ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>ğ‘°</ci>
      </apply>
     </apply>
     <cn type="integer">4</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{R}=\boldsymbol{V}\boldsymbol{S}\boldsymbol{V}^{H}+\sigma^{2}%
\boldsymbol{I}\ \ (4)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Sensor_array:13">
 <semantics>
  <msup>
   <mi>Ïƒ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Ïƒ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>


 is the variance of the white noise, 

<math display="inline" id="Sensor_array:14">
 <semantics>
  <mi>ğ‘°</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ‘°</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{I}
  </annotation>
 </semantics>
</math>

 is the identity matrix and 

<math display="inline" id="Sensor_array:15">
 <semantics>
  <mi>ğ‘½</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ‘½</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{V}
  </annotation>
 </semantics>
</math>

 is the array manifold vector 

<math display="inline" id="Sensor_array:16">
 <semantics>
  <mrow>
   <mi>ğ‘½</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>[</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>ğ’—</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹¯</mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>ğ’—</mi>
         <mi>k</mi>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ‘½</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ’—</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-â‹¯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ’—</ci>
        <ci>k</ci>
       </apply>
      </matrixrow>
     </matrix>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{V}=\begin{bmatrix}\boldsymbol{v}_{1}&\cdots&\boldsymbol{v}_{k}\end%
{bmatrix}^{T}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Sensor_array:17">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ’—</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>[</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <msup>
         <mi>e</mi>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mi>j</mi>
           <mi>Ï‰</mi>
           <mi mathvariant="normal">Î”</mi>
           <msub>
            <mi>t</mi>
            <mi>i</mi>
           </msub>
          </mrow>
         </mrow>
        </msup>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹¯</mi>
       </mtd>
       <mtd columnalign="center">
        <msup>
         <mi>e</mi>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mi>j</mi>
           <mi>Ï‰</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>M</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi mathvariant="normal">Î”</mi>
           <msub>
            <mi>t</mi>
            <mi>i</mi>
           </msub>
          </mrow>
         </mrow>
        </msup>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ’—</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>Ï‰</ci>
          <ci>normal-Î”</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>normal-â‹¯</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>Ï‰</ci>
          <apply>
           <minus></minus>
           <ci>M</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-Î”</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{v}_{i}=\begin{bmatrix}1&e^{-j\omega\Delta t_{i}}&\cdots&e^{-j%
\omega(M-1)\Delta t_{i}}\end{bmatrix}^{T}
  </annotation>
 </semantics>
</math>

. This model is of central importance in frequency domain beamforming algorithms.</p>

<p>Some spectrum-based beamforming approaches are listed below.</p>
<h3 id="conventional-bartlett-beamformer">Conventional (Bartlett) beamformer</h3>

<p>The Bartlett beamformer is a natural extension of conventional spectral analysis (<a class="uri" href="spectrogram" title="wikilink">spectrogram</a>) to the sensor array. Its spectral power is represented by</p>

<p>

<math display="inline" id="Sensor_array:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>P</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>B</mi>
      <mi>a</mi>
      <mi>r</mi>
      <mi>t</mi>
      <mi>l</mi>
      <mi>e</mi>
      <mi>t</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Î¸</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ğ’—</mi>
      <mi>H</mi>
     </msup>
     <mi>ğ‘¹</mi>
     <mi>ğ’—</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>5</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>a</ci>
       <ci>r</ci>
       <ci>t</ci>
       <ci>l</ci>
       <ci>e</ci>
       <ci>t</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>Î¸</ci>
    </apply>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ’—</ci>
       <ci>H</ci>
      </apply>
      <ci>ğ‘¹</ci>
      <ci>ğ’—</ci>
     </apply>
     <cn type="integer">5</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{P}_{Bartlett}(\theta)=\boldsymbol{v}^{H}\boldsymbol{R}\boldsymbol{v}\ \ (5)
  </annotation>
 </semantics>
</math>


.</p>

<p>The angle that maximizes this power is an estimation of the angle of arrival.</p>
<h3 id="mvdr-capon-beamformer">MVDR (Capon) beamformer</h3>

<p>The Minimum Variance Distortionless Response beamformer, also known as the Capon beamforming algorithm, has a power given by</p>

<p>

<math display="inline" id="Sensor_array:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>P</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>C</mi>
      <mi>a</mi>
      <mi>p</mi>
      <mi>o</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Î¸</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msup>
       <mi>ğ’—</mi>
       <mi>H</mi>
      </msup>
      <msup>
       <mi>ğ‘¹</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>ğ’—</mi>
     </mrow>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>6</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>a</ci>
       <ci>p</ci>
       <ci>o</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>Î¸</ci>
    </apply>
    <list>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ’—</ci>
        <ci>H</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ‘¹</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>ğ’—</ci>
      </apply>
     </apply>
     <cn type="integer">6</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{P}_{Capon}(\theta)=\frac{1}{\boldsymbol{v}^{H}\boldsymbol{R}^{-1}%
\boldsymbol{v}}\ \ (6)
  </annotation>
 </semantics>
</math>

.</p>

<p>Though the MVDR/Capon beamformer can achieve better resolution than the conventional (Bartlett) approach, but this algorithm has higher complexity due to the full-rank matrix inversion. Technical advances in <a href="General-purpose_computing_on_graphics_processing_units" title="wikilink">GPU computing</a> have begun to narrow this gap and make real-time Capon beamforming possible.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="music-beamformer">MUSIC Beamformer</h3>

<p>MUSIC (<a href="Multiple_signal_classification" title="wikilink">MUltiple SIgnal Classification</a>) beamforming algorithm starts with decomposing the covariance matrix as given by Eq. (4) for both the signal part and the noise part. The eigen-decomposition of is represented by</p>

<p>

<math display="inline" id="Sensor_array:20">
 <semantics>
  <mrow>
   <mi>ğ‘¹</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>ğ‘¼</mi>
       <mi>s</mi>
      </msub>
      <msub>
       <mi>ğš²</mi>
       <mi>s</mi>
      </msub>
      <msubsup>
       <mi>ğ‘¼</mi>
       <mi>s</mi>
       <mi>H</mi>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>ğ‘¼</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>ğš²</mi>
       <mi>n</mi>
      </msub>
      <msubsup>
       <mi>ğ‘¼</mi>
       <mi>n</mi>
       <mi>H</mi>
      </msubsup>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>7</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ‘¹</ci>
    <list>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ‘¼</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğš²</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğ‘¼</ci>
         <ci>s</ci>
        </apply>
        <ci>H</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ‘¼</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğš²</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğ‘¼</ci>
         <ci>n</ci>
        </apply>
        <ci>H</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">7</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{R}=\boldsymbol{U}_{s}\boldsymbol{\Lambda}_{s}\boldsymbol{U}_{s}^{H%
}+\boldsymbol{U}_{n}\boldsymbol{\Lambda}_{n}\boldsymbol{U}_{n}^{H}\ \ (7)
  </annotation>
 </semantics>
</math>

.</p>

<p>MUSIC uses the noise sub-space of the spatial covariance matrix in the denominator of the Capon algorithm</p>

<p>

<math display="inline" id="Sensor_array:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>P</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>M</mi>
      <mi>U</mi>
      <mi>S</mi>
      <mi>I</mi>
      <mi>C</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Î¸</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msup>
       <mi>ğ’—</mi>
       <mi>H</mi>
      </msup>
      <msub>
       <mi>ğ‘¼</mi>
       <mi>n</mi>
      </msub>
      <msubsup>
       <mi>ğ‘¼</mi>
       <mi>n</mi>
       <mi>H</mi>
      </msubsup>
      <mi>ğ’—</mi>
     </mrow>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>8</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>U</ci>
       <ci>S</ci>
       <ci>I</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <ci>Î¸</ci>
    </apply>
    <list>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ’—</ci>
        <ci>H</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ‘¼</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğ‘¼</ci>
         <ci>n</ci>
        </apply>
        <ci>H</ci>
       </apply>
       <ci>ğ’—</ci>
      </apply>
     </apply>
     <cn type="integer">8</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{P}_{MUSIC}(\theta)=\frac{1}{\boldsymbol{v}^{H}\boldsymbol{U}_{n}%
\boldsymbol{U}_{n}^{H}\boldsymbol{v}}\ \ (8)
  </annotation>
 </semantics>
</math>

.</p>

<p>Therefore MUSIC beamformer is also known as subspace beamformer. Compared to the Capon beamformer, it gives much better DOA estimation.</p>
<h2 id="parametric-beamformers">Parametric beamformers</h2>

<p>One of the major advantages of the spectral based beamformers is a lower computational complexity, but they may not give accurate DOA estimation if the signals are correlated or coherent. An alternative approach are parametric beamformers, also known as <strong><a href="Maximum_likelihood" title="wikilink">Maximum Likelihood (ML)</a></strong> beamformers. One example of a maximum likelihood method commonly used in engineering is the <a href="least_squares" title="wikilink">least squares</a> method. In the least square approach, a quadratic penalty function is used. To get the minimum value (or least squared error) of the quadratic penalty function (or <a href="objective_function" title="wikilink">objective function</a>), take its derivative (which is linear), let it equal zero and solve a system of linear equations.</p>

<p>In ML Beamformers the quadratic penalty function is used to the spatial covariance matrix and the signal model. One example of ML beamformer penalty function is</p>

<p>

<math display="inline" id="Sensor_array:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>M</mi>
       <mi>L</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Î¸</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msubsup>
     <mrow>
      <mo>âˆ¥</mo>
      <mrow>
       <mover accent="true">
        <mi>ğ‘¹</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo>-</mo>
       <mi>ğ‘¹</mi>
      </mrow>
      <mo>âˆ¥</mo>
     </mrow>
     <mi>F</mi>
     <mn>2</mn>
    </msubsup>
    <mo>=</mo>
    <msubsup>
     <mrow>
      <mo>âˆ¥</mo>
      <mrow>
       <mover accent="true">
        <mi>ğ‘¹</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>ğ‘½</mi>
          <mi>ğ‘º</mi>
          <msup>
           <mi>ğ‘½</mi>
           <mi>H</mi>
          </msup>
         </mrow>
         <mo>+</mo>
         <mrow>
          <msup>
           <mi>Ïƒ</mi>
           <mn>2</mn>
          </msup>
          <mi>ğ‘°</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>âˆ¥</mo>
     </mrow>
     <mi>F</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>9</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>M</ci>
         <ci>L</ci>
        </apply>
       </apply>
       <ci>Î¸</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <ci>normal-^</ci>
           <ci>ğ‘¹</ci>
          </apply>
          <ci>ğ‘¹</ci>
         </apply>
        </apply>
        <ci>F</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <ci>normal-^</ci>
           <ci>ğ‘¹</ci>
          </apply>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <ci>ğ‘½</ci>
            <ci>ğ‘º</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>ğ‘½</ci>
             <ci>H</ci>
            </apply>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>Ïƒ</ci>
             <cn type="integer">2</cn>
            </apply>
            <ci>ğ‘°</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <ci>F</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">9</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{ML}(\theta)=\|\hat{\boldsymbol{R}}-\boldsymbol{R}\|_{F}^{2}=\|\hat{%
\boldsymbol{R}}-(\boldsymbol{V}\boldsymbol{S}\boldsymbol{V}^{H}+\sigma^{2}%
\boldsymbol{I})\|_{F}^{2}\ \ (9)
  </annotation>
 </semantics>
</math>

 ,</p>

<p>where 

<math display="inline" id="Sensor_array:23">
 <semantics>
  <mrow>
   <mo>âˆ¥</mo>
   <mo>â‹…</mo>
   <msub>
    <mo>âˆ¥</mo>
    <mi>F</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">parallel-to</csymbol>
    <ci>normal-â‹…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <ci>F</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\cdot\|_{F}
  </annotation>
 </semantics>
</math>


 is the Frobenius norm. It can be seen in Eq. (4) that the penalty function of Eq. (9) is minimized by approximating the signal model to the sample covariance matrix as accurate as possible. In other words, the Maximum Likelihood beamformer is to find the DOA 

<math display="inline" id="Sensor_array:24">
 <semantics>
  <mi>Î¸</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Î¸</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

, the independent variable of matrix 

<math display="inline" id="Sensor_array:25">
 <semantics>
  <mi>ğ‘½</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ‘½</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{V}
  </annotation>
 </semantics>
</math>

, so that the penalty function in Eq. (9) is minimized. In practice, the penalty function may look different, depending on the signal and noise model. For this reason, there are two major categories of maximum likelihood beamformers: Deterministic ML beamformers and stochastic ML beamformers, corresponding to a deterministic and a <a class="uri" href="stochastic" title="wikilink">stochastic</a> model, respectively.</p>

<p>Another idea to change the former penalty equation is the consideration of simplifying the minimization by differentiation of the penalty function. In order to simplify the <a class="uri" href="optimization" title="wikilink">optimization</a> algorithm, logarithmic operations and the <a href="Probability_density_function" title="wikilink">probability density function (PDF)</a> of the observations may be used in some ML beamformers.</p>

<p>The optimizing problem is solved by finding the roots of the derivative of the penalty function after equating it with zero. Because the equation is non-linear a numerical searching approach such as <a href="Newtonâ€“Raphson_method" title="wikilink">Newtonâ€“Raphson method</a> is usually employed. The Newtonâ€“Raphson method is an iterative root search method with the iteration</p>

<p>

<math display="inline" id="Sensor_array:26">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>â€²</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>10</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-â€²</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">10</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f(x_{n})}{f^{\prime}(x_{n})}\ \ (10)
  </annotation>
 </semantics>
</math>

.</p>

<p>The search starts from an initial guess 

<math display="inline" id="Sensor_array:27">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

. If the Newton-Raphson search method is employed to minimize the beamforming penalty function, the resulting beamformer is called Newton ML beamformer. Several well-known ML beamformers are described below without providing further details due to the complexity of the expressions.</p>
<dl>
<dt>Deterministic Maximum Likelihood Beamformer</dt>
<dd>In Deterministic Maximum Likelihood Beamformer (<strong>DML</strong>), the noise is modeled as a stationary Gaussian white random processes while the signal waveform as deterministic (but arbitrary) and unknown.
</dd>
</dl>
<dl>
<dt>Stochastic Maximum Likelihood Beamformer</dt>
<dd>In Stochastic Maximum Likelihood Beamformer (<strong>SML</strong>), the noise is modeled as stationary Gaussian white random processes (the same as in DML) whereas the signal waveform as Gaussian random processes.
</dd>
</dl>
<dl>
<dt>Method of Direction Estimation</dt>
<dd>Method of Direction Estimation (<strong>MODE</strong>) is subspace maximum likelihood beamformer, just as <strong>MUSIC</strong>, is the subspace spectral based beamformer. Subspace ML beamforming is obtained by <a href="Eigendecomposition_of_a_matrix" title="wikilink">eigen-decomposition</a> of the sample covariance matrix.
</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li>H. L. Van Trees, â€œOptimum array processing â€“ Part IV of detection, estimation, and modulation theoryâ€, John Wiley, 2002</li>
<li>H. Krim and M. Viberg, â€œTwo decades of array signal processing researchâ€, IEEE Transactions on Signal Processing Magazine, July 1996</li>
<li>S. Haykin, Ed., â€œArray Signal Processingâ€, Eaglewood Cliffs, NJ: Prentice-Hall, 1985</li>
<li>S. U. Pillai, â€œArray Signal Processingâ€, New York: Springer-Verlag, 1989</li>
<li>P. Stoica and R. Moses, â€œIntroduction to Spectral Analysis", Prentice-Hall, Englewood Cliffs, USA, 1997. <a href="http://user.it.uu.se/~ps/SAS-new.pdf">available for download.</a></li>
<li>J. Li and P. Stoica, â€œRobust Adaptive Beamforming", John Wiley, 2006.</li>
<li>J. Cadzow, â€œMultiple Source Locationâ€”The Signal Subspace Approachâ€, IEEE Transactions on Acoustics, Speech and Signal Processing, Vol. 38, No. 7, July 1990</li>
<li>G. Bienvenu and L. Kopp, â€œOptimality of high resolution array processing using the eigensystem approachâ€, IEEE Transactions on Acoustics, Speech and Signal Process, Vol. ASSP-31, pp.Â 1234â€“1248, October 1983</li>
<li>I. Ziskind and M. Wax, â€œMaximum likelihood localization of multiple sources by alternating projectionâ€, IEEE Transactions on Acoustics, Speech and Signal Process, Vol. ASSP-36, pp.Â 1553â€“1560, October 1988</li>
<li>B. Ottersten, M. Verberg, P. Stoica, and A. Nehorai, â€œExact and large sample maximum likelihood techniques for parameter estimation and detection in array processingâ€, Radar Array Processing, Springer-Verlag, Berlin, pp.Â 99â€“151, 1993</li>
<li>M. Viberg, B. Ottersten, and T. Kailath, â€œDetection and estimation in sensor arrays using weighted subspace fittingâ€, IEEE Transactions on Signal Processing, vol. SP-39, pp 2346â€“2449, November 1991</li>
<li>M. Feder and E. Weinstein, â€œParameter estimation of superimposed signals using the EM algorithmâ€, IEEE Transactions on Acoustic, Speech and Signal Proceeding, vol ASSP-36, pp.Â 447â€“489, April 1988</li>
<li>Y. Bresler and Macovski, â€œExact maximum likelihood parameter estimation of superimposed exponential signals in noiseâ€, IEEE Transactions on Acoustic, Speech and Signal Proceeding, vol ASSP-34, pp.Â 1081â€“1089, October 1986</li>
<li>R. O. Schmidt, â€œNew mathematical tools in direction finding and spectral analysisâ€, Proceedings of SPIE 27th Annual Symposium, San Diego, California, August 1983</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Sensors" title="wikilink">Category:Sensors</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6689777&amp;sortType;%3Dasc_p_Sequence%26filter%3DAND%28p_IS_Number%3A6689765%29">http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6689777&amp;sortType;%3Dasc_p_Sequence%26filter%3DAND%28p_IS_Number%3A6689765%29</a><a href="#fnref1">â†©</a></li>
</ol>
</section>
</body>
</html>
