   Jacobi eigenvalue algorithm      Jacobi eigenvalue algorithm   In numerical linear algebra , the Jacobi eigenvalue algorithm is an iterative method for the calculation of the eigenvalues and eigenvectors of a real  symmetric matrix (a process known as diagonalization ). It is named after Carl Gustav Jacob Jacobi , who first proposed the method in 1846, 1 but only became widely used in the 1950s with the advent of computers. 2  Description  Let S be a symmetric matrix, and G = G ( i , j , θ ) be a Givens rotation matrix . Then:       S  ′   =   G  S    G  ⊤          superscript  S  normal-′     G  S   superscript  G  top      S^{\prime}=GSG^{\top}\,     is symmetric and similar to S .  Furthermore, S′ has entries:      S   i  i   ′     subscript   superscript  S  normal-′     i  i     \displaystyle S^{\prime}_{ii}     where s = sin( θ ) and c = cos( θ ).  Since G is orthogonal, S and S ′ have the same Frobenius norm ||·|| F (the square-root sum of squares of all components), however we can choose θ such that S ′ ij = 0, in which case S ′ has a larger sum of squares on the diagonal:       S   i  j   ′   =     cos   (   2  θ   )     S   i  j     +     1  2     sin   (   2  θ   )     (    S   i  i    -   S   j  j     )          subscript   superscript  S  normal-′     i  j            2  θ     subscript  S    i  j         1  2       2  θ       subscript  S    i  i     subscript  S    j  j         S^{\prime}_{ij}=\cos(2\theta)S_{ij}+\tfrac{1}{2}\sin(2\theta)(S_{ii}-S_{jj})     Set this equal to 0, and rearrange:       tan   (   2  θ   )    =    2   S   i  j       S   j  j    -   S   i  i              2  θ        2   subscript  S    i  j        subscript  S    j  j     subscript  S    i  i        \tan(2\theta)=\frac{2S_{ij}}{S_{jj}-S_{ii}}     if     S   j  j    =   S   i  i         subscript  S    j  j     subscript  S    i  i      S_{jj}=S_{ii}         θ  =   π  4       θ    π  4     \theta=\frac{\pi}{4}     In order to optimize this effect, S ij should be the off-diagonal component with the largest absolute value, called the pivot .  The Jacobi eigenvalue method repeatedly performs rotations until the matrix becomes almost diagonal. Then the elements in the diagonal are approximations of the (real) eigenvalues of S .  Convergence  If    p  =   S   k  l        p   subscript  S    k  l      p=S_{kl}   is a pivot element, then by definition     |   S   i  j    |   ≤   |  p  |          subscript  S    i  j       p     |S_{ij}|\leq|p|   for     1  ≤  i   ,    j  ≤  n   ,   i  ≠  j       formulae-sequence    1  i    formulae-sequence    j  n     i  j      1\leq i,j\leq n,i\neq j   . Since ''S '' has exactly 2'' N '':= ''n ''( ''n '' - 1) off-diag elements, we have     p  2   ≤   Γ    (  S  )   2    ≤   2  N   p  2           superscript  p  2     normal-Γ   superscript  S  2           2  N   superscript  p  2       p^{2}\leq\Gamma(S)^{2}\leq 2Np^{2}   or     2   p  2    ≥    Γ    (  S  )   2    /  N         2   superscript  p  2        normal-Γ   superscript  S  2    N     2p^{2}\geq\Gamma(S)^{2}/N   . This implies        Γ    (   S  J   )   2    ≤    (   1  -   1  /  N    )   Γ    (  S  )   2          normal-Γ   superscript   superscript  S  J   2        1    1  N    normal-Γ   superscript  S  2      \Gamma(S^{J})^{2}\leq(1-1/N)\Gamma(S)^{2}    or      Γ   (   S  J   )    ≤     (   1  -   1  /  N    )    1  /  2    Γ   (  S  )          normal-Γ   superscript  S  J       superscript    1    1  N      1  2    normal-Γ  S     \Gamma(S^{J})\leq(1-1/N)^{1/2}\Gamma(S)    ,  i.e. the sequence of Jacobi rotations converges at least linearly by a factor     (   1  -   1  /  N    )    1  /  2      superscript    1    1  N      1  2     (1-1/N)^{1/2}   to a diagonal matrix.  A number of ''N '' Jacobi rotations is called a sweep; let    S  σ     superscript  S  σ    S^{\sigma}   denote the result. The previous estimate yields       Γ   (   S  σ   )    ≤     (   1  -   1  /  N    )    N  /  2    Γ   (  S  )          normal-Γ   superscript  S  σ       superscript    1    1  N      N  2    normal-Γ  S     \Gamma(S^{\sigma})\leq(1-1/N)^{N/2}\Gamma(S)   , i.e. the sequence of sweeps converges at least linearly with a factor ≈    e   1  /  2      superscript  e    1  2     e^{1/2}   .  However the following result of Schönhage 3 yields locally quadratic convergence. To this end let S have m distinct eigenvalues     λ  1   ,  …  ,   λ  m       subscript  λ  1   normal-…   subscript  λ  m     \lambda_{1},...,\lambda_{m}   with multiplicities     ν  1   ,  …  ,   ν  m       subscript  ν  1   normal-…   subscript  ν  m     \nu_{1},...,\nu_{m}   and let d > 0 be the smallest distance of two different eigenvalues. Let us call a number of       N  S   :=     1  2   n   (   n  -  1   )    -    ∑   μ  =  1   m     1  2    ν  μ    (    ν  μ   -  1   )      ≤  N       assign   subscript  N  S         1  2   n    n  1      superscript   subscript     μ  1    m       1  2    subscript  ν  μ      subscript  ν  μ   1           N     N_{S}:=\frac{1}{2}n(n-1)-\sum_{\mu=1}^{m}\frac{1}{2}\nu_{\mu}(\nu_{\mu}-1)\leq
 N     Jacobi rotations a Schönhage-sweep. If    S  s     superscript  S  s    S^{s}   denotes the result then        Γ   (   S  s   )    ≤      n  2   -  1      γ  2    d  -   2  γ       ,   γ  :=   Γ   (  S  )        formulae-sequence      normal-Γ   superscript  S  s            n  2   1       superscript  γ  2     d    2  γ        assign  γ    normal-Γ  S      \Gamma(S^{s})\leq\sqrt{\frac{n}{2}-1}\frac{\gamma^{2}}{d-2\gamma},\quad\gamma:%
 =\Gamma(S)   .  Thus convergence becomes quadratic as soon as     Γ   (  S  )    <   d  /   (   2  +     n  2   -  1     )          normal-Γ  S     d    2        n  2   1        \Gamma(S)     Cost  Each Jacobi rotation can be done in n steps when the pivot element p is known. However the search for p requires inspection of all N ≈ ½ n 2 off-diag elements. We can reduce this to n steps too if we introduce an additional index array     m  1   ,   …   ,   m   n  -  1        subscript  m  1   normal-…   subscript  m    n  1      m_{1},\,\dots\,,\,m_{n-1}   with the property that    m  i     subscript  m  i    m_{i}   is the index of the largest element in row i , ( i = 1, …, n − 1) of the current S . Then ( k , l ) must be one of the pairs    (  i  ,   m  i   )     i   subscript  m  i     (i,m_{i})   . Since only columns k and l change, only     m  k   and   m  l        subscript  m  k   and   subscript  m  l     m_{k}\mbox{ and }m_{l}   must be updated, which again can be done in n steps. Thus each rotation has O( n ) cost and one sweep has O( n 3 ) cost which is equivalent to one matrix multiplication. Additionally the    m  i     subscript  m  i    m_{i}   must be initialized before the process starts, this can be done in n 2 steps.  Typically the Jacobi method converges within numerical precision after a small number of sweeps. Note that multiple eigenvalues reduce the number of iterations since     N  S   <  N       subscript  N  S   N    N_{S}   .  Algorithm  The following algorithm is a description of the Jacobi method in math-like notation. It calculates a vector e which contains the eigenvalues and a matrix E which contains the corresponding eigenvectors, i.e.    e  i     subscript  e  i    e_{i}   is an eigenvalue and the column    E  i     subscript  E  i    E_{i}   an orthonormal eigenvector for    e  i     subscript  e  i    e_{i}   , i = 1, …, n .  procedure jacobi( S ∈ R n × n ; out  e ∈ R n ; out  E ∈ R n × n )   var   i , k , l , m , state ∈ N   s , c , t , p , y , d , r ∈ R   ind ∈ N n   changed ∈ L n    function maxind( k ∈ N ) ∈ N ! index  of  largest  off-diagonal  element  in  row  k   m := k +1   for  i := k +2 to  n  do   if │ S ki │ > │ S km │ then  m := i  endif   endfor   return  m   endfunc    procedure update( k ∈ N ; t ∈ R ) ! update  e k  and  its  status   y := e k ; e k := y + t   if  changed k and ( y = e k ) then  changed k := false; state := state −1   elsif (not changed k ) and ( y ≠ e k ) then  changed k := true; state := state +1   endif   endproc    procedure rotate( k , l , i , j ∈ N ) ! perform  rotation  of  S ij ,  S kl  ┌ ┐    ┌     ┐┌ ┐  │ S kl │    │ c − s ││ S kl │  │ │ := │     ││ │  │ S ij │    │ s  c ││ S ij │  └ ┘    └     ┘└ ┘   endproc   ! init  e,  E,  and  arrays  ind,  changed   E := I ; state := n   for  k := 1 to  n  do  ind k := maxind( k ); e k := S kk ; changed k := true endfor   while  state ≠0 do ! next  rotation   m := 1 ! find  index  (k,l)  of  pivot  p   for  k := 2 to  n −1 do   if │ S k  ind k │ > │ S m  ind m │ then  m := k  endif   endfor   k := m ; l := ind m ; p := S kl  ! calculate  c  =  cos  φ,  s  =  sin  φ   y := ( e l − e k )/2; d := │ y │+√( p 2 + y 2 )   r := √( p 2 + d 2 ); c := d / r ; s := p / r ; t := p 2 / d   if  y kl := 0.0; update( k ,− t ); update( l , t )  ! ''rotate rows and columns k and l   for  i := 1 to  k −1 do rotate( i , k , i , l ) endfor   for  i := k +1 to  l −1 do rotate( k , i , i , l ) endfor   for  i := l +1 to  n  do rotate( k , i , l , i ) endfor  ! rotate  eigenvectors   for  i := 1 to  n  do  ┌ ┐    ┌     ┐┌ ┐  │ E ki │    │ c − s ││ E ki │  │ │ := │     ││ │  │ E li │    │ s  c ││ E li │  └ ┘    └     ┘└ ┘   endfor  ! rows  k,  l  have  changed,  update  rows  ind k ,  ind l   ind k := maxind( k ); ind l := maxind( l )   loop  endproc  Notes  1. The logical array changed holds the status of each eigenvalue. If the numerical value of    e  k     subscript  e  k    e_{k}   or    e  l     subscript  e  l    e_{l}   changes during an iteration, the corresponding component of changed is set to true , otherwise to false . The integer state counts the number of components of changed which have the value true . Iteration stops as soon as state = 0. This means that none of the approximations     e  1   ,   …   ,   e  n       subscript  e  1   normal-…   subscript  e  n     e_{1},\,...\,,e_{n}   has recently changed its value and thus it is not very likely that this will happen if iteration continues. Here it is assumed that floating point operations are optimally rounded to the nearest floating point number.  2. The upper triangle of the matrix S is destroyed while the lower triangle and the diagonal are unchanged. Thus it is possible to restore S if necessary according to  for  k := 1 to  n −1 do ! restore  matrix  S   for  l := k +1 to  n  do  S kl := S lk  endfor  endfor  3. The eigenvalues are not necessarily in descending order. This can be achieved by a simple sorting algorithm.  for  k := 1 to  n −1 do   m := k   for  l := k +1 to  n  do   if  e l > e m  then  m := l  endif   endfor   if  k ≠ m  then swap e m , e k ; swap E m , E k  endif  endfor  4. The algorithm is written using matrix notation (1 based arrays instead of 0 based).  5. When implementing the algorithm, the part specified using matrix notation must be performed simultaneously.  6. This implementation does not correctly account for the case in which one dimension is an independent subspace. For example, if given a diagonal matrix, the above implementation will never terminate, as none of the eigenvalues will change. Hence, in real implementations, extra logic must be added to account for this case.  Example  Let    S  =   (     4     -  30     60     -  35        -  30     300     -  675     420      60     -  675     1620     -  1050        -  35     420     -  1050     700     )       S    4    30   60    35       30   300    675   420    60    675   1620    1050       35   420    1050   700      S=\begin{pmatrix}4&-30&60&-35\\
 -30&300&-675&420\\
 60&-675&1620&-1050\\
 -35&420&-1050&700\end{pmatrix}     Then jacobi produces the following eigenvalues and eigenvectors after 3 sweeps (19 iterations) :       e  1   =  2585.25381092892231       subscript  e  1   2585.25381092892231    e_{1}=2585.25381092892231        E  1   =   (     0.0291933231647860588       -  0.328712055763188997       0.791411145833126331       -  0.514552749997152907      )        subscript  E  1     0.0291933231647860588      0.328712055763188997     0.791411145833126331      0.514552749997152907       E_{1}=\begin{pmatrix}0.0291933231647860588\\
 -0.328712055763188997\\
 0.791411145833126331\\
 -0.514552749997152907\end{pmatrix}        e  2   =  37.1014913651276582       subscript  e  2   37.1014913651276582    e_{2}=37.1014913651276582        E  2   =   (      -  0.179186290535454826       0.741917790628453435       -  0.100228136947192199        -  0.638282528193614892      )        subscript  E  2       0.179186290535454826     0.741917790628453435      0.100228136947192199       0.638282528193614892       E_{2}=\begin{pmatrix}-0.179186290535454826\\
 0.741917790628453435\\
 -0.100228136947192199\\
 -0.638282528193614892\end{pmatrix}        e  3   =  1.4780548447781369       subscript  e  3   1.4780548447781369    e_{3}=1.4780548447781369        E  3   =   (      -  0.582075699497237650       0.370502185067093058      0.509578634501799626      0.514048272222164294     )        subscript  E  3       0.582075699497237650     0.370502185067093058    0.509578634501799626    0.514048272222164294      E_{3}=\begin{pmatrix}-0.582075699497237650\\
 0.370502185067093058\\
 0.509578634501799626\\
 0.514048272222164294\end{pmatrix}        e  4   =  0.1666428611718905       subscript  e  4   0.1666428611718905    e_{4}=0.1666428611718905        E  4   =   (     0.792608291163763585      0.451923120901599794      0.322416398581824992      0.252161169688241933     )        subscript  E  4     0.792608291163763585    0.451923120901599794    0.322416398581824992    0.252161169688241933      E_{4}=\begin{pmatrix}0.792608291163763585\\
 0.451923120901599794\\
 0.322416398581824992\\
 0.252161169688241933\end{pmatrix}     Applications for real symmetric matrices  When the eigenvalues (and eigenvectors) of a symmetric matrix are known, the following values are easily calculated.   Singular values  The singular values of a (square) matrix A are the square roots of the (non-negative) eigenvalues of     A  T   A       superscript  A  T   A    A^{T}A   . In case of a symmetric matrix S we have of      S  T   S   =   S  2          superscript  S  T   S    superscript  S  2     S^{T}S=S^{2}   , hence the singular values of S are the absolute values of the eigenvalues of S     2-norm and spectral radius  The 2-norm of a matrix A is the norm based on the Euclidean vectornorm, i.e. the largest value     ∥   A  x   ∥   2     subscript   norm    A  x    2    \|Ax\|_{2}   when x runs through all vectors with      ∥  x  ∥   2   =  1       subscript   norm  x   2   1    \|x\|_{2}=1   . It is the largest singular value of A . In case of a symmetric matrix it is largest absolute value of its eigenvectors and thus equal to its spectral radius.    Condition number  The condition number of a nonsingular matrix A is defined as     cond   (  A  )    =     ∥  A  ∥   2     ∥   A   -  1    ∥   2          cond  A      subscript   norm  A   2    subscript   norm   superscript  A    1     2      \mbox{cond}(A)=\|A\|_{2}\|A^{-1}\|_{2}   . In case of a symmetric matrix it is the absolute value of the quotient of the largest and smallest eigenvalue. Matrices with large condition numbers can cause numerically unstable results: small perturbation can result in large errors. Hilbert matrices are the most famous ill-conditioned matrices. For example, the fourth-order Hilbert matrix has a condition of 15514, while for order 8 it is 2.7 × 10 8 .    Rank  A matrix A has rank r if it has r columns that are linearly independent while the remaining columns are linearly dependent on these. Equivalently, r is the dimension of the range of A . Furthermore it is the number of nonzero singular values.  In case of a symmetric matrix r is the number of nonzero eigenvalues. Unfortunately because of rounding errors numerical approximations of zero eigenvalues may not be zero (it may also happen that a numerical approximation is zero while the true value is not). Thus one can only calculate the numerical rank by making a decision which of the eigenvalues are close enough to zero.    Pseudo-inverse  The pseudo inverse of a matrix A is the unique matrix    X  =   A  +       X   superscript  A      X=A^{+}   for which AX and XA are symmetric and for which AXA = A, XAX = X holds. If A is nonsingular, then '     A  +   =   A   -  1         superscript  A     superscript  A    1      A^{+}=A^{-1}   .  When procedure jacobi (S, e, E) is called, then the relation    S  =    E  T   Diag   (  e  )   E       S     superscript  E  T   Diag  e  E     S=E^{T}\mbox{Diag}(e)E   holds where Diag( e ) denotes the diagonal matrix with vector e on the diagonal. Let    e  +     superscript  e     e^{+}   denote the vector where    e  i     subscript  e  i    e_{i}   is replaced by    1  /   e  i       1   subscript  e  i     1/e_{i}   if     e  i   ≤  0       subscript  e  i   0    e_{i}\leq 0   and by 0 if    e  i     subscript  e  i    e_{i}   is (numerically close to) zero. Since matrix E is orthogonal, it follows that the pseudo-inverse of S is given by     S  +   =    E  T   Diag   (   e  +   )   E        superscript  S       superscript  E  T   Diag   superscript  e    E     S^{+}=E^{T}\mbox{Diag}(e^{+})E   .    Least squares solution  If matrix A does not have full rank, there may not be a solution of the linear system Ax = b . However one can look for a vector x for which     ∥    A  x   -  b   ∥   2     subscript   norm      A  x   b    2    \|Ax-b\|_{2}   is minimal. The solution is    x  =    A  +   b       x     superscript  A    b     x=A^{+}b   . In case of a symmetric matrix S as before, one has    x  =    S  +   b   =    E  T   Diag   (   e  +   )   E  b         x     superscript  S    b           superscript  E  T   Diag   superscript  e    E  b      x=S^{+}b=E^{T}\mbox{Diag}(e^{+})Eb   .    Matrix exponential  From    S  =    E  T   Diag   (  e  )   E       S     superscript  E  T   Diag  e  E     S=E^{T}\mbox{Diag}(e)E   one finds     exp  S   =    E  T   Diag   (   exp  e   )   E         S      superscript  E  T   Diag    e   E     \exp S=E^{T}\mbox{Diag}(\exp e)E   where exp e is the vector where    e  i     subscript  e  i    e_{i}   is replaced by    exp   e  i        subscript  e  i     \exp e_{i}   . In the same way, f ( S ) can be calculated in an obvious way for any (analytic) function f .    Linear differential equations  The differential equation x' = Ax , x (0) = a has the solution x ( t ) = exp( t A ) a . For a symmetric matrix S , it follows that     x   (  t  )    =    E  T   Diag   (   exp   t  e    )   E  a         x  t      superscript  E  T   Diag      t  e    E  a     x(t)=E^{T}\mbox{Diag}(\exp te)Ea   . If    a  =    ∑   i  =  1   n     a  i    E  i         a    superscript   subscript     i  1    n      subscript  a  i    subscript  E  i       a=\sum_{i=1}^{n}a_{i}E_{i}   is the expansion of a by the eigenvectors of S , then     x   (  t  )    =    ∑   i  =  1   n     a  i    exp   (   t   e  i    )     E  i           x  t     superscript   subscript     i  1    n      subscript  a  i       t   subscript  e  i      subscript  E  i       x(t)=\sum_{i=1}^{n}a_{i}\exp(te_{i})E_{i}   .  Let    W  s     superscript  W  s    W^{s}   be the vector space spanned by the eigenvectors of S which correspond to a negative eigenvalue and    W  u     superscript  W  u    W^{u}   analogously for the positive eigenvalues. If    a  ∈   W  s       a   superscript  W  s     a\in W^{s}   then      lim    t   ∞    x   (  t  )    =  0         subscript  lim    t     x  t   0    \mbox{lim}_{t\ \infty}x(t)=0   i.e. the equilibrium point 0 is attractive to x ( t ). If    a  ∈   W  u       a   superscript  W  u     a\in W^{u}   then      lim    t   ∞    x   (  t  )    =  ∞         subscript  lim    t     x  t      \mbox{lim}_{t\ \infty}x(t)=\infty   , i.e. 0 is repulsive to x ( t ).    W  s     superscript  W  s    W^{s}   and    W  u     superscript  W  u    W^{u}   are called stable and unstable manifolds for S . If a has components in both manifolds, then one component is attracted and one component is repelled. Hence x ( t ) approaches    W  u     superscript  W  u    W^{u}   as     t   ∞      t     t\ \infty   .   Generalizations  The Jacobi Method has been generalized to complex Hermitian matrices , general nonsymmetric real and complex matrices as well as block matrices.  Since singular values of a real matrix are the square roots of the eigenvalues of the symmetric matrix    S  =    A  T   A       S     superscript  A  T   A     S=A^{T}A   it can also be used for the calculation of these values. For this case, the method is modified in such a way that S must not be explicitly calculated which reduces the danger of round-off errors . Note that     J  S   J  T    =   J   A  T   A   J  T    =   J   A  T    J  T   J  A   J  T    =    B  T   B           J  S   superscript  J  T      J   superscript  A  T   A   superscript  J  T           J   superscript  A  T    superscript  J  T   J  A   superscript  J  T            superscript  B  T   B      JSJ^{T}=JA^{T}AJ^{T}=JA^{T}J^{T}JAJ^{T}=B^{T}B   with     B   :=   J  A   J  T       assign  B    J  A   superscript  J  T      B\,:=JAJ^{T}   .  The Jacobi Method is also well suited for parallelism.  References  Further reading          External links   Jacobi Iteration for Eigenvectors  Matlab implementation of Jacobi algorithm that avoids trigonometric functions   "  Category:Numerical linear algebra  Category:Articles with example pseudocode     ↩  ↩  ↩     