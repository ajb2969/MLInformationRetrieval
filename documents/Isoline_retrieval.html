<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="36">Isoline retrieval</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Isoline retrieval</h1>
<hr/>

<p><strong>Isoline retrieval</strong> is a <a href="remote_sensing" title="wikilink">remote sensing</a> <a href="Inverse_problem" title="wikilink">inverse method</a> that retrieves one or more <a href="Contour_line" title="wikilink">isolines</a> of a trace atmospheric constituent or variable. When used to validate another contour, it is the most accurate method possible for the task. When used to retrieve a whole field, it is a general, nonlinear inverse method and a robust estimator.</p>
<h2 id="for-validating-advected-contours">For validating advected contours</h2>
<h3 id="rationale">Rationale</h3>

<p>Suppose we have, as in <a href="contour_advection" title="wikilink">contour advection</a>, inferred knowledge of a single contour or isoline of an atmospheric constituent, <em>q</em> and we wish to validate this against satellite remote-sensing data. Since satellite instruments cannot measure the constituent directly, we need to perform some sort of inversion. In order to validate the contour, it is not necessary to know, at any given point, the exact value of the constituent. We only need to know whether it falls inside or outside, that is, is it greater than or less than the value of the contour, <em>q<sub>0</sub></em>.</p>

<p>This is a classification problem. Let:</p>

<p>

<math display="block" id="Isoline_retrieval:0">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mn>1</mn>
        <mo>;</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>q</mi>
        <mo><</mo>
        <msub>
         <mi>q</mi>
         <mn>0</mn>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mn>2</mn>
        <mo>;</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>q</mi>
        <mo>≥</mo>
        <msub>
         <mi>q</mi>
         <mn>0</mn>
        </msub>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <lt></lt>
      <ci>q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
     <apply>
      <geq></geq>
      <ci>q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=\begin{cases}1;&q<q_{0}\\
2;&q\geq q_{0}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>be the discretized variable. This will be related to the satellite <em>measurement vector</em>, 

<math display="inline" id="Isoline_retrieval:1">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{y}
  </annotation>
 </semantics>
</math>

, by some conditional probability, 

<math display="inline" id="Isoline_retrieval:2">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\vec{y}|j)
  </annotation>
 </semantics>
</math>

, which we approximate by collecting samples, called <em>training data</em>, of both the measurement vector and the state variable, <em>q</em>. By generating classification results over the region of interest and using any contouring algorithm to separate the two classes, the isoline will have been "retrieved."</p>

<p>The accuracy of a retrieval will be given by integrating the conditional probability over the area of interest, <em>A</em>:</p>

<p>

<math display="block" id="Isoline_retrieval:3">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>A</mi>
   </mfrac>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi>A</mi>
   </msub>
   <mi>P</mi>
   <mrow>
    <mo>[</mo>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="4.2pt">]</mo>
   </mrow>
   <mi>d</mi>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <ci>A</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">c</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=\frac{1}{A}\int_{A}P\left[c(\vec{r})|\vec{y}(\vec{r})\right]\,d\vec{r}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>c</em> is the retrieved class at position, 

<math display="inline" id="Isoline_retrieval:4">
 <semantics>
  <mover accent="true">
   <mi>r</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}
  </annotation>
 </semantics>
</math>

. We can maximize this quantity by maximizing the value of the integrand at each point:</p>

<p>

<math display="block" id="Isoline_retrieval:5">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>A</mi>
   </mfrac>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi>A</mi>
   </msub>
   <mrow>
    <mo>{</mo>
    <munder>
     <mi>max</mi>
     <mi>j</mi>
    </munder>
    <mi>P</mi>
    <mrow>
     <mo>[</mo>
     <mi>j</mi>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>r</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mo rspace="4.2pt">}</mo>
   </mrow>
   <mi>d</mi>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <max></max>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <ci>A</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>j</ci>
     </apply>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">j</csymbol>
      <ci>normal-|</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>y</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(a)=\frac{1}{A}\int_{A}\left\{\max_{j}P\left[j|\vec{y}(\vec{r})\right]%
\right\}\,d\vec{r}
  </annotation>
 </semantics>
</math>

</p>

<p>Since this is the definition of maximum likelihood, a <a href="statistical_classification" title="wikilink">classification algorithm</a> based on <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> is the most accurate method possible of validating an advected contour. A good method for performing maximum likelihood classification from a set of training data is <a href="variable_kernel_density_estimation" title="wikilink">variable kernel density estimation</a>.</p>
<h3 id="training-data">Training data</h3>

<p>There are two methods of generating the training data. The most obvious is empirically, by simply matching measurements of the variable, <em>q</em>, with <a href="collocation_(remote_sensing)" title="wikilink">collocated</a> measurements from the satellite instrument. In this case, no knowledge of the actual physics that produce the measurement is required and the retrieval algorithm is purely statistical. The second is with a forward model:</p>

<p>

<math display="block" id="Isoline_retrieval:6">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{y}=\vec{f}(\vec{x})\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Isoline_retrieval:7">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}
  </annotation>
 </semantics>
</math>

 is the <em>state vector</em> and <em>q = x<sub>k</sub></em> is a single component. An advantage of this method is that state vectors need not reflect actual atmospheric configurations, they need only take on a state that could reasonably occur in the real atmosphere. There are also none of the errors inherent in most <a href="collocation_(remote_sensing)" title="wikilink">collocation</a> procedures, e.g. because of offset errors in the locations of the paired samples and differences in the footprint sizes of the two instruments. Since retrievals will be biased towards more common states, however, the statistics ought to reflect those in the real world.</p>
<h3 id="error-characterization">Error characterization</h3>

<p>The conditional probabilities, 

<math display="inline" id="Isoline_retrieval:8">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">|</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\vec{y}|j)
  </annotation>
 </semantics>
</math>

, provide excellent error characterization, therefore the classification algorithm ought to return them. We define the <em>confidence rating</em> by rescaling the conditional probability:</p>

<p>

<math display="block" id="Isoline_retrieval:9">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>c</mi>
     </msub>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">|</mo>
      <mover accent="true">
       <mi>y</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>c</mi>
     </msub>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>c</ci>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">c</csymbol>
       <ci>normal-|</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>y</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <minus></minus>
      <cn type="integer">1</cn>
     </cerror>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>c</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\frac{n_{c}P(c|\vec{y})-1}{n_{c}-1}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>n<sub>c</sub></em> is the number of classes (in this case, two). If <em>C</em> is zero, then the classification is little better than chance, while if it is one, then it should be perfect. To transform the confidence rating to a statistical <em>tolerance</em>, the following line integral can be applied to an isoline retrieval for which the true isoline is known:</p>

<p>

<math display="block" id="Isoline_retrieval:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>l</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mi>l</mi>
     </msubsup>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>C</mi>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>C</mi>
          <mo>′</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>r</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>s</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>l</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <minus></minus>
        <ci>C</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>C</ci>
          <ci>normal-′</ci>
         </apply>
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(C)=\frac{1}{l}\int_{0}^{l}h(C-C^{\prime}(\vec{r}))\,ds
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>s</em> is the path, <em>l</em> is the length of the isoline and 

<math display="inline" id="Isoline_retrieval:11">
 <semantics>
  <msup>
   <mi>C</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\prime}
  </annotation>
 </semantics>
</math>

 is the retrieved confidence as a function of position. While it appears that the integral must be evaluated separately for each value of the confidence rating, <em>C</em>, in fact it may be done for all values of <em>C</em> by sorting the confidence ratings of the results, 

<math display="inline" id="Isoline_retrieval:12">
 <semantics>
  <msup>
   <mi>C</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\prime}
  </annotation>
 </semantics>
</math>

. The function relates the threshold value of the confidence rating for which the tolerance is applicable. That is, it defines a region that contains a fraction of the true isoline equal to the tolerance.</p>
<h3 id="example-water-vapour-from-amsu">Example: water vapour from AMSU</h3>

<p><a href="Image:tolerance_from_confidence.png" title="wikilink">thumb|right|upright=1.5|alt=Tolerance vs. confidence|Statistical tolerance versus confidence rating for water-vapour isoline retrieval.</a></p>

<p>The <a href="Advanced_Microwave_Sounding_Unit" title="wikilink">Advanced Microwave Sounding Unit</a> (AMSU) series of satellite instruments are designed to detect temperature and water vapour. They have a high horizontal resolution (as little as 15 km) and because they are mounted on more than one satellite, full global coverage can be obtained in less than one day. Training data was generated using the second method from <a href="European_Centre_for_Medium-Range_Weather_Forecasts" title="wikilink">European Centre for Medium-Range Weather Forecasts</a> (ECMWF) ERA-40 data fed to a fast <a href="radiative_transfer" title="wikilink">radiative transfer</a> model called <a href="RTTOV_(radiative_transfer_code)" title="wikilink">RTTOV</a>. The function, 

<math display="inline" id="Isoline_retrieval:13">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(C)
  </annotation>
 </semantics>
</math>

 has been generated from simulated retrievals and is shown in the figure to the right. This is then used to set the 90 percent tolerance in the figure below by shading all the confidence ratings less than 0.8. Thus we expect the true isoline to fall within the shading 90 percent of the time.</p>

<p><a href="Image:ret_colour.gif" title="wikilink">thumb|center|upright=3|alt=Sample isoline retrieval|Water vapour isoline retrieved from AMSU measurements and compared with ECMWF reanalysis.</a></p>
<h2 id="for-continuum-retrievals">For continuum retrievals</h2>

<p><a href="Image:conditional_probability_proxy.png" title="wikilink">thumb|left|upright=1.5|alt=The conditional probability as proxy for the continuum variable|Specific humidity versus conditional probabilities from water-vapour isoline retrieval.</a></p>

<p>Isoline retrieval is also useful for retrieving a continuum variable and constitutes a general, <a class="uri" href="nonlinear" title="wikilink">nonlinear</a> <a href="inverse_method" title="wikilink">inverse method</a>. It has the advantage over both a <a href="neural_network" title="wikilink">neural network</a>, as well as iterative methods such as <a href="optimal_estimation" title="wikilink">optimal estimation</a> that invert the forward model directly, in that there is no possibility of getting stuck in a <a href="local_minimum" title="wikilink">local minimum</a>.</p>

<p>There are a number of methods of reconstituting the continuum variable from the discretized one. Once a sufficient number of contours have been retrieved, it is straightforward to <a class="uri" href="interpolate" title="wikilink">interpolate</a> between them. Conditional probabilities make a good <a href="Proxy_(statistics)" title="wikilink">proxy</a> for the continuum value.</p>

<p>Consider the transformation from a continuum to a discrete variable:</p>

<p>

<math display="block" id="Isoline_retrieval:14">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
   </msubsup>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(1|\vec{y})=\int_{-\infty}^{q_{0}}P(q|\vec{y})\,dq
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Isoline_retrieval:15">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <int></int>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(2|\vec{y})=\int^{\infty}_{q_{0}}P(q|\vec{y})\,dq
  </annotation>
 </semantics>
</math>

</p>

<p>Suppose that 

<math display="inline" id="Isoline_retrieval:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(q|\vec{y})
  </annotation>
 </semantics>
</math>

 is given by a Gaussian:</p>

<p>

<math display="block" id="Isoline_retrieval:17">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <msqrt>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </msqrt>
     <msub>
      <mi>σ</mi>
      <mi>q</mi>
     </msub>
    </mrow>
   </mfrac>
   <mi>exp</mi>
   <mrow>
    <mo>{</mo>
    <mo>-</mo>
    <mfrac>
     <msup>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mi>q</mi>
        <mo>-</mo>
        <mrow>
         <mover accent="true">
          <mi>q</mi>
          <mo stretchy="false">¯</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>y</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>σ</mi>
       <mi>q</mi>
      </msub>
     </mrow>
    </mfrac>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <exp></exp>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>q</ci>
         <apply>
          <times></times>
          <apply>
           <ci>normal-¯</ci>
           <ci>q</ci>
          </apply>
          <apply>
           <ci>normal-→</ci>
           <ci>y</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>q</ci>
       </apply>
      </apply>
     </apply>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(q|\vec{y})=\frac{1}{\sqrt{2\pi}\sigma_{q}}\exp\left\{-\frac{\left[q-\bar{q}(%
\vec{y})\right]^{2}}{2\sigma_{q}}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Isoline_retrieval:18">
 <semantics>
  <mover accent="true">
   <mi>q</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{q}
  </annotation>
 </semantics>
</math>

 is the expectation value and 

<math display="inline" id="Isoline_retrieval:19">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{q}
  </annotation>
 </semantics>
</math>

 is the standard deviation, then the conditional probability is related to the continuum variable, <em>q</em>, by the error function:</p>

<p>

<math display="block" id="Isoline_retrieval:20">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>erf</mi>
   <mrow>
    <mo>[</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>q</mi>
       <mn>0</mn>
      </msub>
      <mo>-</mo>
      <mrow>
       <mover accent="true">
        <mi>q</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mover accent="true">
         <mi>y</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <msqrt>
       <mn>2</mn>
      </msqrt>
      <msub>
       <mi>σ</mi>
       <mi>q</mi>
      </msub>
     </mrow>
    </mfrac>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">erf</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-¯</ci>
         <ci>q</ci>
        </apply>
        <apply>
         <ci>normal-→</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>q</ci>
       </apply>
      </apply>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=P(2|\vec{y})-P(1|\vec{y})=\mathrm{erf}\left[\frac{q_{0}-\bar{q}(\vec{y})}{%
\sqrt{2}\sigma_{q}}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>The figure shows conditional probability versus specific humidity for the example retrieval discussed above.</p>
<h3 id="as-a-robust-estimator">As a robust estimator</h3>

<p>The location of <em>q</em><sub>0</sub> is found by setting the conditional probabilities of the two classes to be equal:</p>

<p>

<math display="block" id="Isoline_retrieval:21">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
   </msubsup>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mi>q</mi>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <int></int>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{-\infty}^{q_{0}}P(q|\vec{y})\,dq=\int^{\infty}_{q_{0}}P(q|\vec{y})\,dq
  </annotation>
 </semantics>
</math>

</p>

<p>In other words, equal amounts of the "zeroeth order moment" lie on either side of <em>q</em><sub>0</sub>. This type of formulation is characteristic of a <a href="robust_estimator" title="wikilink">robust estimator</a>.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://isoret.sourceforge.net">Software for isoline retrieval</a></li>
</ul>

<p>"</p>

<p><a href="Category:Remote_sensing" title="wikilink">Category:Remote sensing</a> <a href="Category:Inverse_problems" title="wikilink">Category:Inverse problems</a></p>
</body>
</html>
