<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="472">Apostolico–Giancarlo algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Apostolico–Giancarlo algorithm</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, the <strong>Apostolico–Giancarlo algorithm</strong> is a variant of the <a href="Boyer–Moore_string_search_algorithm" title="wikilink">Boyer–Moore string search algorithm</a>, the basic application of which is searching for occurrences of a pattern 

<math display="inline" id="Apostolico–Giancarlo_algorithm:0">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in a text 

<math display="inline" id="Apostolico–Giancarlo_algorithm:1">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. As with other comparison-based string searches, this is done by aligning 

<math display="inline" id="Apostolico–Giancarlo_algorithm:2">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 to a certain index of 

<math display="inline" id="Apostolico–Giancarlo_algorithm:3">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and checking whether a match occurs at that index. 

<math display="inline" id="Apostolico–Giancarlo_algorithm:4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is then shifted relative to 

<math display="inline" id="Apostolico–Giancarlo_algorithm:5">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 according to the rules of the Boyer-Moore algorithm, and the process repeats until the end of 

<math display="inline" id="Apostolico–Giancarlo_algorithm:6">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 has been reached. Application of the Boyer-Moore shift rules often results in large chunks of the text being skipped entirely.</p>

<p>With regard to the shift operation, Apostolico-Giancarlo is exactly equivalent in functionality to Boyer-Moore. The utility of Apostolico-Giancarlo is to speed up the match-checking operation at any index. With Boyer-Moore, finding an occurrence of 

<math display="inline" id="Apostolico–Giancarlo_algorithm:7">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Apostolico–Giancarlo_algorithm:8">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 requires that all 

<math display="inline" id="Apostolico–Giancarlo_algorithm:9">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 characters of 

<math display="inline" id="Apostolico–Giancarlo_algorithm:10">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 be explicitly matched. For certain patterns and texts, this is very inefficient - a simple example is when both pattern and text consist of the same repeated character, in which case Boyer-Moore runs in 

<math display="inline" id="Apostolico–Giancarlo_algorithm:11">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nm)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Apostolico–Giancarlo_algorithm:12">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the length in characters of 

<math display="inline" id="Apostolico–Giancarlo_algorithm:13">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. Apostolico-Giancarlo speeds this up by recording the number of characters matched at the alignments of 

<math display="inline" id="Apostolico–Giancarlo_algorithm:14">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 in a table, which is combined with data gathered during the pre-processing of 

<math display="inline" id="Apostolico–Giancarlo_algorithm:15">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 to avoid redundant equality checking for sequences of characters that are known to match.</p>
<h2 id="references">References</h2>
<ul>
<li>Apostolico A., Giancarlo R., 1986, The Boyer-Moore-Galil string searching strategies revisited, <a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a> 15(1):98-105.</li>
<li>Crochemore, M., Lecroq, T., 1997, Tight bounds on the complexity of the Apostolico–Giancarlo algorithm, Information Processing Letters 63(4):195-203.</li>
<li>Crochemore, M., <a href="Wojciech_Rytter" title="wikilink">Rytter, W.</a>, 1994, Text Algorithms, <a href="Oxford_University_Press" title="wikilink">Oxford University Press</a>.</li>
<li>Gusfield, D., 1997, Algorithms on strings, trees, and sequences: <a href="Computer_science" title="wikilink">Computer Science</a> and Computational Biology, <a href="Cambridge_University_Press" title="wikilink">Cambridge University Press</a>.</li>
<li>Lecroq, T., 1992, Recherches de mot, Ph. D. Thesis, <a href="Orléans" title="wikilink">University of Orléans</a>, France.</li>
<li>Lecroq, T., 1995, Experimental results on <a href="String_searching_algorithm" title="wikilink">string matching</a> algorithms, Software - Practice &amp; Experience 25(7):727-765.</li>
</ul>

<p>"</p>

<p><a href="Category:String_matching_algorithms" title="wikilink">Category:String matching algorithms</a></p>
</body>
</html>
