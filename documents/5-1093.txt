   Row-major order      Row-major order   In computing, row-major order and column-major order describe methods for arranging multidimensional arrays in linear storage such as memory .  The difference is simply that in row-major order, consecutive elements of the rows of the array are contiguous in memory; in column-major order, consecutive elements of the columns are contiguous.  Array layout is critical for correctly passing arrays between programs written in different languages. It is also important for performance when traversing an array because accessing array elements that are contiguous in memory is usually faster than accessing elements which are not, due to caching . 1 In some media such as tape or NAND flash memory , accessing sequentially is orders of magnitude faster than nonsequential access.  Explanation and example  Following conventional matrix notation , rows are numbered by the first index of a two-dimensional array and columns by the second index, i.e., a 1,2 is the second element of the first row, counting downwards and rightwards. (Note this is the opposite of Cartesian conventions .)  The difference between row-major and column-major order is simply that the order of the dimensions is reversed. Equivalently, in row-major order the rightmost indices vary faster as one steps through consecutive memory locations, while in column-major order the leftmost indices vary faster.  This array      [     11    12    13      21    22    23     ]      11  12  13    21  22  23     \begin{bmatrix}11&12&13\\
 21&22&23\end{bmatrix}     Would be stored as follows in the two orders:      Column-major order e.g. Fortran     Address     0     1     2     3     4     5         Row-major order e.g. C     Address     0     1     2     3     4     5     Programming languages  Programming languages which support multi-dimensional arrays have a native storage order for these arrays.  Row-major order is used in C / C++ , Mathematica , PL/I , Pascal , Python , Speakeasy , SAS , Torch , C# / CLI / .Net and others.  Column-major order is used in Fortran , OpenGL and OpenGL ES , MATLAB , 2  GNU Octave , S-Plus , 3  R , 4  Julia , Rasdaman , and Scilab .  Transposition  As exchanging the indices of an array is the essence of array transposition , an array stored as row-major but read as column-major (or vice versa) will appear transposed. As actually performing this rearrangement in memory is typically an expensive operation, some systems provide options to specify individual matrices as being stored transposed.  For example, the Basic Linear Algebra Subprograms functions are passed flags indicating which arrays are transposed. 5  Address calculation in general  The concept generalizes to arrays with more than two dimensions.  For a d -dimensional     N  1   ×   N  2   ×  ⋯  ×   N  d        subscript  N  1    subscript  N  2   normal-⋯   subscript  N  d     N_{1}\times N_{2}\times\cdots\times N_{d}   array with dimensions N k ( k =1... d ), a given element of this array is specified by a tuple     (   n  1   ,   n  2   ,  …  ,   n  d   )      subscript  n  1    subscript  n  2   normal-…   subscript  n  d     (n_{1},n_{2},\ldots,n_{d})   of d (zero-based) indices     n  k   ∈   [  0  ,    N  k   -  1   ]        subscript  n  k    0     subscript  N  k   1      n_{k}\in[0,N_{k}-1]   .  In row-major order, the last dimension is contiguous, so that the memory-offset of this element is given by:       n  d   +   N  d   ⋅   (   n   d  -  1    +   N   d  -  1    ⋅   (   n   d  -  2    +   N   d  -  2    ⋅   (  ⋯  +   N  2    n  1   )   ⋯  )   )   )  =  ∑     k  =  1      d   (   ∏   ℓ  =   k  +  1    d    N  ℓ   )  n    k      fragments   subscript  n  d     subscript  N  d   normal-⋅   fragments  normal-(   subscript  n    d  1      subscript  N    d  1    normal-⋅   fragments  normal-(   subscript  n    d  2      subscript  N    d  2    normal-⋅   fragments  normal-(  normal-⋯    subscript  N  2    subscript  n  1   normal-)   normal-⋯  normal-)   normal-)   normal-)       k  1     d   normal-(   superscript   subscript  product    normal-ℓ    k  1     d    subscript  N  normal-ℓ   normal-)  n   k     n_{d}+N_{d}\cdot(n_{d-1}+N_{d-1}\cdot(n_{d-2}+N_{d-2}\cdot(\cdots+N_{2}n_{1})%
 \cdots)))=\sum_{k=1}^{d}\left(\prod_{\ell=k+1}^{d}N_{\ell}\right)n_{k}     In column-major order, the first dimension is contiguous, so that the memory-offset of this element is given by:       n  1   +   N  1   ⋅   (   n  2   +   N  2   ⋅   (   n  3   +   N  3   ⋅   (  ⋯  +   N   d  -  1     n  d   )   ⋯  )   )   )  =  ∑     k  =  1      d   (   ∏   ℓ  =  1    k  -  1     N  ℓ   )  n    k      fragments   subscript  n  1     subscript  N  1   normal-⋅   fragments  normal-(   subscript  n  2     subscript  N  2   normal-⋅   fragments  normal-(   subscript  n  3     subscript  N  3   normal-⋅   fragments  normal-(  normal-⋯    subscript  N    d  1     subscript  n  d   normal-)   normal-⋯  normal-)   normal-)   normal-)       k  1     d   normal-(   superscript   subscript  product    normal-ℓ  1      k  1     subscript  N  normal-ℓ   normal-)  n   k     n_{1}+N_{1}\cdot(n_{2}+N_{2}\cdot(n_{3}+N_{3}\cdot(\cdots+N_{d-1}n_{d})\cdots)%
 ))=\sum_{k=1}^{d}\left(\prod_{\ell=1}^{k-1}N_{\ell}\right)n_{k}     See also   Matrix representation  Vectorization (mathematics) , the equivalent of turning a matrix into the corresponding column-major vector   References    Sources   Donald E. Knuth, The Art of Computer Programming Volume 1: Fundamental Algorithms , third edition, section 2.2.6 (Addison-Wesley: New York, 1997).   "  Category:Arrays     ↩  MATLAB documentation, MATLAB Data Storage (retrieved from Mathworks.co.uk, January 2014). ↩  : ↩  An Introduction to R , Section 5.1: Arrays (retrieved March 2010). ↩  ↩     