<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1907">Non-uniform rational B-spline</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Non-uniform rational B-spline</h1>
<hr/>

<p> <strong>Non-uniform rational <a href="b-spline" title="wikilink">basis spline</a></strong> (<strong>NURBS</strong>) is a mathematical model commonly used in <a href="computer_graphics" title="wikilink">computer graphics</a> for generating and representing curves and surfaces. It offers great flexibility and precision for handling both analytic (<a href="surface" title="wikilink">surfaces</a> defined by common mathematical <a href="formula" title="wikilink">formulae</a>) and <a href="3D_modeling" title="wikilink">modeled</a> shapes. NURBS are commonly used in computer-aided design (<a class="uri" href="CAD" title="wikilink">CAD</a>), manufacturing (<a href="Computer-aided_manufacturing" title="wikilink">CAM</a>), and engineering (<a href="Computer-aided_engineering" title="wikilink">CAE</a>) and are part of numerous industry wide standards, such as <a class="uri" href="IGES" title="wikilink">IGES</a>, <a href="ISO_10303" title="wikilink">STEP</a>, <a class="uri" href="ACIS" title="wikilink">ACIS</a>, and <a class="uri" href="PHIGS" title="wikilink">PHIGS</a>. NURBS tools are also found in various <a href="3D_computer_graphics_software" title="wikilink">3D modelling</a> and <a class="uri" href="animation" title="wikilink">animation</a> software packages.</p>

<p>They can be efficiently handled by the computer programs and yet allow for easy human interaction. NURBS surfaces are functions of two parameters mapping to a surface in three-dimensional space. The shape of the surface is determined by control points. NURBS surfaces can represent, in a compact form, simple geometrical shapes. <a href="T-Spline_(mathematics)" title="wikilink">T-splines</a> and <a href="subdivision_surfaces" title="wikilink">subdivision surfaces</a> are more suitable for complex organic shapes because they reduce the number of control points twofold in comparison with the NURBS surfaces.</p>

<p>In general, editing NURBS curves and surfaces is highly intuitive and predictable. Control points are always either connected directly to the curve/surface, or act as if they were connected by a rubber band. Depending on the type of user interface, editing can be realized via an element’s control points, which are most obvious and common for <a href="Bézier_curve" title="wikilink">Bézier curves</a>, or via higher level tools such as spline modeling or hierarchical editing.</p>
<h2 id="history">History</h2>

<p>Before computers, designs were drawn by hand on paper with various <a href="Technical_drawing" title="wikilink">drafting tools</a>. <a href="Ruler" title="wikilink">Rulers</a> were used for straight lines, <a href="Compass_(drafting)" title="wikilink">compasses</a> for circles, and <a class="uri" href="protractors" title="wikilink">protractors</a> for angles. But many shapes, such as the <a href="freeform_surface" title="wikilink">freeform curve</a> of a ship's bow, could not be drawn with these tools. Although such curves could be drawn freehand at the drafting board, shipbuilders often needed a life-size version which could not be done by hand. Such large drawings were done with the help of flexible strips of wood, called splines. The splines were held in place at a number of predetermined points, called "ducks"; between the ducks, the <a href="Elasticity_(physics)" title="wikilink">elasticity</a> of the spline material caused the strip to take the shape that minimized the energy of bending, thus creating the smoothest possible shape that fit the constraints. The shape could be tweaked by moving the ducks.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>In 1946, mathematicians started studying the spline shape, and derived the piecewise <a class="uri" href="polynomial" title="wikilink">polynomial</a> formula known as the <a href="spline_(mathematics)" title="wikilink">spline curve</a> or spline function. <a href="Isaac_Jacob_Schoenberg" title="wikilink">I. J. Schoenberg</a> gave the spline function its name after its resemblance to the mechanical spline used by draftsmen.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>As computers were introduced into the design process, the physical properties of such splines were investigated so that they could be modelled with mathematical precision and reproduced where needed. Pioneering work was done in <a class="uri" href="France" title="wikilink">France</a> by <a class="uri" href="Renault" title="wikilink">Renault</a> engineer <a href="Pierre_Bézier" title="wikilink">Pierre Bézier</a>, and <a class="uri" href="Citroën" title="wikilink">Citroën</a>'s physicist and mathematician <a href="Paul_de_Casteljau" title="wikilink">Paul de Casteljau</a>. They worked nearly parallel to each other, but because Bézier published the results of his work, Bézier curves were named after him, while de Casteljau’s name is only known and used for the algorithms.</p>

<p>At first NURBS were only used in the proprietary <a href="Computer_aided_design" title="wikilink">CAD</a> packages of car companies. Later they became part of standard computer graphics packages.</p>

<p>Real-time, interactive rendering of NURBS curves and surfaces was first made commercially available on <a href="Silicon_Graphics" title="wikilink">Silicon Graphics</a> workstations in 1989. In 1993, the first interactive NURBS modeller for PCs, called NöRBS, was developed by CAS Berlin, a small startup company cooperating with the <a href="Technical_University_of_Berlin" title="wikilink">Technical University of Berlin</a>. Today most professional computer graphics applications available for desktop use offer NURBS technology, which is most often realized by integrating a NURBS engine from a specialized company.</p>
<h2 id="continuity">Continuity</h2>

<p>A surface under construction, e.g. the hull of a motor yacht, is usually composed of several NURBS surfaces known as <em>patches</em>. These patches should be fitted together in such a way that the boundaries are invisible. This is mathematically expressed by the concept of <a href="geometric_continuity" title="wikilink">geometric continuity</a>.</p>

<p>Higher-level tools exist that benefit from the ability of NURBS to create and establish geometric continuity of different levels:</p>
<ul>
<li><strong>Positional continuity</strong> (G<sup>0</sup>) holds whenever the end positions of two curves or surfaces coincide. The curves or surfaces may still meet at an angle, giving rise to a sharp corner or edge and causing broken highlights.</li>
<li><strong>Tangential continuity</strong> (G¹) requires the end vectors of the curves or surfaces to be parallel and pointing the same way, ruling out sharp edges. Because highlights falling on a tangentially continuous edge are always continuous and thus look natural, this level of continuity can often be sufficient.</li>
<li><strong>Curvature continuity</strong> (G²) further requires the end vectors to be of the same length and rate of length change. Highlights falling on a curvature-continuous edge do not display any change, causing the two surfaces to appear as one. This can be visually recognized as "perfectly smooth". This level of continuity is very useful in the creation of models that require many <a class="uri" href="bi-cubic" title="wikilink">bi-cubic</a> patches composing one continuous surface.</li>
</ul>

<p>Geometric continuity mainly refers to the shape of the resulting surface; since NURBS surfaces are functions, it is also possible to discuss the derivatives of the surface with respect to the parameters. This is known as <a href="parametric_continuity" title="wikilink">parametric continuity</a>. Parametric continuity of a given degree implies geometric continuity of that degree.</p>

<p>First- and second-level parametric continuity (C<sup>0</sup> and C¹) are for practical purposes identical to positional and tangential (G<sup>0</sup> and G¹) continuity. Third-level parametric continuity (C²), however, differs from curvature continuity in that its parameterization is also continuous. In practice, C² continuity is easier to achieve if uniform B-splines are used.</p>

<p>The definition of C<sup><em>n</em></sup> continuity requires that the <em>n</em>th derivative of adjacent curves/surfaces (

<math display="inline" id="Non-uniform_rational_B-spline:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>d</mi>
      <mi>n</mi>
     </msup>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>d</mi>
   </mrow>
   <msup>
    <mi>u</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <ci>n</ci>
      </apply>
      <ci>C</ci>
      <ci>u</ci>
     </apply>
     <ci>d</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>u</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{n}C(u)/du^{n}
  </annotation>
 </semantics>
</math>

) are equal at a joint.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Note that the (partial) derivatives of curves and surfaces are vectors that have a direction and a magnitude; both should be equal.</p>

<p>Highlights and reflections can reveal the perfect smoothing, which is otherwise practically impossible to achieve without NURBS surfaces that have at least G² continuity. This same principle is used as one of the surface evaluation methods whereby a <a href="Ray_tracing_(graphics)" title="wikilink">ray-traced</a> or <a href="reflection_mapping" title="wikilink">reflection-mapped</a> image of a surface with white stripes reflecting on it will show even the smallest deviations on a surface or set of surfaces. This method is derived from car prototyping wherein surface quality is inspected by checking the quality of reflections of a neon-light ceiling on the car surface. This method is also known as "Zebra analysis".</p>
<h2 id="technical-specifications">Technical specifications</h2>

<p> A NURBS curve is defined by its order, a set of weighted control points, and a knot vector.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> NURBS curves and surfaces are generalizations of both <a href="B-spline" title="wikilink">B-splines</a> and <a href="Bézier_curve" title="wikilink">Bézier curves</a> and surfaces, the primary difference being the weighting of the control points, which makes NURBS curves <em>rational</em> (non-rational B-splines are a special case of rational B-splines). By using a two-dimensional grid of control points, NURBS surfaces including planar patches and sections of spheres can be created. These are parametrized with two variables (typically called <em>s</em> and <em>t</em> or <em>u</em> and <em>v</em>). This can be extended to arbitrary dimensions to create NURBS mapping 

<math display="inline" id="Non-uniform_rational_B-spline:1">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mi>n</mi>
   </msup>
   <mo>→</mo>
   <msup>
    <mi>R</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{n}\to R^{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>NURBS curves and surfaces are useful for a number of reasons:</p>
<ul>
<li>They are <a href="invariant_(mathematics)" title="wikilink">invariant</a> under <a href="affine_transformation" title="wikilink">affine</a> transformations:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> operations like rotations and translations can be applied to NURBS curves and surfaces by applying them to their control points.</li>
<li>They offer one common mathematical form for both standard analytical shapes (e.g., <a class="uri" href="conics" title="wikilink">conics</a>) and free-form shapes.</li>
<li>They provide the flexibility to design a large variety of shapes.</li>
<li>They reduce the memory consumption when storing shapes (compared to simpler methods).</li>
<li>They can be evaluated reasonably quickly by <a href="numerically_stable" title="wikilink">numerically stable</a> and accurate <a href="algorithm" title="wikilink">algorithms</a>.</li>
</ul>

<p>In the next sections, NURBS is discussed in one dimension (curves). It should be noted that all of it can be generalized to two or even more dimensions.</p>
<h3 id="control-points">Control points</h3>

<p> The control points determine the shape of the curve.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Typically, each point of the curve is computed by taking a <a class="uri" href="weighted" title="wikilink">weighted</a> sum of a number of control points. The weight of each point varies according to the governing parameter. For a curve of degree d, the weight of any control point is only nonzero in d+1 intervals of the parameter space. Within those intervals, the weight changes according to a polynomial function (<em>basis functions</em>) of degree d. At the boundaries of the intervals, the basis functions go smoothly to zero, the smoothness being determined by the degree of the polynomial.</p>

<p>As an example, the basis function of degree one is a triangle function. It rises from zero to one, then falls to zero again. While it rises, the basis function of the previous control point falls. In that way, the curve interpolates between the two points, and the resulting curve is a polygon, which is <a href="continuous_function" title="wikilink">continuous</a>, but not <a class="uri" href="differentiable" title="wikilink">differentiable</a> at the interval boundaries, or knots. Higher degree polynomials have correspondingly more continuous derivatives. Note that within the interval the polynomial nature of the basis functions and the linearity of the construction make the curve perfectly smooth, so it is only at the knots that discontinuity can arise.</p>

<p>In many applications the fact that a single control point only influences those intervals where it is active is a highly desirable property, known as <strong>local support</strong>. In modeling, it allows the changing of one part of a surface while keeping other parts unchanged.</p>

<p>Adding more control points allows better approximation to a given curve, although only a certain class of curves can be represented exactly with a finite number of control points. NURBS curves also feature a scalar <strong>weight</strong> for each control point. This allows for more control over the shape of the curve without unduly raising the number of control points. In particular, it adds conic sections like circles and ellipses to the set of curves that can be represented exactly. The term <em>rational</em> in NURBS refers to these weights.</p>

<p>The control points can have any <a class="uri" href="dimensionality" title="wikilink">dimensionality</a>. One-dimensional points just define a <a href="scalar_(mathematics)" title="wikilink">scalar</a> function of the parameter. These are typically used in image processing programs to tune the brightness and color curves. Three-dimensional control points are used abundantly in 3D modeling, where they are used in the everyday meaning of the word 'point', a location in 3D space. Multi-dimensional points might be used to control sets of time-driven values, e.g. the different positional and rotational settings of a robot arm. NURBS surfaces are just an application of this. Each control 'point' is actually a full vector of control points, defining a curve. These curves share their degree and the number of control points, and span one dimension of the parameter space. By interpolating these control vectors over the other dimension of the parameter space, a continuous set of curves is obtained, defining the surface.</p>
<h3 id="knot-vector">Knot vector</h3>

<p>The knot vector is a sequence of parameter values that determines where and how the control points affect the NURBS curve. The number of knots is always equal to the number of control points plus curve degree plus one (i.e. number of control points plus curve order). The knot vector divides the parametric space in the intervals mentioned before, usually referred to as <em>knot spans</em>. Each time the parameter value enters a new knot span, a new control point becomes active, while an old control point is discarded. It follows that the values in the knot vector should be in nondecreasing order, so (0, 0, 1, 2, 3, 3) is valid while (0, 0, 2, 1, 3, 3) is not.</p>

<p>Consecutive knots can have the same value. This then defines a knot span of zero length, which implies that two control points are activated at the same time (and of course two control points become deactivated). This has impact on continuity of the resulting curve or its higher derivatives; for instance, it allows the creation of corners in an otherwise smooth NURBS curve. A number of coinciding knots is sometimes referred to as a knot with a certain <strong>multiplicity</strong>. Knots with multiplicity two or three are known as double or triple knots. The multiplicity of a knot is limited to the degree of the curve; since a higher multiplicity would split the curve into disjoint parts and it would leave control points unused. For first-degree NURBS, each knot is paired with a control point.</p>

<p>The knot vector usually starts with a knot that has multiplicity equal to the order. This makes sense, since this activates the control points that have influence on the first knot span. Similarly, the knot vector usually ends with a knot of that multiplicity. Curves with such knot vectors start and end in a control point.</p>

<p>The values of the knots control the mapping between the input parameter and the corresponding NURBS value. For example, if a NURBS describes a path through space over time, the knots control the time that the function proceeds past the control points. For the purposes of representing shapes, however, only the ratios of the difference between the knot values matter; in that case, the knot vectors (0, 0, 1, 2, 3, 3) and (0, 0, 2, 4, 6, 6) produce the same curve. The positions of the knot values influences the mapping of parameter space to curve space. Rendering a NURBS curve is usually done by stepping with a fixed stride through the parameter range. By changing the knot span lengths, more sample points can be used in regions where the curvature is high. Another use is in situations where the parameter value has some physical significance, for instance if the parameter is time and the curve describes the motion of a robot arm. The knot span lengths then translate into velocity and acceleration, which are essential to get right to prevent damage to the robot arm or its environment. This flexibility in the mapping is what the phrase <em>non uniform</em> in NURBS refers to.</p>

<p>Necessary only for internal calculations, knots are usually not helpful to the users of modeling software. Therefore, many modeling applications do not make the knots editable or even visible. It's usually possible to establish reasonable knot vectors by looking at the variation in the control points. More recent versions of NURBS software (e.g., <a href="Autodesk_Maya" title="wikilink">Autodesk Maya</a> and <a href="Rhinoceros_3D" title="wikilink">Rhinoceros 3D</a>) allow for interactive editing of knot positions, but this is significantly less intuitive than the editing of control points.</p>
<h3 id="comparison-of-knots-and-control-points">Comparison of Knots and Control Points</h3>

<p>A common misconception is that each knot is paired with a control point. This is true only for degree 1 NURBS (polylines). In general, the knots break the domain up into knot spans, but each control point corresponds to one basis function which spans a range of (degree+1) knot spans. For example, suppose we have a degree-3 NURBS with 7 control points and knots 0,0,0,1,2,5,8,8,8. The first four control points are grouped with the first six knots. The second through fifth control points are grouped with the knots 0,0,1,2,5,8. The third through sixth control points are grouped with the knots 0,1,2,5,8,8. The last four control points are grouped with the last six knots.</p>

<p>Some modelers that use older algorithms for NURBS evaluation require two extra knot values for a total of (degree+N+1) knots.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="order">Order</h3>

<p>The <em>order</em> of a NURBS curve defines the number of nearby control points that influence any given point on the curve. The curve is represented mathematically by a polynomial of degree one less than the order of the curve. Hence, second-order curves (which are represented by linear polynomials) are called linear curves, third-order curves are called quadratic curves, and fourth-order curves are called cubic curves. The number of control points must be greater than or equal to the order of the curve.</p>

<p>In practice, cubic curves are the ones most commonly used. Fifth- and sixth-order curves are sometimes useful, especially for obtaining continuous higher order derivatives, but curves of higher orders are practically never used because they lead to internal numerical problems and tend to require disproportionately large calculation times.</p>
<h3 id="construction-of-the-basis-functions">Construction of the basis functions</h3>

<p>The B-spline basis functions used in the construction of NURBS curves are usually denoted as 

<math display="inline" id="Non-uniform_rational_B-spline:2">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <list>
      <ci>i</ci>
      <ci>n</ci>
     </list>
    </apply>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,n}(u)
  </annotation>
 </semantics>
</math>

, in which 

<math display="inline" id="Non-uniform_rational_B-spline:3">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 corresponds to the 

<math display="inline" id="Non-uniform_rational_B-spline:4">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

<sup>th</sup> control point, and 

<math display="inline" id="Non-uniform_rational_B-spline:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 corresponds with the degree of the basis function.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The parameter dependence is frequently left out, so we can write 

<math display="inline" id="Non-uniform_rational_B-spline:6">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <ci>i</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,n}
  </annotation>
 </semantics>
</math>

. The definition of these basis functions is recursive in 

<math display="inline" id="Non-uniform_rational_B-spline:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. The degree-0 functions 

<math display="inline" id="Non-uniform_rational_B-spline:8">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mn>0</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <ci>i</ci>
     <cn type="integer">0</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,0}
  </annotation>
 </semantics>
</math>

 are piecewise constant functions. They are one on the corresponding knot span and zero everywhere else. Effectively, 

<math display="inline" id="Non-uniform_rational_B-spline:9">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <ci>i</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,n}
  </annotation>
 </semantics>
</math>

 is a linear interpolation of 

<math display="inline" id="Non-uniform_rational_B-spline:10">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <ci>i</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,n-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-uniform_rational_B-spline:11">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i+1,n-1}
  </annotation>
 </semantics>
</math>

. The latter two functions are non-zero for 

<math display="inline" id="Non-uniform_rational_B-spline:12">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 knot spans, overlapping for 

<math display="inline" id="Non-uniform_rational_B-spline:13">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 knot spans. The function 

<math display="inline" id="Non-uniform_rational_B-spline:14">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <ci>i</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,n}
  </annotation>
 </semantics>
</math>

 is computed as</p>
<figure><b>(Figure)</b>
<figcaption>From top to bottom: Linear basis functions 

<math display="inline" id="Non-uniform_rational_B-spline:15">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{1,1}
  </annotation>
 </semantics>
</math>

 (blue) and 

<math display="inline" id="Non-uniform_rational_B-spline:16">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mn>2</mn>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{2,1}
  </annotation>
 </semantics>
</math>

 (green) (top), their weight functions 

<math display="inline" id="Non-uniform_rational_B-spline:17">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-uniform_rational_B-spline:18">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 (middle) and the resulting quadratic basis function (bottom). The knots are 0, 1, 2, and 2.5</figcaption>
</figure>

<p>

<math display="block" id="Non-uniform_rational_B-spline:19">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <msub>
      <mi>N</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>g</mi>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo>,</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <msub>
      <mi>N</mi>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <list>
      <ci>i</ci>
      <ci>n</ci>
     </list>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <list>
        <ci>i</ci>
        <ci>n</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <list>
        <ci>i</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </list>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <list>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>n</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <list>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,n}=f_{i,n}N_{i,n-1}+g_{i+1,n}N_{i+1,n-1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Non-uniform_rational_B-spline:20">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 rises linearly from zero to one on the interval where 

<math display="inline" id="Non-uniform_rational_B-spline:21">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <ci>i</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,n-1}
  </annotation>
 </semantics>
</math>

 is non-zero, while 

<math display="inline" id="Non-uniform_rational_B-spline:22">
 <semantics>
  <msub>
   <mi>g</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i+1}
  </annotation>
 </semantics>
</math>

 falls from one to zero on the interval where 

<math display="inline" id="Non-uniform_rational_B-spline:23">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i+1,n-1}
  </annotation>
 </semantics>
</math>

 is non-zero. As mentioned before, 

<math display="inline" id="Non-uniform_rational_B-spline:24">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,1}
  </annotation>
 </semantics>
</math>

 is a triangular function, nonzero over two knot spans rising from zero to one on the first, and falling to zero on the second knot span. Higher order basis functions are non-zero over corresponding more knot spans and have correspondingly higher degree. If 

<math display="inline" id="Non-uniform_rational_B-spline:25">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is the parameter, and 

<math display="inline" id="Non-uniform_rational_B-spline:26">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{i}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Non-uniform_rational_B-spline:27">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

<sup>th</sup> knot, we can write the functions 

<math display="inline" id="Non-uniform_rational_B-spline:28">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-uniform_rational_B-spline:29">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Non-uniform_rational_B-spline:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>u</mi>
     <mo>-</mo>
     <msub>
      <mi>k</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>k</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>k</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <list>
       <ci>i</ci>
       <ci>n</ci>
      </list>
     </apply>
     <ci>u</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i,n}(u)={{u-k_{i}}\over{k_{i+n}-k_{i}}}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Non-uniform_rational_B-spline:31">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>k</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <mo>-</mo>
     <mi>u</mi>
    </mrow>
    <mrow>
     <msub>
      <mi>k</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>k</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <list>
       <ci>i</ci>
       <ci>n</ci>
      </list>
     </apply>
     <ci>u</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>u</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i,n}(u)={{k_{i+n}-u}\over{k_{i+n}-k_{i}}}
  </annotation>
 </semantics>
</math>

</p>

<p>The functions 

<math display="inline" id="Non-uniform_rational_B-spline:32">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-uniform_rational_B-spline:33">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 are positive when the corresponding lower order basis functions are non-zero. By <a href="mathematical_induction" title="wikilink">induction</a> on n it follows that the basis functions are non-negative for all values of 

<math display="inline" id="Non-uniform_rational_B-spline:34">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-uniform_rational_B-spline:35">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

. This makes the computation of the basis functions numerically stable.</p>

<p>Again by induction, it can be proved that the sum of the basis functions for a particular value of the parameter is unity. This is known as the <strong>partition of unity</strong> property of the basis functions.</p>
<figure><b>(Figure)</b>
<figcaption>Linear basis functions</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>Quadratic basis functions</figcaption>
</figure>

<p>The figures show the linear and the quadratic basis functions for the knots {..., 0, 1, 2, 3, 4, 4.1, 5.1, 6.1, 7.1, ...}</p>

<p>One knot span is considerably shorter than the others. On that knot span, the peak in the quadratic basis function is more distinct, reaching almost one. Conversely, the adjoining basis functions fall to zero more quickly. In the geometrical interpretation, this means that the curve approaches the corresponding control point closely. In case of a double knot, the length of the knot span becomes zero and the peak reaches one exactly. The basis function is no longer differentiable at that point. The curve will have a sharp corner if the neighbour control points are not collinear.</p>
<h3 id="general-form-of-a-nurbs-curve">General form of a NURBS curve</h3>

<p>Using the definitions of the basis functions 

<math display="inline" id="Non-uniform_rational_B-spline:36">
 <semantics>
  <msub>
   <mi>N</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <list>
     <ci>i</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i,n}
  </annotation>
 </semantics>
</math>

 from the previous paragraph, a NURBS curve takes the following form:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>

<math display="block" id="Non-uniform_rational_B-spline:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <mrow>
     <mfrac>
      <mrow>
       <msub>
        <mi>N</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>n</mi>
        </mrow>
       </msub>
       <msub>
        <mi>w</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>k</mi>
       </msubsup>
       <mrow>
        <msub>
         <mi>N</mi>
         <mrow>
          <mi>j</mi>
          <mo>,</mo>
          <mi>n</mi>
         </mrow>
        </msub>
        <msub>
         <mi>w</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
     </mfrac>
     <msub>
      <mi>ℙ</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>N</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>n</mi>
       </mrow>
      </msub>
      <msub>
       <mi>w</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>ℙ</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>N</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>n</mi>
       </mrow>
      </msub>
      <msub>
       <mi>w</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>N</ci>
          <list>
           <ci>i</ci>
           <ci>n</ci>
          </list>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>k</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>N</ci>
           <list>
            <ci>j</ci>
            <ci>n</ci>
           </list>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>w</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ℙ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <list>
          <ci>i</ci>
          <ci>n</ci>
         </list>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ℙ</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <list>
          <ci>i</ci>
          <ci>n</ci>
         </list>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(u)=\sum_{i=1}^{k}{\frac{N_{i,n}w_{i}}{\sum_{j=1}^{k}N_{j,n}w_{j}}}\mathbb{P}%
_{i}=\frac{\sum_{i=1}^{k}{N_{i,n}w_{i}\mathbb{P}_{i}}}{\sum_{i=1}^{k}{N_{i,n}w%
_{i}}}
  </annotation>
 </semantics>
</math>

</p>

<p>In this, 

<math display="inline" id="Non-uniform_rational_B-spline:38">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the number of control points 

<math display="inline" id="Non-uniform_rational_B-spline:39">
 <semantics>
  <msub>
   <mi>ℙ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℙ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{P}_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-uniform_rational_B-spline:40">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

 are the corresponding weights. The denominator is a normalizing factor that evaluates to one if all weights are one. This can be seen from the partition of unity property of the basis functions. It is customary to write this as</p>

<p>

<math display="block" id="Non-uniform_rational_B-spline:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>ℙ</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <list>
        <ci>i</ci>
        <ci>n</ci>
       </list>
      </apply>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℙ</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(u)=\sum_{i=1}^{k}R_{i,n}(u)\mathbb{P}_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>in which the functions</p>

<p>

<math display="block" id="Non-uniform_rational_B-spline:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>N</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>N</mi>
       <mrow>
        <mi>j</mi>
        <mo>,</mo>
        <mi>n</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>w</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <list>
       <ci>i</ci>
       <ci>n</ci>
      </list>
     </apply>
     <ci>u</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <list>
        <ci>i</ci>
        <ci>n</ci>
       </list>
      </apply>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <list>
         <ci>j</ci>
         <ci>n</ci>
        </list>
       </apply>
       <ci>u</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i,n}(u)={N_{i,n}(u)w_{i}\over\sum_{j=1}^{k}N_{j,n}(u)w_{j}}
  </annotation>
 </semantics>
</math>

</p>

<p>are known as the <em>rational basis functions</em>.</p>
<h3 id="general-form-of-a-nurbs-surface">General form of a NURBS surface</h3>

<p>A NURBS surface is obtained as the <a href="tensor_product" title="wikilink">tensor product</a> of two NURBS curves, thus using two independent parameters 

<math display="inline" id="Non-uniform_rational_B-spline:43">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-uniform_rational_B-spline:44">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 (with indices 

<math display="inline" id="Non-uniform_rational_B-spline:45">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-uniform_rational_B-spline:46">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 respectively):<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>

<math display="block" id="Non-uniform_rational_B-spline:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>l</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>R</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>ℙ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ℙ</ci>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(u,v)=\sum_{i=1}^{k}\sum_{j=1}^{l}R_{i,j}(u,v)\mathbb{P}_{i,j}
  </annotation>
 </semantics>
</math>

</p>

<p>with</p>

<p>

<math display="block" id="Non-uniform_rational_B-spline:48">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>N</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>N</mi>
      <mrow>
       <mi>j</mi>
       <mo>,</mo>
       <mi>m</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>p</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>q</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>l</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>N</mi>
        <mrow>
         <mi>p</mi>
         <mo>,</mo>
         <mi>n</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>N</mi>
        <mrow>
         <mi>q</mi>
         <mo>,</mo>
         <mi>m</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>w</mi>
        <mrow>
         <mi>p</mi>
         <mo>,</mo>
         <mi>q</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <list>
        <ci>i</ci>
        <ci>n</ci>
       </list>
      </apply>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <list>
        <ci>j</ci>
        <ci>m</ci>
       </list>
      </apply>
      <ci>v</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <list>
        <ci>i</ci>
        <ci>j</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>q</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>l</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <list>
          <ci>p</ci>
          <ci>n</ci>
         </list>
        </apply>
        <ci>u</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <list>
          <ci>q</ci>
          <ci>m</ci>
         </list>
        </apply>
        <ci>v</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <list>
          <ci>p</ci>
          <ci>q</ci>
         </list>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i,j}(u,v)=\frac{N_{i,n}(u)N_{j,m}(v)w_{i,j}}{\sum_{p=1}^{k}\sum_{q=1}^{l}N_%
{p,n}(u)N_{q,m}(v)w_{p,q}}
  </annotation>
 </semantics>
</math>

</p>

<p>as rational basis functions.</p>
<h2 id="manipulating-nurbs-objects">Manipulating NURBS objects</h2>

<p> A number of transformations can be applied to a NURBS object. For instance, if some curve is defined using a certain degree and N control points, the same curve can be expressed using the same degree and N+1 control points. In the process a number of control points change position and a knot is inserted in the knot vector. These manipulations are used extensively during interactive design. When adding a control point, the shape of the curve should stay the same, forming the starting point for further adjustments. A number of these operations are discussed below.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="knot-insertion">Knot insertion</h3>

<p>As the term suggests, <strong>knot insertion</strong> inserts a knot into the knot vector. If the degree of the curve is 

<math display="inline" id="Non-uniform_rational_B-spline:49">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Non-uniform_rational_B-spline:50">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 control points are replaced by 

<math display="inline" id="Non-uniform_rational_B-spline:51">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 new ones. The shape of the curve stays the same.</p>

<p>A knot can be inserted multiple times, up to the maximum multiplicity of the knot. This is sometimes referred to as <strong>knot refinement</strong> and can be achieved by an algorithm that is more efficient than repeated knot insertion.</p>
<h3 id="knot-removal">Knot removal</h3>

<p><strong>Knot removal</strong> is the reverse of knot insertion. Its purpose is to remove knots and the associated control points in order to get a more compact representation. Obviously, this is not always possible while retaining the exact shape of the curve. In practice, a tolerance in the accuracy is used to determine whether a knot can be removed. The process is used to clean up after an interactive session in which control points may have been added manually, or after importing a curve from a different representation, where a straightforward conversion process leads to redundant control points.</p>
<h3 id="degree-elevation">Degree elevation</h3>

<p>A NURBS curve of a particular degree can always be represented by a NURBS curve of higher degree. This is frequently used when combining separate NURBS curves, e.g., when creating a NURBS surface interpolating between a set of NURBS curves or when unifying adjacent curves. In the process, the different curves should be brought to the same degree, usually the maximum degree of the set of curves. The process is known as <strong>degree elevation</strong>.</p>
<h3 id="curvature">Curvature</h3>

<p>The most important property in <a href="differential_geometry" title="wikilink">differential geometry</a> is the <a class="uri" href="curvature" title="wikilink">curvature</a> 

<math display="inline" id="Non-uniform_rational_B-spline:52">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

. It describes the local properties (edges, corners, etc.) and relations between the first and second derivative, and thus, the precise curve shape. Having determined the derivatives it is easy to compute 

<math display="inline" id="Non-uniform_rational_B-spline:53">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mrow>
        <msup>
         <mi>r</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>×</mo>
       <msup>
        <mi>r</mi>
        <mi>′′</mi>
       </msup>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msup>
        <mi>r</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>3</mn>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>κ</ci>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>r</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>r</ci>
         <ci>′′</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>r</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa=\frac{|r^{\prime}(t)\times r^{\prime\prime}(t)|}{|r^{\prime}(t)|^{3}}
  </annotation>
 </semantics>
</math>

 or approximated as the arclength from the second derivate 

<math display="inline" id="Non-uniform_rational_B-spline:54">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msup>
      <mi>r</mi>
      <mi>′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>s</mi>
       <mi>o</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>κ</ci>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <ci>′′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>o</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa=|r^{\prime\prime}(s_{o})|
  </annotation>
 </semantics>
</math>

. The direct computation of the curvature 

<math display="inline" id="Non-uniform_rational_B-spline:55">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 with these equations is the big advantage of parameterized curves against their polygonal representations.</p>
<h2 id="example-a-circle">Example: a circle</h2>

<p> Non-rational splines or <a href="Bézier_curve" title="wikilink">Bézier curves</a> may approximate a circle, but they cannot represent it exactly. Rational splines can represent any conic section, including the circle, exactly. This representation is not unique, but one possibility appears below:</p>
<center>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><em>x</em></p></th>
<th style="text-align: left;">
<p><em>y</em></p></th>
<th style="text-align: left;">
<p><em>z</em></p></th>
<th style="text-align: left;">
<p>Weight</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Non-uniform_rational_B-spline:56">
 <semantics>
  <mstyle scriptlevel="+1">
   <mfrac>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mn>2</mn>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\frac{\sqrt{2}}{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Non-uniform_rational_B-spline:57">
 <semantics>
  <mstyle scriptlevel="+1">
   <mfrac>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mn>2</mn>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\frac{\sqrt{2}}{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Non-uniform_rational_B-spline:58">
 <semantics>
  <mstyle scriptlevel="+1">
   <mfrac>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mn>2</mn>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\frac{\sqrt{2}}{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Non-uniform_rational_B-spline:59">
 <semantics>
  <mstyle scriptlevel="+1">
   <mfrac>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mn>2</mn>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\frac{\sqrt{2}}{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>
</center>

<p>The order is three, since a circle is a quadratic curve and the spline's order is one more than the degree of its piecewise polynomial segments. The knot vector is 

<math display="inline" id="Non-uniform_rational_B-spline:60">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mrow>
    <mi>π</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>π</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mi>π</mi>
   <mo>,</mo>
   <mi>π</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <mi>π</mi>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <mi>π</mi>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>2</mn>
    <mi>π</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>2</mn>
    <mi>π</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>2</mn>
    <mi>π</mi>
   </mrow>
   <mo rspace="4.2pt" stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <cn type="integer">0</cn>
    <cn type="integer">0</cn>
    <apply>
     <divide></divide>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>π</ci>
    <ci>π</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>π</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>π</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>π</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>π</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>π</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,0,0,\pi/2,\pi/2,\pi,\pi,3\pi/2,3\pi/2,2\pi,2\pi,2\pi\}\,
  </annotation>
 </semantics>
</math>

. The circle is composed of four quarter circles, tied together with double knots. Although double knots in a third order NURBS curve would normally result in loss of continuity in the first derivative, the control points are positioned in such a way that the first derivative is continuous. In fact, the curve is infinitely differentiable everywhere, as it must be if it exactly represents a circle.</p>

<p>The curve represents a circle exactly, but it is not exactly parametrized in the circle's arc length. This means, for example, that the point at 

<math display="inline" id="Non-uniform_rational_B-spline:61">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 does not lie at 

<math display="inline" id="Non-uniform_rational_B-spline:62">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>sin</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>cos</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <sin></sin>
     <ci>t</ci>
    </apply>
    <apply>
     <cos></cos>
     <ci>t</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sin(t),\cos(t))
  </annotation>
 </semantics>
</math>

 (except for the start, middle and end point of each quarter circle, since the representation is symmetrical). This would be impossible, since the <em>x</em> coordinate of the circle would provide an exact rational polynomial expression for 

<math display="inline" id="Non-uniform_rational_B-spline:63">
 <semantics>
  <mrow>
   <mi>cos</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <cos></cos>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos(t)
  </annotation>
 </semantics>
</math>

, which is impossible. The circle does make one full revolution as its parameter 

<math display="inline" id="Non-uniform_rational_B-spline:64">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 goes from 0 to 

<math display="inline" id="Non-uniform_rational_B-spline:65">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\pi
  </annotation>
 </semantics>
</math>

, but this is only because the knot vector was arbitrarily chosen as multiples of 

<math display="inline" id="Non-uniform_rational_B-spline:66">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi/2
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Spline_(mathematics)" title="wikilink">Spline</a></li>
<li><a href="Bézier_surface" title="wikilink">Bézier surface</a></li>
<li><a href="de_Boor's_algorithm" title="wikilink">de Boor's algorithm</a></li>
<li><a href="Triangle_mesh" title="wikilink">Triangle mesh</a></li>
<li><a href="Point_cloud" title="wikilink">Point cloud</a></li>
<li><a href="Rational_motion" title="wikilink">Rational motion</a></li>
<li><a href="Isogeometric_analysis" title="wikilink">Isogeometric analysis</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.rw-designer.com/NURBS">Clear explanation of NURBS for non-experts</a></li>
<li><a href="http://geometrie.foretnik.net/files/NURBS-en.swf">Interactive NURBS demo</a></li>
<li><a href="http://www.cs.wpi.edu/~matt/courses/cs563/talks/nurbs.html">About Nonuniform Rational B-Splines - NURBS</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computer-aided_design" title="wikilink">Category:Computer-aided design</a> <a class="uri" href="Category:Splines" title="wikilink">Category:Splines</a> <a href="Category:3D_computer_graphics" title="wikilink">Category:3D computer graphics</a> <a class="uri" href="Category:Interpolation" title="wikilink">Category:Interpolation</a> <a href="Category:Multivariate_interpolation" title="wikilink">Category:Multivariate interpolation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Foley, van Dam, Feiner &amp; Hughes: <em><a href="Computer_Graphics:_Principles_and_Practice" title="wikilink">Computer Graphics: Principles and Practice</a></em>, section 11.2, <a class="uri" href="Addison-Wesley" title="wikilink">Addison-Wesley</a> 1996 (2nd ed.).<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">David F. Rogers: An Introduction to NURBS with Historical Perspective, section 7.1<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
</ol>
</section>
</body>
</html>
