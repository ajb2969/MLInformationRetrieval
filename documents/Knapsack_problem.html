<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="567">Knapsack problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Knapsack problem</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Example of a one-dimensional (constraint) knapsack problem: which boxes should be chosen to maximize the amount of money while still keeping the overall weight under or equal to 15 kg? A <a href="List_of_knapsack_problems#Multiple_constraints" title="wikilink">multiple constrained problem</a> could consider both the weight and volume of the boxes.<br/>
(Solution: if any number of each box is available, then three yellow boxes and three grey boxes; if only the shown boxes are available, then all but the green box.)</figcaption>
</figure>

<p>The <strong>knapsack problem</strong> or <strong>rucksack problem</strong> is a problem in <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a>: Given a set of items, each with a mass and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size <a class="uri" href="knapsack" title="wikilink">knapsack</a> and must fill it with the most valuable items.</p>

<p>The problem often arises in <a href="resource_allocation" title="wikilink">resource allocation</a> where there are financial constraints and is studied in fields such as <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>, <a href="computer_science" title="wikilink">computer science</a>, <a href="computational_complexity_theory" title="wikilink">complexity theory</a>, <a class="uri" href="cryptography" title="wikilink">cryptography</a> and <a href="applied_mathematics" title="wikilink">applied mathematics</a>.</p>

<p>The knapsack problem has been studied for more than a century, with early works dating as far back as 1897.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is not known how the name "knapsack problem" originated, though the problem was referred to as such in the early works of mathematician <a href="Tobias_Dantzig" title="wikilink">Tobias Dantzig</a> (1884–1956),<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> suggesting that the name could have existed in folklore before a mathematical problem had been fully defined.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="applications">Applications</h2>

<p>A 1998 study of the <a href="http://www.cs.sunysb.edu/~algorith/">Stony Brook University Algorithm Repository</a> showed that, out of 75 algorithmic problems, the knapsack problem was the 18th most popular and the 4th most needed after <a href="kd-tree" title="wikilink">kd-trees</a>, <a href="suffix_tree" title="wikilink">suffix trees</a>, and the <a href="bin_packing_problem" title="wikilink">bin packing problem</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Knapsack problems appear in real-world decision-making processes in a wide variety of fields, such as finding the least wasteful way to cut raw materials,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> seating contest of <a href="investment" title="wikilink">investments</a> and <a href="Portfolio_(finance)" title="wikilink">portfolios</a>,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> seating contest of assets for <a href="Securitization" title="wikilink">asset-backed securitization</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and generating keys for the <a href="Merkle–Hellman_knapsack_cryptosystem" title="wikilink">Merkle–Hellman</a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and other <a href="knapsack_cryptosystems" title="wikilink">knapsack cryptosystems</a>.</p>

<p>One early application of knapsack algorithms was in the construction and scoring of tests in which the test-takers have a choice as to which questions they answer. For small examples it is a fairly simple process to provide the test-takers with such a choice. For example, if an exam contains 12 questions each worth 10 points, the test-taker need only answer 10 questions to achieve a maximum possible score of 100 points. However, on tests with a heterogeneous distribution of point values—i.e. different questions are worth different point values— it is more difficult to provide choices. Feuerman and Weiss proposed a system in which students are given a heterogeneous test with a total of 125 possible points. The students are asked to answer all of the questions to the best of their abilities. Of the possible subsets of problems whose total point values add up to 100, a knapsack algorithm would determine which subset gives each student the highest possible score.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="definition">Definition</h2>

<p>The most common problem being solved is the <strong>0-1 knapsack problem</strong>, which restricts the number <em>x<sub>i</sub></em> of copies of each kind of item to zero or one. Given a set of <em>n</em> items numbered from 1 up to <em>n</em>, each with a weight <em>w<sub>i</sub></em> and a value <em>v<sub>i</sub></em>, along with a maximum weight capacity <em>W</em>,</p>
<dl>
<dd>maximize 

<math display="inline" id="Knapsack_problem:0">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}v_{i}x_{i}
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to 

<math display="inline" id="Knapsack_problem:1">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}w_{i}x_{i}\leq W
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Knapsack_problem:2">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\in\{0,1\}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>Here <em>x<sub>i</sub></em> represents the number of instances of item <em>i</em> to include in the knapsack. Informally, the problem is to maximize the sum of the values of the items in the knapsack so that the sum of the weights is less than or equal to the knapsack's capacity.</p>

<p>The <strong>bounded knapsack problem</strong> (<strong>BKP</strong>) removes the restriction that there is only one of each item, but restricts the number 

<math display="inline" id="Knapsack_problem:3">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>


 of copies of each kind of item to an integer value 

<math display="inline" id="Knapsack_problem:4">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dd>maximize 

<math display="inline" id="Knapsack_problem:5">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}v_{i}x_{i}
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to 

<math display="inline" id="Knapsack_problem:6">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}w_{i}x_{i}\leq W
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Knapsack_problem:7">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\in\{0,\ldots,c_{i}\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The <strong>unbounded knapsack problem</strong> (<strong>UKP</strong>) places no upper bound on the number of copies of each kind of item and can be formulated as above except for that the only restriction on 

<math display="inline" id="Knapsack_problem:8">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>


 is that it is a non-negative integer.</p>
<dl>
<dd>maximize 

<math display="inline" id="Knapsack_problem:9">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}v_{i}x_{i}
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to 

<math display="inline" id="Knapsack_problem:10">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}w_{i}x_{i}\leq W
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Knapsack_problem:11">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\geq 0
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>One example of the unbounded knapsack problem is given using the figure shown at the beginning of this article and the text "if any number of each box is available" in the caption of that figure.</p>
<h2 id="computational-complexity">Computational complexity</h2>

<p>The knapsack problem is interesting from the perspective of computer science for many reasons:</p>
<ul>
<li>The <a href="decision_problem" title="wikilink">decision problem</a> form of the knapsack problem (''Can a value of at least <em>V</em> be achieved without exceeding the weight <em>W</em>?'') is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, thus there is no possible algorithm both correct and fast (polynomial-time) on all cases, unless <a href="P_versus_NP_problem" title="wikilink">P=NP</a>.</li>
<li>While the decision problem is NP-complete, the optimization problem is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, its resolution is at least as difficult as the decision problem, and there is no known polynomial algorithm which can tell, given a solution, whether it is optimal (which would mean that there is no solution with a larger <em>V</em>, thus solving the decision problem NP-complete).</li>
<li>There is a <a href="pseudo-polynomial_time" title="wikilink">pseudo-polynomial time</a> algorithm using <a href="dynamic_programming" title="wikilink">dynamic programming</a>.</li>
<li>There is a <a href="FPTAS" title="wikilink">fully polynomial-time approximation scheme</a>, which uses the pseudo-polynomial time algorithm as a subroutine, described below.</li>
<li>Many cases that arise in practice, and "random instances" from some distributions, can nonetheless be solved exactly.</li>
</ul>

<p>There is a link between the "decision" and "optimization" problems in that if there exists a polynomial algorithm that solves the "decision" problem, then one can find the maximum value for the optimization problem in polynomial time by applying this algorithm iteratively while increasing the value of k . On the other hand, if an algorithm finds the optimal value of optimization problem in polynomial time, then the decision problem can be solved in polynomial time by comparing the value of the solution output by this algorithm with the value of k . Thus, both versions of the problem are of similar difficulty.</p>

<p>One theme in research literature is to identify what the "hard" instances of the knapsack problem look like,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> or viewed another way, to identify what properties of instances in practice might make them more amenable than their worst-case NP-complete behaviour suggests.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The goal in finding these "hard" instances is for their use in <a href="public_key_cryptography" title="wikilink">public key cryptography</a> systems, such as the <a href="Merkle-Hellman_knapsack_cryptosystem" title="wikilink">Merkle-Hellman knapsack cryptosystem</a>.</p>
<h2 id="solving">Solving</h2>

<p>Several algorithms are available to solve knapsack problems, based on dynamic programming approach,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> branch and bound approach<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> or <a href="hybrid_algorithm" title="wikilink">hybridizations</a> of both approaches.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="dynamic-programming-in-advance-algorithm">Dynamic programming in advance algorithm</h3>
<h4 id="unbounded-knapsack-problem">Unbounded knapsack problem</h4>

<p>If all weights (

<math display="inline" id="Knapsack_problem:12">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>w</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1},\ldots,w_{n}
  </annotation>
 </semantics>
</math>

) are nonnegative integers, the knapsack problem can be solved in <a href="pseudo-polynomial_time" title="wikilink">pseudo-polynomial time</a> using <a href="dynamic_programming" title="wikilink">dynamic programming</a>. The following describes a dynamic programming solution for the <em>unbounded</em> knapsack problem.</p>

<p>To simplify things, assume all weights are strictly positive (<em>w<sub>i</sub></em> &gt; 0). We wish to maximize total value subject to the constraint that total weight is less than or equal to <em>W</em>. Then for each <em>w</em> ≤ <em>W</em>, define <em>m[w]</em> to be the maximum value that can be attained with total weight less than or equal to <em>w</em>. <em>m[W]</em> then is the solution to the problem.</p>

<p>Observe that <em>m[w]</em> has the following properties:</p>
<ul>
<li>

<math display="inline" id="Knapsack_problem:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[0]=0\,\!
  </annotation>
 </semantics>
</math>


 (the sum of zero items, i.e., the summation of the empty set)</li>
<li>

<math display="inline" id="Knapsack_problem:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>w</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>max</mi>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>i</mi>
      </msub>
      <mo>≤</mo>
      <mi>w</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>v</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <mi>m</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>w</mi>
         <mo>-</mo>
         <msub>
          <mi>w</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <leq></leq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <ci>w</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>m</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>w</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[w]=\max_{w_{i}\leq w}(v_{i}+m[w-w_{i}])
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>where 

<math display="inline" id="Knapsack_problem:15">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 is the value of the <em>i</em>-th kind of item.</p>

<p>(To formulate the equation above, the idea used is that the solution for a knapsack is the same as the value of one correct item plus the solution for a knapsack with smaller capacity, specifically one with the capacity reduced by the weight of that chosen item.)</p>

<p>Here the maximum of the empty set is taken to be zero. Tabulating the results from 

<math display="inline" id="Knapsack_problem:16">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[0]
  </annotation>
 </semantics>
</math>

 up through 

<math display="inline" id="Knapsack_problem:17">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>W</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[W]
  </annotation>
 </semantics>
</math>

 gives the solution. Since the calculation of each 

<math display="inline" id="Knapsack_problem:18">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>w</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[w]
  </annotation>
 </semantics>
</math>


 involves examining 

<math display="inline" id="Knapsack_problem:19">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 items, and there are 

<math display="inline" id="Knapsack_problem:20">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 values of 

<math display="inline" id="Knapsack_problem:21">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>w</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[w]
  </annotation>
 </semantics>
</math>

 to calculate, the running time of the dynamic programming solution is <a href="Big_O_notation" title="wikilink">

<math display="inline" id="Knapsack_problem:22">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>W</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nW)
  </annotation>
 </semantics>
</math>

</a>. Dividing 

<math display="inline" id="Knapsack_problem:23">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>w</mi>
    <mn>2</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">…</mi>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>w</mi>
    <mi>n</mi>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
    <ci>W</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1},\,w_{2},\,\ldots,\,w_{n},\,W
  </annotation>
 </semantics>
</math>


 by their <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> is a way to improve the running time.</p>

<p>The 

<math display="inline" id="Knapsack_problem:24">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>W</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nW)
  </annotation>
 </semantics>
</math>

 complexity does not contradict the fact that the knapsack problem is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, since 

<math display="inline" id="Knapsack_problem:25">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

, unlike 

<math display="inline" id="Knapsack_problem:26">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, is not polynomial in the length of the input to the problem. The length of the 

<math display="inline" id="Knapsack_problem:27">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 input to the problem is proportional to the number of bits in 

<math display="inline" id="Knapsack_problem:28">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Knapsack_problem:29">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log W
  </annotation>
 </semantics>
</math>

, not to 

<math display="inline" id="Knapsack_problem:30">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 itself.</p>
<h4 id="knapsack-problem">0/1 knapsack problem</h4>

<p>A similar dynamic programming solution for the 0/1 knapsack problem also runs in pseudo-polynomial time. Assume 

<math display="inline" id="Knapsack_problem:31">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>w</mi>
    <mn>2</mn>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">…</mi>
   <mo rspace="4.2pt">,</mo>
   <msub>
    <mi>w</mi>
    <mi>n</mi>
   </msub>
   <mo rspace="4.2pt">,</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
    <ci>W</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1},\,w_{2},\,\ldots,\,w_{n},\,W
  </annotation>
 </semantics>
</math>

 are strictly positive integers. Define 

<math display="inline" id="Knapsack_problem:32">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <interval closure="closed">
     <ci>i</ci>
     <ci>w</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[i,w]
  </annotation>
 </semantics>
</math>

 to be the maximum value that can be attained with weight less than or equal to 

<math display="inline" id="Knapsack_problem:33">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>


 using items up to 

<math display="inline" id="Knapsack_problem:34">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 (first 

<math display="inline" id="Knapsack_problem:35">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 items).</p>

<p>We can define 

<math display="inline" id="Knapsack_problem:36">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <interval closure="closed">
     <ci>i</ci>
     <ci>w</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[i,w]
  </annotation>
 </semantics>
</math>

 recursively as follows:</p>
<ul>
<li>

<math display="inline" id="Knapsack_problem:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>i</mi>
     <mo rspace="4.2pt">,</mo>
     <mi>w</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo rspace="4.2pt">,</mo>
     <mi>w</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <interval closure="closed">
      <ci>i</ci>
      <ci>w</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <interval closure="closed">
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>w</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[i,\,w]=m[i-1,\,w]
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Knapsack_problem:38">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}>w\,\!
  </annotation>
 </semantics>
</math>


 (the new item is more than the current weight limit)</li>
<li>

<math display="inline" id="Knapsack_problem:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>i</mi>
     <mo rspace="4.2pt">,</mo>
     <mi>w</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo rspace="4.2pt">,</mo>
       <mi>w</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt">,</mo>
     <mrow>
      <mrow>
       <mi>m</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>w</mi>
         <mo>-</mo>
         <msub>
          <mi>w</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <msub>
       <mi>v</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <interval closure="closed">
      <ci>i</ci>
      <ci>w</ci>
     </interval>
    </apply>
    <apply>
     <max></max>
     <apply>
      <times></times>
      <ci>m</ci>
      <interval closure="closed">
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>w</ci>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>m</ci>
       <interval closure="closed">
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>w</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[i,\,w]=\max(m[i-1,\,w],\,m[i-1,w-w_{i}]+v_{i})
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Knapsack_problem:40">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>⩽</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}\leqslant w
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The solution can then be found by calculating 

<math display="inline" id="Knapsack_problem:41">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>W</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <interval closure="closed">
     <ci>n</ci>
     <ci>W</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[n,W]
  </annotation>
 </semantics>
</math>

. To do this efficiently we can use a table to store previous computations.</p>

<p>The following is pseudo code for the dynamic program:</p>

<p><code>// Input:</code><br/>
<code>// Values (stored in array v)</code><br/>
<code>// Weights (stored in array w)</code><br/>
<code>// Number of distinct items (n)</code><br/>
<code>// Knapsack capacity (W)</code><br/>
<code>for j from 0 to W do</code><br/>
<code>  m[0, j] := 0</code><br/>
<code>end for </code><br/>
<code>for i from 1 to n do</code><br/>
<code>  for j from 0 to W do</code><br/>
<code>    if w[i] </code><code>O(nW)</code><code> time and </code>

<math display="inline" id="Knapsack_problem:42">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>W</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nW)
  </annotation>
 </semantics>
</math>

<code> space.  Additionally, if we use only a 1-dimensional array </code>

<math display="inline" id="Knapsack_problem:43">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>w</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[w]
  </annotation>
 </semantics>
</math>


<code> to store the current optimal values and pass over this array </code>

<math display="inline" id="Knapsack_problem:44">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>i</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i+1
  </annotation>
 </semantics>
</math>

<code> times, rewriting from </code>

<math display="inline" id="Knapsack_problem:45">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>W</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[W]
  </annotation>
 </semantics>
</math>

<code> to </code>

<math display="inline" id="Knapsack_problem:46">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m[1]
  </annotation>
 </semantics>
</math>

<code> every time, we get the same result for only </code>

<math display="inline" id="Knapsack_problem:47">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(W)
  </annotation>
 </semantics>
</math>

<code> space.</code></p>
<h3 id="meet-in-the-middle">Meet-in-the-middle</h3>

<p>Another algorithm for 0-1 knapsack, discovered in 1974 <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> and sometimes called "meet-in-the-middle" due to parallels to <a href="Meet-in-the-middle_attack" title="wikilink">a similarly named algorithm in cryptography</a>, is exponential in the number of different items but may be preferable to the DP algorithm when 

<math display="inline" id="Knapsack_problem:48">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>


 is large compared to n. In particular, if the 

<math display="inline" id="Knapsack_problem:49">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

 are nonnegative but not integers, we could still use the dynamic programming algorithm by scaling and rounding (i.e. using <a href="fixed-point_arithmetic" title="wikilink">fixed-point arithmetic</a>), but if the problem requires 

<math display="inline" id="Knapsack_problem:50">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 fractional digits of precision to arrive at the correct answer, 

<math display="inline" id="Knapsack_problem:51">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 will need to be scaled by 

<math display="inline" id="Knapsack_problem:52">
 <semantics>
  <msup>
   <mn>10</mn>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">10</cn>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10^{d}
  </annotation>
 </semantics>
</math>

, and the DP algorithm will require 

<math display="inline" id="Knapsack_problem:53">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>W</mi>
     <mo>*</mo>
     <msup>
      <mn>10</mn>
      <mi>d</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>W</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(W*10^{d})
  </annotation>
 </semantics>
</math>


 space and 

<math display="inline" id="Knapsack_problem:54">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mi>W</mi>
     </mrow>
     <mo>*</mo>
     <msup>
      <mn>10</mn>
      <mi>d</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>W</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nW*10^{d})
  </annotation>
 </semantics>
</math>

 time.</p>
<dl>
<dd>'' Meet-in-the-middle algorithm
</dd>
</dl>

<p><code>  </code><strong><code>input:</code></strong><code> </code><br/>
<code>    a set of items with weights and values</code><br/>
<code>  </code><strong><code>output:</code></strong><code> </code><br/>
<code>    the greatest combined value of a subset</code><br/>
<code>  partition the set {1...n} into two sets A and B of approximately equal size</code><br/>
<code>  compute the weights and values of all subsets of each set</code><br/>
<code>  </code><strong><code>for</code></strong><code> each subset of A</code><br/>
<code>    find the subset of B of greatest value such that the combined weight is less than W</code><br/>
<code>  keep track of the greatest combined value seen so far</code></p>

<p>The algorithm takes 

<math display="inline" id="Knapsack_problem:55">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(2^{n/2})
  </annotation>
 </semantics>
</math>

 space, and efficient implementations of step 3 (for instance, sorting the subsets of B by weight, discarding subsets of B which weigh more than other subsets of B of greater or equal value, and using binary search to find the best match) result in a runtime of 

<math display="inline" id="Knapsack_problem:56">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>*</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n*2^{n/2})
  </annotation>
 </semantics>
</math>

. As with the <a href="Meet-in-the-middle_attack" title="wikilink">meet in the middle attack</a> in cryptography, this improves on the 

<math display="inline" id="Knapsack_problem:57">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>*</mo>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n*2^{n})
  </annotation>
 </semantics>
</math>

 runtime of a naive brute force approach (examining all subsets of {1...n}), at the cost of using exponential rather than constant space (see also <a href="baby-step_giant-step" title="wikilink">baby-step giant-step</a>).</p>
<h3 id="approximation-algorithms">Approximation algorithms</h3>

<p>As for most NP-complete problems, it may be enough to find workable solutions even if they are not optimal. Preferably, however, the approximation comes with a guarantee on the difference between the value of the solution found and the value of the optimal solution.</p>

<p>As with many useful but computationally complex algorithms, there has been substantial research on creating and analyzing algorithms that approximate a solution. The knapsack problem, though NP-Hard, is one of a collection of algorithms that can still be approximated to any specified degree. This means that the problem has a polynomial time approximation scheme. To be exact, the knapsack problem has a fully polynomial time approximation scheme (FPTAS).<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h4 id="greedy-approximation-algorithm">Greedy approximation algorithm</h4>

<p><a href="George_Dantzig" title="wikilink">George Dantzig</a> proposed a <a href="greedy_algorithm" title="wikilink">greedy</a> <a href="approximation_algorithm" title="wikilink">approximation algorithm</a> to solve the unbounded knapsack problem.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> His version sorts the items in decreasing order of value per unit of weight, 

<math display="inline" id="Knapsack_problem:58">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>/</mo>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}/w_{i}
  </annotation>
 </semantics>
</math>


. It then proceeds to insert them into the sack, starting with as many copies as possible of the first kind of item until there is no longer space in the sack for more. Provided that there is an unlimited supply of each kind of item, if 

<math display="inline" id="Knapsack_problem:59">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the maximum value of items that fit into the sack, then the greedy algorithm is guaranteed to achieve at least a value of 

<math display="inline" id="Knapsack_problem:60">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>m</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m/2
  </annotation>
 </semantics>
</math>

. However, for the bounded problem, where the supply of each kind of item is limited, the algorithm may be far from optimal.</p>
<h4 id="fully-polynomial-time-approximation-scheme">Fully polynomial time approximation scheme</h4>

<p>The <a href="fully_polynomial_time_approximation_scheme" title="wikilink">fully polynomial time approximation scheme</a> (FPTAS) for the knapsack problem takes advantage of the fact that the reason the problem has no known polynomial time solutions is because the profits associated with the items are not restricted. If one rounds off some of the least significant digits of the profit values then they will be bounded by a polynomial and 1/ε where ε is a bound on the correctness of the solution. This restriction then means that an algorithm can find a solution in polynomial time that is correct within a factor of (1-ε) of the optimal solution.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<dl>
<dd>'' An Algorithm for FPTAS
</dd>
</dl>

<p><code> </code><strong><code>input</code></strong><code>: </code><br/>
<code>   ε ∈ [0,1]</code><br/>
<code>   a list A of n items, specified by their values, </code>

<math display="inline" id="Knapsack_problem:61">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

<code>, and weights</code><br/>
<code> </code><strong><code>output</code></strong><code>:</code><br/>
<code>   S' the FPTAS solution</code></p>

<p><code> P := max </code>

<math display="inline" id="Knapsack_problem:62">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <mrow>
    <mn>1</mn>
    <mo>≤</mo>
    <mi>i</mi>
    <mo>≤</mo>
    <mi>n</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v_{i}\mid 1\leq i\leq n\}
  </annotation>
 </semantics>
</math>

<code>  // the highest item value</code><br/>
<code> K := εP/n</code><br/>
<code> </code><strong><code>for</code></strong><code> i </code><strong><code>from</code></strong><code> 1 </code><strong><code>to</code></strong><code> n </code><strong><code>do</code></strong><br/>
<code>    </code>

<math display="inline" id="Knapsack_problem:63">
 <semantics>
  <msubsup>
   <mi>v</mi>
   <mi>i</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>v</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{\prime}_{i}
  </annotation>
 </semantics>
</math>


<code> := ⌊</code>

<math display="inline" id="Knapsack_problem:64">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

<code>/K⌋</code><br/>
<code> </code><strong><code>end</code> <code>for</code></strong><br/>
<code> </code><strong><code>return</code></strong><code> the solution, S', using the </code>

<math display="inline" id="Knapsack_problem:65">
 <semantics>
  <msubsup>
   <mi>v</mi>
   <mi>i</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>v</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{\prime}_{i}
  </annotation>
 </semantics>
</math>

<code> values in the dynamic program outlined above</code></p>

<p><strong>Theorem:</strong> The set 

<math display="inline" id="Knapsack_problem:66">
 <semantics>
  <msup>
   <mi>S</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}
  </annotation>
 </semantics>
</math>

 computed by the algorithm above satisfies 

<math display="inline" id="Knapsack_problem:67">
 <semantics>
  <mrow>
   <mrow>
    <mi>profit</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>ε</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mi>profit</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>profit</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ε</ci>
      </apply>
      <ci>profit</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{profit}(S^{\prime})\geq(1-\varepsilon)\cdot\mathrm{profit}(S^{*})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Knapsack_problem:68">
 <semantics>
  <msup>
   <mi>S</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{*}
  </annotation>
 </semantics>
</math>


 is an optimal solution.</p>
<h3 id="dominance-relations">Dominance relations</h3>

<p>Solving the unbounded knapsack problem can be made easier by throwing away items which will never be needed. For a given item <em>i</em>, suppose we could find a set of items <em>J</em> such that their total weight is less than the weight of <em>i</em>, and their total value is greater than the value of <em>i</em>. Then <em>i</em> cannot appear in the optimal solution, because we could always improve any potential solution containing <em>i</em> by replacing <em>i</em> with the set <em>J</em>. Therefore we can disregard the <em>i</em>-th item altogether. In such cases, <em>J</em> is said to <strong>dominate</strong> <em>i</em>. (Note that this does not apply to bounded knapsack problems, since we may have already used up the items in <em>J</em>.)</p>

<p>Finding dominance relations allows us to significantly reduce the size of the search space. There are several different types of <a href="dominance_relations" title="wikilink">dominance relations</a>,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> which all satisfy an inequality of the form:</p>

<p>

<math display="inline" id="Knapsack_problem:69">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" lspace="22.5pt" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mi>J</mi>
     </mrow>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>w</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
     <mpadded width="+5pt">
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>α</mi>
    </mpadded>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>j</ci>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad\sum_{j\in J}w_{j}\,x_{j}\ \leq\alpha\,w_{i}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Knapsack_problem:70">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" lspace="22.5pt" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mi>J</mi>
     </mrow>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>v</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
     <mpadded width="+5pt">
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>α</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>j</ci>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad\sum_{j\in J}v_{j}\,x_{j}\ \geq\alpha\,v_{i}\,
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Knapsack_problem:71">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>Z</mi>
    <mo>+</mo>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <plus></plus>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in Z_{+}^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Knapsack_problem:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mo>∈</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>Z</mi>
      <mo>+</mo>
     </msub>
    </mpadded>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>J</mi>
    <mo>⊆</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>α</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <plus></plus>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <ci>J</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in Z_{+}\,,J\subseteq N
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Knapsack_problem:73">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∉</mo>
   <mi>J</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>i</ci>
    <ci>J</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\not\in J
  </annotation>
 </semantics>
</math>


. The vector 

<math display="inline" id="Knapsack_problem:74">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 denotes the number of copies of each member of <em>J</em>.</p>
<dl>
<dt>Collective dominance: The <em>i</em>-th item is <strong>collectively dominated</strong> by <em>J</em>, written as 

<math display="inline" id="Knapsack_problem:75">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>≪</mo>
   <mi>J</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-less-than</csymbol>
    <ci>i</ci>
    <ci>J</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\ll J
  </annotation>
 </semantics>
</math>

, if the total weight of some combination of items in <em>J</em> is less than <em>w<sub>i</sub></em> and their total value is greater than <em>v<sub>i</sub></em>. Formally, 

<math display="inline" id="Knapsack_problem:76">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" lspace="22.5pt" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mi>J</mi>
     </mrow>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>w</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
     <mpadded width="+5pt">
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>j</ci>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad\sum_{j\in J}w_{j}\,x_{j}\ \leq w_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Knapsack_problem:77">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" lspace="22.5pt" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mi>J</mi>
     </mrow>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>v</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
     <mpadded width="+5pt">
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>j</ci>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad\sum_{j\in J}v_{j}\,x_{j}\ \geq v_{i}
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Knapsack_problem:78">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>Z</mi>
    <mo>+</mo>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <plus></plus>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in Z_{+}^{n}
  </annotation>
 </semantics>
</math>


, i.e. 

<math display="inline" id="Knapsack_problem:79">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=1
  </annotation>
 </semantics>
</math>

. Verifying this dominance is computationally hard, so it can only be used with a dynamic programming approach. In fact, this is equivalent to solving a smaller knapsack decision problem where2 <em>V</em> = <em>v<sub>i</sub></em>, <em>W</em> = <em>w<sub>i</sub></em>, and the items are restricted to <em>J</em>.<br/>
Threshold dominance: The <em>i</em>-th item is <strong>threshold dominated</strong> by <em>J</em>, written as 

<math display="inline" id="Knapsack_problem:80">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>≺</mo>
   <mo>≺</mo>
   <mi>J</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="latexml">precedes</csymbol>
    <csymbol cd="latexml">precedes</csymbol>
    <csymbol cd="unknown">J</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\prec\prec J
  </annotation>
 </semantics>
</math>

, if some number of copies of <em>i</em> are dominated by <em>J</em>. Formally, 

<math display="inline" id="Knapsack_problem:81">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" lspace="22.5pt" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mi>J</mi>
     </mrow>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>w</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
     <mpadded width="+5pt">
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>α</mi>
    </mpadded>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>j</ci>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad\sum_{j\in J}w_{j}\,x_{j}\ \leq\alpha\,w_{i}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Knapsack_problem:82">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" lspace="22.5pt" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mi>J</mi>
     </mrow>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>v</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
     <mpadded width="+5pt">
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>α</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>j</ci>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad\sum_{j\in J}v_{j}\,x_{j}\ \geq\alpha\,v_{i}\,
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Knapsack_problem:83">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>Z</mi>
    <mo>+</mo>
    <mi>n</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <plus></plus>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in Z_{+}^{n}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Knapsack_problem:84">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\geq 1
  </annotation>
 </semantics>
</math>

. This is a generalization of collective dominance, first introduced in<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> and used in the EDUK algorithm. The smallest such 

<math display="inline" id="Knapsack_problem:85">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 defines the <strong>threshold</strong> of the item <em>i</em>, written 

<math display="inline" id="Knapsack_problem:86">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>α</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{i}=(\alpha-1)w_{i}
  </annotation>
 </semantics>
</math>

. In this case, the optimal solution could contain at most 

<math display="inline" id="Knapsack_problem:87">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha-1
  </annotation>
 </semantics>
</math>

 copies of <em>i</em>.<br/>
Multiple dominance: The <em>i</em>-th item is <strong>multiply dominated</strong> by a single item <em>j</em>, written as 

<math display="inline" id="Knapsack_problem:88">
 <semantics>
  <mrow>
   <mi>i</mi>
   <msub>
    <mo>≪</mo>
    <mi>m</mi>
   </msub>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">much-less-than</csymbol>
     <ci>m</ci>
    </apply>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\ll_{m}j
  </annotation>
 </semantics>
</math>


, if <em>i</em> is dominated by some number of copies of <em>j</em>. Formally, 

<math display="inline" id="Knapsack_problem:89">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <msub>
      <mpadded lspace="20pt" width="+20pt">
       <mi>w</mi>
      </mpadded>
      <mi>j</mi>
     </msub>
    </mpadded>
    <mpadded width="+5pt">
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
    </mpadded>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad w_{j}\,x_{j}\ \leq w_{i}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Knapsack_problem:90">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <msub>
      <mpadded lspace="20pt" width="+20pt">
       <mi>v</mi>
      </mpadded>
      <mi>j</mi>
     </msub>
    </mpadded>
    <mpadded width="+5pt">
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
    </mpadded>
   </mrow>
   <mo>≥</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad v_{j}\,x_{j}\ \geq v_{i}
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Knapsack_problem:91">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi>Z</mi>
    <mo>+</mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}\in Z_{+}
  </annotation>
 </semantics>
</math>

 i.e. 

<math display="inline" id="Knapsack_problem:92">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>j</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mo stretchy="false">⌊</mo>
      <mfrac>
       <msub>
        <mi>w</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>w</mi>
        <mi>j</mi>
       </msub>
      </mfrac>
      <mo stretchy="false">⌋</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>J</ci>
     <set>
      <ci>j</ci>
     </set>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <floor></floor>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\{j\},\alpha=1,x_{j}=\lfloor\frac{w_{i}}{w_{j}}\rfloor
  </annotation>
 </semantics>
</math>

. This dominance could be efficiently used during preprocessing because it can be detected relatively easily.<br/>
Modular dominance: Let <em>b</em> be the <em>best item</em>, i.e. 

<math display="inline" id="Knapsack_problem:93">
 <semantics>
  <mrow>
   <mfrac>
    <msub>
     <mi>v</mi>
     <mi>b</mi>
    </msub>
    <msub>
     <mi>w</mi>
     <mi>b</mi>
    </msub>
   </mfrac>
   <mo>≥</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{v_{b}}{w_{b}}\geq\frac{v_{i}}{w_{i}}\,
  </annotation>
 </semantics>
</math>


 for all <em>i</em>. This is the item with the greatest density of value. The <em>i</em>-th item is <strong>modularly dominated</strong> by a single item <em>j</em>, written as 

<math display="inline" id="Knapsack_problem:94">
 <semantics>
  <mrow>
   <mi>i</mi>
   <msub>
    <mo>≪</mo>
    <mo>≡</mo>
   </msub>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">much-less-than</csymbol>
     <equivalent></equivalent>
    </apply>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\ll_{\equiv}j
  </annotation>
 </semantics>
</math>

, if <em>i</em> is dominated by <em>j</em> plus several copies of <em>b</em>. Formally, 

<math display="inline" id="Knapsack_problem:95">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>j</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>t</mi>
     <msub>
      <mi>w</mi>
      <mi>b</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}+tw_{b}\leq w_{i}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Knapsack_problem:96">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>t</mi>
     <msub>
      <mi>v</mi>
      <mi>b</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{j}+tv_{b}\geq v_{i}
  </annotation>
 </semantics>
</math>

 i.e. 

<math display="inline" id="Knapsack_problem:97">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>b</mi>
      </msub>
      <mo>=</mo>
      <mi>t</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>J</ci>
     <set>
      <ci>b</ci>
      <ci>j</ci>
     </set>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>b</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\{b,j\},\alpha=1,x_{b}=t,x_{j}=1
  </annotation>
 </semantics>
</math>

.</dt>
</dl>
<h2 id="variations">Variations</h2>

<p>There are many variations of the knapsack problem that have arisen from the vast number of applications of the basic problem. The main variations occur by changing the number of some problem parameter such as the number of items, number of objectives, or even the number of knapsacks.</p>
<h3 id="multi-objective-knapsack-problem">Multi-objective knapsack problem</h3>

<p>This variation changes the goal of the individual filling the knapsack. Instead of one objective, such as maximizing the monetary profit, the objective could have several dimensions. For example there could be environmental or social concerns as well as economic goals. Problems frequently addressed include portfolio and transportation logistics optimizations <a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>As a concrete example, suppose you ran a cruise ship. You have to decide how many famous comedians to hire. This boat can handle no more than one ton of passengers and the entertainers must weigh less than 1000 lbs. Each comedian has a weight, brings in business based on their popularity and asks for a specific salary. In this example you have multiple objectives. You want, of course, to maximize the popularity of your entertainers while minimizing their salaries. Also, you want to have as many entertainers as possible.</p>
<h3 id="multi-dimensional-knapsack-problem">Multi-dimensional knapsack problem</h3>

<p>In this variation, the weight of knapsack item 

<math display="inline" id="Knapsack_problem:98">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


 is given by a D-dimensional vector 

<math display="inline" id="Knapsack_problem:99">
 <semantics>
  <mrow>
   <mover accent="true">
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
    <mo>¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mi>D</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>D</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{w_{i}}=(w_{i1},\ldots,w_{iD})
  </annotation>
 </semantics>
</math>

 and the knapsack has a D-dimensional capacity vector 

<math display="inline" id="Knapsack_problem:100">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>W</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>W</mi>
    <mi>D</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>D</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (W_{1},\ldots,W_{D})
  </annotation>
 </semantics>
</math>

. The target is to maximize the sum of the values of the items in the knapsack so that the sum of weights in each dimension 

<math display="inline" id="Knapsack_problem:101">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 does not exceed 

<math display="inline" id="Knapsack_problem:102">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>d</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{d}
  </annotation>
 </semantics>
</math>

.</p>

<p>Multi-dimensional knapsack is computationally harder than knapsack; even for 

<math display="inline" id="Knapsack_problem:103">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=2
  </annotation>
 </semantics>
</math>


, the problem does not have <a class="uri" href="EPTAS" title="wikilink">EPTAS</a> unless P

<math display="inline" id="Knapsack_problem:104">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

NP.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> However, the algorithm in <a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> is shown to solve sparse instances efficiently. An instance of multi-dimensional knapsack is sparse if there is a set 

<math display="inline" id="Knapsack_problem:105">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>m</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\{1,2,\ldots,m\}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Knapsack_problem:106">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>z</mi>
   </mrow>
   <mo>></mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <exists></exists>
     <ci>z</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists z>m
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Knapsack_problem:107">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>j</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>J</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>z</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>j</ci>
     </apply>
     <apply>
      <union></union>
      <ci>J</ci>
      <set>
       <ci>z</ci>
      </set>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall j\in J\cup\{z\},\ w_{ij}\geq 0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Knapsack_problem:108">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>y</mi>
    </mrow>
    <mo>∉</mo>
    <mrow>
     <mi>J</mi>
     <mo>∪</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>z</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mi>y</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <notin></notin>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>y</ci>
     </apply>
     <apply>
      <union></union>
      <ci>J</ci>
      <set>
       <ci>z</ci>
      </set>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall y\notin J\cup\{z\},w_{iy}=0
  </annotation>
 </semantics>
</math>


 and 

<math display="block" id="Knapsack_problem:109">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}=v_{i}
  </annotation>
 </semantics>
</math>

. Such instances occur, for example, when scheduling packets in a wireless network with relay nodes.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> The algorithm from <a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> also solves sparse instances of the multiple choice variant, multiple-choice multi-dimensional knapsack.</p>
<h3 id="multiple-knapsack-problem">Multiple knapsack problem</h3>

<p>This variation is similar to the <a href="Bin_packing_problem" title="wikilink">Bin Packing Problem</a>. It differs from the Bin Packing Problem in that a subset of items can be selected, whereas, in the Bin Packing Problem, all items have to be packed to certain bins. The concept is that there are multiple knapsacks. This may seem like a trivial change, but it is not equivalent to adding to the capacity of the initial knapsack. This variation is used in many loading and scheduling problems in Operations Research and has a <a href="Polynomial-time_approximation_scheme" title="wikilink">PTAS</a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h3 id="quadratic-knapsack-problem">Quadratic knapsack problem</h3>

<p>As described by Wu et al.:</p>
<blockquote>

<p>The quadratic knapsack problem (QKP) maximizes a quadratic objective function subject to a binary and linear capacity constraint.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>
</blockquote>

<p>The quadratic knapsack problem was discussed under that title by Gallo, Hammer, and Simeone in 1980.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> However, Gallo and Simeone<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> attribute the first treatment of the problem to Witzgall<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> in 1975.</p>
<h3 id="subset-sum-problem">Subset-sum problem</h3>

<p>The <a href="subset_sum_problem" title="wikilink">subset sum problem</a>, is a special case of the decision and <strong>0-1</strong> problems where each kind of item, the weight equals the value<span class="LaTeX">$$w_i=v_i$$</span>. In the field of <a class="uri" href="cryptography" title="wikilink">cryptography</a>, the term <em>knapsack problem</em> is often used to refer specifically to the subset sum problem and is commonly known as one of <a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a>.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>

<p>The generalization of subset sum problem is called multiple subset-sum problem, in which multiple bins exist with the same capacity. It has been shown that the generalization does not have an FPTAS.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>
<h2 id="software">Software</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>License</p></th>
<th style="text-align: left;">
<p>Brief info</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Practical_Approximation_Algorithms_Library_(PAAL)" title="wikilink">PAAL</a></p></td>
<td style="text-align: left;">
<p>BOOST LICENSE</p></td>
<td style="text-align: left;">
<p>Approximation algorithms library containing generic and efficient implementations of various knapsack algorithms including: dynamic algorithm, greedy (2-approximation) and FPTAS. The above algorithms are implemented for both 0/1 and unbounded versions of the problem.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="OpenOpt" title="wikilink">OpenOpt</a></p></td>
<td style="text-align: left;">
<p>BSD</p></td>
<td style="text-align: left;">
<p>Free Python language framework that can use either free or commercial <a href="Mixed_integer_linear_programming#Integer_unknowns" title="wikilink">MILP</a> and other solvers to solve knapsack problems, possibly constrained, nonlinear and multiobjective.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>adagio</p></td>
<td style="text-align: left;">
<p>GPL</p></td>
<td style="text-align: left;">
<p>The <a href="R_(programming_language)" title="wikilink">R</a>'s <a href="CRAN_(R_programming_language)" title="wikilink">CRAN</a> package <code>adagio</code> provides methods and algorithms for discrete optimization and (evolutionary) global optimization.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Algorithm::Knapsack</p></td>
<td style="text-align: left;">
<p>Perl 5</p></td>
<td style="text-align: left;">
<p>[<a class="uri" href="https://metacpan.org/pod/Algorithm">https://metacpan.org/pod/Algorithm</a>::Knapsack Algorithm::Knapsack] is a simple Perl module that solves 0/1 versions of the knapsack problem.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p></td>
</tr>
</tbody>
</table>
<h2 id="popular-culture">Popular culture</h2>
<ul>
<li>Neal Stephenson provides an example of the knapsack problem in chapter 70 of his novel, <em><a class="uri" href="Cryptonomicon" title="wikilink">Cryptonomicon</a></em>, to distribute family heirlooms.</li>
<li>The knapsack problem occurs commonly in role-playing games, both digital and paper-based (prominent examples include <em><a href="The_Elder_Scrolls" title="wikilink">The Elder Scrolls</a></em> series and the <em><a href="Dungeons_and_Dragons" title="wikilink">Dungeons and Dragons</a></em> game, respectively), where the player character is constrained by their encumbrance threshold when carrying items and treasure, which regularly forces the player to evaluate the items' value-to-weight ratio in order to bring only the most valuable items to a merchant.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Change-making_problem" title="wikilink">Change-making problem</a></li>
<li><a href="Combinatorial_auction" title="wikilink">Combinatorial auction</a></li>
<li><a href="Combinatorial_optimization" title="wikilink">Combinatorial optimization</a></li>
<li><a href="Continuous_knapsack_problem" title="wikilink">Continuous knapsack problem</a></li>
<li><a href="Cutting_stock_problem" title="wikilink">Cutting stock problem</a></li>
<li><a href="List_of_knapsack_problems" title="wikilink">List of knapsack problems</a></li>
<li><a href="Packing_problem" title="wikilink">Packing problem</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>A6: MP9, pg.247.</p></li>
<li><cite name="Kellerer"></cite>
</li>
<li><cite name="Martello"></cite></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cse.unl.edu/~goddard/Courses/CSCE310J/Lectures/Lecture8-DynamicProgramming.pdf">Lecture slides on the knapsack problem</a></li>
<li><a href="http://download.gna.org/pyasukp">PYAsUKP: Yet Another solver for the Unbounded Knapsack Problem</a>, with code taking advantage of the dominance relations in an hybrid algorithm, benchmarks and downloadable copies of some papers.</li>
<li><a href="http://www.diku.dk/~pisinger/">Home page of David Pisinger</a> with downloadable copies of some papers on the publication list (including "Where are the hard knapsack problems?")</li>
<li><a href="http://rosettacode.org/wiki/Knapsack_Problem">Knapsack Problem solutions in many languages</a> at <a href="Rosetta_Code" title="wikilink">Rosetta Code</a></li>
<li><a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/Dynamic/knapsackdyn.htm">Dynamic Programming algorithm to 0/1 Knapsack problem</a></li>
<li><a href="http://karaffeltut.com/NEWKaraffeltutCom/Knapsack/knapsack.html">Knapsack Problem solver (online)</a></li>
<li><a href="http://allievi.sssup.it/jacopo/BB/">Interactive JavaScript branch-and-bound solver</a></li>
<li><a href="http://www.nils-haldenwang.de/computer-science/computational-intelligence/genetic-algorithm-vs-0-1-knapsack">Solving 0-1-KNAPSACK with Genetic Algorithms in Ruby</a></li>
<li><a href="http://www.adaptivebox.net/CILib/code/qkpcodes_link.html">Codes for Quadratic Knapsack Problem</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a> <a href="Category:Packing_problems" title="wikilink">Category:Packing problems</a> <a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Dynamic_programming" title="wikilink">Category:Dynamic programming</a> <a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a> <a href="Category:Weakly_NP-complete_problems" title="wikilink">Category:Weakly NP-complete problems</a> <a href="Category:Pseudo-polynomial_time_algorithms" title="wikilink">Category:Pseudo-polynomial time algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Dantzig, Tobias. Numbers: The Language of Science, 1930.<a href="#fnref2">↩</a></li>
<li id="fn3">Kellerer, Pferschy, and Pisinger 2004, p. 3<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Kellerer, Pferschy, and Pisinger 2004, p. 449<a href="#fnref5">↩</a></li>
<li id="fn6">Kellerer, Pferschy, and Pisinger 2004, p. 461<a href="#fnref6">↩</a></li>
<li id="fn7">Kellerer, Pferschy, and Pisinger 2004, p. 465<a href="#fnref7">↩</a></li>
<li id="fn8">Kellerer, Pferschy, and Pisinger 2004, p. 472<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Pisinger, D. 2003. Where are the hard knapsack problems? Technical Report 2003/08, Department of Computer Science, University of Copenhagen, Copenhagen, Denmark.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">Vincent Poirriez, Nicola Yanev, Rumen Andonov (2009) A Hybrid Algorithm for the Unbounded Knapsack Problem <em>Discrete Optimization</em> <a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14">S. Martello, P. Toth, Knapsack Problems: Algorithms and Computer Implementation, John Wiley and Sons, 1990<a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16">S. Martello, D. Pisinger, P. Toth, Dynamic programming and strong bounds for the 0-1 knapsack problem, <em>Manag. Sci.</em>, 45:414–424, 1999.<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20">Vazirani, Vijay. Approximation Algorithms. Springer-Verlag Berlin Heidelberg, 2003.<a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23">Vincent Poirriez, Nicola Yanev, Rumen Andonov (2009) A Hybrid Algorithm for the Unbounded Knapsack Problem, section 2: Discrete Optimization <a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25">Chang, T. J., et al. Heuristics for Cardinality Constrained Portfolio Optimization. Technical Report, London SW7 2AZ, England: The Management School, Imperial College, May 1998<a href="#fnref25">↩</a></li>
<li id="fn26">Chang, C. S., et al. "Genetic Algorithm Based Bicriterion Optimization for Traction Substations in DC Railway System." In Fogel [102], 11-16.<a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28">Cohen, R. and Grebla, G. 2014. <a href="http://wimnet.ee.columbia.edu/wp-content/uploads/2013/03/paper_short.pdf">"Multi-Dimensional OFDMA Scheduling in a Wireless Network with Relay Nodes"</a>. in <em>Proc. IEEE INFOCOM’14</em>, 2427–2435.<a href="#fnref28">↩</a></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31">Chandra Chekuri and Sanjeev Khanna. 2000. A PTAS for the multiple knapsack problem. In Proceedings of the eleventh annual ACM-SIAM symposium on Discrete algorithms (SODA '00). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 213-222.<a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36">Richard M. Karp (1972). "Reducibility Among Combinatorial Problems". In R. E. Miller and J. W. Thatcher (editors). Complexity of Computer Computations. New York: Plenum. pp. 85–103<a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
</ol>
</section>
</body>
</html>
