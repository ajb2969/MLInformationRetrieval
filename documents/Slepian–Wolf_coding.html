<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="641">Slepian–Wolf coding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Slepian–Wolf coding</h1>
<hr/>

<p>__NOTOC__ In <a href="information_theory" title="wikilink">information theory</a> and <a class="uri" href="communication" title="wikilink">communication</a>, the <strong>Slepian–Wolf coding</strong>, also known as the <strong>Slepian–Wolf bound</strong>, is a fundamental result in <a href="distributed_source_coding" title="wikilink">distributed source coding</a> discovered by <a href="David_Slepian" title="wikilink">David Slepian</a> and <a href="Jack_Wolf" title="wikilink">Jack Wolf</a> in 1973. It is a method of theoretically <a href="Line_code" title="wikilink">coding</a> two <a href="Lossless_compression" title="wikilink">lossless compressed</a> correlated <a href="Communication_source" title="wikilink">sources</a>.</p>

<p>Distributed coding is the coding of two, in this case, or more dependent sources with separate <a href="encoder" title="wikilink">encoders</a> and a joint <a href="Codec" title="wikilink">decoder</a>. Given two statistically dependent i.i.d. finite-alphabet random <a href="sequence" title="wikilink">sequences</a> X and Y, the Slepian–Wolf theorem includes theoretical bound for the lossless coding rate for distributed coding of the two sources as shown below:</p>

<p>

<math display="block" id="Slepian–Wolf_coding:0">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>X</mi>
   </msub>
   <mo>≥</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>X</ci>
    </apply>
    <geq></geq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}\geq H(X|Y),\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Slepian–Wolf_coding:1">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>Y</mi>
   </msub>
   <mo>≥</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>Y</ci>
    </apply>
    <geq></geq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{Y}\geq H(Y|X),\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Slepian–Wolf_coding:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>X</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mi>Y</mi>
     </msub>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <interval closure="open">
      <ci>X</ci>
      <ci>Y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{X}+R_{Y}\geq H(X,Y).\,
  </annotation>
 </semantics>
</math>

</p>

<p>If both the encoder and the decoder of the two sources are independent, the lowest rate it can achieve for lossless compression is 

<math display="inline" id="Slepian–Wolf_coding:3">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Slepian–Wolf_coding:4">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(Y)
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Slepian–Wolf_coding:5">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Slepian–Wolf_coding:6">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 respectively, where 

<math display="inline" id="Slepian–Wolf_coding:7">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Slepian–Wolf_coding:8">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(Y)
  </annotation>
 </semantics>
</math>

 are the entropies of 

<math display="inline" id="Slepian–Wolf_coding:9">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Slepian–Wolf_coding:10">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. However, with joint decoding, if vanishing error probability for long sequences is accepted, the Slepian–Wolf theorem shows that much better compression rate can be achieved. As long as the total rate of 

<math display="inline" id="Slepian–Wolf_coding:11">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Slepian–Wolf_coding:12">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is larger than their joint entropy 

<math display="inline" id="Slepian–Wolf_coding:13">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X,Y)
  </annotation>
 </semantics>
</math>

 and none of the sources is encoded with a rate larger than its <a class="uri" href="entropy" title="wikilink">entropy</a>, distributed coding can achieve arbitrarily small <a href="Probability_of_error" title="wikilink">error probability</a> for long sequences.</p>

<p>A special case of distributed coding is compression with decoder side information, where source 

<math display="inline" id="Slepian–Wolf_coding:14">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 is available at the decoder side but not accessible at the encoder side. This can be treated as the condition that 

<math display="inline" id="Slepian–Wolf_coding:15">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>Y</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{Y}=H(Y)
  </annotation>
 </semantics>
</math>

 has already been used to encode 

<math display="inline" id="Slepian–Wolf_coding:16">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

, while we intend to use 

<math display="inline" id="Slepian–Wolf_coding:17">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X|Y)
  </annotation>
 </semantics>
</math>

 to encode 

<math display="inline" id="Slepian–Wolf_coding:18">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

. In other words, two isolated sources can compress data as efficiently as if they were communicating with each other. The whole system is operating in an asymmetric way (compression rate for the two sources are asymmetric).</p>

<p>This bound has been extended to the case of more than two correlated sources by <a href="Thomas_M._Cover" title="wikilink">Thomas M. Cover</a> in 1975, and similar results were obtained in 1976 by <a href="Aaron_D._Wyner" title="wikilink">Aaron D. Wyner</a> and <a href="Jacob_Ziv" title="wikilink">Jacob Ziv</a> with regard to lossy coding of joint Gaussian sources.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Data_compression" title="wikilink">Data compression</a></li>
<li><a href="Data_synchronization" title="wikilink">Data synchronization</a>
<ul>
<li><a href="Synchronization_(computer_science)" title="wikilink">Synchronization (computer science)</a></li>
</ul></li>
<li><a class="uri" href="DISCUS" title="wikilink">DISCUS</a></li>
<li><a href="Timeline_of_information_theory" title="wikilink">Timeline of information theory</a></li>
</ul>
<h2 id="references">References</h2>
<h3 id="sources">Sources</h3>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://ivms.stanford.edu/~dsc/wzcodingvideo">Wyner-Ziv Coding of Video</a> algorithm for video compression that performs close to the Slepian–Wolf bound (with links to source code).</li>
</ul>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a></p>
</body>
</html>
