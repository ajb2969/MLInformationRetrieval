<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="972">Schrödinger method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Schrödinger method</h1>
<hr/>

<p>In <a href="combinatorics" title="wikilink">combinatorial</a> <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a href="probability_theory" title="wikilink">probability theory</a>, the <strong>Schrödinger method</strong>, named after the Austrian physicist <a href="Erwin_Schrödinger" title="wikilink">Erwin Schrödinger</a>, is used to solve some problems of <a href="distribution_and_occupancy" title="wikilink">distribution and occupancy</a>.</p>

<p>Suppose</p>

<p>

<math display="block" id="Schrödinger_method:0">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},\dots,X_{n}\,
  </annotation>
 </semantics>
</math>

</p>

<p>are <a href="statistical_independence" title="wikilink">independent</a> <a href="random_variable" title="wikilink">random variables</a> that are <a href="uniform_distribution_(continuous)" title="wikilink">uniformly distributed</a> on the interval [0, 1]. Let</p>

<p>

<math display="block" id="Schrödinger_method:1">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{(1)},\dots,X_{(n)}\,
  </annotation>
 </semantics>
</math>

</p>

<p>be the corresponding <a href="order_statistic" title="wikilink">order statistics</a>, i.e., the result of sorting these <em>n</em> random variables into increasing order. We seek the probability of some event <em>A</em> defined in terms of these order statistics. For example, we might seek the probability that in a certain seven-day period there were at most two days in on which only one phone call was received, given that the number of phone calls during that time was 20. This assumes uniform distribution of arrival times.</p>

<p>The Schrödinger method begins by assigning a <a href="Poisson_distribution" title="wikilink">Poisson distribution</a> with <a href="expected_value" title="wikilink">expected value</a> <em>λt</em> to the number of observations in the interval [0, <em>t</em>], the number of observations in non-overlapping subintervals being independent (see <a href="Poisson_process" title="wikilink">Poisson process</a>). The number <em>N</em> of observations is Poisson-distributed with expected value <em>λ</em>. Then we rely on the fact that the <a href="conditional_probability" title="wikilink">conditional probability</a></p>

<p>

<math display="block" id="Schrödinger_method:2">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>∣</mo>
    <mi>N</mi>
    <mo>=</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">N</csymbol>
     <eq></eq>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\mid N=n)\,
  </annotation>
 </semantics>
</math>

</p>

<p>does not depend on <em>λ</em> (in the language of <a href="statistics" title="wikilink">statisticians</a>, <em>N</em> is a <a href="sufficiency_(statistics)" title="wikilink">sufficient statistic</a> for this <a href="parametrized_family" title="wikilink">parametrized family</a> of probability distributions for the order statistics). We proceed as follows:</p>

<p>

<math display="block" id="Schrödinger_method:3">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>λ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </munderover>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>∣</mo>
    <mi>N</mi>
    <mo>=</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo>=</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </munderover>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>∣</mo>
    <mi>N</mi>
    <mo>=</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <msup>
      <mi>λ</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mi>λ</mi>
      </mrow>
     </msup>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mfrac>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>λ</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">N</csymbol>
     <eq></eq>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <eq></eq>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">N</csymbol>
     <eq></eq>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\lambda}(A)=\sum_{n=0}^{\infty}P(A\mid N=n)P(N=n)=\sum_{n=0}^{\infty}P(A%
\mid N=n){\lambda^{n}e^{-\lambda}\over n!},
  </annotation>
 </semantics>
</math>

</p>

<p>so that</p>

<p>

<math display="block" id="Schrödinger_method:4">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msup>
     <mi>e</mi>
     <mi>λ</mi>
    </msup>
   </mpadded>
   <msub>
    <mi>P</mi>
    <mi>λ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </munderover>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>∣</mo>
    <mi>N</mi>
    <mo>=</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <msup>
     <mi>λ</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>λ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>λ</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">N</csymbol>
     <eq></eq>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\lambda}\,P_{\lambda}(A)=\sum_{n=0}^{\infty}P(A\mid N=n){\lambda^{n}\over n%
!}.
  </annotation>
 </semantics>
</math>

</p>

<p>Now the lack of dependence of <em>P</em>(<em>A</em> | <em>N</em> = <em>n</em>) upon <em>λ</em> entails that the last sum displayed above is a <a href="power_series" title="wikilink">power series</a> in <em>λ</em> and <em>P</em>(<em>A</em> | <em>N</em> = <em>n</em>) is the value of its <em>n</em>th derivative at <em>λ</em> = 0, i.e.,</p>

<p>

<math display="block" id="Schrödinger_method:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>∣</mo>
    <mi>N</mi>
    <mo>=</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo>[</mo>
     <mfrac>
      <msup>
       <mi>d</mi>
       <mi>n</mi>
      </msup>
      <mrow>
       <mi>d</mi>
       <msup>
        <mi>λ</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mpadded width="+1.7pt">
       <msup>
        <mi>e</mi>
        <mi>λ</mi>
       </msup>
      </mpadded>
      <msub>
       <mi>P</mi>
       <mi>λ</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mi>λ</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">N</csymbol>
     <eq></eq>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>d</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>λ</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <ci>λ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>λ</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">A</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <apply>
      <eq></eq>
      <ci>λ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\mid N=n)=\left[{d^{n}\over d\lambda^{n}}\left(e^{\lambda}\,P_{\lambda}(A)%
\right)\right]_{\lambda=0}.
  </annotation>
 </semantics>
</math>

</p>

<p>For this method to be of any use in finding <em>P</em>(<em>A</em> | <em>N</em> =<em>n</em>), must be possible to find <em>P</em><sub><em>λ</em></sub>(<em>A</em>) more directly than <em>P</em>(<em>A</em> | <em>N</em> = <em>n</em>). What makes that possible is the independence of the numbers of arrivals in non-overlapping subintervals.</p>

<p>"</p>

<p><a href="Category:Probability_theory" title="wikilink">Category:Probability theory</a> <a href="Category:Erwin_Schrödinger" title="wikilink">Method</a></p>
</body>
</html>
