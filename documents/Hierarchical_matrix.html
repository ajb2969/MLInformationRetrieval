<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1469">Hierarchical matrix</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hierarchical matrix</h1>
<hr/>

<p>In <a href="numerical_mathematics" title="wikilink">numerical mathematics</a>, <strong>hierarchical matrices (H-matrices)</strong> <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> are used as data-sparse approximations of non-sparse matrices. While a <a href="sparse_matrix" title="wikilink">sparse matrix</a> of dimension 

<math display="inline" id="Hierarchical_matrix:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 can be represented efficiently in 

<math display="inline" id="Hierarchical_matrix:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 units of storage by storing only its non-zero entries, a non-sparse matrix would require 

<math display="inline" id="Hierarchical_matrix:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 units of storage, and using this type of matrices for large problems would therefore be prohibitively expensive in terms of storage and computing time. Hierarchical matrices provide an approximation requiring only 

<math display="inline" id="Hierarchical_matrix:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mpadded width="+1.7pt">
      <mi>k</mi>
     </mpadded>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>k</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nk\,\log(n))
  </annotation>
 </semantics>
</math>

 units of storage, where 

<math display="inline" id="Hierarchical_matrix:4">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is a parameter controlling the accuracy of the approximation. In typical applications, e.g., when discretizing integral equations <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> or solving elliptic partial differential equations <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> a rank proportional to 

<math display="inline" id="Hierarchical_matrix:5">
 <semantics>
  <mrow>
   <mi>log</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>/</mo>
     <mi>ϵ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>γ</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <log></log>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">1</cn>
      <divide></divide>
      <csymbol cd="unknown">ϵ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>γ</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(1/\epsilon)^{\gamma}
  </annotation>
 </semantics>
</math>

 with a small constant 

<math display="inline" id="Hierarchical_matrix:6">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 is sufficient to ensure an accuracy of 

<math display="inline" id="Hierarchical_matrix:7">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

. Compared to many other data-sparse representations of non-sparse matrices, hierarchical matrices offer a major advantage: the results of matrix arithmetic operations like matrix multiplication, factorization or inversion can be approximated in 

<math display="inline" id="Hierarchical_matrix:8">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>k</mi>
      <mi>α</mi>
     </msup>
    </mpadded>
    <mi>log</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>β</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">O</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <ci>α</ci>
     </apply>
     <log></log>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>β</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nk^{\alpha}\,\log(n)^{\beta})
  </annotation>
 </semantics>
</math>

 operations, where 

<math display="inline" id="Hierarchical_matrix:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>,</mo>
     <mi>β</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>3</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>α</ci>
     <ci>β</ci>
    </list>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha,\beta\in\{1,2,3\}.
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="basic-idea">Basic idea</h2>

<p>Hierarchical matrices rely on local low-rank approximations: let 

<math display="inline" id="Hierarchical_matrix:10">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>,</mo>
   <mi>J</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>I</ci>
    <ci>J</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I,J
  </annotation>
 </semantics>
</math>

 be index sets, and let 

<math display="inline" id="Hierarchical_matrix:11">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mi>I</mi>
     <mo>×</mo>
     <mi>J</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>J</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\in{\mathbb{R}}^{I\times J}
  </annotation>
 </semantics>
</math>

 denote the matrix we have to approximate. In many applications (see above), we can find subsets 

<math display="inline" id="Hierarchical_matrix:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>⊆</mo>
    <mi>I</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mo>⊆</mo>
    <mi>J</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <subset></subset>
     <ci>t</ci>
     <ci>I</ci>
    </apply>
    <apply>
     <subset></subset>
     <ci>s</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\subseteq I,s\subseteq J
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Hierarchical_matrix:13">
 <semantics>
  <msub>
   <mrow>
    <mi>G</mi>
    <mo fence="true">|</mo>
   </mrow>
   <mrow>
    <mi>t</mi>
    <mo>×</mo>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">evaluated-at</csymbol>
    <ci>G</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G|_{t\times s}
  </annotation>
 </semantics>
</math>

 can be approximated by a rank-

<math display="inline" id="Hierarchical_matrix:14">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 matrix. This approximation can be represented in factorized form 

<math display="inline" id="Hierarchical_matrix:15">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mi>G</mi>
     <mo fence="true">|</mo>
    </mrow>
    <mrow>
     <mi>t</mi>
     <mo>×</mo>
     <mi>s</mi>
    </mrow>
   </msub>
   <mo>≈</mo>
   <mrow>
    <mi>A</mi>
    <msup>
     <mi>B</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <ci>G</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G|_{t\times s}\approx AB^{*}
  </annotation>
 </semantics>
</math>

 with factors 

<math display="inline" id="Hierarchical_matrix:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mi>t</mi>
      <mo>×</mo>
      <mi>k</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>B</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mi>s</mi>
      <mo>×</mo>
      <mi>k</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in{\mathbb{R}}^{t\times k},B\in{\mathbb{R}}^{s\times k}
  </annotation>
 </semantics>
</math>

. While the standard representation of the matrix 

<math display="inline" id="Hierarchical_matrix:17">
 <semantics>
  <msub>
   <mrow>
    <mi>G</mi>
    <mo fence="true">|</mo>
   </mrow>
   <mrow>
    <mi>t</mi>
    <mo>×</mo>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">evaluated-at</csymbol>
    <ci>G</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G|_{t\times s}
  </annotation>
 </semantics>
</math>

 requires 

<math display="inline" id="Hierarchical_matrix:18">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">#</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">#</mi>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>normal-#</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-#</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O((\#t)(\#s))
  </annotation>
 </semantics>
</math>

 units of storage, the factorized representation requires only 

<math display="inline" id="Hierarchical_matrix:19">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi mathvariant="normal">#</mi>
        <mi>t</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi mathvariant="normal">#</mi>
        <mi>s</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>normal-#</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-#</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k(\#t+\#s))
  </annotation>
 </semantics>
</math>

 units. If 

<math display="inline" id="Hierarchical_matrix:20">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is not too large, the storage requirements are reduced significantly.</p>

<p>In order to approximate the entire matrix 

<math display="inline" id="Hierarchical_matrix:21">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, it is split into a family of submatrices. Large submatrices are stored in factorized representation, while small submatrices are stored in standard representation in order to improve the efficiency.</p>

<p>Low-rank matrices are closely related to degenerate expansions used in <a href="panel_clustering" title="wikilink">panel clustering</a> and the <a href="fast_multipole_method" title="wikilink">fast multipole method</a> to approximate integral operators. In this sense, hierarchical matrices can be considered the algebraic counterparts of these techniques.</p>
<h2 id="application-to-integral-operators">Application to integral operators</h2>

<p>Hierarchical matrices are successfully used to treat integral equations, e.g., the single and double layer potential operators appearing in the <a href="boundary_element_method" title="wikilink">boundary element method</a>. A typical operator has the form</p>

<p>

<math display="block" id="Hierarchical_matrix:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒢</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>u</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mi>κ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>u</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝒢</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>u</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <ci>κ</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <ci>u</ci>
      <ci>y</ci>
      <ci>d</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathcal{G}}[u](x)=\int_{\Omega}\kappa(x,y)u(y)\,dy.
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="Galerkin_method" title="wikilink">Galerkin method</a> leads to matrix entries of the form</p>

<p>

<math display="block" id="Hierarchical_matrix:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi mathvariant="normal">Ω</mi>
      </msub>
      <mrow>
       <mi>κ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>φ</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>ψ</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mpadded width="+1.7pt">
        <mi>y</mi>
       </mpadded>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <times></times>
       <ci>κ</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ψ</ci>
        <ci>j</ci>
       </apply>
       <ci>y</ci>
       <ci>d</ci>
       <ci>y</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{ij}=\int_{\Omega}\int_{\Omega}\kappa(x,y)\varphi_{i}(x)\psi_{j}(y)\,dy\,dx,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Hierarchical_matrix:24">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>φ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mi>I</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <in></in>
     <ci>i</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\varphi_{i})_{i\in I}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hierarchical_matrix:25">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ψ</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>j</mi>
    <mo>∈</mo>
    <mi>J</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <in></in>
     <ci>j</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\psi_{j})_{j\in J}
  </annotation>
 </semantics>
</math>

 are families of finite element basis functions. If the kernel function 

<math display="inline" id="Hierarchical_matrix:26">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 is sufficiently smooth, we can approximate it by <a href="polynomial_interpolation" title="wikilink">polynomial interpolation</a> to obtain</p>

<p>

<math display="block" id="Hierarchical_matrix:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>κ</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>ν</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </munderover>
     <mrow>
      <mi>κ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msub>
        <mi>ξ</mi>
        <mi>ν</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi mathvariant="normal">ℓ</mi>
       <mi>ν</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>κ</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>ν</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>κ</ci>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <ci>ν</ci>
       </apply>
      </interval>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-ℓ</ci>
       <ci>ν</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\kappa}(x,y)=\sum_{\nu=1}^{k}\kappa(x,\xi_{\nu})\ell_{\nu}(y),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Hierarchical_matrix:28">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ξ</mi>
     <mi>ν</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>ν</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>k</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <ci>ν</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>ν</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\xi_{\nu})_{\nu=1}^{k}
  </annotation>
 </semantics>
</math>

 is the family of interpolation points and 

<math display="inline" id="Hierarchical_matrix:29">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mi>ν</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>ν</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>k</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <ci>ν</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>ν</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\ell_{\nu})_{\nu=1}^{k}
  </annotation>
 </semantics>
</math>

 is the corresponding family of <a href="Lagrange_polynomial" title="wikilink">Lagrange polynomials</a>. Replacing 

<math display="inline" id="Hierarchical_matrix:30">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Hierarchical_matrix:31">
 <semantics>
  <mover accent="true">
   <mi>κ</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>κ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\kappa}
  </annotation>
 </semantics>
</math>

 yields an approximation</p>

<p>

<math display="block" id="Hierarchical_matrix:32">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi mathvariant="normal">Ω</mi>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mover accent="true">
       <mi>κ</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>φ</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>ψ</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mpadded width="+1.7pt">
       <mi>y</mi>
      </mpadded>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>ν</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mi>κ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msub>
        <mi>ξ</mi>
        <mi>ν</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>φ</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∫</mo>
        <mi mathvariant="normal">Ω</mi>
       </msub>
       <mrow>
        <msub>
         <mi mathvariant="normal">ℓ</mi>
         <mi>ν</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>ψ</mi>
         <mi>j</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <mi>y</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>ν</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mi>ν</mi>
      </mrow>
     </msub>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>j</mi>
       <mi>ν</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>g</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Ω</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-~</ci>
         <ci>κ</ci>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>φ</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ψ</ci>
         <ci>j</ci>
        </apply>
        <ci>y</ci>
        <ci>d</ci>
        <ci>y</ci>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>ν</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Ω</ci>
       </apply>
       <apply>
        <times></times>
        <ci>κ</ci>
        <interval closure="open">
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ξ</ci>
          <ci>ν</ci>
         </apply>
        </interval>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>φ</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
        <ci>d</ci>
        <ci>x</ci>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <int></int>
          <ci>normal-Ω</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>normal-ℓ</ci>
           <ci>ν</ci>
          </apply>
          <ci>y</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ψ</ci>
           <ci>j</ci>
          </apply>
          <ci>y</ci>
          <ci>d</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>ν</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>ν</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>ν</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{g}_{ij}=\int_{\Omega}\int_{\Omega}\tilde{\kappa}(x,y)\varphi_{i}(x)\psi%
_{j}(y)\,dy\,dx=\sum_{\nu=1}^{k}\int_{\Omega}\kappa(x,\xi_{\nu})\varphi_{i}(x)%
\,dx\int_{\Omega}\ell_{\nu}(y)\psi_{j}(y)\,dy=\sum_{\nu=1}^{k}a_{i\nu}b_{j\nu}
  </annotation>
 </semantics>
</math>

</p>

<p>with the coefficients</p>

<p>

<math display="block" id="Hierarchical_matrix:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mi>ν</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mi>κ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msub>
        <mi>ξ</mi>
        <mi>ν</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>φ</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>ν</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <ci>κ</ci>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ξ</ci>
        <ci>ν</ci>
       </apply>
      </interval>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i\nu}=\int_{\Omega}\kappa(x,\xi_{\nu})\varphi_{i}(x)\,dx,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Hierarchical_matrix:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>b</mi>
     <mrow>
      <mi>j</mi>
      <mi>ν</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <msub>
       <mi mathvariant="normal">ℓ</mi>
       <mi>ν</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>ψ</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ν</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-ℓ</ci>
       <ci>ν</ci>
      </apply>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ψ</ci>
       <ci>j</ci>
      </apply>
      <ci>y</ci>
      <ci>d</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{j\nu}=\int_{\Omega}\ell_{\nu}(y)\psi_{j}(y)\,dy.
  </annotation>
 </semantics>
</math>

</p>

<p>If we choose 

<math display="inline" id="Hierarchical_matrix:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>⊆</mo>
    <mi>I</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mo>⊆</mo>
    <mi>J</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <subset></subset>
     <ci>t</ci>
     <ci>I</ci>
    </apply>
    <apply>
     <subset></subset>
     <ci>s</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\subseteq I,s\subseteq J
  </annotation>
 </semantics>
</math>

 and use the same interpolation points for all 

<math display="inline" id="Hierarchical_matrix:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mi>t</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>j</mi>
    <mo>∈</mo>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>i</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <in></in>
     <ci>j</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in t,j\in s
  </annotation>
 </semantics>
</math>

, we obtain 

<math display="inline" id="Hierarchical_matrix:37">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mi>G</mi>
     <mo fence="true">|</mo>
    </mrow>
    <mrow>
     <mi>t</mi>
     <mo>×</mo>
     <mi>s</mi>
    </mrow>
   </msub>
   <mo>≈</mo>
   <mrow>
    <mi>A</mi>
    <msup>
     <mi>B</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <ci>G</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G|_{t\times s}\approx AB^{*}
  </annotation>
 </semantics>
</math>

.</p>

<p>Obviously, any other approximation separating the variables 

<math display="inline" id="Hierarchical_matrix:38">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hierarchical_matrix:39">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, e.g., the multipole expansion, would also allow us to split the double integral into two single integrals and thus arrive at a similar factorized low-rank matrix.</p>

<p>Of particular interest are cross approximation techniques <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> that use only the entries of the original matrix 

<math display="inline" id="Hierarchical_matrix:40">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 to construct a <a href="low_rank_approximation" title="wikilink">low-rank approximation</a>.</p>
<h2 id="application-to-elliptic-partial-differential-equations">Application to elliptic partial differential equations</h2>

<p>Since the solution operator of an elliptic partial differential equation can be expressed as an integral operator involving <a href="Green's_function" title="wikilink">Green's function</a>, it is not surprising that the inverse of the stiffness matrix arising from the <a href="finite_element_method" title="wikilink">finite element method</a> can be approximated by a hierarchical matrix.</p>

<p>Green's function depends on the shape of the computational domain, therefore it is usually not known. Nevertheless, approximate arithmetic operations can be employed to compute an approximate inverse without knowing the function explicitly.</p>

<p>Surprisingly, it is possible to prove<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> that the inverse can be approximated even if the differential operator involves non-smooth coefficients and Green's function is therefore not smooth.</p>
<h2 id="arithmetic-operations">Arithmetic operations</h2>

<p>The most important innovation of the hierarchical matrix method is the development of efficient algorithms for performing (approximate) matrix arithmetic operations on non-sparse matrices, e.g., to compute approximate inverses, <a href="LU_decomposition" title="wikilink">LU decompositions</a> and solutions to matrix equations.</p>

<p>The central algorithm is the efficient matrix-matrix multiplication, i.e., the computation of 

<math display="inline" id="Hierarchical_matrix:41">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <mi>Z</mi>
    <mo>+</mo>
    <mrow>
     <mi>α</mi>
     <mi>X</mi>
     <mi>Y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <plus></plus>
     <ci>Z</ci>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=Z+\alpha XY
  </annotation>
 </semantics>
</math>

 for hierarchical matrices 

<math display="inline" id="Hierarchical_matrix:42">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>,</mo>
   <mi>Y</mi>
   <mo>,</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>X</ci>
    <ci>Y</ci>
    <ci>Z</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y,Z
  </annotation>
 </semantics>
</math>

 and a scalar factor 

<math display="inline" id="Hierarchical_matrix:43">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

. The algorithm requires the submatrices of the hierarchical matrices to be organized in a block tree structure and takes advantage of the properties of factorized low-rank matrices to compute the updated 

<math display="inline" id="Hierarchical_matrix:44">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Hierarchical_matrix:45">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>k</mi>
      <mn>2</mn>
     </msup>
    </mpadded>
    <mi>log</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">O</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
     <log></log>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nk^{2}\,\log(n)^{2})
  </annotation>
 </semantics>
</math>

 operations.</p>

<p>Taking advantage of the block structure, the inverse can be computed by using recursion to compute inverses and <a href="Schur_complement" title="wikilink">Schur complements</a> of diagonal blocks and combining both using the matrix-matrix multiplication. In a similar way, the <a href="LU_decomposition" title="wikilink">LU decomposition</a> <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> can be constructed using only recursion and multiplication. Both operations also require 

<math display="inline" id="Hierarchical_matrix:46">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>k</mi>
      <mn>2</mn>
     </msup>
    </mpadded>
    <mi>log</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">O</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
     <log></log>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nk^{2}\,\log(n)^{2})
  </annotation>
 </semantics>
</math>

 operations.</p>
<h2 id="h2-matrices">H<sup>2</sup>-matrices</h2>

<p>In order to treat very large problems, the structure of hierarchical matrices can be improved: H<sup>2</sup>-matrices <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> replace the general low-rank structure of the blocks by a hierarchical representation closely related to the <a href="fast_multipole_method" title="wikilink">fast multipole method</a> in order to reduce the storage complexity to 

<math display="inline" id="Hierarchical_matrix:47">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>k</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nk)
  </annotation>
 </semantics>
</math>

.</p>

<p>In the context of boundary integral operators, replacing the fixed rank 

<math display="inline" id="Hierarchical_matrix:48">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 by block-dependent ranks leads to approximations that preserve the rate of convergence of the underlying boundary element method at a complexity of 

<math display="inline" id="Hierarchical_matrix:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n).
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h2 id="literature">Literature</h2>
<references>
</references>
<h2 id="software">Software</h2>

<p><a href="http://www.hlib.org">HLib</a> is a C software library implementing the most important algorithms for hierarchical and 

<math display="inline" id="Hierarchical_matrix:50">
 <semantics>
  <msup>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℋ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathcal{H}}^{2}
  </annotation>
 </semantics>
</math>

-matrices.</p>

<p><a href="http://bebendorf.ins.uni-bonn.de/AHMED.html">AHMED</a> is a C++ software library that can be downloaded for educational purposes.</p>

<p><a href="http://www.hlibpro.com">HLIBpro</a> is an implementation of the core hierarchical matrix algorithms for commercial applications.</p>

<p><a href="http://www.h2lib.org">H2Lib</a> is an open source implementation of hierarchical matrix algorithms intended for research and teaching.</p>

<p><a href="https://github.com/gchavez2/awesome-hierarchical-matrices">awesome-hierarchical-matrices</a> is a repository containing a list of other H-Matrices implementations.</p>

<p>"</p>

<p><a class="uri" href="Category:Matrices" title="wikilink">Category:Matrices</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">W. Hackbusch, <em>A sparse matrix arithmetic based on H-matrices. Part I: Introduction to H-matrices</em>, Computing (1999), 62:89–108<a href="#fnref1">↩</a></li>
<li id="fn2">M. Bebendorf, <em>Hierarchical matrices: A means to efficiently solve elliptic boundary value problems</em>, Springer (2008)<a href="#fnref2">↩</a></li>
<li id="fn3">W. Hackbusch, <em>Hierarchische Matrizen. Algorithmen und Analysis</em>, Springer (2009)<a href="#fnref3">↩</a></li>
<li id="fn4">W. Hackbusch and B. N. Khoromskij, <em>A sparse H-Matrix Arithmetic. Part II: Application to Multi-Dimensional Problems</em>, Computing (2000), 64:21–47<a href="#fnref4">↩</a></li>
<li id="fn5">M. Bebendorf, <em>Approximation of boundary element matrices</em>, Num. Math. (2000), 86:565--589<a href="#fnref5">↩</a></li>
<li id="fn6">M. Bebendorf and S. Rjasanow, <em>Adaptive low-rank approximation of collocation matrices</em>, Computing (2003), 70:1–24<a href="#fnref6">↩</a></li>
<li id="fn7">S. Börm and L. Grasedyck, <em>Hybrid cross approximation of integral operators</em>, Num. Math. (2005), 101:221–249<a href="#fnref7">↩</a></li>
<li id="fn8">M. Bebendorf and W. Hackbusch, <em>Existence of H-matrix approximants to the inverse FE-matrix of elliptic operators with 

<math display="inline" id="Hierarchical_matrix:51">
 <semantics>
  <msup>
   <mi>L</mi>
   <mi mathvariant="normal">∞</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{\infty}
  </annotation>
 </semantics>
</math>

-coefficients</em>, Num. Math. (2003), 95:1–28<a href="#fnref8">↩</a></li>
<li id="fn9">S. Börm, <em>Approximation of solution operators of elliptic partial differential equations by H- and H<sup>2</sup>-matrices</em>, Num. Math. (2010), 115:165–193<a href="#fnref9">↩</a></li>
<li id="fn10">M. Faustmann, J. M. Melenk and D. Praetorius, <em>H-matrix approximability of the inverses of FEM matrices</em>, to appear in Num. Math., preprint available at <a href="http://arxiv.org/abs/1308.0499">arXiv.org</a><a href="#fnref10">↩</a></li>
<li id="fn11">L. Grasedyck and W. Hackbusch, <em>Construction and Arithmetics of H-Matrices</em>, Computing (2003), 70:295–334<a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14">E. Tyrtyshnikov, <em>Incomplete cross approximation in the mosaic-skeleton method</em>, Computing (2000), 64:367–380<a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17">M. Bebendorf, <em>Why finite element discretizations can be factored by triangular hierarchical matrices</em>, SIAM J. Num. Anal. (2007), 45:1472–1494<a href="#fnref17">↩</a></li>
<li id="fn18">L. Grasedyck, R. Kriemann and S. Le Borne, <em>Domain decomposition based H-LU preconditioning</em>, Num. Math. (2009), 112:565–600<a href="#fnref18">↩</a></li>
<li id="fn19">W. Hackbusch, B. N. Khoromskij and S. A. Sauter, <em>On H<sup>2</sup>-matrices</em>, Lectures on Applied Mathematics (2002), 9–29<a href="#fnref19">↩</a></li>
<li id="fn20">S. Börm, <em>Efficient Numerical Methods for Non-local Operators: H<sup>2</sup>-Matrix Compression, Algorithms and Analysis</em>, EMS Tracts in Mathematics 14 (2010)<a href="#fnref20">↩</a></li>
<li id="fn21">S. A. Sauter, <em>Variable order panel clustering</em>, Computing (2000), 64:223–261<a href="#fnref21">↩</a></li>
<li id="fn22">S. Börm and S. A. Sauter, <em>BEM with linear complexity for the classical boundary integral operators</em>, Math. Comp. (2005), 74:1139–1177<a href="#fnref22">↩</a></li>
</ol>
</section>
</body>
</html>
