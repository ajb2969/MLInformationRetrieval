<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="587">Dynamization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dynamization</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>dynamization</strong> is the process of transforming a <a href="static_data_structure" title="wikilink">static data structure</a> into a <a href="dynamic_data_structure" title="wikilink">dynamic</a> one. Although static data structures may provide very good functionality and fast queries, their utility is limited because of their inability to grow/shrink fast, thus making them inapplicable for the solution of <a href="dynamic_problem_(algorithms)" title="wikilink">dynamic problems</a>, where the amount of the input data changes. Dynamization techniques provide uniform ways of creating dynamic data structures.</p>
<h2 id="decomposable-search-problems">Decomposable search problems</h2>

<p>We define problem 

<math display="inline" id="Dynamization:0">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 of searching for the predicate 

<math display="inline" id="Dynamization:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 match in the set 

<math display="inline" id="Dynamization:2">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Dynamization:3">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <interval closure="open">
     <ci>M</ci>
     <ci>S</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(M,S)
  </annotation>
 </semantics>
</math>

. Problem 

<math display="inline" id="Dynamization:4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is <em>decomposable</em> if the set 

<math display="inline" id="Dynamization:5">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 can be decomposed into subsets 

<math display="inline" id="Dynamization:6">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

 and there exists an operation 

<math display="inline" id="Dynamization:7">
 <semantics>
  <mo>+</mo>
  <annotation-xml encoding="MathML-Content">
   <plus></plus>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +
  </annotation>
 </semantics>
</math>

 of result unification such that 

<math display="inline" id="Dynamization:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <msub>
       <mi>S</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
    <mo>+</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <msub>
       <mi>S</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <ci>M</ci>
      <ci>S</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>P</ci>
      <interval closure="open">
       <ci>M</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <interval closure="open">
       <ci>M</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <interval closure="open">
       <ci>M</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(M,S)=P(M,S_{0})+P(M,S_{1})+\dots+P(M,S_{n})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="decomposition">Decomposition</h2>

<p>Decomposition is a term used in computer science to break static data structures into smaller units of unequal size. The basic principle is the idea that any decimal number can be translated into a representation in any other base. For more details about the topic see <a href="Decomposition_(computer_science)" title="wikilink">Decomposition (computer science)</a>. For simplicity, binary system will be used in this article but any other base (as well as other possibilities such as <a href="Fibonacci_number" title="wikilink">Fibonacci numbers</a>) can also be utilized.</p>

<p>If using the binary system, a set of 

<math display="inline" id="Dynamization:9">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements is broken down into subsets of sizes with</p>

<p>

<math display="block" id="Dynamization:10">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>i</mi>
   </msup>
   <mo>*</mo>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{i}*n_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>elements where 

<math display="inline" id="Dynamization:11">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Dynamization:12">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th bit of 

<math display="inline" id="Dynamization:13">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in binary. This means that if 

<math display="inline" id="Dynamization:14">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 has 

<math display="inline" id="Dynamization:15">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th bit equal to 0, the corresponding set does not contain any elements. Each of the subset has the same property as the original static data structure. Operations performed on the new dynamic data structure may involve traversing 

<math display="inline" id="Dynamization:16">
 <semantics>
  <mrow>
   <msub>
    <mi>log</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}\left(n\right)
  </annotation>
 </semantics>
</math>

 sets formed by decomposition. As a result, this will add 

<math display="inline" id="Dynamization:17">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo>(</mo>
      <mi>n</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log\left(n\right))
  </annotation>
 </semantics>
</math>

 factor as opposed to the static data structure operations but will allow insert/delete operation to be added.</p>

<p><a href="Kurt_Mehlhorn" title="wikilink">Kurt Mehlhorn</a> proved several equations for time complexity of operations on the data structures dynamized according to this idea. Some of these equalities are listed.</p>

<p>If</p>

<p>

<math display="inline" id="Dynamization:18">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>S</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{S}\left(n\right)\,\!
  </annotation>
 </semantics>
</math>

<code> = time to build the static data structure</code><br/>


<math display="inline" id="Dynamization:19">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>S</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{S}\left(n\right)\,\!
  </annotation>
 </semantics>
</math>

<code> = time to query the static data structure</code><br/>


<math display="inline" id="Dynamization:20">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>D</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>D</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{D}\left(n\right)\,\!
  </annotation>
 </semantics>
</math>

<code> = time to query the dynamic data structure formed by decomposition</code><br/>


<math display="inline" id="Dynamization:21">
 <semantics>
  <mover accent="true">
   <mi>I</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{I}
  </annotation>
 </semantics>
</math>

<code> = amortized insertion time</code></p>

<p>then</p>

<p><code> </code>

<math display="inline" id="Dynamization:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>D</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <mi>n</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo>(</mo>
       <mi>n</mi>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo>(</mo>
        <mi>n</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>D</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>S</ci>
      </apply>
      <ci>n</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{D}\left(n\right)=O(Q_{S}\left(n\right)\log\left(n\right))\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Dynamization:23">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>I</mi>
    <mo>¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>P</mi>
          <mi>S</mi>
         </msub>
         <mrow>
          <mo>(</mo>
          <mi>n</mi>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>/</mo>
        <mi>n</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo>(</mo>
        <mi>n</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>I</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>S</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{I}=O(\left(P_{S}\left(n\right)/n\right)\log\left(n\right))
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Dynamization:24">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>S</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{S}\left(n\right)
  </annotation>
 </semantics>
</math>

 is at least <a class="uri" href="polynomial" title="wikilink">polynomial</a>, then 

<math display="inline" id="Dynamization:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>D</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <mi>n</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo>(</mo>
       <mi>n</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>D</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>S</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{D}\left(n\right)=O\left(Q_{S}\left(n\right)\right)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Kurt Mehlhorn, <a href="http://www.mpi-sb.mpg.de/~mehlhorn/DatAlgbooks.html">Data structures and algorithms</a> 3, . An EATCS Series, vol. 3, Springer, 1984.</li>
</ul>

<p>"</p>

<p><a href="Category:Data_structures" title="wikilink">Category:Data structures</a></p>
</body>
</html>
