<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="85">Variable neighborhood search</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Variable neighborhood search</h1>
<hr/>

<p><strong>Variable neighborhood search</strong> (VNS),<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> proposed by <a href="Mladenović,_Hansen" title="wikilink">Mladenović, Hansen</a>, 1997,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is a <a class="uri" href="metaheuristic" title="wikilink">metaheuristic</a> method for solving a set of <a href="combinatorial_optimization_(mathematics)" title="wikilink">combinatorial optimization</a> and global optimization problems. It explores distant neighborhoods of the current incumbent solution, and moves from there to a new one if and only if an improvement was made. The local search method is applied repeatedly to get from solutions in the neighborhood to local optima. VNS was designed for approximating solutions of discrete and continuous optimization problems and according to these, it is aimed for solving <a href="linear_programming" title="wikilink">linear program</a> problems, <a href="linear_programming" title="wikilink">integer program</a> problems, mixed integer program problems, <a href="nonlinear_programming" title="wikilink">nonlinear program</a> problems, etc.</p>
<h2 id="introduction">Introduction</h2>

<p>VNS systematically changes the neighborhood in two phases: firstly, descent to find a <a href="local_optimum" title="wikilink">local optimum</a> and finally, a perturbation phase to get out of the corresponding valley.</p>

<p>Applications are rapidly increasing in number and pertain to many fields: <a href="location_theory" title="wikilink">location theory</a>, <a href="cluster_analysis" title="wikilink">cluster analysis</a>, <a class="uri" href="scheduling" title="wikilink">scheduling</a>, <a href="Vehicle_routing_problem" title="wikilink">vehicle routing</a>, <a href="Network_planning_and_design" title="wikilink">network design</a>, lot-sizing, <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>, engineering, pooling problems, biology, <a href="Phylogenetics" title="wikilink">phylogeny</a>, <a href="wikt:reliability" title="wikilink">reliability</a>, geometry, telecommunication design, etc.</p>

<p>There are several books important for understanding VNS, such as: <em>Handbook of Metaheuristics</em>, 2010,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Handbook of Metaheuristics, 2003<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and Search methodologies, 2005.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Earlier work that motivated this approach can be found in</p>
<ol>
<li>Davidson, W.C.,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>Fletcher, R., Powell, M.J.D.,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li>Mladenovi´c, N.<ref></ref></li>
</ol>

<p> and 4. Brimberg, J., Mladenovi´c, N.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Recent surveys on VNS methodology as well as numerous applications can be found in 4OR, 2008.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and Annals of OR, 2010.</p>
<h2 id="definition-of-the-problem">Definition of the problem</h2>

<p>Define one deterministic <a href="optimization_problem" title="wikilink">optimization problem</a> with</p>

<p>

<math display="inline" id="Variable_neighborhood_search:0">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>X</mi>
     <mo>⊆</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <subset></subset>
     <ci>X</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min{\{f(x)|x\in X,X\subseteq S\}}
  </annotation>
 </semantics>
</math>

, (1)</p>

<p>where <em>S</em>, <em>X</em>, <em>x</em>, and <em>f</em> are the solution space, the feasible set, a feasible solution, and a real-valued <a href="mathematical_optimization" title="wikilink">objective function</a>, respectively. If <em>S</em> is a finite but large set, a combinatorial optimization problem is defined. If 

<math display="inline" id="Variable_neighborhood_search:1">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <msup>
    <mi>R</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {S=R^{n}}
  </annotation>
 </semantics>
</math>

, there is continuous optimization model.</p>

<p>A solution 

<math display="inline" id="Variable_neighborhood_search:2">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>*</mo>
   </msup>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x^{*}\in X}
  </annotation>
 </semantics>
</math>

 is optimal if</p>

<p>

<math display="inline" id="Variable_neighborhood_search:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {f(x^{*})\leq f(x),\qquad\forall{x}\,\in X}
  </annotation>
 </semantics>
</math>


.</p>

<p>Exact algorithm for problem (1) is to be found an optimal solution <em>x*</em>, with the validation of its optimal structure, or if it is unrealizable, in procedure have to be shown that there is no achievable solution, i.e., 

<math display="inline" id="Variable_neighborhood_search:4">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\varnothing
  </annotation>
 </semantics>
</math>

, or the solution is unbounded. CPU time has to be finite and short. For continuous optimization, it is reasonable to allow for some degree of tolerance, i.e., to stop when a feasible solution 

<math display="inline" id="Variable_neighborhood_search:5">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 has been found such that</p>

<p>

<math display="inline" id="Variable_neighborhood_search:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>ϵ</mi>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <ci>ϵ</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {f(x^{*})\leq f(x)+\epsilon,\qquad\forall{x}\,\in X}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Variable_neighborhood_search:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>x</mi>
           <mo>*</mo>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <times></times>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {(f(x^{*})-f(x))/f(x^{*})<\epsilon,\qquad\forall{x}\,\in X}
  </annotation>
 </semantics>
</math>

</p>

<p>Some heuristics speedily accept an approximate solution, or optimal solution but one with no validation of its optimality. Some of them have an incorrect certificate, i.e., the solution 

<math display="inline" id="Variable_neighborhood_search:8">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{h}
  </annotation>
 </semantics>
</math>


 obtained satisfies</p>

<p>

<math display="inline" id="Variable_neighborhood_search:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>h</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>h</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>h</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>h</ci>
      </apply>
     </apply>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {(f(x_{h})-f(x))/f(x_{h})\leq\epsilon,\qquad\forall{x}\,\in X}
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Variable_neighborhood_search:10">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

, though this is rarely small.</p>

<p>Heuristics are faced with the problem of local optima as a result of avoiding boundless computing time. A local optimum 

<math display="inline" id="Variable_neighborhood_search:11">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{L}
  </annotation>
 </semantics>
</math>

 of problem is such that</p>

<p>

<math display="inline" id="Variable_neighborhood_search:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>L</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>L</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∩</mo>
     <mi>X</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>L</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <intersect></intersect>
      <apply>
       <times></times>
       <ci>N</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>L</ci>
       </apply>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {f(x_{L})\leq f(x),\qquad\forall{x}\,\in N(x_{L})\cap X}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Variable_neighborhood_search:13">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>L</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(x_{L})
  </annotation>
 </semantics>
</math>


 denotes a neighborhood of 

<math display="inline" id="Variable_neighborhood_search:14">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{L}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="description">Description</h2>

<p>According to (Mladenovic, 1995), VNS is a metaheuristic which systematically performs the procedure of neighborhood change, both in descent to local minima and in escape from the valleys which contain them.</p>

<p>VNS is built upon the following perceptions:</p>
<ol>
<li>A local minimum with respect to one neighbourhood structure is not necessarily a local minimum for another neighbourhood structure.</li>
<li>A global minimum is a local minimum with respect to all possible neighborhood structures.</li>
<li>For many problems, local minima with respect to one or several neighborhoods are relatively close to each other.</li>
</ol>

<p>Unlike many other metaheuristics, the basic schemes of VNS and its extensions are simple and require few, and sometimes no parameters. Therefore, in addition to providing very good solutions, often in simpler ways than other methods, VNS gives insight into the reasons for such a performance, which, in turn, can lead to more efficient and sophisticated implementations.</p>

<p>There are several papers where it could be studied among recently mentioned, such as (Hansen and Mladenovi´c 1999, 2001a, 2003, 2005; Moreno-Pérez et al.;<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a>)</p>
<h2 id="local-search">Local search</h2>

<p>A local search heuristic is performed through choosing an initial solution x, discovering a direction of descent from x, within a neighbourhood N(x), and proceeding to the minimum of f(x) within N(x) in the same direction. If there is no direction of descent, the heuristic stops; otherwise, it is iterated. Usually the highest direction of descent, also related to as best improvement, is used. This set of rules is summarized in Algorithm 1, where we assume that an initial solution x is given. The output consists of a local minimum, also denoted by x, and its value. Observe that a neighbourhood structure N(x) is defined for all x ∈ X. At each step, the neighbourhood N(x) of x is explored completely. As this may be timeconsuming, an alternative is to use the first descent heuristic. Vectors 

<math display="inline" id="Variable_neighborhood_search:15">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mi>i</mi>
   </msup>
   <mo>∈</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{i}\in N(x)
  </annotation>
 </semantics>
</math>

 are then enumerated systematically and a move is made as soon as a direction for the descent is found. This is summarized in Algorithm 2.</p>
<h3 id="algorithm-1-best-improvement-highest-descent-heuristic">Algorithm 1: Best improvement (highest descent) heuristic</h3>
<pre><code>Function BestImprovement(x)
  1: repeat
  2:     x' ← x
  3:     x←argmin_{f (y)}, y∈N(x)
  4: until ( f (x) ≥ f (x'))
  5: return x</code></pre>
<h3 id="algorithm-2-first-improvement-first-descent-heuristic">Algorithm 2: First improvement (first descent) heuristic</h3>
<pre><code>Function FirstImprovement(x)
  1: repeat
  2:    x' ← x; i←0
  3:    repeat
  4:       i←i+1
  5:       x←argmin{ f (x), f (x^i)}, x^i  ∈ N(x)
  6:    until ( f (x) &lt; f (x^i) or i = |N(x)|)
  7: until ( f (x) ≥ f (x'))
  8: return x</code></pre>

<p>Let one denote 

<math display="inline" id="Variable_neighborhood_search:16">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>k</mi>
     <mrow>
      <mi>m</mi>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒩</ci>
     <ci>k</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">k</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}_{k}(k=1,...,k_{max})
  </annotation>
 </semantics>
</math>

, a finite set of pre-selected neighborhood structures, and with 

<math display="inline" id="Variable_neighborhood_search:17">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒩</ci>
     <ci>k</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}_{k}(x)
  </annotation>
 </semantics>
</math>

 the set of solutions in the <em>kth</em> neighborhood of <em>x</em>.</p>

<p>One will also use the notation 

<math display="inline" id="Variable_neighborhood_search:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mmultiscripts>
       <mi class="ltx_font_mathcaligraphic">𝒩</mi>
       <none></none>
       <mo>′</mo>
       <mi>k</mi>
       <none></none>
      </mmultiscripts>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>k</mi>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msubsup>
     <mi>k</mi>
     <mrow>
      <mi>m</mi>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>′</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝒩</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>k</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <ci>k</ci>
     </list>
     <cn type="integer">1</cn>
    </apply>
    <list>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N^{\prime}}_{k}(x),k=1,...,k^{\prime}_{max}
  </annotation>
 </semantics>
</math>


 when describing local descent. Neighborhoods 

<math display="inline" id="Variable_neighborhood_search:19">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒩</ci>
     <ci>k</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}_{k}(x)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Variable_neighborhood_search:20">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <none></none>
    <mo>′</mo>
    <mi>k</mi>
    <none></none>
   </mmultiscripts>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒩</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N^{\prime}}_{k}(x)
  </annotation>
 </semantics>
</math>

 may be induced from one or more <a href="metric_(mathematics)" title="wikilink">metric</a> (or quasi-metric) functions introduced into a solution space <em>S</em>. An optimal solution 

<math display="inline" id="Variable_neighborhood_search:21">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{opt}
  </annotation>
 </semantics>
</math>

 (or <a href="maxima_and_minima" title="wikilink">global minimum</a>) is a feasible solution where a minimum of problem ( is reached. We call <em>x' ∈ X</em> a local minimum of problem with respect to 

<math display="inline" id="Variable_neighborhood_search:22">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒩</ci>
     <ci>k</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}_{k}(x)
  </annotation>
 </semantics>
</math>

, if there is no solution 

<math display="inline" id="Variable_neighborhood_search:23">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mmultiscripts>
     <mi class="ltx_font_mathcaligraphic">𝒩</mi>
     <none></none>
     <mo>′</mo>
     <mi>k</mi>
     <none></none>
    </mmultiscripts>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>x</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝒩</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathcal{N^{\prime}}_{k}(x)\subseteq X
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Variable_neighborhood_search:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)<f(x^{\prime})
  </annotation>
 </semantics>
</math>

.</p>

<p>In order to solve problem by using several neighbourhoods, facts 1–3 can be used in three different ways: (i) deterministic; (ii) <a class="uri" href="stochastic" title="wikilink">stochastic</a>; (iii) both deterministic and stochastic. We first give in Algorithm 3 the steps of the neighbourhood change function which will be used later. Function NeighbourhoodChange() compares the new value f(x') with the incumbent value f(x) obtained in the neighbourhood k (line 1). If an improvement is obtained, k is returned to its initial value and the new incumbent updated (line 2). Otherwise, the next neighbourhood is considered (line 3).</p>
<h3 id="algorithm-3-neighborhood-change">Algorithm 3: – Neighborhood change</h3>
<pre><code>Function NeighborhoodChange (x, x', k)
 1: if f (x') &lt; f(x) then
 2:    x ← x' // Make a move
 3:    k ← 1 // Initial neighborhood
 4: else
 5:    k ← k+1 // Next neighborhood</code></pre>

<p>When VNS does not render good solution, there are several steps which could be helped in process, such as comparing first and best improvement strategies in local search, reducing neighborhood, intensifying shaking, adopting VND, adopting FSS, and experimenting with parameter settings.</p>

<p>The Basic VNS (BVNS) method (Mladenovic and Hansen 1997) combines deterministic and stochastic changes of neighbourhood. Its steps are given in Algorithm 4. Often successive neighbourhoods 

<math display="inline" id="Variable_neighborhood_search:25">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒩</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}_{k}
  </annotation>
 </semantics>
</math>

 will be nested. Observe that point x' is generated at random in Step 4 in order to avoid cycling, which might occur if a deterministic rule were applied. In Step 5, the first improvement local search (Algorithm 2) is usually adopted. However, it can be replaced with best improvement (Algorithm 1).</p>
<h3 id="algorithm-4-basic-vns">Algorithm 4: Basic VNS</h3>
<pre><code>Function VNS (x, kmax, tmax );
 1: repeat
 2:    k ← 1;
 3:    repeat
 4:       x' ←Shake(x, k) /* Shaking */;
 5:       x'' ← FirstImprovement(x' ) /* Local search */;
 6:       NeighbourhoodChange(x, x', k) /* Change neighbourhood */;
 7:    until k = k_max ;
 8:    t ←CpuTime()
 9: until t &gt; t_max ;</code></pre>
<h3 id="vns-variants">VNS variants</h3>

<p>The basic VNS is a first improvement <a href="method_of_steepest_descent" title="wikilink">descent method</a> with randomization. Without much additional effort, it can be transformed into a descent-ascent method: in NeighbourhoodChange() function, replace also x by x" with some probability, even if the solution is worse than the incumbent. It can also be changed into a best improvement method: make a move to the best neighbourhood k* among all k_max of them. Another variant of the basic VNS can be to find a solution x' in the “Shaking” step as the best among b (a parameter) randomly generated solutions from the <em>k</em>th neighbourhood. There are two possible variants of this extension: (1) to perform only one local search from the best among b points; (2) to perform all b local searches and then choose the best. In paper (Fleszar and Hindi<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a>) could be found algorithm.</p>
<h2 id="extensions">Extensions</h2>
<ul>
<li>VND<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ul>
<dl>
<dd>The variable neighborhood descent (VND) method is obtained if a change of neighborhoods is performed in a deterministic way. In the descriptions :of its algorithms, we assume that an initial solution x is given. Most local search heuristics in their descent phase use very few :neighbourhoods. The final solution should be a local minimum with respect to all 

<math display="inline" id="Variable_neighborhood_search:26">
 <semantics>
  <msub>
   <mi>k</mi>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{max}
  </annotation>
 </semantics>
</math>

 neighbourhoods; hence the chances to reach :a global one are larger when using VND than with a single neighbourhood structure.
</dd>
</dl>
<ul>
<li>RVNS<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
</ul>
<dl>
<dd>The reduced VNS (RVNS) method is obtained if random points are selected from 

<math display="inline" id="Variable_neighborhood_search:27">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒩</ci>
     <ci>k</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}_{k}(x)
  </annotation>
 </semantics>
</math>

 and no descent is made. Rather, the :values of these new points are compared with that of the incumbent and an update takes place in case of improvement. It is assumed that a :stopping condition has been chosen like the maximum <a href="CPU_time" title="wikilink">CPU time</a> allowed 

<math display="inline" id="Variable_neighborhood_search:28">
 <semantics>
  <msub>
   <mi>t</mi>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{max}
  </annotation>
 </semantics>
</math>


 or the maximum number of iterations :between two improvements.
</dd>
<dd>To simplify the description of the algorithms it is used 

<math display="inline" id="Variable_neighborhood_search:29">
 <semantics>
  <msub>
   <mi>t</mi>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{max}
  </annotation>
 </semantics>
</math>

 below. Therefore, RVNS uses two parameters

<math display="block" id="Variable_neighborhood_search:30">
 <semantics>
  <msub>
   <mi>t</mi>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{max}
  </annotation>
 </semantics>
</math>

 :and 

<math display="inline" id="Variable_neighborhood_search:31">
 <semantics>
  <msub>
   <mi>k</mi>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{max}
  </annotation>
 </semantics>
</math>

. RVNS is useful in very large instances, for which local search is costly. It has been observed that the best value for :the parameter k_max is often 2. In addition, the maximum number of iterations between two improvements is usually used as a stopping condition. :RVNS is akin to a <a href="Monte-Carlo_method" title="wikilink">Monte-Carlo method</a>, but is more systematic.
</dd>
</dl>
<ul>
<li>Skewed VNS</li>
</ul>
<dl>
<dd>The skewed VNS (SVNS) method (Hansen et al.)<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> addresses the :problem of exploring valleys far from the incumbent solution. Indeed, once the best solution in a large region has been found, it is necessary to :go some way to obtain an improved one. Solutions drawn at random in distant neighbourhoods may differ substantially from the incumbent and VNS :can then degenerate, to some extent, into the Multistart heuristic (in which descents are made iteratively from solutions generated at random, a :heuristic which is known not to be very efficient). Consequently, some compensation for distance from the incumbent must be made.
</dd>
</dl>
<ul>
<li>Variable Neighbourhood Decomposition Search</li>
</ul>
<dl>
<dd>The variable neighbourhood decomposition search (VNDS) method (Hansen et al.)<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> extends the basic VNS into a two-level VNS scheme based upon :decomposition of the problem. For ease of presentation, but without loss of generality, it is assumed that the solution x represents the set of :some elements.
</dd>
</dl>
<ul>
<li>Parallel VNS</li>
</ul>
<dl>
<dd>Several ways of parallelizing VNS have recently been proposed for solving the p-Median problem. In García-López et al.:<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a>  three of them :are tested: (i) parallelize local search; (ii) augment the number of solutions drawn from the current neighbourhood and make a :local search in :parallel from each of them and (iii) do the same as (ii) but update the information about the best solution found. Three Parallel :VNS strategies :are also suggested for solving the <a href="Travelling_purchaser_problem" title="wikilink">Travelling purchaser problem</a> in Ochi et al.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a>
</dd>
</dl>
<ul>
<li>Primal-dual VNS</li>
</ul>
<dl>
<dd>For most modern heuristics, the difference in value between the optimal solution and the obtained one is completely unknown. Guaranteed :performance of the primal heuristic may be determined if a <a href="upper_and_lower_bounds" title="wikilink">lower bound</a> on the objective function value is known. To :this end, the standard approach is to relax the integrality condition on the primal variables, based on a mathematical programming formulation of :the problem.
</dd>
<dd>However, when the dimension of the problem is large, even the relaxed problem may be impossible to solve exactly by standard :commercial solvers. :Therefore, it seems a good idea to solve dual relaxed problems heuristically as well. It was obtained guaranteed bounds on :the primal heuristics :performance. In Primal-dual VNS (PD-VNS) (Hansen et al.)<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> one :possible general way to attain both the guaranteed bounds and the exact solution is proposed.
</dd>
</dl>
<ul>
<li>Variable Neighborhood Branching.)<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></li>
</ul>
<dl>
<dd>The mixed integer linear programming (MILP) problem consists of maximizing or minimizing a linear function, subject to equality or inequality :constraints, and integrality restrictions on some of the variables.
</dd>
</dl>
<ul>
<li>Variable Neighborhood Formulation Space Search .)<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
</ul>
<dl>
<dd>FSS is method which is very useful because, one problem could be defined in addition formulations and moving through formulations is legitimate. :It is proved that local search works within formulations, implying a final solution when started from some initial solution in first formulation. :Local search systematically alternates between different formulations which was investigated for <a href="Circle_packing_in_a_circle" title="wikilink">circle packing</a> :problem (CPP) where <a href="stationary_point" title="wikilink">stationary point</a> for a <a href="nonlinear_programming" title="wikilink">nonlinear programming</a> formulation of CPP in <a href="Cartesian_coordinate_system" title="wikilink">Cartesian coordinates</a> is not strictly a stationary point in <a href="Polar_coordinate_system" title="wikilink">polar coordinates</a>.
</dd>
</dl>
<h2 id="development">Development</h2>

<p>In order to make a simple version of VNS, here is the list of steps which should be made. Most of it is very similar with steps in other metaheuristics.</p>
<ol>
<li>It is necessary to be involved in problem, give some examples and try to solve them</li>
<li>Study books, surveys and scientific papers</li>
<li>Try to test some benchmarks</li>
<li>Choose appropriate data structure for representing in memory</li>
<li>Find initial solution</li>
<li>Calculate objective function</li>
<li>Design a procedure for Shaking</li>
<li>Choose an local search heuristic with some moves as drop, add, swap, interchange, etc.</li>
<li>Compare VNS with other methods from the literature</li>
</ol>
<h2 id="applications">Applications</h2>

<p>Applications of VNS, or of varieties of VNS are very abundant and numerous. Some fields where it could be found collections of scientific papers:</p>
<ul>
<li>Industrial applications</li>
<li>Design problems in communication</li>
<li>Location problems</li>
<li><a href="Data_mining" title="wikilink">Data mining</a></li>
<li><a href="Graph_theory" title="wikilink">Graph problems</a></li>
<li><a href="Knapsack_problem" title="wikilink">Knapsack</a> and packing problems</li>
<li>Mixed integer problems</li>
<li>Time tabling</li>
<li><a class="uri" href="Scheduling" title="wikilink">Scheduling</a></li>
<li><a href="Vehicle_routing_problem" title="wikilink">Vehicle routing problems</a></li>
<li><a href="Arc_routing" title="wikilink">Arc routing</a> and waste collection</li>
<li>Fleet sheet problems</li>
<li>Extended vehicle routing problems</li>
<li>Problems in biosciences and chemistry</li>
<li>Continuous optimization</li>
<li>Other optimization problems</li>
<li>Discovery science</li>
</ul>
<h2 id="conclusion">Conclusion</h2>

<p>VNS implies several features which are presented in Hansen and Mladenovic<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> and some are presented here:</p>

<p>(i) Simplicity: VNS is simple a simple and clear which is universally applicable;</p>

<p>(ii) Precision: VNS is formulated in precise mathematical definitions;</p>

<p>(iii) Coherence: all actions of the heuristics for solving problems follow from the VNS principles;</p>

<p>(iv) Effectiveness: VNS supplies optimal or near-optimal solutions for all or at least most realistic instances;</p>

<p>(v) Efficiency: VNS takes a moderate computing time to generate optimal or near-optimal solutions;</p>

<p>(vi) Robustness: the functioning of the VNS is coherent over a variety of instances;</p>

<p>(vii) User friendliness: VNS has no parameters, so it is easy for understanding, expressing and using;</p>

<p>(viii) Innovation: VNS is generating new types of application.</p>

<p>(ix) Generality: VNS is inducing to good results for a wide variety of problems;</p>

<p>(x) Interactivity: VNS allows the user to incorporate his knowledge to improve the resolution process;</p>

<p>(xi) Multiplicity: VNS is able to produce a certain near-optimal solutions from which the user can choose;</p>

<p>Interest in VNS is growing quickly, evidenced by the increasing number of papers published each year on this topic (10 years ago, only a few; 5 years ago, about a dozen; and about 50 in 2007). Moreover, the 18th EURO mini-conference held in Tenerife in November 2005 was entirely devoted to VNS. It led to special issues of <a href="Institute_of_Mathematics_and_its_Applications" title="wikilink">IMA Journal of Management Mathematics</a> in 2007, European Journal of Operational Research (http://www.journals.elsevier.com/european-journal-of-operational-research/), and Journal of Heuristics (http://www.springer.com/mathematics/applications/journal/10732/) in 2008.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://toledo.mi.sanu.ac.rs/~grujicic/vnsconference">EURO Mini Conference XXVIII on Variable Neighbourhood Search</a></li>
</ul>

<p>"</p>

<p><a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
</ol>
</section>
</body>
</html>
