   Wang and Landau algorithm      Wang and Landau algorithm  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     The Wang and Landau algorithm , proposed by Fugao Wang and David P. Landau , 1 is a Monte Carlo method designed to calculate the density of states of a system. The method performs a non-markovian random walk to build the density of states by quickly visiting all the available energy spectrum. The Wang and Landau algorithm is an important method to obtain the density of states required to perform a multicanonical simulation .  The Wang–Landau algorithm can be applied to any system which is characterized by a cost (or energy) function. For instance, it has been applied to the solution of numerical integrals 2 and the folding of proteins. 3 4 The Wang-Landau Sampling is related to the Metadynamics algorithm. 5  Overview  The Wang and Landau algorithm is used to obtain the density of states of a system characterized by a cost function. It uses a non-markovian stochastic process which asymptotically converges to a multicanonical ensemble . 6 (I.e. to a Metropolis-Hastings algorithm with sampling distribution inverse to the density of states.) The major consequence is that this sampling distribution leads to a simulation where the energy barriers are invisible. This means that the algorithm visits all the accessible states (favorable and less favorable) much faster than a metropolis algorithm. 7  Algorithm  Consider a system defined on a phase space   Ω   normal-Ω   \Omega   , and a cost function, E, (e.g. the energy), bounded on a spectrum    E  ∈  Γ  =   [   E  min   ,   E  max   ]         E  normal-Γ         subscript  E     subscript  E        E\in\Gamma=[E_{\min},E_{\max}]   , which has an associated density of states     ρ   (  E  )    ≡   exp   (   S   (  E  )    )          ρ  E       S  E      \rho(E)\equiv\exp(S(E))   , which is to be computed. Because Wang and Landau algorithm works in discrete spectra, 8 the spectrum   Γ   normal-Γ   \Gamma   is divided in N discrete values with a difference between them of   Δ   normal-Δ   \Delta   , such that       N  =     E  max   -   E  min    Δ    ,      N       subscript  E     subscript  E     normal-Δ     N=\frac{E_{\max}-E_{\min}}{\Delta},   .  Given this discrete spectrum, the algorithm is initialized by:   setting all entries of the entropy to zero,      S   (   E  i   )    =  0    i  =   1  ,  2  ,  …  ,  N       formulae-sequence      S   subscript  E  i    0     i   1  2  normal-…  N      S(E_{i})=0\ \ i=1,2,...,N     initializing    f  =  1      f  1    f=1   and  initializing the system randomly, by putting in a random configuration    𝒓  ∈  Ω      𝒓  normal-Ω    \boldsymbol{r}\in\Omega   .   The algorithm then performs a multicanonical ensemble like simulation: 9 a Metropolis-Hastings random walk in the phase space of the system with a probability distribution given by     P   (  𝒓  )    =    1  /  ρ    (   E   (  𝒓  )    )    =   exp   (   -   S   (   E   (  𝒓  )    )     )            P  𝒓       1  ρ     E  𝒓               S    E  𝒓         P(\boldsymbol{r})=1/\rho(E(\boldsymbol{r}))=\exp(-S(E(\boldsymbol{r})))   and a probability of proposing a new state given by a probability distribution    g   (  𝒓  →   𝒓  ′   )      fragments  g   fragments  normal-(  r  normal-→   superscript  𝒓  normal-′   normal-)     g(\boldsymbol{r}\rightarrow\boldsymbol{r}^{\prime})   . A histogram    H   (  E  )       H  E    H(E)   of visited energies is stored. Like in the Metropolis-Hastings algorithm, a proposal-acceptance step is performed, and consists in (see Metropolis–Hastings algorithm overview ):   proposing a state     𝒓  ′   ∈  Ω       superscript  𝒓  normal-′   normal-Ω    \boldsymbol{r}^{\prime}\in\Omega   according to    g   (  𝒓  →   𝒓  ′   )      fragments  g   fragments  normal-(  r  normal-→   superscript  𝒓  normal-′   normal-)     g(\boldsymbol{r}\rightarrow\boldsymbol{r}^{\prime})     accept/refuse the proposed state according to         A   (  𝒓  →   𝒓  ′   )   =  min   (  1  ,   e   S  -   S  ′       g   (   𝒓  ′   →  𝒓  )     g   (  𝒓  →   𝒓  ′   )     )      fragments  A   fragments  normal-(  r  normal-→   superscript  𝒓  normal-′   normal-)      fragments  normal-(  1  normal-,   superscript  e    S   superscript  S  normal-′        fragments  g   fragments  normal-(   superscript  𝒓  normal-′   normal-→  r  normal-)     fragments  g   fragments  normal-(  r  normal-→   superscript  𝒓  normal-′   normal-)     normal-)     A(\boldsymbol{r}\rightarrow\boldsymbol{r}^{\prime})=\min\left(1,e^{S-S^{\prime%
 }}\frac{g(\boldsymbol{r}^{\prime}\rightarrow\boldsymbol{r})}{g(\boldsymbol{r}%
 \rightarrow\boldsymbol{r}^{\prime})}\right)          where    S  =   S   (   E   (  𝒓  )    )        S    S    E  𝒓      S=S(E(\boldsymbol{r}))   and     S  ′   =   S   (   E   (   𝒓  ′   )    )         superscript  S  normal-′     S    E   superscript  𝒓  normal-′       S^{\prime}=S(E(\boldsymbol{r}^{\prime}))   .     After each proposal-acceptance step, the system transits to some value    E  i     subscript  E  i    E_{i}   ,    H   (   E  i   )       H   subscript  E  i     H(E_{i})   is incremented by one and the following update is performed:       S   (   E  i   )    ←    S   (   E  i   )    +  f      normal-←    S   subscript  E  i        S   subscript  E  i    f     S(E_{i})\leftarrow S(E_{i})+f   .  This is the crucial step of the algorithm, and it is what make this Wang and Landau algorithm non-markovian: the stochastic process now depends on the history of the process. Hence the next time there is a proposal to a state with that particular energy    E  i     subscript  E  i    E_{i}   , that proposal is now more likely refused; in this sense, the algorithm forces the system to visit all the spectrum equally. 10 The consequence is that the histogram    H   (  E  )       H  E    H(E)   is more and more flat. However, this flatness depends on how well approximated the calculated entropy is to the exact entropy, which naturally depends on the value of f. 11 To better and better approximate the exact entropy (and thus histogram's flatness), f is decreased after M proposal-acceptance steps:      f  ←   f  /  2      normal-←  f    f  2     f\leftarrow f/2   .  It was later shown that updating the f by constantly dividing by two can lead to saturation errors. 12 A small modification to the Wang and Landau method to avoid this problem is to use the f factor proportional to    1  /  t      1  t    1/t   , where   t   t   t   is proportional to the number of steps of the simulation. 13  Test system  We want to obtain the DOS for the harmonic oscillator potential.        E   (  x  )    =   x  2    ,        E  x    superscript  x  2     E(x)=x^{2},\,     The analytical DOS is given by,        g   (  E  )    =   ∫   δ   (    E   (  x  )    -   E  0    )   d  x    =   ∫   δ   (    x  2   -   E  0    )   d  x     ,          g  E       δ      E  x    subscript  E  0    d  x             δ     superscript  x  2    subscript  E  0    d  x       g(E)=\int\delta(E(x)-E_{0})\,dx=\int\delta(x^{2}-E_{0})\,dx,     by performing the last integral we obtain,        g   (  E  )    ∝   E   -   1  /  2      ,     proportional-to    g  E    superscript  E      1  2       g(E)\propto E^{-1/2},     in general, the DOS for a multidimensional harmonic oscillator will be given by some power of E , the exponent will be a function of the dimension of the system.  Hence, we can use a simple harmonic oscillator potential to test the accuracy of Wang–Landau algorithm because we know already the analytic form of the density of states. Therefore we compare the density of states    ρ   (  E  )       ρ  E    \rho(E)   obtained by the Wang–Landau algorithm with    g   (  E  )       g  E    g(E)   .  Sample code  The following is a sample code of the Wang–Landau algorithm in Python , considering that the proposal is such that        g   (   𝒙  ′   →  𝒙  )     g   (  𝒙  →   𝒙  ′   )     =  1         fragments  g   fragments  normal-(   superscript  𝒙  normal-′   normal-→  x  normal-)     fragments  g   fragments  normal-(  x  normal-→   superscript  𝒙  normal-′   normal-)     1    \frac{g(\boldsymbol{x}^{\prime}\rightarrow\boldsymbol{x})}{g(\boldsymbol{x}%
 \rightarrow\boldsymbol{x}^{\prime})}=1     The code considers a "system" which is the underlying system being studied.  currentEnergy = system.randomConfiguration() # a random initial configuration  while (f > epsilon):
     system.proposeConfiguration() # a proposed configuration is proposed proposedEnergy = system.proposedEnergy() # the energy of the proposed configuration computed  if (random() < exp(entropy[currentEnergy] - entropy[proposedEnergy])): # if accepted, update the energy and the system: currentEnergy = proposedEnergy
         system.acceptProposedConfiguration() else : # if rejected system.rejectProposedConfiguration()
     
     H[currentEnergy] +=  1 entropy[currentEnergy] += f if (isFlat(H)): # isFlat tests whether the histogram is flat (e.g. 95% flatness) H[:] =  0 f *=  0.5  # refine the f parameter  Wang and Landau molecular dynamics  It should be noted that the Wang and Landau algorithm can be implemented not only in a Monte Carlo simulation but also in a molecular dynamics simulation. To do this would require an escalation of the temperature of the system as follows:         T  ′    (  E  )    →    (     ∂  S    (  E  )    /   ∂  E    )   T   (  E  )     ,     normal-→     superscript  T  normal-′   E           S   E     E    T  E     T^{\prime}(E)\rightarrow(\partial S(E)/\partial E)T(E),     where    S   (  E  )       S  E    S(E)   is the entropy of the system,    T   (  E  )       T  E    T(E)   the micro-canonical temperature and     T  ′    (  E  )        superscript  T  normal-′   E    T^{\prime}(E)   is the "scaled" temperature used in the simulation.  References  "  Category:Markov chain Monte Carlo  Category:Statistical algorithms  Category:Computational physics  Category:Articles with example Python code         Junghans, Christoph, Danny Perez, and Thomas Vogel. "Molecular Dynamics in the Multicanonical Ensemble: Equivalence of Wang–Landau Sampling, Statistical Temperature Molecular Dynamics, and Metadynamics." Journal of Chemical Theory and Computation 10.5 (2014): 1843-1847. ↩            