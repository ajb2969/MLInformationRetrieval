<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1139">Backpressure routing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Backpressure routing</h1>
<hr/>

<p>In <a href="queueing_theory" title="wikilink">queueing theory</a>, a discipline within the mathematical <a href="probability_theory" title="wikilink">theory of probability</a>, the <strong>backpressure routing algorithm</strong> is a method for directing traffic around a queueing network that achieves maximum network throughput,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> which is established using concepts of <a href="Lyapunov_optimization" title="wikilink">Lyapunov drift</a>. Backpressure routing considers the situation where each job can visit multiple service nodes in the network. It is an extension of <a href="max-weight_scheduling" title="wikilink">max-weight scheduling</a> where rather each job visits only a single service node.</p>
<h2 id="introduction-to-backpressure-routing">Introduction to backpressure routing</h2>

<p><strong>Backpressure routing</strong> is an algorithm for dynamically routing traffic over a multi-hop network by using congestion gradients. The algorithm can be applied to wireless communication networks, including <a href="Wireless_sensor_network" title="wikilink">sensor networks</a>, mobile ad hoc networks (<a href="Mobile_ad_hoc_network" title="wikilink">MANETS</a>), and heterogeneous networks with wireless and wireline components<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> . Backpressure principles can also be applied to other areas, such as to the study of product assembly systems and processing networks <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> . This article focuses on communication networks, where packets from multiple data streams arrive and must be delivered to appropriate destinations. The backpressure algorithm operates in slotted time. Every time slot it seeks to route data in directions that maximize the <em>differential backlog</em> between neighboring nodes. This is similar to how water flows through a network of pipes via pressure gradients. However, the backpressure algorithm can be applied to multi-commodity networks (where different packets may have different destinations), and to networks where transmission rates can be selected from a set of (possibly time-varying) options. Attractive features of the backpressure algorithm are: (i) it leads to maximum network throughput, (ii) it is provably robust to time-varying network conditions, (iii) it can be implemented without knowing traffic arrival rates or channel state probabilities. However, the algorithm may introduce large delays, and may be difficult to implement exactly in networks with interference. Modifications of backpressure that reduce delay and simplify implementation are described below under <a href="#Improving_delay" title="wikilink">Improving Delay</a> and <a href="#Distributed_backpressure" title="wikilink">Distributed Backpressure</a>.</p>

<p>Backpressure routing has mainly been studied in a theoretical context. In practice, ad hoc wireless networks have typically implemented alternative routing methods based on shortest path computations or network flooding, such as <a href="Ad_hoc_On-Demand_Distance_Vector_Routing" title="wikilink">Ad Hoc on-Demand Distance Vector Routing</a> (AODV), <a href="Geographic_routing" title="wikilink">Geographic Routing</a>, and <a href="ExOR_(wireless_network_protocol)" title="wikilink">Extremely Opportunistic Routing</a> (ExOR). However, the mathematical optimality properties of backpressure have motivated recent experimental demonstrations of its use on wireless testbeds at the University of Southern California and at North Carolina State University <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> .</p>
<h3 id="origins">Origins</h3>

<p>The original backpressure algorithm was developed by Tassiulas and Ephremides.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> They considered a multi-hop packet radio network with random packet arrivals and a fixed set of link selection options. Their algorithm consisted of a <em>max-weight link selection</em> stage and a <em>differential backlog routing</em> stage. An algorithm related to backpressure, designed for computing multi-commodity network flows, was developed in Awerbuch and Leighton.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The backpressure algorithm was later extended by Neely, Modiano, and Rohrs to treat scheduling for mobile networks.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Backpressure is mathematically analyzed via the theory of <a href="Lyapunov_optimization" title="wikilink">Lyapunov drift</a>, and can be used jointly with flow control mechanisms to provide network utility maximization. <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> (see also <a href="#Backpressure_with_utility_optimization_and_penalty_minimization" title="wikilink">Backpressure with Utility Optimization and Penalty Minimization</a>).</p>
<h2 id="how-it-works">How it works</h2>

<p>Backpressure routing is designed to make decisions that (roughly) minimize the sum of squares of queue backlogs in the network from one timeslot to the next. The precise mathematical development of this technique is described in later sections. This section describes the general network model and the operation of backpressure routing with respect to this model.</p>
<h3 id="the-multi-hop-queueing-network-model">The multi-hop queueing network model</h3>

<p> Consider a multi-hop network with <em>N</em> nodes (see Fig. 1 for an example with <em>N</em>=6). The network operates in slotted time 

<math display="inline" id="Backpressure_routing:0">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in\{0,1,2,\ldots\}
  </annotation>
 </semantics>
</math>

. On each slot, new data can arrive to the network, and routing and transmission scheduling decisions are made in an effort to deliver all data to its proper destination. Let data that is destined for node 

<math display="inline" id="Backpressure_routing:1">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\{1,\dots,N\}
  </annotation>
 </semantics>
</math>

 be labeled as <em>commodity c data</em>. Data in each node is stored according to its commodity. For 

<math display="inline" id="Backpressure_routing:2">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpressure_routing:3">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Backpressure_routing:4">
 <semantics>
  <mrow>
   <msubsup>
    <mi>Q</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{n}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 be the current amount of commodity <em>c</em> data in node <em>n</em>, also called the <em>queue backlog</em>. A closeup of the queue backlogs inside a node is shown in Fig. 2. The units of 

<math display="inline" id="Backpressure_routing:5">
 <semantics>
  <mrow>
   <msubsup>
    <mi>Q</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{n}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 depend on the context of the problem. For example, backlog can take integer units of <em>packets</em>, which is useful in cases when data is segmented into fixed length packets. Alternatively, it can take real valued units of <em>bits</em>. It is assumed that 

<math display="inline" id="Backpressure_routing:6">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>Q</mi>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>c</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{c}^{(c)}(t)=0
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Backpressure_routing:7">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

 and all timeslots <em>t</em>, because no node stores data destined for itself. Every timeslot, nodes can transmit data to others. Data that is transmitted from one node to another node is removed from the queue of the first node and added to the queue of the second. Data that is transmitted to its destination is removed from the network. Data can also arrive exogenously to the network, and 

<math display="inline" id="Backpressure_routing:8">
 <semantics>
  <mrow>
   <msubsup>
    <mi>A</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{n}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 is defined as the amount of new data that arrives to node <em>n</em> on slot <em>t</em> that must eventually be delivered to node <em>c</em>.</p>

<p>Let 

<math display="inline" id="Backpressure_routing:9">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}(t)
  </annotation>
 </semantics>
</math>

 be the <em>transmission rate</em> used by the network over link (<em>a</em>,<em>b</em>) on slot <em>t</em>, representing the amount of data it can transfer from node <em>a</em> to node <em>b</em> on the current slot. Let 

<math display="inline" id="Backpressure_routing:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 be the transmission rate matrix. These transmission rates must be selected within a set of possibly time-varying options. Specifically, the network may have time-varying channels and node mobility, and this can affect its transmission capabilities every slot. To model this, let <em>S</em>(<em>t</em>) represent the <em>topology state</em> of the network, which captures properties of the network on slot <em>t</em> that affect transmission. Let 

<math display="inline" id="Backpressure_routing:11">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

 represent the set of transmission rate matrix options available under topology state <em>S</em>(<em>t</em>). Every slot <em>t</em>, the network controller observes <em>S</em>(<em>t</em>) and chooses transmission rates 

<math display="inline" id="Backpressure_routing:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 within the set 

<math display="inline" id="Backpressure_routing:13">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

. The choice of which 

<math display="inline" id="Backpressure_routing:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 matrix to select on each slot <em>t</em> is described in the next subsection.</p>

<p>This time-varying network model was first developed for the case when transmission rates every slot t were determined by general functions of a channel state matrix and a power allocation matrix.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The model can also be used when rates are determined by other control decisions, such as server allocation, sub-band selection, coding type, and so on. It assumes the supportable transmission rates are known and there are no transmission errors. Extended formulations of backpressure routing can be used for networks with probabilistic channel errors, including networks that exploit the wireless broadcast advantage via <em>multi-receiver diversity</em>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h3 id="the-backpressure-control-decisions">The backpressure control decisions</h3>

<p>Every slot <em>t</em> the backpressure controller observes <em>S</em>(<em>t</em>) and performs the following 3 steps:</p>
<ul>
<li>First, for each link (<em>a</em>,<em>b</em>), it selects an <em>optimal commodity</em> 

<math display="inline" id="Backpressure_routing:15">
 <semantics>
  <mrow>
   <msubsup>
    <mi>c</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
     <mi>t</mi>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ab}^{opt}(t)
  </annotation>
 </semantics>
</math>

 to use.</li>
<li>Next, it determines what 

<math display="inline" id="Backpressure_routing:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 matrix in 

<math display="inline" id="Backpressure_routing:17">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

 to use.</li>
<li>Finally, it determines the amount of commodity 

<math display="inline" id="Backpressure_routing:18">
 <semantics>
  <mrow>
   <msubsup>
    <mi>c</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
     <mi>t</mi>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ab}^{opt}(t)
  </annotation>
 </semantics>
</math>

 it will transmit over link (<em>a</em>,<em>b</em>) (being at most 

<math display="inline" id="Backpressure_routing:19">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}(t)
  </annotation>
 </semantics>
</math>

, but possibly being less in some cases).</li>
</ul>
<h4 id="choosing-the-optimal-commodity">Choosing the optimal commodity</h4>

<p>Each node <em>a</em> observes its own queue backlogs and the backlogs in its current neighbors. A <em>current neighbor</em> of node <em>a</em> is a node <em>b</em> such that it is possible to choose a non-zero transmission rate 

<math display="inline" id="Backpressure_routing:20">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}(t)
  </annotation>
 </semantics>
</math>

 on the current slot. Thus, neighbors are determined by the set 

<math display="inline" id="Backpressure_routing:21">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

. In the extreme case, a node can have all <em>N</em> − 1 other nodes as neighbors. However, it is common to use sets 

<math display="inline" id="Backpressure_routing:22">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

 that preclude transmissions between nodes that are separated by more than a certain geographic distance, or that would have a propagated signal strength below a certain threshold. Thus, it is typical for the number of neighbors to be much less than <em>N</em> − 1. The example in Fig. 1 illustrates neighbors by link connections, so that node 5 has neighbors 4 and 6. The example suggests a symmetric relationship between neighbors (so that if 5 is a neighbor of 4, then 4 is a neighbor of 5), but this need not be the case in general.</p>

<p>The set of neighbors of a given node determines the set of outgoing links it can use for transmission on the current slot. For each outgoing link (<em>a</em>,<em>b</em>), the <em>optimal commodity</em> 

<math display="inline" id="Backpressure_routing:23">
 <semantics>
  <mrow>
   <msubsup>
    <mi>c</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
     <mi>t</mi>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ab}^{opt}(t)
  </annotation>
 </semantics>
</math>

 is defined as the commodity 

<math display="inline" id="Backpressure_routing:24">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

 that maximizes the following <em>differential backlog</em> quantity:</p>

<p>

<math display="block" id="Backpressure_routing:25">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>Q</mi>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <msubsup>
     <mi>Q</mi>
     <mi>b</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>a</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>b</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{a}^{(c)}(t)-Q_{b}^{(c)}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Any ties in choosing the optimal commodity are broken arbitrarily.</p>

<p> An example is shown in Fig. 2. The example assumes each queue currently has only 3 commodities: <em>red</em>, <em>green</em>, and <em>blue</em>, and these are measured in integer units of packets. Focusing on the directed link (1,2), the differential backlogs are:</p>

<p>

<math display="block" id="Backpressure_routing:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mn>1</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mtext>red</mtext>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mtext>red</mtext>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <mtext>red</mtext>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">2</cn>
       </apply>
       <mtext>red</mtext>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}^{(\text{red})}(t)-Q_{2}^{(\text{red})}(t)=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Backpressure_routing:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mn>1</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mtext>green</mtext>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mtext>green</mtext>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <mtext>green</mtext>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">2</cn>
       </apply>
       <mtext>green</mtext>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}^{(\text{green})}(t)-Q_{2}^{(\text{green})}(t)=2
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Backpressure_routing:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mn>1</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mtext>blue</mtext>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>b</mi>
        <mi>l</mi>
        <mi>u</mi>
        <mi>e</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <mtext>blue</mtext>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>l</ci>
        <ci>u</ci>
        <ci>e</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}^{(\text{blue})}(t)-Q_{2}^{(blue)}(t)=-1
  </annotation>
 </semantics>
</math>

</p>

<p>Hence, the optimal commodity to send over link (1,2) on slot <em>t</em> is the green commodity. On the other hand, the optimal commodity to send over the reverse link (2,1) on slot <em>t</em> is the blue commodity.</p>
<h4 id="choosing-the-μabt-matrix">Choosing the <em>μ</em><sub><em>ab</em></sub>(<em>t</em>) matrix</h4>

<p>Once the optimal commodities have been determined for each link (<em>a</em>,<em>b</em>), the network controller computes the following weights 

<math display="inline" id="Backpressure_routing:29">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ab}(t)
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Backpressure_routing:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <msubsup>
        <mi>Q</mi>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msubsup>
           <mi>c</mi>
           <mrow>
            <mi>a</mi>
            <mi>b</mi>
           </mrow>
           <mi>opt</mi>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msubsup>
        <mi>Q</mi>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msubsup>
           <mi>c</mi>
           <mrow>
            <mi>a</mi>
            <mi>b</mi>
           </mrow>
           <mrow>
            <mi>o</mi>
            <mi>p</mi>
            <mi>t</mi>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mn>0</mn>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <max></max>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>a</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <apply>
            <times></times>
            <ci>a</ci>
            <ci>b</ci>
           </apply>
          </apply>
          <ci>opt</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>b</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <apply>
            <times></times>
            <ci>a</ci>
            <ci>b</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>o</ci>
           <ci>p</ci>
           <ci>t</ci>
          </apply>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ab}(t)=\max\left[Q_{a}^{(c_{ab}^{\mathrm{opt}}(t))}(t)-Q_{b}^{(c_{ab}^{opt}%
(t))}(t),0\right]
  </annotation>
 </semantics>
</math>

</p>

<p>The weight 

<math display="inline" id="Backpressure_routing:31">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ab}(t)
  </annotation>
 </semantics>
</math>

 is the value of the differential backlog associated with the optimal commodity for link (<em>a</em>,<em>b</em>), maxed with 0. The controller then chooses transmission rates as the solution to the following <em>max-weight</em> problem (breaking ties arbitrarily):</p>

<p>

<math display="block" id="Backpressure_routing:32">
 <semantics>
  <mrow>
   <mtext>(Eq. 1)</mtext>
   <mrow>
    <mtext>Maximize:</mtext>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>a</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>b</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mrow>
         <mi>a</mi>
         <mi>b</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>W</mi>
        <mrow>
         <mi>a</mi>
         <mi>b</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <mtext>(Eq. 1)</mtext>
    <apply>
     <times></times>
     <mtext>Maximize:</mtext>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>b</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <apply>
          <times></times>
          <ci>a</ci>
          <ci>b</ci>
         </apply>
        </apply>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>W</ci>
         <apply>
          <times></times>
          <ci>a</ci>
          <ci>b</ci>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 1)}\qquad\text{Maximize: }\sum_{a=1}^{N}\sum_{b=1}^{N}\mu_{ab}(t)W_%
{ab}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Backpressure_routing:33">
 <semantics>
  <mrow>
   <mrow>
    <mtext>(Eq. 2)</mtext>
    <mrow>
     <mtext>Subject to:</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mrow>
         <mi>a</mi>
         <mi>b</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <mtext>(Eq. 2)</mtext>
     <apply>
      <times></times>
      <mtext>Subject to:</mtext>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 2)}\qquad\text{Subject to: }(\mu_{ab}(t))\in\Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

</p>

<p>As an example of the max-weight decision, suppose that on the current slot <em>t</em>, the differential backlogs on each link of the 6 node network lead to link weights 

<math display="inline" id="Backpressure_routing:34">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ab}(t)
  </annotation>
 </semantics>
</math>

 given by:</p>

<p>

<math display="block" id="Backpressure_routing:35">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>6</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>5</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>6</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>7</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>7</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>5</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>5</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">6</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
       <cn type="integer">5</cn>
       <cn type="integer">6</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">7</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">7</cn>
       <cn type="integer">5</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">5</cn>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (W_{ab}(t))=\left[\begin{array}[]{cccccc}0&2&1&1&6&0\\
1&0&1&2&5&6\\
0&7&0&0&0&0\\
1&0&1&0&0&0\\
1&0&7&5&0&0\\
0&0&0&0&5&0\end{array}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>While the set 

<math display="inline" id="Backpressure_routing:36">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

 might contain an uncountably infinite number of possible transmission rate matrices, assume for simplicity that the current topology state admits only 4 possible choices:</p>

<p>

<math display="block" id="Backpressure_routing:37">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>𝝁</mi>
     <mi>a</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>𝝁</mi>
     <mi>b</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>𝝁</mi>
     <mi>c</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>𝝁</mi>
     <mi>d</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝝁</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝝁</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝝁</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝝁</ci>
      <ci>d</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{S(t)}=\{\boldsymbol{\mu}_{a},\boldsymbol{\mu}_{b},\boldsymbol{\mu}_{c}%
,\boldsymbol{\mu}_{d}\}
  </annotation>
 </semantics>
</math>

</p>

<p>illustration of the 4 possible transmission rate selections under the current topology state <em>S</em>(<em>t</em>). Option (a) activates the single link (1,5) with a transmission rate of 

<math display="inline" id="Backpressure_routing:38">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mn>15</mn>
   </msub>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">15</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{15}=2
  </annotation>
 </semantics>
</math>

. All other options use two links, with transmission rates of 1 on each of the activated links.]]</p>

<p>These four possibilities are illustrated in Fig. 3. The options in Fig. 3 are represented in matrix form by:</p>

<p>

<math display="block" id="Backpressure_routing:39">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝝁</mi>
     <mi>a</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <msub>
     <mi>𝝁</mi>
     <mi>b</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝝁</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">2</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝝁</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\mu}_{a}=\left[\begin{array}[]{cccccc}0&0&0&0&2&0\\
0&0&0&0&0&0\\
0&0&0&0&0&0\\
0&0&0&0&0&0\\
0&0&0&0&0&0\\
0&0&0&0&0&0\end{array}\right],\quad\boldsymbol{\mu}_{b}=\left[\begin{array}[]{%
cccccc}0&0&0&0&0&0\\
0&0&1&0&0&0\\
0&0&0&0&0&0\\
0&0&0&0&1&0\\
0&0&0&0&0&0\\
0&0&0&0&0&0\end{array}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Backpressure_routing:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝝁</mi>
     <mi>c</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <msub>
     <mi>𝝁</mi>
     <mi>d</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝝁</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝝁</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\mu}_{c}=\left[\begin{array}[]{cccccc}0&0&0&0&0&0\\
1&0&0&0&0&0\\
0&0&0&0&0&0\\
0&0&0&0&1&0\\
0&0&0&0&0&0\\
0&0&0&0&0&0\end{array}\right],\quad\boldsymbol{\mu}_{d}=\left[\begin{array}[]{%
cccccc}0&0&0&0&0&0\\
0&0&0&0&0&0\\
0&1&0&0&0&0\\
0&0&0&0&0&0\\
0&0&0&1&0&0\\
0&0&0&0&0&0\end{array}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>Observe that node 6 can neither send nor receive under any of these possibilities. This might arise because node 6 is currently out of communication range. The weighted sum of rates for each of the 4 possibilities are:</p>
<ul>
<li>Choice (a)

<math display="block" id="Backpressure_routing:41">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>12</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{ab}W_{ab}(t)\mu_{ab}(t)=12
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Choice (b)

<math display="block" id="Backpressure_routing:42">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{ab}W_{ab}(t)\mu_{ab}(t)=1
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Choice (c)

<math display="block" id="Backpressure_routing:43">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{ab}W_{ab}(t)\mu_{ab}(t)=1
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Choice (d)

<math display="block" id="Backpressure_routing:44">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>12</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{ab}W_{ab}(t)\mu_{ab}(t)=12
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Because there is a tie for the maximum weight of 12, the network controller can break the tie arbitrarily by choosing either option 

<math display="inline" id="Backpressure_routing:45">
 <semantics>
  <msub>
   <mi>𝝁</mi>
   <mi>a</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝝁</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\mu}_{a}
  </annotation>
 </semantics>
</math>

 or option 

<math display="inline" id="Backpressure_routing:46">
 <semantics>
  <msub>
   <mi>𝝁</mi>
   <mi>d</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝝁</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\mu}_{d}
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="finalizing-the-routing-variables">Finalizing the routing variables</h4>

<p>Suppose now that the optimal commodities 

<math display="inline" id="Backpressure_routing:47">
 <semantics>
  <mrow>
   <msubsup>
    <mi>c</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
     <mi>t</mi>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ab}^{opt}(t)
  </annotation>
 </semantics>
</math>

 have been determined for each link, and the transmission rates 

<math display="inline" id="Backpressure_routing:48">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 have also been determined. If the differential backlog for the optimal commodity on a given link (<em>a</em>,<em>b</em>) is negative, then no data is transferred over this link on the current slot. Else, the network offers to send 

<math display="inline" id="Backpressure_routing:49">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}(t)
  </annotation>
 </semantics>
</math>

 units of commodity 

<math display="inline" id="Backpressure_routing:50">
 <semantics>
  <mrow>
   <msubsup>
    <mi>c</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mi>opt</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>opt</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ab}^{\mathrm{opt}}(t)
  </annotation>
 </semantics>
</math>

 data over this link. This is done by defining <em>routing variables</em> 

<math display="inline" id="Backpressure_routing:51">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 for each link (<em>a</em>,<em>b</em>) and each commodity <em>c</em>, where:</p>

<p>

<math display="block" id="Backpressure_routing:52">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>μ</mi>
         <mrow>
          <mi>a</mi>
          <mi>b</mi>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>c</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mrow>
          <msubsup>
           <mi>c</mi>
           <mrow>
            <mi>a</mi>
            <mi>b</mi>
           </mrow>
           <mrow>
            <mi>o</mi>
            <mi>p</mi>
            <mi>t</mi>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mtext>and</mtext>
          <msubsup>
           <mi>Q</mi>
           <mi>a</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msubsup>
              <mi>c</mi>
              <mrow>
               <mi>a</mi>
               <mi>b</mi>
              </mrow>
              <mrow>
               <mi>o</mi>
               <mi>p</mi>
               <mi>t</mi>
              </mrow>
             </msubsup>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>t</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <msubsup>
           <mi>Q</mi>
           <mi>b</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msubsup>
              <mi>c</mi>
              <mrow>
               <mi>a</mi>
               <mi>b</mi>
              </mrow>
              <mrow>
               <mi>o</mi>
               <mi>p</mi>
               <mi>t</mi>
              </mrow>
             </msubsup>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>t</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>≥</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
    <mi></mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <apply>
          <times></times>
          <ci>a</ci>
          <ci>b</ci>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <and></and>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <mtext>if</mtext>
          <ci>c</ci>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>c</ci>
             <apply>
              <times></times>
              <ci>a</ci>
              <ci>b</ci>
             </apply>
            </apply>
            <apply>
             <times></times>
             <ci>o</ci>
             <ci>p</ci>
             <ci>t</ci>
            </apply>
           </apply>
           <ci>t</ci>
           <mtext>and</mtext>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>Q</ci>
             <ci>a</ci>
            </apply>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>c</ci>
               <apply>
                <times></times>
                <ci>a</ci>
                <ci>b</ci>
               </apply>
              </apply>
              <apply>
               <times></times>
               <ci>o</ci>
               <ci>p</ci>
               <ci>t</ci>
              </apply>
             </apply>
             <ci>t</ci>
            </apply>
           </apply>
           <ci>t</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>Q</ci>
             <ci>b</ci>
            </apply>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>c</ci>
               <apply>
                <times></times>
                <ci>a</ci>
                <ci>b</ci>
               </apply>
              </apply>
              <apply>
               <times></times>
               <ci>o</ci>
               <ci>p</ci>
               <ci>t</ci>
              </apply>
             </apply>
             <ci>t</ci>
            </apply>
           </apply>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <geq></geq>
         <share href="#.cmml">
         </share>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <mtext>otherwise</mtext>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}^{(c)}(t)=\left\{\begin{array}[]{ll}\mu_{ab}(t)&\mbox{ if }c=c_{ab}^{%
opt}(t)\mbox{ and }Q_{a}^{(c_{ab}^{opt}(t))}(t)-Q_{b}^{(c_{ab}^{opt}(t))}(t)%
\geq 0\\
0&\mbox{ otherwise}\end{array}\right.
  </annotation>
 </semantics>
</math>

</p>

<p>The value of 

<math display="inline" id="Backpressure_routing:53">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 represents the transmission rate offered to commodity <em>c</em> data over link (<em>a</em>,<em>b</em>) on slot <em>t</em>. However, nodes might not have enough of a certain commodity to support transmission at the offered rates on all of their outgoing links. This arises on slot <em>t</em> for node <em>n</em> and commodity <em>c</em> if:</p>

<p>

<math display="block" id="Backpressure_routing:54">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>Q</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>b</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msubsup>
      <mi>μ</mi>
      <mrow>
       <mi>n</mi>
       <mi>b</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>n</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{n}^{(c)}(t)<\sum_{b=1}^{N}\mu_{nb}^{(c)}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>In this case, all of the 

<math display="inline" id="Backpressure_routing:55">
 <semantics>
  <mrow>
   <msubsup>
    <mi>Q</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{n}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 data is sent, and null data is used to fill the unused portions of the offered rates, allocating the actual data and null data arbitrarily over the corresponding outgoing links (according to the offered rates). This is called a <em>queue underflow</em> situation. Such underflows do not affect the throughput or stability properties of the network. Intuitively, this is because underflows only arise when the transmitting node has a low amount of backlog, which means the node is not in danger of instability.</p>
<h3 id="improving-delay">Improving delay</h3>

<p>It is important to note that the backpressure algorithm does not use any pre-specified paths. Paths are learned dynamically, and may be different for different packets. Delay can be very large, particularly when the system is lightly loaded so that there is not enough pressure to push data towards the destination. As an example, suppose one packet enters the network, and nothing else ever enters. This packet may take a loopy walk through the network and never arrive at its destination because no pressure gradients build up. This does not contradict the throughput optimality or stability properties of backpressure because the network has at most one packet at any time and hence is trivially stable (achieving a delivery rate of 0, equal to the arrival rate).</p>

<p>It is also possible to implement backpressure on a set of pre-specified paths. This can restrict the capacity region, but might improve in-order delivery and delay. Another way to improve delay, without affecting the capacity region, is to use an <em>enhanced</em> version that biases link weights towards desirable directions.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Simulations of such biasing have shown significant delay improvements.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Note that backpressure does not require First-in-First-Out (<a href="FIFO_(computing_and_electronics)" title="wikilink">FIFO</a>) service at the queues. It has been observed that Last-in-First-Out (<a href="LIFO_(computing)" title="wikilink">LIFO</a>) service can dramatically improve delay for the vast majority of packets, without affecting throughput.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> <a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h3 id="distributed-backpressure">Distributed backpressure</h3>

<p>Note that once the transmission rates 

<math display="inline" id="Backpressure_routing:56">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 have been selected, the routing decision variables 

<math display="inline" id="Backpressure_routing:57">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 can be computed in a simple distributed manner, where each node only requires knowledge of queue backlog differentials between itself and its neighbors. However, selection of the transmission rates requires a solution to the max-weight problem in Eqs. (1)-(2). In the special case when channels are orthogonal, the algorithm has a natural distributed implementation and reduces to separate decisions at each node. However, the max-weight problem is a centralized control problem for networks with inter-channel interference. It can also be very difficult to solve even in a centralized way.</p>

<p>A distributed approach for interference networks with link rates that are determined by the signal-to-noise-plus-interefernce ratio (SINR) can be carried out using randomization.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Each node randomly decides to transmit every slot <em>t</em> (transmitting a "null" packet if it currently does not have a packet to send). The actual transmission rates, and the corresponding actual packets to send, are determined by a 2-step handshake: On the first step, the randomly selected transmitter nodes send a pilot signal with signal strength proportional to that of an actual transmission. On the second step, all potential receiver nodes measure the resulting interference and send that information back to the transmitters. The SINR levels for all outgoing links (<em>n</em>,<em>b</em>) are then known to all nodes <em>n</em>, and each node <em>n</em> can decide its 

<math display="inline" id="Backpressure_routing:58">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>n</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{nb}(t)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpressure_routing:59">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>n</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{nb}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 variables based on this information. The resulting throughput is not necessarily optimal. However, the random transmission process can be viewed as a part of the channel state process (provided that null packets are sent in cases of underflow, so that the channel state process does not depend on past decisions). Hence, the resulting throughput of this distributed implementation is optimal over the class of all routing and scheduling algorithms that use such randomized transmissions.</p>

<p>Alternative distributed implementations can roughly be grouped into two classes: The first class of algorithms consider constant multiplicative factor approximations to the max-weight problem, and yield constant-factor throughput results. The second class of algorithms consider additive approximations to the max-weight problem, based on updating solutions to the max-weight problem over time. Algorithms in this second class seem to require static channel conditions and longer (often non-polynomial) convergence times, although they can provably achieve maximum throughput under appropriate assumptions.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> <a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> <a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Additive approximations are often useful for proving optimality of backpressure when implemented with out-of-date queue backlog information (see Exercise 4.10 of the Neely text).<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="mathematical-construction-via-lyapunov-drift">Mathematical construction via Lyapunov drift</h2>

<p>This section shows how the backpressure algorithm arises as a natural consequence of greedily minimizing a bound on the change in the sum of squares of queue backlogs from one slot to the next.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h3 id="control-decision-constraints-and-the-queue-update-equation">Control decision constraints and the queue update equation</h3>

<p>Consider a multi-hop network with <em>N</em> nodes, as described in the above section. Every slot <em>t</em>, the network controller observes the topology state <em>S</em>(<em>t</em>) and chooses transmission rates 

<math display="inline" id="Backpressure_routing:60">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 and routing variables 

<math display="inline" id="Backpressure_routing:61">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 subject to the following constraints:</p>

<p>

<math display="block" id="Backpressure_routing:62">
 <semantics>
  <mrow>
   <mrow>
    <mtext>(Eq. 3)</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>μ</mi>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <mtext>(Eq. 3)</mtext>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 3)}\qquad(\mu_{ab}(t))\in\Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Backpressure_routing:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>(Eq. 4)</mtext>
     <mn>0</mn>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msubsup>
      <mi>μ</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>a</mi>
    </mrow>
    <mo>,</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mrow>
     <mo>∀</mo>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <list>
      <mtext>(Eq. 4)</mtext>
      <cn type="integer">0</cn>
     </list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
     <ci>c</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>t</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 4)}\qquad 0\leq\mu_{ab}^{(c)}(t)\qquad\forall a,b,c,\forall t
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Backpressure_routing:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>(Eq. 5)</mtext>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>c</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </munderover>
      <mrow>
       <msubsup>
        <mi>μ</mi>
        <mrow>
         <mi>a</mi>
         <mi>b</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>∀</mo>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <list>
      <mtext>(Eq. 5)</mtext>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>c</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>μ</ci>
          <apply>
           <times></times>
           <ci>a</ci>
           <ci>b</ci>
          </apply>
         </apply>
         <ci>c</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <interval closure="open">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>t</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 5)}\qquad\sum_{c=1}^{N}\mu_{ab}^{(c)}(t)\leq\mu_{ab}(t)\qquad%
\forall(a,b),\forall t
  </annotation>
 </semantics>
</math>

</p>

<p>Once these routing variables are determined, transmissions are made (using idle fill if necessary), and the resulting queue backlogs satisfy the following:</p>

<p>

<math display="block" id="Backpressure_routing:65">
 <semantics>
  <mrow>
   <mrow>
    <mtext>(Eq. 6)</mtext>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <msubsup>
         <mi>Q</mi>
         <mi>n</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>b</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>N</mi>
        </munderover>
        <mrow>
         <msubsup>
          <mi>μ</mi>
          <mrow>
           <mi>n</mi>
           <mi>b</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>c</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mn>0</mn>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>a</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <msubsup>
       <mi>μ</mi>
       <mrow>
        <mi>a</mi>
        <mi>n</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mi>A</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <list>
     <mtext>(Eq. 6)</mtext>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>n</ci>
       </apply>
       <ci>c</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </list>
    <apply>
     <plus></plus>
     <apply>
      <max></max>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <ci>n</ci>
         </apply>
         <ci>c</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>b</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>μ</ci>
           <apply>
            <times></times>
            <ci>n</ci>
            <ci>b</ci>
           </apply>
          </apply>
          <ci>c</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <apply>
          <times></times>
          <ci>a</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>c</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>n</ci>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 6)}\qquad Q_{n}^{(c)}(t+1)\leq\max\left[Q_{n}^{(c)}(t)-\sum_{b=1}^{%
N}\mu_{nb}^{(c)}(t),0\right]+\sum_{a=1}^{N}\mu_{an}^{(c)}(t)+A_{n}^{(c)}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Backpressure_routing:66">
 <semantics>
  <mrow>
   <msubsup>
    <mi>A</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{n}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 is the random amount of new commodity <em>c</em> data that exogenously arrives to node <em>n</em> on slot <em>t</em>, and 

<math display="inline" id="Backpressure_routing:67">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mrow>
     <mi>n</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{nb}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 is the transmission rate allocated to commodity <em>c</em> traffic on link <em>(n,b)</em> on slot <em>t</em>. Note that 

<math display="inline" id="Backpressure_routing:68">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mrow>
     <mi>n</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{nb}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 may be more than the amount of commodity <em>c</em> data that is actually transmitted on link <em>(a,b)</em> on slot <em>t</em>. This is because there may not be enough backlog in node <em>n</em>. For this same reason, Eq. (6) is an inequality, rather than an equality, because 

<math display="inline" id="Backpressure_routing:69">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>a</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </msubsup>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>n</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{a=1}^{N}\mu_{an}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 may be more than the actual endogenous arrivals of commodity <em>c</em> to node <em>n</em> on slot <em>t</em>. An important feature of Eq. (6) is that it holds even if the 

<math display="inline" id="Backpressure_routing:70">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 decision variables are chosen independently of queue backlogs.</p>

<p>It is assumed that 

<math display="inline" id="Backpressure_routing:71">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>Q</mi>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>c</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{c}^{(c)}(t)=0
  </annotation>
 </semantics>
</math>

 for all slots <em>t</em> and all 

<math display="inline" id="Backpressure_routing:72">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

, as no queue stores data destined for itself.</p>
<h3 id="lyapunov-drift">Lyapunov drift</h3>

<p>Define 

<math display="inline" id="Backpressure_routing:73">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝑸</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝑸</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>n</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Q}(t)=(Q_{n}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 as the matrix of current queue backlogs. Define the following non-negative function, called a <a href="Lyapunov_function" title="wikilink">Lyapunov function</a>:</p>

<p>

<math display="inline" id="Backpressure_routing:74">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>c</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <mrow>
       <msubsup>
        <mi>Q</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>c</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <ci>n</ci>
         </apply>
         <ci>c</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(t)=\frac{1}{2}\sum_{n=1}^{N}\sum_{c=1}^{N}Q_{n}^{(c)}(t)^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>This is a sum of the squares of queue backlogs (multiplied by 1/2 only for convenience in later analysis). The above sum is the same as summing over all <em>n, c</em> such that 

<math display="inline" id="Backpressure_routing:75">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≠</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>n</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\neq c
  </annotation>
 </semantics>
</math>

 because 

<math display="inline" id="Backpressure_routing:76">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>Q</mi>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>c</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{c}^{(c)}(t)=0
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Backpressure_routing:77">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

 and all slots <em>t</em>.</p>

<p>The <em>conditional Lyapunov drift</em> 

<math display="inline" id="Backpressure_routing:78">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)
  </annotation>
 </semantics>
</math>

 is defined:</p>

<p>

<math display="block" id="Backpressure_routing:79">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo>[</mo>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>𝑸</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Δ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <minus></minus>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)=E\left[L(t+1)-L(t)|\boldsymbol{Q}(t)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the following inequality holds for all 

<math display="inline" id="Backpressure_routing:80">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>q</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\geq 0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Backpressure_routing:81">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\geq 0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Backpressure_routing:82">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>b</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\geq 0
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Backpressure_routing:83">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>max</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>q</mi>
         <mo>-</mo>
         <mi>b</mi>
        </mrow>
        <mo>,</mo>
        <mn>0</mn>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>≤</mo>
   <mrow>
    <msup>
     <mi>q</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>b</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>a</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <max></max>
       <apply>
        <minus></minus>
        <ci>q</ci>
        <ci>b</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <ci>a</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>q</ci>
      <apply>
       <minus></minus>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\max[q-b,0]+a)^{2}\leq q^{2}+b^{2}+a^{2}+2q(a-b)
  </annotation>
 </semantics>
</math>

</p>

<p>By squaring the queue update equation (Eq. (6)) and using the above inequality, it is not difficult to show that for all slots <em>t</em> and under any algorithm for choosing transmission and routing variables 

<math display="inline" id="Backpressure_routing:84">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpressure_routing:85">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{(c)}(t))
  </annotation>
 </semantics>
</math>

:<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>

<p>

<math display="block" id="Backpressure_routing:86">
 <semantics>
  <mrow>
   <mtext>(Eq. 7)</mtext>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mi>B</mi>
   <mo>+</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>c</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <msubsup>
    <mi>Q</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>E</mi>
   <mrow>
    <mo>[</mo>
    <msubsup>
     <mi>λ</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>a</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>n</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>b</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>n</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>𝑸</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>(Eq. 7)</mtext>
    <ci>italic-</ci>
    <csymbol cd="unknown">Δ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">B</csymbol>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 7)}\qquad\Delta(t)\leq B+\sum_{n=1}^{N}\sum_{c=1}^{N}Q_{n}^{(c)}(t)%
E\left[\lambda_{n}^{(c)}(t)+\sum_{a=1}^{N}\mu_{an}^{(c)}(t)-\sum_{b=1}^{N}\mu_%
{nb}^{(c)}(t)|\boldsymbol{Q}(t)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>B</em> is a finite constant that depends on the second moments of arrivals and the maximum possible second moments of transmission rates.</p>
<h3 id="minimizing-the-drift-bound-by-switching-the-sums">Minimizing the drift bound by switching the sums</h3>

<p>The backpressure algorithm is designed to observe 

<math display="inline" id="Backpressure_routing:87">
 <semantics>
  <mrow>
   <mi>𝑸</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑸</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Q}(t)
  </annotation>
 </semantics>
</math>

 and <em>S</em>(<em>t</em>) every slot <em>t</em> and choose 

<math display="inline" id="Backpressure_routing:88">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpressure_routing:89">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 to minimize the right-hand-side of the drift bound Eq. (7). Because <em>B</em> is a constant and 

<math display="inline" id="Backpressure_routing:90">
 <semantics>
  <msubsup>
   <mi>λ</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{n}^{(c)}
  </annotation>
 </semantics>
</math>

 are constants, this amounts to maximizing:</p>

<p>

<math display="block" id="Backpressure_routing:91">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>[</mo>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>c</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <msubsup>
     <mi>Q</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>b</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <msubsup>
      <mi>μ</mi>
      <mrow>
       <mi>n</mi>
       <mi>b</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>-</mo>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>a</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <msubsup>
      <mi>μ</mi>
      <mrow>
       <mi>a</mi>
       <mi>n</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>𝑸</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>n</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left[\sum_{n=1}^{N}\sum_{c=1}^{N}Q_{n}^{(c)}(t)\left[\sum_{b=1}^{N}\mu_{nb}^%
{(c)}(t)-\sum_{a=1}^{N}\mu_{an}^{(c)}(t)\right]|\boldsymbol{Q}(t)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>where the finite sums have been pushed through the expectations to illuminate the maximizing decision. By the principle of <em>opportunistically maximizing an expectation</em>, the above expectation is maximized by maximizing the function inside of it (given the observed 

<math display="inline" id="Backpressure_routing:92">
 <semantics>
  <mrow>
   <mi>𝑸</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑸</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Q}(t)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Backpressure_routing:93">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(t)
  </annotation>
 </semantics>
</math>

). Thus, one chooses 

<math display="inline" id="Backpressure_routing:94">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpressure_routing:95">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 subject to the constraints Eqs. (3)-(5) to maximize:</p>

<p>

<math display="block" id="Backpressure_routing:96">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>c</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>b</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>N</mi>
        </munderover>
        <mrow>
         <msubsup>
          <mi>μ</mi>
          <mrow>
           <mi>n</mi>
           <mi>b</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>c</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>a</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>N</mi>
        </munderover>
        <mrow>
         <msubsup>
          <mi>μ</mi>
          <mrow>
           <mi>a</mi>
           <mi>n</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>c</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>n</ci>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>b</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>N</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>μ</ci>
            <apply>
             <times></times>
             <ci>n</ci>
             <ci>b</ci>
            </apply>
           </apply>
           <ci>c</ci>
          </apply>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>a</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>N</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>μ</ci>
            <apply>
             <times></times>
             <ci>a</ci>
             <ci>n</ci>
            </apply>
           </apply>
           <ci>c</ci>
          </apply>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n=1}^{N}\sum_{c=1}^{N}Q_{n}^{(c)}(t)\left[\sum_{b=1}^{N}\mu_{nb}^{(c)}(t%
)-\sum_{a=1}^{N}\mu_{an}^{(c)}(t)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>It is not immediately obvious what decisions maximize the above. This can be illuminated by switching the sums. Indeed, the above expression is the same as below:</p>

<p>

<math display="block" id="Backpressure_routing:97">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>a</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>b</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>c</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <msubsup>
       <mi>μ</mi>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <msubsup>
          <mi>Q</mi>
          <mi>a</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>c</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <msubsup>
          <mi>Q</mi>
          <mi>b</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>c</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>c</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <apply>
          <times></times>
          <ci>a</ci>
          <ci>b</ci>
         </apply>
        </apply>
        <ci>c</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>Q</ci>
            <ci>a</ci>
           </apply>
           <ci>c</ci>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>Q</ci>
            <ci>b</ci>
           </apply>
           <ci>c</ci>
          </apply>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{a=1}^{N}\sum_{b=1}^{N}\sum_{c=1}^{N}\mu_{ab}^{(c)}(t)[Q_{a}^{(c)}(t)-Q_{%
b}^{(c)}(t)]
  </annotation>
 </semantics>
</math>

</p>

<p>The weight 

<math display="inline" id="Backpressure_routing:98">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>Q</mi>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <msubsup>
     <mi>Q</mi>
     <mi>b</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>a</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>b</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{a}^{(c)}(t)-Q_{b}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 is called the current <em>differential backlog</em> of commodity <em>c</em> between nodes <em>a</em> and <em>b</em>. The idea is to choose decision variables 

<math display="inline" id="Backpressure_routing:99">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 so as to maximize the above weighted sum, where weights are differential backlogs. Intuitively, this means allocating larger rates in directions of larger differential backlog.</p>

<p>Clearly one should choose 

<math display="inline" id="Backpressure_routing:100">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}^{(c)}(t)=0
  </annotation>
 </semantics>
</math>

 whenever 

<math display="inline" id="Backpressure_routing:101">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>a</ci>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>b</ci>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{a}^{(c)}(t)-Q_{b}^{(c)}(t)<0
  </annotation>
 </semantics>
</math>

. Further, given 

<math display="inline" id="Backpressure_routing:102">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}(t)
  </annotation>
 </semantics>
</math>

 for a particular link 

<math display="inline" id="Backpressure_routing:103">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

, it is not difficult to show that the optimal 

<math display="inline" id="Backpressure_routing:104">
 <semantics>
  <mrow>
   <msubsup>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}^{(c)}(t)
  </annotation>
 </semantics>
</math>

 selections, subject to Eqs. (3)-(5), are determined as follows: First find the commodity 

<math display="inline" id="Backpressure_routing:105">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>c</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mi>o</mi>
      <mi>p</mi>
      <mi>t</mi>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ab}^{opt}(t)\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

 that <em>maximizes the differential backlog</em> for link <em>(a,b)</em>. If the maximizing differential backlog is negative for link <em>(a,b)</em>, assign 

<math display="inline" id="Backpressure_routing:106">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}^{(c)}(t)=0
  </annotation>
 </semantics>
</math>

 for all commodities 

<math display="inline" id="Backpressure_routing:107">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

 on link (<em>a</em>,<em>b</em>). Else, allocate the full link rate 

<math display="inline" id="Backpressure_routing:108">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}(t)
  </annotation>
 </semantics>
</math>

 to the commodity 

<math display="inline" id="Backpressure_routing:109">
 <semantics>
  <mrow>
   <msubsup>
    <mi>c</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
     <mi>t</mi>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{ab}^{opt}(t)
  </annotation>
 </semantics>
</math>

, and zero rate to all other commodities on this link. With this choice, it follows that:</p>

<p>

<math display="block" id="Backpressure_routing:110">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>c</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msubsup>
      <mi>μ</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <msubsup>
         <mi>Q</mi>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msubsup>
         <mi>Q</mi>
         <mi>b</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <ci>a</ci>
          </apply>
          <ci>c</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <ci>b</ci>
          </apply>
          <ci>c</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{c=1}^{N}\mu_{ab}^{(c)}(t)[Q_{a}^{(c)}(t)-Q_{b}^{(c)}(t)]=\mu_{ab}(t)W_{%
ab}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Backpressure_routing:111">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ab}(t)
  </annotation>
 </semantics>
</math>

 is the differential backlog of the optimal commodity for link (<em>a</em>,<em>b</em>) on slot <em>t</em> (maxed with 0):</p>

<p>

<math display="block" id="Backpressure_routing:112">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <msubsup>
        <mi>Q</mi>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msubsup>
           <mi>c</mi>
           <mrow>
            <mi>a</mi>
            <mi>b</mi>
           </mrow>
           <mrow>
            <mi>o</mi>
            <mi>p</mi>
            <mi>t</mi>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msubsup>
        <mi>Q</mi>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msubsup>
           <mi>c</mi>
           <mrow>
            <mi>a</mi>
            <mi>b</mi>
           </mrow>
           <mrow>
            <mi>o</mi>
            <mi>p</mi>
            <mi>t</mi>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <max></max>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>a</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <apply>
            <times></times>
            <ci>a</ci>
            <ci>b</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>o</ci>
           <ci>p</ci>
           <ci>t</ci>
          </apply>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>b</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <apply>
            <times></times>
            <ci>a</ci>
            <ci>b</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>o</ci>
           <ci>p</ci>
           <ci>t</ci>
          </apply>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ab}(t)=\max[Q_{a}^{(c_{ab}^{opt}(t))}(t)-Q_{b}^{(c_{ab}^{opt}(t))}(t),0]
  </annotation>
 </semantics>
</math>

</p>

<p>It remains only to choose 

<math display="inline" id="Backpressure_routing:113">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))\in\Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

. This is done by solving the following:</p>

<p>

<math display="block" id="Backpressure_routing:114">
 <semantics>
  <mrow>
   <mi>Maximize</mi>
   <mo>:</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>a</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>b</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>μ</mi>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>W</mi>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>Maximize</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Maximize:}\sum_{a=1}^{N}\sum_{b=1}^{N}\mu_{ab}(t)W_{ab}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Backpressure_routing:115">
 <semantics>
  <mrow>
   <mi>Subjectto</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>μ</mi>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <msub>
     <mi mathvariant="normal">Γ</mi>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>Subjectto</ci>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Γ</ci>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Subjectto:}(\mu_{ab}(t))\in\Gamma_{S(t)}
  </annotation>
 </semantics>
</math>

</p>

<p>The above problem is identical to the max-weight problem in Eqs. (1)-(2). The <em>backpressure algorithm</em> uses the max-weight decisions for 

<math display="inline" id="Backpressure_routing:116">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

, and then chooses routing variables 

<math display="inline" id="Backpressure_routing:117">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 via the maximum differential backlog as described above.</p>

<p>A remarkable property of the backpressure algorithm is that it acts greedily every slot <em>t</em> based only on the observed topology state <em>S(t)</em> and queue backlogs 

<math display="inline" id="Backpressure_routing:118">
 <semantics>
  <mrow>
   <mi>𝑸</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑸</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Q}(t)
  </annotation>
 </semantics>
</math>

 for that slot. Thus, it does not require knowledge of the arrival rates 

<math display="inline" id="Backpressure_routing:119">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msubsup>
    <mi>λ</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{n}^{(c)})
  </annotation>
 </semantics>
</math>

 or the topology state probabilities 

<math display="inline" id="Backpressure_routing:120">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mi>S</mi>
   </msub>
   <mo>=</mo>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <ci>S</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">S</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{S}=Pr[S(t)=S]
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="performance-analysis">Performance analysis</h2>

<p>This section proves throughput optimality of the backpressure algorithm.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> For simplicity, the scenario where events are independent and identically distributed (i.i.d.) over slots is considered, although the same algorithm can be shown to work in non-i.i.d. scenarios (see below under <a href="#Non-i.i.d._operation_and_universal_scheduling" title="wikilink">Non-I.I.D. Operation and Universal Scheduling</a>).</p>
<h3 id="dynamic-arrivals">Dynamic arrivals</h3>

<p>Let 

<math display="inline" id="Backpressure_routing:121">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>A</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A_{n}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 be the matrix of exogenous arrivals on slot <em>t</em>. Assume this matrix is independent and identically distributed (i.i.d.) over slots with finite second moments and with means:</p>

<p>

<math display="block" id="Backpressure_routing:122">
 <semantics>
  <mrow>
   <msubsup>
    <mi>λ</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <msubsup>
       <mi>A</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <ci>n</ci>
        </apply>
        <ci>c</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{n}^{(c)}=E\left[A_{n}^{(c)}(t)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>It is assumed that 

<math display="inline" id="Backpressure_routing:123">
 <semantics>
  <mrow>
   <msubsup>
    <mi>λ</mi>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>c</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{c}^{(c)}=0
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Backpressure_routing:124">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\{1,\ldots,N\}
  </annotation>
 </semantics>
</math>

, as no data arrives that is destined for itself. Thus, the matrix of arrival rates 

<math display="inline" id="Backpressure_routing:125">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msubsup>
    <mi>λ</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{n}^{(c)})
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Backpressure_routing:126">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times N
  </annotation>
 </semantics>
</math>

 matrix of non-negative real numbers, with zeros on the diagonal.</p>
<h3 id="network-capacity-region">Network capacity region</h3>

<p>Assume the topology state <em>S</em>(<em>t</em>) is i.i.d. over slots with probabilities 

<math display="inline" id="Backpressure_routing:127">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mi>S</mi>
   </msub>
   <mo>=</mo>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <ci>S</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">S</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{S}=Pr[S(t)=S]
  </annotation>
 </semantics>
</math>

 (if <em>S(t)</em> takes values in an uncountably infinite set of vectors with real-valued entries, then 

<math display="inline" id="Backpressure_routing:128">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{S}
  </annotation>
 </semantics>
</math>

 is a probability distribution, not a probability mass function). A general algorithm for the network observes <em>S(t)</em> every slot <em>t</em> and chooses transmission rates 

<math display="inline" id="Backpressure_routing:129">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 and routing variables 

<math display="inline" id="Backpressure_routing:130">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 according to the constraints in Eqs. (3)-(5). The <em>network capacity region</em> 

<math display="inline" id="Backpressure_routing:131">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

 is the closure of the set of all arrival rate matrices 

<math display="inline" id="Backpressure_routing:132">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msubsup>
    <mi>λ</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{n}^{(c)})
  </annotation>
 </semantics>
</math>

 for which there exists an algorithm that stabilizes the network. Stability of all queues implies that the total input rate of traffic into the network is the same as the total rate of data delivered to its destination. It can be shown that for any arrival rate matrix 

<math display="inline" id="Backpressure_routing:133">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msubsup>
    <mi>λ</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{n}^{(c)})
  </annotation>
 </semantics>
</math>

 in the capacity region 

<math display="inline" id="Backpressure_routing:134">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

, there is a <em>stationary and randomized algorithm</em> that chooses decision variables 

<math display="inline" id="Backpressure_routing:135">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <times></times>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{*}(t))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpressure_routing:136">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>*</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <csymbol cd="latexml">absent</csymbol>
      <ci>c</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{*(c)}(t))
  </annotation>
 </semantics>
</math>

 every slot <em>t</em> based only on <em>S(t)</em> (and hence independently of queue backlogs) that yields the following for all 

<math display="inline" id="Backpressure_routing:137">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≠</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>n</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\neq c
  </annotation>
 </semantics>
</math>

:<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>

<math display="block" id="Backpressure_routing:138">
 <semantics>
  <mrow>
   <mrow>
    <mtext>(Eq. 8)</mtext>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <msubsup>
         <mi>λ</mi>
         <mi>n</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mo>+</mo>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mrow>
           <mi>a</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>N</mi>
         </munderover>
         <mrow>
          <msubsup>
           <mi>μ</mi>
           <mrow>
            <mi>a</mi>
            <mi>n</mi>
           </mrow>
           <mrow>
            <mi></mi>
            <mo>*</mo>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>c</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>b</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>N</mi>
        </munderover>
        <mrow>
         <msubsup>
          <mi>μ</mi>
          <mrow>
           <mi>n</mi>
           <mi>b</mi>
          </mrow>
          <mrow>
           <mi></mi>
           <mo>*</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>c</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <list>
     <mtext>(Eq. 8)</mtext>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>λ</ci>
           <ci>n</ci>
          </apply>
          <ci>c</ci>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>a</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>N</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>μ</ci>
             <apply>
              <times></times>
              <ci>a</ci>
              <ci>n</ci>
             </apply>
            </apply>
            <apply>
             <times></times>
             <csymbol cd="latexml">absent</csymbol>
             <ci>c</ci>
            </apply>
           </apply>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>b</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>N</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>μ</ci>
            <apply>
             <times></times>
             <ci>n</ci>
             <ci>b</ci>
            </apply>
           </apply>
           <apply>
            <times></times>
            <csymbol cd="latexml">absent</csymbol>
            <ci>c</ci>
           </apply>
          </apply>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 8)}\qquad E\left[\lambda_{n}^{(c)}+\sum_{a=1}^{N}\mu_{an}^{*(c)}(t)%
-\sum_{b=1}^{N}\mu_{nb}^{*(c)}(t)\right]\leq 0
  </annotation>
 </semantics>
</math>

</p>

<p>Such a stationary and randomized algorithm that bases decisions only on <em>S(t)</em> is called an <em>S-only algorithm</em>. It is often useful to assume that 

<math display="inline" id="Backpressure_routing:139">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msubsup>
    <mi>λ</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{n}^{(c)})
  </annotation>
 </semantics>
</math>

 is <em>interior</em> to 

<math display="inline" id="Backpressure_routing:140">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

, so that there is an 

<math display="inline" id="Backpressure_routing:141">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Backpressure_routing:142">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msubsup>
      <mi>λ</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo>+</mo>
     <mrow>
      <mi>ϵ</mi>
      <msubsup>
       <mn>1</mn>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ϵ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <ci>n</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <ci>normal-Λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{n}^{(c)}+\epsilon 1_{n}^{(c)})\in\Lambda
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Backpressure_routing:143">
 <semantics>
  <msubsup>
   <mn>1</mn>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{n}^{(c)}
  </annotation>
 </semantics>
</math>

 is 1 if 

<math display="inline" id="Backpressure_routing:144">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≠</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>n</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\neq c
  </annotation>
 </semantics>
</math>

, and zero else. In that case, there is an <em>S</em>-only algorithm that yields the following for all 

<math display="inline" id="Backpressure_routing:145">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≠</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>n</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\neq c
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Backpressure_routing:146">
 <semantics>
  <mrow>
   <mrow>
    <mtext>(Eq. 9)</mtext>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <msubsup>
         <mi>λ</mi>
         <mi>n</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mo>+</mo>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mrow>
           <mi>a</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>N</mi>
         </munderover>
         <mrow>
          <msubsup>
           <mi>μ</mi>
           <mrow>
            <mi>a</mi>
            <mi>n</mi>
           </mrow>
           <mrow>
            <mi></mi>
            <mo>*</mo>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>c</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>b</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>N</mi>
        </munderover>
        <mrow>
         <msubsup>
          <mi>μ</mi>
          <mrow>
           <mi>n</mi>
           <mi>b</mi>
          </mrow>
          <mrow>
           <mi></mi>
           <mo>*</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>c</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>-</mo>
    <mi>ϵ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <list>
     <mtext>(Eq. 9)</mtext>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>λ</ci>
           <ci>n</ci>
          </apply>
          <ci>c</ci>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>a</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>N</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>μ</ci>
             <apply>
              <times></times>
              <ci>a</ci>
              <ci>n</ci>
             </apply>
            </apply>
            <apply>
             <times></times>
             <csymbol cd="latexml">absent</csymbol>
             <ci>c</ci>
            </apply>
           </apply>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>b</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>N</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>μ</ci>
            <apply>
             <times></times>
             <ci>n</ci>
             <ci>b</ci>
            </apply>
           </apply>
           <apply>
            <times></times>
            <csymbol cd="latexml">absent</csymbol>
            <ci>c</ci>
           </apply>
          </apply>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </list>
    <apply>
     <minus></minus>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 9)}\qquad E\left[\lambda_{n}^{(c)}+\sum_{a=1}^{N}\mu_{an}^{*(c)}(t)%
-\sum_{b=1}^{N}\mu_{nb}^{*(c)}(t)\right]\leq-\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>As a technical requirement, it is assumed that the second moments of transmission rates 

<math display="inline" id="Backpressure_routing:147">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ab}(t)
  </annotation>
 </semantics>
</math>

 are finite under any algorithm for choosing these rates. This trivially holds if there is a finite maximum rate 

<math display="inline" id="Backpressure_routing:148">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{max}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="comparing-to-s-only-algorithms">Comparing to S-only algorithms</h3>

<p>Because the backpressure algorithm observes 

<math display="inline" id="Backpressure_routing:149">
 <semantics>
  <mrow>
   <mi>𝑸</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑸</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Q}(t)
  </annotation>
 </semantics>
</math>

 and <em>S(t)</em> every slot <em>t</em> and chooses decisions 

<math display="inline" id="Backpressure_routing:150">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}(t))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpressure_routing:151">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{(c)}(t))
  </annotation>
 </semantics>
</math>

 to minimize the right-hand-side of the drift bound Eq. (7), we have:</p>

<p>

<math display="block" id="Backpressure_routing:152">
 <semantics>
  <mrow>
   <mtext>(Eq. 10)</mtext>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mi>B</mi>
   <mo>+</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>c</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <msubsup>
    <mi>Q</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>E</mi>
   <mrow>
    <mo>[</mo>
    <msubsup>
     <mi>λ</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>a</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>n</mi>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>*</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>b</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>n</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>*</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>𝑸</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>(Eq. 10)</mtext>
    <ci>italic-</ci>
    <csymbol cd="unknown">Δ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">B</csymbol>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <csymbol cd="latexml">absent</csymbol>
       <ci>c</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <csymbol cd="latexml">absent</csymbol>
       <ci>c</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(Eq. 10)}\qquad\Delta(t)\leq B+\sum_{n=1}^{N}\sum_{c=1}^{N}Q_{n}^{(c)}(t%
)E\left[\lambda_{n}^{(c)}(t)+\sum_{a=1}^{N}\mu_{an}^{*(c)}(t)-\sum_{b=1}^{N}%
\mu_{nb}^{*(c)}(t)|\boldsymbol{Q}(t)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Backpressure_routing:153">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo>*</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <times></times>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{*}(t))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpressure_routing:154">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>*</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <csymbol cd="latexml">absent</csymbol>
      <ci>c</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu_{ab}^{*(c)}(t))
  </annotation>
 </semantics>
</math>

 are any alternative decisions that satisfy Eqs. (3)-(5), including randomized decisions.</p>

<p>Now assume 

<math display="inline" id="Backpressure_routing:155">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>λ</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>normal-Λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{n}^{(c)})\in\Lambda
  </annotation>
 </semantics>
</math>

. Then there exists an <em>S</em>-only algorithm that satisfies Eq. (8). Plugging this into the right-hand-side of Eq. (10) and noting that the conditional expectation given 

<math display="inline" id="Backpressure_routing:156">
 <semantics>
  <mrow>
   <mi>𝑸</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑸</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{Q}(t)
  </annotation>
 </semantics>
</math>

 under this <em>S</em>-only algorithm is the same as the unconditional expectation (because <em>S</em>(<em>t</em>) is i.i.d. over slots, and the <em>S</em>-only algorithm is independent of current queue backlogs) yields:</p>

<p>

<math display="block" id="Backpressure_routing:157">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mpadded width="+1.7pt">
    <mi>B</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)\leq B\,
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, the drift of a quadratic Lyapunov function is less than or equal to a constant <em>B</em> for all slots <em>t</em>. This fact, together with the assumption that queue arrivals have bounded second moments, imply the following for all network queues:<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> 

<math display="inline" id="Backpressure_routing:158">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>t</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>Q</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi>t</mi>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mtext>with probability 1</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>t</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>n</ci>
        </apply>
        <ci>c</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">0</cn>
     <mtext>with probability 1</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{t\rightarrow\infty}\frac{Q_{n}^{(c)}(t)}{t}=0\text{ with probability 1}
  </annotation>
 </semantics>
</math>

</p>

<p>For a stronger understanding of average queue size, one can assume the arrival rates 

<math display="inline" id="Backpressure_routing:159">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msubsup>
    <mi>λ</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{n}^{(c)})
  </annotation>
 </semantics>
</math>

 are interior to 

<math display="inline" id="Backpressure_routing:160">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

, so there is an 

<math display="inline" id="Backpressure_routing:161">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

 such that Eq. (9) holds for some alternative <em>S</em>-only algorithm. Plugging Eq. (9) into the right-hand-side of Eq. (10) yields:</p>

<p>

<math display="block" id="Backpressure_routing:162">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>B</mi>
    <mo>-</mo>
    <mrow>
     <mi>ϵ</mi>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </munderover>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>c</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>N</mi>
       </munderover>
       <mrow>
        <msubsup>
         <mi>Q</mi>
         <mi>n</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>B</ci>
     <apply>
      <times></times>
      <ci>ϵ</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>c</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Q</ci>
           <ci>n</ci>
          </apply>
          <ci>c</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)\leq B-\epsilon\sum_{n=1}^{N}\sum_{c=1}^{N}Q_{n}^{(c)}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>from which one immediately obtains (see<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a>):</p>

<p>

<math display="block" id="Backpressure_routing:163">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo movablelimits="false">lim sup</mo>
     <mrow>
      <mi>t</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </munder>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>t</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>τ</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>n</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>N</mi>
       </munderover>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>c</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>N</mi>
        </munderover>
        <mrow>
         <mi>E</mi>
         <mrow>
          <mo>[</mo>
          <mrow>
           <msubsup>
            <mi>Q</mi>
            <mi>n</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>c</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </msubsup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>τ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>]</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <mi>B</mi>
    <mi>ϵ</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">limit-supremum</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>t</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>τ</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>c</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>N</ci>
         </apply>
         <apply>
          <times></times>
          <ci>E</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>Q</ci>
              <ci>n</ci>
             </apply>
             <ci>c</ci>
            </apply>
            <ci>τ</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>B</ci>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \limsup_{t\rightarrow\infty}\frac{1}{t}\sum_{\tau=0}^{t-1}\sum_{n=1}^{N}\sum_{%
c=1}^{N}E\left[Q_{n}^{(c)}(\tau)\right]\leq\frac{B}{\epsilon}
  </annotation>
 </semantics>
</math>

</p>

<p>It is interesting to note that this average queue size bound increases as the distance 

<math display="inline" id="Backpressure_routing:164">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 to the boundary of the capacity region 

<math display="inline" id="Backpressure_routing:165">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

 goes to zero. This is the same qualitative performance as a single M/M/1 queue with arrival rate 

<math display="inline" id="Backpressure_routing:166">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 and service rate 

<math display="inline" id="Backpressure_routing:167">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

, where average queue size is proportional to 

<math display="inline" id="Backpressure_routing:168">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\epsilon
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Backpressure_routing:169">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>=</mo>
   <mrow>
    <mi>μ</mi>
    <mo>-</mo>
    <mi>λ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϵ</ci>
    <apply>
     <minus></minus>
     <ci>μ</ci>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon=\mu-\lambda
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="extensions-of-the-above-formulation">Extensions of the above formulation</h2>
<h3 id="non-i.i.d.-operation-and-universal-scheduling">Non-i.i.d. operation and universal scheduling</h3>

<p>The above analysis assumes i.i.d. properties for simplicity. However, the same backpressure algorithm can be shown to operate robustly in non-i.i.d. situations. When arrival processes and topology states are ergodic but not necessarily i.i.d., backpressure still stabilizes the system whenever 

<math display="inline" id="Backpressure_routing:170">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>λ</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>normal-Λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda_{n}^{(c)})\in\Lambda
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> More generally, using a <em>universal scheduling</em> approach, it has been shown to offer stability and optimality properties for arbitrary (possibly non-ergodic) sample paths.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>
<h3 id="backpressure-with-utility-optimization-and-penalty-minimization">Backpressure with utility optimization and penalty minimization</h3>

<p>Backpressure has been shown to work in conjunction with flow control via a <a href="Drift_plus_penalty" title="wikilink">drift-plus-penalty</a> technique.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a><a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> This technique greedily maximizes a sum of drift and a weighted penalty expression. The penalty is weighted by a parameter <em>V</em> that determines a performance tradeoff. This technique ensures throughput utility is within <em>O</em>(1/<em>V</em>) of optimality while average delay is <em>O</em>(<em>V</em>). Thus, utility can be pushed arbitrarily close to optimality, with a corresponding tradeoff in average delay. Similar properties can be shown for average power minimization<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> and for optimization of more general network attributes.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></p>

<p>Alternative algorithms for stabilizing queues while maximizing a network utility have be developed using fluid model analysis,<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> joint fluid analysis and Lagrange multiplier analysis ,<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> convex optimization ,<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> and stochastic gradients .<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> These approaches do not provide the <em>O</em>(1/<em>V</em>), <em>O</em>(<em>V</em>) utility-delay results.</p>
<h2 id="related-links">Related links</h2>
<ul>
<li><a href="Drift_plus_penalty" title="wikilink">Drift plus penalty</a></li>
<li><a href="Lyapunov_optimization" title="wikilink">Lyapunov optimization</a></li>
<li><a href="Ad_hoc_On-Demand_Distance_Vector_Routing" title="wikilink">AODV</a></li>
<li><a href="Geographic_routing" title="wikilink">Geographic routing</a></li>
<li><a href="ExOR_(wireless_network_protocol)" title="wikilink">ExOR</a></li>
<li>Diversity Backpressure Routing (DIVBAR)<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></li>
<li><a href="List_of_ad_hoc_routing_protocols" title="wikilink">List of ad hoc routing protocols</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="primary-sources">Primary Sources</h2>
<ul>
<li>L. Tassiulas and A. Ephremides, "Stability Properties of Constrained Queueing Systems and Scheduling Policies for Maximum Throughput in Multihop Radio Networks," <em>IEEE Transactions on Automatic Control</em>, vol. 37, no. 12, pp. 1936–1948, Dec. 1992.</li>
<li>L. Georgiadis, M. J. Neely, and L. Tassiulas, "Resource Allocation and Cross-Layer Control in Wireless Networks," <em>Foundations and Trends in Networking</em>, vol. 1, no. 1, pp. 1–149, 2006.</li>
<li>M. J. Neely. <em>Stochastic Network Optimization with Application to Communication and Queueing Systems</em>, Morgan &amp; Claypool, 2010.</li>
</ul>

<p>"</p>

<p><a href="Category:Networking_algorithms" title="wikilink">Category:Networking algorithms</a> <a href="Category:Queueing_theory" title="wikilink">Category:Queueing theory</a> <a href="Category:Routing_algorithms" title="wikilink">Category:Routing algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2">L. Tassiulas and A. Ephremides, "Stability Properties of Constrained Queueing Systems and Scheduling Policies for Maximum Throughput in Multihop Radio Networks, <em>IEEE Transactions on Automatic Control</em>, vol. 37, no. 12, pp. 1936-1948, Dec. 1992.<a href="#fnref2">↩</a></li>
<li id="fn3">L. Georgiadis, M. J. Neely, and L. Tassiulas, "Resource Allocation and Cross-Layer Control in Wireless Networks," <em>Foundations and Trends in Networking</em>, vol. 1, no. 1, pp. 1-149, 2006.<a href="#fnref3">↩</a></li>
<li id="fn4">L. Jiang and J. Walrand. <em>Scheduling and Congestion Control for Wireless and Processing Networks</em>, Morgan &amp; Claypool, 2010.<a href="#fnref4">↩</a></li>
<li id="fn5">A. Sridharan, S. Moeller, and B. Krishnamachari, "Making Distributed Rate Control using Lyapunov Drifts a Reality in Wireless Sensor Networks," 6th Intl. Symposium on Modeling and Optimization in Mobile, Ad Hoc, and Wireless Networks (WiOpt), April 2008.<a href="#fnref5">↩</a></li>
<li id="fn6">A. Warrier, S. Janakiraman, S. Ha, and I. Rhee, "DiffQ: Practical Differential Backlog Congestion Control for Wireless Networks," Proc. IEEE INFOCOM, Rio de Janeiro, Brazil, 2009.<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9">B. Awerbuch and T. Leighton, "A Simple Local-Control Approximation Algorithm for Multicommodity Flow," Proc. 34th IEEE Conf. on Foundations of Computer Science, Oct. 1993.<a href="#fnref9">↩</a></li>
<li id="fn10">M. J. Neely, E. Modiano, and C. E. Rohrs, "Dynamic Power Allocation and Routing for Time Varying Wireless Networks," ''IEEE Journal on Selected Areas in Communications, vol. 23, no. 1, pp. 89-103, January 2005.<a href="#fnref10">↩</a></li>
<li id="fn11">M. J. Neely. Dynamic Power Allocation and Routing for Satellite and Wireless Networks with Time Varying Channels. Ph.D. Dissertation, Massachusetts Institute of Technology, LIDS. November 2003.<a href="#fnref11">↩</a></li>
<li id="fn12">M. J. Neely, E. Modiano, and C. Li, "Fairness and Optimal Stochastic Control for Heterogeneous Networks," Proc. IEEE INFOCOM, March 2005.<a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14">A. Stolyar, "Maximizing Queueing Network Utility subject to Stability: Greedy Primal-Dual Algorithm," <em>Queueing Systems</em>, vol. 50, no. 4, pp. 401-457, 2005.<a href="#fnref14">↩</a></li>
<li id="fn15">M. J. Neely. <em>Stochastic Network Optimization with Application to Communication and Queueing Systems,</em> Morgan &amp; Claypool, 2010.<a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17">M. J. Neely and R. Urgaonkar, "Optimal Backpressure Routing in Wireless Networks with Multi-Receiver Diversity," Ad Hoc Networks (Elsevier), vol. 7, no. 5, pp. 862-881, July 2009.<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21">S. Moeller, A. Sridharan, B. Krishnamachari, and O. Gnawali, "Routing Without Routes: The Backpressure Collection Protocol," <em>Proc. 9th ACM/IEEE Intl. Conf. on Information Processing in Sensor Networks (IPSN)</em>, April 2010.<a href="#fnref21">↩</a></li>
<li id="fn22">L. Huang, S. Moeller, M. J. Neely, and B. Krishnamachari, "LIFO-Backpressure Achieves Near Optimal Utility-Delay Tradeoff," Proc. WiOpt, May 2011.<a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24">E. Modiano, D. Shah, and G. Zussman, "Maximizing throughput in wireless networks via gossiping," Proc. ACM SIGMETRICS, 2006.<a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35">M. J. Neely, "Queue Stability and Probability 1 Convergence via Lyapunov Optimization," Journal of Applied Mathematics, vol. 2012, <a class="uri" href="doi:10.1155/2012/831909">doi:10.1155/2012/831909</a>.<a href="#fnref35">↩</a></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39">M. J. Neely, "Universal Scheduling for Networks with Arbitrary Traffic, Channels, and Mobility," <em>Proc. IEEE Conf. on Decision and Control (CDC)</em>, Atlanta, GA, Dec. 2010.<a href="#fnref39">↩</a></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"></li>
<li id="fn43">M. J. Neely, "Energy Optimal Control for Time Varying Wireless Networks," <em>IEEE Transactions on Information Theory</em>, vol. 52, no. 7, pp. 2915-2934, July 2006<a href="#fnref43">↩</a></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46">A. Eryilmaz and R. Srikant, "Fair Resource Allocation in Wireless Networks using Queue-Length-Based Scheduling and Congestion Control," Proc. IEEE INFOCOM, March 2005.<a href="#fnref46">↩</a></li>
<li id="fn47">X. Lin and N. B. Shroff, "Joint Rate Control and Scheduling in Multihop Wireless Networks," Proc. of 43rd IEEE Conf. on Decision and Control, Paradise Island, Bahamas, Dec. 2004.<a href="#fnref47">↩</a></li>
<li id="fn48">J. W. Lee, R. R. Mazumdar, and N. B. Shroff, "Opportunistic Power Scheduling for Dynamic Multiserver Wireless Systems," <em>IEEE Transactions on Wireless Communications</em>, vol. 5, no.6, pp. 1506–1515, June 2006.<a href="#fnref48">↩</a></li>
<li id="fn49"></li>
</ol>
</section>
</body>
</html>
