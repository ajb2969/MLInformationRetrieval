<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="210">Definite clause grammar</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Definite clause grammar</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>A <strong>definite clause grammar</strong> (<strong>DCG</strong>) is a way of expressing grammar, either for <a href="Natural_language" title="wikilink">natural</a> or <a href="Formal_language" title="wikilink">formal</a> languages, in a logic programming language such as <a class="uri" href="Prolog" title="wikilink">Prolog</a>. It is closely related to the concept of <a href="attribute_grammar" title="wikilink">attribute grammars</a> / <a href="affix_grammar" title="wikilink">affix grammars</a> from which Prolog was originally developed. DCGs are usually associated with Prolog, but similar languages such as <a href="Mercury_(programming_language)" title="wikilink">Mercury</a> also include DCGs. They are called definite clause grammars because they represent a grammar as a set of <a href="definite_clause" title="wikilink">definite clauses</a> in <a href="first-order_logic" title="wikilink">first-order logic</a>.</p>

<p>The term DCG refers to the specific type of expression in Prolog and other similar languages; not all ways of expressing grammars using definite clauses are considered DCGs. However, all of the capabilities or properties of DCGs will be the same for any grammar that is represented with definite clauses in essentially the same way as in Prolog.</p>

<p>The definite clauses of a DCG can be considered a set of axioms where the validity of a sentence, and the fact that it has a certain parse tree can be considered theorems that follow from these axioms.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> This has the advantage of making it so that recognition and parsing of expressions in a language becomes a general matter of proving statements, such as statements in a logic programming language.</p>
<h2 id="history">History</h2>

<p>The history of DCGs is closely tied to the history of Prolog, and the history of Prolog revolves around several researchers in both Marseilles, France, and Edinburgh, Scotland. According to <a href="Robert_Kowalski" title="wikilink">Robert Kowalski</a>, an early developer of Prolog, the first Prolog system was developed in 1972 by <a href="Alain_Colmerauer" title="wikilink">Alain Colmerauer</a> and Phillipe Roussel.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The first program written in the language was a large natural-language processing system. Fernando Pereira and <a href="David_H._D._Warren" title="wikilink">David Warren</a> at the University of Edinburgh were also involved in the early development of Prolog.</p>

<p>Colmerauer had previously worked on a language processing system called Q-systems that was used to translate between English and French.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In 1978, Colmerauer wrote a paper about a way of representing grammars called metamorphosis grammars which were part of the early version of Prolog called Marseille Prolog. In this paper, he gave a formal description of metamorphosis grammars and some examples of programs that use them.</p>

<p>Fernando Pereira and David Warren, two other early architects of Prolog, coined the term "definite clause grammar" and created the notation for DCGs that is used in Prolog today. They gave credit for the idea to Colmeraur and Kowalski, and they note that DCGs are a special case of Colmeraur's metamorphosis grammars. They introduced the idea in an article called "Definite Clause Grammars for Language Analysis", where they describe DCGs as a "formalism ... in which grammars are expressed clauses of first-order predicate logic" that "constitute effective programs of the programming language Prolog".<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Pereira, Warren, and other pioneers of Prolog later wrote about several other aspects of DCGs. Pereira and Warren wrote an article called "Parsing as Deduction", describing things such as how the Earley Deduction proof procedure is used for parsing.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Pereira also collaborated with Stuart Shieber on a book called "Prolog and Natural Language Analysis", that was intended as a general introduction to computational linguistics using logic programming.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="example">Example</h2>

<p>A basic example of DCGs helps to illustrate what they are and what they look like.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"> sentence <span class="kw">--&gt;</span> noun_phrase<span class="kw">,</span> verb_phrase<span class="kw">.</span>
 noun_phrase <span class="kw">--&gt;</span> det<span class="kw">,</span> noun<span class="kw">.</span>
 verb_phrase <span class="kw">--&gt;</span> verb<span class="kw">,</span> noun_phrase<span class="kw">.</span>
 det <span class="kw">--&gt;</span> [the]<span class="kw">.</span>
 det <span class="kw">--&gt;</span> [a]<span class="kw">.</span>
 noun <span class="kw">--&gt;</span> [cat]<span class="kw">.</span>
 noun <span class="kw">--&gt;</span> [bat]<span class="kw">.</span>
 verb <span class="kw">--&gt;</span> [eats]<span class="kw">.</span></code></pre></div>

<p>This generates sentences such as "the cat eats the bat", "a bat eats the cat". One can generate all of the valid expressions in the language generated by this grammar at a Prolog interpreter by typing <code>sentence(X,[])</code>. Similarly, one can test whether a sentence is valid in the language by typing something like <code>sentence([the,bat,eats,the,bat],[])</code>.</p>
<h2 id="translation-into-definite-clauses">Translation into definite clauses</h2>

<p>DCG notation is just <a href="syntactic_sugar" title="wikilink">syntactic sugar</a> for normal definite clauses in Prolog. For example, the previous example could be translated into the following:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"> sentence(<span class="dt">S1</span><span class="kw">,</span><span class="dt">S3</span>) <span class="kw">:-</span> noun_phrase(<span class="dt">S1</span><span class="kw">,</span><span class="dt">S2</span>)<span class="kw">,</span> verb_phrase(<span class="dt">S2</span><span class="kw">,</span><span class="dt">S3</span>)<span class="kw">.</span>
 noun_phrase(<span class="dt">S1</span><span class="kw">,</span><span class="dt">S3</span>) <span class="kw">:-</span> det(<span class="dt">S1</span><span class="kw">,</span><span class="dt">S2</span>)<span class="kw">,</span> noun(<span class="dt">S2</span><span class="kw">,</span><span class="dt">S3</span>)<span class="kw">.</span>
 verb_phrase(<span class="dt">S1</span><span class="kw">,</span><span class="dt">S3</span>) <span class="kw">:-</span> verb(<span class="dt">S1</span><span class="kw">,</span><span class="dt">S2</span>)<span class="kw">,</span> noun_phrase(<span class="dt">S2</span><span class="kw">,</span><span class="dt">S3</span>)<span class="kw">.</span>
 det([the<span class="fu">|</span><span class="dt">X</span>]<span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span>
 det([a<span class="fu">|</span><span class="dt">X</span>]<span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span>
 noun([cat<span class="fu">|</span><span class="dt">X</span>]<span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span>
 noun([bat<span class="fu">|</span><span class="dt">X</span>]<span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span>
 verb([eats<span class="fu">|</span><span class="dt">X</span>]<span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span></code></pre></div>
<h3 id="difference-lists">Difference lists</h3>

<p>The arguments to each functor, such as <code>(S1,S3)</code> and <code>(S1,S2)</code> are <a href="Difference_list" title="wikilink">difference lists</a>; difference lists are a way of representing a list as the difference of two lists. Using Prolog's notation for lists, a list <code>L</code> can be represented with the pair <code>([L|X],X)</code>.</p>

<p>Difference lists are used to represent lists with DCGs for reasons of efficiency. It is much more efficient to concatenate difference lists, in the circumstances that they can be used, because the concatenation of <code>(S1,S2)</code> and <code>(S2,S3)</code> is just <code>(S1,S3)</code>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="non-context-free-grammars">Non-context-free grammars</h2>

<p>In <a href="Prolog#Rules_and_facts" title="wikilink">pure Prolog</a>, normal DCG rules with no extra arguments on the functors, such as the previous example, can only express <a href="context-free_grammar" title="wikilink">context-free grammars</a>; there is only one argument on the left side of the <a href="Production_(computer_science)" title="wikilink">production</a>. However, <a href="context-sensitive_grammar" title="wikilink">context-sensitive grammars</a> can also be expressed with DCGs, by providing extra arguments, such as in the following example:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"> s <span class="kw">--&gt;</span> a(<span class="dt">N</span>)<span class="kw">,</span> b(<span class="dt">N</span>)<span class="kw">,</span> c(<span class="dt">N</span>)<span class="kw">.</span>
 a(<span class="dv">0</span>) <span class="kw">--&gt;</span> []<span class="kw">.</span>
 a(<span class="dt">M</span>) <span class="kw">--&gt;</span> [a]<span class="kw">,</span> a(<span class="dt">N</span>)<span class="kw">,</span> <span class="kw">{</span><span class="dt">M</span> <span class="dt">is</span> <span class="dt">N</span> <span class="dt">+</span> <span class="dv">1</span><span class="kw">}.</span>
 b(<span class="dv">0</span>) <span class="kw">--&gt;</span> []<span class="kw">.</span>
 b(<span class="dt">M</span>) <span class="kw">--&gt;</span> [b]<span class="kw">,</span> b(<span class="dt">N</span>)<span class="kw">,</span> <span class="kw">{</span><span class="dt">M</span> <span class="dt">is</span> <span class="dt">N</span> <span class="dt">+</span> <span class="dv">1</span><span class="kw">}.</span>
 c(<span class="dv">0</span>) <span class="kw">--&gt;</span> []<span class="kw">.</span>
 c(<span class="dt">M</span>) <span class="kw">--&gt;</span> [c]<span class="kw">,</span> c(<span class="dt">N</span>)<span class="kw">,</span> <span class="kw">{</span><span class="dt">M</span> <span class="dt">is</span> <span class="dt">N</span> <span class="dt">+</span> <span class="dv">1</span><span class="kw">}.</span></code></pre></div>

<p>This set of DCG rules describes the grammar which generates the language that consists of strings of the form 

<math display="inline" id="Definite_clause_grammar:0">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mi>n</mi>
   </msup>
   <msup>
    <mi>b</mi>
    <mi>n</mi>
   </msup>
   <msup>
    <mi>c</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{n}b^{n}c^{n}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"> s <span class="kw">--&gt;</span> symbols(<span class="dt">Sem</span><span class="kw">,</span>a)<span class="kw">,</span> symbols(<span class="dt">Sem</span><span class="kw">,</span>b)<span class="kw">,</span> symbols(<span class="dt">Sem</span><span class="kw">,</span>c)<span class="kw">.</span>
 symbols(end<span class="kw">,</span><span class="dt">_</span>) <span class="kw">--&gt;</span> []<span class="kw">.</span>
 symbols(s(<span class="dt">Sem</span>)<span class="kw">,</span><span class="dt">S</span>) <span class="kw">--&gt;</span> [<span class="dt">S</span>]<span class="kw">,</span> symbols(<span class="dt">Sem</span><span class="kw">,</span><span class="dt">S</span>)<span class="kw">.</span></code></pre></div>

<p>This set of DCG rules describes the grammar which generates the language that consists of strings of the form 

<math display="inline" id="Definite_clause_grammar:1">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mi>n</mi>
   </msup>
   <msup>
    <mi>b</mi>
    <mi>n</mi>
   </msup>
   <msup>
    <mi>c</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{n}b^{n}c^{n}
  </annotation>
 </semantics>
</math>

, by structurally representing 

<math display="inline" id="Definite_clause_grammar:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 </p>
<h2 id="representing-features">Representing features</h2>

<p>Various linguistic <a href="Feature_(linguistics)" title="wikilink">features</a> can also be represented fairly concisely with DCGs by providing extra arguments to the functors.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> For example, consider the following set of DCG rules:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"> sentence <span class="kw">--&gt;</span> pronoun(subject)<span class="kw">,</span> verb_phrase<span class="kw">.</span>
 verb_phrase <span class="kw">--&gt;</span> verb<span class="kw">,</span> pronoun(object)<span class="kw">.</span>
 pronoun(subject) <span class="kw">--&gt;</span> [he]<span class="kw">.</span>
 pronoun(subject) <span class="kw">--&gt;</span> [she]<span class="kw">.</span>
 pronoun(object) <span class="kw">--&gt;</span> [him]<span class="kw">.</span>
 pronoun(object) <span class="kw">--&gt;</span> [her]<span class="kw">.</span>
 verb <span class="kw">--&gt;</span> [likes]<span class="kw">.</span></code></pre></div>

<p>This grammar allows sentences like "he likes her" and "he likes him", but <em>not</em> "her likes he" and "him likes him".</p>
<h2 id="parsing-with-dcgs">Parsing with DCGs</h2>
<figure><b>(Figure)</b>
<figcaption>An example parse tree for this grammar.</figcaption>
</figure>

<p>The main practical use of a DCG is to parse sentences of the given grammar, i.e. to construct a parse tree. This can be done by providing "extra arguments" to the functors in the DCG, like in the following rules:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"> sentence(s(<span class="dt">NP</span><span class="kw">,</span><span class="dt">VP</span>)) <span class="kw">--&gt;</span> noun_phrase(<span class="dt">NP</span>)<span class="kw">,</span> verb_phrase(<span class="dt">VP</span>)<span class="kw">.</span>
 noun_phrase(np(<span class="dt">D</span><span class="kw">,</span><span class="dt">N</span>)) <span class="kw">--&gt;</span> det(<span class="dt">D</span>)<span class="kw">,</span> noun(<span class="dt">N</span>)<span class="kw">.</span>
 verb_phrase(vp(<span class="dt">V</span><span class="kw">,</span><span class="dt">NP</span>)) <span class="kw">--&gt;</span> verb(<span class="dt">V</span>)<span class="kw">,</span> noun_phrase(<span class="dt">NP</span>)<span class="kw">.</span>
 det(d(the)) <span class="kw">--&gt;</span> [the]<span class="kw">.</span>
 det(d(a)) <span class="kw">--&gt;</span> [a]<span class="kw">.</span>
 noun(n(bat)) <span class="kw">--&gt;</span> [bat]<span class="kw">.</span>
 noun(n(cat)) <span class="kw">--&gt;</span> [cat]<span class="kw">.</span>
 verb(v(eats)) <span class="kw">--&gt;</span> [eats]<span class="kw">.</span></code></pre></div>

<p>One can now query the interpreter to yield a parse tree of any given sentence:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"> | <span class="fu">?-</span> sentence(<span class="dt">Parse_tree</span><span class="kw">,</span> [the,bat,eats,a,cat]<span class="kw">,</span> [])<span class="kw">.</span>
 <span class="dt">Parse_tree</span> <span class="kw">=</span> s(np(d(the)<span class="kw">,</span>n(bat))<span class="kw">,</span>vp(v(eats)<span class="kw">,</span>np(d(a)<span class="kw">,</span>n(cat)))) ? <span class="kw">;</span></code></pre></div>
<h2 id="other-uses">Other uses</h2>

<p>DCGs can serve as a convenient syntactic sugar to hide certain parameters in code in other places besides parsing applications. In the declarativly pure programming language <a href="Mercury_(programming_language)" title="wikilink">Mercury</a> I/O must be represented by a pair of <code>io.state</code> arguments. DCG notation can be used to make using I/O more covenient,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> although state variable notation is usually preferred.</p>

<p>DCG notation is also used for parsing and similar things in Mercury as it is in Prolog.</p>
<h2 id="extensions">Extensions</h2>

<p>Since DCGs were introduced by Pereira and Warren, several extensions have been proposed. Pereira himself proposed an extension called extraposition grammars (XGs).<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> This formalism was intended in part to make it easier to express certain grammatical phenomena, such as left-extraposition. Pereira states, "The difference between XG rules and DCG rules is then that the left-hand side of an XG rule may contain several symbols." This makes it easier to express rules for context-sensitive grammars.</p>

<p>Another, more recent, extension was made by researchers at NEC Corporation called Multi-Modal Definite Clause Grammars (MM-DCGs) in 1995. Their extensions were intended to allow the recognizing and parsing expressions that include non-textual parts such as pictures.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>Another extension, called definite clause translation grammars (DCTGs) was described by in 1984.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> DCTG notation looks very similar to DCG notation; the major difference is that one uses <code>::=</code> instead of <code>--&gt;</code> in the rules. It was devised to handle grammatical attributes conveniently.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> The translation of DCTGs into normal Prolog clauses is like that of DCGs, but 3 arguments are added instead of 2.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Natural_language_processing" title="wikilink">Natural language processing</a></li>
<li><a href="Phrase_structure_grammar" title="wikilink">Phrase structure grammar</a></li>
<li><a href="Chomsky_hierarchy" title="wikilink">Chomsky hierarchy</a></li>
<li><a href="Context-free_grammar" title="wikilink">Context-free grammar</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://cs.union.edu/~striegnk/courses/nlp-with-prolog/html/node31.html">NLP with Prolog</a></li>
<li><a href="http://www.coli.uni-saarland.de/projects/milca/courses/coal/xhtml/CHA_CFG.xhtml">Context-free grammars and DCGs</a></li>
<li><a href="http://www.cotilliongroup.com/arts/DCG.html">Definite Clause Grammars: Not Just for Parsing Anymore</a></li>
<li><a href="http://cgi.di.uoa.gr/~takis/pereira-warren.pdf">Definite Clause Grammars for Language Analysis</a></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
</ol>
</section>
</body>

