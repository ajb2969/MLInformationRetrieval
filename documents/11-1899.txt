   Mogensen–Scott encoding      Mogensen–Scott encoding   In computer science , Scott encoding is a way to represent (recursive) data types in the lambda calculus . Church encoding performs a similar function. The data and operators form a mathematical structure which is embedded in the lambda calculus.  Whereas Church encoding starts with representations of the basic data types, and builds up from it, Scott encoding starts from the simplest method to compose algebraic data types .  Mogensen–Scott encoding extends and slightly modifies Scott encoding by applying the encoding to Metaprogramming . This encoding allows the representation of lambda calculus terms, as data, to be operated on by a meta program.  History  Scott encoding appears first in a set of unpublished lecture notes by Dana Scott . Torben Mogensen later extended Scott encoding for the encoding of Lambda terms as data. 1  Discussion  Lambda calculus allows data to be stored as parameters to a function that does not yet have all the parameters required for application. For example,       (   (  λ   x  1   …   x  n   .  λ  c  .   c    x  1   …   x  n   )    v  1   …   v  n   )   f     fragments   fragments  normal-(   fragments  normal-(  λ   subscript  x  1   normal-…   subscript  x  n   normal-.  λ  c  normal-.  c   subscript  x  1   normal-…   subscript  x  n   normal-)    subscript  v  1   normal-…   subscript  v  n   normal-)   f    ((\lambda x_{1}\ldots x_{n}.\lambda c.c\ x_{1}\ldots x_{n})\ v_{1}\ldots v_{n}%
 )\ f     May be thought of as a record or struct where the fields     x  1   …   x  n        subscript  x  1   normal-…   subscript  x  n     x_{1}\ldots x_{n}   have been initialized with the values     v  1   …   v  n        subscript  v  1   normal-…   subscript  v  n     v_{1}\ldots v_{n}   . These values may then be accessed by applying the term to a function f . This reduces to,       f    v  1   …   v  n       f   subscript  v  1   normal-…   subscript  v  n     f\ v_{1}\ldots v_{n}     c may represent a constructor for an algebraic data type in functional languages such as Haskell . Now suppose there N constructors, each with    A  i     subscript  A  i    A_{i}   arguments;      Constructor   Given arguments   Result           (   (  λ   x  1   …   x   A  1    .  λ   c  1   …   c  N   .    c  1     x  1   …   x   A  1    )    v  1   …   v   A  1    )     fragments  normal-(   fragments  normal-(  λ   subscript  x  1   normal-…   subscript  x   subscript  A  1    normal-.  λ   subscript  c  1   normal-…   subscript  c  N   normal-.   subscript  c  1    subscript  x  1   normal-…   subscript  x   subscript  A  1    normal-)    subscript  v  1   normal-…   subscript  v   subscript  A  1    normal-)    ((\lambda x_{1}\ldots x_{A_{1}}.\lambda c_{1}\ldots c_{N}.c_{1}\ x_{1}\ldots x%
 _{A_{1}})\ v_{1}\ldots v_{A_{1}})           f  1   …   f  N        subscript  f  1   normal-…   subscript  f  N     f_{1}\ldots f_{N}            f  1     v  1   …   v   A  1         subscript  f  1    subscript  v  1   normal-…   subscript  v   subscript  A  1      f_{1}\ v_{1}\ldots v_{A_{1}}            (   (  λ   x  1   …   x   A  2    .  λ   c  1   …   c  N   .    c  2     x  1   …   x   A  2    )    v  1   …   v   A  2    )     fragments  normal-(   fragments  normal-(  λ   subscript  x  1   normal-…   subscript  x   subscript  A  2    normal-.  λ   subscript  c  1   normal-…   subscript  c  N   normal-.   subscript  c  2    subscript  x  1   normal-…   subscript  x   subscript  A  2    normal-)    subscript  v  1   normal-…   subscript  v   subscript  A  2    normal-)    ((\lambda x_{1}\ldots x_{A_{2}}.\lambda c_{1}\ldots c_{N}.c_{2}\ x_{1}\ldots x%
 _{A_{2}})\ v_{1}\ldots v_{A_{2}})           f  1   …   f  N        subscript  f  1   normal-…   subscript  f  N     f_{1}\ldots f_{N}            f  2     v  1   …   v   A  2         subscript  f  2    subscript  v  1   normal-…   subscript  v   subscript  A  2      f_{2}\ v_{1}\ldots v_{A_{2}}        ...         (   (  λ   x  1   …   x   A  N    .  λ   c  1   …   c  N   .    c  N     x  1   …   x   A  N    )    v  1   …   v   A  N    )     fragments  normal-(   fragments  normal-(  λ   subscript  x  1   normal-…   subscript  x   subscript  A  N    normal-.  λ   subscript  c  1   normal-…   subscript  c  N   normal-.   subscript  c  N    subscript  x  1   normal-…   subscript  x   subscript  A  N    normal-)    subscript  v  1   normal-…   subscript  v   subscript  A  N    normal-)    ((\lambda x_{1}\ldots x_{A_{N}}.\lambda c_{1}\ldots c_{N}.c_{N}\ x_{1}\ldots x%
 _{A_{N}})\ v_{1}\ldots v_{A_{N}})           f  1   …   f  N        subscript  f  1   normal-…   subscript  f  N     f_{1}\ldots f_{N}            f  N     v  1   …   v   A  1         subscript  f  N    subscript  v  1   normal-…   subscript  v   subscript  A  1      f_{N}\ v_{1}\ldots v_{A_{1}}        Each constructor selects a different function from the function parameters     f  1   …   f  N        subscript  f  1   normal-…   subscript  f  N     f_{1}\ldots f_{N}   . This provides branching in the process flow, based on the constructor. Each constructor may have a different arity (number of parameters). If the constructors have no parameters then the set of constructors acts like an enum ; a type with a fixed number of values. If the constructors have parameters, recursive data structures may be constructed.  Definition  Let D be a datatype with N  constructors ,     {   c  i   }    i  =  1   N     superscript   subscript    subscript  c  i      i  1    N    \{c_{i}\}_{i=1}^{N}   , such that constructor    c  i     subscript  c  i    c_{i}   has arity     A  i     subscript  A  i    A_{i}   .  Scott encoding  The Scott encoding of constructor    c  i     subscript  c  i    c_{i}   of the data type D is       λ   x  1   …   x   A  i     .   λ   c  1   …   c  N    .     c  i     x  1   …   x   A  i        formulae-sequence    λ   subscript  x  1   normal-…   subscript  x   subscript  A  i       λ   subscript  c  1   normal-…   subscript  c  N       subscript  c  i    subscript  x  1   normal-…   subscript  x   subscript  A  i       \lambda x_{1}\ldots x_{A_{i}}.\lambda c_{1}\ldots c_{N}.c_{i}\ x_{1}\ldots x_{%
 A_{i}}     Mogensen–Scott encoding  Mogensen extends Scott encoding to encode any untyped lambda term as data. This allows a lambda term to be represented as data, within a Lambda calculus meta program . The meta function mse converts a lambda term into the corresponding data representation of the lambda term;         mse   [  x  ]      =       λ  a   ,  b  ,  c   .    a   x         mse   [    M   N   ]      =       λ  a   ,  b  ,  c   .    b    mse   [  M  ]     mse   [  N  ]           mse   [  λ  x  .  M  ]      =     λ  a  ,  b  ,  c  .   c    (  λ  x  .  mse   [  M  ]   )           mse  x     formulae-sequence     λ  a   b  c     a  x       mse    M  N      formulae-sequence     λ  a   b  c     b   mse  M    mse  N        fragments  mse   fragments  normal-[  λ  x  normal-.  M  normal-]      fragments  λ  a  normal-,  b  normal-,  c  normal-.  c   fragments  normal-(  λ  x  normal-.  mse   fragments  normal-[  M  normal-]   normal-)       \begin{array}[]{rcl}\operatorname{mse}[x]&=&\lambda a,b,c.a\ x\\
 \ \operatorname{mse}[M\ N]&=&\lambda a,b,c.b\ \operatorname{mse}[M]\ %
 \operatorname{mse}[N]\\
 \ \operatorname{mse}[\lambda x.M]&=&\lambda a,b,c.c\ (\lambda x.\operatorname{%
 mse}[M])\\
 \end{array}     The "lambda term" is represented as a tagged union with three cases:   Constructor a - a variable ( arity 1, not recursive)  Constructor b - function application (arity 2, recursive in both arguments),  Constructor c - lambda-abstraction (arity 1, recursive).   For example,      mse   [  λ  x  .   f    (   x   x  )   ]      fragments  mse   fragments  normal-[  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-]     \operatorname{mse}[\lambda x.f\ (x\ x)]         λ  a  ,  b  ,  c  .   c    (  λ  x  .  mse   [   f    (   x   x  )   ]   )      fragments  λ  a  normal-,  b  normal-,  c  normal-.  c   fragments  normal-(  λ  x  normal-.  mse   fragments  normal-[  f   fragments  normal-(  x  x  normal-)   normal-]   normal-)     \lambda a,b,c.c\ (\lambda x.\operatorname{mse}[f\ (x\ x)])         λ  a  ,  b  ,  c  .   c    (  λ  x  .  λ  a  ,  b  ,  c  .   b   mse   [  f  ]   mse   [   x   x  ]   )      fragments  λ  a  normal-,  b  normal-,  c  normal-.  c   fragments  normal-(  λ  x  normal-.  λ  a  normal-,  b  normal-,  c  normal-.  b  mse   fragments  normal-[  f  normal-]   mse   fragments  normal-[  x  x  normal-]   normal-)     \lambda a,b,c.c\ (\lambda x.\lambda a,b,c.b\ \operatorname{mse}[f]\ %
 \operatorname{mse}[x\ x])         λ  a  ,  b  ,  c  .   c    (  λ  x  .  λ  a  ,  b  ,  c  .   b    (  λ  a  ,  b  ,  c  .   a   f  )   mse   [   x   x  ]   )      fragments  λ  a  normal-,  b  normal-,  c  normal-.  c   fragments  normal-(  λ  x  normal-.  λ  a  normal-,  b  normal-,  c  normal-.  b   fragments  normal-(  λ  a  normal-,  b  normal-,  c  normal-.  a  f  normal-)   mse   fragments  normal-[  x  x  normal-]   normal-)     \lambda a,b,c.c\ (\lambda x.\lambda a,b,c.b\ (\lambda a,b,c.a\ f)\ %
 \operatorname{mse}[x\ x])         λ  a  ,  b  ,  c  .   c    (  λ  x  .  λ  a  ,  b  ,  c  .   b    (  λ  a  ,  b  ,  c  .   a   f  )    (  λ  a  ,  b  ,  c  .   b   mse   [  x  ]   mse   [  x  ]   )   )      fragments  λ  a  normal-,  b  normal-,  c  normal-.  c   fragments  normal-(  λ  x  normal-.  λ  a  normal-,  b  normal-,  c  normal-.  b   fragments  normal-(  λ  a  normal-,  b  normal-,  c  normal-.  a  f  normal-)    fragments  normal-(  λ  a  normal-,  b  normal-,  c  normal-.  b  mse   fragments  normal-[  x  normal-]   mse   fragments  normal-[  x  normal-]   normal-)   normal-)     \lambda a,b,c.c\ (\lambda x.\lambda a,b,c.b\ (\lambda a,b,c.a\ f)\ (\lambda a,%
 b,c.b\ \operatorname{mse}[x]\ \operatorname{mse}[x]))         λ  a  ,  b  ,  c  .   c    (  λ  x  .  λ  a  ,  b  ,  c  .   b    (  λ  a  ,  b  ,  c  .   a   f  )    (  λ  a  ,  b  ,  c  .   b    (  λ  a  ,  b  ,  c  .   a   x  )    (  λ  a  ,  b  ,  c  .   a   x  )   )   )      fragments  λ  a  normal-,  b  normal-,  c  normal-.  c   fragments  normal-(  λ  x  normal-.  λ  a  normal-,  b  normal-,  c  normal-.  b   fragments  normal-(  λ  a  normal-,  b  normal-,  c  normal-.  a  f  normal-)    fragments  normal-(  λ  a  normal-,  b  normal-,  c  normal-.  b   fragments  normal-(  λ  a  normal-,  b  normal-,  c  normal-.  a  x  normal-)    fragments  normal-(  λ  a  normal-,  b  normal-,  c  normal-.  a  x  normal-)   normal-)   normal-)     \lambda a,b,c.c\ (\lambda x.\lambda a,b,c.b\ (\lambda a,b,c.a\ f)\ (\lambda a,%
 b,c.b\ (\lambda a,b,c.a\ x)\ (\lambda a,b,c.a\ x)))     Comparison to the Church encoding  The Scott encoding coincides with the Church encoding for booleans. Church encoding of pairs may be generalized to arbitrary data types by encoding    c  i     subscript  c  i    c_{i}   of D above as       λ   x  1   …   x   A  i     .   λ   c  1   …   c  N    .    c  i    (    x  1    c  1   …   c  N    )   …   (    x   A  i     c  1   …   c  N    )       formulae-sequence    λ   subscript  x  1   normal-…   subscript  x   subscript  A  i       λ   subscript  c  1   normal-…   subscript  c  N       subscript  c  i      subscript  x  1    subscript  c  1   normal-…   subscript  c  N    normal-…     subscript  x   subscript  A  i     subscript  c  1   normal-…   subscript  c  N       \lambda x_{1}\ldots x_{A_{i}}.\lambda c_{1}\ldots c_{N}.c_{i}(x_{1}c_{1}\ldots
 c%
 _{N})\ldots(x_{A_{i}}c_{1}\ldots c_{N})   compare this to the Mogensen Scott encoding,       λ   x  1   …   x   A  i     .   λ   c  1   …   c  N    .    c  i    x  1   …   x   A  i        formulae-sequence    λ   subscript  x  1   normal-…   subscript  x   subscript  A  i       λ   subscript  c  1   normal-…   subscript  c  N       subscript  c  i    subscript  x  1   normal-…   subscript  x   subscript  A  i       \lambda x_{1}\ldots x_{A_{i}}.\lambda c_{1}\ldots c_{N}.c_{i}x_{1}\ldots x_{A_%
 {i}}     With this generalization, the Scott and Church encodings coincide on all enumerated datatypes (such as the boolean datatype) because each constructor is a constant (no parameters).  Type definitions  Church-encoded data and operations on them are typable in system F , but Scott-encoded data and operations are not obviously typable in system F. Universal as well as recursive types appear to be required, 2 and since strong normalization does not hold for recursively typed lambda calculus, termination of programs manipulating Scott-encoded data cannot be established by determining well-typedness of such programs.  See also   Church encoding  System F  Lambda cube   Notes  References   Directly Reﬂective Meta-Programming  Torben Mogensen (1992). Efficient Self-Interpretation in Lambda Calculus . '' Journal of Functional Programming''.   "  Category:Lambda calculus     {{ cite journal| last=Mogensen| first=Torben| title=Efficient Self-Interpretation in Lambda Calculus| journal=Journal of Functional Programming| year=1994| volume=2| pages=345-364}} ↩  See the note "Types for the Scott numerals" by Martín Abadi, Luca Cardelli and Gordon Plotkin (February 18, 1993). ↩     