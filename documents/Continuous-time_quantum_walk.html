<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1703">Continuous-time quantum walk</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Continuous-time quantum walk</h1>
<hr/>

<p>A <strong>Continuous-time quantum walk (CTQW)</strong> is a <a href="Glossary_of_graph_theory#Walks" title="wikilink">walk</a> on a given <a href="Connectivity_(graph_theory)" title="wikilink">connected</a> <a href="Graph_(mathematics)" title="wikilink">graph</a> that is dictated by a time-varying unitary matrix that relies on the <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a> of the quantum system and the <a href="adjacency_matrix" title="wikilink">adjacency matrix</a>. CTQW belongs to what is known as <a href="Quantum_random_walk" title="wikilink"><em>Quantum walks</em></a>, which also consists of the Discrete-time quantum walk. The concept of Continuous-time quantum walk is believed to have been first considered for quantum computation by Edward Farhi and Sam Gutmann.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Though, it may be possible to consider CTQW for directed graphs, we focus on this area as it applies to undirected graphs unless stated otherwise.</p>
<h2 id="introduction">Introduction</h2>

<p>Ever since the advent of quantum mechanics and the discovery by Shor of how to achieve factorization of large semi-primes efficiently (polynomial time) using quantum computation, scientists have been intrigued by the realm of possibilities. In many cases where the quantum algorithms are derived for problems, the complexity of the algorithms are faster than their classical counterpart. Some of these include <a href="Shor's_algorithm" title="wikilink">Shor's factorization algorithm</a>, which is exponentially faster than known classical factoring algorithms, and <a href="Grover's_algorithm" title="wikilink">Grover's searching algorithms</a>, which is polynomially faster than any possible black-box classical algorithm. Many of these algorithms use (or can be modified to use) the concept of <a href="Quantum_Fourier_transform" title="wikilink"><em>quantum fourier transform</em></a>.</p>

<p>In recent times, some scientists have decided to propose a new form of looking at quantum computation algorithms. The reason is that many classical algorithms are based on (classical) random walks. This led to the intuitive question of whether a "quantum random walk" (or simply "quantum walk") could be proposed. One such model of a quantum walk is the Continuous-time quantum walk (CTQW) proposed by E. Farhi et al.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> There are a number of variations to representing a CTQW, but we follow the definition below.</p>
<h3 id="mathematical-definition">Mathematical Definition</h3>

<p>A continuous-time quantum walk (CTQW) on a graph <em>G</em> = (<em>V,E</em>), where <em>V</em> is the set of vertices (nodes) and <em>E</em> is the set of edges connecting the nodes, is defined as follows:<br/>
 Let <em>A</em> be the <em>|V| 

<math display="inline" id="Continuous-time_quantum_walk:0">
<semantics>
<mo>×</mo>
<annotation-xml encoding="MathML-Content">
<times></times>
</annotation-xml>
<annotation encoding="application/x-tex">
   \times
  </annotation>
</semantics>
</math>

 |V|</em> <a href="adjacency_matrix" title="wikilink">adjacency matrix</a> of <em>G</em> with elements</p>

<p>
<math display="block" id="Continuous-time_quantum_walk:1">
<semantics>
<mrow>
<msub>
<mi>A</mi>
<mrow>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mn>1</mn>
</mtd>
<mtd columnalign="center">
<mrow>
<mtext>if {u,v}</mtext>
<mi>ϵ</mi>
<mrow></mrow>
<mi>E</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mn>0</mn>
</mtd>
<mtd columnalign="center">
<mtext>otherwise</mtext>
</mtd>
</mtr>
</mtable>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<list>
<ci>u</ci>
<ci>v</ci>
</list>
</apply>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-{</ci>
<matrix>
<matrixrow>
<cn type="integer">1</cn>
<apply>
<times></times>
<mtext>if {u,v}</mtext>
<ci>ϵ</ci>
<mtext></mtext>
<ci>E</ci>
</apply>
</matrixrow>
<matrixrow>
<cn type="integer">0</cn>
<mtext>otherwise</mtext>
</matrixrow>
</matrix>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   A_{u,v}=\left\{\begin{matrix}1&amp;\text{if }\textrm{\{u,v\}}\text{ }\epsilon\text%
{ }E\\
0&amp;\text{otherwise}\end{matrix}\right.
  </annotation>
</semantics>
</math>

 and <em>D</em> be the <em>|V| 

<math display="inline" id="Continuous-time_quantum_walk:2">
<semantics>
<mo>×</mo>
<annotation-xml encoding="MathML-Content">
<times></times>
</annotation-xml>
<annotation encoding="application/x-tex">
   \times
  </annotation>
</semantics>
</math>

 |V|</em> <a href="degree_matrix" title="wikilink">degree matrix</a> of <em>G</em> (for which the diagonal entry corresponding to vertex <em>v</em> is degree(<em>v</em>)), and let <em>L</em> = <em>D</em> - <em>A</em>, be the corresponding <a href="Laplacian_matrix" title="wikilink">Laplacian matrix</a> which is positive semidefinite. The continuous-time quantum walk on the graph <em>G</em> is then defined by the unitary matrix</p>

<p>
<math display="block" id="Continuous-time_quantum_walk:3">
<semantics>
<mrow>
<mrow>
<mpadded lspace="1.7pt" width="+1.7pt">
<mi>U</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mrow>
<mi>i</mi>
<mi>t</mi>
<mi>L</mi>
</mrow>
</mrow>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>U</ci>
<ci>t</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>i</ci>
<ci>t</ci>
<ci>L</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \,U(t)=e^{-itL}
  </annotation>
</semantics>
</math>
<br/>
where 

<math display="inline" id="Continuous-time_quantum_walk:4">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

 is the <a href="imaginary_unit" title="wikilink">imaginary unit</a> and 

<math display="inline" id="Continuous-time_quantum_walk:5">
<semantics>
<mrow>
<mpadded width="+3.4pt">
<mi>t</mi>
</mpadded>
<mi>ϵ</mi>
<mrow></mrow>
<mi>ℝ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>t</ci>
<ci>ϵ</ci>
<mtext></mtext>
<ci>ℝ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t\,\,\epsilon\text{ }\mathbb{R}
  </annotation>
</semantics>
</math>

. The probability of a walk starting at vertex 

<math display="inline" id="Continuous-time_quantum_walk:6">
<semantics>
<mi>u</mi>
<annotation-xml encoding="MathML-Content">
<ci>u</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   u
  </annotation>
</semantics>
</math>

 ending up at vertex 

<math display="inline" id="Continuous-time_quantum_walk:7">
<semantics>
<mi>v</mi>
<annotation-xml encoding="MathML-Content">
<ci>v</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   v
  </annotation>
</semantics>
</math>

 at time 

<math display="inline" id="Continuous-time_quantum_walk:8">
<semantics>
<mi>t</mi>
<annotation-xml encoding="MathML-Content">
<ci>t</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   t
  </annotation>
</semantics>
</math>

 is given by 

<math display="inline" id="Continuous-time_quantum_walk:9">
<semantics>
<msup>
<mrow>
<mo>|</mo>
<mrow>
<mo stretchy="false">⟨</mo>
<mi>v</mi>
<mo fence="true" stretchy="false">|</mo>
<mrow>
<mi>U</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo fence="true" stretchy="false">|</mo>
<mi>u</mi>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>|</mo>
</mrow>
<mn>2</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="latexml">quantum-operator-product</csymbol>
<ci>v</ci>
<apply>
<times></times>
<ci>U</ci>
<ci>t</ci>
</apply>
<ci>u</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \left|\langle v|U(t)|u\rangle\right|^{2}
  </annotation>
</semantics>
</math>

. Consequently starting from the quantum state 

<math display="inline" id="Continuous-time_quantum_walk:10">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<msub>
<mi>ψ</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\psi_{0}\rangle
  </annotation>
</semantics>
</math>

 and performing a quantum walk for time 

<math display="inline" id="Continuous-time_quantum_walk:11">
<semantics>
<mi>t</mi>
<annotation-xml encoding="MathML-Content">
<ci>t</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   t
  </annotation>
</semantics>
</math>

 will result in the new state 

<math display="inline" id="Continuous-time_quantum_walk:12">
<semantics>
<mrow>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<msub>
<mi>ψ</mi>
<mi>t</mi>
</msub>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>=</mo>
<mrow>
<mi>U</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<msub>
<mi>ψ</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>t</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>U</ci>
<ci>t</ci>
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\psi_{t}\rangle=U(t)|\psi_{0}\rangle
  </annotation>
</semantics>
</math>

 and measuring will thus localize the walk in vertex 

<math display="inline" id="Continuous-time_quantum_walk:13">
<semantics>
<mi>v</mi>
<annotation-xml encoding="MathML-Content">
<ci>v</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   v
  </annotation>
</semantics>
</math>

 with the probability 

<math display="inline" id="Continuous-time_quantum_walk:14">
<semantics>
<msup>
<mrow>
<mo>|</mo>
<mrow>
<mo stretchy="false">⟨</mo>
<mi>v</mi>
<mo fence="true" stretchy="false">|</mo>
<mrow>
<mi>U</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo fence="true" stretchy="false">|</mo>
<msub>
<mi>ψ</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>|</mo>
</mrow>
<mn>2</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="latexml">quantum-operator-product</csymbol>
<ci>v</ci>
<apply>
<times></times>
<ci>U</ci>
<ci>t</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \left|\langle v|U(t)|\psi_{0}\rangle\right|^{2}
  </annotation>
</semantics>
</math>

. <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="quantum-walk">Quantum walk</h2>

<p>To discuss the quantum walk, it is useful to define the more familiar topic of (classical) random walk (CRW). The random walk is well-defined in random processes with the <a href="http://mathworld.wolfram.com/MarkovProcess.html">Markov process</a> model.</p>
<h3 id="classical-random-walk-crw">Classical Random Walk (CRW)</h3>

<p>Here, a graph is traversed in an order that predicts the probability of being at a node 

<math display="inline" id="Continuous-time_quantum_walk:15">
<semantics>
<mi>v</mi>
<annotation-xml encoding="MathML-Content">
<ci>v</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   v
  </annotation>
</semantics>
</math>

 in time 

<math display="inline" id="Continuous-time_quantum_walk:16">
<semantics>
<mi>t</mi>
<annotation-xml encoding="MathML-Content">
<ci>t</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   t
  </annotation>
</semantics>
</math>

 given that the walk starts from a node 

<math display="inline" id="Continuous-time_quantum_walk:17">
<semantics>
<mi>u</mi>
<annotation-xml encoding="MathML-Content">
<ci>u</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   u
  </annotation>
</semantics>
</math>

 in the graph. To elaborate this concept, consider the case of a classical walk on a line. Assume a person, John, stands at the origin of a straight line and he has a fair coin. John wants to exhibit a random walk in which the probability of moving a step to the left or right is equal (=1/2). John flips his coin and the outcome dictates where he goes next. If the outcome is head (H), he takes one step to the right and if it is tail (T), he takes one step to the left. Following this rule, then the probability of John being at position 

<math display="inline" id="Continuous-time_quantum_walk:18">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 after 

<math display="inline" id="Continuous-time_quantum_walk:19">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

 steps can be shown to be</p>

<p>
<math display="block" id="Continuous-time_quantum_walk:20">
<semantics>
<mrow>
<mrow>
<msub>
<mi>P</mi>
<mi>N</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<msup>
<mn>2</mn>
<mi>N</mi>
</msup>
</mfrac>
<mrow>
<mo>(</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mi>N</mi>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mstyle displaystyle="false">
<mfrac>
<mrow>
<mi>d</mi>
<mo>+</mo>
<mi>N</mi>
</mrow>
<mn>2</mn>
</mfrac>
</mstyle>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>N</ci>
</apply>
<ci>d</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>N</ci>
</apply>
</apply>
<matrix>
<matrixrow>
<ci>N</ci>
</matrixrow>
<matrixrow>
<apply>
<divide></divide>
<apply>
<plus></plus>
<ci>d</ci>
<ci>N</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</matrixrow>
</matrix>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P_{N}(d)=\frac{1}{2^{N}}\begin{pmatrix}N\\
\frac{d+N}{2}\end{pmatrix}
  </annotation>
</semantics>
</math>
</p>

<p>Since John has a fair coin, the average of his distribution (where he's expected to be on the average) is the origin (position 0), and the standard deviation can be shown to be 

<math display="inline" id="Continuous-time_quantum_walk:21">
<semantics>
<msqrt>
<mi>N</mi>
</msqrt>
<annotation-xml encoding="MathML-Content">
<apply>
<root></root>
<ci>N</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sqrt{N}
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A table showing the probability of this distribution for up to the fourth step is shown below:</p>
<h3 id="continuous-time-quantum-walk-ctqw">Continuous-time quantum walk (CTQW)</h3>

<p>Now, the fair coin in John's possession is replaced with a qubit. This qubit is defined in terms of states 

<math display="inline" id="Continuous-time_quantum_walk:22">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mo>↓</mo>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>normal-↓</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\downarrow\rangle
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Continuous-time_quantum_walk:23">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mo>↑</mo>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>normal-↑</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\uparrow\rangle
  </annotation>
</semantics>
</math>

 different from the 

<math display="inline" id="Continuous-time_quantum_walk:24">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mn>0</mn>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |0\rangle
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Continuous-time_quantum_walk:25">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mn>1</mn>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |1\rangle
  </annotation>
</semantics>
</math>

 basis. Next, a Hadamard operation is applied to the initial state. A Hadamard on the up state will give a superposition of up and down as follows</p>

<p>
<math display="block" id="Continuous-time_quantum_walk:26">
<semantics>
<mrow>
<mrow>
<mi>H</mi>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mo>↑</mo>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mfrac>
<mn>1</mn>
<msqrt>
<mn>2</mn>
</msqrt>
</mfrac>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mo>↑</mo>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mfrac>
<mn>1</mn>
<msqrt>
<mn>2</mn>
</msqrt>
</mfrac>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mo>↓</mo>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>H</ci>
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>normal-↑</ci>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<root></root>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>normal-↑</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<root></root>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>normal-↓</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H|\uparrow\rangle=\frac{1}{\sqrt{2}}|\uparrow\rangle+\frac{1}{\sqrt{2}}|\downarrow\rangle
  </annotation>
</semantics>
</math>

 and</p>

<p>
<math display="block" id="Continuous-time_quantum_walk:27">
<semantics>
<mrow>
<mi>H</mi>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<msqrt>
<mn>2</mn>
</msqrt>
</mfrac>
<mrow>
<mo>(</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mn>1</mn>
</mtd>
<mtd columnalign="center">
<mn>1</mn>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mn>1</mn>
</mtd>
<mtd columnalign="center">
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>H</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<root></root>
<cn type="integer">2</cn>
</apply>
</apply>
<matrix>
<matrixrow>
<cn type="integer">1</cn>
<cn type="integer">1</cn>
</matrixrow>
<matrixrow>
<cn type="integer">1</cn>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</matrixrow>
</matrix>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H=\frac{1}{\sqrt{2}}\begin{pmatrix}1&amp;1\\
1&amp;-1\end{pmatrix}
  </annotation>
</semantics>
</math>

 After applying the Hadamard operator, the spin-1/2 rotation in the z-direction is applied, thereby stepping left or right based on the resulting state. Overall, the applied operator becomes</p>

<p>
<math display="block" id="Continuous-time_quantum_walk:28">
<semantics>
<mrow>
<mi>U</mi>
<mo>=</mo>
<mrow>
<msup>
<mi>e</mi>
<mrow>
<mi>i</mi>
<mover accent="true">
<mi>p</mi>
<mo stretchy="false">^</mo>
</mover>
<msub>
<mi>σ</mi>
<mi>z</mi>
</msub>
</mrow>
</msup>
<mi>H</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>U</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<times></times>
<ci>i</ci>
<apply>
<ci>normal-^</ci>
<ci>p</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>σ</ci>
<ci>z</ci>
</apply>
</apply>
</apply>
<ci>H</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   U=e^{i\hat{p}\sigma_{z}}H
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Continuous-time_quantum_walk:29">
<semantics>
<msub>
<mi>σ</mi>
<mi>z</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>σ</ci>
<ci>z</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sigma_{z}
  </annotation>
</semantics>
</math>

 is the Pauli-Z operator and 

<math display="inline" id="Continuous-time_quantum_walk:30">
<semantics>
<mover accent="true">
<mi>p</mi>
<mo stretchy="false">^</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-^</ci>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{p}
  </annotation>
</semantics>
</math>

 is the momentum operator of the qubit particle. This evolving operator in the CTQW is applied N times to the resulting qubit states. When the initial state representing the origin of the line is chosen to be 

<math display="inline" id="Continuous-time_quantum_walk:31">
<semantics>
<mrow>
<mrow>
<mfrac>
<mn>1</mn>
<msqrt>
<mn>2</mn>
</msqrt>
</mfrac>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mo>↑</mo>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mfrac>
<mn>1</mn>
<msqrt>
<mn>2</mn>
</msqrt>
</mfrac>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mo>↓</mo>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<root></root>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>normal-↑</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<root></root>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>normal-↓</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{1}{\sqrt{2}}|\uparrow\rangle+\frac{1}{\sqrt{2}}|\downarrow\rangle
  </annotation>
</semantics>
</math>

, the standard deviation is shown to be approximately 

<math display="inline" id="Continuous-time_quantum_walk:32">
<semantics>
<mrow>
<mfrac>
<mn>3</mn>
<mn>5</mn>
</mfrac>
<mi>N</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">3</cn>
<cn type="integer">5</cn>
</apply>
<ci>N</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{3}{5}N
  </annotation>
</semantics>
</math>
<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> which is in quadratic form of the standard deviation from classical algorithm. In this case the probability of being at position <em>d</em> after <em>N</em> steps is different from the classical case as depicted below:</p>

<p>Note that the description employs a discrete-time quantum walk, but it provides an intuitive use on the graph problem for the continuous-time quantum walk where the <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a> evolves the state of the system at any given time.</p>
<h2 id="difference-between-ctqw-and-crw">Difference between CTQW and CRW<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></h2>

<p>Farhi et al. showed<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> that on a symmetric graph known as 

<math display="inline" id="Continuous-time_quantum_walk:33">
<semantics>
<msub>
<mi>G</mi>
<mn>4</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G_{4}
  </annotation>
</semantics>
</math>

, which consists of two binary trees of depth four(4) merged at their children nodes, it is possible for the quantum random walk to achieve exponential speed-up over its classical counterpart.  It could be deduced that the probability of reaching the EXIT node from the ENTRANCE node of a 

<math display="inline" id="Continuous-time_quantum_walk:34">
<semantics>
<msub>
<mi>G</mi>
<mi>n</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G_{n}
  </annotation>
</semantics>
</math>

 is less than 

<math display="inline" id="Continuous-time_quantum_walk:35">
<semantics>
<msup>
<mn>2</mn>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{-n}
  </annotation>
</semantics>
</math>

, but in the quantum case, the limiting distribution probability is at least 

<math display="inline" id="Continuous-time_quantum_walk:36">
<semantics>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mn>2</mn>
<mi>n</mi>
</mrow>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   {(2n+1)}^{-1}
  </annotation>
</semantics>
</math>

. This is a tremendous increase, but it only states that the time to reach the EXIT is faster <em>as contrasted from</em> the algorithmic speedup. However, it was later shown by the same author <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> that indeed an exponential algorithmic speedup can be achieved by the quantum walk.</p>

<p>It is also important to note that the quantum walk 'collapses' to a classical random walk with the degree of decoherence.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> It is possible to obtain the classical if one measures the positions in the quantum work at every step. In other words, the inability to have superposition restricts the classical domain of walks in graph theory.</p>
<h2 id="potential-applications">Potential Applications</h2>

<p>The area of CTQW as well as discrete-time quantum walk has given additional insight on how to achieve quantum computation. It is an area of research that is still captivating interest and a number of algorithm using CTQW has been proposed. The three main applications to date are</p>
<ol>
<li>Quantum search algorithm<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li>Graph Traversal problem<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li><a href="http://info.phys.unm.edu/~alandahl/iqiwiki/index.php/Quantum_Scattering_NAND-Tree_Algorithm">Quantum scattering NAND-tree</a></li>
</ol>

<p>In each case, the algorithmic speedup is not different from what was expected in existing quantum algorithms like the Grover search algorithm that takes 

<math display="inline" id="Continuous-time_quantum_walk:37">
<semantics>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<msqrt>
<mi>N</mi>
</msqrt>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<root></root>
<ci>N</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O(\sqrt{N})
  </annotation>
</semantics>
</math>

.</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li>[<a class="uri" href="http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1">http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1;</a>;=151590 Quantum Walk on arxiv.org]</li>
<li><a href="http://demonstrations.wolfram.com/ContinuousTimeQuantumWalk/">CTQW on Wolfram Demonstrations</a></li>
<li><a href="http://www.kisc.meiji.ac.jp/~tz14040/quantumwalk/english/">Quantum walk</a></li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_mechanics" title="wikilink">Category:Quantum mechanics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">E. Farhi and S. Gutmann, <em>Quantum computation and decision trees</em>, Phys. Rev. A <strong>58</strong>, 915 (1998)<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3">H. Gerhardt and J. Watrous, <em>Continuous-time quantum walks on the symmetric group</em>, quant-ph/0305182<a href="#fnref3">↩</a></li>
<li id="fn4">B.C. Travaglione and G.J. Milburn, <em>Implementing the quantum random walk</em>, quant-ph/0109076<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">A.M. Childs, E. Farhi, and S. Gutmann, <em>An example of the difference between quantum and classical random walks</em>, quant-ph/0103020<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8">A.M. Childs, R. Cleve, E. Deotto, E. Farhi, S. Gutmann, and D.A. Spielman, <em>Exponential Algorithmic Speedup by a Quantum walk</em> quant-ph/0209131<a href="#fnref8">↩</a></li>
<li id="fn9">J. Kempe, <em>Quantum random walks - an introductory overview</em>, quant-ph/0303081<a href="#fnref9">↩</a></li>
<li id="fn10">N. Shenvi, J. Kempe, and K.B. Whaley, <em>A quantum random walk search algorithm</em>, quant-ph/0210064<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
</ol>
</section>
</body>
</html>
