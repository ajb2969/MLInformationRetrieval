<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1644">Valiant–Vazirani theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Valiant–Vazirani theorem</h1>
<hr/>

<p>The <strong>Valiant–Vazirani theorem</strong> is a theorem in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>. It was proven by <a href="Leslie_Valiant" title="wikilink">Leslie Valiant</a> and <a href="Vijay_Vazirani" title="wikilink">Vijay Vazirani</a> in their paper titled <em>NP is as easy as detecting unique solutions</em> published in 1986.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The theorem states that if there is a <a href="P_(complexity)" title="wikilink">polynomial time algorithm</a> for <a href="Boolean_satisfiability_problem#Extensions_of_SAT" title="wikilink">Unambiguous-SAT</a>, then <a href="NP_(complexity)" title="wikilink">NP</a>=<a href="RP_(complexity)" title="wikilink">RP</a>. The proof is based on the Mulmuley–Vazirani <a href="isolation_lemma" title="wikilink">isolation lemma</a>, which was subsequently used for a number of important applications in <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>.</p>

<p>The Valiant–Vazirani theorem implies that the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a>, which is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, remains a computationally hard problem even if the input instances are promised to have at most one satisfying assignment.</p>
<h2 id="proof-outline">Proof outline</h2>

<p><a href="Boolean_satisfiability_problem#Extensions_of_SAT" title="wikilink">Unambiguous-SAT</a> is the <a href="promise_problem" title="wikilink">promise problem</a> of deciding whether a given Boolean formula that has at most one satisfying assignment is unsatisfiable or has exactly one satisfying assignment. In the first case, an algorithm for Unambiguous-SAT should reject, and in the second it should accept the formula. If the formula has more than one satisfying assignment, then there is no condition on the behavior of the algorithm. The promise problem Unambiguous-SAT can be decided by a <a href="nondeterministic_Turing_machine" title="wikilink">nondeterministic Turing machine</a> that has at most one accepting computation path. In this sense, this promise problem belongs to the complexity class <a href="UP_(complexity)" title="wikilink">UP</a> (which is usually only defined for languages).</p>

<p>The proof of the Valiant–Vazirani theorem consists of a probabilistic reduction from SAT to SAT such that, with probability at least 

<math display="inline" id="Valiant–Vazirani_theorem:0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(1/n)
  </annotation>
 </semantics>
</math>

, the output formula has at most one satisfying assignment, and thus satisfies the promise of the Unambiguous-SAT problem. More precisely, the reduction is a randomized polynomial-time algorithm that maps a Boolean formula 

<math display="inline" id="Valiant–Vazirani_theorem:1">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Valiant–Vazirani_theorem:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 variables 

<math display="inline" id="Valiant–Vazirani_theorem:3">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{n}
  </annotation>
 </semantics>
</math>

 to a Boolean formula 

<math display="inline" id="Valiant–Vazirani_theorem:4">
 <semantics>
  <mrow>
   <msup>
    <mi>F</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>normal-′</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

 such that</p>
<ul>
<li>every satisfying assignment of 

<math display="inline" id="Valiant–Vazirani_theorem:5">
 <semantics>
  <msup>
   <mi>F</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>F</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}
  </annotation>
 </semantics>
</math>

 also satisfies 

<math display="inline" id="Valiant–Vazirani_theorem:6">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

, and</li>
<li>if 

<math display="inline" id="Valiant–Vazirani_theorem:7">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is satisfiable, then, with probability at least 

<math display="inline" id="Valiant–Vazirani_theorem:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(1/n)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Valiant–Vazirani_theorem:9">
 <semantics>
  <msup>
   <mi>F</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>F</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}
  </annotation>
 </semantics>
</math>

 has a unique satisfying assignment 

<math display="inline" id="Valiant–Vazirani_theorem:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{1},\dots,a_{n})
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>By running the reduction a polynomial number 

<math display="inline" id="Valiant–Vazirani_theorem:11">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 of times, each time with fresh independent random bits, we get formulas 

<math display="inline" id="Valiant–Vazirani_theorem:12">
 <semantics>
  <mrow>
   <msubsup>
    <mi>F</mi>
    <mn>1</mn>
    <mo>′</mo>
   </msubsup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msubsup>
    <mi>F</mi>
    <mi>t</mi>
    <mo>′</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>normal-′</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}_{1},\dots,F^{\prime}_{t}
  </annotation>
 </semantics>
</math>

. Choosing 

<math display="inline" id="Valiant–Vazirani_theorem:13">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=O(n)
  </annotation>
 </semantics>
</math>

, we get that the probability that at least one formula 

<math display="inline" id="Valiant–Vazirani_theorem:14">
 <semantics>
  <msubsup>
   <mi>F</mi>
   <mi>i</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}_{i}
  </annotation>
 </semantics>
</math>

 is uniquely satisfiable is at least 

<math display="inline" id="Valiant–Vazirani_theorem:15">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Valiant–Vazirani_theorem:16">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is satisfiable. This gives a Turing reduction from SAT to Unambiguous-SAT since an assumed algorithm for Unambiguous-SAT can be invoked on the 

<math display="inline" id="Valiant–Vazirani_theorem:17">
 <semantics>
  <msubsup>
   <mi>F</mi>
   <mi>i</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}_{i}
  </annotation>
 </semantics>
</math>

. Then the <a href="random_self-reducibility" title="wikilink">random self-reducibility</a> of SAT can be used to compute a satisfying assignment, should it exist. Overall, this proves that NP=RP if Unambiguous-SAT can be solved in RP.</p>

<p>The idea of the reduction is to intersect the solution space of the formula 

<math display="inline" id="Valiant–Vazirani_theorem:18">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Valiant–Vazirani_theorem:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 random affine hyperplanes over 

<math display="inline" id="Valiant–Vazirani_theorem:20">
 <semantics>
  <mrow>
   <mtext>GF</mtext>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>GF</mtext>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{GF}(2)^{n}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Valiant–Vazirani_theorem:21">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in\{1,\dots,n\}
  </annotation>
 </semantics>
</math>

 is chosen uniformly at random. An alternative proof is based on the <a href="isolation_lemma" title="wikilink">isolation lemma</a> by Mulmuley, Vazirani, and Vazirani. They consider a more general setting, and applied to the setting here this gives an isolation probability of only 

<math display="inline" id="Valiant–Vazirani_theorem:22">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <msup>
      <mi>n</mi>
      <mn>8</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">8</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(1/n^{8})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Structural_complexity_theory" title="wikilink">Category:Structural complexity theory</a> <a href="Category:Theorems_in_computational_complexity_theory" title="wikilink">Category:Theorems in computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
