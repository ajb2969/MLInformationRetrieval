<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1360">Wiener‚ÄìHopf method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Wiener‚ÄìHopf method</h1>
<hr/>

<p>The <strong>Wiener‚ÄìHopf method</strong> is a mathematical technique widely used in <a href="applied_mathematics" title="wikilink">applied mathematics</a>. It was initially developed by <a href="Norbert_Wiener" title="wikilink">Norbert Wiener</a> and <a href="Eberhard_Hopf" title="wikilink">Eberhard Hopf</a> as a method to solve systems of <a href="integral_equation" title="wikilink">integral equations</a>, but has found wider use in solving two-dimensional <a href="partial_differential_equation" title="wikilink">partial differential equations</a> with mixed <a href="boundary_conditions" title="wikilink">boundary conditions</a> on the same boundary. In general, the method works by exploiting the <a href="Complex_analysis" title="wikilink">complex-analytical</a> properties of transformed functions. Typically, the standard <a href="Fourier_transform" title="wikilink">Fourier transform</a> is used, but examples exist using other transforms, such as the <a href="Mellin_transform" title="wikilink">Mellin transform</a>.</p>

<p>In general, the governing equations and boundary conditions are transformed and these transforms are used to define a pair of complex functions (typically denoted with '+' and '‚àí' subscripts) which are respectively <a href="analytic_function" title="wikilink">analytic</a> in the upper and lower halves of the complex plane, and have growth no faster than polynomials in these regions. These two functions will also coincide on some region of the <a href="complex_plane" title="wikilink">complex plane</a>, typically, a thin strip containing the <a href="real_line" title="wikilink">real line</a>. <a href="Analytic_continuation" title="wikilink">Analytic continuation</a> guarantees that these two functions define a single function analytic in the entire complex plane, and <a href="Liouville's_theorem_(complex_analysis)" title="wikilink">Liouville's theorem</a> implies that this function is an unknown <a class="uri" href="polynomial" title="wikilink">polynomial</a>, which is often zero or constant. Analysis of the conditions at the edges and corners of the boundary allows one to determine the degree of this polynomial.</p>
<h2 id="wienerhopf-decomposition">Wiener‚ÄìHopf decomposition</h2>

<p>The key step in many Wiener‚ÄìHopf problems is to decompose an arbitrary function 

<math display="inline" id="Wiener‚ÄìHopf_method:0">
<semantics>
<mi mathvariant="normal">Œ¶</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Œ¶</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi
  </annotation>
</semantics>
</math>

 into two functions 

<math display="inline" id="Wiener‚ÄìHopf_method:1">
<semantics>
<msub>
<mi mathvariant="normal">Œ¶</mi>
<mo>¬±</mo>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Œ¶</ci>
<csymbol cd="latexml">plus-or-minus</csymbol>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi_{\pm}
  </annotation>
</semantics>
</math>

 with the desired properties outlined above. In general, this can be done by writing</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:2">
<semantics>
<mrow>
<mrow>
<msub>
<mi mathvariant="normal">Œ¶</mi>
<mo>+</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>Œ±</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mrow>
<mn>2</mn>
<mi>œÄ</mi>
<mi>i</mi>
</mrow>
</mfrac>
<mrow>
<msub>
<mo largeop="true" symmetric="true">‚à´</mo>
<msub>
<mi>C</mi>
<mn>1</mn>
</msub>
</msub>
<mrow>
<mi mathvariant="normal">Œ¶</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mfrac>
<mrow>
<mi>d</mi>
<mi>z</mi>
</mrow>
<mrow>
<mi>z</mi>
<mo>-</mo>
<mi>Œ±</mi>
</mrow>
</mfrac>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Œ¶</ci>
<plus></plus>
</apply>
<ci>Œ±</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>œÄ</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>normal-Œ¶</ci>
<ci>z</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>d</ci>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<ci>z</ci>
<ci>Œ±</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi_{+}(\alpha)=\frac{1}{2\pi i}\int_{C_{1}}\Phi(z)\frac{dz}{z-\alpha}
  </annotation>
</semantics>
</math>
</p>

<p>and</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:3">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi mathvariant="normal">Œ¶</mi>
<mo>-</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>Œ±</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mrow>
<mn>2</mn>
<mi>œÄ</mi>
<mi>i</mi>
</mrow>
</mfrac>
<mrow>
<msub>
<mo largeop="true" symmetric="true">‚à´</mo>
<msub>
<mi>C</mi>
<mn>2</mn>
</msub>
</msub>
<mrow>
<mi mathvariant="normal">Œ¶</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mfrac>
<mrow>
<mi>d</mi>
<mi>z</mi>
</mrow>
<mrow>
<mi>z</mi>
<mo>-</mo>
<mi>Œ±</mi>
</mrow>
</mfrac>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Œ¶</ci>
<minus></minus>
</apply>
<ci>Œ±</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>œÄ</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>normal-Œ¶</ci>
<ci>z</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>d</ci>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<ci>z</ci>
<ci>Œ±</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi_{-}(\alpha)=-\frac{1}{2\pi i}\int_{C_{2}}\Phi(z)\frac{dz}{z-\alpha},
  </annotation>
</semantics>
</math>
</p>

<p>where the contours 

<math display="inline" id="Wiener‚ÄìHopf_method:4">
<semantics>
<msub>
<mi>C</mi>
<mn>1</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{1}
  </annotation>
</semantics>
</math>


 and 

<math display="inline" id="Wiener‚ÄìHopf_method:5">
<semantics>
<msub>
<mi>C</mi>
<mn>2</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{2}
  </annotation>
</semantics>
</math>

 are parallel to the real line, but pass above and below the point 

<math display="inline" id="Wiener‚ÄìHopf_method:6">
<semantics>
<mrow>
<mi>z</mi>
<mo>=</mo>
<mi>Œ±</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>z</ci>
<ci>Œ±</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z=\alpha
  </annotation>
</semantics>
</math>

, respectively.</p>

<p>Similarly, arbitrary scalar functions may be decomposed into a product of +/‚àí functions, i.e. 

<math display="inline" id="Wiener‚ÄìHopf_method:7">
<semantics>
<mrow>
<mrow>
<mi>K</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>Œ±</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>K</mi>
<mo>+</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>Œ±</mi>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>K</mi>
<mo>-</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>Œ±</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>K</ci>
<ci>Œ±</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
<ci>Œ±</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>K</ci>
<minus></minus>
</apply>
<ci>Œ±</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K(\alpha)=K_{+}(\alpha)K_{-}(\alpha)
  </annotation>
</semantics>
</math>

, by first taking the logarithm, and then performing a sum decomposition. Product decompositions of matrix functions (which occur in coupled multi-modal systems such as elastic waves) are considerably more problematic since the logarithm is not well defined, and any decomposition might be expected to be non-commutative. A small subclass of commutative decompositions were obtained by Khrapkov, and various approximate methods have also been developed.</p>
<h2 id="example">Example</h2>

<p>Let us consider the linear <a href="partial_differential_equation" title="wikilink">partial differential equation</a></p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:8">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>ùë≥</mi>
<mrow>
<mi>x</mi>
<mi>y</mi>
</mrow>
</msub>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ùë≥</ci>
<apply>
<times></times>
<ci>x</ci>
<ci>y</ci>
</apply>
</apply>
<ci>f</ci>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \boldsymbol{L}_{xy}f(x,y)=0,
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Wiener‚ÄìHopf_method:9">
<semantics>
<msub>
<mi>ùë≥</mi>
<mrow>
<mi>x</mi>
<mi>y</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ùë≥</ci>
<apply>
<times></times>
<ci>x</ci>
<ci>y</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \boldsymbol{L}_{xy}
  </annotation>
</semantics>
</math>


 is a linear operator which contains derivatives with respect to 

<math display="inline" id="Wiener‚ÄìHopf_method:10">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Wiener‚ÄìHopf_method:11">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

, subject to the mixed conditions on 

<math display="inline" id="Wiener‚ÄìHopf_method:12">
<semantics>
<mrow>
<mi>y</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>y</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y=0
  </annotation>
</semantics>
</math>

, for some prescribed function 

<math display="inline" id="Wiener‚ÄìHopf_method:13">
<semantics>
<mrow>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>g</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   g(x)
  </annotation>
</semantics>
</math>

,</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:14">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mo>=</mo>
<mrow>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mtext>for</mtext>
<mi>x</mi>
</mrow>
<mo>‚â§</mo>
<mn>0</mn>
</mrow>
<mo rspace="12.5pt">,</mo>
<mrow>
<msub>
<mi>f</mi>
<mi>y</mi>
</msub>
<mo>=</mo>
<mrow>
<mn>0</mn>
<mtext>when</mtext>
<mi>x</mi>
</mrow>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<and></and>
<apply>
<eq></eq>
<ci>f</ci>
<apply>
<times></times>
<ci>g</ci>
<ci>x</ci>
<mtext>for</mtext>
<ci>x</ci>
</apply>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>y</ci>
</apply>
<apply>
<times></times>
<cn type="integer">0</cn>
<mtext>when</mtext>
<ci>x</ci>
</apply>
</apply>
<apply>
<gt></gt>
<share href="#.cmml">
</share>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f=g(x)\text{ for }x\leq 0,\quad f_{y}=0\text{ when }x&gt;0
  </annotation>
</semantics>
</math>
</p>

<p>and decay at infinity i.e. 

<math display="inline" id="Wiener‚ÄìHopf_method:15">
<semantics>
<mrow>
<mi>f</mi>
<mo>‚Üí</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-‚Üí</ci>
<ci>f</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f\rightarrow 0
  </annotation>
</semantics>
</math>

 as 

<math display="inline" id="Wiener‚ÄìHopf_method:16">
<semantics>
<mrow>
<mi>ùíô</mi>
<mo>‚Üí</mo>
<mi mathvariant="normal">‚àû</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-‚Üí</ci>
<ci>ùíô</ci>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \boldsymbol{x}\rightarrow\infty
  </annotation>
</semantics>
</math>

. Taking a <a href="Fourier_transform" title="wikilink">Fourier transform</a> with respect to 

<math display="inline" id="Wiener‚ÄìHopf_method:17">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 results in the following <a href="ordinary_differential_equation" title="wikilink">ordinary differential equation</a></p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:18">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<msub>
<mi>ùë≥</mi>
<mi>y</mi>
</msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ùë≥</ci>
<ci>y</ci>
</apply>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<times></times>
<ci>P</ci>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \boldsymbol{L}_{y}\hat{f}(k,y)-P(k,y)\hat{f}(k,y)=0,
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Wiener‚ÄìHopf_method:19">
<semantics>
<msub>
<mi>ùë≥</mi>
<mi>y</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ùë≥</ci>
<ci>y</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \boldsymbol{L}_{y}
  </annotation>
</semantics>
</math>


 is a linear operator containing 

<math display="inline" id="Wiener‚ÄìHopf_method:20">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

 derivatives only, 

<math display="inline" id="Wiener‚ÄìHopf_method:21">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(k,y)
  </annotation>
</semantics>
</math>

 is a known function of 

<math display="inline" id="Wiener‚ÄìHopf_method:22">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Wiener‚ÄìHopf_method:23">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

 and</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:24">
<semantics>
<mrow>
<mrow>
<mrow>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">‚à´</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">‚àû</mi>
</mrow>
<mi mathvariant="normal">‚àû</mi>
</msubsup>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mrow>
<mi>i</mi>
<mi>k</mi>
<mi>x</mi>
</mrow>
</mrow>
</msup>
<mtext>d</mtext>
<mi>x</mi>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<ci>f</ci>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>i</ci>
<ci>k</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
<mtext>d</mtext>
<ci>x</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{f}(k,y)=\int_{-\infty}^{\infty}f(x,y)e^{-ikx}\textrm{d}x.
  </annotation>
</semantics>
</math>
</p>

<p>If a particular solution of this ordinary differential equation which satisfies the necessary decay at infinity is denoted 

<math display="inline" id="Wiener‚ÄìHopf_method:25">
<semantics>
<mrow>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>F</ci>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   F(k,y)
  </annotation>
</semantics>
</math>

, a general solution can be written as</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:26">
<semantics>
<mrow>
<mrow>
<mrow>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<times></times>
<ci>C</ci>
<ci>k</ci>
<ci>F</ci>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{f}(k,y)=C(k)F(k,y),
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Wiener‚ÄìHopf_method:27">
<semantics>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>C</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C(k)
  </annotation>
</semantics>
</math>

 is an unknown function to be determined by the boundary conditions on 

<math display="inline" id="Wiener‚ÄìHopf_method:28">
<semantics>
<mrow>
<mi>y</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>y</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y=0
  </annotation>
</semantics>
</math>

.</p>

<p>The key idea is to split 

<math display="inline" id="Wiener‚ÄìHopf_method:29">
<semantics>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{f}
  </annotation>
</semantics>
</math>


 into two separate functions, 

<math display="inline" id="Wiener‚ÄìHopf_method:30">
<semantics>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>+</mo>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{f}_{+}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Wiener‚ÄìHopf_method:31">
<semantics>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>-</mo>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{f}_{-}
  </annotation>
</semantics>
</math>

 which are analytic in the lower- and upper-halves of the complex plane, respectively</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:32">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>+</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">‚à´</mo>
<mn>0</mn>
<mi mathvariant="normal">‚àû</mi>
</msubsup>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mrow>
<mi>i</mi>
<mi>k</mi>
<mi>x</mi>
</mrow>
</mrow>
</msup>
<mtext>d</mtext>
<mi>x</mi>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<plus></plus>
</apply>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<ci>f</ci>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>i</ci>
<ci>k</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
<mtext>d</mtext>
<ci>x</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{f}_{+}(k,y)=\int_{0}^{\infty}f(x,y)e^{-ikx}\textrm{d}x,
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:33">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>-</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">‚à´</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">‚àû</mi>
</mrow>
<mn>0</mn>
</msubsup>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mrow>
<mi>i</mi>
<mi>k</mi>
<mi>x</mi>
</mrow>
</mrow>
</msup>
<mtext>d</mtext>
<mi>x</mi>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<minus></minus>
</apply>
<interval closure="open">
<ci>k</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
<apply>
<times></times>
<ci>f</ci>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>i</ci>
<ci>k</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
<mtext>d</mtext>
<ci>x</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{f}_{-}(k,y)=\int_{-\infty}^{0}f(x,y)e^{-ikx}\textrm{d}x.
  </annotation>
</semantics>
</math>
</p>

<p>The boundary conditions then give</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:34">
<semantics>
<mrow>
<mrow>
<mrow>
<mover accent="true">
<mi>g</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>+</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>-</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>+</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>g</ci>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<plus></plus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<minus></minus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<plus></plus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>C</ci>
<ci>k</ci>
<ci>F</ci>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{g}(k)+\hat{f}_{+}(k,0)=\hat{f}_{-}(k,0)+\hat{f}_{+}(k,0)=\hat{f}(k,0)=C(k%
)F(k,0)
  </annotation>
</semantics>
</math>
</p>

<p>and, on taking derivatives with respect to 

<math display="inline" id="Wiener‚ÄìHopf_method:35">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

,</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:36">
<semantics>
<mrow>
<mrow>
<mrow>
<msubsup>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>-</mo>
<mo>‚Ä≤</mo>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msubsup>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>-</mo>
<mo>‚Ä≤</mo>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msubsup>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>+</mo>
<mo>‚Ä≤</mo>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>‚Ä≤</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>F</mi>
<mo>‚Ä≤</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<ci>normal-‚Ä≤</ci>
</apply>
<minus></minus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<ci>normal-‚Ä≤</ci>
</apply>
<minus></minus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<ci>normal-‚Ä≤</ci>
</apply>
<plus></plus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<ci>normal-‚Ä≤</ci>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>C</ci>
<ci>k</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>F</ci>
<ci>normal-‚Ä≤</ci>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{f}^{\prime}_{-}(k,0)=\hat{f}^{\prime}_{-}(k,0)+\hat{f}^{\prime}_{+}(k,0)=%
\hat{f}^{\prime}(k,0)=C(k)F^{\prime}(k,0).
  </annotation>
</semantics>
</math>
</p>

<p>Eliminating 

<math display="inline" id="Wiener‚ÄìHopf_method:37">
<semantics>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>C</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C(k)
  </annotation>
</semantics>
</math>

 yields</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:38">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mover accent="true">
<mi>g</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>+</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<msubsup>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>-</mo>
<mo>‚Ä≤</mo>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>/</mo>
<mi>K</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>g</ci>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<plus></plus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<ci>normal-‚Ä≤</ci>
</apply>
<minus></minus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
<ci>K</ci>
</apply>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{g}(k)+\hat{f}_{+}(k,0)=\hat{f}^{\prime}_{-}(k,0)/K(k),
  </annotation>
</semantics>
</math>
</p>

<p>where</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:39">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>K</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mfrac>
<mrow>
<msup>
<mi>F</mi>
<mo>‚Ä≤</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>K</ci>
<ci>k</ci>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>F</ci>
<ci>normal-‚Ä≤</ci>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
<apply>
<times></times>
<ci>F</ci>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K(k)=\frac{F^{\prime}(k,0)}{F(k,0)}.
  </annotation>
</semantics>
</math>
</p>

<p>Now 

<math display="inline" id="Wiener‚ÄìHopf_method:40">
<semantics>
<mrow>
<mi>K</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>K</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K(k)
  </annotation>
</semantics>
</math>

 can be decomposed into the product of functions 

<math display="inline" id="Wiener‚ÄìHopf_method:41">
<semantics>
<msup>
<mi>K</mi>
<mo>-</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K^{-}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Wiener‚ÄìHopf_method:42">
<semantics>
<msup>
<mi>K</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K^{+}
  </annotation>
</semantics>
</math>

 which are analytic in the upper and lower half-planes respectively. To be precise, 

<math display="inline" id="Wiener‚ÄìHopf_method:43">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>K</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>K</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>K</mi>
<mo>-</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>K</ci>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
<ci>k</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<minus></minus>
</apply>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K(k)=K^{+}(k)K^{-}(k),
  </annotation>
</semantics>
</math>

 where</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:44">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mtext>log</mtext>
<msup>
<mi>K</mi>
<mo>-</mo>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mrow>
<mn>2</mn>
<mi>œÄ</mi>
<mi>i</mi>
</mrow>
</mfrac>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">‚à´</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">‚àû</mi>
</mrow>
<mi mathvariant="normal">‚àû</mi>
</msubsup>
<mrow>
<mfrac>
<mrow>
<mtext>log</mtext>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>K</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mi>z</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</mfrac>
<mtext>d</mtext>
<mi>z</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<mo rspace="12.5pt">,</mo>
<mrow>
<mrow>
<mtext>Im</mtext>
<mi>k</mi>
</mrow>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<times></times>
<mtext>log</mtext>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<minus></minus>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>œÄ</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<mtext>log</mtext>
<apply>
<times></times>
<ci>K</ci>
<ci>z</ci>
</apply>
</apply>
<apply>
<minus></minus>
<ci>z</ci>
<ci>k</ci>
</apply>
</apply>
<mtext>d</mtext>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<gt></gt>
<apply>
<times></times>
<mtext>Im</mtext>
<ci>k</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hbox{log}K^{-}=\frac{1}{2\pi i}\int_{-\infty}^{\infty}\frac{\hbox{log}(K(z))}%
{z-k}\textrm{d}z,\quad\hbox{Im}k&gt;0,
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:45">
<semantics>
<mrow>
<mrow>
<mrow>
<mtext>log</mtext>
<msup>
<mi>K</mi>
<mo>+</mo>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mrow>
<mn>2</mn>
<mi>œÄ</mi>
<mi>i</mi>
</mrow>
</mfrac>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">‚à´</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">‚àû</mi>
</mrow>
<mi mathvariant="normal">‚àû</mi>
</msubsup>
<mrow>
<mfrac>
<mrow>
<mtext>log</mtext>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>K</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mi>z</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</mfrac>
<mtext>d</mtext>
<mi>z</mi>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo rspace="12.5pt">,</mo>
<mrow>
<mrow>
<mtext>Im</mtext>
<mi>k</mi>
</mrow>
<mo>&lt;</mo>
<mn>0.</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<times></times>
<mtext>log</mtext>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>œÄ</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<mtext>log</mtext>
<apply>
<times></times>
<ci>K</ci>
<ci>z</ci>
</apply>
</apply>
<apply>
<minus></minus>
<ci>z</ci>
<ci>k</ci>
</apply>
</apply>
<mtext>d</mtext>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<lt></lt>
<apply>
<times></times>
<mtext>Im</mtext>
<ci>k</ci>
</apply>
<cn type="float">0.</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hbox{log}K^{+}=-\frac{1}{2\pi i}\int_{-\infty}^{\infty}\frac{\hbox{log}(K(z))%
}{z-k}\textrm{d}z,\quad\hbox{Im}k&lt;0.
  </annotation>
</semantics>
</math>
</p>

<p>(Note that this sometimes involves scaling 

<math display="inline" id="Wiener‚ÄìHopf_method:46">
<semantics>
<mi>K</mi>
<annotation-xml encoding="MathML-Content">
<ci>K</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   K
  </annotation>
</semantics>
</math>

 so that it tends to 

<math display="inline" id="Wiener‚ÄìHopf_method:47">
<semantics>
<mn>1</mn>
<annotation-xml encoding="MathML-Content">
<cn type="integer">1</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   1
  </annotation>
</semantics>
</math>

 as 

<math display="inline" id="Wiener‚ÄìHopf_method:48">
<semantics>
<mrow>
<mi>k</mi>
<mo>‚Üí</mo>
<mi mathvariant="normal">‚àû</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-‚Üí</ci>
<ci>k</ci>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k\rightarrow\infty
  </annotation>
</semantics>
</math>

.) We also decompose 

<math display="inline" id="Wiener‚ÄìHopf_method:49">
<semantics>
<mrow>
<msup>
<mi>K</mi>
<mo>+</mo>
</msup>
<mover accent="true">
<mi>g</mi>
<mo stretchy="false">^</mo>
</mover>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
<apply>
<ci>normal-^</ci>
<ci>g</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K^{+}\hat{g}
  </annotation>
</semantics>
</math>


 into the sum of two functions 

<math display="inline" id="Wiener‚ÄìHopf_method:50">
<semantics>
<msup>
<mi>G</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>G</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G^{+}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Wiener‚ÄìHopf_method:51">
<semantics>
<msup>
<mi>G</mi>
<mo>-</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>G</ci>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G^{-}
  </annotation>
</semantics>
</math>

 which are analytic in the lower and upper half-planes respectively ‚Äì i.e.,</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Wiener‚ÄìHopf_method:52">
<semantics>
<mrow>
<mrow>
<mrow>
<msup>
<mi>K</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
<mover accent="true">
<mi>g</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msup>
<mi>G</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msup>
<mi>G</mi>
<mo>-</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
<ci>k</ci>
<apply>
<ci>normal-^</ci>
<ci>g</ci>
</apply>
<ci>k</ci>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>G</ci>
<plus></plus>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>G</ci>
<minus></minus>
</apply>
<ci>k</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K^{+}(k)\hat{g}(k)=G^{+}(k)+G^{-}(k).
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>

<p>This can be done in the same way that we factorised 

<math display="inline" id="Wiener‚ÄìHopf_method:53">
<semantics>
<mrow>
<mrow>
<mi>K</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>K</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K(k).
  </annotation>
</semantics>
</math>

 Consequently,</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:54">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<msup>
<mi>G</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>K</mi>
<mo>+</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>+</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<mrow>
<msubsup>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>-</mo>
<mo>‚Ä≤</mo>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>/</mo>
<msub>
<mi>K</mi>
<mo>-</mo>
</msub>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<msup>
<mi>G</mi>
<mo>-</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>G</ci>
<plus></plus>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
<ci>k</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<plus></plus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<ci>normal-‚Ä≤</ci>
</apply>
<minus></minus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>K</ci>
<minus></minus>
</apply>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>G</ci>
<minus></minus>
</apply>
<ci>k</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G^{+}(k)+K_{+}(k)\hat{f}_{+}(k,0)=\hat{f}^{\prime}_{-}(k,0)/K_{-}(k)-G^{-}(k).
  </annotation>
</semantics>
</math>
</p>

<p>Now, as the left-hand side of the above equation is analytic in the lower half-plane, whilst the right-hand side is analytic in the upper half-plane, analytic continuation guarantees existence of an entire function which coincides with the left- or right-hand sides in their respective half-planes. Furthermore, since it can be shown that the functions on either side of the above equation decay at large 

<math display="inline" id="Wiener‚ÄìHopf_method:55">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

, an application of <a href="Liouville's_theorem_(complex_analysis)" title="wikilink">Liouville's theorem</a> shows that this entire function is identically zero, therefore</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:56">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mover accent="true">
<mi>f</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>+</mo>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mfrac>
<mrow>
<msup>
<mi>G</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<msup>
<mi>K</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>f</ci>
</apply>
<plus></plus>
</apply>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>G</ci>
<plus></plus>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{f}_{+}(k,0)=-\frac{G^{+}(k)}{K^{+}(k)},
  </annotation>
</semantics>
</math>
</p>

<p>and so</p>

<p>
<math display="block" id="Wiener‚ÄìHopf_method:57">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>C</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mfrac>
<mrow>
<mrow>
<msup>
<mi>K</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
<mover accent="true">
<mi>g</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<msup>
<mi>G</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mrow>
<msup>
<mi>K</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>C</ci>
<ci>k</ci>
</apply>
<apply>
<divide></divide>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
<ci>k</ci>
<apply>
<ci>normal-^</ci>
<ci>g</ci>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>G</ci>
<plus></plus>
</apply>
<ci>k</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<plus></plus>
</apply>
<ci>k</ci>
<ci>F</ci>
<interval closure="open">
<ci>k</ci>
<cn type="integer">0</cn>
</interval>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C(k)=\frac{K^{+}(k)\hat{g}(k)-G^{+}(k)}{K^{+}(k)F(k,0)}.
  </annotation>
</semantics>
</math>
</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Wiener_filter" title="wikilink">Wiener filter</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.wikiwaves.org/Category:Wiener-Hopf">Wiener‚ÄìHopf method</a> at Wikiwaves</li>
</ul>

<p>"</p>

<p><a href="Category:Partial_differential_equations" title="wikilink">Category:Partial differential equations</a></p>
</body>
</html>
