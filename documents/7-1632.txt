   Advantage (cryptography)      Advantage (cryptography)   In cryptography , an adversary's advantage is a measure of how successfully it can attack a cryptographic algorithm , by distinguishing it from an idealized version of that type of algorithm. Note that in this context, the " adversary " is itself an algorithm and not a person . A cryptographic algorithm is considered secure if no adversary has a non-negligible advantage, subject to specified bounds on the adversary's computational resources (see concrete security ). "Negligible" usually means "within O (2 −p )" where p is a security parameter associated with the algorithm. For example, p might be the number of bits in a block cipher's key .  Description of concept  Let F be an oracle for the function being studied, and let G be an oracle for an idealized function of that type. The adversary A is a probabilistic algorithm given F or G as input and which outputs 1 or 0. A's job is to distinguish F from G based on making queries to the oracle that it's given. We say:     A  d  v   (  A  )    =   |    Pr   [    A   (  F  )    =  1   ]    -   Pr   [    A   (  G  )    =  1   ]     |         A  d  v  A        Pr      A  F   1     Pr      A  G   1        Adv(A)=|\Pr[A(F)=1]-\Pr[A(G)=1]|     Examples  Let F be a random instance of the DES  block cipher . This cipher has 64-bit blocks and a 56-bit key. The key therefore selects one of a family of 2 56  permutations on the 2 64 possible 64-bit blocks. A "random DES instance" means our oracle F computes DES using some key K (which is unknown to the adversary) where K is selected from the 2 56 possible keys with equal probability.  We want to compare the DES instance with an idealized 64-bit block cipher, meaning a permutation selected at random from the (2 64 ) ! possible permutations on 64-bit blocks. Call this randomly selected permutation G. Note from Stirling's approximation that (2 64 )! is around    10   3.47  ×   10  20       superscript  10    3.47   superscript  10  20      10^{3.47\times 10^{20}}   , so even specifying which permutation is selected requires writing down a number too large to represent exactly in any real computer. Viewed another way, G is an instance of a "cipher" whose "key length" is about 10 21 bits, which again is too large to fit in a computer. (We can, however, implement G with storage space proportional to the number of queries, using a random oracle ).  Note that because the oracles we're given encrypt plaintext of our choosing, we're modelling a chosen-plaintext attack or CPA , and the advantage we're calculating can be called the CPA-advantage of a given adversary. If we also had decryption oracles available, we'd be doing a chosen-ciphertext attack or CCA and finding the CCA-advantage of the adversary.  Example 1: Guess at random  Call this adversary A 0 . It simply flips a coin and returns 1 or 0 with equal probability and without making any oracle calls. Thus, Pr[A 0 (F)=1] and Pr[A 0 (G)=1] are both 0.5. The difference between these probabilities is zero, so Adv(A 0 ) is zero. The same thing applies if we always return 0, or always return 1: the probability is the same for both F and G, so the advantage is zero. This adversary can't tell F and G apart. If we're cipher designers, our desire (maybe not achievable) is to make it so that it's computationally infeasible for any adversary to do significantly better than this. We will have succeeded if we can make a cipher for which there's no distinguisher faster than brute force search.  Example 2: Brute force search  This adversary (call it A 1 ) will attempt to cryptanalyze its input by brute force . It has its own DES implementation. It gives a single query to its oracle, asking for the 64-bit string of all zeroes to be encrypted. Call the resulting ciphertext E 0 . It then runs an exhaustive key search. The algorithm looks like this:  E 0 = oracle_query(0)  for k in 0,1,...,2 56 -1:  if DES k (0) == E 0 :  return 1  return 0  This searches the entire 56-bit DES keyspace and returns "1" if it probably finds a matching key. In practice, several plaintexts are required to confirm the key, as two different keys can result in one or more matching plaintext-ciphertext pairs. If no key is found, it returns 0.  If the input oracle is DES, this exhaustive search is certain to find the key, so Pr[A 1 (F)=1] = 1. If the input oracle is a random permutation, there are 2 64 possible values of E 0 , and at most 2 56 of them will get examined in the DES keysearch. So the probability of A 1 returning 1 is at most 2 −8 . That is:  Pr[A 1 (G)=1] −8, so  Adv(A 1 ) = |Pr[A 1 (F)=1] - Pr[A 1 (G)=1]| >= 1 - 2 −8  so the advantage is at least about 0.996. This is a near-certain distinguisher, but it's not a security failure because it's no faster than brute force search, after all, it is the brute force search.  See also   Pseudorandom-function advantage  Key-recovery advantage  PR-CPA advantage   References   Phillip Rogaway and Mihir Bellare , Introduction to Modern Cryptography  Oded Goldreich, Foundations of Cryptography (Fragments of a Book)   "  Category:Theory of cryptography   