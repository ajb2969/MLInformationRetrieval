<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1640">Evidence-based subjective logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Evidence-based subjective logic</h1>
<hr/>

<p><strong>Evidence-based subjective logic (EBSL)</strong> is a variant <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> of <a href="subjective_logic" title="wikilink">subjective logic</a> in which the transitivity of opinions (discounting) is handled by applying weights to the evidence underlying the opinions. Subjective Logic is based on <a href="Dempster-Shafer_theory" title="wikilink">Dempster–Shafer belief theory</a>. The discounting rule in EBSL makes it possible to handle arbitrary trust networks.</p>
<h2 id="relation-between-evidence-and-opinions">Relation between evidence and opinions</h2>

<p>Consider a <a href="Proposition#Treatment_in_logic" title="wikilink">proposition</a> P. Let <em>p</em> be the amount of evidence supporting P, and <em>n</em> the amount of evidence supporting ¬P. We write the evidence as a vector (<em>p</em>, <em>n</em>). Let <em>c</em> be a positive constant representing a "unit" of evidence. An <a href="Subjective_Logic#Subjective_opinions" title="wikilink">opinion</a> (<em>b</em>, <em>d</em>, <em>u</em>) is formed on the basis of the evidence (<em>p</em>, <em>n</em>). There is a one-to-one mapping between the opinion and the evidence,</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mo>+</mo>
     <mi>n</mi>
     <mo>+</mo>
     <mi>c</mi>
    </mrow>
   </mfrac>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>c</mi>
   <mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>d</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>u</mi>
   </mfrac>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <vector>
      <ci>p</ci>
      <ci>n</ci>
      <ci>c</ci>
     </vector>
     <apply>
      <plus></plus>
      <ci>p</ci>
      <ci>n</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">c</csymbol>
    <apply>
     <divide></divide>
     <interval closure="open">
      <ci>b</ci>
      <ci>d</ci>
     </interval>
     <ci>u</ci>
    </apply>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b,d,u)=\frac{(p,n,c)}{p+n+c}\quad\quad(p,n)=c\frac{(b,d)}{u}.\quad\quad(1)
  </annotation>
 </semantics>
</math>

</p>

<p>In the original literature on subjective logic the constant was set to <em>c</em> = 2. The mapping (1) is the unique solution of the following set of constraints,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<ul>
<li><em>b</em>/<em>d</em> = <em>p</em>/<em>n</em>.</li>
<li><em>b</em> + <em>d</em> + <em>u</em> = 1.</li>
<li><em>p</em> + <em>n</em> = 0 implies <em>u</em> = 1.</li>
<li>

<math display="inline" id="Evidence-based_subjective_logic:1">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\to\infty
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Evidence-based_subjective_logic:2">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>u</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\to 0
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Alternatively, (1) can be derived from an analysis of <a href="Posterior_probability" title="wikilink">a posteriori probability</a> distributions<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> (<a href="beta_distribution" title="wikilink">beta distributions</a>).<br/>
There are three "corner points" in opinion space: the full Belief B = (1,0,0), the full Disbelief D = (0,1,0), and full Uncertainty U = (0,0,1). Opinions on the line between B and D (including B and D) are called "dogmatic opinions". They have zero uncertainty, which is achievable only with an infinite amount of evidence. Dogmatic opinions are often excluded from the algebra.</p>
<h2 id="consensus-fusion">Consensus / fusion</h2>

<p>The consensus operation combines two opinions about the same predicate into one opinion by piling up the evidence. Let <em>x</em> = (<em>x</em><sub>b</sub>,<em>x</em><sub>d</sub>,<em>x</em><sub>u</sub>) and <em>y</em> = (<em>y</em><sub>b</sub>,<em>y</em><sub>d</sub>,<em>y</em><sub>u</sub>) be the opinions that are to be fused, and <em>z</em> = <em>x</em> ⊕ <em>y</em> the result. We denote their evidence vectors as (<em>p</em><sub><em>x</em></sub>, <em>n</em><sub><em>x</em></sub>), (<em>p</em><sub><em>y</em></sub>, <em>n</em><sub><em>y</em></sub>) and (<em>p</em><sub><em>z</em></sub>, <em>n</em><sub><em>z</em></sub>) respectively. In evidence space the consensus is straightforwardly defined as</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>p</mi>
      <mi>z</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mi>z</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mi>x</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mi>x</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mi>y</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mi>y</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>z</ci>
     </apply>
    </interval>
    <apply>
     <plus></plus>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>x</ci>
      </apply>
     </interval>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>y</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p_{z},n_{z})=(p_{x},n_{x})+(p_{y},n_{y}).
  </annotation>
 </semantics>
</math>

</p>

<p>In opinion space this yields</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>⊕</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>x</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>p</mi>
       <mi>y</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>n</mi>
       <mi>x</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>n</mi>
       <mi>y</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>x</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>p</mi>
      <mi>y</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>n</mi>
      <mi>x</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>n</mi>
      <mi>y</mi>
     </msub>
     <mo>+</mo>
     <mi>c</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <divide></divide>
     <vector>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </vector>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>y</ci>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\oplus y=\frac{(p_{x}+p_{y},n_{x}+n_{y},c)}{p_{x}+p_{y}+n_{x}+n_{y}+c}
  </annotation>
 </semantics>
</math>

</p>

<p>which using (1) can be rewritten as</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:5">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>⊕</mo>
   <mi>y</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi mathvariant="normal">u</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi mathvariant="normal">b</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi mathvariant="normal">u</mi>
       </msub>
       <msub>
        <mi>x</mi>
        <mi mathvariant="normal">b</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi mathvariant="normal">u</mi>
       </msub>
       <msub>
        <mi>y</mi>
        <mi mathvariant="normal">d</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi mathvariant="normal">u</mi>
       </msub>
       <msub>
        <mi>x</mi>
        <mi mathvariant="normal">d</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi mathvariant="normal">u</mi>
      </msub>
      <msub>
       <mi>y</mi>
       <mi mathvariant="normal">u</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi mathvariant="normal">u</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>y</mi>
       <mi mathvariant="normal">u</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi mathvariant="normal">u</mi>
      </msub>
      <msub>
       <mi>y</mi>
       <mi mathvariant="normal">u</mi>
      </msub>
     </mrow>
    </mrow>
   </mfrac>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="latexml">direct-sum</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <eq></eq>
    <apply>
     <divide></divide>
     <vector>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>normal-u</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>normal-b</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>normal-u</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>normal-b</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>normal-u</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>normal-d</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>normal-u</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>normal-d</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>normal-u</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>normal-u</ci>
       </apply>
      </apply>
     </vector>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>normal-u</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>normal-u</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>normal-u</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>normal-u</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\oplus y=\frac{(x_{\rm u}y_{\rm b}+y_{\rm u}x_{\rm b},x_{\rm u}y_{\rm d}+y_{%
\rm u}x_{\rm d},x_{\rm u}y_{\rm u})}{x_{\rm u}+y_{\rm u}-x_{\rm u}y_{\rm u}}.%
\quad\quad(2)
  </annotation>
 </semantics>
</math>

</p>

<p>The consensus rule can only be applied if the evidence underlying <em>x</em> and <em>y</em> is independent, otherwise <em>double counting</em> of evidence occurs.</p>
<h2 id="discounting">Discounting</h2>
<h3 id="old-discounting-rule">Old discounting rule (⊗)</h3>

<p>The traditional discounting operation in Subjective Logic is denoted as ⊗ and defined as</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>⊗</mo>
     <mi>y</mi>
    </mrow>
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">x</mi>
       <mi mathvariant="normal">b</mi>
      </msub>
      <msub>
       <mi mathvariant="normal">y</mi>
       <mi mathvariant="normal">b</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">x</mi>
       <mi mathvariant="normal">b</mi>
      </msub>
      <msub>
       <mi mathvariant="normal">y</mi>
       <mi mathvariant="normal">d</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi mathvariant="normal">x</mi>
        <mi mathvariant="normal">b</mi>
       </msub>
       <msub>
        <mi mathvariant="normal">y</mi>
        <mi mathvariant="normal">b</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi mathvariant="normal">x</mi>
        <mi mathvariant="normal">b</mi>
       </msub>
       <msub>
        <mi mathvariant="normal">y</mi>
        <mi mathvariant="normal">d</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <vector>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-x</ci>
       <ci>normal-b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-y</ci>
       <ci>normal-b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-x</ci>
       <ci>normal-b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-y</ci>
       <ci>normal-d</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-x</ci>
        <ci>normal-b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-y</ci>
        <ci>normal-b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-x</ci>
        <ci>normal-b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-y</ci>
        <ci>normal-d</ci>
       </apply>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\otimes y\stackrel{\rm def}{=}(x_{\rm b}y_{\rm b},x_{\rm b}y_{\rm d},1-x_{\rm
b%
}y_{\rm b}-x_{\rm b}y_{\rm d}).
  </annotation>
 </semantics>
</math>

<br/>
This operation suffers from a number of serious problems, e.g.</p>
<ul>
<li>There is no natural interpretation of the evidence underlying <em>x</em> ⊗ <em>y</em> when (1) is applied.</li>
</ul>
<ul>
<li>Consider the following. Alice has trust <em>x</em> in Bob. Bob gathers two independent evidence vectors, (<em>p</em><sub>1</sub>, <em>n</em><sub>1</sub>) and (<em>p</em><sub>2</sub>, <em>n</em><sub>2</sub>), about some proposition P.<br/>
 Scenario I: Bob forms two indendent opinions, <em>y</em><sub>1</sub> and <em>y</em><sub>2</sub>, based on the evidence. He sends <em>y</em><sub>1</sub> and <em>y</em><sub>2</sub> to Alice. Alice forms opinion 

<math display="inline" id="Evidence-based_subjective_logic:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>x</mi>
     <mo>⊗</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊕</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>x</mi>
     <mo>⊗</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\otimes y_{1})\oplus(x\otimes y_{2})
  </annotation>
 </semantics>
</math>

 about P.<br/>
 Scenario II: Bob combines his evidence and forms opinion 

<math display="inline" id="Evidence-based_subjective_logic:8">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>⊕</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}\oplus y_{2}
  </annotation>
 </semantics>
</math>

. He then sends 

<math display="inline" id="Evidence-based_subjective_logic:9">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>⊕</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}\oplus y_{2}
  </annotation>
 </semantics>
</math>

 to Alice. Alice forms opinion 

<math display="inline" id="Evidence-based_subjective_logic:10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>⊗</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>⊕</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\otimes(y_{1}\oplus y_{2})
  </annotation>
 </semantics>
</math>

 about P.<br/>
 It is obvious that these scenarios should yield the same result for Alice. Yet the traditional discounting rule gives:<math></math></li>
</ul>

<p>x\otimes(y_1\oplus y_2)\neq (x\otimes y_1)\oplus(x\otimes y_2).  These problems make it very difficult to handle trust networks in subjective logic.</p>
<h3 id="the-product-of-a-scalar-and-an-opinion">The product of a scalar and an opinion</h3>

<p>Let <em>x</em> = (<em>x</em><sub>b</sub>, <em>x</em><sub>d</sub>, <em>x</em><sub>u</sub>) be an opinion based on evidence (<em>p</em>, <em>n</em>). Let λ ≥ 0 be a scalar. The product λ ⋅ <em>x</em> is defined<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> as (λ <em>p</em>, λ <em>n</em>) in evidence space, which corresponds to</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mo>⋅</mo>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <msub>
        <mi>x</mi>
        <mi mathvariant="normal">b</mi>
       </msub>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>λ</mi>
       <msub>
        <mi>x</mi>
        <mi mathvariant="normal">d</mi>
       </msub>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi mathvariant="normal">u</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mrow>
       <mi>λ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi mathvariant="normal">b</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>x</mi>
          <mi mathvariant="normal">d</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <msub>
       <mi>x</mi>
       <mi mathvariant="normal">u</mi>
      </msub>
     </mrow>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <list>
     <apply>
      <divide></divide>
      <vector>
       <apply>
        <times></times>
        <ci>λ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>normal-b</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>λ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>normal-d</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>normal-u</ci>
       </apply>
      </vector>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>λ</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>normal-b</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>normal-d</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>normal-u</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">3</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\cdot x=\frac{(\lambda x_{\rm b},\lambda x_{\rm d},x_{\rm u})}{\lambda(%
x_{\rm b}+x_{\rm d})+x_{\rm u}}\quad\quad(3)
  </annotation>
 </semantics>
</math>

</p>

<p>in opinion space.</p>
<h3 id="the-discounting-rule-in-ebsl">The discounting rule (☒) in EBSL</h3>

<p>Let <em>x</em> and <em>y</em> be opinions. Let <em>g</em> be a mapping from opinion space to [0,1] satisfying <em>g</em>(B) = 1 and <em>g</em>(D) = 0.</p>

<p>In EBSL the discounting of <em>y</em> through <em>x</em> is denoted as <em>x</em> ☒ <em>y</em> and defined as<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="block" id="Evidence-based_subjective_logic:12">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="10pt" width="+10pt">
     <mi>x</mi>
    </mpadded>
    <mo>⊠</mo>
    <mi>y</mi>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mi>def</mi>
   </mover>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi mathvariant="normal">x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi mathvariant="normal">y</mi>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>4</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <ci>normal-⊠</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <list>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>normal-g</ci>
       <ci>normal-x</ci>
      </apply>
      <ci>normal-y</ci>
     </apply>
     <cn type="integer">4</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad x\boxtimes y\stackrel{\rm def}{=}g(x)\cdot y,\quad\quad(4)
  </annotation>
 </semantics>
</math>

</p>

<p>with the "dot" product as specified in (3).</p>

<p>The function <em>g</em> can be chosen at will, depending on the context. The ☒ rule has a very simple interpretation in evidence space: Due to the disbelief and uncertainty present in <em>x</em>, only a fraction <em>g</em>(<em>x</em>) of the evidence in <em>y</em> survives.</p>

<p>The ☒ operation avoids all the inconsistencies of the ⊗ operation. The following properties hold,</p>
<ul>
<li>

<math display="inline" id="Evidence-based_subjective_logic:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>⊠</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>⊕</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>⊠</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>⊠</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⊠</ci>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <ci>normal-⊠</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⊠</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\boxtimes(y_{1}\oplus y_{2})=(x\boxtimes y_{1})\oplus(x\boxtimes y_{2})
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li>

<math display="inline" id="Evidence-based_subjective_logic:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>⊠</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>⊠</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>⊠</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>⊠</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⊠</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>normal-⊠</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⊠</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>normal-⊠</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\boxtimes(x_{2}\boxtimes y)=x_{2}\boxtimes(x_{1}\boxtimes y)
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>There is no <a href="Associative_property" title="wikilink">associativity</a>, i.e. 

<math display="inline" id="Evidence-based_subjective_logic:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>⊠</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>⊠</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>⊠</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊠</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <ci>normal-⊠</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>normal-⊠</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⊠</ci>
     <apply>
      <ci>normal-⊠</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\boxtimes(x_{2}\boxtimes y)\neq(x_{1}\boxtimes x_{2})\boxtimes y
  </annotation>
 </semantics>
</math>

, in contrast to the ⊗ operation. This is not a problem, since the flow if information in a trust network has a well defined direction.</p>

<p>Also, we have</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>⊕</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⊠</mo>
     <mi>y</mi>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>⊠</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⊕</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>⊠</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <ci>normal-⊠</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <ci>normal-⊠</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <ci>normal-⊠</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1}\oplus x_{2})\boxtimes y\neq(x_{1}\boxtimes y)\oplus(x_{2}\boxtimes y).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="computation-of-opinions-in-arbitrary-trust-networks">Computation of opinions in arbitrary trust networks</h2>

<p>EBSL makes it possible to compute <a href="Trust_metric" title="wikilink">trust values</a> even when the graph connecting the users in the trust network is complicated. This makes EBSL interesting e.g. for <a href="Reputation_system" title="wikilink">Reputation systems</a></p>

<p>Let <em>A</em><sub><em>ij</em></sub> be the opinion that user <em>i</em> has about the trustworthiness of user <em>j</em>, based on <em>direct evidence</em>, e.g. direct interactions between <em>i</em> and <em>j</em>. We set <em>A</em><sub><em>ii</em></sub> = U. Let every user publish these direct opinions in a reliable way; the matrix <em>A</em> is public and its integrity is guaranteed.<br/>
Based on all the available trust information, direct as well as indirect, what should a user conclude about the trustworthiness of all the other users? In general this is a nontrivial problem because of the complicated connection graphs, in which loops may occur. The problem is to find a "reputation" matrix <em>R</em> that consistently combines the direct and indirect evidence. In EBSL the following "self-consistent" (self-containing) equation must be satisfied<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> by <em>R</em>,</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:17">
 <semantics>
  <mrow>
   <mtext>For</mtext>
   <mi>i</mi>
   <mo>≠</mo>
   <mi>j</mi>
   <mo>:</mo>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>⊕</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>k</mi>
     <mo rspace="4.2pt">:</mo>
     <mrow>
      <mi>k</mi>
      <mo>≠</mo>
      <mi>i</mi>
     </mrow>
    </mrow>
   </munder>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>i</mi>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>⊠</mo>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>k</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>5</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>For</mtext>
    <csymbol cd="unknown">i</csymbol>
    <neq></neq>
    <csymbol cd="unknown">j</csymbol>
    <ci>normal-:</ci>
    <ci></ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <ci>normal-:</ci>
      <ci>k</ci>
      <apply>
       <neq></neq>
       <ci>k</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>normal-⊠</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">5</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{For }i\neq j:\quad R_{ij}=A_{ij}\oplus\sum_{k:\,k\neq i}R_{ik}\boxtimes A%
_{kj}\quad\quad(5)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>Diagonal:</mtext>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>i</mi>
       <mi>i</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mi>B</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Diagonal:</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Diagonal: }R_{ii}=B.
  </annotation>
 </semantics>
</math>

</p>

<p>Here the "Σ" stands for ⊕ operations. The diagonal is set to full belief since everybody trusts himself implicitly, independent of other users' opinions.<br/>
User <em>i</em> forms an opinion about <em>j</em> by combining his direct opinion <em>A</em><sub>ij</sub> with other users' opinions <em>A</em><sub>kj</sub>. The indirect evidence is weighted with a scalar that depends on the reputation of the intermediary: <em>g</em>(<em>R</em><sub>ik</sub>).</p>

<p>Equation (5) can be written compactly in matrix form,</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:19">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mi>B</mi>
   <mn>𝟏</mn>
   <mo>⊕</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>⊠</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>6</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">B</csymbol>
    <cn type="integer">1</cn>
    <csymbol cd="latexml">direct-sum</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-⊠</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">6</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=B{\mathbf{1}}\oplus(R\boxtimes A).\quad\quad(6)
  </annotation>
 </semantics>
</math>

<br/>
Here 

<math display="inline" id="Evidence-based_subjective_logic:20">
 <semantics>
  <mn>𝟏</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{1}}
  </annotation>
 </semantics>
</math>

 is the <a href="identity_matrix" title="wikilink">identity matrix</a>, and summation should be executed as ⊕. Eq.(6) is a <a href="Fixed_point_(mathematics)" title="wikilink">fixed point</a> equation similar to the case of <a href="Markov_chain" title="wikilink">Markov chains</a>. It can be solved <a href="Fixed-point_iteration" title="wikilink">recursively</a>. Let <em>X</em> be a square matrix with the same dimensions as <em>A</em>. Define a function f as</p>

<p>

<math display="block" id="Evidence-based_subjective_logic:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mn>𝟏</mn>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>⊠</mo>
      <mi>A</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>normal-⊠</ci>
      <ci>X</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X)=B{\mathbf{1}}\oplus(X\boxtimes A)
  </annotation>
 </semantics>
</math>

.</p>

<p>Pick a starting matrix 

<math display="inline" id="Evidence-based_subjective_logic:22">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}
  </annotation>
 </semantics>
</math>

 and repeatedly apply f until the result does not change any more, i.e. a fixed point 

<math display="inline" id="Evidence-based_subjective_logic:23">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=f(R)
  </annotation>
 </semantics>
</math>

 is reached. Independent of the choice of 

<math display="inline" id="Evidence-based_subjective_logic:24">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}
  </annotation>
 </semantics>
</math>

, after one iteration the diagonal is B<strong>1</strong> and stays B<strong>1</strong> in all further iterations.<br/>
If Eq.(6) were an ordinary matrix equation 

<math display="inline" id="Evidence-based_subjective_logic:25">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mn>𝟏</mn>
    <mo>+</mo>
    <mrow>
     <mi>R</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R={\mathbf{1}}+RA
  </annotation>
 </semantics>
</math>

 for real-valued (or complex) <em>A</em><sub>ij</sub>, it would have solution 

<math display="inline" id="Evidence-based_subjective_logic:26">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>𝟏</mn>
      <mo>-</mo>
      <mi>A</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mn>𝟏</mn>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>A</mi>
      <mi>k</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>A</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <geq></geq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=({\mathbf{1}}-A)^{-1}={\mathbf{1}}+\sum_{k\geq 1}A^{k}
  </annotation>
 </semantics>
</math>

. However, the opinion algebra does not allow for such a simple expression. Instead we have</p>

<p>         f<sup>2</sup>(<em>X</em><sub>0</sub>) = B<strong>1</strong> ⊕ ((B<strong>1</strong> ⊕ (<em>X</em><sub>0</sub> ☒ <em>A</em>)) ☒ <em>A</em>)</p>

<p>         f<sup>3</sup>(<em>X</em><sub>0</sub>) = B<strong>1</strong> ⊕ ((B<strong>1</strong> ⊕ ( B<strong>1</strong> ⊕ (<em>X</em><sub>0</sub> ☒ <em>A</em>) ☒ <em>A</em>)) ☒ <em>A</em>)</p>

<p>         ...</p>

<p>which in general cannot be simplified.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Probability_theory" title="wikilink">Category:Probability theory</a> <a href="Category:Non-classical_logic" title="wikilink">Category:Non-classical logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">B. Skoric, S.J.A. de Hoogh, N. Zannone. <em>Flow-based reputation with uncertainty: Evidence-Based Subjective Logic</em>. 2014. <a class="uri" href="http://arxiv.org/abs/1402.3319">http://arxiv.org/abs/1402.3319</a><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3">A. Jøsang. A Logic for Uncertain Probabilities. <em><a href="International_Journal_of_Uncertainty,_Fuzziness_and_Knowledge-Based_Systems" title="wikilink">International Journal of Uncertainty, Fuzziness and Knowledge-Based Systems</a>.</em> 9(3), pp. 279–311, June 2001. <a href="http://www.unik.no/people/josang/papers/Jos2001-IJUFKS.pdf">PDF</a><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
</ol>
</section>
</body>
</html>
