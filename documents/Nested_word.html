<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="988">Nested word</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Nested word</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, more specifically in <a href="automata_theory" title="wikilink">automata</a> and <a href="formal_language" title="wikilink">formal language</a> theory, <strong>nested words</strong> are a concept proposed by <a href="Rajeev_Alur" title="wikilink">Alur</a> and Madhusudan as a joint generalization of <a href="String_(computer_science)" title="wikilink">words</a>, as traditionally used for modelling <a href="linearly_ordered" title="wikilink">linearly ordered</a> structures, and of ordered unranked <a href="Tree_(data_structure)" title="wikilink">trees</a>, as traditionally used for modelling hierarchical structures. Finite-state acceptors for nested words, so-called <strong>nested word automata</strong>, then give a more expressive generalization of <a href="nondeterministic_finite_automaton" title="wikilink">finite automata</a> on words. The linear encodings of languages accepted by finite nested word automata gives the class of <strong>visibly pushdown languages</strong>. The latter language class lies properly between the <a href="regular_language" title="wikilink">regular languages</a> and the <a href="deterministic_context-free_language" title="wikilink">deterministic context-free languages</a>. Since their introduction in 2004, these concepts have triggered much research in that area.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="formal-definition">Formal definition</h2>

<p>To define <em>nested words</em>, we first need to define <em>matching relation</em>. As usual, for a <a href="nonnegative_integer" title="wikilink">nonnegative integer</a> 

<math display="inline" id="Nested_word:0">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

, we use the notation 

<math display="inline" id="Nested_word:1">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi mathvariant="normal">ℓ</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\ell]
  </annotation>
 </semantics>
</math>

 to denote the set 

<math display="inline" id="Nested_word:2">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">ℓ</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">ℓ</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <ci>normal-ℓ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-ℓ</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,2,\ldots,\ell-1,\ell\}
  </annotation>
 </semantics>
</math>

, with the special case 

<math display="inline" id="Nested_word:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <cn type="integer">0</cn>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0]=\emptyset
  </annotation>
 </semantics>
</math>

.</p>

<p>A <em>matching relation</em> ↝ of length 

<math display="inline" id="Nested_word:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">ℓ</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>normal-ℓ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell\geq 0
  </annotation>
 </semantics>
</math>

 is a subset of 

<math display="inline" id="Nested_word:5">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">ℓ</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">ℓ</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">ℓ</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">ℓ</mi>
    <mo>,</mo>
    <mi mathvariant="normal">∞</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <set>
     <apply>
      <minus></minus>
      <infinity></infinity>
     </apply>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>normal-ℓ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-ℓ</ci>
    </set>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>normal-ℓ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-ℓ</ci>
     <infinity></infinity>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{-\infty,1,2,\ldots,\ell-1,\ell\}\times\{1,2,\ldots,\ell-1,\ell,\infty\}
  </annotation>
 </semantics>
</math>

 such that:</p>
<ol>
<li>all nesting edges are forward, that is, if <em>i</em> ↝ <em>j</em> then <em>i</em>&lt;<em>j</em>;</li>
<li>nesting edges never have a finite position in common, that is, for -∞ &lt; <em>i</em> &lt; ∞, there is at most one position <em>h</em> such that <em>h</em> ↝ <em>i</em>, and there is at most one position <em>j</em> such that <em>i</em> ↝ <em>j</em>; and</li>
<li>nesting edges never cross, that is, we can't find <em>i</em>&lt;<em>i</em>’≤<em>j</em>&lt;<em>j</em>’ such that both <em>i</em> ↝ <em>j</em> and <em>i</em>’ ↝ <em>j</em>’.</li>
</ol>

<p>A position <em>i</em> is referred to as</p>
<ul>
<li>a <em>call position</em>, if <em>i</em> ↝ <em>j</em> for some <em>j</em>,</li>
<li>a <em>pending call</em> if <em>i</em> ↝ ∞,</li>
<li>a <em>return position</em>, if <em>h</em> ↝ <em>i</em> for some <em>h</em>,</li>
<li>a <em>pending return</em> if -∞ ↝ <em>i</em>, and</li>
<li>an <em>internal position</em> in all remaining cases.</li>
</ul>

<p>A <em>nested word</em> of length 

<math display="inline" id="Nested_word:6">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 over an <a href="alphabet_(computer_science)" title="wikilink">alphabet</a> Σ is a pair (<em>w</em>,↝), where <em>w</em> is a word of length 

<math display="inline" id="Nested_word:7">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

over Σ (in the usual sense) and ↝ is a matching relation of length 

<math display="inline" id="Nested_word:8">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="encoding-nested-words-into-ordinary-words">Encoding nested words into ordinary words</h2>

<p>Nested words over the alphabet 

<math display="inline" id="Nested_word:9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Σ</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma=\{a_{1},a_{2},\ldots,a_{n}\}
  </annotation>
 </semantics>
</math>

 can be encoded into "ordinary" words over the <em>tagged alphabet</em> 

<math display="inline" id="Nested_word:10">
 <semantics>
  <mover accent="true">
   <mi mathvariant="normal">Σ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Sigma}
  </annotation>
 </semantics>
</math>

, in which each symbol <em>a</em> from Σ has three tagged counterparts: the symbol <strong>⟨a</strong> for encoding a call position in a nested word labelled with <em>a</em>, the symbol <strong>a⟩</strong> for encoding a return position labelled with <em>a</em>, and finally the symbol <strong>a</strong> itself for representing an internal position labelled with <em>a</em>. More precisely, let φ be the function mapping nested words over Σ to words over 

<math display="inline" id="Nested_word:11">
 <semantics>
  <mover accent="true">
   <mi mathvariant="normal">Σ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Sigma}
  </annotation>
 </semantics>
</math>

 such that each nested word (

<math display="inline" id="Nested_word:12">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>w</mi>
    <mn>2</mn>
   </msub>
   <mi mathvariant="normal">⋯</mi>
   <msub>
    <mi>w</mi>
    <mi mathvariant="normal">ℓ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>normal-ℓ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1}w_{2}\cdots w_{\ell}
  </annotation>
 </semantics>
</math>

,↝) is mapped to the word 

<math display="inline" id="Nested_word:13">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>x</mi>
    <mi mathvariant="normal">ℓ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>normal-ℓ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}x_{2}...x_{\ell}
  </annotation>
 </semantics>
</math>

, where the letter 

<math display="inline" id="Nested_word:14">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 equals <strong>⟨a</strong>, <strong>a</strong>, and <strong>a⟩</strong>, if 

<math display="inline" id="Nested_word:15">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}=a
  </annotation>
 </semantics>
</math>

 and <em>i</em> is a (possibly pending) call position, an internal position, and a (possibly pending) return position, respectively.</p>
<h3 id="example">Example</h3>

<p>For illustration, let <em>n=(w,↝)</em> be the nested word over an ternary alphabet with <em>w=abaabccca</em> and matching relation <em>↝ = {(-∞,1),(2,∞),(3,4),(5,7),(8,∞)}</em>. Then its encoding as word reads as <em>φ(n) = a⟩⟨b⟨aa⟩⟨bcc⟩⟨ca</em>.</p>
<h2 id="automata">Automata</h2>
<h3 id="nested-word-automaton">Nested word automaton</h3>

<p>A <em>nested word automaton</em> has a finite number of states, and operates in almost the same way as a <a href="deterministic_finite_automaton" title="wikilink">deterministic finite automaton</a> on classical strings: a classical finite automaton reads the input word 

<math display="inline" id="Nested_word:16">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mi>w</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>normal-ℓ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=w_{1}\cdots w_{\ell}
  </annotation>
 </semantics>
</math>

 from left to right, and the state of the automaton after reading the <em>j</em>th letter 

<math display="inline" id="Nested_word:17">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}
  </annotation>
 </semantics>
</math>

 depends on the state in which the automaton was before reading 

<math display="inline" id="Nested_word:18">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}
  </annotation>
 </semantics>
</math>

.</p>

<p>In a nested word automaton, the position 

<math display="inline" id="Nested_word:19">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 in the nested word (w,↝) might be a return position; if so, the state after reading 

<math display="inline" id="Nested_word:20">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}
  </annotation>
 </semantics>
</math>

 will not only depend on the <em>linear state</em> in which the automaton was before reading 

<math display="inline" id="Nested_word:21">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j}
  </annotation>
 </semantics>
</math>

, but also on a <em>hierarchical state</em> propagated by the automaton at the time it was in the corresponding call position. In analogy to <a href="regular_language" title="wikilink">regular languages</a> of words, a set <em>L</em> of nested words is called <em>regular</em> if it is accepted by some (finite-state) nested word automaton.</p>
<h3 id="visibly-pushdown-automaton">Visibly pushdown automaton</h3>

<p>Nested word automata are an automaton model accepting nested words. There is an equivalent automaton model operating on (ordinary) words. Namely, the notion of a <strong>deterministic visibly pushdown automaton</strong> is a restriction of the notion of a <a href="deterministic_pushdown_automaton" title="wikilink">deterministic pushdown automaton</a>.</p>

<p>Following Alur and Madhusudan,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> a deterministic visibly pushdown automaton is formally defined as a 6-tuple 

<math display="inline" id="Nested_word:22">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi mathvariant="normal">Σ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>,</mo>
    <mi mathvariant="normal">Γ</mi>
    <mo>,</mo>
    <mi>δ</mi>
    <mo>,</mo>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <vector>
     <ci>Q</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>normal-Σ</ci>
     </apply>
     <ci>normal-Γ</ci>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>F</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=(Q,\hat{\Sigma},\Gamma,\delta,q_{0},F)
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Nested_word:23">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is a finite set of <em>states</em>,</li>
<li>

<math display="inline" id="Nested_word:24">
 <semantics>
  <mover accent="true">
   <mi mathvariant="normal">Σ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Sigma}
  </annotation>
 </semantics>
</math>

 is the <em>input alphabet</em>, which – in contrast to that of ordinary pushdown automata – is partitioned into three sets 

<math display="inline" id="Nested_word:25">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mtext>c</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <mtext>c</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{\text{c}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Nested_word:26">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mtext>r</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <mtext>r</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{\text{r}}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Nested_word:27">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mtext>int</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <mtext>int</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{\text{int}}
  </annotation>
 </semantics>
</math>

. The alphabet 

<math display="inline" id="Nested_word:28">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mtext>c</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <mtext>c</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{\text{c}}
  </annotation>
 </semantics>
</math>

 denotes the set of <em>call symbols</em>, 

<math display="inline" id="Nested_word:29">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mtext>r</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <mtext>r</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{\text{r}}
  </annotation>
 </semantics>
</math>

 contains the <em>return symbols</em>, and the set 

<math display="inline" id="Nested_word:30">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mtext>int</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <mtext>int</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{\text{int}}
  </annotation>
 </semantics>
</math>

 contains the <em>internal symbols</em>,</li>
<li>

<math display="inline" id="Nested_word:31">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 is a finite set which is called the <em>stack alphabet</em>, containing a special symbol 

<math display="inline" id="Nested_word:32">
 <semantics>
  <mrow>
   <mo>⊥</mo>
   <mo>∈</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">bottom</csymbol>
    <in></in>
    <csymbol cd="unknown">Γ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot\in\Gamma
  </annotation>
 </semantics>
</math>

 denoting the empty stack,</li>
<li>

<math display="inline" id="Nested_word:33">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>δ</mi>
     <mtext>c</mtext>
    </msub>
    <mo>∪</mo>
    <msub>
     <mi>δ</mi>
     <mtext>r</mtext>
    </msub>
    <mo>∪</mo>
    <msub>
     <mi>δ</mi>
     <mtext>int</mtext>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>δ</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <mtext>c</mtext>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <mtext>r</mtext>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <mtext>int</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta=\delta_{\text{c}}\cup\delta_{\text{r}}\cup\delta_{\text{int}}
  </annotation>
 </semantics>
</math>

 is the <em>transition function</em>, which is partitioned into three parts corresponding to call transitions, return transitions, and internal transitions, namely
<ul>
<li>

<math display="inline" id="Nested_word:34">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mtext>c</mtext>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mo>×</mo>
     <msub>
      <mi mathvariant="normal">Σ</mi>
      <mtext>c</mtext>
     </msub>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>Q</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Γ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <mtext>c</mtext>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <mtext>c</mtext>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>normal-Γ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{\text{c}}\colon Q\times\Sigma_{\text{c}}\to Q\times\Gamma
  </annotation>
 </semantics>
</math>

, the <em>call transition function</em></li>
<li>

<math display="inline" id="Nested_word:35">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mtext>r</mtext>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mo>×</mo>
     <msub>
      <mi mathvariant="normal">Σ</mi>
      <mtext>r</mtext>
     </msub>
     <mo>×</mo>
     <mi mathvariant="normal">Γ</mi>
    </mrow>
    <mo>→</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <mtext>r</mtext>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <mtext>r</mtext>
      </apply>
      <ci>normal-Γ</ci>
     </apply>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{\text{r}}\colon Q\times\Sigma_{\text{r}}\times\Gamma\to Q
  </annotation>
 </semantics>
</math>

, the <em>return transition function</em></li>
<li>

<math display="inline" id="Nested_word:36">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mtext>int</mtext>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mo>×</mo>
     <msub>
      <mi mathvariant="normal">Σ</mi>
      <mtext>int</mtext>
     </msub>
    </mrow>
    <mo>→</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <mtext>int</mtext>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <mtext>int</mtext>
      </apply>
     </apply>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{\text{int}}:Q\times\Sigma_{\text{int}}\to Q
  </annotation>
 </semantics>
</math>

, the <em>internal transition function</em>,</li>
</ul></li>
<li>

<math display="inline" id="Nested_word:37">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="4.2pt">∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{0}\in\,Q
  </annotation>
 </semantics>
</math>

 is the <em>initial state</em>, and</li>
<li>

<math display="inline" id="Nested_word:38">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊆</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>F</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\subseteq Q
  </annotation>
 </semantics>
</math>

 is the set of <em>accepting states</em>.</li>
</ul>

<p>The notion of <em>computation</em> of a visibly pushdown automaton is a restriction of the one used for <a href="Pushdown_automaton#Formal_Definition" title="wikilink">pushdown automata</a>. Visibly pushdown automata only add a symbol to the stack when reading a call symbol 

<math display="inline" id="Nested_word:39">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mtext>c</mtext>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mtext>c</mtext>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <mtext>c</mtext>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <mtext>c</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{\text{c}}\in\Sigma_{\text{c}}
  </annotation>
 </semantics>
</math>

, they only remove the top element from the stack when reading a return symbol 

<math display="inline" id="Nested_word:40">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mtext>r</mtext>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mtext>r</mtext>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <mtext>r</mtext>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <mtext>r</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{\text{r}}\in\Sigma_{\text{r}}
  </annotation>
 </semantics>
</math>

 and they do not alter the stack when reading an internal event 

<math display="inline" id="Nested_word:41">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mtext>i</mtext>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mtext>int</mtext>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <mtext>i</mtext>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <mtext>int</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{\text{i}}\in\Sigma_{\text{int}}
  </annotation>
 </semantics>
</math>

. A computation ending in an accepting state is an <em>accepting computation</em>.</p>

<p>As a result, a visibly pushdown automaton cannot push to and pop from the stack with the same input symbol. Thus the language 

<math display="inline" id="Nested_word:42">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
     <mi>b</mi>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mi>n</mi>
     <mo>∈</mo>
     <mi mathvariant="normal">N</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>n</ci>
      <ci>normal-N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{a^{n}ba^{n}\mid n\in\mathrm{N}\}
  </annotation>
 </semantics>
</math>

 cannot be accepted by a visibly pushdown automaton for any partition of 

<math display="inline" id="Nested_word:43">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, however there are pushdown automata accepting this language.</p>

<p>If a <a href="Formal_language" title="wikilink">language</a> 

<math display="inline" id="Nested_word:44">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 over a tagged alphabet 

<math display="inline" id="Nested_word:45">
 <semantics>
  <mover accent="true">
   <mi mathvariant="normal">Σ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Sigma}
  </annotation>
 </semantics>
</math>

 is accepted by a deterministic visibly pushdown automaton, then 

<math display="inline" id="Nested_word:46">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is called a <em>visibly pushdown language</em>.</p>
<h3 id="nondeterministic-visibly-pushdown-automata">Nondeterministic visibly pushdown automata</h3>

<p><a href="Nondeterministic_finite_automaton" title="wikilink">Nondeterministic</a> visibly pushdown automata are as expressive as deterministic ones. Hence one can transform a nondeterministic visibly pushdown automaton into a deterministic one, but if the nondeterministic automaton had 

<math display="inline" id="Nested_word:47">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 states, the deterministic one may have up to 

<math display="inline" id="Nested_word:48">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mi>s</mi>
    <mn>2</mn>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{s^{2}}
  </annotation>
 </semantics>
</math>

 states.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="decision-problems">Decision problems</h2>

<p>Let 

<math display="inline" id="Nested_word:49">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|
  </annotation>
 </semantics>
</math>

 be the size of the description of an automaton 

<math display="inline" id="Nested_word:50">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, then it is possible to check if a word <em>n</em> is accepted by the automaton in time 

<math display="inline" id="Nested_word:51">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>A</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>3</mn>
     </msup>
     <mi mathvariant="normal">ℓ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <ci>A</ci>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-ℓ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|A|^{3}\ell)
  </annotation>
 </semantics>
</math>

. In particular, the emptiness problem is solvable in time 

<math display="inline" id="Nested_word:52">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>A</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|A|^{3})
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Nested_word:53">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is fixed, it is decidable in time 

<math display="inline" id="Nested_word:54">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">ℓ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\ell)
  </annotation>
 </semantics>
</math>

 and space 

<math display="inline" id="Nested_word:55">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(d)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Nested_word:56">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is the depth of <em>n</em> in a streaming seeing. It is also decidable with space 

<math display="inline" id="Nested_word:57">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">ℓ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>normal-ℓ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(\ell))
  </annotation>
 </semantics>
</math>

 and time 

<math display="inline" id="Nested_word:58">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi mathvariant="normal">ℓ</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi mathvariant="normal">ℓ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-ℓ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <ci>normal-ℓ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\ell^{2}\log(\ell))
  </annotation>
 </semantics>
</math>

, and by a uniform boolean circuit of depth 

<math display="inline" id="Nested_word:59">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi mathvariant="normal">ℓ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>normal-ℓ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log\ell)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>For two nondeterministic automata <em>A</em> and <em>B</em>, deciding whether the set of words accepted by <em>A</em> is a subset of the word accepted by <em>B</em> is <a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a>-complete. It is also EXPTIME-complete to figure out if there is a word that is not accepted.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="languages">Languages</h2>

<p>As the definition of visibly pushdown automata shows, deterministic visibly pushdown automata can be seen as a special case of <a href="deterministic_pushdown_automata" title="wikilink">deterministic pushdown automata</a>; thus the set <strong>VPL</strong> of visibly pushdown languages over 

<math display="inline" id="Nested_word:60">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mover accent="true">
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">^</mo>
   </mover>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{\Sigma}
  </annotation>
 </semantics>
</math>

 forms a subset of the set <strong>DCFL</strong> of <a href="deterministic_context-free_language" title="wikilink">deterministic context-free languages</a> over the set of symbols in 

<math display="inline" id="Nested_word:61">
 <semantics>
  <mpadded lspace="1.7pt" width="+1.7pt">
   <mover accent="true">
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">^</mo>
   </mover>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\hat{\Sigma}
  </annotation>
 </semantics>
</math>

. In particular, the function that removes the matching relation from nested words transforms regular languages over nested words into context-free languages.</p>
<h3 id="closure-properties">Closure properties</h3>

<p>The set of visibly pushdown languages is closed under the following operations:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ul>
<li>set operations:
<ul>
<li>union</li>
<li>intersection</li>
<li>complement,</li>
</ul></li>
</ul>
<dl>
<dd>thus giving rise to a <a href="Boolean_algebra_(structure)" title="wikilink">boolean algebra</a>.
</dd>
</dl>
<ul>
<li><a href="Kleene_star" title="wikilink">Kleene star</a></li>
<li><a href="Concatenation#Concatenation_of_sets_of_strings" title="wikilink">concatenation</a></li>
</ul>

<p>For the intersection operation, one can construct a VPA <em>M</em> simulating two given VPAs 

<math display="inline" id="Nested_word:62">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nested_word:63">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}
  </annotation>
 </semantics>
</math>

 by a simple product construction : For 

<math display="inline" id="Nested_word:64">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2
  </annotation>
 </semantics>
</math>

, assume 

<math display="inline" id="Nested_word:65">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>

 is given as 

<math display="inline" id="Nested_word:66">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>Q</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <mover accent="true">
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi mathvariant="normal">Γ</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>δ</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>Z</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>F</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <ci>normal-Σ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Γ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>i</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q_{i},\ \hat{\Sigma},\ \Gamma_{i},\ \delta_{i},\ s_{i},\ Z_{i},\ F_{i})
  </annotation>
 </semantics>
</math>

. Then for the automaton <em>M</em>, the set of states is 

<math display="inline" id="Nested_word:67">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>Q</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mo>×</mo>
   <msub>
    <mi>Q</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,Q_{1}\times Q_{2}
  </annotation>
 </semantics>
</math>

, the initial state is 

<math display="inline" id="Nested_word:68">
 <semantics>
  <mrow>
   <mo>(</mo>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mn>2</mn>
   </msub>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(s_{1},s_{2}\right)
  </annotation>
 </semantics>
</math>

, the set of final states is 

<math display="inline" id="Nested_word:69">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>1</mn>
   </msub>
   <mo>×</mo>
   <msub>
    <mi>F</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}\times F_{2}
  </annotation>
 </semantics>
</math>

, the stack alphabet is given by 

<math display="inline" id="Nested_word:70">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi mathvariant="normal">Γ</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mo>×</mo>
   <msub>
    <mi mathvariant="normal">Γ</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Γ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Γ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\Gamma_{1}\times\Gamma_{2}
  </annotation>
 </semantics>
</math>

, and the initial stack symbol is 

<math display="inline" id="Nested_word:71">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>Z</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>Z</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Z_{1},Z_{2})
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Nested_word:72">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is in state 

<math display="inline" id="Nested_word:73">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p_{1},p_{2})
  </annotation>
 </semantics>
</math>

 on reading a <em>call symbol</em> 

<math display="inline" id="Nested_word:74">
 <semantics>
  <mrow>
   <mo>⟨</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-⟨</ci>
    <csymbol cd="unknown">a</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle a\right.
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Nested_word:75">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 pushes the stack symbol 

<math display="inline" id="Nested_word:76">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>γ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>γ</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\gamma_{1},\gamma_{2})
  </annotation>
 </semantics>
</math>

 and goes to state 

<math display="inline" id="Nested_word:77">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>q</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>q</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q_{1},q_{2})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Nested_word:78">
 <semantics>
  <msub>
   <mi>γ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{i}
  </annotation>
 </semantics>
</math>

 is the stack symbol pushed by 

<math display="inline" id="Nested_word:79">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>

 when transitioning from state 

<math display="inline" id="Nested_word:80">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Nested_word:81">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}
  </annotation>
 </semantics>
</math>

 on reading input 

<math display="inline" id="Nested_word:82">
 <semantics>
  <mrow>
   <mo>⟨</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-⟨</ci>
    <csymbol cd="unknown">a</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle a\right.
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Nested_word:83">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is in state 

<math display="inline" id="Nested_word:84">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p_{1},p_{2})
  </annotation>
 </semantics>
</math>

 on reading an <em>internal symbol</em> 

<math display="inline" id="Nested_word:85">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Nested_word:86">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 goes to state 

<math display="inline" id="Nested_word:87">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>q</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>q</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q_{1},q_{2})
  </annotation>
 </semantics>
</math>

, whenever 

<math display="inline" id="Nested_word:88">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>

 transitions from state 

<math display="inline" id="Nested_word:89">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Nested_word:90">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}
  </annotation>
 </semantics>
</math>

 on reading <em>a</em>.</p>

<p>If 

<math display="inline" id="Nested_word:91">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is in state 

<math display="inline" id="Nested_word:92">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p_{1},p_{2})
  </annotation>
 </semantics>
</math>

 on reading a <em>return symbol</em> 

<math display="inline" id="Nested_word:93">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-⟩</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.a\right\rangle
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Nested_word:94">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 pops the symbol 

<math display="inline" id="Nested_word:95">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>γ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>γ</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\gamma_{1},\gamma_{2})
  </annotation>
 </semantics>
</math>

 from the stack and goes to state 

<math display="inline" id="Nested_word:96">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>q</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>q</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q_{1},q_{2})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Nested_word:97">
 <semantics>
  <msub>
   <mi>γ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{i}
  </annotation>
 </semantics>
</math>

 is the stack symbol popped by 

<math display="inline" id="Nested_word:98">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>

 when transitioning from state 

<math display="inline" id="Nested_word:99">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Nested_word:100">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{i}
  </annotation>
 </semantics>
</math>

 on reading 

<math display="inline" id="Nested_word:101">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-⟩</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.a\right\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>Correctness of the above construction crucially relies on the fact that the push and pop actions of the simulated machines 

<math display="inline" id="Nested_word:102">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nested_word:103">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}
  </annotation>
 </semantics>
</math>

 are synchronized along the input symbols read. In fact, a similar simulation is no longer possible for <a href="deterministic_pushdown_automaton" title="wikilink">deterministic pushdown automata</a>, as the larger class of deterministic context-free languages is no longer closed under intersection.</p>

<p>In contrast to the construction for concatenation shown above, the complementation construction for visibly pushdown automata parallels the standard construction<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> for deterministic pushdown automata.</p>

<p>Moreover, like the class of context free languages the class of visibly pushdown languages is closed under <a href="String_operations#Prefixes" title="wikilink">prefix closure</a> and reversal, hence also suffix closure.</p>
<h3 id="relation-to-other-language-classes">Relation to other language classes</h3>

<p>point out that the visibly pushdown languages are more general than the parenthesis languages suggested in . As shown by , the VPL in turn are strictly contained in the class of languages described by <a href="operator-precedence_grammar" title="wikilink">operator-precedence grammars</a>, which were introduced by . In comparison to <a href="conjunctive_grammars" title="wikilink">conjunctive grammars</a>, a generalization of context-free grammars,  shows that the linear conjunctive languages form a superclass of the visibly pushdown languages. The table at the end of this article puts the family of visibly pushdown languages in relation to other language families in the <a href="Chomsky_hierarchy" title="wikilink">Chomsky hierarchy</a>. Rajeev Alur and Parthasarathy Madhusudan<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> related a subclass of regular binary tree languages to visibly pushdown languages.</p>
<h2 id="other-models-of-description">Other models of description</h2>
<h3 id="visibly-pushdown-grammars">Visibly pushdown grammars</h3>

<p>Visibly pushdown languages are exactly the languages that can be described by <em>visibly pushdown grammars</em>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>Visibly pushdown grammars can be defined as a restriction of <a href="Context-free_grammar#Formal_definitions" title="wikilink">context-free grammars</a>. A visibly pushdown grammars <em>G</em> is defined by the 4-<a class="uri" href="tuple" title="wikilink">tuple</a>:</p>

<p>

<math display="inline" id="Nested_word:104">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>=</mo>
    <msup>
     <mi>V</mi>
     <mn>0</mn>
    </msup>
    <mo>∪</mo>
    <mpadded width="+1.7pt">
     <msup>
      <mi>V</mi>
      <mn>1</mn>
     </msup>
    </mpadded>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi mathvariant="normal">Σ</mi>
    </mpadded>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>S</mi>
    </mpadded>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <cn type="integer">0</cn>
     </apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Σ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V=V^{0}\cup V^{1}\,,\Sigma\,,R\,,S\,)
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Nested_word:105">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>V</mi>
    <mn>0</mn>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{0}\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nested_word:106">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>V</mi>
    <mn>1</mn>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{1}\,
  </annotation>
 </semantics>
</math>

 are disjoint finite set; each element 

<math display="inline" id="Nested_word:107">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

 is called <em>a non-terminal character</em> or a <em>variable</em>. Each variable represents a different type of phrase or clause in the sentence. Each variable defines a sub-language of the language defined by 

<math display="inline" id="Nested_word:108">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>G</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\,
  </annotation>
 </semantics>
</math>

, and the sub-languages of 

<math display="inline" id="Nested_word:109">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>V</mi>
    <mn>0</mn>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{0}\,
  </annotation>
 </semantics>
</math>

 are the one without pending calls or pending returns.</li>
<li>

<math display="inline" id="Nested_word:110">
 <semantics>
  <mpadded width="+1.7pt">
   <mi mathvariant="normal">Σ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma\,
  </annotation>
 </semantics>
</math>

 is a finite set of <em>terminal</em>s, disjoint from 

<math display="inline" id="Nested_word:111">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\,
  </annotation>
 </semantics>
</math>

, which make up the actual content of the sentence. The set of terminals is the alphabet of the language defined by the grammar 

<math display="inline" id="Nested_word:112">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>G</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\,
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Nested_word:113">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

 is the start variable (or start symbol), used to represent the whole sentence (or program). It must be an element of 

<math display="inline" id="Nested_word:114">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\,
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Nested_word:115">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 is a finite relation from 

<math display="inline" id="Nested_word:116">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\,
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Nested_word:117">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mo>∪</mo>
     <mi mathvariant="normal">Σ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <union></union>
     <ci>V</ci>
     <ci>normal-Σ</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (V\cup\Sigma)^{*}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Nested_word:118">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\exist</mtext>
     </merror>
     <mi>w</mi>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>V</mi>
       <mo>∪</mo>
       <mi mathvariant="normal">Σ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>\exist</mtext>
      <ci>w</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <union></union>
       <ci>V</ci>
       <ci>normal-Σ</ci>
      </apply>
      <times></times>
     </apply>
    </apply>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>S</ci>
      <ci>w</ci>
     </interval>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exist\,w\in(V\cup\Sigma)^{*}:(S,w)\in R
  </annotation>
 </semantics>
</math>

. The members of 

<math display="inline" id="Nested_word:119">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\,
  </annotation>
 </semantics>
</math>

 are called the <em>(rewrite) rule</em>s or <em>production</em>s of the grammar. There are three kinds of rewrite rules. For 

<math display="inline" id="Nested_word:120">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
    </mrow>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>Z</mi>
    <mo>∈</mo>
    <msup>
     <mi>V</mi>
     <mn>0</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <ci>X</ci>
      <ci>Y</ci>
     </list>
     <ci>V</ci>
    </apply>
    <apply>
     <in></in>
     <ci>Z</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y\in V,Z\in V^{0}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Nested_word:121">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mover accent="true">
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">^</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <apply>
     <ci>normal-^</ci>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in\hat{\Sigma}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nested_word:122">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>∈</mo>
   <mover accent="true">
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">^</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>b</ci>
    <apply>
     <ci>normal-^</ci>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\in\hat{\Sigma}
  </annotation>
 </semantics>
</math>


<ul>
<li>

<math display="inline" id="Nested_word:123">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>→</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>X</ci>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\to\epsilon
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Nested_word:124">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>→</mo>
   <mrow>
    <mi>a</mi>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\to aY
  </annotation>
 </semantics>
</math>

 and if 

<math display="inline" id="Nested_word:125">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <msup>
    <mi>V</mi>
    <mn>0</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in V^{0}
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Nested_word:126">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>∈</mo>
   <msup>
    <mi>V</mi>
    <mn>0</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>Y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\in V^{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Nested_word:127">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in\Sigma
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Nested_word:128">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>a</mi>
      <mi>Z</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>X</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>Z</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\to\langle aZb\rangle Y
  </annotation>
 </semantics>
</math>

 and if 

<math display="inline" id="Nested_word:129">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <msup>
    <mi>V</mi>
    <mn>0</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in V^{0}
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Nested_word:130">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>∈</mo>
   <msup>
    <mi>V</mi>
    <mn>0</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>Y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\in V^{0}
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul>

<p>Here, the asterisk represents the <a href="Kleene_star" title="wikilink">Kleene star</a> operation and 

<math display="inline" id="Nested_word:131">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 is the empty word.</p>
<h3 id="uniform-boolean-circuits">Uniform Boolean circuits</h3>

<p>The problem whether a word of length 

<math display="inline" id="Nested_word:132">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 is accepted by a given nested word automaton can be solved by uniform <a href="boolean_circuit" title="wikilink">boolean circuits</a> of depth 

<math display="inline" id="Nested_word:133">
 <semantics>
  <mrow>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\Omicron</mtext>
   </merror>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi mathvariant="normal">ℓ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>\Omicron</mtext>
    <apply>
     <log></log>
     <ci>normal-ℓ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omicron(\log\ell)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="logical-description">Logical description</h3>

<p>Regular languages over nested words are exactly the set of languages described by <a href="Monadic_predicate_calculus" title="wikilink">Monadic</a> <a href="SO_(complexity)" title="wikilink">second-order logic</a> with two unary predicates <em>call</em> and <em>return</em>, linear successor and the matching relation ↝.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Model_checking" title="wikilink">Model checking</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Okhotin, Alexander: <a href="http://users.utu.fi/aleokh/papers/linconj_vs_dcfl.pdf">Comparing linear conjunctive languages to subfamilies of the context-free languages</a>, 37th International Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM 2011).</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cis.upenn.edu/~alur/nw.html">Nested words and visibly pushdown languages</a></li>
<li><a href="http://www.cs.uiuc.edu/~madhu/vpa/">Visibly pushdown automata - Automata on nested words</a></li>
<li><a href="http://qwiki.stanford.edu/index.php/Complexity_Zoo:V#vpl">class VPL</a> at the <a href="Complexity_Zoo" title="wikilink">Complexity Zoo</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Words" title="wikilink">Category:Words</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">[<a class="uri" href="http://scholar.google.com/scholar?as_q">http://scholar.google.com/scholar?as_q</a>=&amp;as;_oq=%22nested+words%22+%22visibly+pushdown%22 Google Scholar search results] for "nested words" OR "visibly pushdown"<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7">, p. 238 f.<a href="#fnref7">↩</a></li>
<li id="fn8"> Sect.4, Theorem 5,<a href="#fnref8">↩</a></li>
<li id="fn9"> Sect.7<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
</ol>
</section>
</body>
</html>
