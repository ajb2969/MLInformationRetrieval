<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1375">Large countable ordinal</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Large countable ordinal</h1>
<hr/>

<p>In the mathematical discipline of <a href="set_theory" title="wikilink">set theory</a>, there are many ways of describing specific <a href="countable_set" title="wikilink">countable</a> <a href="ordinal_number" title="wikilink">ordinals</a>. The smallest ones can be usefully and non-circularly expressed in terms of their <a href="Cantor_normal_form" title="wikilink">Cantor normal forms</a>. Beyond that, many ordinals of relevance to <a href="proof_theory" title="wikilink">proof theory</a> still have <a href="computable_function" title="wikilink">computable</a> <a href="ordinal_notation" title="wikilink">ordinal notations</a>. However, it is not possible to decide effectively whether a given putative ordinal notation is a notation or not (for reasons somewhat analogous to the unsolvability of the <a href="halting_problem" title="wikilink">halting problem</a>); various more-concrete ways of defining ordinals that definitely have notations are available.</p>

<p>Since there are only countably many notations, all ordinals with notations are exhausted well below the <a href="first_uncountable_ordinal" title="wikilink">first uncountable ordinal ω<sub>1</sub></a>; their <a class="uri" href="supremum" title="wikilink">supremum</a> is called <strong><em>Church–Kleene ω<sub>1</sub></em></strong> or ω<sub>1</sub><sup>CK</sup> (not to be confused with the first uncountable ordinal, ω<sub>1</sub>), described <a href="#The_Church–Kleene_ordinal" title="wikilink">below</a>. Ordinal numbers below ω<sub>1</sub><sup>CK</sup> are the <strong>recursive</strong> ordinals (see <a href="#Generalities_on_recursive_ordinals" title="wikilink">below</a>). Countable ordinals larger than this may still be defined, but do not have notations.</p>

<p>Due to the focus on countable ordinals, <a href="ordinal_arithmetic" title="wikilink">ordinal arithmetic</a> is used throughout, except where otherwise noted. The ordinals described here are not as large as the ones described in <a href="large_cardinals" title="wikilink">large cardinals</a>, but they are large among those that have constructive notations (descriptions). Larger and larger ordinals can be defined, but they become more and more difficult to describe.</p>
<h2 id="generalities-on-recursive-ordinals">Generalities on recursive ordinals</h2>
<h3 id="ordinal-notations">Ordinal notations</h3>

<p><a href="Recursive_ordinal" title="wikilink">Recursive ordinals</a> (or computable ordinals) are certain countable ordinals: loosely speaking those represented by a <a href="computable_function" title="wikilink">computable function</a>. There are several equivalent definitions of this: the simplest is to say that a computable ordinal is the order-type of some recursive (i.e., computable) well-ordering of the natural numbers; so, essentially, an ordinal is recursive when we can present the set of smaller ordinals in such a way that a computer (<a href="Turing_machine" title="wikilink">Turing machine</a>, say) can manipulate them (and, essentially, compare them).</p>

<p>A different definition uses <a href="Stephen_Cole_Kleene" title="wikilink">Kleene</a>'s system of <a href="ordinal_notation" title="wikilink">ordinal notations</a>. Briefly, an ordinal notation is either the name zero (describing the ordinal 0), or the successor of an ordinal notation (describing the successor of the ordinal described by that notation), or a Turing machine (computable function) that produces an increasing sequence of ordinal notations (that describe the ordinal that is the limit of the sequence), and ordinal notations are (partially) ordered so as to make the successor of <em>o</em> greater than <em>o</em> and to make the limit greater than any term of the sequence (this order is computable; however, the set <strong>O</strong> of ordinal notations itself is highly non-recursive, owing to the impossibility of deciding whether a given Turing machine does indeed produce a sequence of notations); a recursive ordinal is then an ordinal described by some ordinal notation.</p>

<p>Any ordinal smaller than a recursive ordinal is itself recursive, so the set of all recursive ordinals forms a certain (countable) ordinal, the <a href="Church-Kleene_ordinal" title="wikilink">Church-Kleene ordinal</a> (see below).</p>

<p>It is tempting to forget about ordinal notations, and only speak of the recursive ordinals themselves: and some statements are made about recursive ordinals which, in fact, concern the notations for these ordinals. This leads to difficulties, however, as even the smallest infinite ordinal, ω, has many notations, some of which cannot be proven to be equivalent to the obvious notation (the limit of the simplest program that enumerates all natural numbers).</p>
<h3 id="relationship-to-systems-of-arithmetic">Relationship to systems of arithmetic</h3>

<p>There is a relation between computable ordinals and certain <a href="formal_system" title="wikilink">formal systems</a> (containing <a class="uri" href="arithmetic" title="wikilink">arithmetic</a>, that is, at least a reasonable fragment of <a href="Peano_axioms" title="wikilink">Peano arithmetic</a>).</p>

<p>Certain computable ordinals are so large that while they can be given by a certain ordinal notation <em>o</em>, a given formal system might not be sufficiently powerful to show that <em>o</em> is, indeed, an ordinal notation: the system does not show transfinite induction for such large ordinals.</p>

<p>For example, the usual <a href="First-order_logic" title="wikilink">first-order</a> <a href="Peano_axioms" title="wikilink">Peano axioms</a> do not prove transfinite induction for (or beyond) ε<sub>0</sub>: while the ordinal ε<sub>0</sub> can easily be arithmetically described (it is countable), the Peano axioms are not strong enough to show that it is indeed an ordinal; in fact, transfinite induction on ε<sub>0</sub> proves the consistency of Peano's axioms (a theorem by <a href="Gerhard_Gentzen" title="wikilink">Gentzen</a>), so by <a href="Gödel's_second_incompleteness_theorem" title="wikilink">Gödel's second incompleteness theorem</a>, Peano's axioms cannot formalize that reasoning. (This is at the basis of the <a href="Kirby–Paris_theorem" title="wikilink">Kirby–Paris theorem</a> on <a href="Goodstein's_theorem" title="wikilink">Goodstein sequences</a>.) We say that ε<sub>0</sub> measures the <a href="proof-theoretic_strength" title="wikilink">proof-theoretic strength</a> of Peano's axioms.</p>

<p>But we can do this for systems far beyond Peano's axioms. For example, the proof-theoretic strength of <a href="Kripke–Platek_set_theory" title="wikilink">Kripke–Platek set theory</a> is the Bachmann-Howard ordinal (see below), and, in fact, merely adding to Peano's axioms the axioms that state the well-ordering of all ordinals below the <a href="Bachmann–Howard_ordinal" title="wikilink">Bachmann–Howard ordinal</a> is sufficient to obtain all arithmetical consequences of <a href="Kripke–Platek_set_theory" title="wikilink">Kripke–Platek set theory</a>.</p>
<h2 id="specific-recursive-ordinals">Specific recursive ordinals</h2>
<h3 id="predicative-definitions-and-the-veblen-hierarchy">Predicative definitions and the Veblen hierarchy</h3>

<p>We have already mentioned (see <a href="Ordinal_arithmetic#Cantor_normal_form" title="wikilink">Cantor normal form</a>) the ordinal <a href="epsilon_numbers_(mathematics)" title="wikilink">ε<sub>0</sub></a>, which is the smallest satisfying the equation 

<math display="inline" id="Large_countable_ordinal:0">
 <semantics>
  <mrow>
   <msup>
    <mi>ω</mi>
    <mi>α</mi>
   </msup>
   <mo>=</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>α</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\alpha}=\alpha
  </annotation>
 </semantics>
</math>

, so it is the limit of the sequence 0, 1, 

<math display="inline" id="Large_countable_ordinal:1">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Large_countable_ordinal:2">
 <semantics>
  <msup>
   <mi>ω</mi>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ω</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\omega}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Large_countable_ordinal:3">
 <semantics>
  <msup>
   <mi>ω</mi>
   <msup>
    <mi>ω</mi>
    <mi>ω</mi>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\omega^{\omega}}
  </annotation>
 </semantics>
</math>

, etc. The next ordinal satisfying this equation is called ε<sub>1</sub>: it is the limit of the sequence</p>

<p>

<math display="block" id="Large_countable_ordinal:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>ε</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo rspace="22.5pt">,</mo>
     <msup>
      <mi>ω</mi>
      <mrow>
       <msub>
        <mi>ε</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>ε</mi>
      <mn>0</mn>
     </msub>
     <mo>⋅</mo>
     <mi>ω</mi>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msup>
      <mi>ω</mi>
      <mrow>
       <msub>
        <mi>ε</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ε</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ω</mi>
     </msup>
     <mo rspace="22.5pt">,</mo>
     <mtext>etc.</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ε</ci>
        <cn type="integer">0</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ε</ci>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </list>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ε</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ε</ci>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ε</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>ω</ci>
      </apply>
      <mtext>etc.</mtext>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{0}+1,\qquad\omega^{\varepsilon_{0}+1}=\varepsilon_{0}\cdot\omega,%
\qquad\omega^{\omega^{\varepsilon_{0}+1}}=(\varepsilon_{0})^{\omega},\qquad%
\text{etc.}
  </annotation>
 </semantics>
</math>

</p>

<p>More generally, the 

<math display="inline" id="Large_countable_ordinal:5">
 <semantics>
  <mi>ι</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ι</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iota
  </annotation>
 </semantics>
</math>

-th ordinal such that 

<math display="inline" id="Large_countable_ordinal:6">
 <semantics>
  <mrow>
   <msup>
    <mi>ω</mi>
    <mi>α</mi>
   </msup>
   <mo>=</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>α</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\alpha}=\alpha
  </annotation>
 </semantics>
</math>

 is called 

<math display="inline" id="Large_countable_ordinal:7">
 <semantics>
  <msub>
   <mi>ε</mi>
   <mi>ι</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ε</ci>
    <ci>ι</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{\iota}
  </annotation>
 </semantics>
</math>

. We could define 

<math display="inline" id="Large_countable_ordinal:8">
 <semantics>
  <msub>
   <mi>ζ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ζ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{0}
  </annotation>
 </semantics>
</math>

 as the smallest ordinal such that 

<math display="inline" id="Large_countable_ordinal:9">
 <semantics>
  <mrow>
   <msub>
    <mi>ε</mi>
    <mi>α</mi>
   </msub>
   <mo>=</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ε</ci>
     <ci>α</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{\alpha}=\alpha
  </annotation>
 </semantics>
</math>

, but since the Greek alphabet does not have transfinitely many letters it is better to use a more robust notation: define ordinals 

<math display="inline" id="Large_countable_ordinal:10">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mi>γ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>γ</ci>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\gamma}(\beta)
  </annotation>
 </semantics>
</math>

 by transfinite induction as follows: let 

<math display="inline" id="Large_countable_ordinal:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>ω</mi>
    <mi>β</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>β</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{0}(\beta)=\omega^{\beta}
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Large_countable_ordinal:12">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mrow>
     <mi>γ</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <apply>
      <plus></plus>
      <ci>γ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\gamma+1}(\beta)
  </annotation>
 </semantics>
</math>

 be the 

<math display="inline" id="Large_countable_ordinal:13">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

-th fixed point of 

<math display="inline" id="Large_countable_ordinal:14">
 <semantics>
  <msub>
   <mi>φ</mi>
   <mi>γ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>φ</ci>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\gamma}
  </annotation>
 </semantics>
</math>

 (i.e., the 

<math display="inline" id="Large_countable_ordinal:15">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

-th ordinal such that 

<math display="inline" id="Large_countable_ordinal:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mi>γ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>γ</ci>
     </apply>
     <ci>α</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\gamma}(\alpha)=\alpha
  </annotation>
 </semantics>
</math>

; so for example, 

<math display="inline" id="Large_countable_ordinal:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>ε</mi>
    <mi>β</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>β</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ε</ci>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{1}(\beta)=\varepsilon_{\beta}
  </annotation>
 </semantics>
</math>

), and when 

<math display="inline" id="Large_countable_ordinal:18">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 is a limit ordinal, define 

<math display="inline" id="Large_countable_ordinal:19">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mi>δ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>δ</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\delta}(\alpha)
  </annotation>
 </semantics>
</math>

 as the 

<math display="inline" id="Large_countable_ordinal:20">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

-th common fixed point of the 

<math display="inline" id="Large_countable_ordinal:21">
 <semantics>
  <msub>
   <mi>φ</mi>
   <mi>γ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>φ</ci>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\gamma}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Large_countable_ordinal:22">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo><</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>γ</ci>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma<\delta
  </annotation>
 </semantics>
</math>

. This family of functions is known as the <strong><a href="Veblen_hierarchy" title="wikilink">Veblen hierarchy</a></strong>. (There are inessential variations in the definition, such as letting, for 

<math display="inline" id="Large_countable_ordinal:23">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 a limit ordinal, 

<math display="inline" id="Large_countable_ordinal:24">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mi>δ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>δ</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\delta}(\alpha)
  </annotation>
 </semantics>
</math>

 be the limit of the 

<math display="inline" id="Large_countable_ordinal:25">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mi>γ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>γ</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\gamma}(\alpha)
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Large_countable_ordinal:26">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo><</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>γ</ci>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma<\delta
  </annotation>
 </semantics>
</math>

: this essentially just shifts the indices by 1, which is harmless.) 

<math display="inline" id="Large_countable_ordinal:27">
 <semantics>
  <msub>
   <mi>φ</mi>
   <mi>γ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>φ</ci>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\gamma}
  </annotation>
 </semantics>
</math>

 is called the 

<math display="inline" id="Large_countable_ordinal:28">
 <semantics>
  <msup>
   <mi>γ</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>γ</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma^{th}
  </annotation>
 </semantics>
</math>

 <strong><a href="Veblen_function" title="wikilink">Veblen function</a></strong> (to the base 

<math display="inline" id="Large_countable_ordinal:29">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

).</p>

<p>Ordering

<math display="block" id="Large_countable_ordinal:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mi>γ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>δ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>α</ci>
     </apply>
     <ci>β</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>γ</ci>
     </apply>
     <ci>δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\alpha}(\beta)<\varphi_{\gamma}(\delta)
  </annotation>
 </semantics>
</math>

 if and only if either (

<math display="inline" id="Large_countable_ordinal:31">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mi>γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=\gamma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Large_countable_ordinal:32">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo><</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>β</ci>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta<\delta
  </annotation>
 </semantics>
</math>

) or (

<math display="inline" id="Large_countable_ordinal:33">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo><</mo>
   <mi>γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>α</ci>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha<\gamma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Large_countable_ordinal:34">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo><</mo>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mi>γ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>δ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>β</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>γ</ci>
     </apply>
     <ci>δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta<\varphi_{\gamma}(\delta)
  </annotation>
 </semantics>
</math>

) or (

<math display="inline" id="Large_countable_ordinal:35">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>></mo>
   <mi>γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>α</ci>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha>\gamma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Large_countable_ordinal:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>α</ci>
     </apply>
     <ci>β</ci>
    </apply>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\alpha}(\beta)<\delta
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="the-fefermanschütte-ordinal-and-beyond">The Feferman–Schütte ordinal and beyond</h3>

<p>The smallest ordinal such that 

<math display="inline" id="Large_countable_ordinal:37">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>φ</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>α</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{\alpha}(0)=\alpha
  </annotation>
 </semantics>
</math>

 is known as the <a href="Feferman–Schütte_ordinal" title="wikilink">Feferman–Schütte ordinal</a> and generally written 

<math display="inline" id="Large_countable_ordinal:38">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{0}
  </annotation>
 </semantics>
</math>

. It can be described as the set of all ordinals that can be written as finite expressions, starting from zero, using only the Veblen hierarchy and addition. The Feferman-Schütte ordinal is important because, in a sense that is complicated to make precise, it is the smallest (infinite) ordinal that cannot be (“<a href="impredicative" title="wikilink">predicatively</a>”) described using smaller ordinals. It measures the strength of such systems as “<a href="Reverse_mathematics#Arithmetical_transfinite_recursion" title="wikilink">arithmetical transfinite recursion</a>”.</p>

<p>More generally, Γ<sub>α</sub> enumerates the ordinals that cannot be obtained from smaller ordinals using addition and the Veblen functions.</p>

<p>It is, of course, possible to describe ordinals beyond the Feferman-Schütte ordinal. One could continue to seek fixed points in more and more complicated manner: enumerate the fixed points of 

<math display="inline" id="Large_countable_ordinal:39">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>↦</mo>
   <msub>
    <mi mathvariant="normal">Γ</mi>
    <mi>α</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Γ</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\mapsto\Gamma_{\alpha}
  </annotation>
 </semantics>
</math>

, then enumerate the fixed points of <em>that</em>, and so on, and then look for the first ordinal α such that α is obtained in α steps of this process, and continue diagonalizing in this <em>ad hoc</em> manner. This leads to the definition of the “<a href="small_Veblen_ordinal" title="wikilink">small</a>” and “<a href="large_Veblen_ordinal" title="wikilink">large</a>” Veblen ordinals.</p>
<h3 id="impredicative-ordinals">Impredicative ordinals</h3>

<p>To go far beyond the Feferman-Schütte ordinal, one needs to introduce new methods. Unfortunately there is not yet any standard way to do this: every author in the subject seems to have invented their own system of notation, and it is quite hard to translate between the different systems. The first such system was introduced by Bachmann in 1950 (in an <em>ad hoc</em> manner), and different extensions and variations of it were described by Buchholz, Takeuti (ordinal diagrams), Feferman (θ systems), Aczel, Bridge, Schütte, and Pohlers. However most systems use the same basic idea, of constructing new countable ordinals by using the existence of certain uncountable ordinals. Here is an example of such a definition, described in much greater detail in the article on <a href="ordinal_collapsing_function" title="wikilink">ordinal collapsing function</a>:</p>
<ul>
<li>ψ(α) is defined to be the smallest ordinal that cannot be constructed by starting with 0, 1, ω and Ω, and repeatedly applying addition, multiplication and exponentiation, and ψ to previously constructed ordinals (except that ψ can only be applied to arguments less than α, to ensure that it is well defined).</li>
</ul>

<p>Here Ω = ω<sub>1</sub> is the first uncountable ordinal. It is put in because otherwise the function ψ gets "stuck" at the smallest ordinal σ such that ε<sub>σ</sub>=σ: in particular ψ(α)=σ for any ordinal α satisfying σ≤α≤Ω. However the fact that we included Ω allows us to get past this point: ψ(Ω+1) is greater than σ. The key property of Ω that we used is that it is greater than any ordinal produced by ψ.</p>

<p>To construct still larger ordinals, we can extend the definition of ψ by throwing in more ways of constructing uncountable ordinals. There are several ways to do this, described to some extent in the article on <a href="ordinal_collapsing_function" title="wikilink">ordinal collapsing function</a>.</p>

<p>The <strong><a href="Bachmann-Howard_ordinal" title="wikilink">Bachmann-Howard ordinal</a></strong> (sometimes just called the <strong>Howard ordinal</strong>, ψ(ε<sub>Ω+1</sub>) with the notation above) is an important one, because it describes the proof-theoretic strength of <a href="Kripke-Platek_set_theory" title="wikilink">Kripke-Platek set theory</a>. Indeed, the main importance of these large ordinals, and the reason to describe them, is their relation to certain formal systems as explained above. However, such powerful formal systems as full <a href="second-order_arithmetic" title="wikilink">second-order arithmetic</a>, let alone <a href="Zermelo-Fraenkel_set_theory" title="wikilink">Zermelo-Fraenkel set theory</a>, seem beyond reach for the moment.</p>
<h3 id="unrecursable-recursive-ordinals">“Unrecursable” recursive ordinals</h3>

<p>By dropping the requirement of having a useful description, even larger recursive countable ordinals can be obtained as the ordinals measuring the strengths of various strong theories; roughly speaking, these ordinals are the smallest ordinals that the theories cannot prove are well ordered. By taking stronger and stronger theories such as <a href="second-order_arithmetic" title="wikilink">second-order arithmetic</a>, <a href="Zermelo_set_theory" title="wikilink">Zermelo set theory</a>, <a href="Zermelo-Fraenkel_set_theory" title="wikilink">Zermelo-Fraenkel set theory</a>, or Zermelo-Fraenkel set theory with various <a href="large_cardinal" title="wikilink">large cardinal</a> axioms, one gets some extremely large recursive ordinals. (Strictly speaking it is not known that all of these really are ordinals: by construction, the ordinal strength of a theory can only be proven to be an ordinal from an even stronger theory. So for the large cardinal axioms this becomes quite unclear.)</p>
<h2 id="beyond-recursive-ordinals">Beyond recursive ordinals</h2>
<h3 id="the-churchkleene-ordinal">The Church–Kleene ordinal</h3>

<p>The set of <a href="recursive_ordinal" title="wikilink">recursive ordinals</a> is an ordinal that is the smallest ordinal that <em>cannot</em> be described in a recursive way. (It is not the order type of any recursive well-ordering of the integers.) That ordinal is a countable ordinal called the <a href="Church–Kleene_ordinal" title="wikilink">Church–Kleene ordinal</a>, 

<math display="inline" id="Large_countable_ordinal:40">
 <semantics>
  <msubsup>
   <mi>ω</mi>
   <mn>1</mn>
   <mi>CK</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>CK</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1}^{\mathrm{CK}}
  </annotation>
 </semantics>
</math>

. Thus, 

<math display="inline" id="Large_countable_ordinal:41">
 <semantics>
  <msubsup>
   <mi>ω</mi>
   <mn>1</mn>
   <mi>CK</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>CK</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1}^{\mathrm{CK}}
  </annotation>
 </semantics>
</math>

 is the smallest non-recursive ordinal, and there is no hope of precisely “describing” any ordinals from this point on — we can only <em>define</em> them. But it is still far less than the first uncountable ordinal, 

<math display="inline" id="Large_countable_ordinal:42">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1}
  </annotation>
 </semantics>
</math>

. However, as its symbol suggests, it behaves in many ways rather like 

<math display="inline" id="Large_countable_ordinal:43">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1}
  </annotation>
 </semantics>
</math>

. </p>
<h3 id="admissible-ordinals">Admissible ordinals</h3>

<p>The Church-Kleene ordinal is again related to <a href="Kripke-Platek_set_theory" title="wikilink">Kripke-Platek set theory</a>, but now in a different way: whereas the Bachmann-Howard ordinal (described <a href="#Impredicative_ordinals" title="wikilink">above</a>) was the smallest ordinal for which KP does not prove transfinite induction, the Church-Kleene ordinal is the smallest α such that the construction of the <a href="Constructible_universe" title="wikilink">Gödel universe</a>, <em>L</em>, up to stage α, yields a model 

<math display="inline" id="Large_countable_ordinal:44">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\alpha}
  </annotation>
 </semantics>
</math>

 of KP. Such ordinals are called <strong>admissible</strong>, thus 

<math display="inline" id="Large_countable_ordinal:45">
 <semantics>
  <msubsup>
   <mi>ω</mi>
   <mn>1</mn>
   <mi>CK</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>CK</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1}^{\mathrm{CK}}
  </annotation>
 </semantics>
</math>

 is the smallest admissible ordinal (beyond ω in case the axiom of infinity is not included in KP).</p>

<p>By a theorem of <a href="Gerald_Sacks" title="wikilink">Sacks</a>, the countable admissible ordinals are exactly those constructed in a manner similar to the Church-Kleene ordinal but for Turing machines with <a href="Oracle_machine" title="wikilink">oracles</a>. One sometimes writes 

<math display="inline" id="Large_countable_ordinal:46">
 <semantics>
  <msubsup>
   <mi>ω</mi>
   <mi>α</mi>
   <mi>CK</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>α</ci>
    </apply>
    <ci>CK</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{\alpha}^{\mathrm{CK}}
  </annotation>
 </semantics>
</math>

 for the 

<math display="inline" id="Large_countable_ordinal:47">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

-th ordinal that is either admissible or a limit of admissible.</p>
<h3 id="beyond-admissible-ordinals">Beyond admissible ordinals</h3>

<p>An ordinal that is both admissible and a limit of admissibles, or equivalently such that 

<math display="inline" id="Large_countable_ordinal:48">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Large_countable_ordinal:49">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

-th admissible ordinal, is called <em>recursively inaccessible</em>. There exists a theory of large ordinals in this manner that is highly parallel to that of (small) <a href="large_cardinal_property" title="wikilink">large cardinals</a>. For example, we can define recursively <em>Mahlo ordinals</em>: these are the 

<math display="inline" id="Large_countable_ordinal:50">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 such that every 

<math display="inline" id="Large_countable_ordinal:51">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

-recursive closed unbounded subset of 

<math display="inline" id="Large_countable_ordinal:52">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 contains an admissible ordinal (a recursive analog of the definition of a <a href="Mahlo_cardinal" title="wikilink">Mahlo cardinal</a>). But note that we are still talking about possibly countable ordinals here. (While the existence of inaccessible or Mahlo cardinals cannot be proved in <a href="ZFC" title="wikilink">Zermelo-Fraenkel set theory</a>, that of recursively inaccessible or recursively Mahlo ordinals is a theorem of ZFC: in fact, any <a href="regular_cardinal" title="wikilink">regular cardinal</a> is recursively Mahlo and more, but even if we limit ourselves to countable ordinals, ZFC proves the existence of recursively Mahlo ordinals. They are, however, beyond the reach of Kripke-Platek set theory.)</p>

<p>An admissible ordinal 

<math display="inline" id="Large_countable_ordinal:53">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is called <em>nonprojectible</em> if there is no total 

<math display="inline" id="Large_countable_ordinal:54">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

-recursive injective function mapping 

<math display="inline" id="Large_countable_ordinal:55">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 into a smaller ordinal. (This is trivially true for regular cardinals; however, we are mainly interested in countable ordinals.) Being nonprojectible is a much stronger condition than being admissible, recursively inaccessible, or even recursively Mahlo. It is equivalent to the statement that the <a href="Constructible_universe" title="wikilink">Gödel universe</a>, <em>L</em>, up to stage α, yields a model 

<math display="inline" id="Large_countable_ordinal:56">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\alpha}
  </annotation>
 </semantics>
</math>

 of KP + 

<math display="inline" id="Large_countable_ordinal:57">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{1}
  </annotation>
 </semantics>
</math>

-separation.</p>
<h3 id="unprovable-ordinals">“Unprovable” ordinals</h3>

<p>We can imagine even larger ordinals that are still countable. For example, if <a href="Zermelo-Fraenkel_set_theory" title="wikilink">ZFC</a> has a <a href="transitive_model" title="wikilink">transitive model</a> (a hypothesis stronger than the mere hypothesis of consistency, and implied by the existence of an inaccessible cardinal), then there exists a countable 

<math display="inline" id="Large_countable_ordinal:58">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Large_countable_ordinal:59">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\alpha}
  </annotation>
 </semantics>
</math>

 is a model of ZFC. Such ordinals are beyond the strength of ZFC in the sense that it cannot (by construction) prove their existence.</p>

<p>Even larger countable ordinals, called the <em><a href="stable_ordinal" title="wikilink">stable ordinals</a></em>, can be defined by indescribability conditions or as those 

<math display="inline" id="Large_countable_ordinal:60">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Large_countable_ordinal:61">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\alpha}
  </annotation>
 </semantics>
</math>

 is a <a href="elementary_equivalence" title="wikilink">1-elementary submodel</a> of <em>L</em>; the existence of these ordinals can be proven in ZFC,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and they are closely related to the <a href="nonprojectible_ordinal" title="wikilink">nonprojectible ordinals</a>.</p>
<h2 id="a-pseudo-well-ordering">A pseudo-well-ordering</h2>

<p>Within the <a href="Kleene's_O" title="wikilink">scheme of notations of Kleene</a> some represent ordinals and some do not. One can define a recursive total ordering that is a subset of the Kleene notations and has an initial segment which is well-ordered with order-type 

<math display="inline" id="Large_countable_ordinal:62">
 <semantics>
  <msubsup>
   <mi>ω</mi>
   <mn>1</mn>
   <mi>CK</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>CK</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1}^{\mathrm{CK}}
  </annotation>
 </semantics>
</math>

. Every recursively enumerable (or even hyperarithmetic) nonempty subset of this total ordering has a least element. So it resembles a well-ordering in some respects. For example, one can define the arithmetic operations on it. Yet it is not possible to effectively determine exactly where the initial well-ordered part ends and the part lacking a least element begins.</p>
<h2 id="references">References</h2>

<p>Most books describing large countable ordinals are on proof theory, and unfortunately tend to be out of print.</p>
<h3 id="on-recursive-ordinals">On recursive ordinals</h3>
<ul>
<li><a href="Wolfram_Pohlers" title="wikilink">Wolfram Pohlers</a>, <em>Proof theory</em>, Springer 1989 ISBN 0-387-51842-8 (for Veblen hierarchy and some impredicative ordinals). This is probably the most readable book on large countable ordinals (which is not saying much).</li>
<li><a href="Gaisi_Takeuti" title="wikilink">Gaisi Takeuti</a>, <em>Proof theory</em>, 2nd edition 1987 ISBN 0-444-10492-5 (for ordinal diagrams)</li>
<li><a href="Kurt_Schütte" title="wikilink">Kurt Schütte</a>, <em>Proof theory</em>, Springer 1977 ISBN 0-387-07911-4 (for Veblen hierarchy and some impredicative ordinals)</li>
<li><a href="Craig_Smorynski" title="wikilink">Craig Smorynski</a>, <em>The varieties of arboreal experience</em> Math. Intelligencer 4 (1982), no. 4, 182–189; contains an informal description of the Veblen hierarchy.</li>
<li><a href="Hartley_Rogers,_Jr." title="wikilink">Hartley Rogers, Jr.</a>, <em>Theory of Recursive Functions and Effective Computability</em> McGraw-Hill (1967) ISBN 0-262-68052-1 (describes recursive ordinals and the Church–Kleene ordinal)</li>
<li><a href="Larry_W._Miller" title="wikilink">Larry W. Miller</a>, <em>Normal Functions and Constructive Ordinal Notations</em>, <em>The Journal of Symbolic Logic</em>, volume 41, number 2, June 1976, pages 439 to 459, ,</li>
<li><a href="Hilbert_Levitz" title="wikilink">Hilbert Levitz</a>, <em><a href="http://www.cs.fsu.edu/~levitz/ords.ps">Transfinite Ordinals and Their Notations: For The Uninitiated</a></em>, expository article (8 pages, in <a class="uri" href="PostScript" title="wikilink">PostScript</a>)</li>
<li><a href="Herman_Ruge_Jervell" title="wikilink">Herman Ruge Jervell</a>, <a href="http://folk.uio.no/herman/incompleteness.pdf">Truth and provability</a>, manuscript in progress.</li>
</ul>
<h3 id="beyond-recursive-ordinals-1">Beyond recursive ordinals</h3>
<ul>
<li></li>
<li></li>
</ul>
<h3 id="both-recursive-and-nonrecursive-ordinals">Both recursive and nonrecursive ordinals</h3>
<ul>
<li><a href="Michael_Rathjen" title="wikilink">Michael Rathjen</a>, "The realm of ordinal analysis." in S. Cooper and J. Truss (eds.): <em>Sets and Proofs</em>. (Cambridge University Press, 1999) 219–279. At <a href="http://www.maths.leeds.ac.uk/~rathjen/srealm.ps">Postscript file</a>.</li>
</ul>
<h3 id="inline-references">Inline references</h3>
<references>
</references>

<p>"</p>

<p><a href="Category:Ordinal_numbers" title="wikilink">Category:Ordinal numbers</a> <a href="Category:Proof_theory" title="wikilink">Category:Proof theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Barwise (1976), theorem 7.2.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
