<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="709">Formal grammar</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Formal grammar</h1>
<hr/>

<p>In <a href="formal_language_theory" title="wikilink">formal language theory</a>, a <strong>grammar</strong> (when the context is not given, often called a <strong>formal grammar</strong> for clarity) is a set of <a href="Production_(computer_science)" title="wikilink">production rules</a> for <a href="String_(computer_science)" title="wikilink">strings</a> in a <a href="formal_language" title="wikilink">formal language</a>. The rules describe how to form strings from the language's <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> that are valid according to the language's <a href="syntax_(programming_languages)" title="wikilink">syntax</a>. A grammar does not describe the <a href="semantics" title="wikilink">meaning of the strings</a> or what can be done with them in whatever context—only their form.</p>

<p><a href="Formal_language_theory" title="wikilink">Formal language theory</a>, the discipline which studies formal grammars and languages, is a branch of <a href="applied_mathematics" title="wikilink">applied mathematics</a>. Its applications are found in <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, <a href="theoretical_linguistics" title="wikilink">theoretical linguistics</a>, <a href="Formal_semantics_(logic)" title="wikilink">formal semantics</a>, <a href="mathematical_logic" title="wikilink">mathematical logic</a>, and other areas.</p>

<p>A formal grammar is a set of rules for rewriting strings, along with a "start symbol" from which rewriting starts. Therefore, a grammar is usually thought of as a language generator. However, it can also sometimes be used as the basis for a "<a class="uri" href="recognizer" title="wikilink">recognizer</a>"—a function in computing that determines whether a given string belongs to the language or is grammatically incorrect. To describe such recognizers, formal language theory uses separate formalisms, known as <a href="automata_theory" title="wikilink">automata theory</a>. One of the interesting results of automata theory is that it is not possible to design a recognizer for certain formal languages.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="uri" href="Parsing" title="wikilink">Parsing</a> is the process of recognizing an utterance (a string in natural languages) by breaking it down to a set of symbols and analyzing each one against the grammar of the language. Most languages have the meanings of their utterances structured according to their syntax—a practice known as <a href="compositional_semantics" title="wikilink">compositional semantics</a>. As a result, the first step to describing the meaning of an utterance in language is to break it down part by part and look at its analyzed form (known as its <a href="parse_tree" title="wikilink">parse tree</a> in computer science, and as its <a href="deep_structure" title="wikilink">deep structure</a> in <a href="generative_grammar" title="wikilink">generative grammar</a>).</p>
<h2 id="introductory-example">Introductory example</h2>

<p>A grammar mainly consists of a set of rules for transforming strings. (If it <em>only</em> consisted of these rules, it would be a <a href="semi-Thue_system" title="wikilink">semi-Thue system</a>.) To generate a string in the language, one begins with a string consisting of only a single <em>start symbol</em>. The <em><a href="Production_(computer_science)" title="wikilink">production rules</a></em> are then applied in any order, until a string that contains neither the start symbol nor designated <em>nonterminal symbols</em> is produced. A production rule is applied to a string by replacing one occurrence of the production rule's left-hand side in the string by that production rule's right-hand side (<em>cf.</em> the operation of the theoretical <a href="Turing_machine" title="wikilink">Turing machine</a>). The language formed by the grammar consists of all distinct strings that can be generated in this manner. Any particular sequence of production rules on the start symbol yields a distinct string in the language. If there are essentially different ways of generating the same single string, the grammar is said to be <a href="ambiguous_grammar" title="wikilink">ambiguous</a>.</p>

<p>For example, assume the alphabet consists of <em>a</em> and <em>b</em>, the start symbol is <em>S</em>, and we have the following production rules:</p>
<dl>
<dd>1. 

<math display="inline" id="Formal_grammar:0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mrow>
    <mi>a</mi>
    <mi>S</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>S</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\rightarrow aSb
  </annotation>
 </semantics>
</math>


</dd>
<dd>2. 

<math display="inline" id="Formal_grammar:1">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mrow>
    <mi>b</mi>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\rightarrow ba
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>then we start with <em>S</em>, and can choose a rule to apply to it. If we choose rule 1, we obtain the string <em>aSb</em>. If we then choose rule 1 again, we replace <em>S</em> with <em>aSb</em> and obtain the string <em>aaSbb</em>. If we now choose rule 2, we replace <em>S</em> with <em>ba</em> and obtain the string <em>aababb</em>, and are done. We can write this series of choices more briefly, using symbols

<math display="block" id="Formal_grammar:2">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>a</mi>
    <mi>S</mi>
    <mi>b</mi>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>a</mi>
    <mi>a</mi>
    <mi>S</mi>
    <mi>b</mi>
    <mi>b</mi>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>a</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>S</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>S</ci>
      <ci>b</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>b</ci>
      <ci>a</ci>
      <ci>b</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\Rightarrow aSb\Rightarrow aaSbb\Rightarrow aababb
  </annotation>
 </semantics>
</math>

. The language of the grammar is then the infinite set 

<math display="inline" id="Formal_grammar:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
     <mi>b</mi>
     <mi>a</mi>
     <msup>
      <mi>b</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>n</mi>
     <mo>≥</mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>b</mi>
     <mi>a</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mi>a</mi>
     <mi>b</mi>
     <mi>a</mi>
     <mi>b</mi>
     <mi>b</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mi>a</mi>
     <mi>a</mi>
     <mi>b</mi>
     <mi>a</mi>
     <mi>b</mi>
     <mi>b</mi>
     <mi>b</mi>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <ci>b</ci>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <set>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>b</ci>
      <ci>a</ci>
      <ci>b</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>a</ci>
      <ci>b</ci>
      <ci>a</ci>
      <ci>b</ci>
      <ci>b</ci>
      <ci>b</ci>
     </apply>
     <ci>normal-…</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a^{n}bab^{n}|n\geq 0\}=\{ba,abab,aababb,aaababbb,\ldots\}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Formal_grammar:4">
 <semantics>
  <msup>
   <mi>a</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>a</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{k}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Formal_grammar:5">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 repeated 

<math display="inline" id="Formal_grammar:6">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 times (and 

<math display="inline" id="Formal_grammar:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 in particular represents the number of times production rule 1 has been applied).</p>
<h2 id="formal-definition">Formal definition</h2>
<h3 id="the-syntax-of-grammars">The syntax of grammars</h3>

<p>In the classic formalization of generative grammars first proposed by <a href="Noam_Chomsky" title="wikilink">Noam Chomsky</a> in the 1950s,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> a grammar <em>G</em> consists of the following components:</p>
<ul>
<li>A finite set <em>N</em> of <em><a href="nonterminal_symbol" title="wikilink">nonterminal symbols</a></em>, that is <a href="Disjoint_sets" title="wikilink">disjoint</a> with the strings formed from <em>G</em>.</li>
<li>A finite set 

<math display="inline" id="Formal_grammar:8">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 of <em><a href="terminal_symbol" title="wikilink">terminal symbols</a></em> that is <a href="Disjoint_sets" title="wikilink">disjoint</a> from <em>N</em>.</li>
<li>A finite set <em>P</em> of <em>production rules</em>, each rule of the form</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Formal_grammar:9">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Σ</mi>
       <mo>∪</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
    <mi>N</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Σ</mi>
       <mo>∪</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>→</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mo>∪</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <union></union>
       <ci>normal-Σ</ci>
       <ci>N</ci>
      </apply>
      <times></times>
     </apply>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <union></union>
       <ci>normal-Σ</ci>
       <ci>N</ci>
      </apply>
      <times></times>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <union></union>
      <ci>normal-Σ</ci>
      <ci>N</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Sigma\cup N)^{*}N(\Sigma\cup N)^{*}\rightarrow(\Sigma\cup N)^{*}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>where 

<math display="inline" id="Formal_grammar:10">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {*}
  </annotation>
 </semantics>
</math>

 is the <a href="Kleene_star" title="wikilink">Kleene star</a> operator and 

<math display="inline" id="Formal_grammar:11">
 <semantics>
  <mo>∪</mo>
  <annotation-xml encoding="MathML-Content">
   <union></union>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup
  </annotation>
 </semantics>
</math>

 denotes <a href="union_(set_theory)" title="wikilink">set union</a>. That is, each production rule maps from one string of symbols to another, where the first string (the "head") contains an arbitrary number of symbols provided at least one of them is a nonterminal. In the case that the second string (the "body") consists solely of the <a href="empty_string" title="wikilink">empty string</a> – i.e., that it contains no symbols at all – it may be denoted with a special notation (often 

<math display="inline" id="Formal_grammar:12">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

, <em>e</em> or 

<math display="inline" id="Formal_grammar:13">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

) in order to avoid confusion.
</dd>
</dl>
<ul>
<li>A distinguished symbol 

<math display="inline" id="Formal_grammar:14">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∈</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in N
  </annotation>
 </semantics>
</math>

 that is the <em>start symbol</em>, also called the <em>sentence symbol</em>.</li>
</ul>

<p>A grammar is formally defined as the <a class="uri" href="tuple" title="wikilink">tuple</a> 

<math display="inline" id="Formal_grammar:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>N</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
   <mi>P</mi>
   <mo>,</mo>
   <mi>S</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>N</ci>
    <ci>normal-Σ</ci>
    <ci>P</ci>
    <ci>S</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N,\Sigma,P,S)
  </annotation>
 </semantics>
</math>

. Such a formal grammar is often called a <a href="rewriting_system" title="wikilink">rewriting system</a> or a <a href="phrase_structure_grammar" title="wikilink">phrase structure grammar</a> in the literature.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="the-semantics-of-grammars">The semantics of grammars</h3>

<p>The operation of a grammar can be defined in terms of relations on strings:</p>
<ul>
<li>Given a grammar 

<math display="inline" id="Formal_grammar:16">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <ci>N</ci>
     <ci>normal-Σ</ci>
     <ci>P</ci>
     <ci>S</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(N,\Sigma,P,S)
  </annotation>
 </semantics>
</math>

, the binary relation 

<math display="inline" id="Formal_grammar:17">
 <semantics>
  <msub>
   <mo>⇒</mo>
   <mi>G</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-⇒</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow_{G}
  </annotation>
 </semantics>
</math>

 (pronounced as "G derives in one step") on strings in 

<math display="inline" id="Formal_grammar:18">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Σ</mi>
     <mo>∪</mo>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <union></union>
     <ci>normal-Σ</ci>
     <ci>N</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Sigma\cup N)^{*}
  </annotation>
 </semantics>
</math>

 is defined by:</li>
</ul>

<p>

<math display="inline" id="Formal_grammar:19">
 <semantics>
  <mrow>
   <mi>x</mi>
   <msub>
    <mo>⇒</mo>
    <mi>G</mi>
   </msub>
   <mi>y</mi>
   <mtext>iff</mtext>
   <mo>∃</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Σ</mi>
     <mo>∪</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mi>p</mi>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
    <mo>∈</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mi>q</mi>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-⇒</ci>
     <ci>G</ci>
    </apply>
    <csymbol cd="unknown">y</csymbol>
    <mtext>iff</mtext>
    <exists></exists>
    <csymbol cd="unknown">u</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">v</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">q</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Σ</csymbol>
      <union></union>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
    </apply>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">q</csymbol>
     <in></in>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\Rightarrow_{G}y\mbox{ iff }\exists u,v,p,q\in(\Sigma\cup N)^{*}:(x=upv)%
\wedge(p\rightarrow q\in P)\wedge(y=uqv)
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>the relation 

<math display="inline" id="Formal_grammar:20">
 <semantics>
  <mmultiscripts>
   <mo>⇒</mo>
   <mi>G</mi>
   <none></none>
   <none></none>
   <mo>*</mo>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-⇒</ci>
     <ci>G</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Rightarrow_{G}}^{*}
  </annotation>
 </semantics>
</math>

 (pronounced as <em>G derives in zero or more steps</em>) is defined as the <a href="reflexive_transitive_closure" title="wikilink">reflexive transitive closure</a> of 

<math display="inline" id="Formal_grammar:21">
 <semantics>
  <msub>
   <mo>⇒</mo>
   <mi>G</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-⇒</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow_{G}
  </annotation>
 </semantics>
</math>

</li>
<li>a <em>sentential form</em> is a member of 

<math display="inline" id="Formal_grammar:22">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Σ</mi>
     <mo>∪</mo>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <union></union>
     <ci>normal-Σ</ci>
     <ci>N</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Sigma\cup N)^{*}
  </annotation>
 </semantics>
</math>

 that can be derived in a finite number of steps from the start symbol 

<math display="inline" id="Formal_grammar:23">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

; that is, a sentential form is a member of 

<math display="inline" id="Formal_grammar:24">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>w</mi>
    <mo>∈</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Σ</mi>
       <mo>∪</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>S</mi>
    <mmultiscripts>
     <mo>⇒</mo>
     <mi>G</mi>
     <none></none>
     <none></none>
     <mo>*</mo>
    </mmultiscripts>
    <mi>w</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <union></union>
       <ci>normal-Σ</ci>
       <ci>N</ci>
      </apply>
      <times></times>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-⇒</ci>
       <ci>G</ci>
      </apply>
      <times></times>
     </apply>
     <ci>S</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{w\in(\Sigma\cup N)^{*}\mid S{\Rightarrow_{G}}^{*}w\}
  </annotation>
 </semantics>
</math>

. A sentential form that contains no nonterminal symbols (i.e. is a member of 

<math display="inline" id="Formal_grammar:25">
 <semantics>
  <msup>
   <mi mathvariant="normal">Σ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Σ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{*}
  </annotation>
 </semantics>
</math>

) is called a <em>sentence</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>the <em>language</em> of 

<math display="inline" id="Formal_grammar:26">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, denoted as 

<math display="inline" id="Formal_grammar:27">
 <semantics>
  <mrow>
   <mi>𝑳</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑳</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{L}(G)
  </annotation>
 </semantics>
</math>

, is defined as all those sentences that can be derived in a finite number of steps from the start symbol 

<math display="inline" id="Formal_grammar:28">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

; that is, the set 

<math display="inline" id="Formal_grammar:29">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>w</mi>
    <mo>∈</mo>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mi>S</mi>
    <mmultiscripts>
     <mo>⇒</mo>
     <mi>G</mi>
     <none></none>
     <none></none>
     <mo>*</mo>
    </mmultiscripts>
    <mi>w</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-⇒</ci>
       <ci>G</ci>
      </apply>
      <times></times>
     </apply>
     <ci>S</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{w\in\Sigma^{*}\mid S{\Rightarrow_{G}}^{*}w\}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Note that the grammar 

<math display="inline" id="Formal_grammar:30">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <ci>N</ci>
     <ci>normal-Σ</ci>
     <ci>P</ci>
     <ci>S</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(N,\Sigma,P,S)
  </annotation>
 </semantics>
</math>

 is effectively the <a href="semi-Thue_system" title="wikilink">semi-Thue system</a> 

<math display="inline" id="Formal_grammar:31">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>N</mi>
    <mo>∪</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <union></union>
     <ci>N</ci>
     <ci>normal-Σ</ci>
    </apply>
    <ci>P</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N\cup\Sigma,P)
  </annotation>
 </semantics>
</math>

, rewriting strings in exactly the same way; the only difference is in that we distinguish specific <em>nonterminal</em> symbols which must be rewritten in rewrite rules, and are only interested in rewritings from the designated start symbol 

<math display="inline" id="Formal_grammar:32">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to strings without nonterminal symbols.</p>
<h3 id="example">Example</h3>

<p><em>For these examples, formal languages are specified using <a href="set-builder_notation" title="wikilink">set-builder notation</a>.</em></p>

<p>Consider the grammar 

<math display="inline" id="Formal_grammar:33">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Formal_grammar:34">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <set>
     <ci>S</ci>
     <ci>B</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=\left\{S,B\right\}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Formal_grammar:35">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>c</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Σ</ci>
    <set>
     <ci>a</ci>
     <ci>b</ci>
     <ci>c</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma=\left\{a,b,c\right\}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Formal_grammar:36">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the start symbol, and 

<math display="inline" id="Formal_grammar:37">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 consists of the following production rules:</p>
<dl>
<dd>1. 

<math display="inline" id="Formal_grammar:38">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mrow>
    <mi>a</mi>
    <mi>B</mi>
    <mi>S</mi>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>B</ci>
     <ci>S</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\rightarrow aBSc
  </annotation>
 </semantics>
</math>


</dd>
<dd>2. 

<math display="inline" id="Formal_grammar:39">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mrow>
    <mi>a</mi>
    <mi>b</mi>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\rightarrow abc
  </annotation>
 </semantics>
</math>


</dd>
<dd>3. 

<math display="inline" id="Formal_grammar:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mi>a</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>a</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ba\rightarrow aB
  </annotation>
 </semantics>
</math>


</dd>
<dd>4. 

<math display="inline" id="Formal_grammar:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mi>b</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>b</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Bb\rightarrow bb
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>This grammar defines the language 

<math display="inline" id="Formal_grammar:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>b</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>c</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>n</mi>
     <mo>≥</mo>
     <mn>1</mn>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(G)=\left\{a^{n}b^{n}c^{n}|n\geq 1\right\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Formal_grammar:43">
 <semantics>
  <msup>
   <mi>a</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>a</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{n}
  </annotation>
 </semantics>
</math>

 denotes a string of <em>n</em> consecutive 

<math display="inline" id="Formal_grammar:44">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

's. Thus, the language is the set of strings that consist of 1 or more 

<math display="inline" id="Formal_grammar:45">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

's, followed by the same number of 

<math display="inline" id="Formal_grammar:46">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

's, followed by the same number of 

<math display="inline" id="Formal_grammar:47">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

's.</p>

<p>Some examples of the derivation of strings in 

<math display="inline" id="Formal_grammar:48">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(G)
  </annotation>
 </semantics>
</math>

 are:</p>
<ul>
<li>

<math display="inline" id="Formal_grammar:49">
 <semantics>
  <mrow>
   <mi>𝑺</mi>
   <msub>
    <mo>⇒</mo>
    <mn>2</mn>
   </msub>
   <mrow>
    <mi>𝒂</mi>
    <mi>𝒃</mi>
    <mi>𝒄</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-⇒</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>𝑺</ci>
    <apply>
     <times></times>
     <ci>𝒂</ci>
     <ci>𝒃</ci>
     <ci>𝒄</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{S}\Rightarrow_{2}\boldsymbol{abc}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Formal_grammar:50">
 <semantics>
  <mrow>
   <mi>𝑺</mi>
   <msub>
    <mo>⇒</mo>
    <mn>1</mn>
   </msub>
   <mrow>
    <mi>𝒂</mi>
    <mi>𝑩</mi>
    <mi>𝑺</mi>
    <mi>𝒄</mi>
   </mrow>
   <msub>
    <mo>⇒</mo>
    <mn>2</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>B</mi>
    <mi>𝒂</mi>
    <mi>𝒃</mi>
    <mi>𝒄</mi>
    <mi>c</mi>
   </mrow>
   <msub>
    <mo>⇒</mo>
    <mn>3</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>𝒂</mi>
    <mi>𝑩</mi>
    <mi>b</mi>
    <mi>c</mi>
    <mi>c</mi>
   </mrow>
   <msub>
    <mo>⇒</mo>
    <mn>4</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>a</mi>
    <mi>𝒃</mi>
    <mi>𝒃</mi>
    <mi>c</mi>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>𝑺</ci>
     <apply>
      <times></times>
      <ci>𝒂</ci>
      <ci>𝑩</ci>
      <ci>𝑺</ci>
      <ci>𝒄</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">2</cn>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>B</ci>
      <ci>𝒂</ci>
      <ci>𝒃</ci>
      <ci>𝒄</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">3</cn>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>𝒂</ci>
      <ci>𝑩</ci>
      <ci>b</ci>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">4</cn>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>𝒃</ci>
      <ci>𝒃</ci>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{S}\Rightarrow_{1}\boldsymbol{aBSc}\Rightarrow_{2}aB\boldsymbol{abc%
}c\Rightarrow_{3}a\boldsymbol{aB}bcc\Rightarrow_{4}aa\boldsymbol{bb}cc
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Formal_grammar:51">
 <semantics>
  <mrow>
   <mi>𝑺</mi>
   <msub>
    <mo>⇒</mo>
    <mn>1</mn>
   </msub>
   <mrow>
    <mi>𝒂</mi>
    <mi>𝑩</mi>
    <mi>𝑺</mi>
    <mi>𝒄</mi>
   </mrow>
   <msub>
    <mo>⇒</mo>
    <mn>1</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>B</mi>
    <mi>𝒂</mi>
    <mi>𝑩</mi>
    <mi>𝑺</mi>
    <mi>𝒄</mi>
    <mi>c</mi>
   </mrow>
   <msub>
    <mo>⇒</mo>
    <mn>2</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>B</mi>
    <mi>a</mi>
    <mi>B</mi>
    <mi>𝒂</mi>
    <mi>𝒃</mi>
    <mi>𝒄</mi>
    <mi>c</mi>
    <mi>c</mi>
   </mrow>
   <msub>
    <mo>⇒</mo>
    <mn>3</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>𝒂</mi>
    <mi>𝑩</mi>
    <mi>B</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>c</mi>
    <mi>c</mi>
    <mi>c</mi>
   </mrow>
   <msub>
    <mo>⇒</mo>
    <mn>3</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>a</mi>
    <mi>B</mi>
    <mi>𝒂</mi>
    <mi>𝑩</mi>
    <mi>b</mi>
    <mi>c</mi>
    <mi>c</mi>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>𝑺</ci>
     <apply>
      <times></times>
      <ci>𝒂</ci>
      <ci>𝑩</ci>
      <ci>𝑺</ci>
      <ci>𝒄</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">1</cn>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>B</ci>
      <ci>𝒂</ci>
      <ci>𝑩</ci>
      <ci>𝑺</ci>
      <ci>𝒄</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">2</cn>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>B</ci>
      <ci>a</ci>
      <ci>B</ci>
      <ci>𝒂</ci>
      <ci>𝒃</ci>
      <ci>𝒄</ci>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">3</cn>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>𝒂</ci>
      <ci>𝑩</ci>
      <ci>B</ci>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">3</cn>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>B</ci>
      <ci>𝒂</ci>
      <ci>𝑩</ci>
      <ci>b</ci>
      <ci>c</ci>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{S}\Rightarrow_{1}\boldsymbol{aBSc}\Rightarrow_{1}aB\boldsymbol{%
aBSc}c\Rightarrow_{2}aBaB\boldsymbol{abc}cc\Rightarrow_{3}a\boldsymbol{aB}%
Babccc\Rightarrow_{3}aaB\boldsymbol{aB}bccc
  </annotation>
 </semantics>
</math>



<math display="inline" id="Formal_grammar:52">
 <semantics>
  <mrow>
   <mi></mi>
   <msub>
    <mo>⇒</mo>
    <mn>3</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>a</mi>
    <mi>𝒂</mi>
    <mi>𝑩</mi>
    <mi>B</mi>
    <mi>b</mi>
    <mi>c</mi>
    <mi>c</mi>
    <mi>c</mi>
   </mrow>
   <msub>
    <mo>⇒</mo>
    <mn>4</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>a</mi>
    <mi>a</mi>
    <mi>B</mi>
    <mi>𝒃</mi>
    <mi>𝒃</mi>
    <mi>c</mi>
    <mi>c</mi>
    <mi>c</mi>
   </mrow>
   <msub>
    <mo>⇒</mo>
    <mn>4</mn>
   </msub>
   <mrow>
    <mi>a</mi>
    <mi>a</mi>
    <mi>a</mi>
    <mi>𝒃</mi>
    <mi>𝒃</mi>
    <mi>b</mi>
    <mi>c</mi>
    <mi>c</mi>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">3</cn>
     </apply>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>𝒂</ci>
      <ci>𝑩</ci>
      <ci>B</ci>
      <ci>b</ci>
      <ci>c</ci>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">4</cn>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>a</ci>
      <ci>B</ci>
      <ci>𝒃</ci>
      <ci>𝒃</ci>
      <ci>c</ci>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-⇒</ci>
      <cn type="integer">4</cn>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>a</ci>
      <ci>𝒃</ci>
      <ci>𝒃</ci>
      <ci>b</ci>
      <ci>c</ci>
      <ci>c</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow_{3}aa\boldsymbol{aB}Bbccc\Rightarrow_{4}aaaB\boldsymbol{bb}ccc%
\Rightarrow_{4}aaa\boldsymbol{bb}bccc
  </annotation>
 </semantics>
</math>

</li>
</ul>
<dl>
<dd>(Note on notation

<math display="block" id="Formal_grammar:53">
 <semantics>
  <mrow>
   <mi>P</mi>
   <msub>
    <mo>⇒</mo>
    <mi>i</mi>
   </msub>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-⇒</ci>
     <ci>i</ci>
    </apply>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\Rightarrow_{i}Q
  </annotation>
 </semantics>
</math>

 reads "String <em>P</em> generates string <em>Q</em> by means of production <em>i</em>", and the generated part is each time indicated in bold type.)
</dd>
</dl>
<h2 id="the-chomsky-hierarchy">The Chomsky hierarchy</h2>

<p>When <a href="Noam_Chomsky" title="wikilink">Noam Chomsky</a> first formalized generative grammars in 1956,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> he classified them into types now known as the <a href="Chomsky_hierarchy" title="wikilink">Chomsky hierarchy</a>. The difference between these types is that they have increasingly strict production rules and can express fewer formal languages. Two important types are <em><a href="context-free_grammar" title="wikilink">context-free grammars</a></em> (Type 2) and <em><a href="regular_grammar" title="wikilink">regular grammars</a></em> (Type 3). The languages that can be described with such a grammar are called <em><a href="context-free_language" title="wikilink">context-free languages</a></em> and <em><a href="regular_language" title="wikilink">regular languages</a></em>, respectively. Although much less powerful than <a href="unrestricted_grammar" title="wikilink">unrestricted grammars</a> (Type 0), which can in fact express any language that can be accepted by a <a href="Turing_machine" title="wikilink">Turing machine</a>, these two restricted types of grammars are most often used because <a href="parsing" title="wikilink">parsers</a> for them can be efficiently implemented.<ref name="Grune&amp;Jacobs1990">Grune, Dick &amp; Jacobs, Ceriel H., <em>Parsing Techniques – A Practical Guide</em>, Ellis Horwood, England, 1990. For example, all regular languages can be recognized by a <a href="finite_state_machine" title="wikilink">finite state machine</a>, and for useful subsets of context-free grammars there are well-known algorithms to generate efficient <a href="LL_parser" title="wikilink">LL parsers</a> and <a href="LR_parser" title="wikilink">LR parsers</a> to recognize the corresponding languages those grammars generate.</ref></p>
<h3 id="context-free-grammars">Context-free grammars</h3>

<p>A <em><a href="context-free_grammar" title="wikilink">context-free grammar</a></em> is a grammar in which the left-hand side of each production rule consists of only a single nonterminal symbol. This restriction is non-trivial; not all languages can be generated by context-free grammars. Those that can are called <em>context-free languages</em>.</p>

<p>The language 

<math display="inline" id="Formal_grammar:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>b</mi>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>c</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>n</mi>
     <mo>≥</mo>
     <mn>1</mn>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(G)=\left\{a^{n}b^{n}c^{n}|n\geq 1\right\}
  </annotation>
 </semantics>
</math>

 defined above is not a context-free language, and this can be strictly proven using the <a href="pumping_lemma_for_context-free_languages" title="wikilink">pumping lemma for context-free languages</a>, but for example the language 

<math display="inline" id="Formal_grammar:55">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>b</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>1</mn>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{a^{n}b^{n}|n\geq 1\right\}
  </annotation>
 </semantics>
</math>

 (at least 1 

<math display="inline" id="Formal_grammar:56">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 followed by the same number of 

<math display="inline" id="Formal_grammar:57">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

's) is context-free, as it can be defined by the grammar 

<math display="inline" id="Formal_grammar:58">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{2}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Formal_grammar:59">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>S</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <set>
     <ci>S</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=\left\{S\right\}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Formal_grammar:60">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Σ</ci>
    <set>
     <ci>a</ci>
     <ci>b</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma=\left\{a,b\right\}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Formal_grammar:61">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 the start symbol, and the following production rules:</p>
<dl>
<dd>1. 

<math display="inline" id="Formal_grammar:62">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mrow>
    <mi>a</mi>
    <mi>S</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>S</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\rightarrow aSb
  </annotation>
 </semantics>
</math>


</dd>
<dd>2. 

<math display="inline" id="Formal_grammar:63">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mrow>
    <mi>a</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\rightarrow ab
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>A context-free language can be recognized in 

<math display="inline" id="Formal_grammar:64">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 time (<em>see</em> <a href="Big_O_notation" title="wikilink">Big O notation</a>) by an algorithm such as <a href="Earley's_algorithm" title="wikilink">Earley's algorithm</a>. That is, for every context-free language, a machine can be built that takes a string as input and determines in 

<math display="inline" id="Formal_grammar:65">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 time whether the string is a member of the language, where 

<math display="inline" id="Formal_grammar:66">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the length of the string.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a href="Deterministic_context-free_language" title="wikilink">Deterministic context-free languages</a> is a subset of context-free languages that can be recognized in linear time.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> There exist various algorithms that target either this set of languages or some subset of it.</p>
<h3 id="regular-grammars">Regular grammars</h3>

<p>In <a href="regular_grammar" title="wikilink">regular grammars</a>, the left hand side is again only a single nonterminal symbol, but now the right-hand side is also restricted. The right side may be the empty string, or a single terminal symbol, or a single terminal symbol followed by a nonterminal symbol, but nothing else. (Sometimes a broader definition is used: one can allow longer strings of terminals or single nonterminals without anything else, making languages <a href="syntactic_sugar" title="wikilink">easier to denote</a> while still defining the same class of languages.)</p>

<p>The language 

<math display="inline" id="Formal_grammar:67">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>b</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>1</mn>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{a^{n}b^{n}|n\geq 1\right\}
  </annotation>
 </semantics>
</math>

 defined above is not regular, but the language 

<math display="inline" id="Formal_grammar:68">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>n</mi>
    </msup>
    <mpadded width="+1.7pt">
     <msup>
      <mi>b</mi>
      <mi>m</mi>
     </msup>
    </mpadded>
   </mrow>
   <mo rspace="4.2pt" stretchy="false">|</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
    <mo>≥</mo>
    <mn>1</mn>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <list>
      <ci>m</ci>
      <ci>n</ci>
     </list>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{a^{n}b^{m}\,|\,m,n\geq 1\right\}
  </annotation>
 </semantics>
</math>

 (at least 1 

<math display="inline" id="Formal_grammar:69">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 followed by at least 1 

<math display="inline" id="Formal_grammar:70">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, where the numbers may be different) is, as it can be defined by the grammar 

<math display="inline" id="Formal_grammar:71">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{3}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Formal_grammar:72">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <set>
     <ci>S</ci>
     <ci>A</ci>
     <ci>B</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=\left\{S,A,B\right\}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Formal_grammar:73">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Σ</ci>
    <set>
     <ci>a</ci>
     <ci>b</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma=\left\{a,b\right\}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Formal_grammar:74">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 the start symbol, and the following production rules:</p>

<p>:# 

<math display="inline" id="Formal_grammar:75">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mrow>
    <mi>a</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\rightarrow aA
  </annotation>
 </semantics>
</math>

</p>

<p>:# 

<math display="inline" id="Formal_grammar:76">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mi>a</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow aA
  </annotation>
 </semantics>
</math>

</p>

<p>:# 

<math display="inline" id="Formal_grammar:77">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mi>b</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow bB
  </annotation>
 </semantics>
</math>

</p>

<p>:# 

<math display="inline" id="Formal_grammar:78">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>→</mo>
   <mrow>
    <mi>b</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\rightarrow bB
  </annotation>
 </semantics>
</math>

</p>

<p>:# 

<math display="inline" id="Formal_grammar:79">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>→</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>B</ci>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\rightarrow\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>All languages generated by a regular grammar can be recognized in linear time by a <a href="finite_state_machine" title="wikilink">finite state machine</a>. Although, in practice, regular grammars are commonly expressed using <a href="regular_expression" title="wikilink">regular expressions</a>, some forms of regular expression used in practice do not strictly generate the regular languages and do not show linear recognitional performance due to those deviations.</p>
<h3 id="other-forms-of-generative-grammars">Other forms of generative grammars</h3>

<p>Many extensions and variations on Chomsky's original hierarchy of formal grammars have been developed, both by linguists and by computer scientists, usually either in order to increase their expressive power or in order to make them easier to analyze or <a href="parsing" title="wikilink">parse</a>. Some forms of grammars developed include:</p>
<ul>
<li><a href="Tree-adjoining_grammar" title="wikilink">Tree-adjoining grammars</a> increase the expressiveness of conventional generative grammars by allowing rewrite rules to operate on <a href="parse_tree" title="wikilink">parse trees</a> instead of just strings.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li><a href="Affix_grammar" title="wikilink">Affix grammars</a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and <a href="attribute_grammar" title="wikilink">attribute grammars</a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> allow rewrite rules to be augmented with semantic attributes and operations, useful both for increasing grammar expressiveness and for constructing practical language translation tools.</li>
</ul>
<h3 id="recursive-grammars">Recursive grammars</h3>

<p>A recursive grammar is a grammar which contains production rules that are <a href="recursion_(computer_science)" title="wikilink">recursive</a>. For example, a grammar for a <a href="context-free_language" title="wikilink">context-free language</a> is <a href="left_recursion" title="wikilink">left-recursive</a> if there exists a non-terminal symbol <em>A</em> that can be put through the production rules to produce a string with <em>A</em> as the leftmost symbol.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> All types of grammars in the <a href="Chomsky_hierarchy" title="wikilink">Chomsky hierarchy</a> can be recursive.</p>
<h2 id="analytic-grammars">Analytic grammars</h2>

<p>Though there is a tremendous body of literature on <a class="uri" href="parsing" title="wikilink">parsing</a> <a class="uri" href="algorithms" title="wikilink">algorithms</a>, most of these algorithms assume that the language to be parsed is initially <em>described</em> by means of a <em>generative</em> formal grammar, and that the goal is to transform this generative grammar into a working parser. Strictly speaking, a generative grammar does not in any way correspond to the algorithm used to parse a language, and various algorithms have different restrictions on the form of production rules that are considered well-formed.</p>

<p>An alternative approach is to formalize the language in terms of an analytic grammar in the first place, which more directly corresponds to the structure and semantics of a parser for the language. Examples of analytic grammar formalisms include the following:</p>
<ul>
<li><a href="http://languagemachine.sourceforge.net/">The Language Machine</a> directly implements unrestricted analytic grammars. Substitution rules are used to transform an input to produce outputs and behaviour. The system can also produce <a href="http://languagemachine.sourceforge.net/picturebook.html">the lm-diagram</a> which shows what happens when the rules of an unrestricted analytic grammar are being applied.</li>
<li><a href="Top-down_parsing_language" title="wikilink">Top-down parsing language</a> (TDPL): a highly minimalist analytic grammar formalism developed in the early 1970s to study the behavior of <a href="Top-down_parsing" title="wikilink">top-down parsers</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
<li><a href="Link_grammar" title="wikilink">Link grammars</a>: a form of analytic grammar designed for <a class="uri" href="linguistics" title="wikilink">linguistics</a>, which derives syntactic structure by examining the positional relationships between pairs of words.<ref name="Sleater&amp;Temperly1991">Sleator, Daniel D. &amp; Temperly, Davy, "Parsing English with a Link Grammar," Technical Report CMU-CS-91-196, Carnegie Mellon University Computer Science, 1991.<ref name="Sleater&amp;Temperly1993">Sleator, Daniel D. &amp; Temperly, Davy, "Parsing English with a Link Grammar," <em>Third International Workshop on Parsing Technologies</em>, 1993. (Revised version of above report.)</ref></ref></li>
<li><a href="Parsing_expression_grammar" title="wikilink">Parsing expression grammars</a> (PEGs): a more recent generalization of TDPL designed around the practical <a href="Expressivity_(computer_science)" title="wikilink">expressiveness</a> needs of <a href="programming_language" title="wikilink">programming language</a> and <a class="uri" href="compiler" title="wikilink">compiler</a> writers.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Abstract_syntax_tree" title="wikilink">Abstract syntax tree</a></li>
<li><a href="Adaptive_grammar" title="wikilink">Adaptive grammar</a></li>
<li><a href="Ambiguous_grammar" title="wikilink">Ambiguous grammar</a></li>
<li><a href="Backus–Naur_form" title="wikilink">Backus–Naur form (BNF)</a></li>
<li><a href="Categorial_grammar" title="wikilink">Categorial grammar</a></li>
<li><a href="Concrete_syntax_tree" title="wikilink">Concrete syntax tree</a></li>
<li><a href="Extended_Backus–Naur_form" title="wikilink">Extended Backus–Naur form (EBNF)</a></li>
<li><a href="Grammar_framework" title="wikilink">Grammar framework</a></li>
<li><a class="uri" href="L-system" title="wikilink">L-system</a></li>
<li><a class="uri" href="Lojban" title="wikilink">Lojban</a></li>
<li><a href="Post_canonical_system" title="wikilink">Post canonical system</a></li>
<li><a href="Shape_grammar" title="wikilink">Shape grammar</a></li>
<li><a href="Well-formed_formula" title="wikilink">Well-formed formula</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://cs.haifa.ac.il/~shuly/fg/">Yearly Formal Grammar conference</a></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a class="uri" href="Category:Grammar" title="wikilink">Category:Grammar</a> <a class="uri" href="Category:Linguistics" title="wikilink">Category:Linguistics</a> <a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a> <a class="uri" href="Category:Syntax" title="wikilink">Category:Syntax</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">. For more on this subject, see <a href="undecidable_problem" title="wikilink">undecidable problem</a>.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="http://www.seas.upenn.edu/~cit596/notes/dave/cfg7.html">Sentential Forms</a>, Context-Free Grammars, David Matuszek<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8">Earley, Jay, "An Efficient Context-Free Parsing Algorithm," <em>Communications of the ACM</em>, Vol. 13 No. 2, pp. 94-102, February 1970.<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Joshi, Aravind K., <em>et al.</em>, "Tree Adjunct Grammars," <em>Journal of Computer Systems Science</em>, Vol. 10 No. 1, pp. 136-163, 1975.<a href="#fnref10">↩</a></li>
<li id="fn11">Koster , Cornelis H. A., "Affix Grammars," in <em>ALGOL 68 Implementation</em>, North Holland Publishing Company, Amsterdam, p. 95-109, 1971.<a href="#fnref11">↩</a></li>
<li id="fn12">Knuth, Donald E., "Semantics of Context-Free Languages," <em>Mathematical Systems Theory</em>, Vol. 2 No. 2, pp. 127-145, 1968.<a href="#fnref12">↩</a></li>
<li id="fn13">Knuth, Donald E., "Semantics of Context-Free Languages (correction)," <em>Mathematical Systems Theory</em>, Vol. 5 No. 1, pp 95-96, 1971.<a href="#fnref13">↩</a></li>
<li id="fn14">[<a class="uri" href="http://www.cs.may.ie/~jpower/Courses/parsing/parsing.pdf#search">http://www.cs.may.ie/~jpower/Courses/parsing/parsing.pdf#search</a>='indirect%20left%20recursion' Notes on Formal Language Theory and Parsing], James Power, Department of Computer Science National University of Ireland, Maynooth Maynooth, Co. Kildare, Ireland.<a class="uri" href="JPR02" title="wikilink">JPR02</a><a href="#fnref14">↩</a></li>
<li id="fn15">Birman, Alexander, <em>The TMG Recognition Schema</em>, Doctoral thesis, Princeton University, Dept. of Electrical Engineering, February 1970.<a href="#fnref15">↩</a></li>
<li id="fn16">Ford, Bryan, <em>Packrat Parsing: a Practical Linear-Time Algorithm with Backtracking</em>, Master’s thesis, Massachusetts Institute of Technology, Sept. 2002.<a href="#fnref16">↩</a></li>
</ol>
</section>
</body>
</html>
