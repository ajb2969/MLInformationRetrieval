<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1631">Segmentation-based object categorization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Segmentation-based object categorization</h1>
<hr/>

<p>The <a href="image_segmentation" title="wikilink">image segmentation</a> problem is concerned with partitioning an image into multiple regions according to some homogeneity criterion. This article is primarily concerned with graph theoretic approaches to image segmentation. <strong>Segmentation-based object categorization</strong> can be viewed as a specific case of <a href="spectral_clustering" title="wikilink">spectral clustering</a> applied to image segmentation.</p>
<h2 id="applications-of-image-segmentation">Applications of image segmentation</h2>
<ul>
<li><strong>Image compression</strong>
<ul>
<li>Segment the image into homogeneous components, and use the most suitable compression algorithm for each component to improve compression.</li>
</ul></li>
<li><strong>Medical diagnosis</strong>
<ul>
<li>Automatic segmentation of MRI images for identification of cancerous regions.</li>
</ul></li>
<li><strong>Mapping and measurement</strong>
<ul>
<li>Automatic analysis of remote sensing data from satellites to identify and measure regions of interest.</li>
</ul></li>
</ul>
<h2 id="segmentation-using-normalized-cuts">Segmentation using normalized cuts</h2>
<h3 id="graph-theoretic-formulation">Graph theoretic formulation</h3>

<p>The set of points in an arbitrary feature space can be represented as a weighted undirected complete graph G = (V, E), where the nodes of the graph are the points in the feature space. The weight 

<math display="inline" id="Segmentation-based_object_categorization:0">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

 of an edge 

<math display="inline" id="Segmentation-based_object_categorization:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)\in E
  </annotation>
 </semantics>
</math>

 is a function of the similarity between the nodes 

<math display="inline" id="Segmentation-based_object_categorization:2">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Segmentation-based_object_categorization:3">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

. In this context, we can formulate the image segmentation problem as a graph partitioning problem that asks for a partition 

<math display="inline" id="Segmentation-based_object_categorization:4">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>V</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{1},\cdots,V_{k}
  </annotation>
 </semantics>
</math>

 of the vertex set 

<math display="inline" id="Segmentation-based_object_categorization:5">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, where, according to some measure, the vertices in any set 

<math display="inline" id="Segmentation-based_object_categorization:6">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{i}
  </annotation>
 </semantics>
</math>

 have high similarity, and the vertices in two different sets 

<math display="inline" id="Segmentation-based_object_categorization:7">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>V</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{i},V_{j}
  </annotation>
 </semantics>
</math>

 have low similarity.</p>
<h3 id="normalized-cuts">Normalized cuts</h3>

<p>Let <em>G</em> = (<em>V</em>, <em>E</em>, <em>w</em>) be a weighted graph. Let 

<math display="inline" id="Segmentation-based_object_categorization:8">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Segmentation-based_object_categorization:9">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 be two subsets of vertices.</p>

<p>Let:</p>

<p>

<math display="block" id="Segmentation-based_object_categorization:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>A</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mi>B</mi>
      </mrow>
     </mrow>
    </munder>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>B</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>A</ci>
       </apply>
       <apply>
        <in></in>
        <ci>j</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(A,B)=\sum\limits_{i\in A,j\in B}w_{ij}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Segmentation-based_object_categorization:11">
 <semantics>
  <mrow>
   <mrow>
    <mo>ncut</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>V</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo>,</mo>
       <mi>V</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>ncut</ci>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>B</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>V</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>B</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>B</ci>
        <ci>V</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ncut}(A,B)=\frac{w(A,B)}{w(A,V)}+\frac{w(A,B)}{w(B,V)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Segmentation-based_object_categorization:12">
 <semantics>
  <mrow>
   <mrow>
    <mo>nassoc</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>V</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo>,</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo>,</mo>
       <mi>V</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>nassoc</ci>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>A</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>V</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>B</ci>
        <ci>B</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <ci>B</ci>
        <ci>V</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{nassoc}(A,B)=\frac{w(A,A)}{w(A,V)}+\frac{w(B,B)}{w(B,V)}
  </annotation>
 </semantics>
</math>

</p>

<p>In the normalized cuts approach,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> for any cut 

<math display="inline" id="Segmentation-based_object_categorization:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mover accent="true">
    <mi>S</mi>
    <mo>¯</mo>
   </mover>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>S</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\overline{S})
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Segmentation-based_object_categorization:14">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Segmentation-based_object_categorization:15">
 <semantics>
  <mrow>
   <mo>ncut</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>S</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>ncut</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ncut}(S,\overline{S})
  </annotation>
 </semantics>
</math>

 measures the similarity between different parts, and 

<math display="inline" id="Segmentation-based_object_categorization:16">
 <semantics>
  <mrow>
   <mo>nassoc</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>S</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>nassoc</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{nassoc}(S,\overline{S})
  </annotation>
 </semantics>
</math>

 measures the total similarity of vertices in the same part.</p>

<p>Since 

<math display="inline" id="Segmentation-based_object_categorization:17">
 <semantics>
  <mrow>
   <mrow>
    <mo>ncut</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mover accent="true">
      <mi>S</mi>
      <mo>¯</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>-</mo>
    <mrow>
     <mo>nassoc</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>S</mi>
       <mo>¯</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>ncut</ci>
     <ci>S</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
     <apply>
      <ci>nassoc</ci>
      <ci>S</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ncut}(S,\overline{S})=2-\operatorname{nassoc}(S,\overline{S})
  </annotation>
 </semantics>
</math>

, a cut 

<math display="inline" id="Segmentation-based_object_categorization:18">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>S</mi>
    <mo>*</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mover accent="true">
     <mi>S</mi>
     <mo>¯</mo>
    </mover>
    <mo>*</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>S</ci>
     </apply>
     <times></times>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S^{*},{\overline{S}}^{*})
  </annotation>
 </semantics>
</math>

 that minimizes 

<math display="inline" id="Segmentation-based_object_categorization:19">
 <semantics>
  <mrow>
   <mo>ncut</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>S</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>ncut</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ncut}(S,\overline{S})
  </annotation>
 </semantics>
</math>

 also maximizes 

<math display="inline" id="Segmentation-based_object_categorization:20">
 <semantics>
  <mrow>
   <mo>nassoc</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>S</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>nassoc</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{nassoc}(S,\overline{S})
  </annotation>
 </semantics>
</math>

.</p>

<p>Computing a cut 

<math display="inline" id="Segmentation-based_object_categorization:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>S</mi>
    <mo>*</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mover accent="true">
     <mi>S</mi>
     <mo>¯</mo>
    </mover>
    <mo>*</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>S</ci>
     </apply>
     <times></times>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S^{*},{\overline{S}}^{*})
  </annotation>
 </semantics>
</math>

 that minimizes 

<math display="inline" id="Segmentation-based_object_categorization:22">
 <semantics>
  <mrow>
   <mo>ncut</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>S</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>ncut</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ncut}(S,\overline{S})
  </annotation>
 </semantics>
</math>

 is an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> problem. However, we can find in polynomial time a cut 

<math display="inline" id="Segmentation-based_object_categorization:23">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mover accent="true">
    <mi>S</mi>
    <mo>¯</mo>
   </mover>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>S</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\overline{S})
  </annotation>
 </semantics>
</math>

 of small normalized weight 

<math display="inline" id="Segmentation-based_object_categorization:24">
 <semantics>
  <mrow>
   <mo>ncut</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>S</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>ncut</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ncut}(S,\overline{S})
  </annotation>
 </semantics>
</math>

 using <a href="Spectral_graph_theory" title="wikilink">spectral techniques</a>.</p>
<h3 id="the-ncut-algorithm">The ncut algorithm</h3>

<p>Let:</p>

<p>

<math display="block" id="Segmentation-based_object_categorization:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>j</mi>
    </munder>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(i)=\sum\limits_{j}w_{ij}
  </annotation>
 </semantics>
</math>

</p>

<p>Also, let <em>D</em> be an 

<math display="inline" id="Segmentation-based_object_categorization:26">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 diagonal matrix with 

<math display="inline" id="Segmentation-based_object_categorization:27">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 on the diagonal, and let 

<math display="inline" id="Segmentation-based_object_categorization:28">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 be an 

<math display="inline" id="Segmentation-based_object_categorization:29">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 symmetric matrix with 

<math display="inline" id="Segmentation-based_object_categorization:30">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>w</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ij}=w_{ij}
  </annotation>
 </semantics>
</math>

.</p>

<p>After some algebraic manipulations, we get:</p>

<p>

<math display="block" id="Segmentation-based_object_categorization:31">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>S</mi>
       <mo>¯</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </munder>
    <mrow>
     <mo>ncut</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>S</mi>
       <mo>¯</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mi>min</mi>
     <mi>y</mi>
    </munder>
    <mfrac>
     <mrow>
      <msup>
       <mi>y</mi>
       <mi>T</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>D</mi>
        <mo>-</mo>
        <mi>W</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>y</mi>
     </mrow>
     <mrow>
      <msup>
       <mi>y</mi>
       <mi>T</mi>
      </msup>
      <mi>D</mi>
      <mi>y</mi>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <interval closure="open">
       <ci>S</ci>
       <apply>
        <ci>normal-¯</ci>
        <ci>S</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <ci>ncut</ci>
      <ci>S</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <ci>y</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>D</ci>
        <ci>W</ci>
       </apply>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>T</ci>
       </apply>
       <ci>D</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\limits_{(S,\overline{S})}\operatorname{ncut}(S,\overline{S})=\min\limits_%
{y}\frac{y^{T}(D-W)y}{y^{T}Dy}
  </annotation>
 </semantics>
</math>

</p>

<p>subject to the constraints:</p>
<ul>
<li>

<math display="inline" id="Segmentation-based_object_categorization:32">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <set>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>b</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\in\{1,-b\}
  </annotation>
 </semantics>
</math>

, for some constant 

<math display="inline" id="Segmentation-based_object_categorization:33">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -b
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Segmentation-based_object_categorization:34">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>t</mi>
    </msup>
    <mi>D</mi>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <ci>D</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{t}D1=0
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Minimizing 

<math display="inline" id="Segmentation-based_object_categorization:35">
 <semantics>
  <mfrac>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>T</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>D</mi>
      <mo>-</mo>
      <mi>W</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>y</mi>
   </mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mi>T</mi>
    </msup>
    <mi>D</mi>
    <mi>y</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>D</ci>
      <ci>W</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>T</ci>
     </apply>
     <ci>D</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{y^{T}(D-W)y}{y^{T}Dy}
  </annotation>
 </semantics>
</math>

 subject to the constraints above is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>. To make the problem tractable, we relax the constraints on 

<math display="inline" id="Segmentation-based_object_categorization:36">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, and allow it to take real values. The relaxed problem can be solved by solving the generalized eigenvalue problem 

<math display="inline" id="Segmentation-based_object_categorization:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>D</mi>
      <mo>-</mo>
      <mi>W</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>D</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>D</ci>
      <ci>W</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>D</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (D-W)y=\lambda Dy
  </annotation>
 </semantics>
</math>

 for the second smallest generalized eigenvalue.</p>

<p><strong>The partitioning algorithm:</strong></p>
<ol>
<li>Given a set of features, set up a weighted graph 

<math display="inline" id="Segmentation-based_object_categorization:38">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

, compute the weight of each edge, and summarize the information in 

<math display="inline" id="Segmentation-based_object_categorization:39">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Segmentation-based_object_categorization:40">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

.</li>
<li>Solve 

<math display="inline" id="Segmentation-based_object_categorization:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>D</mi>
      <mo>-</mo>
      <mi>W</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>D</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>D</ci>
      <ci>W</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>D</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (D-W)y=\lambda Dy
  </annotation>
 </semantics>
</math>

 for eigenvectors with the smallest eigenvalues.</li>
<li>Use the eigenvector with the second smallest eigenvalue to bipartition the graph (e.g. grouping according to sign).</li>
<li>Decide if the current partition should be subdivided.</li>
<li>Recursively partition the segmented parts, if necessary.</li>
</ol>
<h3 id="computational-complexity">Computational Complexity</h3>

<p>Solving a standard eigenvalue problem for all eigenvectors (using the <a href="QR_algorithm" title="wikilink">QR algorithm</a>, for instance) takes 

<math display="inline" id="Segmentation-based_object_categorization:42">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 time. This is impractical for image segmentation applications where 

<math display="inline" id="Segmentation-based_object_categorization:43">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of pixels in the image.</p>

<p>Since only one eigenvector, corresponding to the second smallest generalized eigenvalue, is used by the ncut algorithm, efficiency can be dramatically improved if the solve of the corresponding eigenvalue problem is performed in a <a href="Matrix-free_methods" title="wikilink">matrix-free fashion</a>, i.e., without explicitly manipulating with or even computing the matrix W, as, e.g., in the <a href="Lanczos_algorithm" title="wikilink">Lanczos algorithm</a>. <a href="Matrix-free_methods" title="wikilink">Matrix-free methods</a> require only a function that performs a matrix-vector product for a given vector, on every iteration. For image segmentaion, the matrix W is typically sparse, with a number of nonzero entries 

<math display="inline" id="Segmentation-based_object_categorization:44">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

, so such a matrix-vector product takes 

<math display="inline" id="Segmentation-based_object_categorization:45">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time.</p>

<p>For high-resolution images, the second eigenvalue is often <a class="uri" href="ill-conditioned" title="wikilink">ill-conditioned</a>, leading to slow convergence of iterative eigenvalue solvers, such as the <a href="Lanczos_algorithm" title="wikilink">Lanczos algorithm</a>.<a href="Preconditioner#Preconditioning_for_eigenvalue_problems" title="wikilink">Preconditioning</a> is a key technology accelerating the convergence, e.g., in the matrix-free <a class="uri" href="LOBPCG" title="wikilink">LOBPCG</a> method. Computing the eigenvector using an optimally preconditioned matrix-free method takes 

<math display="inline" id="Segmentation-based_object_categorization:46">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time, which is the optimal complexity, since the eigenvector has 

<math display="inline" id="Segmentation-based_object_categorization:47">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 components.</p>
<h2 id="obj-cut">OBJ CUT</h2>

<p>OBJ CUT<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is an efficient method that automatically segments an object. The OBJ CUT method is a generic method, and therefore it is applicable to any object category model. Given an image D containing an instance of a known object category, e.g. cows, the OBJ CUT algorithm computes a segmentation of the object, that is, it infers a set of labels <em>m</em>.</p>

<p>Let m be a set of binary labels, and let 

<math display="inline" id="Segmentation-based_object_categorization:48">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

 be a shape parameter(

<math display="inline" id="Segmentation-based_object_categorization:49">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

 is a shape prior on the labels from a <a href="layered_pictorial_structure" title="wikilink">layered pictorial structure</a> (LPS) model). An energy function 

<math display="inline" id="Segmentation-based_object_categorization:50">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <interval closure="open">
     <ci>m</ci>
     <ci>normal-Θ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(m,\Theta)
  </annotation>
 </semantics>
</math>

 is defined as follows.</p>

<p>

<math display="block" id="Segmentation-based_object_categorization:51">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
   <msub>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mi>x</mi>
     <mi>y</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <sum></sum>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <sum></sum>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ψ</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(m,\Theta)=\sum\phi_{x}(D|m_{x})+\phi_{x}(m_{x}|\Theta)+\sum\Psi_{xy}(m_{x},m%
_{y})+\phi(D|m_{x},m_{y})
  </annotation>
 </semantics>
</math>

 (1)</p>

<p>The term 

<math display="inline" id="Segmentation-based_object_categorization:52">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{x}(D|m_{x})+\phi_{x}(m_{x}|\Theta)
  </annotation>
 </semantics>
</math>

 is called a unary term, and the term 

<math display="inline" id="Segmentation-based_object_categorization:53">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mi>x</mi>
     <mi>y</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ψ</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{xy}(m_{x},m_{y})+\phi(D|m_{x},m_{y})
  </annotation>
 </semantics>
</math>

 is called a pairwise term. A unary term consists of the likelihood 

<math display="inline" id="Segmentation-based_object_categorization:54">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{x}(D|m_{x})
  </annotation>
 </semantics>
</math>

 based on color, and the unary potential 

<math display="inline" id="Segmentation-based_object_categorization:55">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{x}(m_{x}|\Theta)
  </annotation>
 </semantics>
</math>

 based on the distance from 

<math display="inline" id="Segmentation-based_object_categorization:56">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

. A pairwise term consists of a prior 

<math display="inline" id="Segmentation-based_object_categorization:57">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mi>x</mi>
     <mi>y</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ψ</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>y</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{xy}(m_{x},m_{y})
  </annotation>
 </semantics>
</math>

 and a contrast term 

<math display="inline" id="Segmentation-based_object_categorization:58">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>m</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(D|m_{x},m_{y})
  </annotation>
 </semantics>
</math>

.</p>

<p>The best labeling 

<math display="inline" id="Segmentation-based_object_categorization:59">
 <semantics>
  <msup>
   <mi>m</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{*}
  </annotation>
 </semantics>
</math>

 minimizes 

<math display="inline" id="Segmentation-based_object_categorization:60">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <msub>
      <mi mathvariant="normal">Θ</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <ci>E</ci>
     <interval closure="open">
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Θ</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum\limits_{i}w_{i}E(m,\Theta_{i})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Segmentation-based_object_categorization:61">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

 is the weight of the parameter 

<math display="inline" id="Segmentation-based_object_categorization:62">
 <semantics>
  <msub>
   <mi mathvariant="normal">Θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Segmentation-based_object_categorization:63">
 <semantics>
  <mrow>
   <msup>
    <mi>m</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>arg</mi>
     <munder>
      <mi>min</mi>
      <mi>m</mi>
     </munder>
    </mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>i</mi>
      </msub>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo>,</mo>
       <msub>
        <mi mathvariant="normal">Θ</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <arg></arg>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <ci>E</ci>
       <interval closure="open">
        <ci>m</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Θ</ci>
         <ci>i</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{*}=\arg\min\limits_{m}\sum\limits_{i}w_{i}E(m,\Theta_{i})
  </annotation>
 </semantics>
</math>

 (2)</p>
<h3 id="algorithm">Algorithm</h3>
<ol>
<li>Given an image D, an object category is chosen, e.g. cows or horses.</li>
<li>The corresponding LPS model is matched to D to obtain the samples 

<math display="inline" id="Segmentation-based_object_categorization:64">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Θ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi mathvariant="normal">Θ</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Θ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Θ</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta_{1},\cdots,\Theta_{s}
  </annotation>
 </semantics>
</math>

</li>
<li>The objective function given by equation (2) is determined by computing 

<math display="inline" id="Segmentation-based_object_categorization:65">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <msub>
     <mi mathvariant="normal">Θ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <interval closure="open">
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Θ</ci>
      <ci>i</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(m,\Theta_{i})
  </annotation>
 </semantics>
</math>

 and using 

<math display="inline" id="Segmentation-based_object_categorization:66">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi mathvariant="normal">Θ</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Θ</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}=g(\Theta_{i}|Z)
  </annotation>
 </semantics>
</math>

</li>
<li>The objective function is minimized using a single <a href="Max-flow_min-cut_theorem" title="wikilink">MINCUT</a> operation to obtain the segmentation <strong>m</strong>.</li>
</ol>
<h2 id="other-approaches">Other approaches</h2>
<ul>
<li>Jigsaw approach<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li>Image parsing <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
<li>Interleaved segmentation <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>LOCUS <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>LayoutCRF <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li><a href="Minimum_spanning_tree-based_segmentation" title="wikilink">Minimum spanning tree-based segmentation</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Object_recognition_and_categorization" title="wikilink">Category:Object recognition and categorization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Jianbo Shi and <a href="Jitendra_Malik" title="wikilink">Jitendra Malik</a> (1997): "Normalized Cuts and Image Segmentation", IEEE Conference on Computer Vision and Pattern Recognition, pp 731–737<a href="#fnref1">↩</a></li>
<li id="fn2">M. P. Kumar, P. H. S. Torr, and A. Zisserman. Obj cut. In <em>Proceedings of IEEE Conference on Computer Vision and Pattern Recognition</em>, San Diego, pages 18–25, 2005.<a href="#fnref2">↩</a></li>
<li id="fn3">E. Borenstein, S. Ullman: Class-specic, top-down segmentation. In Proceedings of the 7th European Conference on Computer Vision, Copenhagen, Denmark, pages 109–124, 2002.<a href="#fnref3">↩</a></li>
<li id="fn4">Z. Tu, X. Chen, A. L. Yuille, S. C. Zhu: Image Parsing: Unifying Segmentation, Detection, and Recognition. Toward Category-Level Object Recognition 2006: 545–576<a href="#fnref4">↩</a></li>
<li id="fn5">B. Leibe, A. Leonardis, B. Schiele: An Implicit Shape Model for Combined Object Categorization and Segmentation. Toward Category-Level Object Recognition 2006: 508–524<a href="#fnref5">↩</a></li>
<li id="fn6">J. Winn, N. Joijic. Locus: Learning object classes with unsupervised segmentation. In Proceedings of the IEEE International Conference on Computer Vision, Beijing, 2005.<a href="#fnref6">↩</a></li>
<li id="fn7">J. M. Winn, J. Shotton: The Layout Consistent Random Field for Recognizing and Segmenting Partially Occluded Objects. CVPR (1) 2006: 37–44<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
