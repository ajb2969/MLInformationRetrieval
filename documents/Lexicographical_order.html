<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1681">Lexicographical order</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lexicographical order</h1>
<hr/>

<p> In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>lexicographic</strong> or <strong>lexicographical order</strong> (also known as <strong>lexical order</strong>, <strong>dictionary order</strong>, <strong>alphabetical order</strong> or <strong>lexicographic(al) product</strong>) is a generalization of the way the <a href="alphabetical_order" title="wikilink">alphabetical order</a> of words is based on the alphabetical order of their component letters.</p>
<h2 id="definition">Definition</h2>

<p>Given two <a href="partially_ordered_set" title="wikilink">partially ordered sets</a> <em>A</em> and <em>B</em>, the lexicographical <a href="order_theory" title="wikilink">order</a> on the <a href="Cartesian_product" title="wikilink">Cartesian product</a> <em>A</em> × <em>B</em> is defined as</p>
<dl>
<dd>(<em>a</em>,<em>b</em>) ≤ (<em>a</em>′,<em>b</em>′) if and only if <em>a</em> &lt; <em>a</em>′ or (<em>a</em> = <em>a</em>′ and <em>b</em> ≤ <em>b</em>′).
</dd>
</dl>

<p>The result is a partial order. If <em>A</em> and <em>B</em> are each <a href="total_order" title="wikilink">totally ordered</a>, then the result is a total order as well. The lexicographical order of two totally ordered sets is thus a <a href="linear_extension" title="wikilink">linear extension</a> of their <a href="product_order" title="wikilink">product order</a>.</p>

<p>More generally, one can define the lexicographic order on the Cartesian product of <em>n</em> ordered sets, on the Cartesian product of a countably infinite family of ordered sets, and on the union of such sets.</p>
<h2 id="motivation-and-uses">Motivation and uses</h2>

<p>The name of the lexicographic order comes from its generalizing the order given to words in a <a class="uri" href="dictionary" title="wikilink">dictionary</a> or <a class="uri" href="encyclopedia" title="wikilink">encyclopedia</a>: a sequence of letters (that is, a <em>word</em>)</p>
<dl>
<dd><em>a</em><sub>1</sub><em>a</em><sub>2</sub> ... <em>a</em><sub><em>k</em></sub>
</dd>
</dl>

<p>appears in a dictionary before a sequence</p>
<dl>
<dd><em>b</em><sub>1</sub><em>b</em><sub>2</sub> ... <em>b</em><sub><em>k</em></sub>
</dd>
</dl>

<p>if and only if at the first <em>i</em> where <em>a<sub>i</sub></em> and <em>b<sub>i</sub></em> differ, <em>a<sub>i</sub></em> comes before <em>b<sub>i</sub></em> in the <a class="uri" href="alphabet" title="wikilink">alphabet</a>.</p>

<p>That comparison assumes both sequences are the same length. To ensure they are the same length, the shorter sequence is usually padded at the end with enough "blanks" (a special symbol that is treated as coming before any other symbol). This also allows ordering of phrases. For the purpose of dictionaries, etc., padding with blank spaces is always done. See <a href="alphabetical_order" title="wikilink">alphabetical order</a>.</p>

<p>For example, the word "Thomas" appears before "Thompson" in dictionaries because the letter 'a' comes before the letter 'p' in the alphabet. The 5th letter is the first that is different in the two words; the first 4 letters are "Thom" in both. Because it is the first difference, the 5th letter is the most significant difference (for an alphabetical ordering).</p>

<p>A lexicographical ordering may not coincide with conventional alphabetical ordering. For example, the numerical order of <a class="uri" href="Unicode" title="wikilink">Unicode</a> codepoints does not always correspond to traditional alphabetic orderings of the characters, which vary from language to language. So the lexicographic ordering induced by codepoint value sorts strings in an unambiguous canonical order, but it does not necessarily "alphabetize" them in the conventional sense.</p>

<p>An important property of the lexicographical order is that it preserves <a href="well-order" title="wikilink">well-orders</a> of <em>finite</em> products; in particular, if <em>A</em> and <em>B</em> are well-ordered sets, then the product set <em>A</em> × <em>B</em> with the lexicographical order is also well-ordered.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The lexicographical order also preserves the <a href="Noetherian_relation" title="wikilink">Noetherian property</a>; the lexicographical product of two (or any finite number of) Noetherian relations is again Noetherian.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>An important exploitation of lexicographical ordering is expressed in the <a href="ISO_8601" title="wikilink">ISO 8601</a> date formatting scheme, which expresses a date as YYYY-MM-DD. This date ordering lends itself to straightforward <a href="sorting_algorithm" title="wikilink">computerized sorting</a> of dates such that the sorting algorithm does not need to treat the numeric parts of the date string any differently from a string of non-numeric characters, and the dates will be sorted into <a href="Chronology" title="wikilink">chronological order</a>. Note, however, that for this to work, there must always be four digits for the year, two for the month, and two for the day, so for example single-digit days must be padded with a zero yielding '01', '02', ..., '09'.</p>

<p>Another generalization of lexical ordering occurs in <a href="social_choice_theory" title="wikilink">social choice theory</a> (the theory of elections). Consider an election in which there are 4 candidates A, B, C and D, each voter expresses a top-to-bottom ordering of the candidates, and the voters' orderings are as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>18%</p></th>
<th style="text-align: left;">
<p>17%</p></th>
<th style="text-align: left;">
<p>33%</p></th>
<th style="text-align: left;">
<p>32%</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>C</p></td>
<td style="text-align: left;">
<p>D</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;">
<p>B</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>C</p></td>
<td style="text-align: left;">
<p>C</p></td>
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>C</p></td>
</tr>
</tbody>
</table>

<p>The <a href="Minimax_Condorcet" title="wikilink">MinMax</a> voting method is a simple <a href="Condorcet_method" title="wikilink">Condorcet method</a> that counts the votes as in a round-robin tournament (all possible pairings of candidates) and judges each candidate according to its largest "pairwise" defeat. The winner is the candidate whose largest defeat is the smallest. In the example:</p>
<ul>
<li>The largest defeat of A is by D: <strong>65%</strong> (33%+32%) rank D over A.</li>
<li>The largest defeat of B is by D: <strong>65%</strong> (33%+32%) rank D over B.</li>
<li>The largest defeat of C is by A (or B): <strong>67%</strong> (18%+17%+32%) rank A over C (and B over C).</li>
<li>The largest defeat of D is by C: <strong>68%</strong> (18%+17%+33%) rank C over D.</li>
</ul>

<p>MinMax declares a tie between A and B since the largest defeats for both are the same size, 65%. This is like saying "Thomas" and "Thompson" should be at the same position because they have the same first letter. However, if the defeats are compared lexically, we have the MinLexMax method. With MinLexMax, because the largest defeats of A and B are the same size, their next largest defeats are then compared:</p>
<ul>
<li>A's next largest defeat is by B: <strong>49%</strong>. (17%+32%) rank B over A.</li>
<li>B's next largest defeat is by A: <strong>51%</strong> (18%+33%) rank A over B.</li>
</ul>

<p>Since B's next largest defeat is larger than A's, MinLexMax elects A, which makes more sense than the MinMax tie since a majority rank A over B.</p>

<p>Another usage in social choice theory is the <a href="Ranked_Pairs" title="wikilink">Ranked Pairs</a> voting method. Although usually defined by a procedure that constructs the order of finish, Ranked Pairs is equivalent to finding which of all possible orders of finish is best according to a minlexmax comparison of the majorities they reverse. In the example above, the Ranked Pairs order of finish is ABCD (which elects A). ABCD affirms the majorities who rank A over B, A over C, B over C and C over D, and reverses the majorities who rank D over A and D over B. The largest majority that ABCD reverses is 65%. The only other ordering that wouldn't reverse a larger majority is BACD (which also reverses 65%). ABCD is a better order of finish than BACD because the lexically relevant set of majorities—the majorities on which ABCD and BACD disagree—is {A over B} and BACD reverses the largest majority in this set.</p>
<h2 id="case-of-multiple-products">Case of multiple products</h2>

<p>Suppose</p>

<p>

<math display="block" id="Lexicographical_order:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{A_{1},A_{2},\cdots,A_{n}\}
  </annotation>
 </semantics>
</math>

 is an n-tuple of sets, with respective total orderings</p>

<p>

<math display="block" id="Lexicographical_order:1">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mo><</mo>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mo><</mo>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mo><</mo>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <lt></lt>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <lt></lt>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <lt></lt>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{<_{1},<_{2},\cdots,<_{n}\}
  </annotation>
 </semantics>
</math>

</p>

<p>The dictionary ordering</p>

<p>

<math display="block" id="Lexicographical_order:2">
 <semantics>
  <msup>
   <mo lspace="12.5pt"><</mo>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <lt></lt>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \ <^{d}
  </annotation>
 </semantics>
</math>

 of</p>

<p>

<math display="block" id="Lexicographical_order:3">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>×</mo>
   <msub>
    <mi>A</mi>
    <mn>2</mn>
   </msub>
   <mo>×</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>×</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}\times A_{2}\times\cdots\times A_{n}
  </annotation>
 </semantics>
</math>

 is then</p>

<p>

<math display="block" id="Lexicographical_order:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mo><</mo>
    <mi>d</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo rspace="7.5pt">∃</mo>
    <mi>m</mi>
    <mo>></mo>
    <mn>0</mn>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo rspace="7.5pt">∀</mo>
    <mi>i</mi>
    <mo><</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>m</mi>
    </msub>
    <msub>
     <mo><</mo>
     <mi>m</mi>
    </msub>
    <msub>
     <mi>b</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <lt></lt>
     <ci>d</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">m</csymbol>
     <gt></gt>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <lt></lt>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <lt></lt>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{1},a_{2},\dots,a_{n})<^{d}(b_{1},b_{2},\dots,b_{n})\iff(\exists\ m>0)\ (%
\forall\ i<m)(a_{i}=b_{i})\land(a_{m}<_{m}b_{m})
  </annotation>
 </semantics>
</math>

</p>

<p>That is, if one of the terms</p>

<p>

<math display="block" id="Lexicographical_order:5">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="10pt" width="+10pt">
     <mi>a</mi>
    </mpadded>
    <mi>m</mi>
   </msub>
   <msub>
    <mo><</mo>
    <mi>m</mi>
   </msub>
   <msub>
    <mi>b</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <lt></lt>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \ a_{m}<_{m}b_{m}
  </annotation>
 </semantics>
</math>

 and all the preceding terms are equal.</p>

<p>Informally,</p>

<p>

<math display="block" id="Lexicographical_order:6">
 <semantics>
  <msub>
   <mpadded lspace="10pt" width="+10pt">
    <mi>a</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \ a_{1}
  </annotation>
 </semantics>
</math>

 represents the first letter,</p>

<p>

<math display="block" id="Lexicographical_order:7">
 <semantics>
  <msub>
   <mpadded lspace="10pt" width="+10pt">
    <mi>a</mi>
   </mpadded>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \ a_{2}
  </annotation>
 </semantics>
</math>

 the second and so on when looking up a word in a dictionary, hence the name.</p>

<p>This could be more elegantly stated by recursively defining the ordering of any set</p>

<p>

<math display="block" id="Lexicographical_order:8">
 <semantics>
  <mrow>
   <mpadded lspace="10pt" width="+10pt">
    <mi>C</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>j</mi>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>A</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>×</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>×</mo>
    <msub>
     <mi>A</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \ C=A_{j}\times A_{j+1}\times\cdots\times A_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>represented by</p>

<p>

<math display="block" id="Lexicographical_order:9">
 <semantics>
  <mrow>
   <mi></mi>
   <msup>
    <mo lspace="12.5pt"><</mo>
    <mi>d</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <lt></lt>
     <ci>d</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \ <^{d}(C)
  </annotation>
 </semantics>
</math>

</p>

<p>This will satisfy</p>

<p>

<math display="block" id="Lexicographical_order:10">
 <semantics>
  <mrow>
   <mi>a</mi>
   <msup>
    <mo><</mo>
    <mi>d</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>a</mi>
    <mo>′</mo>
   </msup>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <msub>
     <mo><</mo>
     <mi>i</mi>
    </msub>
    <msup>
     <mi>a</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <lt></lt>
     <ci>d</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>normal-′</ci>
    </apply>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <lt></lt>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a<^{d}(A_{i})a^{\prime}\iff(a<_{i}a^{\prime})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lexicographical_order:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mo><</mo>
    <mi>d</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>×</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>a</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>b</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mi>a</mi>
   <msup>
    <mo><</mo>
    <mi>d</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>a</mi>
    <mo>′</mo>
   </msup>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <msup>
      <mi>a</mi>
      <mo>′</mo>
     </msup>
    </mpadded>
    <mo rspace="7.5pt">∧</mo>
    <mi>b</mi>
    <msup>
     <mo><</mo>
     <mi>d</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>b</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <lt></lt>
     <ci>d</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <times></times>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <lt></lt>
     <ci>d</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>normal-′</ci>
    </apply>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>normal-′</ci>
     </apply>
     <and></and>
     <csymbol cd="unknown">b</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <lt></lt>
      <ci>d</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)<^{d}(A_{i}\times B)(a^{\prime},b^{\prime})\iff a<^{d}(A_{i})a^{\prime}%
\lor(a=a^{\prime}\ \land\ b<^{d}(B)b^{\prime})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Lexicographical_order:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>×</mo>
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
     </msub>
     <mo>×</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>×</mo>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=A_{i+1}\times A_{i+2}\times\cdots\times A_{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>To put it more simply, compare the first terms. If they are equal, compare the second terms – and so on. The relationship between the first corresponding terms that are not equal determines the relationship between the entire elements.</p>

<p>Unlike in the finite case, an <a href="Cartesian_product#Infinite_products" title="wikilink">infinite product</a> of well-orders is not necessarily well-ordered by its lexicographical order. For instance, the set of <a href="countably_infinite" title="wikilink">countably infinite</a> binary <a href="sequence" title="wikilink">sequences</a> (by definition, the set of functions from <a href="non-negative_integers" title="wikilink">non-negative integers</a> to {0, 1}, also known as the <a href="Cantor_space" title="wikilink">Cantor space</a> {0, 1}<sup>ω</sup>) is not well-ordered; the subset of sequences that have precisely one 1 (i.e. { 100000..., 010000..., 001000..., ... }) does not have a least element under the lexicographical order induced by 0  010000... &gt; 001000... &gt; ... is an <a href="infinite_descending_chain" title="wikilink">infinite descending chain</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Similarly, the infinite lexicographic product is not <a href="Noetherian_relation" title="wikilink">Noetherian</a> either because 011111...  over the <a href="free_monoid" title="wikilink">free monoid</a> <em>A</em>* formed by the set of all <a href="finite_sequence" title="wikilink">finite sequences</a> of elements in <em>A</em>, with sequence <a class="uri" href="concatenation" title="wikilink">concatenation</a> as the monoid operation, as follows:</p>

<p>

<math display="block" id="Lexicographical_order:13">
 <semantics>
  <mrow>
   <mi>u</mi>
   <msup>
    <mo><</mo>
    <mi mathvariant="normal">d</mi>
   </msup>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <lt></lt>
     <ci>normal-d</ci>
    </apply>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u<^{\mathrm{d}}v
  </annotation>
 </semantics>
</math>

 if</p>

<p>:* 

<math display="inline" id="Lexicographical_order:14">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is a <a class="uri" href="prefix" title="wikilink">prefix</a> of 

<math display="inline" id="Lexicographical_order:15">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, or</p>

<p>:* 

<math display="inline" id="Lexicographical_order:16">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mi>a</mi>
    <msup>
     <mi>u</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=wau^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lexicographical_order:17">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mi>b</mi>
    <msup>
     <mi>v</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>v</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=wbv^{\prime}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Lexicographical_order:18">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is the longest common prefix of 

<math display="inline" id="Lexicographical_order:19">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lexicographical_order:20">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Lexicographical_order:21">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lexicographical_order:22">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 are members of <em>A</em> such that 

<math display="inline" id="Lexicographical_order:23">
 <semantics>
  <msup>
   <mi>v</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>v</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lexicographical_order:24">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <msubsup>
    <mi>x</mi>
    <mn>2</mn>
    <mn>3</mn>
   </msubsup>
   <msub>
    <mi>x</mi>
    <mn>4</mn>
   </msub>
   <msubsup>
    <mi>x</mi>
    <mn>5</mn>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">5</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}x_{2}^{3}x_{4}x_{5}^{2}
  </annotation>
 </semantics>
</math>

 are members of <em>A</em>*.</p>

<p>If d on <em>A</em>*. If <em>A</em> is a finite and totally ordered alphabet, <em>A</em>* is the set of all <a href="String_(computer_science)#Formal_theory" title="wikilink">words</a> over <em>A</em>, and we retrieve the notion of dictionary ordering used in lexicography that gave its name to the lexicographic orderings. However, in general this is not a <a class="uri" href="well-order" title="wikilink">well-order</a>, even though it is on the alphabet <em>A</em>; for instance, if <em>A</em> = {<em>a</em>, <em>b</em>}, the <a href="Formal_language" title="wikilink">language</a> {<em>a</em><sup><em>n</em></sup><em>b</em> | <em>n</em> ≥ 0} has no least element: ... d <em>aab</em> d <em>ab</em> d <em>b</em>. A well-order for strings, based on the lexicographical order, is the <a href="shortlex_order" title="wikilink">shortlex order</a>; it is however not Noetherian.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The shortlex order can actually be defined as a lexicographic product of two orders:</p>
<ul>
<li>the ordering of strings by length, and</li>
<li>the (naturally disjoint) union of orders of finite string of every size with some (usually lexicographic) order.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>

<p>Similarly it is also possible to compare a finite and an <a href="infinite_string" title="wikilink">infinite string</a>, or two infinite strings.</p>

<p>Comparing strings of different lengths can also be modeled as comparing strings of infinite length by right-padding finite strings with a special value that is less than any element of the alphabet.</p>

<p>This ordering is the ordering usually used to order <a href="String_(computer_science)" title="wikilink">character strings</a>, including in dictionaries and indexes.</p>
<h3 id="quasi-lexicographic-order">Quasi-lexicographic order</h3>

<p>The <strong><a href="Shortlex_order" title="wikilink">quasi-lexicographic order</a></strong> on the free monoid <em>A</em><sup>∗</sup> over an ordered alphabet <em>A</em> orders strings firstly by length, so that the <a href="empty_string" title="wikilink">empty string</a> comes first, and then within strings of fixed length <em>n</em>, by lexicographic order on <em>A</em><sup><em>n</em></sup>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="another-generalization">Another generalization</h3>

<p>Consider the set of functions <em>f</em> from a <a href="well-ordered_set" title="wikilink">well-ordered set</a> <em>X</em> to a <a href="totally_ordered_set" title="wikilink">totally ordered set</a> <em>Y</em>. For two such functions <em>f</em> and <em>g</em>, the order is determined by the values for the smallest <em>x</em> such that <em>f</em>(<em>x</em>) ≠ <em>g</em>(<em>x</em>).</p>

<p>If <em>Y</em> is also well-ordered and <em>X</em> is finite, then the resulting order is a well-order. As already shown above, if <em>X</em> is infinite this is in general not the case.</p>

<p>If <em>X</em> is infinite and <em>Y</em> has more than one element, then the resulting set <em>Y</em><sup><em>X</em></sup> is not a <a href="countable_set" title="wikilink">countable set</a>, see also <a href="Cardinal_number#Cardinal_exponentiation" title="wikilink">cardinal exponentiation</a>.</p>

<p>Alternatively, consider the functions <em>f</em> from an inversely well-ordered <em>X</em> to a well-ordered <em>Y</em> with minimum 0, restricted to those that are non-zero at only a finite subset of <em>X</em>. The result is well-ordered. Correspondingly we can also consider a well-ordered <em>X</em> and apply lexicographical order where a higher <em>x</em> is a more significant position. This corresponds to <a href="Ordinal_arithmetic#Exponentiation" title="wikilink">exponentiation of ordinal numbers</a> <em>Y</em><sup><em>X</em></sup>. If <em>X</em> and <em>Y</em> are countable then the resulting set is also countable.</p>
<h2 id="example-monomials">Example: Monomials</h2>

<p>In algebra it is traditional to order <a href="term_(mathematics)" title="wikilink">terms</a> in a <a class="uri" href="polynomial" title="wikilink">polynomial</a>, by ordering the <a href="monomial" title="wikilink">monomials</a> in the <a href="indeterminate_(variable)" title="wikilink">indeterminates</a>. Such matters are typically left implicit in discussion between humans, but must of course be dealt with exactly in <a href="computer_algebra" title="wikilink">computer algebra</a>, for example for testing the equality of polynomials.</p>

<p>More specifically, the definition of <a href="Gröbner_basis" title="wikilink">Gröbner bases</a> and their computation are heavily based on the choice of an ordering of the monomials. To define such an ordering, one identifies every monomial (for example 

<math display="block" id="Lexicographical_order:25">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{A_{1},A_{2},\ldots,A_{n}\}
  </annotation>
 </semantics>
</math>

) with its vector of exponents (here [1,3,0,1,2]), and one chooses an ordering on these vectors of integers. This ordering must satisfy some further conditions to be <strong>admissible</strong> for Gröbner bases; see <a href="monomial_order" title="wikilink">monomial order</a> for details and the admissibility conditions.</p>

<p>One of these admissible orders is the <strong>lexicographical order</strong>. Another one is the <strong>total degree order</strong>, which consists in comparing first the <a href="total_degree" title="wikilink">total degrees</a>, and then resolving the conflicts by using the lexicographical order. More generally, every admissible order may be defined as the lexicographical order on the values of a set of <em>n</em> <a href="linear_form" title="wikilink">linear forms</a> with <a href="real_number" title="wikilink">real</a> coefficients applied to the vector of exponents (here <em>n</em> is the number of variables).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="decimal-fractions">Decimal fractions</h2>

<p>For <a href="Decimal#Decimal_fractions" title="wikilink">decimal fractions</a> from the decimal point, <em>a</em> \scriptstyle \{1,...,5\} \, that have a complete 5-<a href="Cycles_and_fixed_points" title="wikilink">cycle</a><br/>
The <a href="Inversion_(discrete_mathematics)" title="wikilink">inversion</a> vectors of permutations in <em>colex</em> order are in <em>revcolex</em> order, and vice versa.]]</p>

<p>The <strong>colexicographic</strong> or <strong>colex order</strong> is a natural order structure of the <a href="Cartesian_product" title="wikilink">Cartesian product</a> of two or more ordered sets. Given two <a href="partially_ordered_set" title="wikilink">partially ordered sets</a> <em>A</em> and <em>B</em>, the colexicographical order on the Cartesian product <em>A</em> × <em>B</em> is defined as</p>
<dl>
<dd>(<em>a</em>,<em>b</em>) ≤ (<em>a′</em>,<em>b</em>′) if and only if <em>b</em> &lt; <em>b</em>′ or (<em>b</em> = <em>b</em>′ and <em>a</em> ≤ <em>a′</em> ).
</dd>
</dl>

<p>The result is a partial order. If <em>A</em> and <em>B</em> are <a href="total_order" title="wikilink">totally ordered</a>, then the result is a total order also.</p>

<p>More generally, one can define the colexicographic order on the Cartesian product of <em>n</em> ordered sets.</p>

<p>Suppose</p>

<p>

<math display="block" id="Lexicographical_order:26">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mo><</mo>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mo><</mo>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mo><</mo>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <lt></lt>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <lt></lt>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <lt></lt>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{<_{1},<_{2},\ldots,<_{n}\}
  </annotation>
 </semantics>
</math>

 is an <em>n</em>-tuple of sets, with respective total orderings</p>

<p>

<math display="block" id="Lexicographical_order:27">
 <semantics>
  <msup>
   <mo lspace="12.5pt"><</mo>
   <mtext>colex</mtext>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <lt></lt>
    <mtext>colex</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \ <^{\text{colex}}
  </annotation>
 </semantics>
</math>

</p>

<p>The colex ordering</p>

<p>

<math display="block" id="Lexicographical_order:28">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>×</mo>
   <msub>
    <mi>A</mi>
    <mn>2</mn>
   </msub>
   <mo>×</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>×</mo>
   <msub>
    <mi>A</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}\times A_{2}\times\cdots\times A_{n}
  </annotation>
 </semantics>
</math>

 of</p>

<p>

<math display="block" id="Lexicographical_order:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mo><</mo>
     <mtext>colex</mtext>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <lt></lt>
      <mtext>colex</mtext>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{1},a_{2},\dots,a_{n})<^{\text{colex}}(b_{1},b_{2},\dots,b_{n})\iff
  </annotation>
 </semantics>
</math>

 is then</p>

<p>

<math display="inline" id="Lexicographical_order:30">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo rspace="7.5pt">∃</mo>
    <mi>m</mi>
    <mo>></mo>
    <mn>0</mn>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo rspace="7.5pt">∀</mo>
    <mi>i</mi>
    <mo>></mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>m</mi>
    </msub>
    <msub>
     <mo><</mo>
     <mi>m</mi>
    </msub>
    <msub>
     <mi>b</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">m</csymbol>
     <gt></gt>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <gt></gt>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <lt></lt>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists\ m>0)\ (\forall\ i>m)(a_{i}=b_{i})\land(a_{m}<_{m}b_{m})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Lexicographical_order:31">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>5</mn>
   <mo>,</mo>
   <mn>6</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
    <cn type="integer">4</cn>
    <cn type="integer">5</cn>
    <cn type="integer">6</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,2,3,4,5,6\}
  </annotation>
 </semantics>
</math>

</p>

<p>The following is an ordering on the 3-element subsets of 

<math display="block" id="Lexicographical_order:32">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mi>y</mi>
    <msup>
     <mi>z</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>x</mi>
    <msup>
     <mi>y</mi>
     <mn>3</mn>
    </msup>
    <msup>
     <mi>z</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}yz^{2}<xy^{3}z^{2}
  </annotation>
 </semantics>
</math>

, based on the colex ordering of the triples obtained by writing the elements of each subset in ascending order:</p>
<dl>
<dd>123 126 &lt; 136 &lt; 236 &lt; 146 &lt; 246 &lt; 346 &lt; 156 &lt; 256 &lt; 356 &lt; 456
</dd>
</dl>

<p>Colexicographical ordering is used in the <a href="Kruskal-Katona_theorem" title="wikilink">Kruskal-Katona theorem</a>.</p>
<h2 id="reverse-lexicographic-order">Reverse lexicographic order</h2>

<p>In a common variation of lexicographic order, one compares elements by reading from the right instead of from the left, i.e., the right-most component is the most significant, e.g. applied in a <a href="rhyming_dictionary" title="wikilink">rhyming dictionary</a>.</p>

<p>In the case of monomials one may sort the exponents downward, with the exponent of the first base variable as primary sort key, e.g.:</p>

<p><span class="LaTeX">$$x^2 y z^2 &lt; x y^3 z^2$$</span>. Alternatively, sorting may be done by the sum of the exponents, downward.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Collation" title="wikilink">Collation</a></li>
<li><a href="Colexicographical_order" title="wikilink">Colexicographical order</a></li>
<li><a href="Kleene–Brouwer_order" title="wikilink">Kleene–Brouwer order</a></li>
<li><a href="Lexicographic_preferences" title="wikilink">Lexicographic preferences</a></li>
<li><a href="Total_order#Orders_on_the_Cartesian_product_of_totally_ordered_sets" title="wikilink">Orders on the Cartesian product of totally ordered sets</a></li>
<li><a href="Ordered_vector_space#Examples" title="wikilink">Lexicographic order on the <strong>R</strong><sup><em>n</em></sup></a></li>
<li><a href="Lexicographic_order_topology_on_the_unit_square" title="wikilink">Lexicographic order topology on the unit square</a></li>
<li><a href="Long_line_(topology)" title="wikilink">Long line (topology)</a></li>
<li><a href="Lyndon_word" title="wikilink">Lyndon word</a></li>
<li><a href="Lexicographically_minimal_string_rotation" title="wikilink">Lexicographically minimal string rotation</a></li>
<li> <a href="v:Lexicographic_and_colexicographic_order" title="wikilink">Lexicographic and colexicographic order</a></li>
<li><a href="Star_product" title="wikilink">Star product</a>, a different way of combining partial orders</li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Order_theory" title="wikilink">Category:Order theory</a> <a class="uri" href="Category:Lexicography" title="wikilink">Category:Lexicography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
