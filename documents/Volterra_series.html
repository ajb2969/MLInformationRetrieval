<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="593">Volterra series</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Volterra series</h1>
<hr/>

<p>The <strong>Volterra series</strong> is a model for non-linear behavior similar to the <a href="Taylor_series" title="wikilink">Taylor series</a>. It differs from the Taylor series in its ability to capture 'memory' effects. The Taylor series can be used for approximating the response of a nonlinear system to a given input if the output of this system depends strictly on the input at that particular time. In the Volterra series the output of the nonlinear system depends on the input to the system at <em>all</em> other times. This provides the ability to capture the 'memory' effect of devices like capacitors and inductors.</p>

<p>It has been applied in the fields of medicine (biomedical engineering) and biology, especially neuroscience. It is also used in electrical engineering to model <a class="uri" href="intermodulation" title="wikilink">intermodulation</a> distortion in many devices including power amplifiers and <a href="frequency_mixer" title="wikilink">frequency mixers</a>. Its main advantage lies in its generality: it can represent a wide range of systems. Thus it is sometimes considered a <a class="uri" href="non-parametric" title="wikilink">non-parametric</a> model.</p>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a Volterra series denotes a functional expansion of a dynamic, <a class="uri" href="nonlinear" title="wikilink">nonlinear</a>, time-invariant <a href="Functional_(mathematics)" title="wikilink">functional</a>. Volterra series are frequently used in <a href="system_identification" title="wikilink">system identification</a>. The Volterra series, which is used to prove the Volterra theorem, is an infinite sum of multidimensional convolutional integrals.</p>
<h2 id="history">History</h2>

<p>The Volterra series is a modernized version of the theory of analytic functionals due to the Italian mathematician <a href="Vito_Volterra" title="wikilink">Vito Volterra</a> in work dating from 1887.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a href="Norbert_Wiener" title="wikilink">Norbert Wiener</a> became interested in this theory in the 1920s from contact with Volterra's student <a href="Paul_Lévy_(mathematician)" title="wikilink">Paul Lévy</a>. He applied his theory of <a href="Brownian_motion" title="wikilink">Brownian motion</a> to the integration of Volterra analytic functionals. The use of Volterra series for system analysis originated from a restricted 1942 wartime report<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> of Wiener, then professor of mathematics at <a href="Massachusetts_Institute_of_Technology" title="wikilink">MIT</a>. It used the series to make an approximate analysis of the effect of radar noise in a nonlinear receiver circuit. The report became public after the war.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> As a general method of analysis of nonlinear systems, Volterra series came into use after about 1957 as the result of a series of reports, at first privately circulated, from MIT and elsewhere.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The name <em>Volterra series</em> came into use a few years later.</p>
<h2 id="mathematical-theory">Mathematical theory</h2>

<p>The theory of Volterra series can be viewed from two different perspectives: either one considers an operator mapping between two real (or complex) function spaces or a functional mapping from a real (or complex) function space into the real (or complex) numbers. The latter, functional perspective is in more frequent use, due to the assumed time-invariance of the system.</p>
<h3 id="continuous-time">Continuous time</h3>

<p>A continuous time-invariant system with <em>x</em>(<em>t</em>) as input and <em>y</em>(<em>t</em>) as output can be expanded in Volterra series as:</p>

<p>

<math display="inline" id="Volterra_series:0">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>h</mi>
    <mn>0</mn>
   </msub>
   <mo>+</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </msubsup>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi>a</mi>
    <mi>b</mi>
   </msubsup>
   <mi mathvariant="normal">⋯</mi>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi>a</mi>
    <mi>b</mi>
   </msubsup>
   <msub>
    <mi>h</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo rspace="4.2pt">.</mo>
    <mo rspace="4.2pt">.</mo>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>-</mo>
    <msub>
     <mi>τ</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <msub>
    <mi>τ</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">0</cn>
    </apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>n</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <ci>n</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>j</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=h_{0}+\sum_{n=1}^{N}{\int_{a}^{b}\cdots\int_{a}^{b}{h_{n}(\tau_{1},.\,.\,%
,\tau_{n})\prod^{n}_{j=1}{x(t-\tau_{j})d\tau_{j}}}}
  </annotation>
 </semantics>
</math>

</p>

<p>Here the constant term 

<math display="inline" id="Volterra_series:1">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{0}
  </annotation>
 </semantics>
</math>

 on the right hand side is usually taken to be zero by suitable choice of output level 

<math display="inline" id="Volterra_series:2">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. The function 

<math display="inline" id="Volterra_series:3">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo rspace="4.2pt">.</mo>
    <mo rspace="4.2pt">.</mo>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>n</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{n}(\tau_{1},.\,.\,,\tau_{n})
  </annotation>
 </semantics>
</math>

 is called the <em>n</em>-th order <strong>Volterra <a href="Integral_kernel" title="wikilink">kernel</a></strong>. It can be regarded as a higher-order impulse response of the system. The integrals are usually taken over an infinite range. Since normally the output depends only on past values of the input, the integrals may in this case equivalently be taken over a half-infinite range.</p>

<p>If <em>N</em> is finite, the series is said to be <em>truncated</em>. If <em>a,b</em>, and <em>N</em> are finite, the series is called <em>doubly-finite</em>.</p>

<p>Sometimes the <em>n</em>-th order term is divided by n!, a convention which is convenient when taking the output of one Volterra system as the input of another ('cascading').</p>

<p><em>The causality condition</em>: Since in any physically realizable system the output can only depend on previous values of the input, the kernels 

<math display="inline" id="Volterra_series:4">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>n</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{n}(t_{1},t_{2},\ldots,t_{n})
  </annotation>
 </semantics>
</math>

 will be zero if any of the variables 

<math display="inline" id="Volterra_series:5">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>t</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{1},t_{2},\ldots,t_{n}
  </annotation>
 </semantics>
</math>

 are negative. The integrals may then be written over the half range from zero to infinity. So if the operator is causal, 

<math display="inline" id="Volterra_series:6">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\geq 0
  </annotation>
 </semantics>
</math>

.</p>

<p><em>Fréchet's approximation theorem</em>: The use of the Volterra series to represent a time-invariant functional relation is often justified by appealing to a theorem due to <a href="Maurice_René_Fréchet" title="wikilink">Fréchet</a>. This theorem states that a time-invariant functional relation (satisfying certain very general conditions) can be approximated uniformly and to an arbitrary degree of precision by a sufficiently high finite order Volterra series. Among other conditions, the set of admissible input functions 

<math display="inline" id="Volterra_series:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)
  </annotation>
 </semantics>
</math>

 for which the approximation will hold is required to be <a href="compact_space" title="wikilink">compact</a>. It is usually taken to be an <a class="uri" href="equicontinuous" title="wikilink">equicontinuous</a>, <a href="uniformly_bounded" title="wikilink">uniformly bounded</a> set of functions, which is compact by the <a href="Arzelà–Ascoli_theorem" title="wikilink">Arzelà–Ascoli theorem</a>. In many physical situations, this assumption about the input set is a reasonable one. The theorem, however, gives no indication as to how many terms are needed for a good approximation, which is an essential question in applications.</p>
<h3 id="discrete-time">Discrete time</h3>

<p>This is similar to the continuous-time case:</p>

<p>

<math display="inline" id="Volterra_series:8">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>h</mi>
    <mn>0</mn>
   </msub>
   <mo>+</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>p</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>P</mi>
   </msubsup>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>τ</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <mi>a</mi>
    </mrow>
    <mi>b</mi>
   </msubsup>
   <mi mathvariant="normal">⋯</mi>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>τ</mi>
      <mi>p</mi>
     </msub>
     <mo>=</mo>
     <mi>a</mi>
    </mrow>
    <mi>b</mi>
   </msubsup>
   <msub>
    <mi>h</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo rspace="4.2pt">.</mo>
    <mo rspace="4.2pt">.</mo>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>p</mi>
   </msubsup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>-</mo>
    <msub>
     <mi>τ</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">0</cn>
    </apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>a</ci>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <ci>p</ci>
       </apply>
       <ci>a</ci>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>p</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <ci>p</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)=h_{0}+\sum_{p=1}^{P}{\sum_{\tau_{1}=a}^{b}\cdots\sum_{\tau_{p}=a}^{b}{h_{%
p}(\tau_{1},.\,.\,,\tau_{p})\prod^{p}_{j=1}{x(n-\tau_{j})}}},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:9">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo rspace="4.2pt">.</mo>
    <mo rspace="4.2pt">.</mo>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>p</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{p}(\tau_{1},.\,.\,,\tau_{p})
  </annotation>
 </semantics>
</math>

 are called discrete-time Volterra kernels.</p>

<p>If <em>P</em> is finite, the series operator is said to be truncated. If <em>a,b</em> and <em>P</em> are finite the series operator is called doubly-finite Volterra series. If 

<math display="inline" id="Volterra_series:10">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\geq 0
  </annotation>
 </semantics>
</math>

 the operator is said to be <strong>causal</strong>.</p>

<p>We can always consider, without loss of the generality, the kernel 

<math display="inline" id="Volterra_series:11">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo rspace="4.2pt">.</mo>
    <mo rspace="4.2pt">.</mo>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>p</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{p}(\tau_{1},.\,.\,,\tau_{p})
  </annotation>
 </semantics>
</math>

 as symmetrical. In fact, for the commutativity of the multiplication it is always possible to symmetrize it by forming a new kernel taken as the average of the kernels for all permutations of the variables 

<math display="inline" id="Volterra_series:12">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mo rspace="4.2pt">.</mo>
   <mo rspace="4.2pt">.</mo>
   <mo>,</mo>
   <msub>
    <mi>τ</mi>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-.</ci>
    <ci>normal-.</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>p</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{1},.\,.\,,\tau_{p}
  </annotation>
 </semantics>
</math>

.</p>

<p>For a causal system with symmetrical kernels we can rewrite the nth term approximately in triangular form 

<math display="inline" id="Volterra_series:13">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>τ</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi>M</mi>
   </msubsup>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>τ</mi>
      <mn>2</mn>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>τ</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mi>M</mi>
   </msubsup>
   <mi mathvariant="normal">⋯</mi>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>τ</mi>
      <mi>p</mi>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>τ</mi>
      <mrow>
       <mi>p</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mi>M</mi>
   </msubsup>
   <msub>
    <mi>h</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo rspace="4.2pt">.</mo>
    <mo rspace="4.2pt">.</mo>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>p</mi>
   </msubsup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>-</mo>
    <msub>
     <mi>τ</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>M</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <apply>
         <minus></minus>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>p</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <ci>p</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{\tau_{1}=0}^{M}\sum_{\tau_{2}=\tau_{1}}^{M}\cdots\sum_{\tau_{p}=\tau_{p-%
1}}^{M}{h_{p}(\tau_{1},.\,.\,,\tau_{p})\prod^{p}_{j=1}{x(n-\tau_{j})}}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="methods-to-estimate-the-kernel-coefficients">Methods to estimate the kernel coefficients</h2>

<p>Estimating the Volterra coefficients individually is complicated since the basis functionals of the Volterra series are correlated. This leads to the problem of simultaneously solving a set of integral-equations for the coefficients. Hence, estimation of Volterra coefficients is generally performed by estimating the coefficients of an orthogonalized series, e.g. the <a href="Wiener_series" title="wikilink">Wiener series</a>, and then recomputing the coefficients of the original Volterra series. The Volterra series main appeal over the orthogonalized series lies in its intuitive, canonical structure, i.e. all interactions of the input have one fixed degree. The orthogonalized basis functionals will generally be quite complicated.</p>

<p>An important aspect, with respect to which the following methods differ is whether the orthogonalization of the basis functionals is to be performed over the idealized specification of the input signal (e.g. gaussian, white noise) or over the actual realization of the input (i.e. the pseudo-random, bounded, almost-white version of gaussian white noise, or any other stimulus). The latter methods, despite their lack of mathematical elegance, have been shown to be more flexible (as arbitrary inputs can be easily accommodated) and precise (due to the effect that the idealized version of the input signal is not always realizable).</p>
<h3 id="crosscorrelation-method">Crosscorrelation method</h3>

<p>This method, developed by Lee &amp; Schetzen, orthogonalizes with respect to the actual mathematical description of the signal, i.e. the projection onto the new basis functionals is based on the knowledge of the moments of the random signal.</p>

<p>To allow identification orthogonalization, Volterra series must be rearranged in terms of orthogonal non-homogeneous <em>G</em> operators (<a href="Wiener_series" title="wikilink">Wiener series</a>):</p>

<p>

<math display="inline" id="Volterra_series:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>p</mi>
    </msub>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>p</mi>
     </msub>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>p</mi>
    </msub>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>p</mi>
     </msub>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>p</ci>
       </apply>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <ci>p</ci>
       </apply>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)=\sum_{p}{H_{p}x(n)}\equiv\sum_{p}{G_{p}x(n)}
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>G</em> operators can be defined by the following</p>

<p>

<math display="inline" id="Volterra_series:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <msub>
        <mi>H</mi>
        <mi>i</mi>
       </msub>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>G</mi>
        <mi>j</mi>
       </msub>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="22.5pt">;</mo>
   <mrow>
    <mi>i</mi>
    <mo><</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <set>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>G</ci>
         <ci>j</ci>
        </apply>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </set>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <lt></lt>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\{H_{i}x(n)G_{j}x(n)\}=0;\qquad i<j
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <msub>
        <mi>G</mi>
        <mi>i</mi>
       </msub>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>G</mi>
        <mi>j</mi>
       </msub>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="22.5pt">;</mo>
   <mrow>
    <mi>i</mi>
    <mo>≠</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <set>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>G</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>G</ci>
         <ci>j</ci>
        </apply>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </set>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <neq></neq>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\{G_{i}x(n)G_{j}x(n)\}=0;\qquad i\neq j
  </annotation>
 </semantics>
</math>

</p>

<p>whenever 

<math display="inline" id="Volterra_series:17">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>i</mi>
   </msub>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}x(n)
  </annotation>
 </semantics>
</math>

 is arbitrary omogeneous Volterra, <em>x(n)</em> is a Stationary white noise with zero mean and variance <em>A</em>.</p>

<p>Recalling that every Volterra functional is orthogonal to all Wiener functional of greater order, and considering the following Volterra functional</p>

<p>

<math display="inline" id="Volterra_series:18">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>H</mi>
     <mover accent="true">
      <mi>p</mi>
      <mo>¯</mo>
     </mover>
     <mo>*</mo>
    </msubsup>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mover accent="true">
      <mi>p</mi>
      <mo>¯</mo>
     </mover>
    </msubsup>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <msub>
        <mi>τ</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <times></times>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{*}_{\overline{p}}x(n)=\prod^{\overline{p}}_{j=1}{x(n-\tau_{j})}
  </annotation>
 </semantics>
</math>

</p>

<p>we can write</p>

<p>

<math display="inline" id="Volterra_series:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msubsup>
       <mi>H</mi>
       <mover accent="true">
        <mi>p</mi>
        <mo>¯</mo>
       </mover>
       <mo>*</mo>
      </msubsup>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>p</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>G</mi>
        <mi>p</mi>
       </msub>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msubsup>
        <mi>H</mi>
        <mover accent="true">
         <mi>p</mi>
         <mo>¯</mo>
        </mover>
        <mo>*</mo>
       </msubsup>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <set>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>H</ci>
         <times></times>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <ci>p</ci>
        </apply>
       </apply>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <set>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>p</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>G</ci>
         <ci>p</ci>
        </apply>
        <ci>x</ci>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>H</ci>
          <times></times>
         </apply>
         <apply>
          <ci>normal-¯</ci>
          <ci>p</ci>
         </apply>
        </apply>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left\{y(n)H^{*}_{\overline{p}}x(n)\right\}=E\left\{\sum_{p=0}^{\infty}{G_{p}%
x(n)H^{*}_{\overline{p}}x(n)}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>x</em> is SWN, 

<math display="inline" id="Volterra_series:20">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mn>1</mn>
   </msub>
   <mo>≠</mo>
   <msub>
    <mi>τ</mi>
    <mn>2</mn>
   </msub>
   <mo>≠</mo>
   <mi mathvariant="normal">…</mi>
   <mo>≠</mo>
   <msub>
    <mi>τ</mi>
    <mi>P</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <neq></neq>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <neq></neq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{1}\neq\tau_{2}\neq\ldots\neq\tau_{P}
  </annotation>
 </semantics>
</math>

 and by letting 

<math display="inline" id="Volterra_series:21">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <msubsup>
    <mi>σ</mi>
    <mi>x</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\sigma^{2}_{x}
  </annotation>
 </semantics>
</math>

, we have:</p>

<p>

<math display="inline" id="Volterra_series:22">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>{</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mover accent="true">
      <mi>p</mi>
      <mo>¯</mo>
     </mover>
    </msubsup>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>-</mo>
     <msub>
      <mi>τ</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>G</mi>
     <mover accent="true">
      <mi>p</mi>
      <mo>¯</mo>
     </mover>
    </msub>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mover accent="true">
      <mi>p</mi>
      <mo>¯</mo>
     </mover>
    </msubsup>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>-</mo>
     <msub>
      <mi>τ</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mo>=</mo>
   <mover accent="true">
    <mi>p</mi>
    <mo>¯</mo>
   </mover>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <msup>
    <mi>A</mi>
    <mover accent="true">
     <mi>p</mi>
     <mo>¯</mo>
    </mover>
   </msup>
   <msub>
    <mi>k</mi>
    <mover accent="true">
     <mi>p</mi>
     <mo>¯</mo>
    </mover>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo rspace="4.2pt">.</mo>
    <mo rspace="4.2pt">.</mo>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mover accent="true">
      <mi>p</mi>
      <mo>¯</mo>
     </mover>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <ci>j</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>p</ci>
    </apply>
    <factorial></factorial>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left\{y(n)\prod^{\overline{p}}_{j=1}{x(n-\tau_{j})}\right\}=E\left\{G_{%
\overline{p}}x(n)\prod^{\overline{p}}_{j=1}{x(n-\tau_{j})}\right\}=\overline{p%
}!A^{\overline{p}}k_{\overline{p}}(\tau_{1},.\,.\,,\tau_{\overline{p}})
  </annotation>
 </semantics>
</math>

</p>

<p>So if we exclude the diagonal elements, 

<math display="inline" id="Volterra_series:23">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mi>i</mi>
   </msub>
   <mo>≠</mo>
   <mrow>
    <msub>
     <mi>τ</mi>
     <mi>j</mi>
    </msub>
    <mo rspace="4.2pt">,</mo>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>i</ci>
    </apply>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <ci>j</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\tau_{i}\neq\tau_{j},\,\forall i,j}
  </annotation>
 </semantics>
</math>

, it is</p>

<p>

<math display="inline" id="Volterra_series:24">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo rspace="4.2pt">.</mo>
    <mo rspace="4.2pt">.</mo>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">⋯</mi>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <msub>
          <mi>τ</mi>
          <mi>p</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>p</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <msup>
      <mi>A</mi>
      <mi>p</mi>
     </msup>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>p</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>p</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>E</ci>
      <set>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>n</ci>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-⋯</ci>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <ci>p</ci>
         </apply>
        </apply>
       </apply>
      </set>
     </apply>
     <apply>
      <times></times>
      <apply>
       <factorial></factorial>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{p}(\tau_{1},.\,.\,,\tau_{p})=\frac{E\left\{{y(n)x(n-\tau_{1})\cdots x(n-%
\tau_{p})}\right\}}{{p!A^{p}}}.
  </annotation>
 </semantics>
</math>

</p>

<p>If we want to consider the diagonal points, the solution proposed by Lee and Schetzen is:</p>

<p>

<math display="inline" id="Volterra_series:25">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>p</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mo rspace="4.2pt">.</mo>
    <mo rspace="4.2pt">.</mo>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mi>p</mi>
    </msub>
    <mo rspace="0.8pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="0.8pt">=</mo>
   <mfrac>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mi>y</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo rspace="0.8pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo rspace="0pt">-</mo>
         <mrow>
          <mpadded width="-1.7pt">
           <mstyle displaystyle="false">
            <munderover>
             <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
             <mrow>
              <mi>m</mi>
              <mo>=</mo>
              <mn>0</mn>
             </mrow>
             <mrow>
              <mi>p</mi>
              <mo>-</mo>
              <mn>1</mn>
             </mrow>
            </munderover>
           </mstyle>
          </mpadded>
          <mrow>
           <msub>
            <mi>G</mi>
            <mi>m</mi>
           </msub>
           <mi>x</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo rspace="0pt" stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
        <mo rspace="0.8pt">)</mo>
       </mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">⋯</mi>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <msub>
          <mi>τ</mi>
          <mi>p</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>p</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <msup>
      <mi>A</mi>
      <mi>p</mi>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>p</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>p</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>E</ci>
      <set>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>y</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>m</ci>
             <cn type="integer">0</cn>
            </apply>
           </apply>
           <apply>
            <minus></minus>
            <ci>p</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>G</ci>
            <ci>m</ci>
           </apply>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-⋯</ci>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <ci>p</ci>
         </apply>
        </apply>
       </apply>
      </set>
     </apply>
     <apply>
      <times></times>
      <apply>
       <factorial></factorial>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{p}(\tau_{1},.\,.\,,\tau_{p})\!=\!\frac{E\left\{{\left({y(n)\!-\!\!\!\sum%
\limits_{m=0}^{p-1}{\!G_{m}x(n)}}\!\!\right)\!x(n-\tau_{1})\cdots x(n-\tau_{p}%
)}\right\}}{p!A^{p}}
  </annotation>
 </semantics>
</math>

</p>

<p>Efficient formulas and references for diagonal kernel point estimation can be found in <ref></ref></p>

<p><code>M. Pirani, S. Orcioni, and C. Turchetti,</code><br/>
<code>``Diagonal kernel point estimation of n-th order discrete Volterra-Wiener systems,''EURASIP Journal on Applied Signal Processing, vol. 2004, no. 12, pp. 1807--1816, Sept. 2004.</code></p>

<p> and .<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="advances-in-crosscorrelation-method">Advances in Crosscorrelation method</h3>

<p>In the traditional orthogonal algorithm, using inputs with high 

<math display="inline" id="Volterra_series:26">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{x}
  </annotation>
 </semantics>
</math>

 has the advantage of stimulating high order nonlinearity, so as to achieve more accurate high order kernel identification. As a drawback, the use of high 

<math display="inline" id="Volterra_series:27">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{x}
  </annotation>
 </semantics>
</math>

 values causes high identification error in lower order kernels, as shown in ,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> mainly due to nonideality of the input and truncation errors.</p>

<p>On the contrary the use of lower 

<math display="inline" id="Volterra_series:28">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{x}
  </annotation>
 </semantics>
</math>

 in the identification process can lead to a better estimation of lower order kernel, but can be insufficient to stimulate high order nonlinearity.</p>

<p>This phenomenon, that can be called <em>locality</em> of truncated Volterra series, can be revealed by calculating the output error of a series as a function of different variances of input. This test can be repeated with series identified with different input variances, obtaining different curves, each with a minimun in correspondence of the variance used in the identification.</p>

<p>To overcome this limitation, a low 

<math display="inline" id="Volterra_series:29">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{x}
  </annotation>
 </semantics>
</math>

 value should be used for the lower order kernel and gradually increased for higher order kernels. This is not a theoretical problem in Wiener kernel identification, since the Wiener functional are orthogonal to each other, but an appropriate normalization is needed in Wiener to Volterra conversion formulas for taking into account the use of different variances. Furthermore new Wiener to Volterra conversion formulas are needed.</p>

<p>The traditional Wiener kernel identification should be changed as follows:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> 

<math display="inline" id="Volterra_series:30">
 <semantics>
  <mrow>
   <msubsup>
    <mi>k</mi>
    <mn>0</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msup>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{0}^{(0)}=E\{y^{(0)}(n)\}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:31">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>k</mi>
     <mn>1</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>τ</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
    </mfrac>
    <mi>E</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <msup>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <msub>
         <mi>τ</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>E</ci>
     <set>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{1}^{(1)}(\tau_{1})=\frac{1}{A_{1}}E\left\{y^{(1)}(n)\,x^{(1)}(n-\tau_{1})\right\}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:32">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>k</mi>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>τ</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>τ</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
       <msubsup>
        <mi>A</mi>
        <mn>2</mn>
        <mn>2</mn>
       </msubsup>
      </mrow>
     </mfrac>
    </mpadded>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo>{</mo>
        <mrow>
         <msup>
          <mi>y</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>2</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo rspace="4.2pt" stretchy="false">)</mo>
         </mrow>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">∏</mo>
           <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mn>2</mn>
          </msubsup>
          <mrow>
           <msup>
            <mi>x</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mn>2</mn>
             <mo stretchy="false">)</mo>
            </mrow>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>n</mi>
             <mo>-</mo>
             <msub>
              <mi>τ</mi>
              <mi>i</mi>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
        <mo>}</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>A</mi>
        <mn>2</mn>
       </msub>
       <msubsup>
        <mi>k</mi>
        <mn>0</mn>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
       <msub>
        <mi>δ</mi>
        <mrow>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
         <msub>
          <mi>τ</mi>
          <mn>2</mn>
         </msub>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <factorial></factorial>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <set>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>E</ci>
        <set>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>y</ci>
           <cn type="integer">2</cn>
          </apply>
          <ci>n</ci>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <csymbol cd="latexml">product</csymbol>
             <apply>
              <eq></eq>
              <ci>i</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>x</ci>
             <cn type="integer">2</cn>
            </apply>
            <apply>
             <minus></minus>
             <ci>n</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>τ</ci>
              <ci>i</ci>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </set>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>δ</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{2}^{(2)}(\tau_{1},\tau_{2})=\frac{1}{2!A_{2}^{2}}\,\left\{E\left\{y^{(2)}(n%
)\,\prod_{i=1}^{2}{x^{(2)}(n-\tau_{i})}\right\}-A_{2}k_{0}^{(2)}\delta_{\tau_{%
1}\tau_{2}}\right\}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:33">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>k</mi>
     <mn>3</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>3</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>τ</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>τ</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>τ</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mrow>
       <mn>3</mn>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <msubsup>
       <mi>A</mi>
       <mn>3</mn>
       <mn>3</mn>
      </msubsup>
     </mrow>
    </mfrac>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo>{</mo>
        <mrow>
         <msup>
          <mi>y</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>3</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo rspace="4.2pt" stretchy="false">)</mo>
         </mrow>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">∏</mo>
           <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mn>3</mn>
          </msubsup>
          <mrow>
           <msup>
            <mi>x</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mn>3</mn>
             <mo stretchy="false">)</mo>
            </mrow>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>n</mi>
             <mo>-</mo>
             <msub>
              <mi>τ</mi>
              <mi>i</mi>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
        <mo>}</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msubsup>
        <mi>A</mi>
        <mn>3</mn>
        <mn>2</mn>
       </msubsup>
       <mrow>
        <mo>[</mo>
        <mrow>
         <mrow>
          <msubsup>
           <mi>k</mi>
           <mn>1</mn>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>3</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>τ</mi>
            <mn>1</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <msub>
           <mi>δ</mi>
           <mrow>
            <msub>
             <mi>τ</mi>
             <mn>2</mn>
            </msub>
            <msub>
             <mi>τ</mi>
             <mn>3</mn>
            </msub>
           </mrow>
          </msub>
         </mrow>
         <mo>+</mo>
         <mrow>
          <msubsup>
           <mi>k</mi>
           <mn>1</mn>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>3</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>τ</mi>
            <mn>2</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <msub>
           <mi>δ</mi>
           <mrow>
            <msub>
             <mi>τ</mi>
             <mn>1</mn>
            </msub>
            <msub>
             <mi>τ</mi>
             <mn>3</mn>
            </msub>
           </mrow>
          </msub>
         </mrow>
         <mo>+</mo>
         <mrow>
          <msubsup>
           <mi>k</mi>
           <mn>1</mn>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>3</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>τ</mi>
            <mn>3</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <msub>
           <mi>δ</mi>
           <mrow>
            <msub>
             <mi>τ</mi>
             <mn>1</mn>
            </msub>
            <msub>
             <mi>τ</mi>
             <mn>2</mn>
            </msub>
           </mrow>
          </msub>
         </mrow>
        </mrow>
        <mo>]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">3</cn>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <factorial></factorial>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">3</cn>
        </apply>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <set>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>E</ci>
        <set>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>y</ci>
           <cn type="integer">3</cn>
          </apply>
          <ci>n</ci>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <csymbol cd="latexml">product</csymbol>
             <apply>
              <eq></eq>
              <ci>i</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <cn type="integer">3</cn>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>x</ci>
             <cn type="integer">3</cn>
            </apply>
            <apply>
             <minus></minus>
             <ci>n</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>τ</ci>
              <ci>i</ci>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </set>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">3</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>k</ci>
             <cn type="integer">1</cn>
            </apply>
            <cn type="integer">3</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>τ</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>δ</ci>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>τ</ci>
              <cn type="integer">2</cn>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>τ</ci>
              <cn type="integer">3</cn>
             </apply>
            </apply>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>k</ci>
             <cn type="integer">1</cn>
            </apply>
            <cn type="integer">3</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>τ</ci>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>δ</ci>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>τ</ci>
              <cn type="integer">1</cn>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>τ</ci>
              <cn type="integer">3</cn>
             </apply>
            </apply>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>k</ci>
             <cn type="integer">1</cn>
            </apply>
            <cn type="integer">3</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>τ</ci>
            <cn type="integer">3</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>δ</ci>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>τ</ci>
              <cn type="integer">1</cn>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>τ</ci>
              <cn type="integer">2</cn>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{3}^{(3)}(\tau_{1},\tau_{2},\tau_{3})=\frac{1}{3!A_{3}^{3}}\left\{E\left\{y^%
{(3)}(n)\,\prod_{i=1}^{3}{x^{(3)}(n-\tau_{i})}\right\}-A_{3}^{2}\left[k_{1}^{(%
3)}(\tau_{1})\delta_{\tau_{2}\tau_{3}}+k_{1}^{(3)}(\tau_{2})\delta_{\tau_{1}%
\tau_{3}}+k_{1}^{(3)}(\tau_{3})\delta_{\tau_{1}\tau_{2}}\right]\right\}
  </annotation>
 </semantics>
</math>

 In the above formulas the impulse functions are introduced for the identification of diagonal kernel points. If the Wiener kernels are extracted with the new formulas, the following Wiener to Volterra formulas (explicited up the fifth order) are needed:</p>

<p>

<math display="inline" id="Volterra_series:34">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>5</mn>
   </msub>
   <mo rspace="4.2pt">=</mo>
   <msubsup>
    <mi>k</mi>
    <mn>5</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>5</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <cn type="integer">5</cn>
     </apply>
     <cn type="integer">5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{5}=\,k_{5}^{(5)}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:35">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>4</mn>
   </msub>
   <mo rspace="4.2pt">=</mo>
   <msubsup>
    <mi>k</mi>
    <mn>4</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>4</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <cn type="integer">4</cn>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{4}=\,k_{4}^{(4)}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:36">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>3</mn>
   </msub>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <msubsup>
     <mi>k</mi>
     <mn>3</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>3</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>-</mo>
    <mrow>
     <mn>10</mn>
     <msub>
      <mi>A</mi>
      <mn>3</mn>
     </msub>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <msub>
        <mi>τ</mi>
        <mn>4</mn>
       </msub>
      </msub>
      <mrow>
       <msubsup>
        <mi>k</mi>
        <mn>5</mn>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>5</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>τ</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>τ</mi>
         <mn>2</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>τ</mi>
         <mn>3</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>τ</mi>
         <mn>4</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>τ</mi>
         <mn>4</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">10</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <cn type="integer">5</cn>
         </apply>
         <cn type="integer">5</cn>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">3</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">4</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">4</cn>
         </apply>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{3}=\,k_{3}^{(3)}-10A_{3}\sum_{\tau_{4}}{k_{5}^{(5)}(\tau_{1},\tau_{2},\tau_%
{3},\tau_{4},\tau_{4})}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:37">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>2</mn>
   </msub>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <msubsup>
     <mi>k</mi>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>-</mo>
    <mrow>
     <mn>6</mn>
     <msub>
      <mi>A</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <msub>
        <mi>τ</mi>
        <mn>3</mn>
       </msub>
      </msub>
      <mrow>
       <msubsup>
        <mi>k</mi>
        <mn>4</mn>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>4</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>τ</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>τ</mi>
         <mn>2</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>τ</mi>
         <mn>3</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>τ</mi>
         <mn>3</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">6</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <cn type="integer">4</cn>
         </apply>
         <cn type="integer">4</cn>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">3</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">3</cn>
         </apply>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}=\,k_{2}^{(2)}-6A_{2}\sum_{\tau_{3}}{k_{4}^{(4)}(\tau_{1},\tau_{2},\tau_{%
3},\tau_{3})}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:38">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>k</mi>
      <mn>1</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo>-</mo>
     <mrow>
      <mn>3</mn>
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <msub>
         <mi>τ</mi>
         <mn>2</mn>
        </msub>
       </msub>
       <mrow>
        <msubsup>
         <mi>k</mi>
         <mn>3</mn>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>3</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>2</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>15</mn>
     <msubsup>
      <mi>A</mi>
      <mn>1</mn>
      <mn>2</mn>
     </msubsup>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>τ</mi>
        <mn>2</mn>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <msub>
         <mi>τ</mi>
         <mn>3</mn>
        </msub>
       </msub>
       <mrow>
        <msubsup>
         <mi>k</mi>
         <mn>5</mn>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>5</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>3</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>3</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <cn type="integer">3</cn>
          </apply>
          <cn type="integer">3</cn>
         </apply>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">2</cn>
          </apply>
         </vector>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">15</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <times></times>
         <ci>τ</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <cn type="integer">5</cn>
          </apply>
          <cn type="integer">5</cn>
         </apply>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">3</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">3</cn>
          </apply>
         </vector>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}=\,k_{1}^{(1)}-3A_{1}\sum_{\tau_{2}}{k_{3}^{(3)}(\tau_{1},\tau_{2},\tau_{%
2})}+15A_{1}^{2}\sum_{\tau 2}{\sum_{\tau_{3}}{k_{5}^{(5)}(\tau_{1},\tau_{2},%
\tau_{2},\tau_{3},\tau_{3})}}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Volterra_series:39">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="4.2pt">=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>k</mi>
      <mn>0</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <msub>
         <mi>τ</mi>
         <mn>1</mn>
        </msub>
       </msub>
       <mrow>
        <msubsup>
         <mi>k</mi>
         <mn>2</mn>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>2</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <msubsup>
      <mi>A</mi>
      <mn>0</mn>
      <mn>2</mn>
     </msubsup>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <msub>
        <mi>τ</mi>
        <mn>1</mn>
       </msub>
      </msub>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <msub>
         <mi>τ</mi>
         <mn>2</mn>
        </msub>
       </msub>
       <mrow>
        <msubsup>
         <mi>k</mi>
         <mn>4</mn>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>4</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>τ</mi>
          <mn>2</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">0</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>τ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <cn type="integer">4</cn>
          </apply>
          <cn type="integer">4</cn>
         </apply>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">2</cn>
          </apply>
         </vector>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{0}=\,k_{0}^{(0)}-A_{0}\sum_{\tau_{1}}{k_{2}^{(2)}(\tau_{1},\tau_{1})}+3A_{0%
}^{2}\sum_{\tau_{1}}{\sum_{\tau_{2}}{k_{4}^{(4)}(\tau_{1},\tau_{1},\tau_{2},%
\tau_{2})}}
  </annotation>
 </semantics>
</math>

</p>

<p>As can be seen, the drawback with respect to the classic formula is that for the identification of the n-order kernel, all lower kernels must be identified again with the higher variance. However an outstanding improvement in the output MSE will be obtained if the Wiener and Volterra kernels are obtained with the new formulas, as can be seen in.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="exact-orthogonal-algorithm">Exact orthogonal algorithm</h3>

<p>This method and its more efficient version (Fast Orthogonal Algorithm) were invented by Korenberg .<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> In this method the orthogonalization is performed empirically over the actual input. It has been shown to perform more precisely than the Crosscorrelation method. Another advantage is that arbitrary inputs can be used for the orthogonalization and that fewer data-points suffice to reach a desired level of accuracy. Also, estimation can be performed incrementally until some criterion is fulfilled.</p>
<h3 id="linear-regression">Linear regression</h3>

<p>Linear regression is a standard tool from linear analysis. Hence, one of its main advantages is the widespread existence of standard tools for solving linear regressions efficiently. It has some educational value, since it highlights the basic property of Volterra series: linear combination of non-linear basis-functionals. For estimation the order of the original should be known, since the volterra basis-functionals are not orthogonal and estimation can thus not be performed incrementally.</p>
<h3 id="kernel-method">Kernel method</h3>

<p>This method was invented by Franz &amp; Schölkopf and is based on <a href="statistical_learning_theory" title="wikilink">statistical learning theory</a>. Consequently, this approach is also based on minimizing the empirical error (often called empirical risk minimization). Franz and Schölkopf proposed that the kernel method could essentially replace the Volterra series representation, although noting that the latter is more intuitive.</p>
<h3 id="differential-sampling">Differential sampling</h3>

<p>This method was developed by van Hemmen and coworkers and utilizes <a href="Dirac_delta_function" title="wikilink">Dirac delta functions</a> to sample the Volterra coefficients.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Wiener_series" title="wikilink">Wiener series</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Barrett J.F: <em>Bibliography of Volterra series, Hermite functional expansions, and related subjects</em>. Dept. Electr. Engrg, Univ.Tech. Eindhoven, NL 1977, T-H report 77-E-71. (Chronological listing of early papers to 1977) URL: <a class="uri" href="http://alexandria.tue.nl/extra1/erap/publichtml/7704263.pdf">http://alexandria.tue.nl/extra1/erap/publichtml/7704263.pdf</a></li>
<li>Bussgang, J.J.; Ehrman, L.; Graham, J.W: <em>Analysis of nonlinear systems with multiple inputs,</em> Proc. IEEE, vol.62, no.8, pp. 1088–1119, Aug. 1974</li>
<li><a href="Georgios_B._Giannakis" title="wikilink">Giannakis G.B</a> &amp; Serpendin E: <em>A bibliography on nonlinear system identification.</em> Signal Processing, 81 2001 533–580. (Alphabetic listing to 2001) www.elsevier.nl/locate/sigpro</li>
<li>Korenberg M.J. Hunter I.W: <em>The Identification of Nonlinear Biological Systems: Volterra Kernel Approaches</em>, Annals Biomedical Engineering (1996), Volume 24, Number 2.</li>
<li>Kuo Y L: <em>Frequency-domain analysis of weakly nonlinear networks</em>, IEEE Trans. Circuits &amp; Systems, vol.CS-11(4) Aug 1977; vol.CS-11(5) Oct 1977 2–6.</li>
<li>Rugh W J: <em>Nonlinear System Theory: The Volterra–Wiener Approach.</em> Baltimore 1981 (Johns Hopkins Univ Press) <a class="uri" href="http://rfic.eecs.berkeley.edu/~niknejad/ee242/pdf/volterra_book.pdf">http://rfic.eecs.berkeley.edu/~niknejad/ee242/pdf/volterra_book.pdf</a></li>
<li>Schetzen M: <em>The Volterra and Wiener Theories of Nonlinear Systems</em>, New York: Wiley, 1980.</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_series" title="wikilink">Category:Mathematical series</a> <a href="Category:Functional_analysis" title="wikilink">Category:Functional analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Vito Volterra. Theory of Functionals and of Integrals and Integro-Differential Equations. Madrid 1927 (Spanish), translated version reprinted New York: Dover Publications, 1959.<a href="#fnref1">↩</a></li>
<li id="fn2">Wiener N: <em>Response of a nonlinear device to noise.</em> Radiation Lab MIT 1942, restricted. report V-16, no 129 (112 pp). Declassified Jul 1946, Published as rep. no. PB-1-58087, U.S. Dept. Commerce. URL: <a class="uri" href="http://www.dtic.mil/dtic/tr/fulltext/u2/a800212.pdf">http://www.dtic.mil/dtic/tr/fulltext/u2/a800212.pdf</a><a href="#fnref2">↩</a></li>
<li id="fn3">Ikehara S: <em>A method of Wiener in a nonlinear circuit.</em> MIT Dec 10 1951, tech. rep. no 217, Res. Lab. Electron.<a href="#fnref3">↩</a></li>
<li id="fn4">Early MIT reports by Brilliant, Zames, George, Hause, Chesler can be found on dspace.mit.edu.<a href="#fnref4">↩</a></li>
<li id="fn5">S. Orcioni, M. Pirani, and C. Turchetti, ``Advances in Lee-Schetzen method for Volterra filter identification,''Multidimensional Systems and Signal Processing, vol. 16, no. 3, pp. 265--284, 2005.<a href="#fnref5">↩</a></li>
<li id="fn6">Simone Orcioni. Improving the approximation ability of Volterra series identified with a cross-correlation method, Nonlinear Dynamics, 2014, DOI: 10.1007/s11071-014-1631-7. URL <a href="http://link.springer.com/content/pdf/10.1007%2Fs11071-014-1631-7.pdf">http://link.springer.com/content/pdf/10.1007%2Fs11071-014-1631-7.pdf</a><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9">Korenberg, M.J., Bruder, S.B., McIlroy, P.J.: Exact orthogonal kernel estimation from finite data records: extending Wiener’s identification of nonlinear systems. Ann. Biomed. Eng.16, 201–214 (1988)<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
