<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="614">Lambda calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lambda calculus</h1>
<hr>'''Lambda calculus''' (also written as '''λ-calculus''') is a [[formal system]] in [[mathematical logic]] for expressing [[computability|computation]] based on function [[Abstraction (computer science)|abstraction]] and [[function application|application]] using variable [[Name binding|binding]] and [[Substitution (algebra)|substitution]]. First formulated by [[Alonzo Church]] to formalize the concept of [[Computable function|effective computability]], lambda calculus found early successes in the area of [[computability theory]], such as a negative answer to [[David Hi
<p>lbert|Hilbert]]'s <a class="uri" href="Entscheidungsproblem" title="wikilink">Entscheidungsproblem</a>. Lambda calculus is a conceptually simple <a href="Turing_completeness" title="wikilink">universal model of computation</a> (Turing showed in 1937<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> that <a href="Turing_machine" title="wikilink">Turing machines</a> equaled the lambda calculus in expressiveness). The name derives from the Greek letter lambda (λ) used to denote <a href="Free_variables_and_bound_variables" title="wikilink">binding</a> a variable in a function. The letter itself is arbitrary and has no special meaning. Lambda calculus is taught and used in computer science because of its usefulness in showcasing functional thinking and iterative reduction.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Because of the importance of the notion of variable binding and substitution, there is not just one system of lambda calculus, and in particular there are <em>typed</em> and <em>untyped</em> variants. Historically, the most important system was the untyped lambda calculus, in which function application has no restrictions (so the notion of the <a href="domain_of_a_function" title="wikilink">domain of a function</a> is not built into the system). In the <a href="Church–Turing_thesis" title="wikilink">Church–Turing Thesis</a>, the untyped lambda calculus is claimed to be capable of computing all <a href="effective_method" title="wikilink">effectively calculable</a> functions. The typed lambda calculus is a variety that restricts function application, so that functions can be applied only if they are capable of accepting the given input's "type" of data.</p>

<p>Today, the lambda calculus has applications in many different areas in <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <a class="uri" href="philosophy" title="wikilink">philosophy</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="uri" href="linguistics" title="wikilink">linguistics</a>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and computer science. It is still used in the area of computability theory, although Turing machines are also an important model for computation. Lambda calculus has played an important role in the development of the <a href="Programming_language_theory" title="wikilink">theory of programming languages</a>. Counterparts to lambda calculus in computer science are <a href="functional_programming_language" title="wikilink">functional programming languages</a>, which essentially implement the lambda calculus (augmented with some <a href="Constant_(programming)" title="wikilink">constants</a> and <a href="datatype" title="wikilink">datatypes</a>). Beyond programming languages, the lambda calculus also has many applications in <a href="proof_theory" title="wikilink">proof theory</a>. A major example of this is the <a href="Curry–Howard_correspondence" title="wikilink">Curry–Howard correspondence</a>, which gives a correspondence between different systems of typed lambda calculus and systems of <a href="formal_logic" title="wikilink">formal logic</a>.</p>
<h2 id="lambda-calculus-in-history-of-mathematics">Lambda calculus in history of mathematics</h2>

<p>The lambda calculus was introduced by mathematician <a href="Alonzo_Church" title="wikilink">Alonzo Church</a> in the 1930s as part of an investigation into the <a href="foundations_of_mathematics" title="wikilink">foundations of mathematics</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The original system was shown to be <a href="Consistency" title="wikilink">logically inconsistent</a> in 1935 when <a href="Stephen_Kleene" title="wikilink">Stephen Kleene</a> and <a href="J._B._Rosser" title="wikilink">J. B. Rosser</a> developed the <a href="Kleene–Rosser_paradox" title="wikilink">Kleene–Rosser paradox</a>.</p>

<p>Subsequently, in 1936 Church isolated and published just the portion relevant to computation, what is now called the untyped lambda calculus.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In 1940, he also introduced a computationally weaker, but logically consistent system, known as the <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="informal-description">Informal description</h2>
<h3 id="motivation">Motivation</h3>

<p><a href="Computable_function" title="wikilink">Computable functions</a> are a fundamental concept within computer science and mathematics. The λ-calculus provides a simple <a href="Semantics#Computer_science" title="wikilink">semantics</a> for computation, enabling properties of computation to be studied formally. The λ-calculus incorporates two simplifications that make this semantics simple. The first simplification is that the λ-calculus treats functions "anonymously", without giving them explicit names. For example, the function</p>

<p>

<math display="block" id="Lambda_calculus:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>sqsum</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>×</mo>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>y</mi>
     <mo>×</mo>
     <mi>y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>sqsum</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sqsum}(x,y)=x\times x+y\times y
  </annotation>
 </semantics>
</math>

 can be rewritten in <em>anonymous form</em> as</p>

<p>

<math display="block" id="Lambda_calculus:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>×</mo>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>y</mi>
     <mo>×</mo>
     <mi>y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)\mapsto x\times x+y\times y
  </annotation>
 </semantics>
</math>

 (read as "the pair of 

<math display="inline" id="Lambda_calculus:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lambda_calculus:3">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is <a href="Map_(disambiguation)#Mathematics_and_programming" title="wikilink">mapped</a> to 

<math display="inline" id="Lambda_calculus:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>×</mo>
    <mi>x</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>y</mi>
    <mo>×</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\times x+y\times y
  </annotation>
 </semantics>
</math>

"). Similarly,</p>

<p>

<math display="block" id="Lambda_calculus:5">
 <semantics>
  <mrow>
   <mrow>
    <mo>id</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>id</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{id}(x)=x
  </annotation>
 </semantics>
</math>

 can be rewritten in anonymous form as 

<math display="inline" id="Lambda_calculus:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>x</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto x
  </annotation>
 </semantics>
</math>

, where the input is simply mapped to itself.</p>

<p>The second simplification is that the λ-calculus only uses functions of a single input. An ordinary function that requires two inputs, for instance the 

<math display="inline" id="Lambda_calculus:7">
 <semantics>
  <mo>sqsum</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>sqsum</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sqsum}
  </annotation>
 </semantics>
</math>

 function, can be reworked into an equivalent function that accepts a single input, and as output returns <em>another</em> function, that in turn accepts a single input. For example,</p>

<p>

<math display="block" id="Lambda_calculus:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>×</mo>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>y</mi>
     <mo>×</mo>
     <mi>y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)\mapsto x\times x+y\times y
  </annotation>
 </semantics>
</math>

 can be reworked into</p>

<p>

<math display="block" id="Lambda_calculus:9">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>↦</mo>
    <mi>x</mi>
    <mo>×</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
    <mo>×</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <times></times>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <csymbol cd="unknown">y</csymbol>
     <times></times>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto(y\mapsto x\times x+y\times y)
  </annotation>
 </semantics>
</math>

 This method, known as <a class="uri" href="currying" title="wikilink">currying</a>, transforms a function that takes multiple arguments into a chain of functions each with a single argument.</p>

<p><a href="Function_application" title="wikilink">Function application</a> of the 

<math display="inline" id="Lambda_calculus:10">
 <semantics>
  <mo>sqsum</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>sqsum</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sqsum}
  </annotation>
 </semantics>
</math>

 function to the arguments (5, 2), yields at once</p>

<p>

<math display="block" id="Lambda_calculus:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↦</mo>
    <mi>x</mi>
    <mo>×</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
    <mo>×</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>5</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="latexml">maps-to</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <times></times>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <csymbol cd="unknown">y</csymbol>
     <times></times>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">5</cn>
     <ci>normal-,</ci>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((x,y)\mapsto x\times x+y\times y)(5,2)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_calculus:12">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>5</mn>
     <mo>×</mo>
     <mn>5</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>×</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">5</cn>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =5\times 5+2\times 2
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_calculus:13">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mn>29</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">29</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =29
  </annotation>
 </semantics>
</math>

, whereas evaluation of the curried version requires one more step</p>

<p>

<math display="block" id="Lambda_calculus:14">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>↦</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>↦</mo>
      <mi>x</mi>
      <mo>×</mo>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
      <mo>×</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>5</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">maps-to</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <csymbol cd="latexml">maps-to</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <times></times>
       <csymbol cd="unknown">x</csymbol>
       <plus></plus>
       <csymbol cd="unknown">y</csymbol>
       <times></times>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">5</cn>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((x\mapsto(y\mapsto x\times x+y\times y))(5))(2)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_calculus:15">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>↦</mo>
    <mn>5</mn>
    <mo>×</mo>
    <mn>5</mn>
    <mo>+</mo>
    <mi>y</mi>
    <mo>×</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <cn type="integer">5</cn>
     <times></times>
     <cn type="integer">5</cn>
     <plus></plus>
     <csymbol cd="unknown">y</csymbol>
     <times></times>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(y\mapsto 5\times 5+y\times y)(2)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_calculus:16">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>5</mn>
     <mo>×</mo>
     <mn>5</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>×</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">5</cn>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =5\times 5+2\times 2
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lambda_calculus:17">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mn>29</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">29</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =29
  </annotation>
 </semantics>
</math>

 to arrive at the same result.</p>
<h3 id="the-lambda-calculus">The lambda calculus</h3>

<p>The lambda calculus consists of a language of <strong>lambda terms</strong>, which is defined by a certain formal syntax, and a set of transformation rules, which allow manipulation of the lambda terms. These transformation rules can be viewed as an equational theory or as an <a href="operational_definition" title="wikilink">operational definition</a>.</p>

<p>As described above, all functions in the lambda calculus are anonymous functions, having no names. They only accept one input variable, with currying used to implement functions with several variables.</p>
<h4 id="lambda-terms">Lambda terms</h4>

<p>The syntax of the lambda calculus defines some expressions as valid lambda calculus expression and some as invalid, just as some strings of characters are valid <a href="C_(programming_language)" title="wikilink">C</a> programs and some are not. A valid lambda calculus expression is called a "lambda term".</p>

<p>The following three rules give an <a href="inductive_definition" title="wikilink">inductive definition</a> that can be applied to build all syntactically valid lambda terms:</p>
<ul>
<li>a variable, 

<math display="inline" id="Lambda_calculus:18">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, is itself a valid lambda term</li>
<li>if 

<math display="inline" id="Lambda_calculus:19">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is a lambda term, and 

<math display="inline" id="Lambda_calculus:20">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a variable, then 

<math display="inline" id="Lambda_calculus:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
    <mo>.</mo>
    <mi>t</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.t)
  </annotation>
 </semantics>
</math>

 is a lambda term (called a <strong>lambda abstraction</strong>);</li>
<li>if 

<math display="inline" id="Lambda_calculus:22">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lambda_calculus:23">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 are lambda terms, then 

<math display="inline" id="Lambda_calculus:24">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>t</mi>
    <mi>s</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (ts)
  </annotation>
 </semantics>
</math>

 is a lambda term (called an <strong>application</strong>).</li>
</ul>

<p>Nothing else is a lambda term. Thus a lambda term is valid if and only if it can be obtained by repeated application of these three rules. However, some parentheses can be omitted according to certain rules. For example, the outermost parentheses are usually not written. <em>See</em> <a class="uri" href="#Notation" title="wikilink">#Notation</a>, below.</p>

<p>A <strong>lambda abstraction</strong> 

<math display="inline" id="Lambda_calculus:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.t
  </annotation>
 </semantics>
</math>

 is a definition of an anonymous function that is capable of taking a single input 

<math display="inline" id="Lambda_calculus:26">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and substituting it into the expression 

<math display="inline" id="Lambda_calculus:27">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. It thus defines an anonymous function that takes x and returns t. For example 

<math display="inline" id="Lambda_calculus:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x^{2}+2
  </annotation>
 </semantics>
</math>

 is a lambda abstraction for the function 

<math display="inline" id="Lambda_calculus:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{2}+2
  </annotation>
 </semantics>
</math>

 using the term 

<math display="inline" id="Lambda_calculus:30">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}+2
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Lambda_calculus:31">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. The definition of a function with a lambda abstraction merely "sets up" the function but does not invoke it. The abstraction <a href="Free_variables_and_bound_variables" title="wikilink">binds</a> the variable 

<math display="inline" id="Lambda_calculus:32">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in the term 

<math display="inline" id="Lambda_calculus:33">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.</p>

<p>An <strong>application</strong> 

<math display="inline" id="Lambda_calculus:34">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ts
  </annotation>
 </semantics>
</math>

 represents the application of a function 

<math display="inline" id="Lambda_calculus:35">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 to an input 

<math display="inline" id="Lambda_calculus:36">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, that is, it represents the act of calling function 

<math display="inline" id="Lambda_calculus:37">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 on input 

<math display="inline" id="Lambda_calculus:38">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to produce 

<math display="inline" id="Lambda_calculus:39">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(s)
  </annotation>
 </semantics>
</math>

.</p>

<p>There is no concept in lambda calculus of variable declaration. In a definition such as 

<math display="inline" id="Lambda_calculus:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x+y
  </annotation>
 </semantics>
</math>

 (i.e. 

<math display="inline" id="Lambda_calculus:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x+y
  </annotation>
 </semantics>
</math>

), the lambda calculus treats 

<math display="inline" id="Lambda_calculus:42">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 as a variable that is not yet defined. The lambda abstraction 

<math display="inline" id="Lambda_calculus:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x+y
  </annotation>
 </semantics>
</math>

 is syntactically valid, and represents a function that adds its input to the yet-unknown 

<math display="inline" id="Lambda_calculus:44">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

.</p>

<p>Bracketing may be used and may be needed to disambiguate terms. For example, 

<math display="inline" id="Lambda_calculus:45">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.((\lambda x.x)x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lambda_calculus:46">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">x</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.(\lambda x.x))x
  </annotation>
 </semantics>
</math>

 denote different terms (although they coincidentally reduce to the same value. Here the first example defines a function who defines a function and returns the result of applying x to the child-function (apply function then return), where the second example defines a function who returns a function for any input and then returns it on application of x (return function then apply))</p>
<h4 id="functions-that-operate-on-functions">Functions that operate on functions</h4>

<p>In lambda calculus, functions are taken to be '<a href="First-class_object" title="wikilink">first class values</a>', so functions may be used as the inputs, or be returned as outputs from other functions.</p>

<p>For example, 

<math display="inline" id="Lambda_calculus:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x
  </annotation>
 </semantics>
</math>

 represents the identity function, 

<math display="inline" id="Lambda_calculus:48">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>→</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\rightarrow x
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Lambda_calculus:49">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.x)y
  </annotation>
 </semantics>
</math>

 represents the identity function applied to 

<math display="inline" id="Lambda_calculus:50">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. Further, 

<math display="inline" id="Lambda_calculus:51">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
    <mo>.</mo>
    <mi>y</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.y)
  </annotation>
 </semantics>
</math>

 represents the <strong>constant function</strong> 

<math display="inline" id="Lambda_calculus:52">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>→</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\rightarrow y
  </annotation>
 </semantics>
</math>

, the function that always returns 

<math display="inline" id="Lambda_calculus:53">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, no matter the input. In lambda calculus, function application is regarded as <a href="Operator_associativity" title="wikilink">left-associative</a>, so that 

<math display="inline" id="Lambda_calculus:54">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>t</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>t</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   stx
  </annotation>
 </semantics>
</math>

 means 

<math display="inline" id="Lambda_calculus:55">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>s</mi>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (st)x
  </annotation>
 </semantics>
</math>

.</p>

<p>There are several notions of "equivalence" and "reduction" that allow lambda terms to be "reduced" to "equivalent" lambda terms.</p>
<h4 id="alpha-equivalence">Alpha equivalence</h4>

<p>A basic form of equivalence, definable on lambda terms, is alpha equivalence. It captures the intuition that the particular choice of a bound variable, in a lambda abstraction, does not (usually) matter. For instance, 

<math display="inline" id="Lambda_calculus:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lambda_calculus:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>y</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda y.y
  </annotation>
 </semantics>
</math>

 are alpha-equivalent lambda terms, and they both represent the same function (the identity function). The terms 

<math display="inline" id="Lambda_calculus:58">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lambda_calculus:59">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are not alpha-equivalent, because they are not bound in a lambda abstraction. In many presentations, it is usual to identify alpha-equivalent lambda terms.</p>

<p>The following definitions are necessary in order to be able to define beta reduction.</p>
<h4 id="free-variables">Free variables</h4>

<p>The <strong>free variables</strong> of a term are those variables not bound by a lambda abstraction. The set of free variables of an expression is defined inductively:</p>
<ul>
<li>The free variables of 

<math display="inline" id="Lambda_calculus:60">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 are just 

<math display="inline" id="Lambda_calculus:61">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

</li>
<li>The set of free variables of 

<math display="inline" id="Lambda_calculus:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.t
  </annotation>
 </semantics>
</math>

 is the set of free variables of 

<math display="inline" id="Lambda_calculus:63">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, but with 

<math display="inline" id="Lambda_calculus:64">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 removed</li>
<li>The set of free variables of 

<math display="inline" id="Lambda_calculus:65">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ts
  </annotation>
 </semantics>
</math>

 is the union of the set of free variables of 

<math display="inline" id="Lambda_calculus:66">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and the set of free variables of 

<math display="inline" id="Lambda_calculus:67">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>For example, the lambda term representing the identity 

<math display="inline" id="Lambda_calculus:68">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x
  </annotation>
 </semantics>
</math>

 has no free variables, but the function 

<math display="inline" id="Lambda_calculus:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x+y
  </annotation>
 </semantics>
</math>

 has a single free variable, 

<math display="inline" id="Lambda_calculus:70">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="capture-avoiding-substitutions">Capture-avoiding substitutions</h4>

<p>Suppose 

<math display="inline" id="Lambda_calculus:71">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Lambda_calculus:72">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lambda_calculus:73">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 are lambda terms and 

<math display="inline" id="Lambda_calculus:74">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lambda_calculus:75">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are variables. The notation 

<math display="inline" id="Lambda_calculus:76">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>r</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t[x:=r]
  </annotation>
 </semantics>
</math>

 indicates substitution of 

<math display="inline" id="Lambda_calculus:77">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Lambda_calculus:78">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Lambda_calculus:79">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 in a <em>capture-avoiding</em> manner. This is defined so that:</p>
<ul>
<li>

<math display="inline" id="Lambda_calculus:80">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>r</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">r</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[x:=r]=r
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Lambda_calculus:81">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>r</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[x:=r]=y
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Lambda_calculus:82">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq y
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Lambda_calculus:83">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>r</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>r</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>r</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (ts)[x:=r]=(t[x:=r])(s[x:=r])
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Lambda_calculus:84">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>r</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">t</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.t)[x:=r]=\lambda x.t
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Lambda_calculus:85">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>y</mi>
    <mo>.</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>r</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>r</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda y.t)[x:=r]=\lambda y.(t[x:=r])
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Lambda_calculus:86">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lambda_calculus:87">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is not in the free variables of 

<math display="inline" id="Lambda_calculus:88">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

. The variable 

<math display="inline" id="Lambda_calculus:89">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is said to be "fresh" for 

<math display="inline" id="Lambda_calculus:90">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>For example, 

<math display="inline" id="Lambda_calculus:91">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>y</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo>:=</mo>
     <mi>y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">x</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.x)[y:=y]=\lambda x.(x[y:=y])=\lambda x.x
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Lambda_calculus:92">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\lambda x.y)x)[x:=y]=((\lambda x.y)[x:=y])(x[x:=y])=(\lambda x.y)y
  </annotation>
 </semantics>
</math>

.</p>

<p>The freshness condition (requiring that 

<math display="inline" id="Lambda_calculus:93">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is not in the free variables of 

<math display="inline" id="Lambda_calculus:94">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

) is crucial in order to ensure that substitution does not change the meaning of functions. For example, a substitution is made that ignores the freshness condition

<math display="block" id="Lambda_calculus:95">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>y</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo>:=</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">x</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.y)[y:=x]=\lambda x.(y[y:=x])=\lambda x.x
  </annotation>
 </semantics>
</math>

. This substitution turns the constant function 

<math display="inline" id="Lambda_calculus:96">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.y
  </annotation>
 </semantics>
</math>

 into the identity 

<math display="inline" id="Lambda_calculus:97">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x
  </annotation>
 </semantics>
</math>

 by substitution.</p>

<p>In general, failure to meet the freshness condition can be remedied by alpha-renaming with a suitable fresh variable. For example, switching back to our correct notion of substitution, in 

<math display="inline" id="Lambda_calculus:98">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>y</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.y)[y:=x]
  </annotation>
 </semantics>
</math>

 the lambda abstraction can be renamed with a fresh variable 

<math display="inline" id="Lambda_calculus:99">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

, to obtain 

<math display="inline" id="Lambda_calculus:100">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>z</mi>
    <mo>.</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>y</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>z</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>y</mi>
     <mo>:=</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>z</mi>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">x</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda z.y)[y:=x]=\lambda z.(y[y:=x])=\lambda z.x
  </annotation>
 </semantics>
</math>

, and the meaning of the function is preserved by substitution.</p>
<h4 id="beta-reduction">Beta reduction</h4>

<p>The beta reduction rule states that an application of the form 

<math display="inline" id="Lambda_calculus:101">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">s</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.t)s
  </annotation>
 </semantics>
</math>

 reduces to the term 

<math display="inline" id="Lambda_calculus:102">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>s</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t[x:=s]
  </annotation>
 </semantics>
</math>

. The notation 

<math display="inline" id="Lambda_calculus:103">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
   <mo>→</mo>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>s</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.t)s\to t[x:=s]
  </annotation>
 </semantics>
</math>

 is used to indicate that 

<math display="inline" id="Lambda_calculus:104">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">s</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.t)s
  </annotation>
 </semantics>
</math>

 beta reduces to 

<math display="inline" id="Lambda_calculus:105">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>s</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t[x:=s]
  </annotation>
 </semantics>
</math>

. For example, for every 

<math display="inline" id="Lambda_calculus:106">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Lambda_calculus:107">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
   <mo>→</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>s</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">s</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.x)s\to x[x:=s]=s
  </annotation>
 </semantics>
</math>

. This demonstrates that 

<math display="inline" id="Lambda_calculus:108">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x
  </annotation>
 </semantics>
</math>

 really is the identity. Similarly, 

<math display="inline" id="Lambda_calculus:109">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
   <mo>→</mo>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>s</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.y)s\to y[x:=s]=y
  </annotation>
 </semantics>
</math>

, which demonstrates that 

<math display="inline" id="Lambda_calculus:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.y
  </annotation>
 </semantics>
</math>

 is a constant function.</p>

<p>The lambda calculus may be seen as an idealised functional programming language, like <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> or <a href="Standard_ML" title="wikilink">Standard ML</a>. Under this view, beta reduction corresponds to a computational step. This step can be repeated by additional beta conversions until there are no more applications left to reduce. In the untyped lambda calculus, as presented here, this reduction process may not terminate. For instance, consider the term 

<math display="inline" id="Lambda_calculus:111">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.xx)(\lambda x.xx)
  </annotation>
 </semantics>
</math>

. Here 

<math display="inline" id="Lambda_calculus:112">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>x</mi>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>x</mi>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>x</mi>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.xx)(\lambda x.xx)\to(xx)[x:=\lambda x.xx]=(x[x:=\lambda x.xx])(x[x:%
=\lambda x.xx])=(\lambda x.xx)(\lambda x.xx)
  </annotation>
 </semantics>
</math>

. That is, the term reduces to itself in a single beta reduction, and therefore the reduction process will never terminate.</p>

<p>Another aspect of the untyped lambda calculus is that it does not distinguish between different kinds of data. For instance, it may be desirable to write a function that only operates on numbers. However, in the untyped lambda calculus, there is no way to prevent a function from being applied to <a href="truth_value" title="wikilink">truth values</a>, strings, or other non-number objects.</p>
<h2 id="formal-definition">Formal definition</h2>
<h3 id="definition">Definition</h3>

<p>Lambda expressions are composed of</p>
<ul>
<li>variables v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>n</sub>, ...</li>
<li>the abstraction symbols lambda 'λ' and dot '.'</li>
<li>parentheses ( )</li>
</ul>

<p>The set of lambda expressions, Λ, can be <a href="Recursive_definition" title="wikilink">defined inductively</a>:</p>
<ol>
<li>If x is a variable, then x ∈ Λ</li>
<li>If x is a variable and M ∈ Λ, then (λx.M) ∈ Λ</li>
<li>If M, N ∈ Λ, then (M N) ∈ Λ</li>
</ol>

<p>Instances of rule 2 are known as abstractions and instances of rule 3 are known as applications.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="notation">Notation</h3>

<p>To keep the notation of lambda expressions uncluttered, the following conventions are usually applied.</p>
<ul>
<li>Outermost parentheses are dropped: M N instead of (M N)</li>
<li>Applications are assumed to be left associative: M N P may be written instead of ((M N) P)<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li>The body of an abstraction extends <a href="Regular_expression#Lazy_quantification" title="wikilink">as far right as possible</a>: λx.M N means λx.(M N) and not (λx.M) N</li>
<li>A sequence of abstractions is contracted: λx.λy.λz.N is abbreviated as λxyz.N<ref name="Selinger"></ref></li>
</ul>

<p><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="free-and-bound-variables">Free and bound variables</h3>

<p>The abstraction operator, λ, is said to bind its variable wherever it occurs in the body of the abstraction. Variables that fall within the scope of an abstraction are said to be <em>bound</em>. All other variables are called <em>free</em>. For example, in the following expression y is a bound variable and x is free: <code>λ''y''.''x'' ''x'' ''y''</code>. Also note that a variable is bound by its "nearest" abstraction. In the following example the single occurrence of x in the expression is bound by the second lambda: <code>λ''x''.''y''  (λ''x''.''z'' ''x'')</code></p>

<p>The set of <em>free variables</em> of a lambda expression, M, is denoted as FV(M) and is defined by recursion on the structure of the terms, as follows:</p>
<ol>
<li>FV(x) = {x}, where x is a variable</li>
<li>FV(λx.M) = FV(M) \ {x}</li>
<li>FV(M N) = FV(M) ∪ FV(N)<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
</ol>

<p>An expression that contains no free variables is said to be <em>closed</em>. Closed lambda expressions are also known as combinators and are equivalent to terms in <a href="combinatory_logic" title="wikilink">combinatory logic</a>.</p>
<h2 id="reduction">Reduction</h2>

<p>The meaning of lambda expressions is defined by how expressions can be reduced.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>There are three kinds of reduction:</p>
<ul>
<li><strong>α-conversion</strong>: changing bound variables (<strong>alpha</strong>);</li>
<li><strong>β-reduction</strong>: applying functions to their arguments (<strong>beta</strong>);</li>
<li><strong>η-conversion</strong>: which captures a notion of extensionality (<strong>eta</strong>).</li>
</ul>

<p>We also speak of the resulting equivalences: two expressions are <em>β-equivalent</em>, if they can be β-converted into the same expression, and α/η-equivalence are defined similarly.</p>

<p>The term <em>redex</em>, short for <em>reducible expression</em>, refers to subterms that can be reduced by one of the reduction rules. For example, <code>(λ''x''.M) N</code> is a beta-redex in expressing the substitution of N for x in M; if <code>''x''</code> is not free in <code>M</code>, <code>λ''x''.M ''x''</code> is an eta-redex. The expression to which a redex reduces is called its reduct; using the previous example, the reducts of these expressions are respectively <code>M[''x'':=N]</code> and <code>M</code>.</p>
<h3 id="α-conversion">α-conversion</h3>

<p>Alpha-conversion, sometimes known as alpha-renaming,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> allows bound variable names to be changed. For example, alpha-conversion of <code>λ''x''.''x''</code> might yield <code>λ''y''.''y''</code>. Terms that differ only by alpha-conversion are called <em>α-equivalent</em>. Frequently, in uses of lambda calculus, α-equivalent terms are considered to be equivalent.</p>

<p>The precise rules for alpha-conversion are not completely trivial. First, when alpha-converting an abstraction, the only variable occurrences that are renamed are those that are bound to the same abstraction. For example, an alpha-conversion of <code>λ''x''.λ''x''.''x''</code> could result in <code>λ''y''.λ''x''.''x''</code>, but it could <em>not</em> result in <code>λ''y''.λ''x''.''y''</code>. The latter has a different meaning from the original.</p>

<p>Second, alpha-conversion is not possible if it would result in a variable getting captured by a different abstraction. For example, if we replace <code>''x''</code> with <code>''y''</code> in <code>λ''x''.λ''y''.''x''</code>, we get <code>λ''y''.λ''y''.''y''</code>, which is not at all the same.</p>

<p>In programming languages with static scope, alpha-conversion can be used to make <a href="name_resolution" title="wikilink">name resolution</a> simpler by ensuring that no variable name <a href="Variable_shadowing" title="wikilink">masks</a> a name in a containing <a href="scope_(programming)" title="wikilink">scope</a> (see <a href="Name_resolution#Alpha_renaming_to_make_name_resolution_trivial" title="wikilink">alpha renaming to make name resolution trivial</a>).</p>

<p>In the <a href="De_Bruijn_index" title="wikilink">De Bruijn index</a> notation, any two alpha-equivalent terms are literally identical.</p>
<h4 id="substitution">Substitution</h4>

<p>Substitution, written <code>''E''[''V'' := ''R'']</code>, is the process of replacing all free occurrences of the variable <code>''V''</code> in the expression <code>''E''</code> with expression <code>''R''</code>. Substitution on terms of the λ-calculus is defined by recursion on the structure of terms, as follows (note: x and y are only variables while M and N are any λ expression).</p>
<dl>
<dd><code>''x''[''x'' := N]        ≡ N</code>
</dd>
<dd><code>''y''[''x'' := N]        ≡ ''y'', if ''x'' ≠ ''y''</code>
</dd>
<dd><code>(M<sub>1</sub> M<sub>2</sub>)[''x'' := N]  ≡ (M<sub>1</sub>[''x'' := N]) (M<sub>2</sub>[''x'' := N])</code>
</dd>
<dd><code>(λ''x''.M)[''x'' := N]   ≡ λ''x''.M</code>
</dd>
<dd><code>(λ''y''.M)[''x'' := N]   ≡ λ''y''.(M[''x'' := N]), if ''x'' ≠ ''y'', ''provided'' ''y'' ∉ FV(N)</code>
</dd>
</dl>

<p>To substitute into a lambda abstraction, it is sometimes necessary to α-convert the expression. For example, it is not correct for <code>(λ''x''.''y'')[''y'' := ''x'']</code> to result in <code>(λ''x''.''x'')</code>, because the substituted <code>''x''</code> was supposed to be free but ended up being bound. The correct substitution in this case is <code>(λ''z''.''x'')</code>, up to α-equivalence. Notice that substitution is defined uniquely up to α-equivalence.</p>
<h3 id="β-reduction">β-reduction</h3>

<p>Beta-reduction captures the idea of function application. Beta-reduction is defined in terms of substitution: the beta-reduction of <code> ((λ''V''.''E'') ''E′'') </code> is <code>''E''[''V'' := ''E′'']</code>.</p>

<p>For example, assuming some encoding of <code>2, 7, ×</code>, we have the following β-reduction: <code>((λ''n''.''n''×2) 7) </code>→<code> 7×2</code>.</p>
<h3 id="η-conversion">η-conversion</h3>

<p>Eta-conversion expresses the idea of <a class="uri" href="extensionality" title="wikilink">extensionality</a>, which in this context is that two functions are the same <a href="if_and_only_if" title="wikilink">if and only if</a> they give the same result for all arguments. Eta-conversion converts between <code>λ''x''.(''f'' ''x'')</code> and <code>''f''</code> whenever <code>''x''</code> does not appear free in <code>''f''</code>.</p>
<h2 id="normal-forms-and-confluence">Normal forms and confluence</h2>

<p>For the untyped lambda calculus, β-reduction as a <a href="rewrite_system" title="wikilink">rewriting rule</a> is neither <a href="strongly_normalising" title="wikilink">strongly normalising</a> nor <a href="weakly_normalising" title="wikilink">weakly normalising</a>.</p>

<p>However, it can be shown that β-reduction is <a href="confluence_(abstract_rewriting)" title="wikilink">confluent</a>. (Of course, we are working up to α-conversion, i.e. we consider two normal forms to be equal, if it is possible to α-convert one into the other.)</p>

<p>Therefore, both strongly normalising terms and weakly normalising terms have a unique normal form. For strongly normalising terms, any reduction strategy is guaranteed to yield the normal form, whereas for weakly normalising terms, some reduction strategies may fail to find it.</p>
<h2 id="encoding-datatypes">Encoding datatypes</h2>

<p>The basic lambda calculus may be used to model booleans, <a class="uri" href="arithmetic" title="wikilink">arithmetic</a>, data structures and recursion, as illustrated in the following sub-sections.</p>
<h3 id="arithmetic-in-lambda-calculus">Arithmetic in lambda calculus</h3>

<p>There are several possible ways to define the <a href="natural_number" title="wikilink">natural numbers</a> in lambda calculus, but by far the most common are the <a href="Church_numeral" title="wikilink">Church numerals</a>, which can be defined as follows:</p>
<dl>
<dd><code>0 := λ''f''.λ''x''.''x''</code>
</dd>
<dd><code>1 := λ''f''.λ''x''.''f'' ''x''</code>
</dd>
<dd><code>2 := λ''f''.λ''x''.''f'' (''f'' ''x'')</code>
</dd>
<dd><code>3 := λ''f''.λ''x''.''f'' (''f'' (''f'' ''x''))</code>
</dd>
</dl>

<p>and so on. Or using the alternative syntax presented above in <em><a href="#Notation" title="wikilink">Notation</a></em>:</p>
<dl>
<dd><code>0 := λ''fx''.''x''</code>
</dd>
<dd><code>1 := λ''fx''.''f'' ''x''</code>
</dd>
<dd><code>2 := λ''fx''.''f'' (''f'' ''x'')</code>
</dd>
<dd><code>3 := λ''fx''.''f'' (''f'' (''f'' ''x''))</code>
</dd>
</dl>

<p>A Church numeral is a <a href="higher-order_function" title="wikilink">higher-order function</a>—it takes a single-argument function <code>''f''</code>, and returns another single-argument function. The Church numeral <code>''n''</code> is a function that takes a function <code>''f''</code> as argument and returns the <code>''n''</code>-th composition of <code>''f''</code>, i.e. the function <code>''f''</code> composed with itself <code>''n''</code> times. This is denoted <code>''f''<sup>(''n'')</sup></code> and is in fact the <code>''n''</code>-th power of <code>''f''</code> (considered as an operator); <code>''f''<sup>(0)</sup></code> is defined to be the identity function. Such repeated compositions (of a single function <code>''f''</code>) obey the <a href="laws_of_exponents" title="wikilink">laws of exponents</a>, which is why these numerals can be used for arithmetic. (In Church's original lambda calculus, the formal parameter of a lambda expression was required to occur at least once in the function body, which made the above definition of <code>0</code> impossible.)</p>

<p>We can define a successor function, which takes a number <code>''n''</code> and returns <code>''n'' + 1</code> by adding another application of <code>''f''</code>,where '(mf)x' means the function 'f' is applied 'm' times on 'x':</p>
<dl>
<dd><code>SUCC := λ''n''.λ''f''.λ''x''.''f'' (''n'' ''f'' ''x'')</code>
</dd>
</dl>

<p>Because the <code>''m''</code>-th composition of <code>''f''</code> composed with the <code>''n''</code>-th composition of <code>''f''</code> gives the <code>''m''+''n''</code>-th composition of <code>''f''</code>, addition can be defined as follows:</p>
<dl>
<dd><code>PLUS := λ''m''.λ''n''.λ''f''.λ''x''.''m'' ''f'' (''n'' ''f'' ''x'')</code>
</dd>
</dl>

<p><code>PLUS</code> can be thought of as a function taking two natural numbers as arguments and returning a natural number; it can be verified that</p>
<dl>
<dd><code>PLUS 2 3</code>
</dd>
</dl>

<p>and</p>
<dl>
<dd><code>5</code>
</dd>
</dl>

<p>are β-equivalent lambda expressions. Since adding <code>''m''</code> to a number <code>''n''</code> can be accomplished by adding 1 <code>''m''</code> times, an equivalent definition is:</p>
<dl>
<dd><code>PLUS := λ''m''.λ''n''.''m'' SUCC ''n ''</code><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a>
</dd>
</dl>

<p>Similarly, multiplication can be defined as</p>
<dl>
<dd><code>MULT := λ''m''.λ''n''.λ''f''.''m'' (''n'' ''f'')</code><ref>
</ref></dd>
</dl>

<p> Alternatively</p>
<dl>
<dd><code>MULT := λ''m''.λ''n''.''m'' (PLUS ''n'') 0</code>
</dd>
</dl>

<p>since multiplying <code>''m''</code> and <code>''n''</code> is the same as repeating the add <code>''n''</code> function <code>''m''</code> times and then applying it to zero. Exponentiation has a rather simple rendering in Church numerals, namely</p>
<dl>
<dd><code>POW := λ''b''.λ''e''.''e'' ''b''</code>
</dd>
</dl>

<p>The predecessor function defined by <code>PRED ''n'' = ''n'' − 1</code> for a positive integer <code>''n''</code> and <code>PRED 0 = 0</code> is considerably more difficult. The formula</p>
<dl>
<dd><code>PRED := λ''n''.λ''f''.λ''x''.''n'' (λ''g''.λ''h''.''h'' (''g'' ''f'')) (λ''u''.''x'') (λ''u''.''u'')</code>
</dd>
</dl>

<p>can be validated by showing inductively that if <em>T</em> denotes <code>(λ''g''.λ''h''.''h'' (''g'' ''f''))</code>, then <code>T<sup>(''n'')</sup>(λ''u''.''x'') = (λ''h''.''h''(''f''<sup>(''n''−1)</sup>(''x'')))</code> for <code>''n'' &gt; 0</code>. Two other definitions of <code>PRED</code> are given below, one using <a href="#Logic_and_predicates" title="wikilink">conditionals</a> and the other using <a href="#Pairs" title="wikilink">pairs</a>. With the predecessor function, subtraction is straightforward. Defining</p>
<dl>
<dd><code>SUB := λ''m''.λ''n''.''n'' PRED ''m''</code>,
</dd>
</dl>

<p><code>SUB ''m'' ''n''</code> yields <code>''m'' − ''n''</code> when <code>''m'' &gt; ''n''</code> and <code>0</code> otherwise.</p>
<h3 id="logic-and-predicates">Logic and predicates</h3>

<p>By convention, the following two definitions (known as Church booleans) are used for the boolean values <code>TRUE</code> and <code>FALSE</code>:</p>
<dl>
<dd><code>TRUE := λ''x''.λ''y''.''x''</code>
</dd>
<dd><code>FALSE := λ''x''.λ''y''.''y''</code>
<dl>
<dd>(Note that <code>FALSE</code> is equivalent to the Church numeral zero defined above)
</dd>
</dl>
</dd>
</dl>

<p>Then, with these two λ-terms, we can define some logic operators (these are just possible formulations; other expressions are equally correct):</p>
<dl>
<dd><code>AND := λ''p''.λ''q''.''p'' ''q'' ''p''</code>
</dd>
<dd><code>OR := λ''p''.λ''q''.''p'' ''p'' ''q''</code>
</dd>
<dd><code>NOT := λ''p''.λ''a''.λ''b''.''p'' ''b'' ''a''</code>
</dd>
<dd><code>IFTHENELSE := λ''p''.λ''a''.λ''b''.''p'' ''a'' ''b''</code>
</dd>
</dl>

<p>We are now able to compute some logic functions, for example:</p>
<dl>
<dd><code>AND TRUE FALSE</code>
<dl>
<dd><code>≡ (λ''p''.λ''q''.''p'' ''q'' ''p'') TRUE FALSE →<sub>β</sub> TRUE FALSE TRUE</code>
</dd>
<dd><code>≡ (λ''x''.λ''y''.''x'') FALSE TRUE →<sub>β</sub>  FALSE</code>
</dd>
</dl>
</dd>
</dl>

<p>and we see that <code>AND TRUE FALSE</code> is equivalent to <code>FALSE</code>.</p>

<p>A <em>predicate</em> is a function that returns a boolean value. The most fundamental predicate is <code>ISZERO</code>, which returns <code>TRUE</code> if its argument is the Church numeral <code>0</code>, and <code>FALSE</code> if its argument is any other Church numeral:</p>
<dl>
<dd><code>ISZERO := λ''n''.''n'' (λ''x''.FALSE) TRUE</code>
</dd>
</dl>

<p>The following predicate tests whether the first argument is less-than-or-equal-to the second:</p>
<dl>
<dd><code>LEQ := λ''m''.λ''n''.ISZERO (SUB ''m'' ''n'')</code>,
</dd>
</dl>

<p>and since <code>''m'' = ''n''</code>, if <code>LEQ ''m'' ''n''</code> and <code>LEQ ''n'' ''m''</code>, it is straightforward to build a predicate for numerical equality.</p>

<p>The availability of predicates and the above definition of <code>TRUE</code> and <code>FALSE</code> make it convenient to write "if-then-else" expressions in lambda calculus. For example, the predecessor function can be defined as:</p>
<dl>
<dd><code>PRED := λ''n''.''n'' (λ''g''.λ''k''.ISZERO (''g'' 1) ''k'' (PLUS (''g'' ''k'') 1)) (λ''v''.0) 0 </code>
</dd>
</dl>

<p>which can be verified by showing inductively that <code>''n'' (λ''g''.λ''k''.ISZERO (''g'' 1) ''k'' (PLUS (''g'' ''k'') 1)) (λ''v''.0)</code> is the add <code>''n''</code> − 1 function for <code>''n''</code> &gt; 0.</p>
<h3 id="pairs">Pairs</h3>

<p>A pair (2-tuple) can be defined in terms of <code>TRUE</code> and <code>FALSE</code>, by using the <a href="Church_encoding#Church_pairs" title="wikilink">Church encoding for pairs</a>. For example, <code>PAIR</code> encapsulates the pair (<code>''x''</code>,<code>''y''</code>), <code>FIRST</code> returns the first element of the pair, and <code>SECOND</code> returns the second.</p>
<dl>
<dd><code>PAIR := λ''x''.λ''y''.λ''f''.''f'' ''x'' ''y''</code>
</dd>
<dd><code>FIRST := λ''p''.''p'' TRUE</code>
</dd>
<dd><code>SECOND := λ''p''.''p'' FALSE</code>
</dd>
<dd><code>NIL := λ''x''.TRUE </code>
</dd>
<dd><code>NULL := λ''p''.''p'' (λ''x''.λ''y''.FALSE)</code>
</dd>
</dl>

<p>A linked list can be defined as either NIL for the empty list, or the <code>PAIR</code> of an element and a smaller list. The predicate <code>NULL</code> tests for the value <code>NIL</code>. (Alternatively, with <code>NIL := FALSE</code>, the construct <code>''l'' (λ''h''.λ''t''.λ''z''.deal_with_head_''h''_and_tail_''t'') (deal_with_nil)</code> obviates the need for an explicit NULL test).</p>

<p>As an example of the use of pairs, the shift-and-increment function that maps <code>(''m'', ''n'')</code> to <code>(''n'', ''n'' + 1)</code> can be defined as</p>
<dl>
<dd><code>Φ := λ''x''.PAIR (SECOND ''x'') (SUCC (SECOND ''x''))</code>
</dd>
</dl>

<p>which allows us to give perhaps the most transparent version of the predecessor function:</p>
<dl>
<dd><code>PRED := λ''n''.FIRST (''n'' Φ (PAIR 0 0)).</code>
</dd>
</dl>
<h3 id="recursion-and-fixed-points">Recursion and fixed points</h3>

<p><a class="uri" href="Recursion" title="wikilink">Recursion</a> is the definition of a function using the function itself; on the face of it, lambda calculus does not allow this (we can't refer to a value which is yet to be defined, inside the lambda term defining that same value, as all functions are anonymous in lambda calculus). However, this impression is misleading: in  <code>(λ''x''.''x'' ''x'') ''y''</code>  both <em>x</em>‍ ‍'s refer to the same lambda term, <em>y</em>, so it is possible for a lambda expression – here <em>y</em> – to be arranged to receive itself as its argument value, through self-application.</p>

<p>Consider for instance the <a class="uri" href="factorial" title="wikilink">factorial</a> function <code>F(''n'')</code> recursively defined by</p>
<dl>
<dd><code>F(''n'') = 1, if ''n'' = 0; else ''n'' × F(''n'' − 1)</code>.
</dd>
</dl>

<p>In the lambda expression which is to represent this function, a <em>parameter</em> (typically the first one) will be assumed to receive the lambda expression itself as its value, so that calling it – applying it to an argument – will amount to recursion. Thus to achieve recursion, the intended-as-self-referencing argument (called <code>''r''</code> here) must always be passed to itself within the function body, at a call point:</p>
<dl>
<dd><code>G := λ''r''. λ''n''.(1, if ''n'' = 0; else ''n'' × (''r'' ''r'' (''n''−1)))</code>
<dl>
<dd><dl>
<dd>with  <code> ''r'' ''r'' ''x'' = F ''x'' = G ''r'' ''x''</code>  to hold, so  <code>''r'' = G</code>  and
</dd>
</dl>
</dd>
</dl>
</dd>
<dd><code>F := G G = (λ''x''.''x'' ''x'') G</code>
</dd>
</dl>

<p>The self-application achieves replication here, passing the function's lambda expression on to the next invocation as an argument value, making it available to be referenced and called there.</p>

<p>This solves it but requires re-writing each recursive call as self-application. We would like to have a generic solution, without a need for any re-writes:</p>
<dl>
<dd><code>G := λ''r''. λ''n''.(1, if ''n'' = 0; else ''n'' × (''r'' (''n''−1)))</code>
<dl>
<dd><dl>
<dd>with  <code> ''r'' ''x'' = F ''x'' = G ''r'' ''x''</code>  to hold, so  <code>''r'' = G ''r'' =: FIX G</code>  and
</dd>
</dl>
</dd>
</dl>
</dd>
<dd><code>F := FIX G</code>  where  <code>FIX ''g'' := (''r'' where ''r'' = ''g'' ''r'') = ''g'' (FIX ''g'')</code>
<dl>
<dd><dl>
<dd>so that  <code> FIX G = G (FIX G) = (λ''n''.(1, if ''n'' = 0; else ''n'' × ((FIX G) (''n''−1)))) </code>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>Given a lambda term with first argument representing recursive call (e.g. <code>G</code> here), the <em>fixed-point</em> combinator <code>FIX</code> will return a self-replicating lambda expression representing the recursive function (here, <code>F</code>). The function does not need to be explicitly passed to itself at any point, for the self-replication is arranged in advance, when it is created, to be done each time it is called. Thus the original lambda expression <code>(FIX G)</code> is re-created inside itself, at call-point, achieving <a class="uri" href="self-reference" title="wikilink">self-reference</a>.</p>

<p>In fact, there are many possible definitions for this <code>FIX</code> operator, the simplest of them being:</p>
<dl>
<dd><code>'''Y''' := λ''g''.(λ''x''.''g'' (''x'' ''x'')) (λ''x''.''g'' (''x'' ''x''))</code>
</dd>
</dl>

<p>In the lambda calculus, <code>'''Y''' ''g''</code>  is a fixed-point of <code>''g''</code>, as it expands to:</p>
<dl>
<dd><code>'''Y''' ''g''</code>
</dd>
<dd><code>λ''h''.((λ''x''.''h'' (''x'' ''x'')) (λ''x''.''h'' (''x'' ''x''))) ''g''</code>
</dd>
<dd><code>(λ''x''.''g'' (''x'' ''x'')) (λ''x''.''g'' (''x'' ''x''))</code>
</dd>
<dd><code>''g'' ((λ''x''.''g'' (''x'' ''x'')) (λ''x''.''g'' (''x'' ''x'')))</code>
</dd>
<dd><code>''g'' ('''Y''' ''g'')</code>
</dd>
</dl>

<p>Now, to perform our recursive call to the factorial function, we would simply call <code>('''Y''' G) ''n''</code>,  where <em>n</em> is the number we are calculating the factorial of. Given <em>n</em> = 4, for example, this gives:</p>
<dl>
<dd><code>('''Y''' G) 4 </code>
</dd>
<dd><code>G ('''Y''' G) 4 </code>
</dd>
<dd><code>(λ''r''.λ''n''.(1, if ''n'' = 0; else ''n'' × (''r'' (''n''−1)))) ('''Y''' G) 4</code>
</dd>
<dd><code>(λ''n''.(1, if ''n'' = 0; else ''n'' × (('''Y''' G) (''n''−1)))) 4</code>
</dd>
<dd><code>1, if 4 = 0; else 4 × (('''Y''' G) (4−1))</code>
</dd>
<dd><code>4 × (G ('''Y''' G) (4−1))</code>
</dd>
<dd><code>4 × ((λ''n''.(1, if ''n'' = 0; else ''n'' × (('''Y''' G) (''n''−1)))) (4−1))</code>
</dd>
<dd><code>4 × (1, if 3 = 0; else 3 × (('''Y''' G) (3−1)))</code>
</dd>
<dd><code>4 × (3 × (G ('''Y''' G) (3−1)))</code>
</dd>
<dd><code>4 × (3 × ((λ''n''.(1, if ''n'' = 0; else ''n'' × (('''Y''' G) (''n''−1)))) (3−1)))</code>
</dd>
<dd><code>4 × (3 × (1, if 2 = 0; else 2 × (('''Y''' G) (2−1))))</code>
</dd>
<dd><code>4 × (3 × (2 × (G ('''Y''' G) (2−1))))</code>
</dd>
<dd><code>4 × (3 × (2 × ((λ''n''.(1, if ''n'' = 0; else ''n'' × (('''Y''' G) (''n''−1)))) (2−1))))</code>
</dd>
<dd><code>4 × (3 × (2 × (1, if 1 = 0; else 1 × (('''Y''' G) (1−1)))))</code>
</dd>
<dd><code>4 × (3 × (2 × (1 × (G ('''Y''' G) (1−1)))))</code>
</dd>
<dd><code>4 × (3 × (2 × (1 × ((λ''n''.(1, if ''n'' = 0; else ''n'' × (('''Y''' G) (''n''−1)))) (1−1)))))</code>
</dd>
<dd><code>4 × (3 × (2 × (1 × (1, if 0 = 0; else 0 × (('''Y''' G) (0−1))))))</code>
</dd>
<dd><code>4 × (3 × (2 × (1 × (1))))</code>
</dd>
<dd><code>24</code>
</dd>
</dl>

<p>Every recursively defined function can be seen as a fixed point of some suitably defined function closing over the recursive call with an extra argument, and therefore, using <code>'''Y'''</code>, every recursively defined function can be expressed as a lambda expression. In particular, we can now cleanly define the subtraction, multiplication and comparison predicate of natural numbers recursively.</p>
<h3 id="standard-terms">Standard terms</h3>

<p>Certain terms have commonly accepted names:</p>
<dl>
<dd>

<p><code>'''I''' := λ''x''.''x''</code></p>
</dd>
<dd>

<p><code>'''K''' := λ''x''.λ''y''.''x''</code></p>
</dd>
<dd>

<p><code>'''S''' := λ''x''.λ''y''.λ''z''.''x'' ''z'' (''y'' ''z'') </code></p>
</dd>
<dd>

<p><code>'''B''' := λ''x''.λ''y''.λ''z''.''x'' (''y'' ''z'') </code></p>
</dd>
<dd>

<p><code>'''C''' := λ''x''.λ''y''.λ''z''.''x'' ''z'' ''y''</code></p>
</dd>
<dd>

<p><code>'''W''' := λ''x''.λ''y''.''x'' ''y'' ''y''</code></p>
</dd>
<dd>

<p><code>'''U''' := λ''x''.''x'' ''x''  </code></p>
</dd>
<dd>

<p><code>'''ω''' := λ''x''.''x'' ''x'' </code></p>
</dd>
<dd>

<p><code>'''Ω''' := '''ω ω''' </code></p>
</dd>
<dd>

<p><code>'''Y''' := λ''g''.(λ''x''.''g'' (''x'' ''x'')) (λ''x''.''g'' (''x'' ''x''))</code></p>
</dd>
</dl>
<h2 id="typed-lambda-calculus">Typed lambda calculus</h2>

<p>A <strong>typed lambda calculus</strong> is a typed <a href="formalism_(mathematics)" title="wikilink">formalism</a> that uses the lambda-symbol (

<math display="inline" id="Lambda_calculus:113">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

) to denote anonymous function abstraction. In this context, types are usually objects of a syntactic nature that are assigned to lambda terms; the exact nature of a type depends on the calculus considered (see kinds below). From a certain point of view, typed lambda calculi can be seen as refinements of the <a href="untyped_lambda_calculus" title="wikilink">untyped lambda calculus</a> but from another point of view, they can also be considered the more fundamental theory and <em>untyped lambda calculus</em> a special case with only one type.</p>

<p>Typed lambda calculi are foundational <a href="programming_languages" title="wikilink">programming languages</a> and are the base of typed <a href="functional_programming_languages" title="wikilink">functional programming languages</a> such as <a href="ML_programming_language" title="wikilink">ML</a> and Haskell and, more indirectly, typed <a href="imperative_programming" title="wikilink">imperative programming languages</a>. Typed lambda calculi play an important role in the design of <a href="type_systems" title="wikilink">type systems</a> for programming languages; here typability usually captures desirable properties of the program, e.g. the program will not cause a memory access violation.</p>

<p>Typed lambda calculi are closely related to <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="proof_theory" title="wikilink">proof theory</a> via the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a> and they can be considered as the <a href="internal_language" title="wikilink">internal language</a> of classes of <a href="category_theory" title="wikilink">categories</a>, e.g. the simply typed lambda calculus is the language of <a href="cartesian_closed_category" title="wikilink">Cartesian closed categories</a> (CCCs).</p>
<h2 id="computable-functions-and-lambda-calculus">Computable functions and lambda calculus</h2>

<p>A function <em>F</em>: <strong>N</strong> → <strong>N</strong> of natural numbers is a computable function if and only if there exists a lambda expression <em>f</em> such that for every pair of <em>x</em>, <em>y</em> in <strong>N</strong>, <em>F</em>(<em>x</em>)=<em>y</em> if and only if <em>f</em> <code>''x''</code> =<sub>β</sub> <code>''y''</code>,  where <code>''x''</code> and <code>''y''</code> are the Church numerals corresponding to <em>x</em> and <em>y</em>, respectively and =<sub>β</sub> meaning equivalence with beta reduction. This is one of the many ways to define computability; see the <a href="Church-Turing_thesis" title="wikilink">Church-Turing thesis</a> for a discussion of other approaches and their equivalence.</p>
<h2 id="undecidability-of-equivalence">Undecidability of equivalence</h2>

<p>There is no algorithm that takes as input two lambda expressions and outputs <code>TRUE</code> or <code>FALSE</code> depending on whether or not the two expressions are equivalent. This was historically the first problem for which undecidability could be proven. As is common for a proof of undecidability, the proof shows that no computable function can decide the equivalence. <a href="Church's_thesis" title="wikilink">Church's thesis</a> is then invoked to show that no algorithm can do so.</p>

<p>Church's proof first reduces the problem to determining whether a given lambda expression has a <em>normal form</em>. A normal form is an equivalent expression that cannot be reduced any further under the rules imposed by the form. Then he assumes that this predicate is computable, and can hence be expressed in lambda calculus. Building on earlier work by Kleene and constructing a <a href="Gödel_numbering" title="wikilink">Gödel numbering</a> for lambda expressions, he constructs a lambda expression <code>''e''</code> that closely follows the proof of <a href="Gödel's_incompleteness_theorems" title="wikilink">Gödel's first incompleteness theorem</a>. If <code>''e''</code> is applied to its own Gödel number, a contradiction results.</p>
<h2 id="lambda-calculus-and-programming-languages">Lambda calculus and programming languages</h2>

<p>As pointed out by <a href="Peter_Landin" title="wikilink">Peter Landin</a>'s 1965 paper <cite>[<a class="uri" href="http://portal.acm.org/citation.cfm?id=363749&amp;coll">http://portal.acm.org/citation.cfm?id=363749&amp;coll;</a>;=portal&amp;dl;=ACM A Correspondence between ALGOL 60 and Church's Lambda-notation]</cite>, sequential <a href="procedural_programming" title="wikilink">procedural programming languages</a> can be understood in terms of the lambda calculus, which provides the basic mechanisms for procedural abstraction and procedure (subprogram) application.</p>

<p>Lambda calculus <a href="Reification_(computer_science)" title="wikilink">reifies</a> "functions" and makes them first-class objects, which raises implementation complexity when it is implemented.</p>
<h3 id="anonymous-functions">Anonymous functions</h3>

<p>For example in <a href="Lisp_(programming_language)" title="wikilink">Lisp</a> the 'square' function can be expressed as a lambda expression as follows:</p>
<pre class="Lisp"><code>(lambda (x) (* x x))</code></pre>

<p>The above example is an expression that evaluates to a first-class function. The symbol <code>lambda</code> creates an anonymous function, given a list of parameter names, <code>(x)</code> — just a single argument in this case, and an expression that is evaluated as the body of the function, <code>(* x x)</code>. The Haskell example is identical. Anonymous functions are sometimes called lambda expressions.</p>

<p>For example <a href="Pascal_(programming_language)" title="wikilink">Pascal</a> and many other imperative languages have long supported passing <a class="uri" href="subprograms" title="wikilink">subprograms</a> as <a class="uri" href="arguments" title="wikilink">arguments</a> to other subprograms through the mechanism of <a href="function_pointers" title="wikilink">function pointers</a>. However, function pointers are not a sufficient condition for functions to be <a href="First-class_function" title="wikilink">first class</a> datatypes, because a function is a first class datatype if and only if new instances of the function can be created at run-time. And this run-time creation of functions is supported in <a class="uri" href="Smalltalk" title="wikilink">Smalltalk</a>, <a class="uri" href="Javascript" title="wikilink">Javascript</a>, and more recently in <a href="Scala_(programming_language)" title="wikilink">Scala</a>, <a href="Eiffel_(programming_language)" title="wikilink">Eiffel</a> ("agents"), <a href="C_Sharp_(programming_language)" title="wikilink">C#</a> ("delegates") and <a class="uri" href="C++11" title="wikilink">C++11</a>, among others.</p>
<h3 id="reduction-strategies">Reduction strategies</h3>

<p>Whether a term is normalising or not, and how much work needs to be done in normalising it if it is, depends to a large extent on the reduction strategy used. The distinction between reduction strategies relates to the distinction in functional programming languages between <a href="eager_evaluation" title="wikilink">eager evaluation</a> and <a href="lazy_evaluation" title="wikilink">lazy evaluation</a>.</p>
<dl>
<dt>Full beta reductions: Any redex can be reduced at any time. This means essentially the lack of any particular reduction strategy—with regard to reducibility, "all bets are off".<br/>
Applicative order: The leftmost, innermost redex is always reduced first. Intuitively this means a function's arguments are always reduced before the function itself. Applicative order always attempts to apply functions to normal forms, even when this is not possible.</dt>
<dd>Most programming languages (including Lisp, ML and imperative languages like C and <a href="Java_programming_language" title="wikilink">Java</a>) are described as "strict", meaning that functions applied to non-normalising arguments are non-normalising. This is done essentially using applicative order, call by value reduction (<a href="#Call_by_value" title="wikilink">see below</a>), but usually called "eager evaluation".
</dd>
<dt>Normal order: The leftmost, outermost redex is always reduced first. That is, whenever possible the arguments are substituted into the body of an abstraction before the arguments are reduced.<br/>
Call by name: As normal order, but no reductions are performed inside abstractions. For example <code>λ''x''.(λ''x''.''x'')''x''</code> is in normal form according to this strategy, although it contains the redex <code>(λ''x''.''x'')''x''</code>.<br/>
Call by value: Only the outermost redexes are reduced: a redex is reduced only when its right hand side has reduced to a value (variable or lambda abstraction).<br/>
Call by need: As normal order, but function applications that would duplicate terms instead name the argument, which is then reduced only "when it is needed". Called in practical contexts "lazy evaluation". In implementations this "name" takes the form of a pointer, with the redex represented by a <a href="thunk_(functional_programming)" title="wikilink">thunk</a>.</dt>
</dl>

<p>Applicative order is not a normalising strategy. The usual counterexample is as follows: define <code>'''Ω''' = ωω</code> where <code>'''ω''' = λ''x''.''xx''</code>. This entire expression contains only one redex, namely the whole expression; its reduct is again <code>'''Ω'''</code>. Since this is the only available reduction, <code>'''Ω'''</code> has no normal form (under any evaluation strategy). Using applicative order, the expression <code>'''KIΩ''' = (λ''x''.λ''y''.''x'') (λ''x''.''x'')'''Ω'''</code> is reduced by first reducing <code>'''Ω'''</code> to normal form (since it is the rightmost redex), but since <code>'''Ω'''</code> has no normal form, applicative order fails to find a normal form for <code>'''KIΩ'''</code>.</p>

<p>In contrast, normal order is so called because it always finds a normalising reduction, if one exists. In the above example, <code>'''KIΩ'''</code> reduces under normal order to <em>I</em>, a normal form. A drawback is that redexes in the arguments may be copied, resulting in duplicated computation (for example, <code>(λ''x''.''xx'') ((λ''x''.''x'')''y'')</code> reduces to <code>((λ''x''.''x'')''y'') ((λ''x''.''x'')''y'')</code> using this strategy; now there are two redexes, so full evaluation needs two more steps, but if the argument had been reduced first, there would now be none).</p>

<p>The positive tradeoff of using applicative order is that it does not cause unnecessary computation, if all arguments are used, because it never substitutes arguments containing redexes and hence never needs to copy them (which would duplicate work). In the above example, in applicative order <code>(λ''x''.''xx'') ((λ''x''.''x'')''y'')</code> reduces first to <code>(λ''x''.''xx'')''y''</code> and then to the normal order <code>''yy''</code>, taking two steps instead of three.</p>

<p>Most <em>purely</em> functional programming languages (notably <a href="Miranda_(programming_language)" title="wikilink">Miranda</a> and its descendents, including Haskell), and the proof languages of <a href="Automated_theorem_prover" title="wikilink">theorem provers</a>, use <em>lazy evaluation</em>, which is essentially the same as call by need. This is like normal order reduction, but call by need manages to avoid the duplication of work inherent in normal order reduction using <em>sharing</em>. In the example given above, <code>(λ''x''.''xx'') ((λ''x''.''x'')''y'')</code> reduces to <code>((λ''x''.''x'')''y'') ((λ''x''.''x'')''y'')</code>, which has two redexes, but in call by need they are represented using the same object rather than copied, so when one is reduced the other is too.</p>
<h3 id="a-note-about-complexity">A note about complexity</h3>

<p>While the idea of beta reduction seems simple enough, it is not an atomic step, in that it must have a non-trivial cost when estimating <a href="Computational_complexity_theory" title="wikilink">computational complexity</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> To be precise, one must somehow find the location of all of the occurrences of the bound variable <code>''V''</code> in the expression <code>''E''</code>, implying a time cost, or one must keep track of these locations in some way, implying a space cost. A naïve search for the locations of <code>''V''</code> in <code>''E''</code> is <a href="Big_O_notation" title="wikilink"><em>O</em>(<em>n</em>)</a> in the length <em>n</em> of <code>''E''</code>. This has led to the study of systems that use <a href="explicit_substitution" title="wikilink">explicit substitution</a>. Sinot's <a href="director_string" title="wikilink">director strings</a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> offer a way of tracking the locations of free variables in expressions.</p>
<h3 id="parallelism-and-concurrency">Parallelism and concurrency</h3>

<p>The <a href="Church–Rosser_theorem" title="wikilink">Church–Rosser</a> property of the lambda calculus means that evaluation (β-reduction) can be carried out in <em>any order</em>, even in parallel. This means that various <a href="evaluation_strategy#Nondeterministic_strategies" title="wikilink">nondeterministic evaluation strategies</a> are relevant. However, the lambda calculus does not offer any explicit constructs for <a href="parallel_computing" title="wikilink">parallelism</a>. One can add constructs such as <a href="Futures_and_promises" title="wikilink">Futures</a> to the lambda calculus. Other <a href="process_calculi" title="wikilink">process calculi</a> have been developed for describing communication and concurrency.</p>
<h2 id="semantics">Semantics</h2>

<p>The fact that lambda calculus terms act as functions on other lambda calculus terms, and even on themselves, led to questions about the semantics of the lambda calculus. Could a sensible meaning be assigned to lambda calculus terms? The natural semantics was to find a set <em>D</em> isomorphic to the function space <em>D</em> → <em>D</em>, of functions on itself. However, no nontrivial such <em>D</em> can exist, by <a class="uri" href="cardinality" title="wikilink">cardinality</a> constraints because the set of all functions from <em>D</em> to <em>D</em> has greater cardinality than <em>D</em>, unless <em>D</em> is a <a href="singleton_set" title="wikilink">singleton set</a>.</p>

<p>In the 1970s, <a href="Dana_Scott" title="wikilink">Dana Scott</a> showed that, if only <a href="Scott_continuity" title="wikilink">continuous functions</a> were considered, a set or <a href="Domain_theory" title="wikilink">domain</a> <em>D</em> with the required property could be found, thus providing a <a href="Model_theory" title="wikilink">model</a> for the lambda calculus.</p>

<p>This work also formed the basis for the <a href="denotational_semantics" title="wikilink">denotational semantics</a> of programming languages.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Applicative_computing_systems" title="wikilink">Applicative computing systems</a> – Treatment of <a href="object_(computer_science)" title="wikilink">objects</a> in the style of the lambda calculus</li>
<li><a href="Binary_lambda_calculus" title="wikilink">Binary lambda calculus</a> – A version of lambda calculus with binary I/O, a binary encoding of terms, and a designated universal machine.</li>
<li><a href="Calculus_of_constructions" title="wikilink">Calculus of constructions</a> – A typed lambda calculus with <a href="type_system" title="wikilink">types</a> as first-class values</li>
<li><a href="Cartesian_closed_category" title="wikilink">Cartesian closed category</a> – A setting for lambda calculus in <a href="category_theory" title="wikilink">category theory</a></li>
<li><a href="Categorical_abstract_machine" title="wikilink">Categorical abstract machine</a> – A <a href="model_of_computation" title="wikilink">model of computation</a> applicable to lambda calculus</li>
<li><a href="Combinatory_logic" title="wikilink">Combinatory logic</a> – A notation for mathematical logic without variables</li>
<li><a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a> – The formal correspondence between programs and <a href="mathematical_proof" title="wikilink">proofs</a></li>
<li><a href="Deductive_lambda_calculus" title="wikilink">Deductive lambda calculus</a> – The consideration of the problems associated with considering lambda calculus as a <a href="Deductive_system" title="wikilink">Deductive system</a>.</li>
<li><a href="Domain_theory" title="wikilink">Domain theory</a> – Study of certain <a href="partially_ordered_sets" title="wikilink">posets</a> giving <a href="denotational_semantics" title="wikilink">denotational semantics</a> for lambda calculus</li>
<li><a href="Evaluation_strategy" title="wikilink">Evaluation strategy</a> – Rules for the evaluation of expressions in <a href="programming_language" title="wikilink">programming languages</a></li>
<li><a href="Explicit_substitution" title="wikilink">Explicit substitution</a> – The theory of substitution, as used in <a href="#β-reduction" title="wikilink">β-reduction</a></li>
<li><a href="Harrop_formula" title="wikilink">Harrop formula</a> – A kind of constructive logical formula such that proofs are lambda terms</li>
<li><a href="Kappa_calculus" title="wikilink">Kappa calculus</a> – A first-order analogue of lambda calculus</li>
<li><a href="Kleene–Rosser_paradox" title="wikilink">Kleene–Rosser paradox</a> – A demonstration that some form of lambda calculus is inconsistent</li>
<li><a href="Knights_of_the_Lambda_Calculus" title="wikilink">Knights of the Lambda Calculus</a> – A semi-fictional organization of LISP and <a href="Scheme_(programming_language)" title="wikilink">Scheme</a> <a href="Hacker_(programmer_subculture)" title="wikilink">hackers</a></li>
<li><a href="Lambda_calculus_definition" title="wikilink">Lambda calculus definition</a> - Formal definition of the lambda calculus.</li>
<li><a href="Lambda_cube" title="wikilink">Lambda cube</a> – A framework for some extensions of typed lambda calculus</li>
<li><a href="Lambda-mu_calculus" title="wikilink">Lambda-mu calculus</a> – An extension of the lambda calculus for treating <a href="classical_logic" title="wikilink">classical logic</a></li>
<li><a href="Let_expression" title="wikilink">Let expression</a> – An expression close related to a lambda abstraction.</li>
<li><a href="Minimalism_(computing)" title="wikilink">Minimalism (computing)</a></li>
<li><a class="uri" href="Rewriting" title="wikilink">Rewriting</a> – Transformation of formulæ in formal systems</li>
<li><a href="SECD_machine" title="wikilink">SECD machine</a> – A <a href="virtual_machine" title="wikilink">virtual machine</a> designed for the lambda calculus</li>
<li>Simply typed lambda calculus - Version(s) with a single type constructor</li>
<li><a href="SKI_combinator_calculus" title="wikilink">SKI combinator calculus</a> – A computational system based on the <strong><a href="#S" title="wikilink">S</a></strong>, <strong><a href="#K" title="wikilink">K</a></strong> and <strong><a href="#I" title="wikilink">I</a></strong> combinators</li>
<li><a href="System_F" title="wikilink">System F</a> – A typed lambda calculus with type-variables</li>
<li><a href="Typed_lambda_calculus" title="wikilink">Typed lambda calculus</a> – Lambda calculus with typed variables (and functions)</li>
<li><a href="Universal_Turing_machine" title="wikilink">Universal Turing machine</a> – A formal computing machine that is equivalent to lambda calculus</li>
<li><a class="uri" href="Unlambda" title="wikilink">Unlambda</a> – An <a href="esoteric_programming_language" title="wikilink">esoteric</a> functional programming language based on combinatory logic</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Abelson, Harold &amp; Gerald Jay Sussman. <a href="Structure_and_Interpretation_of_Computer_Programs" title="wikilink">Structure and Interpretation of Computer Programs</a>. <a href="The_MIT_Press" title="wikilink">The MIT Press</a>. ISBN 0-262-51087-1.</li>
<li>Hendrik Pieter Barendregt <a href="ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf"><em>Introduction to Lambda Calculus</em></a>.</li>
<li>Henk Barendregt, <a href="http://enl.usc.edu/~jkna/fpl/church.pdf">The Impact of the Lambda Calculus in Logic and Computer Science</a>. The Bulletin of Symbolic Logic, Volume 3, Number 2, June 1997.</li>
<li><a href="Hendrik_Pieter_Barendregt" title="wikilink">Barendregt, Hendrik Pieter</a>, <em>The Type Free Lambda Calculus</em> pp1091–1132 of <em>Handbook of Mathematical Logic</em>, <a class="uri" href="North-Holland" title="wikilink">North-Holland</a> (1977) ISBN 0-7204-2285-X</li>
<li>Cardone and Hindley, 2006. <a href="http://www-maths.swan.ac.uk/staff/jrh/papers/JRHHislamWeb.pdf">History of Lambda-calculus and Combinatory Logic</a>. In Gabbay and Woods (eds.), <em>Handbook of the History of Logic</em>, vol. 5. Elsevier.</li>
<li>Church, Alonzo, <em>An unsolvable problem of elementary number theory</em>, <a href="American_Journal_of_Mathematics" title="wikilink">American Journal of Mathematics</a>, 58 (1936), pp. 345–363. This paper contains the proof that the equivalence of lambda expressions is in general not decidable.</li>
<li>Alonzo Church, <em>The Calculi of Lambda-Conversion</em> (ISBN 978-0-691-08394-0)<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></li>
<li>Kleene, Stephen, <em>A theory of positive integers in formal logic</em>, <a href="American_Journal_of_Mathematics" title="wikilink">American Journal of Mathematics</a>, 57 (1935), pp. 153–173 and 219–244. Contains the lambda calculus definitions of several familiar functions.</li>
<li><a href="Peter_Landin" title="wikilink">Landin, Peter</a>, <em>A Correspondence Between ALGOL 60 and Church's Lambda-Notation</em>, <a href="Communications_of_the_ACM" title="wikilink">Communications of the ACM</a>, vol. 8, no. 2 (1965), pages 89–101. Available from the [<a class="uri" href="http://portal.acm.org/citation.cfm?id=363749&amp;coll">http://portal.acm.org/citation.cfm?id=363749&amp;coll;</a>;=portal&amp;dl;=ACM ACM site]. A classic paper highlighting the importance of lambda calculus as a basis for programming languages.</li>
<li>Larson, Jim, <a href="http://www.jetcafe.org/~jim/lambda.html"><em>An Introduction to Lambda Calculus and Scheme</em></a>. A gentle introduction for programmers.</li>
<li>Schalk, A. and Simmons, H. (2005) ''<a href="http://www.cs.man.ac.uk/~hsimmons/BOOKS/lcalculus.pdf">An introduction to λ-calculi and arithmetic with a decent selection of exercises</a>. Notes for a course in the Mathematical Logic MSc at Manchester University.</li>
<li><a href="Ruy_de_Queiroz" title="wikilink">de Queiroz, Ruy J.G.B.</a> (2008) <a href="http://www.springerlink.com/content/27nk266126k817gq/"><em>On Reduction Rules, Meaning-as-Use and Proof-Theoretic Semantics</em></a>. <a href="Studia_Logica" title="wikilink">Studia Logica</a>, 90(2):211-247. A paper giving a formal underpinning to the idea of 'meaning-is-use' which, even if based on proofs, it is different from proof-theoretic semantics as in the Dummett–Prawitz tradition since it takes reduction as the rules giving meaning.</li>
</ul>

<p>Monographs/textbooks for graduate students:</p>
<ul>
<li>Morten Heine Sørensen, Paweł Urzyczyn, <em>Lectures on the Curry-Howard isomorphism</em>, Elsevier, 2006, ISBN 0-444-52077-5 is a recent monograph that covers the main topics of lambda calculus from the type-free variety, to most <a href="typed_lambda_calculi" title="wikilink">typed lambda calculi</a>, including more recent developments like <a href="pure_type_system" title="wikilink">pure type systems</a> and the <a href="lambda_cube" title="wikilink">lambda cube</a>. It does not cover <a class="uri" href="subtyping" title="wikilink">subtyping</a> extensions.</li>
<li>

<p>covers lambda calculi from a practical type system perspective; some topics like dependent types are only mentioned, but subtyping is an important topic.</p></li>
</ul>

<p><em>Some parts of this article are based on material from <a href="Free_On-line_Dictionary_of_Computing" title="wikilink">FOLDOC</a>, used with <a href="Wikipedia:Foldoc_license" title="wikilink">permission</a>.</em></p>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li>Achim Jung, <em><a href="http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf">A Short Introduction to the Lambda Calculus</a></em>-(<a href="Portable_Document_Format" title="wikilink">PDF</a>)</li>
<li>Dana Scott, <em><a href="http://turing100.acm.org/lambda_calculus_timeline.pdf">A timeline of lambda calculus</a></em>-(<a href="Portable_Document_Format" title="wikilink">PDF</a>)</li>
<li>David C. Keenan, <em><a href="http://dkeenan.com/Lambda/">To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction</a></em></li>
<li>Raúl Rojas, <em><a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">A Tutorial Introduction to the Lambda Calculus</a></em>-(<a href="Portable_Document_Format" title="wikilink">PDF</a>)</li>
<li>Peter Selinger, <em><a href="http://www.mscs.dal.ca/~selinger/papers/#lambdanotes">Lecture Notes on the Lambda Calculus</a></em>-(<a href="Portable_Document_Format" title="wikilink">PDF</a>)</li>
<li>L. Allison, <em><a href="http://www.allisons.org/ll/FP/Lambda/Examples/">Some executable λ-calculus examples</a></em></li>
<li>Georg P. Loczewski, <a href="http://www.lambda-bound.com/book/lambdacalc/lcalconl.html"><em>The Lambda Calculus and A++</em></a></li>
<li>Bret Victor, <em><a href="http://worrydream.com/AlligatorEggs/">Alligator Eggs: A Puzzle Game Based on Lambda Calculus</a></em></li>
<li><em><a href="http://www.safalra.com/science/lambda-calculus/">Lambda Calculus</a></em> on <a href="http://www.safalra.com/">Safalra’s Website</a></li>
<li><em></em></li>
<li><a href="http://lci.sourceforge.net/">LCI Lambda Interpreter</a> a simple yet powerful pure calculus interpreter</li>
<li><a href="http://lambda-the-ultimate.org/classic/lc.html">Lambda Calculus links on Lambda-the-Ultimate</a></li>
<li>Mike Thyer, <a href="http://thyer.name/lambda-animator/">Lambda Animator</a>, a graphical Java applet demonstrating alternative reduction strategies.</li>
<li><a href="http://www.jetcafe.org/~jim/lambda.html">An Introduction to Lambda Calculus and Scheme</a>, by Jim Larson</li>
<li><a href="http://matt.might.net/articles/c++-template-meta-programming-with-lambda-calculus/">Implementing the Lambda calculus</a> using <a href="C++_Templates" title="wikilink">C++ Templates</a></li>
<li>Marius Buliga, <a href="http://imar.ro/~mbuliga/graphic_revised.pdf"><em>Graphic lambda calculus</em></a></li>
<li><a href="http://cs.adelaide.edu.au/~pmk/publications/wage2008.pdf"><em>Lambda Calculus as a Workflow Model</em></a> by Peter Kelly, Paul Coddington, and Andrew Wendelborn; mentions <a href="graph_reduction" title="wikilink">graph reduction</a> as a common means of evaluating lambda expressions and discusses the applicability of lambda calculus for <a href="distributed_computing" title="wikilink">distributed computing</a> (due to the <a href="Church–Rosser_theorem" title="wikilink">Church–Rosser</a> property, which enables <a href="parallel_computing" title="wikilink">parallel</a> graph reduction for lambda expressions).</li>
<li>Shane Steinert-Threlkeld, <a href="http://www.iep.utm.edu/lambda-calculi/">"Lambda Calculi"</a>, <em><a href="Internet_Encyclopedia_of_Philosophy" title="wikilink">Internet Encyclopedia of Philosophy</a></em></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:1936_in_computer_science" title="wikilink">Category:1936 in computer science</a> <a href="Category:American_inventions" title="wikilink">Category:American inventions</a> <a href="Category:Articles_with_example_code" title="wikilink">Category:Articles with example code</a> <a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Formal_methods" title="wikilink">Category:Formal methods</a> <a href="Category:Lambda_calculus" title="wikilink"> </a> <a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">Coquand, Thierry, <a href="http://plato.stanford.edu/archives/sum2013/entries/type-theory/">"Type Theory"</a>, <em>The Stanford Encyclopedia of Philosophy</em> (Summer 2013 Edition), Edward N. Zalta (ed.).<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">A. Church, "A set of postulates for the foundation of logic", <em>Annals of Mathematics</em>, Series 2, 33:346–366 (1932).<a href="#fnref6">↩</a></li>
<li id="fn7">For a full history, see Cardone and Hindley's "History of Lambda-calculus and Combinatory Logic" (2006).<a href="#fnref7">↩</a></li>
<li id="fn8">A. Church, "An unsolvable problem of elementary number theory", <em>American Journal of Mathematics</em>, Volume 58, No. 2. (April 1936), pp. 345-363.<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="Ruy_de_Queiroz" title="wikilink">de Queiroz, Ruy J.G.B.</a> "<a href="http://dx.doi.org/10.1111/j.1746-8361.1988.tb00919.x">A Proof-Theoretic Account of Programming and the Role of Reduction Rules.</a>" <em>Dialectica</em> <strong>42</strong>(4), pages 265-282, 1988.<a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">R. Statman, "<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4567929">The typed λ-calculus is not elementary recursive.</a>" <em>Theoretical Computer Science</em>, (1979) <strong>9</strong> pp73-81.<a href="#fnref17">↩</a></li>
<li id="fn18">F.-R. Sinot. "<a href="http://www.lsv.ens-cachan.fr/~sinot/publis.php?onlykey=sinot-jlc05">Director Strings Revisited: A Generic Approach to the Efficient Representation of Free Variables in Higher-order Rewriting.</a>" <em>Journal of Logic and Computation</em> <strong>15</strong>(2), pages 201-218, 2005.<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
</ol>
</section>
</hr></body>
</html>
