<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1724">Heuristic function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Heuristic function</h1>
<hr/>

<p>A <strong>heuristic function</strong>, or simply a <strong>heuristic</strong>, is a <a href="Function_(mathematics)" title="wikilink">function</a> that ranks alternatives in <a href="search_algorithm" title="wikilink">search algorithms</a> at each branching step based on available information to decide which branch to follow.</p>
<h2 id="shortest-paths">Shortest paths</h2>

<p>For example, for <a href="shortest_path_problem" title="wikilink">shortest path problems</a>, a <em>heuristic</em> is a <a href="function_(mathematics)" title="wikilink">function</a>, 

<math display="inline" id="Heuristic_function:0">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)
  </annotation>
 </semantics>
</math>

 defined on the nodes of a <a href="search_tree" title="wikilink">search tree</a>, which serves as an estimate of the cost of the cheapest path from that node to the <a href="Objective_(goal)" title="wikilink">goal</a> node. Heuristics are used by <a href="search_algorithm" title="wikilink">informed search algorithms</a> such as <a href="Best-first_search" title="wikilink">Greedy best-first search</a> and <a href="A*_search_algorithm" title="wikilink">A*</a> to choose the best node to explore. Greedy best-first search will choose the node that has the lowest value for the heuristic function. A* search will expand nodes that have the lowest value for 

<math display="inline" id="Heuristic_function:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(n)+h(n)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Heuristic_function:2">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(n)
  </annotation>
 </semantics>
</math>

 is the (exact) cost of the path from the initial state to the current node. If 

<math display="inline" id="Heuristic_function:3">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)
  </annotation>
 </semantics>
</math>

 is <a href="Admissible_heuristic" title="wikilink"><em>admissible</em></a>, i.e., if 

<math display="inline" id="Heuristic_function:4">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)
  </annotation>
 </semantics>
</math>

 never overestimates the costs of reaching the goal, then A* will always find an <a href="Optimization_(mathematics)" title="wikilink">optimal</a> solution.</p>

<p>The classical problem involving heuristics is the <a href="15_puzzle" title="wikilink">n-puzzle</a>. Commonly used heuristics for this problem include counting the number of misplaced tiles and finding the sum of the <a href="Taxicab_geometry" title="wikilink">Manhattan distances</a> between each block and its position in the goal configuration. Note that both are admissible.</p>
<h3 id="effect-of-heuristics-on-computational-performance">Effect of heuristics on computational performance</h3>

<p>In any searching problem where there are 

<math display="inline" id="Heuristic_function:5">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 choices at each node and a depth of 

<math display="inline" id="Heuristic_function:6">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 at the goal node, a naive searching algorithm would have to potentially search around 

<math display="inline" id="Heuristic_function:7">
 <semantics>
  <msup>
   <mi>b</mi>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>b</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{d}
  </annotation>
 </semantics>
</math>

 nodes before finding a solution. Heuristics improve the efficiency of search algorithms by reducing the <a href="branching_factor" title="wikilink">branching factor</a> from 

<math display="inline" id="Heuristic_function:8">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 to a lower constant 

<math display="inline" id="Heuristic_function:9">
 <semantics>
  <msup>
   <mi>b</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>b</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{\prime}
  </annotation>
 </semantics>
</math>

, using a cutoff mechanism. The branching factor can be used for defining a <a href="partially_ordered_set" title="wikilink">partial order</a> on the heuristics, such that 

<math display="inline" id="Heuristic_function:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}(n)<h_{2}(n)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Heuristic_function:11">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}(n)
  </annotation>
 </semantics>
</math>

 has a lower branch factor than 

<math display="inline" id="Heuristic_function:12">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}(n)
  </annotation>
 </semantics>
</math>

 for a given node 

<math display="inline" id="Heuristic_function:13">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 of the search tree. Heuristics giving lower branching factors at every node in the search tree are preferred for the resolution of a particular problem, as they are more computationally efficient.</p>

<p>There is a useful and usually considered partial order on admissible heuristics where 

<math display="inline" id="Heuristic_function:14">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>h</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}\leq h_{2}
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Heuristic_function:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msup>
     <mi>h</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)\leq h^{\prime}(n)
  </annotation>
 </semantics>
</math>

 for every state n. Thus the true cost is greatest element, and the zero heuristic is the least element in this partial order. If 

<math display="inline" id="Heuristic_function:16">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>h</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}\leq h_{2}
  </annotation>
 </semantics>
</math>

, then the A* search using 

<math display="inline" id="Heuristic_function:17">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

 will have better performance than using 

<math display="inline" id="Heuristic_function:18">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="finding-heuristics">Finding heuristics</h3>

<p>The problem of finding an admissible heuristic with a low branching factor for common search tasks has been extensively researched in the <a href="artificial_intelligence" title="wikilink">artificial intelligence</a> community. Several common techniques are used:</p>
<ul>
<li>Solution costs of <strong>sub-problems</strong> often serve as useful estimates of the overall solution cost. These are always admissible. For example, a heuristic for a 10-puzzle might be the cost of moving tiles 1-5 into their correct places. A common idea is to use a pattern database that stores the exact solution cost of every subproblem instance.</li>
</ul>
<ul>
<li>The solution of a <strong>relaxed problem</strong> often serves as a useful admissible estimate of the original. For example, Manhattan distance is a relaxed version of the n-puzzle problem, because we assume we can move each tile to its position independently of moving the other tiles.</li>
</ul>
<ul>
<li>Given a set of admissible heuristic functions 

<math display="inline" id="Heuristic_function:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}(n),h_{2}(n),...,h_{i}(n)
  </annotation>
 </semantics>
</math>

, the function 

<math display="inline" id="Heuristic_function:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <max></max>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>i</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)=\max\{h_{1}(n),h_{2}(n),...,h_{i}(n)\}
  </annotation>
 </semantics>
</math>

 is an admissible heuristic that dominates all of them.</li>
</ul>

<p>Using these techniques a program called ABSOLVER was written (1993) by A.E. Prieditis for automatically generating heuristics for a given problem<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>". ABSOLVER generated a new heuristic for the <a href="15_puzzle" title="wikilink">8-puzzle</a> better than any pre-existing heuristic and found the first useful heuristic for solving the <a href="Rubik's_Cube" title="wikilink">Rubik's Cube</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="consistency-and-admissibility">Consistency and Admissibility</h3>

<p>If a Heuristic function never overestimates the cost reaching to goal, then it is called an Admissible heuristic function.</p>

<p>A heuristic 

<math display="inline" id="Heuristic_function:21">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)
  </annotation>
 </semantics>
</math>

 is consistent if 

<math display="inline" id="Heuristic_function:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <msup>
      <mi>n</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)-h(n^{\prime})\leq c(n,n^{\prime})
  </annotation>
 </semantics>
</math>

 for any successor state 

<math display="inline" id="Heuristic_function:23">
 <semantics>
  <msup>
   <mi>n</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{\prime}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Heuristic_function:24">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <msup>
     <mi>n</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(n,n^{\prime})
  </annotation>
 </semantics>
</math>

 is the actual cost of going from 

<math display="inline" id="Heuristic_function:25">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Heuristic_function:26">
 <semantics>
  <msup>
   <mi>n</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{\prime}
  </annotation>
 </semantics>
</math>

. Thus the value of the sum "total cost so far + heuristic estimate of the cost left" (which is the one used in A* search) is non-decreasing along any path.</p>

<p>Any consistent heuristic with 

<math display="inline" id="Heuristic_function:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mi>o</mi>
      <mi>a</mi>
      <mi>l</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>o</ci>
      <ci>a</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(goal)=0
  </annotation>
 </semantics>
</math>

 is admissible, and any heuristic obtained by solving a relaxed problem is consistent (as 

<math display="inline" id="Heuristic_function:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>relaxed</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <msup>
      <mi>n</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <msup>
      <mi>n</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>relaxed</ci>
      </apply>
      <interval closure="open">
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)-h(n^{\prime})\leq c_{\mathrm{relaxed}}(n,n^{\prime})\leq c(n,n^{\prime})
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="example">Example</h3>
<figure><b>(Figure)</b>
<figcaption>8puzzle example</figcaption>
</figure>

<p>One might be interested in finding a heuristic to estimate the number of steps required to solve an <a href="15_puzzle" title="wikilink">8-puzzle</a> from a given state. Two simple heuristic functions are:</p>

<p>

<math display="inline" id="Heuristic_function:29">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

 = the number of misplaced tiles. This is also known as the <a href="Hamming_distance" title="wikilink">Hamming Distance</a>. In the pictured example, the start state has 

<math display="inline" id="Heuristic_function:30">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

 = 8. Clearly, 

<math display="inline" id="Heuristic_function:31">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

 is an admissible heuristic because any tile that is out of place will have to be moved at least once.</p>

<p>

<math display="inline" id="Heuristic_function:32">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

 = the sum of the distances of the tiles from their goal positions. Because tiles cannot be moved diagonally, the distance counted is the sum of horizontal and vertical distances. This is also known as the <a href="Taxicab_geometry" title="wikilink">Manhattan Distance</a>. In the pictured example, the start state has 

<math display="inline" id="Heuristic_function:33">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

 = 3 + 1 + 2 + 2 + 2 + 3 + 3 + 2 = 18. Clearly, 

<math display="inline" id="Heuristic_function:34">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

 is also an admissible heuristic because any move can, at best, move one tile one step closer to the goal.</p>

<p>As expected, neither heuristic overestimates the true number of moves required to solve the puzzle, which is 26 (

<math display="inline" id="Heuristic_function:35">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

+

<math display="inline" id="Heuristic_function:36">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

). Additionally, it is easy to see from the definitions of the heuristic functions that for any given state, 

<math display="inline" id="Heuristic_function:37">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

 will always be greater than or equal to 

<math display="inline" id="Heuristic_function:38">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

. Thus, we can say that 

<math display="inline" id="Heuristic_function:39">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

 dominates 

<math display="inline" id="Heuristic_function:40">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

.</p>

<p>(example taken from Russell and Norvig)</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Heuristic_(computer_science)" title="wikilink">Heuristic algorithm</a></li>
<li><a href="Artificial_intelligence" title="wikilink">Artificial intelligence</a></li>
<li><a href="Consistent_heuristic" title="wikilink">Consistent heuristic</a></li>
<li><a href="Expert_system" title="wikilink">Expert system</a></li>
<li><a href="Heuristic_evaluation" title="wikilink">Heuristic evaluation</a></li>
<li><a href="Inference_engine" title="wikilink">Inference engine</a></li>
<li><a class="uri" href="Inquiry" title="wikilink">Inquiry</a></li>
<li><a href="Problem_solving" title="wikilink">Problem solving</a></li>
<li><a href="Admissible_heuristic" title="wikilink">Admissible heuristic</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>

<p>—Chapter 4</p></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Heuristics" title="wikilink">Category:Heuristics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
</ol>
</section>
</body>
</html>
