<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="140">Linear multistep method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Linear multistep method</h1>
<hr/>

<p><strong>Linear multistep methods</strong> are used for the <a href="numerical_ordinary_differential_equations" title="wikilink">numerical solution of ordinary differential equations</a>. Conceptually, a numerical method starts from an initial point and then takes a short <strong>step</strong> forward in time to find the next solution point. The process continues with subsequent steps to map out the solution. Single-step methods (such as <a href="Euler's_method" title="wikilink">Euler's method</a>) refer to only one previous point and its derivative to determine the current value. Methods such as <a href="Runge–Kutta_methods" title="wikilink">Runge–Kutta</a> take some intermediate steps (for example, a half-step) to obtain a higher order method, but then discard all previous information before taking a second step. Multistep methods attempt to gain efficiency by keeping and using the information from previous steps rather than discarding it. Consequently, multistep methods refer to several previous points and derivative values. In the case of <em>linear</em> multistep methods, a <a href="linear_combination" title="wikilink">linear combination</a> of the previous points and derivative values is used.</p>
<h2 id="definitions">Definitions</h2>

<p>Numerical methods for ordinary differential equations approximate solutions to <a href="initial_value_problem" title="wikilink">initial value problems</a> of the form</p>

<p>

<math display="block" id="Linear_multistep_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=f(t,y),\quad y(t_{0})=y_{0}.
  </annotation>
 </semantics>
</math>

</p>

<p>The result is approximations for the value of 

<math display="inline" id="Linear_multistep_method:1">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)
  </annotation>
 </semantics>
</math>

 at discrete times 

<math display="inline" id="Linear_multistep_method:2">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{i}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Linear_multistep_method:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo>≈</mo>
     <mrow>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mtext>where</mtext>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo>+</mo>
      <mrow>
       <mi>i</mi>
       <mi>h</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <approx></approx>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <list>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <mtext>where</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\approx y(t_{i})\quad\text{where}\quad t_{i}=t_{0}+ih,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Linear_multistep_method:4">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is the time step (sometimes referred to as 

<math display="inline" id="Linear_multistep_method:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

) and 

<math display="inline" id="Linear_multistep_method:6">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is an integer.</p>

<p>Multistep methods use information from the previous 

<math display="inline" id="Linear_multistep_method:7">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 steps to calculate the next value. In particular, a <em>linear</em> multistep method uses a linear combination of 

<math display="inline" id="Linear_multistep_method:8">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Linear_multistep_method:9">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t_{i},y_{i})
  </annotation>
 </semantics>
</math>

 to calculate the value of 

<math display="inline" id="Linear_multistep_method:10">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 for the desired current step. Thus, a linear multistep method is a method of the form</p>

<p>

<math display="inline" id="Linear_multistep_method:11">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>s</mi>
    </mrow>
   </msub>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>s</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>y</mi>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mi>s</mi>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>s</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>y</mi>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mi>s</mi>
      </mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y_{n+s}+a_{s-1}\cdot y_{n+s-1}+a_{s-2}\cdot y_{n+s-2}+\cdots+a_{%
0}\cdot y_{n}
  </annotation>
 </semantics>
</math>


 The coefficients 

<math display="inline" id="Linear_multistep_method:12">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0},\ldots,a_{s-1}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Linear_multistep_method:13">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>b</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{0},\ldots,b_{s}
  </annotation>
 </semantics>
</math>

 determine the method. The designer of the method chooses the coefficients, balancing the need to get a good approximation to the true solution against the desire to get a method that is easy to apply. Often, many coefficients are zero to simplify the method.</p>

<p>One can distinguish between <a href="explicit_and_implicit_methods" title="wikilink">explicit and implicit methods</a>. If 

<math display="inline" id="Linear_multistep_method:14">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>s</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{s}=0
  </annotation>
 </semantics>
</math>

, then the method is called "explicit", since the formula can directly compute 

<math display="inline" id="Linear_multistep_method:15">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+s}
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Linear_multistep_method:16">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>s</mi>
   </msub>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>s</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{s}\neq 0
  </annotation>
 </semantics>
</math>

 then the method is called "implicit", since the value of 

<math display="inline" id="Linear_multistep_method:17">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+s}
  </annotation>
 </semantics>
</math>


 depends on the value of 

<math display="inline" id="Linear_multistep_method:18">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>s</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>s</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t_{n+s},y_{n+s})
  </annotation>
 </semantics>
</math>

, and the equation must be solved for 

<math display="inline" id="Linear_multistep_method:19">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+s}
  </annotation>
 </semantics>
</math>

. <a href="Iterative_methods" title="wikilink">Iterative methods</a> such as <a href="Newton's_method" title="wikilink">Newton's method</a> are often used to solve the implicit formula.</p>

<p>Sometimes an explicit multistep method is used to "predict" the value of 

<math display="inline" id="Linear_multistep_method:20">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+s}
  </annotation>
 </semantics>
</math>

. That value is then used in an implicit formula to "correct" the value. The result is a <a href="predictor–corrector_method" title="wikilink">predictor–corrector method</a>.</p>
<h2 id="examples">Examples</h2>

<p>Consider for an example the problem</p>

<p>

<math display="block" id="Linear_multistep_method:21">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>y</mi>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>t</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=f(t,y)=y,\quad y(0)=1.
  </annotation>
 </semantics>
</math>

 The exact solution is 

<math display="inline" id="Linear_multistep_method:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi mathvariant="normal">e</mi>
    <mi>t</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-e</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=\mathrm{e}^{t}
  </annotation>
 </semantics>
</math>


.</p>
<h3 id="one-step-euler">One-step Euler</h3>

<p>A simple numerical method is Euler's method:</p>

<p>

<math display="block" id="Linear_multistep_method:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mi>n</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=y_{n}+hf(t_{n},y_{n}).\,
  </annotation>
 </semantics>
</math>

 Euler's method can be viewed as an explicit multistep method for the degenerate case of one step.</p>

<p>This method, applied with step size 

<math display="inline" id="Linear_multistep_method:24">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=\tfrac{1}{2}
  </annotation>
 </semantics>
</math>

 on the problem 

<math display="inline" id="Linear_multistep_method:25">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=y
  </annotation>
 </semantics>
</math>

, gives the following results:</p>

<p>

<math display="inline" id="Linear_multistep_method:26">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y_{1}
  </annotation>
 </semantics>
</math>


</p>
<h3 id="two-step-adamsbashforth">Two-step Adams–Bashforth</h3>

<p>Euler's method is a one-step method. A simple multistep method is the two-step Adams–Bashforth method</p>

<p>

<math display="block" id="Linear_multistep_method:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>y</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>+</mo>
      <mrow>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>3</mn>
         <mn>2</mn>
        </mfrac>
       </mstyle>
       <mi>h</mi>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>y</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
      </mstyle>
      <mi>h</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mi>n</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>h</ci>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>h</ci>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+2}=y_{n+1}+\tfrac{3}{2}hf(t_{n+1},y_{n+1})-\tfrac{1}{2}hf(t_{n},y_{n}).
  </annotation>
 </semantics>
</math>

 This method needs two values, 

<math display="inline" id="Linear_multistep_method:28">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Linear_multistep_method:29">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}
  </annotation>
 </semantics>
</math>

, to compute the next value, 

<math display="inline" id="Linear_multistep_method:30">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+2}
  </annotation>
 </semantics>
</math>

. However, the initial value problem provides only one value, 

<math display="inline" id="Linear_multistep_method:31">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0}=1
  </annotation>
 </semantics>
</math>


. One possibility to resolve this issue is to use the 

<math display="inline" id="Linear_multistep_method:32">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}
  </annotation>
 </semantics>
</math>

 computed by Euler's method as the second value. With this choice, the Adams–Bashforth method yields (rounded to four digits):</p>

<p>

<math display="inline" id="Linear_multistep_method:33">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y_{2}
  </annotation>
 </semantics>
</math>


 The exact solution at 

<math display="inline" id="Linear_multistep_method:34">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=t_{4}=2
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Linear_multistep_method:35">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">e</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mn>7.3891</mn>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-e</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <cn type="float">7.3891</cn>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{e}^{2}=7.3891\ldots
  </annotation>
 </semantics>
</math>

, so the two-step Adams–Bashforth method is more accurate than Euler's method. This is always the case if the step size is small enough.</p>
<h2 id="families-of-multistep-methods">Families of multistep methods</h2>

<p>Three families of linear multistep methods are commonly used: Adams–Bashforth methods, Adams–Moulton methods, and the <a href="backward_differentiation_formula" title="wikilink">backward differentiation formulas</a> (BDFs).</p>
<h3 id="adamsbashforth-methods">Adams–Bashforth methods</h3>

<p>The Adams–Bashforth methods are explicit methods. The coefficients are 

<math display="inline" id="Linear_multistep_method:36">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{s-1}=-1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Linear_multistep_method:37">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{s-2}=\cdots=a_{0}=0
  </annotation>
 </semantics>
</math>

, while the 

<math display="inline" id="Linear_multistep_method:38">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{j}
  </annotation>
 </semantics>
</math>

 are chosen such that the methods has order <em>s</em> (this determines the methods uniquely).</p>

<p>The Adams–Bashforth methods with <em>s</em> = 1, 2, 3, 4, 5 are (; ):</p>

<p>

<math display="inline" id="Linear_multistep_method:39">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y_{n+1}
  </annotation>
 </semantics>
</math>


</p>

<p>The coefficients 

<math display="inline" id="Linear_multistep_method:40">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{j}
  </annotation>
 </semantics>
</math>

 can be determined as follows. Use <a href="polynomial_interpolation" title="wikilink">polynomial interpolation</a> to find the polynomial <em>p</em> of degree 

<math display="inline" id="Linear_multistep_method:41">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s-1
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Linear_multistep_method:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mi>i</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mi>i</mi>
       </mrow>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mi>i</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mtext>for</mtext>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>s</mi>
      <mo>-</mo>
      <mn>1.</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <ci>i</ci>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="float">1.</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(t_{n+i})=f(t_{n+i},y_{n+i}),\qquad\text{for }i=0,\ldots,s-1.
  </annotation>
 </semantics>
</math>

 The <a href="Lagrange_polynomial" title="wikilink">Lagrange formula</a> for polynomial interpolation yields</p>

<p>

<math display="block" id="Linear_multistep_method:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>s</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mfrac>
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mi>s</mi>
          <mo>-</mo>
          <mi>j</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mi>j</mi>
          </mrow>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>y</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mi>j</mi>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mrow>
         <mi>j</mi>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>s</mi>
           <mo>-</mo>
           <mi>j</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
        <msup>
         <mi>h</mi>
         <mrow>
          <mi>s</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
      </mfrac>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
        <mstyle scriptlevel="+1">
         <mtable columnspacing="0.4em" rowspacing="0.2ex">
          <mtr>
           <mtd>
            <mrow>
             <mi>i</mi>
             <mo>=</mo>
             <mn>0</mn>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd>
            <mrow>
             <mi>i</mi>
             <mo>≠</mo>
             <mi>j</mi>
            </mrow>
           </mtd>
          </mtr>
         </mtable>
        </mstyle>
        <mrow>
         <mi>s</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <msub>
          <mi>t</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mi>i</mi>
          </mrow>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>s</ci>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>f</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <factorial></factorial>
         <ci>j</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <apply>
          <minus></minus>
          <ci>s</ci>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>h</ci>
         <apply>
          <minus></minus>
          <ci>s</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <ci>STACKED</ci>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">0</cn>
          </apply>
          <apply>
           <neq></neq>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>s</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(t)=\sum_{j=0}^{s-1}\frac{(-1)^{s-j-1}f(t_{n+j},y_{n+j})}{j!(s-j-1)!h^{s-1}}%
\prod_{i=0\atop i\neq j}^{s-1}(t-t_{n+i}).
  </annotation>
 </semantics>
</math>

 The polynomial <em>p</em> is locally a good approximation of the right-hand side of the differential equation 

<math display="inline" id="Linear_multistep_method:44">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=f(t,y)
  </annotation>
 </semantics>
</math>


 that is to be solved, so consider the equation 

<math display="inline" id="Linear_multistep_method:45">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=p(t)
  </annotation>
 </semantics>
</math>

 instead. This equation can be solved exactly; the solution is simply the integral of <em>p</em>. This suggests taking</p>

<p>

<math display="block" id="Linear_multistep_method:46">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>s</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mi>s</mi>
       </mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>+</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <msub>
        <mi>t</mi>
        <mrow>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mi>s</mi>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <msub>
        <mi>t</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mi>s</mi>
        </mrow>
       </msub>
      </msubsup>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <apply>
          <minus></minus>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <ci>s</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>t</ci>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+s}=y_{n+s-1}+\int_{t_{n+s-1}}^{t_{n+s}}p(t)\,dt.
  </annotation>
 </semantics>
</math>

 The Adams–Bashforth method arises when the formula for <em>p</em> is substituted. The coefficients 

<math display="inline" id="Linear_multistep_method:47">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{j}
  </annotation>
 </semantics>
</math>

 turn out to be given by</p>

<p>

<math display="block" id="Linear_multistep_method:48">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>b</mi>
     <mrow>
      <mi>s</mi>
      <mo>-</mo>
      <mi>j</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>j</mi>
      </msup>
      <mrow>
       <mrow>
        <mi>j</mi>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>s</mi>
          <mo>-</mo>
          <mi>j</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mn>1</mn>
      </msubsup>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
        <mstyle scriptlevel="+1">
         <mtable columnspacing="0.4em" rowspacing="0.2ex">
          <mtr>
           <mtd>
            <mrow>
             <mi>i</mi>
             <mo>=</mo>
             <mn>0</mn>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd>
            <mrow>
             <mi>i</mi>
             <mo>≠</mo>
             <mi>j</mi>
            </mrow>
           </mtd>
          </mtr>
         </mtable>
        </mstyle>
        <mrow>
         <mi>s</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>u</mi>
          <mo>+</mo>
          <mi>i</mi>
         </mrow>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <mi>u</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mtext>for</mtext>
     <mi>j</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>s</mi>
      <mo>-</mo>
      <mn>1.</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <factorial></factorial>
         <ci>j</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <apply>
          <minus></minus>
          <ci>s</ci>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <ci>STACKED</ci>
           <apply>
            <eq></eq>
            <ci>i</ci>
            <cn type="integer">0</cn>
           </apply>
           <apply>
            <neq></neq>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>s</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <plus></plus>
          <ci>u</ci>
          <ci>i</ci>
         </apply>
         <ci>d</ci>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <ci>j</ci>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="float">1.</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{s-j-1}=\frac{(-1)^{j}}{j!(s-j-1)!}\int_{0}^{1}\prod_{i=0\atop i\neq j}^{s-1%
}(u+i)\,du,\qquad\text{for }j=0,\ldots,s-1.
  </annotation>
 </semantics>
</math>

 Replacing 

<math display="inline" id="Linear_multistep_method:49">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>t</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t,y)
  </annotation>
 </semantics>
</math>


 by its interpolant <em>p</em> incurs an error of order <em>h</em><sup><em>s</em></sup>, and it follows that the <em>s</em>-step Adams–Bashforth method has indeed order <em>s</em> </p>

<p>The Adams–Bashforth methods were designed by <a href="John_Couch_Adams" title="wikilink">John Couch Adams</a> to solve a differential equation modelling <a href="capillary_action" title="wikilink">capillary action</a> due to <a href="Francis_Bashforth" title="wikilink">Francis Bashforth</a>.  published his theory and Adams' numerical method .</p>
<h3 id="adamsmoulton-methods">Adams–Moulton methods</h3>

<p>The Adams–Moulton methods are similar to the Adams–Bashforth methods in that they also have 

<math display="inline" id="Linear_multistep_method:50">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{s-1}=-1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Linear_multistep_method:51">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{s-2}=\cdots=a_{0}=0
  </annotation>
 </semantics>
</math>

. Again the <em>b</em> coefficients are chosen to obtain the highest order possible. However, the Adams–Moulton methods are implicit methods. By removing the restriction that 

<math display="inline" id="Linear_multistep_method:52">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>s</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{s}=0
  </annotation>
 </semantics>
</math>

, an <em>s</em>-step Adams–Moulton method can reach order 

<math display="inline" id="Linear_multistep_method:53">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s+1
  </annotation>
 </semantics>
</math>

, while an <em>s</em>-step Adams–Bashforth methods has only order <em>s</em>.</p>

<p>The Adams–Moulton methods with <em>s</em> = 0, 1, 2, 3, 4 are (; ):</p>

<p>

<math display="inline" id="Linear_multistep_method:54">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y_{n}
  </annotation>
 </semantics>
</math>


</p>

<p>The derivation of the Adams–Moulton methods is similar to that of the Adams–Bashforth method; however, the interpolating polynomial uses not only the points 

<math display="inline" id="Linear_multistep_method:55">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>s</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n-1},\dots,t_{n-s}
  </annotation>
 </semantics>
</math>

, as above, but also 

<math display="inline" id="Linear_multistep_method:56">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n}
  </annotation>
 </semantics>
</math>

. The coefficients are given by</p>

<p>

<math display="block" id="Linear_multistep_method:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>s</mi>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo>=</mo>
     <mrow>
      <mfrac>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>j</mi>
       </msup>
       <mrow>
        <mrow>
         <mi>j</mi>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>s</mi>
           <mo>-</mo>
           <mi>j</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∫</mo>
        <mn>0</mn>
        <mn>1</mn>
       </msubsup>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
         <mstyle scriptlevel="+1">
          <mtable columnspacing="0.4em" rowspacing="0.2ex">
           <mtr>
            <mtd>
             <mrow>
              <mi>i</mi>
              <mo>=</mo>
              <mn>0</mn>
             </mrow>
            </mtd>
           </mtr>
           <mtr>
            <mtd>
             <mrow>
              <mi>i</mi>
              <mo>≠</mo>
              <mi>j</mi>
             </mrow>
            </mtd>
           </mtr>
          </mtable>
         </mstyle>
         <mi>s</mi>
        </munderover>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mi>u</mi>
            <mo>+</mo>
            <mi>i</mi>
           </mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo rspace="4.2pt" stretchy="false">)</mo>
         </mrow>
         <mi>d</mi>
         <mi>u</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mrow>
      <mtext>for</mtext>
      <mi>j</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mn>0</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>s</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <factorial></factorial>
         <ci>j</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <apply>
          <minus></minus>
          <ci>s</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <ci>STACKED</ci>
           <apply>
            <eq></eq>
            <ci>i</ci>
            <cn type="integer">0</cn>
           </apply>
           <apply>
            <neq></neq>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
         </apply>
         <ci>s</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <minus></minus>
          <apply>
           <plus></plus>
           <ci>u</ci>
           <ci>i</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <ci>d</ci>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <ci>j</ci>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <ci>s</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{s-j}=\frac{(-1)^{j}}{j!(s-j)!}\int_{0}^{1}\prod_{i=0\atop i\neq j}^{s}(u+i-%
1)\,du,\qquad\text{for }j=0,\ldots,s.
  </annotation>
 </semantics>
</math>

</p>

<p>The Adams–Moulton methods are solely due to <a href="John_Couch_Adams" title="wikilink">John Couch Adams</a>, like the Adams–Bashforth methods. The name of <a href="Forest_Ray_Moulton" title="wikilink">Forest Ray Moulton</a> became associated with these methods because he realized that they could be used in tandem with the Adams–Bashforth methods as a <a href="Predictor-corrector_method" title="wikilink">predictor-corrector</a> pair ;  had the same idea. Adams used <a href="Newton's_method" title="wikilink">Newton's method</a> to solve the implicit equation .</p>
<h3 id="backward-differentiation-formulas-bdf">Backward differentiation formulas (BDF)</h3>
<dl>
<dd>
</dd>
</dl>

<p>The BDF methods are implicit methods with 

<math display="inline" id="Linear_multistep_method:58">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>=</mo>
   <msub>
    <mi>b</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{s-1}=\cdots=b_{0}=0
  </annotation>
 </semantics>
</math>

 and the other coefficients chosen such that the method attains order <em>s</em> (the maximum possible). These methods are especially used for the solution of <a href="stiff_equation" title="wikilink">stiff differential equations</a>.</p>
<h2 id="analysis">Analysis</h2>

<p>The central concepts in the analysis of linear multistep methods, and indeed any numerical method for differential equations, are <a href="Numerical_ordinary_differential_equations#Analysis" title="wikilink">convergence, order, and stability</a>.</p>
<h3 id="consistency-and-order">Consistency and order</h3>

<p>The first question is whether the method is consistent: is the difference equation</p>

<p>

<math display="inline" id="Linear_multistep_method:59">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>s</mi>
    </mrow>
   </msub>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>s</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <msub>
     <mi>y</mi>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mi>s</mi>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>s</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <msub>
     <mi>y</mi>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mi>s</mi>
      </mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y_{n+s}+a_{s-1}y_{n+s-1}+a_{s-2}y_{n+s-2}+\cdots+a_{0}y_{n}
  </annotation>
 </semantics>
</math>


 a good approximation of the differential equation 

<math display="inline" id="Linear_multistep_method:60">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=f(t,y)
  </annotation>
 </semantics>
</math>

? More precisely, a multistep method is <em>consistent</em> if the <a href="local_truncation_error" title="wikilink">local truncation error</a> goes to zero faster than the step size <em>h</em> as <em>h</em> goes to zero, where the <em>local truncation error</em> is defined to be the difference between the result 

<math display="inline" id="Linear_multistep_method:61">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+s}
  </annotation>
 </semantics>
</math>

 of the method, assuming that all the previous values 

<math display="inline" id="Linear_multistep_method:62">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>s</mi>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+s-1},\ldots,y_{n}
  </annotation>
 </semantics>
</math>

 are exact, and the exact solution of the equation at time 

<math display="inline" id="Linear_multistep_method:63">
 <semantics>
  <msub>
   <mi>t</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n+s}
  </annotation>
 </semantics>
</math>

. A computation using <a href="Taylor_series" title="wikilink">Taylor series</a> shows out that a linear multistep method is consistent if and only if</p>

<p>

<math display="block" id="Linear_multistep_method:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>s</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <msub>
       <mi>a</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mtext>and</mtext>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi>s</mi>
      </munderover>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>s</mi>
      <mo>+</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <mi>s</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
       <mrow>
        <mi>k</mi>
        <msub>
         <mi>a</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>s</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <list>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>s</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{s-1}a_{k}=-1\quad\text{and}\quad\sum_{k=0}^{s}b_{k}=s+\sum_{k=0}^{%
s-1}ka_{k}.
  </annotation>
 </semantics>
</math>

 All the methods mentioned above are consistent .</p>

<p>If the method is consistent, then the next question is how well the difference equation defining the numerical method approximates the differential equation. A multistep method is said to have <em>order</em> <em>p</em> if the local error is of order 

<math display="inline" id="Linear_multistep_method:65">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>h</mi>
     <mrow>
      <mi>p</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <apply>
      <plus></plus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(h^{p+1})
  </annotation>
 </semantics>
</math>

 as <em>h</em> goes to zero. This is equivalent to the following condition on the coefficients of the methods:</p>

<p>

<math display="block" id="Linear_multistep_method:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <mi>s</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
       <msub>
        <mi>a</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mtext>and</mtext>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mi>q</mi>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>k</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mi>s</mi>
        </munderover>
        <mrow>
         <msup>
          <mi>k</mi>
          <mrow>
           <mi>q</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
         <msub>
          <mi>b</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <msup>
        <mi>s</mi>
        <mi>q</mi>
       </msup>
       <mo>+</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>k</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>s</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mrow>
         <msup>
          <mi>k</mi>
          <mi>q</mi>
         </msup>
         <msub>
          <mi>a</mi>
          <mi>k</mi>
         </msub>
         <mtext>for</mtext>
         <mi>q</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>s</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <list>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <mtext>and</mtext>
      </list>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>q</ci>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>k</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <ci>s</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>k</ci>
           <apply>
            <minus></minus>
            <ci>q</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>q</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>k</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>s</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>k</ci>
           <ci>q</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <ci>k</ci>
          </apply>
          <mtext>for</mtext>
          <ci>q</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>p</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{s-1}a_{k}=-1\quad\text{and}\quad q\sum_{k=0}^{s}k^{q-1}b_{k}=s^{q}%
+\sum_{k=0}^{s-1}k^{q}a_{k}\text{ for }q=1,\ldots,p.
  </annotation>
 </semantics>
</math>

 The <em>s</em>-step Adams–Bashforth method has order <em>s</em>, while the <em>s</em>-step Adams–Moulton method has order 

<math display="inline" id="Linear_multistep_method:67">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s+1
  </annotation>
 </semantics>
</math>

 .</p>

<p>These conditions are often formulated using the <em>characteristic polynomials</em></p>

<p>

<math display="block" id="Linear_multistep_method:68">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>ρ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>z</mi>
        <mi>s</mi>
       </msup>
       <mo>+</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>k</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>s</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mrow>
         <msub>
          <mi>a</mi>
          <mi>k</mi>
         </msub>
         <msup>
          <mi>z</mi>
          <mi>k</mi>
         </msup>
        </mrow>
       </mrow>
      </mrow>
      <mtext>and</mtext>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi>s</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
       <msup>
        <mi>z</mi>
        <mi>k</mi>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <ci>z</ci>
     </apply>
     <list>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>k</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>s</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>σ</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(z)=z^{s}+\sum_{k=0}^{s-1}a_{k}z^{k}\quad\text{and}\quad\sigma(z)=\sum_{k=%
0}^{s}b_{k}z^{k}.
  </annotation>
 </semantics>
</math>

 In terms of these polynomials, the above condition for the method to have order <em>p</em> becomes</p>

<p>

<math display="block" id="Linear_multistep_method:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>ρ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi mathvariant="normal">e</mi>
        <mi>h</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>h</mi>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi mathvariant="normal">e</mi>
        <mi>h</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>h</mi>
       <mrow>
        <mi>p</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mtext>as</mtext>
     <mi>h</mi>
    </mrow>
    <mo>→</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-e</ci>
        <ci>h</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>σ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-e</ci>
        <ci>h</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <apply>
        <plus></plus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <mtext>as</mtext>
      <ci>h</ci>
     </apply>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(\mathrm{e}^{h})-h\sigma(\mathrm{e}^{h})=O(h^{p+1})\quad\text{as }h\to 0.
  </annotation>
 </semantics>
</math>

 In particular, the method is consistent if it has order one, which is the case if 

<math display="inline" id="Linear_multistep_method:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(1)=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Linear_multistep_method:71">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ρ</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>normal-′</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>σ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{\prime}(1)=\sigma(1)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="stability-and-convergence">Stability and convergence</h3>

<p>The numerical solution of a one-step method depends on the initial condition 

<math display="inline" id="Linear_multistep_method:72">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0}
  </annotation>
 </semantics>
</math>

, but the numerical solution of an <em>s</em>-step method depend on all the <em>s</em> starting values, 

<math display="inline" id="Linear_multistep_method:73">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0},y_{1},\ldots,y_{s-1}
  </annotation>
 </semantics>
</math>

. It is thus of interest whether the numerical solution is stable with respect to perturbations in the starting values. A linear multistep method is <em>zero-stable</em> for a certain differential equation on a given time interval, if a perturbation in the starting values of size ε causes the numerical solution over that time interval to change by no more than <em>K</em>ε for some value of <em>K</em> which does not depend on the step size <em>h</em>. This is called "zero-stability" because it is enough to check the condition for the differential equation 

<math display="inline" id="Linear_multistep_method:74">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=0
  </annotation>
 </semantics>
</math>

 .</p>

<p>If the roots of the characteristic polynomial ρ all have modulus less than or equal to 1 and the roots of modulus 1 are of multiplicity 1, we say that the <em>root condition</em> is satisfied. A linear multistep method is zero-stable if and only if the root condition is satisfied .</p>

<p>Now suppose that a consistent linear multistep method is applied to a sufficiently smooth differential equation and that the starting values 

<math display="inline" id="Linear_multistep_method:75">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1},\ldots,y_{s-1}
  </annotation>
 </semantics>
</math>

 all converge to the initial value 

<math display="inline" id="Linear_multistep_method:76">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Linear_multistep_method:77">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>h</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\to 0
  </annotation>
 </semantics>
</math>

. Then, the numerical solution converges to the exact solution as 

<math display="inline" id="Linear_multistep_method:78">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>h</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\to 0
  </annotation>
 </semantics>
</math>

 if and only if the method is zero-stable. This result is known as the <em>Dahlquist equivalence theorem</em>, named after <a href="Germund_Dahlquist" title="wikilink">Germund Dahlquist</a>; this theorem is similar in spirit to the <a href="Lax_equivalence_theorem" title="wikilink">Lax equivalence theorem</a> for <a href="finite_difference_method" title="wikilink">finite difference methods</a>. Furthermore, if the method has order <em>p</em>, then the <a href="global_truncation_error" title="wikilink">global error</a> (the difference between the numerical solution and the exact solution at a fixed time) is 

<math display="inline" id="Linear_multistep_method:79">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>h</mi>
     <mi>p</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(h^{p})
  </annotation>
 </semantics>
</math>

 .</p>

<p>Furthermore, if the method is convergent, the method is said to be <em>strongly stable</em> if 

<math display="inline" id="Linear_multistep_method:80">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=1
  </annotation>
 </semantics>
</math>

 is the only root of modulus 1. If it is convergent and all roots of modulus 1 are not repeated, but there is more than one such root, it is said to be <em>relatively stable</em>. Note that 1 must be a root for the method to be convergent; thus convergent methods are always one of these two.</p>

<p>To assess the performance of linear multistep methods on <a href="stiff_equation" title="wikilink">stiff equations</a>, consider the linear test equation <em>y</em>' = λ<em>y</em>. A multistep method applied to this differential equation with step size <em>h</em> yields a linear <a href="recurrence_relation" title="wikilink">recurrence relation</a> with characteristic polynomial</p>

<p>

<math display="block" id="Linear_multistep_method:81">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo>;</mo>
      <mrow>
       <mi>h</mi>
       <mi>λ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>h</mi>
         <mi>λ</mi>
         <msub>
          <mi>β</mi>
          <mi>s</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>z</mi>
       <mi>s</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>s</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>α</mi>
          <mi>k</mi>
         </msub>
         <mo>-</mo>
         <mrow>
          <mi>h</mi>
          <mi>λ</mi>
          <msub>
           <mi>β</mi>
           <mi>k</mi>
          </msub>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>z</mi>
        <mi>k</mi>
       </msup>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>ρ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>h</mi>
      <mi>λ</mi>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>π</ci>
      <list>
       <ci>z</ci>
       <apply>
        <times></times>
        <ci>h</ci>
        <ci>λ</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>h</ci>
         <ci>λ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>s</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <times></times>
          <ci>h</ci>
          <ci>λ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>β</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>λ</ci>
       <ci>σ</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(z;h\lambda)=(1-h\lambda\beta_{s})z^{s}+\sum_{k=0}^{s-1}(\alpha_{k}-h%
\lambda\beta_{k})z^{k}=\rho(z)-h\lambda\sigma(z).
  </annotation>
 </semantics>
</math>

 This polynomial is called the <em>stability polynomial</em> of the multistep method. If all of its roots have modulus less than one then the numerical solution of the multistep method will converge to zero and the multistep method is said to be <em>absolutely stable</em> for that value of <em>h</em>λ. The method is said to <em>A-stable</em> if it is absolutely stable for all <em>h</em>λ with negative real part. The <em>region of absolute stability</em> is the set of all <em>h</em>λ for which the multistep method is absolutely stable . For more details, see the section on <a href="Stiff_equation#Multistep_methods" title="wikilink">stiff equations and multistep methods</a>.</p>
<h3 id="example">Example</h3>

<p>Consider the Adams–Bashforth three-step method</p>

<p>

<math display="block" id="Linear_multistep_method:82">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mrow>
          <mfrac>
           <mn>23</mn>
           <mn>12</mn>
          </mfrac>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>t</mi>
            <mi>n</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>y</mi>
            <mi>n</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mfrac>
           <mn>16</mn>
           <mn>12</mn>
          </mfrac>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>t</mi>
            <mrow>
             <mi>n</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>y</mi>
            <mrow>
             <mi>n</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mfrac>
          <mn>5</mn>
          <mn>12</mn>
         </mfrac>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>2</mn>
           </mrow>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>2</mn>
           </mrow>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">23</cn>
          <cn type="integer">12</cn>
         </apply>
         <ci>f</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>n</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">16</cn>
          <cn type="integer">12</cn>
         </apply>
         <ci>f</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <apply>
            <minus></minus>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <apply>
            <minus></minus>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </interval>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">5</cn>
         <cn type="integer">12</cn>
        </apply>
        <ci>f</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=y_{n}+h\left({23\over 12}f(t_{n},y_{n})-{16\over 12}f(t_{n-1},y_{n-1})%
+{5\over 12}f(t_{n-2},y_{n-2})\right).
  </annotation>
 </semantics>
</math>

 The characteristic equation is thus</p>

<p>

<math display="block" id="Linear_multistep_method:83">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>z</mi>
     <mn>3</mn>
    </msup>
    <mo>-</mo>
    <msup>
     <mi>z</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>z</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>z</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(z)=z^{3}-z^{2}=z^{2}(z-1)\,
  </annotation>
 </semantics>
</math>

 which has roots 

<math display="inline" id="Linear_multistep_method:84">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=0,1
  </annotation>
 </semantics>
</math>

, and the conditions above are satisfied. As 

<math display="inline" id="Linear_multistep_method:85">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=1
  </annotation>
 </semantics>
</math>

 is the only root of modulus 1, the method is strongly stable.</p>
<h2 id="first-and-second-dahlquist-barriers">First and second Dahlquist barriers</h2>

<p>These two results were proved by <a href="Germund_Dahlquist" title="wikilink">Germund Dahlquist</a> and represent an important bound for the order of convergence and for the A-stability of a linear multistep method. The first Dahlquist barrier was proved in  and the second in .</p>
<h3 id="first-dahlquist-barrier">First Dahlquist barrier</h3>

<p>A zero-stable and linear <em>q</em>-step multistep method cannot attain an order of convergence greater than <em>q</em> + 1 if <em>q</em> is odd and greater than <em>q</em> + 2 if <em>q</em> is even. If the method is also explicit, then it cannot attain an order greater than <em>q</em> .</p>
<h3 id="second-dahlquist-barrier">Second Dahlquist barrier</h3>

<p>There are no explicit A-stable and linear multistep methods. The implicit ones have order of convergence at most 2. The <a href="trapezoidal_rule_(differential_equations)" title="wikilink">trapezoidal rule</a> has the smallest error constant amongst the A-stable linear multistep methods of order 2.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Digital_energy_gain" title="wikilink">Digital energy gain</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://math.fullerton.edu/mathews/n2003/AdamsBashforthMod.html">Adams-Bashforth-Moulton Method</a></li>
<li><a href="http://www.dotnumerics.com/NumericalLibraries/DifferentialEquations/">DotNumerics: Ordinary Differential Equations for C# and VB.NET</a> Initial-value problem for nonstiff and stiff ordinary differential equations (explicit Runge-Kutta, implicit Runge-Kutta, Gear’s BDF and Adams-Moulton).</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a></p>
</body>
</html>
