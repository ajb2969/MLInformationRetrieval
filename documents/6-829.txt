   Negation as failure      Negation as failure   Negation as failure ( NAF , for short) is a non-monotonic inference rule in logic programming , used to derive     not   p      not  p    \mathrm{not}~{}p   (i.e. that    p    p   ~{}p   is assumed not to hold) from failure to derive    p    p   ~{}p   . Note that     not   p      not  p    \mathrm{not}~{}p   can be different from the statement    ¬  p       p    \neg p   of the logical negation of    p    p   ~{}p   , depending on the completeness of the inference algorithm and thus also on the formal logic system.  Negation as failure has been an important feature of logic programming since the earliest days of both Planner and Prolog . In Prolog, it is usually implemented using Prolog's extralogical constructs.  Planner semantics  In Planner, negation as failure could be implemented as follows:   ''if'' (''not'' (''goal'' p)),  ''then'' (''assert'' ¬p)    which says that if an exhaustive search to prove p fails, then assert ¬p . 1 Note that the above example uses true mathematical negation, which cannot be expressed in Prolog.  Prolog semantics  In pure Prolog, NAF literals of the form    n  o   t   p      n  o  t  p    not~{}p   can occur in the body of clauses and can be used to derive other NAF literals. For example, given only the four clauses      p  ←   q  and   not   r      normal-←  p    q  italic- and  not  r     p\leftarrow q\and\mathrm{not}~{}r         q  ←  s     normal-←  q  s    q\leftarrow s         q  ←  t     normal-←  q  t    q\leftarrow t         t  ←      normal-←  t  absent    t\leftarrow     NAF derives     not   s      not  s    \mathrm{not}~{}s   ,     not   r      not  r    \mathrm{not}~{}r   and    p    p   ~{}p   .  Completion semantics  The semantics of NAF remained an open issue until Keith Clark [1978] showed that it is correct with respect to the completion of the logic program, where, loosely speaking, "only" and   ←   normal-←   \leftarrow   are interpreted as "if and only if", written as "iff" or "   ≡     \equiv   ".  For example, the completion of the four clauses above is      p  ≡   q  and   not   r       p    q  italic- and  not  r     p\equiv q\and\mathrm{not}~{}r         q  ≡   s  t       q    s  t     q\equiv st         t  ≡  true      t  true    t\equiv\mathrm{true}         r  ≡  false      r  false    r\equiv\mathrm{false}         s  ≡  false      s  false    s\equiv\mathrm{false}     The NAF inference rule simulates reasoning explicitly with the completion, where both sides of the equivalence are negated and negation on the right-hand side is distributed down to atomic formulae . For example, to show     not   p      not  p    \mathrm{not}~{}p   , NAF simulates reasoning with the equivalences        not   p   ≡    not   q  r         not  p     not  q  r     \mathrm{not}~{}p\equiv\mathrm{not}~{}qr           not   q   ≡    not   s  and   not   t         not  q     not  s  italic- and  not  t     \mathrm{not}~{}q\equiv\mathrm{not}~{}s\and\mathrm{not}~{}t           not   t   ≡  false        not  t   false    \mathrm{not}~{}t\equiv\mathrm{false}           not   r   ≡  true        not  r   true    \mathrm{not}~{}r\equiv\mathrm{true}           not   s   ≡  true        not  s   true    \mathrm{not}~{}s\equiv\mathrm{true}     In the non-propositional case, the completion needs to be augmented with equality axioms, to formalise the assumption that individuals with distinct names are distinct. NAF simulates this by failure of unification. For example, given only the two clauses       p   (  a  )    ←      normal-←    p  a   absent    p(a)\leftarrow          p   (  b  )    ←      normal-←    p  b   absent    p(b)\leftarrow   t  NAF derives     not   p   (  c  )       not  p  c    \mathrm{not}~{}p(c)   .  The completion of the program is       p   (  X  )    ≡  X  =   a  X   =  b          p  X   X         a  X        b     p(X)\equiv X=aX=b     augmented with unique names axioms and domain closure axioms.  The completion semantics is closely related both to circumscription and to the closed world assumption .  Autoepistemic semantics  The completion semantics justifies interpreting the result     not   p      not  p    \mathrm{not}~{}p   of a NAF inference as the classical negation    ¬  p       p    \neg p   of   p   p   p   . However, Michael Gelfond [1987] showed that it is also possible to interpret     not   p      not  p    \mathrm{not}~{}p   literally as "   p   p   p   can not be shown", "   p   p   p   is not known" or "   p   p   p   is not believed", as in autoepistemic logic . The autoepistemic interpretation was developed further by Gelfond and Lifschitz [1988] and is the basis of answer set programming .  The autoepistemics semantics of a pure Prolog program P with NAF literals is obtained by "expanding" P with a set of ground (variable-free) NAF literals Δ that is stable in the sense that   Δ = {     not   p      not  p    \mathrm{not}~{}p   |   p   p   p   is not implied by P ∪ Δ}   In other words, a set of assumptions Δ about what can not be shown is stable if and only if Δ is the set of all sentences that truly can not be shown from the program P expanded by Δ. Here, because of the simple syntax of pure Prolog programs, "implied by" can be understood very simply as derivability using modus ponens and universal instantiation alone.  A program can have zero, one or more stable expansions. For example      p  ←    not   p      normal-←  p    not  p     p\leftarrow\mathrm{not}~{}p   has no stable expansions.      p  ←    not   q      normal-←  p    not  q     p\leftarrow\mathrm{not}~{}q   has exactly one stable expansion Δ = {     not   q      not  q    \mathrm{not}~{}q   }      p  ←    not   q      normal-←  p    not  q     p\leftarrow\mathrm{not}~{}q         q  ←    not   p      normal-←  q    not  p     q\leftarrow\mathrm{not}~{}p   has exactly two stable expansions Δ 1 = {     not   p      not  p    \mathrm{not}~{}p   } and Δ 2 = {     not   q      not  q    \mathrm{not}~{}q   }.  The autoepistemic interpretation of NAF can be combined with classical negation, as in extended logic programming and answer set programming . Combining the two negations, it is possible to express, for example       ¬  p   ←    not   p      normal-←     p     not  p     \neg p\leftarrow\mathrm{not}~{}p   (the closed world assumption) and      p  ←    not   ¬  p      normal-←  p    not   p     p\leftarrow\mathrm{not}~{}\neg p   (   p   p   p   holds by default).  Footnotes  References   K. Clark [1978, 1987]. Negation as failure . Readings in nonmonotonic reasoning , Morgan Kaufmann Publishers, pages 311-325.    M. Gelfond [1987] On Stratified Autoepistemic Theories Proc. AAAI, pages 207-211.    M. Gelfond and V. Lifschitz [1988] The Stable Model Semantics for Logic Programming Proc. 5th International Conference and Symposium on Logic Programming (R. Kowalski and K. Bowen, eds), MIT Press, pages 1070-1080.    J.C. Shepherdson [1984] Negation as failure: a comparison of Clark's completed data base and Reiter's closed world assumption , Journal of Logic Programming, vol 1, 1984, pages 51-81.    J.C. Shepherdson [1985] Negation as failure II , Journal of Logic Programming, vol 3, 1985, pages 185-202.   External links   Report from the W3C Workshop on Rule Languages for Interoperability. Includes notes on NAF and SNAF (scoped negation as failure).   "  Category:Logic programming  Category:Rules of inference     ↩     