   Factorization of polynomials over finite fields      Factorization of polynomials over finite fields   In mathematics and computer algebra the factorization of a polynomial consists of decomposing it into a product of irreducible factors . This decomposition is theoretically possible and is unique for polynomials with coefficients in any field , but rather strong restrictions on the field of the coefficients are needed to allow the computation of the factorization by means of an algorithm . In practice, algorithms have been designed only for polynomials with coefficients in a finite field , in the field of rationals or in a finitely generated field extension of one of them.  The case of the factorization of univariate polynomials over a finite field , which is the subject of this article, is especially important, because all the algorithms (including the case of multivariate polynomials over the rational numbers), which are sufficiently efficient to be implemented, reduce the problem to this case (see Polynomial factorization ). It is also interesting for various applications of finite fields, such as coding theory ( cyclic redundancy codes and BCH codes ), cryptography ( public key cryptography by the means of elliptic curves ), and computational number theory .  As the reduction of the factorization of multivariate polynomials to that of univariate polynomials does not have any specificity in the case of coefficients in a finite field, only polynomials with one variable are considered in this article.  Background  Finite field  The theory of finite fields, whose origins can be traced back to the works of Gauss and Galois , has played a part in various branches of mathematics. Due to the applicability of the concept in other topics of mathematics and sciences like computer science there has been a resurgence of interest in finite fields and this is partly due to important applications in coding theory and cryptography . Applications of finite fields introduce some of these developments in cryptography , computer algebra and coding theory .  A finite field or Galois field is a field with a finite order (number of elements). The order of a finite field is always a prime or a power of prime. For each prime power  q = p r , there exists exactly one finite field with q elements, up to isomorphism. This field is denoted GF ( q ) or F q . If p is prime, GF ( p ) is the prime field of order p ; it is the field of residue classes modulo p , and its p elements are denoted 0, 1, ..., p ‚àí1. Thus a = b in GF ( p ) means the same as a ‚â° b (mod p ).  Irreducible polynomials  Let F be a finite field. As for general fields, a non-constant polynomial f in F [ x ] is said to be irreducible over F if it is not the product of two polynomials of positive degree. A polynomial of positive degree that is not irreducible over F is called reducible over  F .  Irreducible polynomials allow us to construct the finite fields of non prime order. In fact, for a prime power q , let F q be the finite field with q elements, unique up to an isomorphism. A polynomial f of degree n greater than one, which is irreducible over F q , defines a field extension of degree n which is isomorphic to the field with q n elements: the elements of this extension are the polynomials of degree lower than n ; addition, subtraction and multiplication by an element of F q are those of the polynomials; the product of two elements it the remainder of the division by f of their product as polynomials; the inverse of an element may be computed by the extended GCD algorithm (see Arithmetic of algebraic extensions ).  It follows that, to compute in a finite field of non prime order, one needs to generate an irreducible polynomial. For this, the common method is to take a polynomial at random and test it for irreducibility. For sake of efficiency of the multiplication in the field, it is usual to search for polynomials of the shape x n + ax + b .  Irreducible polynomials over finite fields are also useful for Pseudorandom number generators using feedback shift registers and discrete logarithm over F 2 n .  Example  The polynomial P = x 4 + 1 is irreducible over Q but not over any finite field.   On any field extension of F 2 , P = ( x +1) 4 .    On every other finite field, at least one of ‚àí1, 2 and ‚àí2 is a square, because the product of two non squares is a square and so we have    If      -  1   =   a  2    ,        1    superscript  a  2     -1=a^{2},   then     P  =    (    x  2   +  a   )    (    x  2   -  a   )     .      P       superscript  x  2   a      superscript  x  2   a      P=(x^{2}+a)(x^{2}-a).     If     2  =   b  2    ,      2   superscript  b  2     2=b^{2},   then     P  =    (    x  2   +   b  x   +  1   )    (     x  2   -   b  x    +  1   )     .      P       superscript  x  2     b  x   1        superscript  x  2     b  x    1      P=(x^{2}+bx+1)(x^{2}-bx+1).     If      -  2   =   c  2    ,        2    superscript  c  2     -2=c^{2},   then     P  =    (     x  2   +   c  x    -  1   )    (    x  2   -   c  x   -  1   )     .      P         superscript  x  2     c  x    1      superscript  x  2     c  x   1      P=(x^{2}+cx-1)(x^{2}-cx-1).      Complexity  Polynomial factoring algorithms use basic polynomial operations such as products, divisions, gcd, powers of one polynomial modulo another, etc. A multiplication of two polynomials of degree at most n can be done in O ( n 2 ) operations in F q using "classical" arithmetic, or in O ( n log( n )) operations in F q using "fast" arithmetic . A Euclidean division (division with remainder) can be performed within the same time bounds. The cost of a polynomial greatest common divisor between two polynomials of degree at most n can be taken as O ( n 2 ) operations in F q using classical methods, or as O ( n log 2 ( n )) operations in F q using fast methods. For polynomials h , g of degree at most n , the exponentiation h q mod g can be done with O (log( q )) polynomial products, using exponentiation by squaring method, that is O ( n 2 log( q )) operations in F q using classical methods, or O ( n log( q )log( n )) operations in F q using fast methods.  In the algorithms that follow, the complexities are expressed in terms of number of arithmetic operations in F q , using classical algorithms for the arithmetic of polynomials.  Factoring algorithms  Many algorithms for factoring polynomials over finite fields include the following three stages:  Square-free factorization  The algorithm determines a square-free factorization for polynomials whose coefficients come from the finite field F q of order q = p m with p a prime. This algorithm firstly determines the derivative and then computes the gcd of the polynomial and its derivative. If it is not one then the gcd is again divided into the original polynomial, provided that the derivative is not zero (a case that exists for non-constant polynomials defined over finite fields).  This algorithm uses the fact that, if the derivative of a polynomial is zero, then it is a polynomial in x p , which is, if the coefficients belong to F p , the p th power of the polynomial obtained by substituting x by x 1/ p . If the coefficients do not belong to F p , the p -th root of a polynomial with zero derivative is obtained by the same substitution on x , completed by applying the inverse of the Frobenius automorphism to the coefficients.  This algorithm works also over a field of characteristic zero, with the only difference that it never enters in the blocks of instructions where p th roots are computed. However, in this case, Yun's algorithm is much more efficient because it computes the greatest common divisors of polynomials of lower degrees. A consequence is that, when factoring a polynomial over the integers, the algorithm which follows is not used: one compute first the square-free factorization over the integers, and to factor the resulting polynomials, one chooses a p such that they remain square-free modulo p .   Algorithm : SFF (Square-Free¬†Factorization)   Input :¬†A monic  polynomial  f in F q [ x ]   Output :¬†Square-free¬†factorization¬†of f   i ‚Üê1; R ‚Üê¬†1; g ‚Üê f ‚Ä≤;   if  g ‚â†¬†0 then {   c ‚Üê gcd ( f , g );   w ‚Üê f / c ;   while  w ‚â†¬†1¬†do¬†{   y ‚Üê gcd ( w , c ); z ‚Üê w / y ;   R ‚Üê R ¬∑ z i ; i ‚Üê¬†i+1;   w ‚Üê y ; c ‚Üê c / y }   if  c ‚â†¬†1 then {   c ‚Üê c 1/ p ;   Output ( R ¬∑ SFF ( c ) p )¬†}  else Output ( R )   else {   f ‚Üê f 1/ p ;   Output ( SFF ( f ) p )¬†}   end .  Example of a square-free factorization  Let       f  =    x  11   +   2   x  9    +   2   x  8    +   x  6   +   x  5   +   2   x  3    +   2   x  2    +  1   ‚àà    ùêÖ  3    [  x  ]     ,        f     superscript  x  11     2   superscript  x  9      2   superscript  x  8     superscript  x  6    superscript  x  5     2   superscript  x  3      2   superscript  x  2    1           subscript  ùêÖ  3    delimited-[]  x       f=x^{11}+2x^{9}+2x^{8}+x^{6}+x^{5}+2x^{3}+2x^{2}+1\in\mathbf{F}_{3}[x],   to be factored over the field with three elements.  The algorithm computes first      c  =   gcd   (  f  ,   f  ‚Ä≤   )    =    x  9   +   2   x  6    +   x  3   +  2.         c    f   superscript  f  normal-‚Ä≤            superscript  x  9     2   superscript  x  6     superscript  x  3   2.      c=\gcd(f,f^{\prime})=x^{9}+2x^{6}+x^{3}+2.     Since the derivative is non-zero we have and we enter the while loop. After one loop we have    y  =   x  +  2       y    x  2     y=x+2   ,    z  =   x  +  1       z    x  1     z=x+1   and    R  =   x  +  1       R    x  1     R=x+1   with updates    i  =  2      i  2    i=2   ,    w  =   x  +  2       w    x  2     w=x+2   and . The second time through the loop gives    y  =   x  +  2       y    x  2     y=x+2   ,    z  =  1      z  1    z=1   ,    R  =   x  +  1       R    x  1     R=x+1   , with updates    i  =  3      i  3    i=3   ,    w  =   x  +  2       w    x  2     w=x+2   and . The third time through the loop also does not change   R   R   R   . For the fourth time through the loop we get    y  =  1      y  1    y=1   ,    z  =   x  +  2       z    x  2     z=x+2   , , with updates    i  =  5      i  5    i=5   ,    w  =  1      w  1    w=1   and . Since w = 1, we exit the while loop. Since c ‚â† 1, it must be a perfect cube. The cube root of c , obtained by replacing x 3 by x is x 2 +¬†1, and calling the square-free procedure recursively determines that it is square-free. Therefore, cubing it and combining it with the value of R to that point gives the square-free decomposition       f  =    (   x  +  1   )     (    x  2   +  1   )   3     (   x  +  2   )   4     .      f      x  1    superscript     superscript  x  2   1   3    superscript    x  2   4      f=(x+1)(x^{2}+1)^{3}(x+2)^{4}.     Distinct-degree factorization  This algorithm splits a square-free polynomial into a product of polynomials whose irreducible factors all have the same degree. Let f ‚àà F q [ x ] of degree n be the polynomial to be factored.   Algorithm Distinct-degree¬†factorization(DDF)   Input :¬†A¬†monic¬†square-free¬†polynomial f ‚àà F q [ x ]   Output :¬†The¬†set¬†of¬†all¬†pairs¬†( g , d ),¬†such¬†that   f has¬†an¬†irreducible¬†factor¬†of¬†degree d and   g is¬†the¬†product¬†of¬†all¬†monic¬†irreducible¬†factors¬†of f of¬†degree d .   Begin         i  :=  1   ;    S  :=  ‚àÖ   ,    f  *   :=  f     ;     formulae-sequence   assign  i  1    formulae-sequence   assign  S     assign   superscript  f    f      i:=1;\qquad S:=\emptyset,\qquad f^{*}:=f;      while       deg   f  *    ‚â•   2  i        degree   superscript  f       2  i     \deg f^{*}\geq 2i     do        g  =   gcd   (   f  *   ,    x   q  i    -  x   )        g     superscript  f       superscript  x   superscript  q  i    x      g=\gcd(f^{*},x^{q^{i}}-x)      if  g ‚â†¬†1, then        S  :=   S  ‚à™   (  g  ,  i  )       assign  S    S   g  i      S:=S\cup{(g,i)}    ;   f* := f* / g ;   end  if   i := i +1;   end  while ;   if  f* ‚â†¬†1, then      S  :=   S  ‚à™   (   f  *   ,   deg   f  *    )       assign  S    S    superscript  f     degree   superscript  f         S:=S\cup{(f^{*},\deg f^{*})}    ;   if  S =¬†‚àÖ   then  return {( f ,¬†1)}   else  return  S   End  The correctness of the algorithm is based on the following:   Lemma. For i ‚â• 1 the polynomial        x   q  i    -  x   ‚àà    ùêÖ  q    [  x  ]           superscript  x   superscript  q  i    x      subscript  ùêÖ  q    delimited-[]  x      x^{q^{i}}-x\in\mathbf{F}_{q}[x]     is the product of all monic irreducible polynomials in F q [ x ] whose degree divides i .   At first glance, this is not efficient since it involves computing the GCD of polynomials of a degree which is exponential in the degree of the input polynomial. However      g  =   gcd   (   f  *   ,    x   q  i    -  x   )        g     superscript  f       superscript  x   superscript  q  i    x      g=\gcd\left(f^{*},x^{q^{i}}-x\right)     may be replaced by       g  =   gcd   (   f  *   ,   (     x   q  i    -  x   mod   f  *    )   )     .      g     superscript  f     modulo     superscript  x   superscript  q  i    x    superscript  f        g=\gcd\left(f^{*},\left(x^{q^{i}}-x\mod f^{*}\right)\right).     Therefore we have to compute:         x   q  i    -  x   mod   f  *    ,     modulo     superscript  x   superscript  q  i    x    superscript  f      x^{q^{i}}-x\mod f^{*},     there are two methods:   Method I. Start from the value of       x   q   i  -  1     mod   f  *      modulo   superscript  x   superscript  q    i  1      superscript  f      x^{q^{i-1}}\mod f^{*}     computed at the preceding step and to compute its q -th power modulo the new f* , using exponentiation by squaring method. This needs      O   (  log   (  q  )   deg    (  f  )   2   )      fragments  O   fragments  normal-(    fragments  normal-(  q  normal-)   degree   superscript   fragments  normal-(  f  normal-)   2   normal-)     O\left(\log(q)\deg(f)^{2}\right)     arithmetic operations in F q at each step, and thus      O   (  log   (  q  )   deg    (  f  )   3   )      fragments  O   fragments  normal-(    fragments  normal-(  q  normal-)   degree   superscript   fragments  normal-(  f  normal-)   3   normal-)     O\left(\log(q)\deg(f)^{3}\right)     arithmetic operations for the whole algorithm.    Method II. Using the fact that the q -th power is a linear map over F q we may compute its matrix with      O   (  deg    (  f  )   2    (  log   (  q  )   +  deg   (  f  )   )   )      fragments  O   fragments  normal-(  degree   superscript   fragments  normal-(  f  normal-)   2    fragments  normal-(    fragments  normal-(  q  normal-)    degree   fragments  normal-(  f  normal-)   normal-)   normal-)     O\left(\deg(f)^{2}(\log(q)+\deg(f))\right)     operations. Then at each iteration of the loop, compute the product of a matrix by a vector (with O (deg( f ) 2 ) operations). This induces a total number of operations in F q which is      O   (  deg    (  f  )   2    (  log   (  q  )   +  deg   (  f  )   )   )   .     fragments  O   fragments  normal-(  degree   superscript   fragments  normal-(  f  normal-)   2    fragments  normal-(    fragments  normal-(  q  normal-)    degree   fragments  normal-(  f  normal-)   normal-)   normal-)   normal-.    O\left(\deg(f)^{2}(\log(q)+\deg(f))\right).     Thus this second method is more efficient and is usually preferred. Moreover, the matrix that is computed in this method is used, by most algorithms, for equal-degree factorization (see below); thus using it for the distinct-degree factorization saves further computing time.   Equal-degree factorization  In this section, we consider the factorization of a monic squarefree univariate polynomial f , of degree n , over a finite field F q , which has r ‚â• 2 pairwise distinct irreducible factors     f  1   ,  ‚Ä¶  ,   f  r       subscript  f  1   normal-‚Ä¶   subscript  f  r     f_{1},\ldots,f_{r}   each of degree d .  We first describe an algorithm by Cantor and Zassenhaus (1981) and then a variant that has a slightly better complexity. Both are probabilistic algorithms whose running time depends on random choices ( Las Vegas algorithms ), and have a good average running time. In next section we describe an algorithm by Shoup (1990), which is also an equal-degree factorization algorithm, but is deterministic. All these algorithms require an odd order q for the field of coefficients. For more factorization algorithms see e.g. Knuth's book The Art of Computer Programming volume 2.  Algorithm¬†Cantor‚ÄìZassenhaus¬†algorithm.  Input:¬†A¬†finite¬†field F q of¬†odd¬†order q .  A¬†monic¬†square¬†free¬†polynomial f in F q [ x ]¬†of¬†degree n = rd ,  which¬†has r ‚â•¬†2¬†irreducible¬†factors¬†each¬†of¬†degree d  Output:¬†The¬†set¬†of¬†monic¬†irreducible¬†factors¬†of f .  Factors:={ f };  while¬†Size(Factors) q [ x ]¬†with¬†deg( h ) g:=h^{\frac{q^d-1}{2}}-¬†1¬†\pmod¬†f  for¬†each u in¬†Factors¬†with¬†deg( u )¬†> d do  if¬†gcd( g , u )¬†‚â†¬†1¬†and¬†gcd( g , u )¬†‚â† u ,¬†then  Factors:=¬†Factors      ‚àñ   {  u  }    ‚à™   {   (   gcd   (  g  ,  u  )    ,   u  /   gcd   (  g  ,  u  )     )   }          u        g  u     u    g  u        \,\setminus\,\{u\}\cup\{(\gcd(g,u),u/\gcd(g,u))\}    ;  endif;  endwhile  return¬†Factors.  The correctness of this algorithm relies on the fact that the ring F q [ x ]/ f is a direct product of the fields F q [ x ]/ f i where f i runs on the irreducible factors of f . As all these fields have q d elements, the component of g in any of these fields is zero with probability          q  d   -  1    2   q  d     ‚àº    1  2     .     similar-to       superscript  q  d   1     2   superscript  q  d       1  2     \frac{q^{d}-1}{2q^{d}}\sim\tfrac{1}{2}.     This implies that the polynomial gcd( g , u ) is the product of the factors of g for which the component of g is zero.  It has been shown that the average number of iterations of the while loop of the algorithm is less than    2.5    log  2   r       2.5    subscript   2   r     2.5\log_{2}r   , giving an average number of arithmetic operations in F q which is    O   (   d   n  2    log   (  r  )     log   (  q  )     )       O    d   superscript  n  2     r     q      O(dn^{2}\log(r)\log(q))   . 1  In the typical case where d log( q ) > n , this complexity may be reduced to      O   (    n  2    (     log   (  r  )     log   (  q  )     +  n   )    )       O     superscript  n  2         r     q    n      O(n^{2}(\log(r)\log(q)+n))     by choosing h in the kernel of the linear map      v  ‚Üí     v  q   -  v      (   mod  f   )       normal-‚Üí  v   annotated     superscript  v  q   v    pmod  f      v\to v^{q}-v\;\;(\mathop{{\rm mod}}f)     and replacing the instruction      g  :=     h     q  d   -  1   2    -  1      (   mod  f   )       assign  g   annotated     superscript  h       superscript  q  d   1   2    1    pmod  f      g:=h^{\frac{q^{d}-1}{2}}-1\;\;(\mathop{{\rm mod}}f)     by       g  :=     h    q  -  1   2    -  1      (   mod  f   )     .     assign  g   annotated     superscript  h      q  1   2    1    pmod  f      g:=h^{\frac{q-1}{2}}-1\;\;(\mathop{{\rm mod}}f).     The proof of validity is the same as above, replacing the direct product of the fields F q [ x ]/ f i by the direct product of their subfields with q elements. The complexity is decomposed in    O   (    n  2    log   (  r  )     log   (  q  )     )       O     superscript  n  2     r     q      O(n^{2}\log(r)\log(q))   for the algorithm itself,    O   (    n  2    (    log   (  q  )    +  n   )    )       O     superscript  n  2       q   n      O(n^{2}(\log(q)+n))   for the computation of the matrix of the linear map (which may be already computed in the square-free factorization) and O ( n 3 ) for computing its kernel. It may be noted that this algorithm works also if the factors have not the same degree (in this case the number r of factors, needed for stopping the while loop, is found as the dimension of the kernel). Nevertheless, the complexity is slightly better if square-free factorization is done before using this algorithm (as n may decrease with square-free factorization, this reduces the complexity of the critical steps).  Victor Shoup's algorithm  Like the algorithms of the preceding section, Victor Shoup 's algorithm is an equal-degree factorization algorithm. 2 Unlike them, it is a deterministic algorithm. However, it is less efficient, in practice, that the algorithms of preceding section. For Shoup's algorithm, the input is restricted to polynomials over prime fields F q .  Let g = g 1 ... g k be the desired factorization, where the g i are distinct monic irreducible polynomials of degree d . Let n = deg( g ) = kd . We consider the ring  R = F q [ x ]/ g and denote also by x the image of x in R . The ring R is the direct product of the fields R i = F q [ x ]/ g i , and we denote by p i the natural homomorphism from the R onto R i . The Galois group of R i over F q is cyclic of order d , generated by the field automorphism  u ‚Üí u p . It follows that the roots of g i in R i are         p  i    (  x  )    ,    p  i    (   x  q   )    ,    p  i    (   x   q  2    )    ,    p  i    (   x   q   d  -  1     )     .        subscript  p  i   x      subscript  p  i    superscript  x  q       subscript  p  i    superscript  x   superscript  q  2        subscript  p  i    superscript  x   superscript  q    d  1        p_{i}(x),p_{i}(x^{q}),p_{i}\left(x^{q^{2}}\right),p_{i}\left(x^{q^{d-1}}\right).     If q > n , the Newton's identities allow to compute the s i with  Like in the preceding algorithm, this algorithm uses the same subalgebra  B of R as the Berlekamp's algorithm , sometimes called the "Berlekamp subagebra" and defined as     B   B   \displaystyle B     A subset S of B is said a separating set if, for every 1¬†‚â§ i p_i(s) \ne p_j(s). In the preceding algorithm, a separating set is constructed by choosing at random the elements of S . In Shoup's algorithm, the separating set is constructed in the following way. Let s in R [ Y ] be such that     s   s   \displaystyle s     Then    {   s  0   ,  ‚Ä¶  ,   s   d  -  1    }      subscript  s  0   normal-‚Ä¶   subscript  s    d  1      \{s_{0},\dots,s_{d-1}\}   is a separating set because      p  i    (  s  )    =   g  i          subscript  p  i   s    subscript  g  i     p_{i}(s)=g_{i}   for i =1, ..., k (the two monic polynomials have the same roots). As the g i are pairwise distinct, for every pair of distinct indexes ( i , j ), at least one of the coefficients s h will satisfy       p  i    (   s  h   )    ‚â†    p  j    (   s  h   )     .         subscript  p  i    subscript  s  h       subscript  p  j    subscript  s  h      p_{i}(s_{h})\neq p_{j}(s_{h}).     Having a separating set, Shoup's algorithm proceeds as the last algorithm of the preceding section, simply by replacing the instruction "choose at random h in the kernel of the linear map    v  ‚Üí     v  q   -  v      (   mod  f   )       normal-‚Üí  v   annotated     superscript  v  q   v    pmod  f      v\to v^{q}-v\;\;(\mathop{{\rm mod}}f)   " by "choose h + i with h in S and i in {1, ..., k ‚àí1}".  Rabin's test of irreducibility  Like distinct-degree factorization algorithm, Rabin's algorithm 3 is based on the Lemma stated above. Distinct-degree factorization algorithm tests every d not greater than half the degree of the input polynomial. Rabin's algorithm takes advantage that the factors are not needed for considering fewer d . Otherwise, it is similar to distinct-degree factorization algorithm. It is based on the following fact.  Let p 1 , ..., p k , be all the prime divisors of n , and denote     n  /   p  i    =   n  i         n   subscript  p  i     subscript  n  i     n/p_{i}=n_{i}   , for 1 ‚â§ i ‚â§ k polynomial f in F q [ x ] of degree n is irreducible in F q [ x ] if and only if     gcd   (  f  ,    x   q   n  i     -  x   )    =  1        f     superscript  x   superscript  q   subscript  n  i     x    1    \gcd\left(f,x^{q^{n_{i}}}-x\right)=1   , for 1¬†‚â§ i ‚â§ k , and f divides     x   q  n    -  x       superscript  x   superscript  q  n    x    x^{q^{n}}-x   . In fact, if f has a factor of degree not dividing n , then f does not divide     x   q  n    -  x       superscript  x   superscript  q  n    x    x^{q^{n}}-x   ; if f has a factor of degree dividing n , then this factor divides at least one of the      x   q   n  i     -  x   .       superscript  x   superscript  q   subscript  n  i     x    x^{q^{n_{i}}}-x.      Algorithm Rabin¬†Irreducibility¬†Test   Input :¬†A¬†monic¬†polynomial f in F q [ x ]¬†of¬†degree n ,   p 1 ,¬†..., p k all¬†distinct¬†prime¬†divisors¬†of n .   Output :¬†Either¬†" f is¬†irreducible"¬†or¬†" f is¬†reducible".   Begin   for  j =¬†1¬†to k  do         n  j   =   n  /   p  j         subscript  n  j     n   subscript  p  j      n_{j}=n/p_{j}    ;   for  i =¬†1¬†to k  do        h  :=     x   q   n  i     -  x   mod  f      assign  h   modulo     superscript  x   superscript  q   subscript  n  i     x   f     h:=x^{q^{n_{i}}}-x\bmod f    ;   g :=¬†gcd( f , h );   if  g ‚â†¬†1, then  return 'f¬†is¬†reducible' and  STOP ;   end  for ;       g  :=     x   q  n    -  x   mod  f      assign  g   modulo     superscript  x   superscript  q  n    x   f     g:=x^{q^{n}}-x\bmod f    ;   if  g =¬†0, then  return "f¬†is¬†irreducible",   else  return " f is¬†reducible"   end.  The basic idea of this algorithm is to compute     x   q   n  i     mod  f     modulo   superscript  x   superscript  q   subscript  n  i     f    x^{q^{n_{i}}}\bmod f   starting from the smallest     n  1   ,  ‚Ä¶  ,   n  k       subscript  n  1   normal-‚Ä¶   subscript  n  k     n_{1},\ldots,n_{k}   by repeated squaring or using the Frobenius automorphism , and then to take the correspondent gcd. Using the elementary polynomial arithmetic, the computation of the matrix of the Frobenius automorphism needs    O   (    n  2    (   n  +   log  q    )    )       O     superscript  n  2     n    q       O(n^{2}(n+\log q))   operations in F q , the computation of        x   q   n  i     -  x      (   mod  f   )      annotated     superscript  x   superscript  q   subscript  n  i     x    pmod  f     x^{q^{n_{i}}}-x\;\;(\mathop{{\rm mod}}f)     needs O ( n 3 ) further operations, and the algorithm itself needs O ( kn 2 ) operations, giving a total of    O   (    n  2    (   n  +   log  q    )    )       O     superscript  n  2     n    q       O(n^{2}(n+\log q))   operations in F q . Using fast arithmetic (complexity    O   (   n   log  n    )       O    n    n      O(n\log n)   for multiplication and division, and    O   (   n    (   log  n   )   2    )       O    n   superscript    n   2      O(n(\log n)^{2})   for GCD computation), the computation of the      x   q   n  i     -  x   mod  f     modulo     superscript  x   superscript  q   subscript  n  i     x   f    x^{q^{n_{i}}}-x\bmod f   by repeated squaring is    O   (    n  2    log   n   log  q      )       O     superscript  n  2       n    q        O(n^{2}\log n\log q)   , and the algorithm itself is    O   (   k  n    (   log  n   )   2    )       O    k  n   superscript    n   2      O(kn(\log n)^{2})   , giving a total of    O   (    n  2    log   n   log  q      )       O     superscript  n  2       n    q        O(n^{2}\log n\log q)   operations in F q .  See also   Berlekamp's algorithm  Cantor‚ÄìZassenhaus algorithm  Polynomial factorization  Ivanyos-Karpinski-Saxena algorithm 4   References   KEMPFERT,H (1969) On the Factorization of Polynomials Department of Mathematics, The Ohio State University,Columbus,Ohio 43210  Shoup,Victor (1996) Smoothness and Factoring Polynomials over Finite Fields Computer Science Department University of Toronto  Von Zur Gathen, J. ; Panario, D. (2001). Factoring Polynomials Over Finite Fields: A Survey . Journal of Symbolic Computation , Volume 31, Issues 1-2, January 2001, 3--17.  Gao Shuhong, Panario Daniel, Test and Construction of Irreducible Polynomials over Finite Fields Department of mathematical Sciences, Clemson University, South Carolina, 29634-1907, USA. and Department of computer science University of Toronto, Canada M5S-1A4  Shoup, Victor (1989) New Algorithms for Finding Irreducible Polynomials over Finite Fields Computer Science Department University of Wisconsin‚ÄìMadison  Geddes, Keith O. ; Czapor, Stephen R.; Labahn, George (1992). Algorithms for computer algebra . Boston, MA: Kluwer Academic Publishers. pp. xxii+585. ISBN 0-7923-9259-0.   External links   Some irreducible polynomials http://www.math.umn.edu/~garrett/m/algebra/notes/07.pdf  Field and Galois Theory : http://www.jmilne.org/math/CourseNotes/FT.pdf  Galois Field: http://designtheory.org/library/encyc/topics/gf.pdf  Factoring polynomials over finite fields: http://www.science.unitn.it/~degraaf/compalg/polfact.pdf   Notes  "  Category:Polynomials  Category:Algebra  Category:Computer algebra  Category:Coding theory  Category:Cryptography  Category:Computational number theory     ‚Ü©  Victor Shoup, On the deterministic complexity of factoring polynomials over finite fields, Information Processing Letters 33:261-267, 1990 ‚Ü©  ‚Ü©  ‚Ü©     