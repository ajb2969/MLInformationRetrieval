<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="930">Procedural parameter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Procedural parameter</h1>
<hr/>

<p>In <a class="uri" href="computing" title="wikilink">computing</a>, a <strong>procedural parameter</strong> is a <a href="parameter_(computer_science)" title="wikilink">parameter</a> of a <a href="subroutine" title="wikilink">procedure</a> that is itself a procedure.</p>

<p>This concept is an extremely powerful and versatile <a href="Computer_programming" title="wikilink">programming</a> tool, because it allows programmers to modify certain steps of a <a href="library_(computer_science)" title="wikilink">library procedure</a> in arbitrarily complicated ways, without having to understand or modify the code of that procedure.</p>

<p>This tool is particularly effective and convenient in languages that support <a href="nested_function" title="wikilink">local function definitions</a>, such as <a href="Pascal_programming_language" title="wikilink">Pascal</a> and the modern <a href="GNU_Compiler_Collection" title="wikilink">GNU dialect</a> of <a href="C_programming_language" title="wikilink">C</a>. It is even more so when <a href="closure_(computer_science)" title="wikilink">function closures</a> are available. The same functionality (and more) is provided by <a href="object_(computing)" title="wikilink">objects</a> in <a href="object_oriented_programming" title="wikilink">object oriented</a> <a href="programming_language" title="wikilink">programming languages</a>, but at a significantly higher cost.</p>

<p>Procedural parameters are somewhat related to the concepts of <a href="first-class_function" title="wikilink">first-class function</a> and <a href="anonymous_function" title="wikilink">anonymous function</a>, but is distinct from them. These two concepts have more to do with how functions are defined, rather than how they are used.</p>
<h2 id="basic-concept">Basic concept</h2>

<p>In most languages that provide this feature, a procedural parameter <em>f</em> of a subroutine <em>P</em> can be called inside the body of <em>P</em> as if it were an ordinary procedure:</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>P</code></em><code>(</code><em><code>f</code></em><code>):</code><br/>
<code>      </code><strong><code>return</code></strong><code> </code><em><code>f</code></em><code>(6,3) * </code><em><code>f</code></em><code>(2,1)</code></p>

<p>When calling the subroutine <em>P</em>, one must give it one argument, that must be some previously defined function compatible with the way <em>P</em> uses its parameter <em>f</em>. For example, if we define</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>plus</code></em><code>(</code><em><code>x</code></em><code>, </code><em><code>y</code></em><code>):</code><br/>
<code>      </code><strong><code>return</code></strong><code> </code><em><code>x</code></em><code> + </code><em><code>y</code></em></p>

<p>then we may call <em>P</em> (<em>plus</em>), and the result will be <em>plus</em>(6,3) * <em>plus</em>(2,1) = (6 + 3)*(2 + 1) = 27. On the other hand, if we define</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>quot</code></em><code>(</code><em><code>u</code></em><code>, </code><em><code>v</code></em><code>):</code><br/>
<code>      </code><strong><code>return</code></strong><code> </code><em><code>u</code></em><code>/</code><em><code>v</code></em></p>

<p>then the call <em>P</em> (<em>quot</em>) will return <em>quot</em>(6,3)*<em>quot</em>(2,1) = (6/3)*(2/1) = 4. Finally, if we define</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>evil</code></em><code>(</code><em><code>z</code></em><code>)</code><br/>
<code>      </code><strong><code>return</code></strong><code> z + 100</code></p>

<p>then the call <em>P</em> (<em>evil</em>) will not make much sense, and may be flagged as an error.</p>
<h3 id="syntactic-details">Syntactic details</h3>

<p>Some programming languages that have this feature may allow or require a complete type declaration for each procedural parameter <em>f</em>, including the number and type of its arguments, and the type of its result, if any. For example, in the C programming language the example above could be written as</p>

<p><code>    int P ( int f (int a, int b) )</code><br/>
<code>      { return f(6,3) * f(2,1); }</code></p>

<p>In principle, the actual function <em>actf</em> that is passed as argument when <em>P</em> is called must be type-compatible with the declared type of the procedure parameter <em>f</em>. This usually means that <em>actf</em> and <em>f</em> must return the same type of result, must have the same number of arguments, and corresponding arguments must have the same type. The names of the arguments need not be the same, however, as shown by the <em>plus</em> and <em>quot</em> examples above. However, some programming languages may me more restrictive or more liberal in this regard.</p>
<h3 id="scoping">Scoping</h3>

<p>In languages that allow procedural parameters, the scoping rules are usually defined in such a way that procedural parameters are executed in their native scope. More precisely, suppose that the function <em>actf</em> is passed as argument to <em>P</em>, as its procedural parameter <em>f</em>; and <em>f</em> is then called from inside the body of <em>P</em>. While <em>actf</em> is being executed, it sees the environment of its definition.</p>

<p>The implementation of these scoping rules is not trivial. By the time that <em>actf</em> is finally executed, the <a href="call_stack#Structure" title="wikilink">activation records</a> where its environment variables live may be arbitrarily deep in the stack. This is the so-called <a href="funarg_problem#Downwards_funarg_problem" title="wikilink">downwards funarg problem</a>.</p>
<h2 id="example-generic-insertion-sort">Example: Generic insertion sort</h2>

<p>The concept of procedural parameter is best explained by examples. A typical application is the following generic implementation of the <a href="insertion_sort" title="wikilink">insertion sort</a> algorithm, that takes two integer parameters <em>a</em>,<em>b</em> and two procedural parameters <em>prec</em>, <em>swap</em>:</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>isort</code></em><code>(</code><em><code>a</code></em><code>, </code><em><code>b</code></em><code>, </code><em><code>prec</code></em><code>, </code><em><code>swap</code></em><code>):</code><br/>
<code>      </code><strong><code>integer</code></strong><code> </code><em><code>i</code></em><code>, </code><em><code>j</code></em><code>;</code><br/>
<code>      </code><em><code>i</code></em><code> </code>

<math display="inline" id="Procedural_parameter:0">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>a</code></em><code>;</code><br/>
<code>      </code><strong><code>while</code></strong><code> </code><em><code>i</code></em><code> </code>

<math display="inline" id="Procedural_parameter:1">
 <semantics>
  <mo>≤</mo>
  <annotation-xml encoding="MathML-Content">
   <leq></leq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq
  </annotation>
 </semantics>
</math>

<code> </code><em><code>b</code></em><code> </code><strong><code>do</code></strong><br/>
<code>        </code><em><code>j</code></em><code> </code>

<math display="inline" id="Procedural_parameter:2">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>i</code></em><br/>
<code>        </code><strong><code>while</code></strong><code> </code><em><code>j</code></em><code> &gt; </code><em><code>a</code></em><code> </code><strong><code>and</code></strong><code> </code><em><code>prec</code></em><code>(</code><em><code>j</code></em><code>, </code><em><code>j</code></em><code>−1) </code><strong><code>do</code></strong><br/>
<code>          </code><em><code>swap</code></em><code>(</code><em><code>j</code></em><code>, </code><em><code>j</code></em><code>−1); </code><em><code>j</code></em><code> </code>

<math display="inline" id="Procedural_parameter:3">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>j</code></em><code>−1</code><br/>
<code>        </code><em><code>i</code></em><code> </code>

<math display="inline" id="Procedural_parameter:4">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>i</code></em><code>+1</code></p>

<p>This procedure can be used to sort the elements <em>x</em>[<em>a</em>] through <em>x</em>[<em>b</em>] of some array <em>x</em>, of arbitrary <a href="datatype" title="wikilink">type</a>, in a user-specified order. The parameters <em>prec</em> and <em>swap</em> should be two <a href="function_(computing)" title="wikilink">functions</a>, defined by the <a href="client_(programming)" title="wikilink">client</a>, both taking two integers <em>r</em>, <em>s</em> between <em>a</em> and <em>b</em>. The <em>prec</em> function should return <strong>true</strong> if and only if the data stored in <em>x</em>[<em>r</em>] should precede the data stored in <em>x</em>[<em>s</em>], in the ordering defined by the client. The <em>swap</em> function should exchange the contents of <em>x</em>[<em>r</em>] and <em>x</em>[<em>s</em>], and return no result.</p>

<p>By the proper choice of the functions <em>prec</em> and <em>swap</em>, the same <em>isort</em> procedure can be used to reorder arrays of any data type, stored in any medium and organized in any data structure that provides indexed access to individual array elements. (Note however that there are <a href="sorting_algorithm" title="wikilink">sorting algorithms</a> that are much more efficient than insertion sort for large arrays.)</p>
<h3 id="sorting-floating-point-numbers">Sorting floating-point numbers</h3>

<p>For instance, we can sort an array <em>z</em> of 20 floating-point numbers, <em>z</em>[1] through <em>z</em>[20] in increasing order by calling <em>isort</em> (1, 20,<em>zprec</em>,<em>zswap</em>), where the functions <em>zprec</em> and <em>zswap</em> are defined as</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>zprec</code></em><code>(</code><em><code>r</code></em><code>,</code><em><code>s</code></em><code>):</code><br/>
<code>      </code><strong><code>return</code></strong><code> (</code><em><code>z</code></em><code>[</code><em><code>r</code></em><code>] </code><code>\gets</code><code> </code><em><code>z</code></em><code>[</code><em><code>r</code></em><code>]; </code><em><code>z</code></em><code>[</code><em><code>r</code></em><code>] </code>

<math display="inline" id="Procedural_parameter:5">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>z</code></em><code>[</code><em><code>s</code></em><code>]; </code><em><code>z</code></em><code>[</code><em><code>s</code></em><code>] </code>

<math display="inline" id="Procedural_parameter:6">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>t</code></em></p>
<h3 id="sorting-rows-of-a-matrix">Sorting rows of a matrix</h3>

<p>For another example, let <em>M</em> be a <a href="matrix_(computing)" title="wikilink">matrix</a> of integers with 10 rows and 20 columns, with indices starting at 1. The following code will rearrange the elements in each row so that all the even values come before all odd values:</p>

<p><code>    </code><strong><code>integer</code></strong><code> i</code><br/>
<code>    </code><strong><code>procedure</code></strong><code> </code><em><code>eoprec</code></em><code>(</code><em><code>r</code></em><code>, </code><em><code>s</code></em><code>):</code><br/>
<code>      </code><strong><code>return</code></strong><code> (</code><em><code>M</code></em><code>[</code><em><code>i</code></em><code>,</code><em><code>r</code></em><code>] </code><strong><code>mod</code></strong><code> 2) </code><code>\gets</code><code> </code><em><code>M</code></em><code>[</code><em><code>i</code></em><code>,</code><em><code>r</code></em><code>]; </code><em><code>M</code></em><code>[</code><em><code>i</code></em><code>,</code><em><code>r</code></em><code>] </code>

<math display="inline" id="Procedural_parameter:7">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>M</code></em><code>[</code><em><code>i</code></em><code>,</code><em><code>s</code></em><code>]; </code><em><code>M</code></em><code>[</code><em><code>i</code></em><code>,</code><em><code>s</code></em><code>] </code>

<math display="inline" id="Procedural_parameter:8">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>t</code></em><br/>
<code> </code><br/>
<code>    </code><strong><code>for</code></strong><code> </code><em><code>i</code></em><code> from 1 </code><strong><code>to</code></strong><code> 10 </code><strong><code>do</code></strong><br/>
<code>      </code><em><code>isort</code></em><code>(1, 20, eoprec, eoswap)</code></p>

<p>Note that the effects of <em>eoprec</em> and <em>eoswap</em> depend on the row number <em>i</em>, but the <em>isort</em> procedure does not need to know that.</p>
<h3 id="vector-sorting-procedure">Vector-sorting procedure</h3>

<p>The following example uses <em>isort</em> to define a procedure <em>vecsort</em> that takes an integer <em>n</em> and an integer vector <em>v</em> with elements <em>v</em>[0] through <em>v</em>[<em>n</em>−1] and sorts them in either increasing or decreasing order, depending on whether a third parameter <em>incr</em> is <strong>true</strong> or <strong>false</strong>, respectively:</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>vecsort</code></em><code>(</code><em><code>n</code></em><code>, </code><em><code>v</code></em><code>, </code><em><code>incr</code></em><code>):</code><br/>
<code> </code><br/>
<code>      </code><strong><code>procedure</code></strong><code> </code><em><code>vprec</code></em><code>(</code><em><code>r</code></em><code>, </code><em><code>s</code></em><code>):</code><br/>
<code>        if </code><em><code>incr</code></em><code> then</code><br/>
<code>          </code><strong><code>return</code></strong><code> </code><em><code>v</code></em><code>[</code><em><code>r</code></em><code>] </code><code> </code><em><code>v</code></em><code>[</code><em><code>s</code></em><code>]</code><br/>
<code> </code><br/>
<code>      </code><strong><code>procedure</code></strong><code> </code><em><code>vswap</code></em><code>(</code><em><code>r</code></em><code>, </code><em><code>s</code></em><code>):</code><br/>
<code>        </code><strong><code>integer</code></strong><code> </code><em><code>t</code></em><code>; </code><em><code>t</code></em><code> </code>

<math display="inline" id="Procedural_parameter:9">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>v</code></em><code>[</code><em><code>r</code></em><code>]; </code><em><code>v</code></em><code>[</code><em><code>r</code></em><code>] </code>

<math display="inline" id="Procedural_parameter:10">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>v</code></em><code>[</code><em><code>s</code></em><code>]; </code><em><code>v</code></em><code>[</code><em><code>s</code></em><code>] </code>

<math display="inline" id="Procedural_parameter:11">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>t</code></em><br/>
<code> </code><br/>
<code>      </code><em><code>isort</code></em><code>(0, </code><em><code>n</code></em><code>−1, </code><em><code>vprec</code></em><code>, </code><em><code>vswap</code></em><code>)</code></p>

<p>Note the use of nested function definitions to get a function <em>vprec</em> whose effect depends on the parameter <em>incr</em> passed to <em>vecsort</em>. In languages that do not allow nested function definitions, like standard C, obtaining this effect would require rather complicated and/or <a href="thread_safety" title="wikilink">thread-unsafe</a> code.</p>
<h2 id="example-merging-two-sequences">Example: merging two sequences</h2>

<p>The following example illustrates the use of procedural parameters to process abstract data structures independently of their concrete implementation. The problem is to merge two ordered sequences of records into a single sorted sequence, where the nature of the records and the ordering criterion can be chosen by the client. The following implementation assumes only that each record can be referenced by a memory address, and there is a "null address" Λ that is not the address of any valid record. The client must provide the addresses <em>A</em>, <em>B</em> of the first records in each sequence, and functions <em>prec</em>, <em>next</em>, and <em>append</em>, to be described later.</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>merge</code></em><code>(</code><em><code>A</code></em><code>, </code><em><code>B</code></em><code>, </code><em><code>prec</code></em><code>, </code><em><code>nextA</code></em><code>, </code><em><code>appendA</code></em><code>, </code><em><code>nextB</code></em><code>, </code><em><code>appendB</code></em><code>):</code><br/>
<code>      </code><strong><code>address</code></strong><code> </code><em><code>ini</code></em><code>, </code><em><code>fin</code></em><code>, </code><em><code>t</code></em><br/>
<code>      </code><em><code>ini</code></em><code> </code>

<math display="inline" id="Procedural_parameter:12">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> Λ; </code><em><code>fin</code></em><code> </code>

<math display="inline" id="Procedural_parameter:13">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> Λ</code><br/>
<code>      </code><strong><code>while</code></strong><code> </code><em><code>A</code></em><code> </code>

<math display="inline" id="Procedural_parameter:14">
 <semantics>
  <mo>≠</mo>
  <annotation-xml encoding="MathML-Content">
   <neq></neq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neq
  </annotation>
 </semantics>
</math>

<code> Λ or </code><em><code>B</code></em><code> </code>

<math display="inline" id="Procedural_parameter:15">
 <semantics>
  <mo>≠</mo>
  <annotation-xml encoding="MathML-Content">
   <neq></neq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neq
  </annotation>
 </semantics>
</math>

<code> Λ </code><strong><code>do</code></strong><br/>
<code>        </code><strong><code>if</code></strong><code> </code><em><code>B</code></em><code> </code>

<math display="inline" id="Procedural_parameter:16">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

<code> Λ </code><strong><code>or</code></strong><code> (</code><em><code>A</code></em><code> </code>

<math display="inline" id="Procedural_parameter:17">
 <semantics>
  <mo>≠</mo>
  <annotation-xml encoding="MathML-Content">
   <neq></neq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neq
  </annotation>
 </semantics>
</math>

<code> Λ </code><strong><code>and</code></strong><code> </code><em><code>B</code></em><code> </code>

<math display="inline" id="Procedural_parameter:18">
 <semantics>
  <mo>≠</mo>
  <annotation-xml encoding="MathML-Content">
   <neq></neq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neq
  </annotation>
 </semantics>
</math>

<code> Λ </code><strong><code>and</code></strong><code> </code><em><code>prec</code></em><code>(</code><em><code>A</code></em><code>,</code><em><code>B</code></em><code>)) </code><strong><code>then</code></strong><br/>
<code>          </code><em><code>t</code></em><code> </code>

<math display="inline" id="Procedural_parameter:19">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>nextA</code></em><code>(</code><em><code>A</code></em><code>)</code><br/>
<code>          </code><em><code>fin</code></em><code> </code>

<math display="inline" id="Procedural_parameter:20">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> appendA(</code><em><code>A</code></em><code>, </code><em><code>fin</code></em><code>); </code><strong><code>if</code></strong><code> </code><em><code>ini</code></em><code> </code>

<math display="inline" id="Procedural_parameter:21">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

<code> Λ </code><strong><code>then</code></strong><code> </code><em><code>ini</code></em><code> </code>

<math display="inline" id="Procedural_parameter:22">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>fin</code></em><br/>
<code>          </code><em><code>A</code></em><code> </code>

<math display="inline" id="Procedural_parameter:23">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>t</code></em><br/>
<code>        </code><strong><code>else</code></strong><br/>
<code>          </code><em><code>t</code></em><code> </code>

<math display="inline" id="Procedural_parameter:24">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>nextB</code></em><code>(</code><em><code>B</code></em><code>)</code><br/>
<code>          </code><em><code>fin</code></em><code> </code>

<math display="inline" id="Procedural_parameter:25">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>appendB</code></em><code>(</code><em><code>B</code></em><code>, </code><em><code>fin</code></em><code>); </code><strong><code>if</code></strong><code> </code><em><code>ini</code></em><code> </code>

<math display="inline" id="Procedural_parameter:26">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

<code> Λ </code><strong><code>then</code></strong><code> </code><em><code>ini</code></em><code> </code>

<math display="inline" id="Procedural_parameter:27">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>fin</code></em><br/>
<code>          </code><em><code>B</code></em><code> </code>

<math display="inline" id="Procedural_parameter:28">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>t</code></em><br/>
<code>      </code><strong><code>return</code></strong><code> </code><em><code>ini</code></em></p>

<p>The function <em>prec</em> should take the addresses <em>r</em>, <em>s</em> of two records, one from each sequence, and return <strong>true</strong> if the first record should come before the other in the output sequence. The function <em>nextA</em> should take the address of a record from the first sequence, and return the address of the next record in the same sequence, or Λ if there is none. The function <em>appendA</em> should append the first record from sequence <em>A</em> to the output sequence; its arguments are the address <em>A</em> of the record to be appended, and the address <em>fin</em> of the last record of the output list (or Λ if that list is still empty). The procedure <em>appendA</em> should return the updated address of the final element of the output list. The procedures <em>nextB</em> and <em>appendB</em> are analogous for the other input sequence.</p>
<h3 id="merging-linked-lists">Merging linked lists</h3>

<p>To illustrate the use of the generic merge procedure, here is the code for merging two simple <a href="linked_list" title="wikilink">linked lists</a>, starting with nodes at addresses <em>R</em>, <em>S</em>. Here we assume that each record <em>x</em> contains an integer field <em>x</em>.<em>INFO</em> and an address field <em>x</em>.<em>NEXT</em> that points to the next node; where the <em>info</em> fields are in increasing order in each list. The input lists are dismantled by the merge, and their nodes are used to build the output list.</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>listmerge</code></em><code>(</code><em><code>R</code></em><code>, </code><em><code>S</code></em><code>):</code><br/>
<br/>
<code>      </code><strong><code>procedure</code></strong><code> </code><em><code>prec</code></em><code>(</code><em><code>r</code></em><code>, </code><em><code>s</code></em><code>):</code><br/>
<code>        </code><strong><code>return</code></strong><code> </code><em><code>r</code></em><code>.</code><em><code>INFO</code></em><code> </code><code>\neq</code><code> Λ </code><strong><code>then</code></strong><code> </code><em><code>fin</code></em><code>.</code><em><code>NEXT</code></em><code> </code>

<math display="inline" id="Procedural_parameter:29">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>x</code></em><br/>
<code>        </code><em><code>x</code></em><code>.</code><em><code>NEXT</code></em><code> </code>

<math display="inline" id="Procedural_parameter:30">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> Λ</code><br/>
<code>        </code><strong><code>return</code></strong><code> </code><em><code>x</code></em><br/>
<code>       </code><br/>
<code>      </code><strong><code>return</code></strong><code> </code><em><code>merge</code></em><code>(</code><em><code>R</code></em><code>, </code><em><code>S</code></em><code>, </code><em><code>prec</code></em><code>, </code><em><code>next</code></em><code>, </code><em><code>append</code></em><code>, </code><em><code>next</code></em><code>, </code><em><code>append</code></em><code>)</code></p>
<h3 id="merging-vectors">Merging vectors</h3>

<p>The following code illustrates the independence of the generic <em>merge</em> procedure from the actual representation of the sequences. It merges the elements of two ordinary arrays <em>U</em>[0] through <em>U</em>[<em>m</em>−1] and <em>V</em>[0] through <em>V</em>[<em>n</em>−1] of floating-point numbers, in decreasing order. The input arrays are not modified, and the merged sequence of values is stored into a third vector <em>W</em>[0] through <em>W</em>[<em>m</em>+<em>n</em>−1]. As in the C programming language, we assume that the expression "&amp;<em>V</em>" yields the address of variable <em>V</em>, "*<em>p</em>" yields the variable whose address is the value of <em>p</em>, and that "&amp;(<em>X</em>[<em>i</em>])" is equivalent to "&amp;(<em>X</em>[0]) + <em>i</em>" for any array <em>X</em> and any integer <em>i</em>.</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>arraymerge</code></em><code>(</code><em><code>U</code></em><code>, </code><em><code>m</code></em><code>, </code><em><code>V</code></em><code>, </code><em><code>n</code></em><code>, </code><em><code>W</code></em><code>):</code><br/>
<code> </code><br/>
<code>      </code><strong><code>procedure</code></strong><code> </code><em><code>prec</code></em><code>(</code><em><code>r</code></em><code>, </code><em><code>s</code></em><code>):</code><br/>
<code>        </code><strong><code>return</code></strong><code> (*</code><em><code>r</code></em><code>) &gt; (*</code><em><code>s</code></em><code>)</code><br/>
<code> </code><br/>
<code>      </code><strong><code>procedure</code></strong><code> </code><em><code>nextU</code></em><code>(</code><em><code>x</code></em><code>):</code><br/>
<code>       </code><strong><code>if</code></strong><code> </code><em><code>x</code></em><code> = &amp;(</code><em><code>U</code></em><code>[</code><em><code>m</code></em><code>−1]) </code><strong><code>then</code></strong><code> </code><strong><code>return</code></strong><code> Λ </code><strong><code>else</code></strong><code> </code><strong><code>return</code></strong><code> </code><em><code>x</code></em><code> + 1</code><br/>
<code> </code><br/>
<code>      </code><strong><code>procedure</code></strong><code> </code><em><code>nextV</code></em><code>(</code><em><code>x</code></em><code>):</code><br/>
<code>        </code><strong><code>if</code></strong><code> </code><em><code>x</code></em><code> = &amp;(</code><em><code>V</code></em><code>[</code><em><code>n</code></em><code>−1]) </code><strong><code>then</code></strong><code> </code><strong><code>return</code></strong><code> Λ </code><strong><code>else</code></strong><code> </code><strong><code>return</code></strong><code> </code><em><code>x</code></em><code> + 1</code><br/>
<code> </code><br/>
<code>      </code><strong><code>procedure</code></strong><code> </code><em><code>append</code></em><code>(</code><em><code>x</code></em><code>, </code><em><code>fin</code></em><code>)</code><br/>
<code>        </code><strong><code>if</code></strong><code> </code><em><code>fin</code></em><code> </code>

<math display="inline" id="Procedural_parameter:31">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

<code> Λ </code><strong><code>then</code></strong><code> </code><em><code>fin</code></em><code> </code>

<math display="inline" id="Procedural_parameter:32">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> &amp;(</code><em><code>W</code></em><code>[0])</code><br/>
<code>        (*</code><em><code>fin</code></em><code>) </code>

<math display="inline" id="Procedural_parameter:33">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> (*</code><em><code>x</code></em><code>)</code><br/>
<code>        </code><strong><code>return</code></strong><code> </code><em><code>fin</code></em><code> + 1</code><br/>
<code>        </code><br/>
<code>      </code><strong><code>if</code></strong><code> </code><em><code>m</code></em><code> = 0 then </code><em><code>U</code></em><code> </code>

<math display="inline" id="Procedural_parameter:34">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> Λ</code><br/>
<code>      </code><strong><code>if</code></strong><code> </code><em><code>n</code></em><code> = 0 then </code><em><code>V</code></em><code> </code>

<math display="inline" id="Procedural_parameter:35">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> Λ</code><br/>
<code>      </code><strong><code>return</code></strong><code> </code><em><code>merge</code></em><code>(</code><em><code>U</code></em><code>, </code><em><code>V</code></em><code>, </code><em><code>prec</code></em><code>, </code><em><code>nextU</code></em><code>, </code><em><code>append</code></em><code>, </code><em><code>nextV</code></em><code>, </code><em><code>append</code></em><code>)</code></p>
<h2 id="example-definite-integral">Example: Definite integral</h2>
<h3 id="integrating-over-an-interval">Integrating over an interval</h3>

<p>The following procedure computes the approximate <a href="integral_(mathematics)" title="wikilink">integral</a> 

<math display="inline" id="Procedural_parameter:36">
 <semantics>
  <msubsup>
   <mo largeop="true" symmetric="true">∫</mo>
   <mi>a</mi>
   <mi>b</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <ci>a</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\int_{a}^{b}
  </annotation>
 </semantics>
</math>

 <em>f</em> (<em>x</em>) d<em>x</em> of a given real-valued <a href="function_(mathematics)" title="wikilink">function</a> <em>f</em> over a given interval [<em>a</em>,<em>b</em>] of the <a href="real_number" title="wikilink">real line</a>. The <a href="numerical_method" title="wikilink">numerical method</a> used is the <a href="trapezium_rule" title="wikilink">trapezium rule</a> with a given number <em>n</em> of steps; the real numbers are approximated by floating-point numbers.</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>Intg</code></em><code>(</code><em><code>f</code></em><code>, </code><em><code>a</code></em><code>, </code><em><code>b</code></em><code>, </code><em><code>n</code></em><code>):</code><br/>
<code>      </code><strong><code>float</code></strong><code> </code><em><code>t</code></em><code>, </code><em><code>x</code></em><code>, </code><em><code>s</code></em><code>; </code><strong><code>integer</code></strong><code> </code><em><code>i</code></em><br/>
<code>      </code><strong><code>if</code></strong><code> </code><em><code>b</code></em><code> = </code><em><code>a</code></em><code> </code><strong><code>then</code></strong><code> </code><strong><code>return</code></strong><code> 0</code><br/>
<code>      </code><em><code>x</code></em><code> </code>

<math display="inline" id="Procedural_parameter:37">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>a</code></em><code>; </code><em><code>s</code></em><code> </code>

<math display="inline" id="Procedural_parameter:38">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>f</code></em><code>(</code><em><code>a</code></em><code>)/2;</code><br/>
<code>      </code><strong><code>for</code></strong><code> i </code><strong><code>from</code></strong><code> 1 </code><strong><code>to</code></strong><code> </code><em><code>n</code></em><code>−1 </code><strong><code>do</code></strong><br/>
<code>        </code><em><code>t</code></em><code> </code>

<math display="inline" id="Procedural_parameter:39">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>i</code></em><code>/(</code><em><code>n</code></em><code>+1); </code><em><code>x</code></em><code> </code>

<math display="inline" id="Procedural_parameter:40">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> (1−</code><em><code>t</code></em><code>)*</code><em><code>a</code></em><code> + </code><em><code>t</code></em><code>*</code><em><code>b</code></em><code>;</code><br/>
<code>        </code><em><code>s</code></em><code> </code>

<math display="inline" id="Procedural_parameter:41">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>s</code></em><code> + </code><em><code>f</code></em><code>(</code><em><code>x</code></em><code>)</code><br/>
<code>      </code><em><code>s</code></em><code> </code>

<math display="inline" id="Procedural_parameter:42">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>f</code></em><code>(</code><em><code>b</code></em><code>)/2</code><br/>
<code>      </code><strong><code>return</code></strong><code> (</code><em><code>b</code></em><code>−</code><em><code>a</code></em><code>)*</code><em><code>s</code></em><code>/</code><em><code>n</code></em></p>
<h3 id="integrating-over-a-disk">Integrating over a disk</h3>

<p>Consider now the problem of integrating a given function <em>g</em>, with two arguments, over a disk <em>D</em> with given center (<em>xc</em>,<em>yc</em>) and given radius <em>R</em>. This problem can be reduced to two nested single-variable integrals by the change of variables</p>

<p>

<math display="block" id="Procedural_parameter:43">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" rspace="0.8pt" symmetric="true">∫</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>D</mi>
     </msub>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <mpadded width="+1.7pt">
       <mi>x</mi>
      </mpadded>
      <mi mathvariant="normal">d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi>R</mi>
    </msubsup>
    <mrow>
     <mi>z</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∫</mo>
        <mn>0</mn>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
        </mrow>
       </msubsup>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>𝑥𝑐</mi>
          <mo>+</mo>
          <mrow>
           <mi>z</mi>
           <mrow>
            <mi>cos</mi>
            <mi>t</mi>
           </mrow>
          </mrow>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>𝑦𝑐</mi>
          <mo>+</mo>
          <mrow>
           <mi>z</mi>
           <mrow>
            <mi>sin</mi>
            <mi>t</mi>
           </mrow>
          </mrow>
         </mrow>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mi mathvariant="normal">d</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
      <mo rspace="4.2pt">)</mo>
     </mrow>
     <mi mathvariant="normal">d</mi>
     <mi>z</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <int></int>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>D</ci>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
       <ci>normal-d</ci>
       <ci>x</ci>
       <ci>normal-d</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <ci>z</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>g</ci>
        <interval closure="open">
         <apply>
          <plus></plus>
          <ci>𝑥𝑐</ci>
          <apply>
           <times></times>
           <ci>z</ci>
           <apply>
            <cos></cos>
            <ci>t</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <ci>𝑦𝑐</ci>
          <apply>
           <times></times>
           <ci>z</ci>
           <apply>
            <sin></sin>
            <ci>t</ci>
           </apply>
          </apply>
         </apply>
        </interval>
        <ci>normal-d</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>normal-d</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int\!\int_{D}g(x,y)\,\mathrm{d}x\,\mathrm{d}y=\int_{0}^{R}z\left(\int_{0}^{2%
\pi}g(\mathit{xc}+z\cos t,\mathit{yc}+z\sin t)\,\mathrm{d}t\right)\,\mathrm{d}z
  </annotation>
 </semantics>
</math>

</p>

<p>The following code implements the <a href="Sides_of_an_equation" title="wikilink">right-hand-side formula</a>:</p>

<p><code>    </code><strong><code>procedure</code></strong><code> </code><em><code>DiskIntg</code></em><code>(</code><em><code>g</code></em><code>, </code><em><code>xc</code></em><code>, </code><em><code>yc</code></em><code>, </code><em><code>R</code></em><code>, </code><em><code>n</code></em><code>)</code><br/>
<code> </code><br/>
<code>      </code><strong><code>procedure</code></strong><code> </code><em><code>gring</code></em><code>(</code><em><code>z</code></em><code>):</code><br/>
<code> </code><br/>
<code>        </code><strong><code>procedure</code></strong><code> </code><em><code>gpolar</code></em><code>(</code><em><code>t</code></em><code>):</code><br/>
<code>          </code><strong><code>float</code></strong><code> </code><em><code>x</code></em><code>, </code><em><code>y</code></em><br/>
<code>          </code><em><code>x</code></em><code> </code>

<math display="inline" id="Procedural_parameter:44">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>xc</code></em><code> + </code><em><code>z</code></em><code>*</code><em><code>cos</code></em><code>(</code><em><code>t</code></em><code>)</code><br/>
<code>          </code><em><code>y</code></em><code> </code>

<math display="inline" id="Procedural_parameter:45">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>yc</code></em><code> + </code><em><code>z</code></em><code>*</code><em><code>sin</code></em><code>(</code><em><code>t</code></em><code>)</code><br/>
<code>          </code><strong><code>return</code></strong><code> </code><em><code>g</code></em><code>(</code><em><code>x</code></em><code>, </code><em><code>y</code></em><code>)</code><br/>
<code> </code><br/>
<code>        </code><strong><code>integer</code></strong><code> </code><em><code>m</code></em><code> </code>

<math display="inline" id="Procedural_parameter:46">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

<code> </code><em><code>round</code></em><code>(</code><em><code>n</code></em><code>*</code><em><code>z</code></em><code>/</code><em><code>R</code></em><code>)</code><br/>
<code>        </code><strong><code>return</code></strong><code> </code><em><code>z</code></em><code>*</code><em><code>Intg</code></em><code>(</code><em><code>gpolar</code></em><code>, 0, 2*π, </code><em><code>m</code></em><code>)</code><br/>
<code> </code><br/>
<code>      </code><strong><code>return</code></strong><code> </code><em><code>Intg</code></em><code>(</code><em><code>gring</code></em><code>, 0, </code><em><code>R</code></em><code>, </code><em><code>n</code></em><code>)</code></p>

<p>This code uses the integration procedure <em>Intg</em> in two levels. The outer level (last line) uses <em>Intg</em> to compute the integral of <em>gring</em>(<em>z</em>) for <em>z</em> varying from 0 to <em>R</em>. The inner level (next-to-last line) defines <em>gring</em>(<em>z</em>) as being the <a href="line_integral" title="wikilink">line integral</a> of <em>g</em>(<em>x</em>,<em>y</em>) over the circle with center (<em>xc</em>,<em>yc</em>) and radius <em>z</em>.</p>
<h2 id="history">History</h2>

<p>Procedural parameters were invented before the age of electronic computers, by <a href="mathematics" title="wikilink">mathematician</a> <a href="Alonzo_Church" title="wikilink">Alonzo Church</a>, as part of his <a href="lambda_calculus" title="wikilink">lambda calculus</a> model of computation.</p>

<p>Procedural parameters as a programming language feature were introduced by <a href="ALGOL_60_programming_language" title="wikilink">ALGOL 60</a>. In fact, ALGOL 60 had a powerful "<a href="call_by_name" title="wikilink">call by name</a>" parameter-passing mechanism that could simplify some uses of procedural parameters; see <a href="Jensen's_Device" title="wikilink">Jensen's Device</a>.</p>

<p>Procedural parameters were an essential feature of the <a href="LISP_programming_language" title="wikilink">LISP programming language</a>, which also introduced the concept of function closure or <a class="uri" href="funarg" title="wikilink">funarg</a>. The <a href="C_programming_language" title="wikilink">C programming language</a> allows <a href="function_pointers" title="wikilink">function pointers</a> to be passed as parameters, which accomplish the same end, and are often used as <a class="uri" href="callbacks" title="wikilink">callbacks</a> in <a href="event-driven_programming" title="wikilink">event-driven programming</a> and as error handlers. However, only a few modern C compilers allow nested function definitions, so that its other uses are relatively uncommon. Procedural parameters were provided also in Pascal, together with nested procedure definitions; however, since standard Pascal did not allow separate compilation, the feature was little used in that language, too.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Function_pointer" title="wikilink">Function pointer</a></li>
<li><a href="Functional_programming" title="wikilink">Functional programming</a></li>
<li><a href="Funarg_problem" title="wikilink">Funarg problem</a></li>
<li><a href="Design_patterns_(computer_science)" title="wikilink">Design patterns (computer science)</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Subroutines" title="wikilink">Category:Subroutines</a></p>
</body>
</html>
