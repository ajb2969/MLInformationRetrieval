<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="745">Discrete logarithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Discrete logarithm</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>discrete logarithm</strong> is an integer <em>k</em> solving the equation <mtpl></mtpl>, where <em>b</em> and <em>g</em> are elements of a finite <a href="Group_(mathematics)" title="wikilink">group</a>. Discrete logarithms are thus the finite-group-theoretic analogue of ordinary <a href="logarithm" title="wikilink">logarithms</a>, which solve the same equation for <a href="real_number" title="wikilink">real numbers</a> <em>b</em> and <em>g</em>, where <em>b</em> is the base of the logarithm and <em>g</em> is the value whose logarithm is being taken.</p>

<p>Computing discrete logarithms is believed to be difficult. No efficient general method for computing discrete logarithms on conventional computers is known, and several important algorithms in <a href="public-key_cryptography" title="wikilink">public-key cryptography</a> base their security on the assumption that the discrete logarithm problem has no efficient solution.</p>
<h2 id="example">Example</h2>

<p>Discrete logarithms are perhaps simplest to understand in the group <a href="Multiplicative_group_of_integers_modulo_n" title="wikilink">(<strong>Z</strong><sub><em>p</em></sub>)<sup>√ó</sup></a>. This is the group of multiplication <a href="modular_arithmetic" title="wikilink">modulo</a> the <a href="prime_number" title="wikilink">prime</a> <em>p</em>. Its elements are <a href="congruence_class" title="wikilink">congruence classes</a> modulo <em>p</em>, and the group product of two elements may be obtained by ordinary integer multiplication of the elements followed by reduction modulo¬†<em>p</em>.</p>

<p>The <em>k</em>th <a href="exponentiation" title="wikilink">power</a> of one of the numbers in this group may be computed by finding its <em>k</em>th power as an integer and then finding the remainder after division by <em>p</em>. When the numbers involved are large, it is more efficient to reduce modulo <em>p</em> multiple times during the computation. Regardless of the specific algorithm used, this operation is called <a href="modular_exponentiation" title="wikilink">modular exponentiation</a>. For example, consider (<strong>Z</strong><sub>17</sub>)<sup>√ó</sup>. To compute 3<sup>4</sup> in this group, compute 3<sup>4</sup> = 81, and then divide 81 by 17, obtaining a remainder of 13. Thus 3<sup>4</sup> = 13 in the group (<strong>Z</strong><sub>17</sub>)<sup>√ó</sup>.</p>

<p>The discrete logarithm is just the inverse operation. For example, consider the equation 3<sup><em>k</em></sup> ‚â° 13 (mod 17) for <em>k</em>. From the example above, one solution is <em>k</em>¬†=¬†4, but it is not the only solution. Since 3<sup>16</sup> ‚â° 1 (mod 17)‚Äîas follows from <a href="Fermat's_little_theorem" title="wikilink">Fermat's little theorem</a>‚Äîit also follows that if <em>n</em> is an integer then 3<sup>4+16<em>n</em></sup> ‚â° 3<sup>4</sup> √ó (3<sup>16</sup>)<sup><em>n</em></sup> ‚â° 13 √ó 1<sup><em>n</em></sup> ‚â° 13 (mod 17). Hence the equation has infinitely many solutions of the form 4 + 16<em>n</em>. Moreover, since 16 is the smallest positive integer <em>m</em> satisfying 3<sup><em>m</em></sup> ‚â° 1 (mod 17), i.e. 16 is the <a href="Multiplicative_order" title="wikilink">order</a> of 3 in (<strong>Z</strong><sub>17</sub>)<sup>√ó</sup>, these are the only solutions. Equivalently, the set of all possible solutions can be expressed by the constraint that <em>k</em> ‚â° 4 (mod 16).</p>
<h2 id="definition">Definition</h2>

<p>In general, let <em>G</em> be any group, with its group operation denoted by multiplication. Let <em>b</em> and <em>g</em> be any elements of <em>G</em>. Then any integer <em>k</em> that solves <em>b</em><sup><em>k</em></sup> = <em>g</em> is termed a <strong>discrete logarithm</strong> (or simply <strong>logarithm</strong>, in this context) of <em>g</em> to the base <em>b</em>. We write <em>k</em> = log<sub><em>b</em></sub> <em>g</em>. Depending on <em>b</em> and <em>g</em>, it is possible that no discrete logarithm exists, or that more than one discrete logarithm exists. Let <em>H</em> be the <a class="uri" href="subgroup" title="wikilink">subgroup</a> of <em>G</em> <a href="generating_set_of_a_group" title="wikilink">generated</a> by <em>b</em>. Then <em>H</em> is a <a href="cyclic_group" title="wikilink">cyclic group</a>, and integral log<sub><em>b</em></sub> <em>g</em> exists for all <em>g</em> in <em>H</em>. If <em>H</em> is infinite, then log<sub><em>b</em></sub> <em>g</em> is also unique, and the discrete logarithm amounts to a <a href="group_isomorphism" title="wikilink">group isomorphism</a></p>

<p>

<math display="block" id="Discrete_logarithm:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>log</mi>
     <mi>b</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mi>H</mi>
     <mo>‚Üí</mo>
     <mi>ùêô</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <ci>b</ci>
    </apply>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>H</ci>
     <ci>ùêô</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{b}\colon H\rightarrow\mathbf{Z}.
  </annotation>
 </semantics>
</math>

</p>

<p>On the other hand, if <em>H</em> is finite of size <em>n</em>, then log<sub><em>b</em></sub> <em>g</em> is unique only up to congruence modulo <em>n</em>, and the discrete logarithm amounts to a group isomorphism</p>

<p>

<math display="block" id="Discrete_logarithm:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>log</mi>
     <mi>b</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mi>H</mi>
     <mo>‚Üí</mo>
     <msub>
      <mi>ùêô</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <ci>b</ci>
    </apply>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùêô</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{b}\colon H\rightarrow\mathbf{Z}_{n},
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>Z</strong><sub><em>n</em></sub> denotes the <a href="ring_(algebra)" title="wikilink">ring</a> of integers modulo <em>n</em>. The familiar base change formula for ordinary logarithms remains valid: If <em>c</em> is another generator of <em>H</em>, then</p>

<p>

<math display="block" id="Discrete_logarithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>log</mi>
      <mi>c</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>c</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>‚ãÖ</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>b</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>g</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <ci>c</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <ci>c</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <ci>b</ci>
      </apply>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{c}(g)=\log_{c}(b)\cdot\log_{b}(g).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="algorithms">Algorithms</h2>

<p>No efficient classical algorithm for computing general discrete logarithms log<sub><em>b</em></sub> <em>g</em> is known. The naive algorithm is to raise <em>b</em> to higher and higher powers <em>k</em> until the desired <em>g</em> is found; this is sometimes called <em>trial multiplication</em>. This algorithm requires <a href="running_time" title="wikilink">running time</a> linear in the size of the group <em>G</em> and thus exponential in the number of digits in the size of the group. There exists an efficient quantum algorithm due to <a href="Peter_Shor" title="wikilink">Peter Shor</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>More sophisticated algorithms exist, usually inspired by similar algorithms for integer factorization. These algorithms run faster than the naive algorithm, some of them linear in the <em>square root</em> of the size of the group, and thus exponential in half the number of digits in the size of the group. However none of them runs in <a href="polynomial_time" title="wikilink">polynomial time</a> (in the number of digits in the size of the group).</p>
<ul>
<li><a href="Baby-step_giant-step" title="wikilink">Baby-step giant-step</a></li>
<li><a href="Function_field_sieve" title="wikilink">Function field sieve</a></li>
<li><a href="Index_calculus_algorithm" title="wikilink">Index calculus algorithm</a></li>
<li><a href="Number_field_sieve" title="wikilink">Number field sieve</a></li>
<li><a href="Pohlig‚ÄìHellman_algorithm" title="wikilink">Pohlig‚ÄìHellman algorithm</a></li>
<li><a href="Pollard's_rho_algorithm_for_logarithms" title="wikilink">Pollard's rho algorithm for logarithms</a></li>
<li><a href="Pollard's_kangaroo_algorithm" title="wikilink">Pollard's kangaroo algorithm</a> (aka Pollard's lambda algorithm)</li>
</ul>
<h2 id="comparison-with-integer-factorization">Comparison with integer factorization</h2>

<p>While computing discrete logarithms and <a href="integer_factorization" title="wikilink">factoring integers</a> are distinct problems, they share some properties:</p>
<ul>
<li>both problems are difficult (no efficient <a href="algorithm" title="wikilink">algorithms</a> are known for non-<a href="quantum_computer" title="wikilink">quantum computers</a>),</li>
<li>for both problems efficient algorithms on quantum computers are known,</li>
<li>algorithms from one problem are often adapted to the other, and</li>
<li>the difficulty of both problems has been used to construct various <a href="cryptography" title="wikilink">cryptographic</a> systems.</li>
</ul>
<h2 id="cryptography">Cryptography</h2>

<p>There exist groups for which computing discrete logarithms is apparently difficult. In some cases (e.g. large prime order subgroups of groups (<strong>Z</strong><sub><em>p</em></sub>)<sup>√ó</sup>) there is not only no efficient algorithm known for the worst case, but the <a href="average-case_complexity" title="wikilink">average-case complexity</a> can be shown to be about as hard as the worst case using <a href="random_self-reducibility" title="wikilink">random self-reducibility</a>.</p>

<p>At the same time, the inverse problem of discrete exponentiation is not difficult (it can be computed efficiently using <a href="exponentiation_by_squaring" title="wikilink">exponentiation by squaring</a>, for example). This asymmetry is analogous to the one between integer factorization and integer <a class="uri" href="multiplication" title="wikilink">multiplication</a>. Both asymmetries have been exploited in the construction of cryptographic systems.</p>

<p>Popular choices for the group <em>G</em> in discrete logarithm <a class="uri" href="cryptography" title="wikilink">cryptography</a> are the cyclic groups (<strong>Z</strong><sub><em>p</em></sub>)<sup>√ó</sup> (e.g. <a href="ElGamal_encryption" title="wikilink">ElGamal encryption</a>, <a href="Diffie‚ÄìHellman_key_exchange" title="wikilink">Diffie‚ÄìHellman key exchange</a>, and the <a href="Digital_Signature_Algorithm" title="wikilink">Digital Signature Algorithm</a>) and cyclic subgroups of <a href="elliptic_curve" title="wikilink">elliptic curves</a> over <a href="finite_field" title="wikilink">finite fields</a> (<em>see</em> <a href="elliptic_curve_cryptography" title="wikilink">elliptic curve cryptography</a>).</p>
<h2 id="references">References</h2>
<ul>
<li><a href="Richard_Crandall" title="wikilink">Richard Crandall</a>; <a href="Carl_Pomerance" title="wikilink">Carl Pomerance</a>. Chapter 5, <em>Prime Numbers: A computational perspective</em>, 2nd ed., Springer.</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Modular_arithmetic" title="wikilink">Category:Modular arithmetic</a> <a href="Category:Group_theory" title="wikilink">Category:Group theory</a> <a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a> <a class="uri" href="Category:Logarithms" title="wikilink">Category:Logarithms</a> <a href="Category:Finite_fields" title="wikilink">Category:Finite fields</a> <a href="Category:Binary_operations" title="wikilink">Category:Binary operations</a> <a href="Category:Computational_hardness_assumptions" title="wikilink">Category:Computational hardness assumptions</a> <a href="Category:Unsolved_problems_in_computer_science" title="wikilink">Category:Unsolved problems in computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
