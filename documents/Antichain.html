<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="253">Antichain</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Antichain</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, in the area of <a href="order_theory" title="wikilink">order theory</a>, an <strong>antichain</strong> is a subset of a <a href="partially_ordered_set" title="wikilink">partially ordered set</a> such that any two elements in the subset are incomparable. (Some authors use the term "antichain" to mean <a href="strong_antichain" title="wikilink">strong antichain</a>, a subset such that there is no element of the <a href="Partially_ordered_set" title="wikilink">poset</a> smaller than two distinct elements of the antichain.)</p>

<p>Let <em>S</em> be a partially ordered set. We say two elements <em>a</em> and <em>b</em> of a partially ordered set are <strong><a href="Comparability" title="wikilink">comparable</a></strong> if <em>a</em> ≤ <em>b</em> or <em>b</em> ≤ <em>a</em>. If two elements are not comparable, we say they are <strong>incomparable</strong>; that is, <em>x</em> and <em>y</em> are incomparable if neither <em>x</em> ≤ <em>y</em> nor <em>y</em> ≤ <em>x</em>.</p>

<p>A <strong>chain</strong> in <em>S</em> is a <a class="uri" href="subset" title="wikilink">subset</a> <em>C</em> of <em>S</em> in which each pair of elements is comparable; that is, <em>C</em> is <a href="Total_order" title="wikilink">totally ordered</a>. An <strong>antichain</strong> in <em>S</em> is a <a class="uri" href="subset" title="wikilink">subset</a> <em>A</em> of <em>S</em> in which each pair of different elements is incomparable; that is, there is no order relation between any two different elements in <em>A</em>.</p>
<h2 id="height-and-width">Height and width</h2>

<p>A <strong>maximal antichain</strong> is an antichain that is not a <a href="proper_subset" title="wikilink">proper subset</a> of any other antichain. A <strong>maximum antichain</strong> is an antichain that has cardinality at least as large as every other antichain. The <em>width</em> of a partially ordered set is the cardinality of a maximum antichain. Any antichain can intersect any chain in at most one element, so, if we can partition the elements of an order into <em>k</em> chains then the width of the order must be at most <em>k</em>. <a href="Dilworth's_theorem" title="wikilink">Dilworth's theorem</a> states that this bound can always be reached: there always exists an antichain, and a partition of the elements into chains, such that the number of chains equals the number of elements in the antichain, which must therefore also equal the width. Similarly, we can define the <em>height</em> of a partial order to be the maximum cardinality of a chain. <a href="Mirsky's_theorem" title="wikilink">Mirsky's theorem</a> states similarly that in any partial order of finite height, the height equals the smallest number of antichains into which the order may be partitioned.</p>
<h2 id="sperner-families">Sperner families</h2>

<p>An antichain in the inclusion ordering of subsets of an <em>n</em>-element set is known as a <a href="Sperner_family" title="wikilink">Sperner family</a>. The number of different Sperner families is counted by the <a href="Dedekind_number" title="wikilink">Dedekind numbers</a>, the first few of which numbers are</p>
<dl>
<dd>2, 3, 6, 20, 168, 7581, 7828354, 2414682040998, 56130437228687557907788 .
</dd>
</dl>

<p>Even the empty set has two antichains in its power set: one containing a single set (the empty set itself) and one containing no sets.</p>
<h2 id="join-and-meet-operations">Join and meet operations</h2>

<p>Any antichain <em>A</em> corresponds to a <a href="lower_set" title="wikilink">lower set</a></p>

<p>

<math display="block" id="Antichain:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>A</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <mo>∃</mo>
       <mi>y</mi>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mi>A</mi>
       <mtext>s.t.</mtext>
       <mi>x</mi>
      </mrow>
      <mo>≤</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <apply>
        <exists></exists>
        <ci>y</ci>
       </apply>
       <apply>
        <times></times>
        <ci>A</ci>
        <mtext>s.t.</mtext>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{A}=\{x\mid\exists y\in A\mbox{ s.t. }x\leq y\}.
  </annotation>
 </semantics>
</math>

 In a finite partial order (or more generally a partial order satisfying the <a href="ascending_chain_condition" title="wikilink">ascending chain condition</a>) all lower sets have this form. The union of any two lower sets is another lower set, and the union operation corresponds in this way to a <strong>join</strong> operation on antichains:</p>

<p>

<math display="block" id="Antichain:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mo>∨</mo>
     <mi>B</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mrow>
       <mi>A</mi>
       <mo>∪</mo>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <mo>∄</mo>
       <mi>y</mi>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mi>A</mi>
       <mo>∪</mo>
       <mrow>
        <mi>B</mi>
        <mtext>s.t.</mtext>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo><</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <apply>
       <union></union>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="latexml">not-exists</csymbol>
        <ci>y</ci>
       </apply>
       <apply>
        <union></union>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>B</ci>
         <mtext>s.t.</mtext>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <lt></lt>
       <share href="#.cmml">
       </share>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vee B=\{x\in A\cup B\mid\not\exists y\in A\cup B\mbox{ s.t. }x<y\}.
  </annotation>
 </semantics>
</math>

 Similarly, we can define a <strong>meet</strong> operation on antichains, corresponding to the intersection of lower sets:</p>

<p>

<math display="block" id="Antichain:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mrow>
       <msub>
        <mi>L</mi>
        <mi>A</mi>
       </msub>
       <mo>∩</mo>
       <msub>
        <mi>L</mi>
        <mi>B</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <mo>∄</mo>
       <mi>y</mi>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <msub>
        <mi>L</mi>
        <mi>A</mi>
       </msub>
       <mo>∩</mo>
       <mrow>
        <msub>
         <mi>L</mi>
         <mi>B</mi>
        </msub>
        <mtext>s.t.</mtext>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo><</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <apply>
       <intersect></intersect>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="latexml">not-exists</csymbol>
        <ci>y</ci>
       </apply>
       <apply>
        <intersect></intersect>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>A</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>L</ci>
          <ci>B</ci>
         </apply>
         <mtext>s.t.</mtext>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <lt></lt>
       <share href="#.cmml">
       </share>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\wedge B=\{x\in L_{A}\cap L_{B}\mid\not\exists y\in L_{A}\cap L_{B}\mbox{ s.t%
. }x<y\}.
  </annotation>
 </semantics>
</math>

 The join and meet operations on all finite antichains of finite subsets of a set <em>X</em> define a <a href="distributive_lattice" title="wikilink">distributive lattice</a>, the free distributive lattice generated by <em>X</em>. <a href="Birkhoff's_representation_theorem" title="wikilink">Birkhoff's representation theorem</a> for distributive lattices states that every finite distributive lattice can be represented via join and meet operations on antichains of a finite partial order, or equivalently as union and intersection operations on the <a href="lower_set" title="wikilink">lower sets</a> of the partial order.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Dedekind_number" title="wikilink">Dedekind number</a>, the number of antichains in the power set of a finite set</li>
<li><a href="Strong_antichain" title="wikilink">Strong antichain</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Order_theory" title="wikilink">Category:Order theory</a> <a href="Category:Integer_sequences" title="wikilink">Category:Integer sequences</a></p>
</body>
</html>
