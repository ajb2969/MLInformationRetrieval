   Range query (data structures)      Range query (data structures)  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In data structures , a range query consists of preprocessing some input data into a data structure to efficiently answer any number of queries on any subset of the input. Particularly, there is a group of problems that have been extensively studied where the input is an array of unsorted numbers and a query consists in computing some function on a specific range of the array. In this article we describe some of these problems together with their solutions.  Problem statement  We may state the problem of range queries in the following way: a range query     q  f    (  A  ,  i  ,  j  )        subscript  q  f    A  i  j     q_{f}(A,i,j)   on an array    A  =   [   a  1   ,   a  2   ,  .  .  ,   a  n   ]      fragments  A    fragments  normal-[   subscript  a  1   normal-,   subscript  a  2   normal-,  normal-.  normal-.  normal-,   subscript  a  n   normal-]     A=[a_{1},a_{2},..,a_{n}]   of n elements of some set   S   S   S   , denoted    A   [  1  ,  n  ]       A   1  n     A[1,n]   , takes two indices    1  ≤  i  ≤  j  ≤  n        1  i       j       n     1\leq i\leq j\leq n   , a function   f   f   f   defined over arrays of elements of   S   S   S   and outputs     f   (   A   [  i  ,  j  ]    )    =   f   (   a  i   ,  …  ,   a  j   )          f    A   i  j       f    subscript  a  i   normal-…   subscript  a  j       f(A[i,j])=f(a_{i},\ldots,a_{j})   . This should be done space and time efficient.  consider for instance    f  =   s  u  m       f    s  u  m     f=sum   and    A   [  1  ,  n  ]       A   1  n     A[1,n]   an array of numbers, the range query    s  u  m   (  A  ,  i  ,  j  )       s  u  m   A  i  j     sum(A,i,j)   computes     s  u  m   (   A   [  i  ,  j  ]    )    =   (    a  i   +  …  +   a  j    )         s  u  m    A   i  j        subscript  a  i   normal-…   subscript  a  j      sum(A[i,j])=(a_{i}+\ldots+a_{j})   , for any    1  ≤  i  ≤  j  ≤  n        1  i       j       n     1\leq i\leq j\leq n   . These queries may be answered in constant time and using    O   (  n  )       O  n    O(n)   extra space by calculating the sums of the first   i   i   i   elements of   A   A   A   and storing them into an auxiliar array   B   B   B   , such that    B   [  i  ]       B   delimited-[]  i     B[i]   contains the sum of the first   i   i   i   elements of   A   A   A   for every    0  ≤  i  ≤  n        0  i       n     0\leq i\leq n   .Therefore any query might be answered by doing     s  u  m   (   A   [  i  ,  j  ]    )    =    B   [  j  ]    -   B   [   i  -  1   ]           s  u  m    A   i  j         B   delimited-[]  j      B   delimited-[]    i  1        sum(A[i,j])=B[j]-B[i-1]   .  This strategy may be extended for every group operator   f   f   f   where the notion of    f   -  1      superscript  f    1     f^{-1}   is well defined and easily computable. 1 Finally notice this solution might be extended for arrays of dimension two with a similar preprocessing. 2  Examples  Semigroup operators    When the function of interest in a range query is a semigroup operator the notion of    f   -  1      superscript  f    1     f^{-1}   is not always defined, therefore we can not use an analogous strategy to the previous section. Yao showed 3 that there exists an efficient solution for range queries that involve semigroup operators. He proved that for any constant   c   c   c   , a preprocessing of time and space    θ   (   c  ⋅  n   )       θ   normal-⋅  c  n     \theta(c\cdot n)   allows to answer range queries on lists where   f   f   f   is a semigroup operator in    θ   (    α  c    (  n  )    )       θ     subscript  α  c   n     \theta(\alpha_{c}(n))   time, where    α  k     subscript  α  k    \alpha_{k}   is a certain functional inverse of the Ackermann function .  There are some semigroup operators that admit slightly better solutions. For instance when    f  ∈   {  max  ,  min  }       f        f\in\{\max,\min\}   . Assume    f  =  min      f     f=\min   then    min   (   A   [   1..  n   ]    )         A   delimited-[]    1..  n       \min(A[1..n])   returns the index of the minimum element of    A   [   1..  n   ]       A   delimited-[]    1..  n      A[1..n]   . Then    min   (  A  ,  i  ,  j  )       A  i  j    \min(A,i,j)   denotes the corresponding minimum range query. There are several data structures that allow to answer a range minimum query in    O   (  1  )       O  1    O(1)   time using a preprocessing of time and space    O   (  n  )       O  n    O(n)   . Probably the simplest solution to sketch here is based on the equivalence between this problem and the Lowest common ancestor problem. We briefly describe this solution.  The cartesian tree     T  A     subscript  T  A    T_{A}   of an array    A   [  1  ,  n  ]       A   1  n     A[1,n]   has as root     a  i   =   m  i  n   {   a  1   ,   a  2   ,  …  ,   a  n   }         subscript  a  i     m  i  n    subscript  a  1    subscript  a  2   normal-…   subscript  a  n       a_{i}=min\{a_{1},a_{2},\ldots,a_{n}\}   and it has as left and right subtrees the cartesian tree of    A   [  1  ,   i  -  1   ]       A   1    i  1      A[1,i-1]   and the cartesian tree of    A   [   i  +  1   ,  n  ]       A     i  1   n     A[i+1,n]   respectively. It is easy to see that a range minimum query    m  i  n   (  A  ,  i  ,  j  )       m  i  n   A  i  j     min(A,i,j)   is the lowest common ancestor in    T  A     subscript  T  A    T_{A}   of    a  i     subscript  a  i    a_{i}   and    a  j     subscript  a  j    a_{j}   . Since the lowest common ancestor is solvable in constant time using a preprocessing of time and space    O   (  n  )       O  n    O(n)   thus so does the range minimum query problem. The solution when f = max is analogous. Cartesian trees can be constructed in linear time.  Mode  The mode of an array A is the element that appears the most in A . For instance the mode of    A  =   [  4  ,  5  ,  6  ,  7  ,  4  ,  ]      fragments  A    fragments  normal-[  4  normal-,  5  normal-,  6  normal-,  7  normal-,  4  normal-,  normal-]     A=[4,5,6,7,4,]   is 4 . In case of ties any of the most frequent elements might be picked as mode. A range mode query consists in preprocessing    A   [  1  ,  n  ]       A   1  n     A[1,n]   such that we can find the mode in any range of    A   [  1  ,  n  ]       A   1  n     A[1,n]   . Several data structures have been devised to solve this problem, we summarize some of the results in the following table. 4      Range Mode Queries         Space   Query Time   Restrictions         O   (   n   2  -   2  ϵ     )       O   superscript  n    2    2  ϵ       O(n^{2-2\epsilon})          O   (    n  ϵ    log  n    )       O     superscript  n  ϵ     n      O(n^{\epsilon}\log n)          0  ≤  ϵ  ≤   1  /  2         0  ϵ         1  2      0\leq\epsilon\leq 1/2            O   (    n  2    log   log   n  /   log  n       )       O     superscript  n  2         n    n         O(n^{2}\log\log n/\log n)          O   (  1  )       O  1    O(1)           Recently Jørgensen et al. proved a lower bound on the cell probe model of    Ω   (    log  n    log   (    S  w   /  n   )     )       normal-Ω      n         S  w   n       \Omega\left(\frac{\log n}{\log(Sw/n)}\right)   for any data structure that uses   S   S   S   cells. 5  Median  This particular case is of special interest since finding the median has several applications, for further reference see. 6 On the other hand, the median problem, a special case of the selection problem , is solvable in O( n ), by the median of medians algorithm. 7 However its generalization through range median queries is recent. 8 A range median query    m  e  d  i  a  n   (  A  ,  i  ,  j  )       m  e  d  i  a  n   A  i  j     median(A,i,j)   where A,i and j have the usual meanings returns the median element of    A   [  i  ,  j  ]       A   i  j     A[i,j]   . Equivalently,    m  e  d  i  a  n   (  A  ,  i  ,  j  )       m  e  d  i  a  n   A  i  j     median(A,i,j)   should return the element of    A   [  i  ,  j  ]       A   i  j     A[i,j]   of rank     j  -  i   2        j  i   2    \frac{j-i}{2}   . Note that range median queries can not be solved by following any of the previous methods discussed above including Yao's approach for semigroup operators. 9  There have been studied two variants of this problem, the offline version, where all the k queries of interest are given in a batch and we are interested in reduce the total cost and a version where all the preprocessing is done up front and we are interested in optimize the cost of any subsequent single query. Concerning the first variant of the problem recently was proven that can be solved in time    O   (    n   log  k    +   k   log  n     )       O      n    k      k    n       O(n\log k+k\log n)   and space    O   (   n   log  k    )       O    n    k      O(n\log k)   . We describe such a solution. 10  The following pseudo code shows how to find the element of rank   r   r   r   in    A   [  i  ,  j  ]       A   i  j     A[i,j]   an unsorted array of distinct elements, to find the range medians we set    r  =    j  -  i   2       r      j  i   2     r=\frac{j-i}{2}   .  rangeMedian(A,i,j,r){ if A.length() == 1  return A[ 1 ] if A.low is undefined then
     m = median(A)
     A.low  = [e in A | e <= m]
     A.high = [e in A | e > m ]
 
  calculate t  the number of elements of A[i,j] that belong to A.low if r <= t return rangeMedian(A.low, i,j,r) else  return rangeMedian(A.high, i,j, r-t)
 }  Procedure rangeMedian partitions A, using A's median, into two arrays A.low and A.high , where the former contains the elements of A that are less than or equal to the median m and the latter the rest of the elements of A . If we know that the number of elements of    A   [  i  ,  j  ]       A   i  j     A[i,j]   that end up in A.low is t and this number is bigger than r then we should keep looking for the element of rank r in A.low else we should look for the element of rank    (   r  -  t   )      r  t    (r-t)   in A.high. To find   t   t   t   , it is enough to find the maximum index    m  ≤   i  -  1       m    i  1     m\leq i-1   such that    a  m     subscript  a  m    a_{m}   is in A.low and the maximum index    l  ≤  j      l  j    l\leq j   such that    a  l     subscript  a  l    a_{l}   is in A.high. Then    t  =   l  -  m       t    l  m     t=l-m   . The total cost for any query, without considering the partitioning part, is    log  n      n    \log n   since at most    log  n      n    \log n   recursion calls are done and only a constant number of operations are performed in each of them (to get the value of   t   t   t    fractional cascading should be used). If a linear algorithm to find the medians is used, the total cost of preprocessing for   k   k   k   range median queries is    n   log  k       n    k     n\log k   . Clearly this algorithm can be easily modified to solve the up front version of the problem. 11  Related Problems  All the problems described above have been studied for higher dimensions as well as their dynamic versions. On the other hand, range queries might be extended to other data structures like trees , 12 such as the level ancestor problem . A similar family of problems are orthogonal range queries also known as counting queries.  References  External links   Open Data Structure - Chapter 13 - Data Structures for Integers  Data Structures for Range Median Queries - Gerth Stolting Brodal and Allan Gronlund Jorgensen   "  Category:Arrays  Category:Articles created via the Article Wizard     ↩  ↩  ↩   ↩  ↩  ↩    ↩   ↩    