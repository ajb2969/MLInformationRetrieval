<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="700">Run-time estimation of system and sub-system level power consumption</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Run-time estimation of system and sub-system level power consumption</h1>
<hr/>

<p>Electronic systems’ <strong><a href="power_consumption" title="wikilink">power consumption</a></strong> has been a real challenge for Hardware and Software designers as well as users especially in portable devices like cell phones and laptop computers. Power consumption also has been an issue for many industries that use computer systems heavily such as Internet service providers using servers or companies with many employees using computers and other computational devices.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Many different approaches (during design of HW, SW or real-time estimation) have been discovered by researchers to estimate power consumption efficiently. This survey paper focuses on the different methods where power consumption can be estimated or measured in real-time.</p>

<p>Measuring real time power dissipation is critical in thermal analysis of a new design of HW like processors (CPU) just as it is important for OS programmers writing process schedulers.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Researchers discovered that knowing the real-time power consumption on a subsystem level like CPU, hard drives, memory and other devices can help power optimizations in applications such as storage encryption, virtualization, and application sandboxing, as well as application tradeoffs.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Different technologies have been discovered that can enable measuring power consumption in real-time. They can be ranked in two main categories: direct measurement using subsystem power sensors and meters or indirect estimation based on provided information like temperature or performance counters.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> There are also different methods within each category; for example, different models are discovered to use performance counters for power estimation. Each one of these methods has its own benefits and disadvantages. The goal of this paper is to <strong><a href="survey_article" title="wikilink">survey</a></strong> that different methods in each category.</p>
<h2 id="run-time-estimation-of-system-and-sub-system-level-power-consumption">Run-time Estimation of System and Sub-system Level Power Consumption</h2>

<p>Power consumption can be different for the same type of system because of differences in manufacturing of Hardware and in temperature conditions in which the device is going to operate. Real-Time power management can be used to optimize the system or subsystems to minimize the energy consumption which may, for example, extend the battery lifetime of mobile devices or result in energy savings for Internet companies operating with many computer servers.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The following sections are technologies discovered to enable real-time power estimation.</p>
<h2 id="indirect-power-measurement">Indirect Power measurement</h2>

<p>Indirect power measurement such as using a CPU performance monitoring unit (PMU),<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> or performance counters to estimate run-time CPU and memory power consumption <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> are widely used for their low cost.</p>
<h3 id="performance-counters">Performance counters</h3>

<p>What are <strong><a href="performance_counters" title="wikilink">performance counters</a></strong>? <a href="Hardware_performance_counter" title="wikilink">Hardware performance counters</a> (HPCs) are a set of special purpose registers built into modern microprocessors to store the counts of hardware-related activities for hardware and software related events.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Different models of processors have limited numbers of hardware counters with different events that will satisfy the CPU requirement.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> These performance counters are usually accurate and provide important detailed information about processor performance at the clock cycle granularity.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Researchers were able to create different models that use the HPCs event to estimate the system power consumption in real-time.</p>
<h4 id="first-order-linear-power-estimation-model-using-performance-counters">First-order, linear power estimation model using performance counters</h4>

<p>The first-order linear model was developed by G. Contreras and M. Martonosi at Princeton University using Intel PXA255 processor to estimate CPU and memory power consumption.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> This is distinct from previous work that uses HPCs to estimate power because the Intel PXA255 processor power requirement was tighter and it offered fewer available performance events compared to mid and high-end processors.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> This method is also not tied to specific processor technology and HPCs layout for power estimation but rather can be used for any type of processor with HPCs.</p>

<p>This linear power model uses five performance events as follows: Instruction Executed, Data Dependencies, Instruction Cache Miss, Data TLB Misses, and Instruction TLB Misses. A linear model expression is derived (equation 1) as follows assuming a linear correlation between performance counters values and power consumption.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>o</mi>
   <mi>w</mi>
   <mi>e</mi>
   <msub>
    <mi>r</mi>
    <mrow>
     <mi>c</mi>
     <mi>p</mi>
     <mi>u</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mo>∝</mo>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>I</mi>
    <mi>F</mi>
    <mi>e</mi>
    <mi>t</mi>
    <mi>c</mi>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>m</mi>
      <mi>i</mi>
      <mi>s</mi>
      <mi>s</mi>
     </mrow>
    </msub>
    <mo>)</mo>
   </mrow>
   <mo>+</mo>
   <msub>
    <mo>∝</mo>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>D</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>D</mi>
    <mi>e</mi>
    <mi>p</mi>
    <mo>)</mo>
   </mrow>
   <mo>+</mo>
   <msub>
    <mo>∝</mo>
    <mn>3</mn>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>D</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>T</mi>
    <mi>L</mi>
    <msub>
     <mi>B</mi>
     <mrow>
      <mi>m</mi>
      <mi>i</mi>
      <mi>s</mi>
      <mi>s</mi>
     </mrow>
    </msub>
    <mo>)</mo>
   </mrow>
   <mo>+</mo>
   <msub>
    <mo>∝</mo>
    <mn>4</mn>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>I</mi>
    <mi>n</mi>
    <mi>s</mi>
    <mi>T</mi>
    <mi>L</mi>
    <msub>
     <mi>B</mi>
     <mrow>
      <mi>m</mi>
      <mi>i</mi>
      <mi>s</mi>
      <mi>s</mi>
     </mrow>
    </msub>
    <mo>)</mo>
   </mrow>
   <mo>+</mo>
   <msub>
    <mo>∝</mo>
    <mn>5</mn>
   </msub>
   <mrow>
    <mo>(</mo>
    <mi>I</mi>
    <mi>n</mi>
    <mi>s</mi>
    <mi>t</mi>
    <mi>E</mi>
    <mi>x</mi>
    <mi>e</mi>
    <mi>c</mi>
    <mo>)</mo>
   </mrow>
   <mo>+</mo>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>c</mi>
     <mi>p</mi>
     <mi>u</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>p</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">1</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">I</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">c</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>s</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">D</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">3</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">T</csymbol>
     <csymbol cd="unknown">L</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>s</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">4</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">I</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="unknown">T</csymbol>
     <csymbol cd="unknown">L</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>s</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">5</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">I</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>p</ci>
      <ci>u</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Powe{{r}_{cpu}}={{\propto}_{1}}\left(IFetc{{h}_{miss}}\right)+{{\propto}_{2}}%
\left(DataDep\right)+{{\propto}_{3}}\left(DataTL{{B}_{miss}}\right)+{{\propto}%
_{4}}\left(InsTL{{B}_{miss}}\right)+{{\propto}_{5}}\left(InstExec\right)+{{K}_%
{cpu}}
  </annotation>
 </semantics>
</math>

 (1)</p>

<p>Where, 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:1">
 <semantics>
  <mrow>
   <msub>
    <mo>∝</mo>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mo>∝</mo>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mo>∝</mo>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mo>∝</mo>
    <mn>4</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mo>∝</mo>
    <mn>5</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proportional-to</csymbol>
     <cn type="integer">5</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\propto}_{1}},{{\propto}_{2}},{{\propto}_{3}},{{\propto}_{4}},{{\propto}_{5}}
  </annotation>
 </semantics>
</math>

 are power weights and 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:2">
 <semantics>
  <msub>
   <mi>K</mi>
   <mrow>
    <mi>c</mi>
    <mi>p</mi>
    <mi>u</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>p</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{K}_{cpu}}
  </annotation>
 </semantics>
</math>

 is a constant for processor power consumption during idle time.</p>

<p>One can also estimate power consumption of memory (external RAM) by tracking the performance events if they are available on the designed processor.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> PXA255 processor, for example, does not have direct performance events accounting for external RAM but Instruction Cache Miss, Data Cache Miss, and Number of Data Dependencies on processor can be used to estimate the memory power consumption. Again, a linear model is derived from the given information (equation 2) to estimate the memory power consumption.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>o</mi>
    <mi>w</mi>
    <mi>e</mi>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>m</mi>
      <mi>e</mi>
      <mi>m</mi>
      <mi>o</mi>
      <mi>r</mi>
      <mi>y</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>β</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>I</mi>
       <mi>F</mi>
       <mi>e</mi>
       <mi>t</mi>
       <mi>c</mi>
       <msub>
        <mi>h</mi>
        <mrow>
         <mi>m</mi>
         <mi>i</mi>
         <mi>s</mi>
         <mi>s</mi>
        </mrow>
       </msub>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>β</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>D</mi>
       <mi>a</mi>
       <mi>t</mi>
       <mi>a</mi>
       <mi>D</mi>
       <mi>e</mi>
       <mi>p</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>K</mi>
     <mrow>
      <mi>m</mi>
      <mi>e</mi>
      <mi>m</mi>
      <mi>o</mi>
      <mi>r</mi>
      <mi>y</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>o</ci>
     <ci>w</ci>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>e</ci>
       <ci>m</ci>
       <ci>o</ci>
       <ci>r</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>F</ci>
       <ci>e</ci>
       <ci>t</ci>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>i</ci>
         <ci>s</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>a</ci>
       <ci>t</ci>
       <ci>a</ci>
       <ci>D</ci>
       <ci>e</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>e</ci>
       <ci>m</ci>
       <ci>o</ci>
       <ci>r</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Powe{{r}_{memory}}={{\beta}_{1}}\left(IFetc{{h}_{miss}}\right)+{{\beta}_{2}}%
\left(DataDep\right)+{{K}_{memory}}
  </annotation>
 </semantics>
</math>

 (2)</p>

<p>Where, 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:4">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\beta}_{1}},{{\beta}_{2}}
  </annotation>
 </semantics>
</math>

 are power weights and 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:5">
 <semantics>
  <msub>
   <mi>K</mi>
   <mrow>
    <mi>m</mi>
    <mi>e</mi>
    <mi>m</mi>
    <mi>o</mi>
    <mi>r</mi>
    <mi>y</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>e</ci>
     <ci>m</ci>
     <ci>o</ci>
     <ci>r</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{K}_{memory}}
  </annotation>
 </semantics>
</math>

 is a power consumption constant during idle time.</p>

<p>The main challenging issue with this method is computing the power weights using a mathematical model (ordinary Least Squares Estimation) at different voltage/frequency points. These constant values in equations 1 and 2 are voltage and frequency depends and they must be computed during benchmark testing. After building such a table for the power weights parameters, then the table can be implemented in software or hardware to estimate the real-time power.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The other challenge is in accessing HPCs; for example, in this case they are being read at the beginning of the main OS timer interrupt which requires a software modification. A software program can be written using the equations 1 and 2 and the estimated power weights derived from the table to estimate the power consumption at run-time. For equation 1 the program also needs 5 samples of HPCs but in this example the PXA255 processor can only sample 2 events at any given time therefore multiple code execution is required as well as aligning the data.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>In summary, the main benefits of this approach are that it is easy to implement, low cost, and does not require special hardware modification. Software designers can benefit from this model by having a quick power estimate for their applications without any extra hardware requirement.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>The main disadvantage of this method is that: real world processors are not perfect and this model does not account for non-linear relationships in those processors. Another issue is also the software overhead running on the processor that consumes power. This approach also does not provide detailed information about power consumption in each architectural functional unit so designers can’t see the difference between each module by executing different parts of the software. This method can’t be used by OS scheduler or software developers executing multi threaded programs because it needs to gather data by running benchmarks several times.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> This work is also good for single core processors but not multi-core processors.</p>
<h4 id="piece-wise-linear-power-estimation-model-using-performance-counters">Piece-wise linear power estimation model using performance counters</h4>

<p>The piece-wise model was developed to estimate power consumption accurately using performance counters. This method was developed by K.Singh, M.Bhadauria at Cornell University and S.A.McKee at Chalmers University of Technology independently of program behavior for SPEC 2006, SPEC-OMP and NAS benchmark suits. This method was developed to analyze the effects of shared resources and temperature on power consumption for chip multiprocessors.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>This method used 4 performance counters of AMD Phenom processor. The performance counters are as follows

<math display="block" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:6">
 <semantics>
  <mrow>
   <mpadded width="-3.4pt">
    <mrow></mrow>
   </mpadded>
   <mpadded width="-3.4pt">
    <mi>ε</mi>
   </mpadded>
   <msub>
    <mrow></mrow>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext></mtext>
    <ci>ε</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext></mtext>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\text{ }\!\!\varepsilon\!\!\text{ }}_{1}}
  </annotation>
 </semantics>
</math>

: L2_CACHE_MISS: ALL, 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:7">
 <semantics>
  <mrow>
   <mpadded width="-3.4pt">
    <mrow></mrow>
   </mpadded>
   <mpadded width="-3.4pt">
    <mi>ε</mi>
   </mpadded>
   <msub>
    <mrow></mrow>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext></mtext>
    <ci>ε</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext></mtext>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\text{ }\!\!\varepsilon\!\!\text{ }}_{2}}
  </annotation>
 </semantics>
</math>

: RETRIED_UOPS, 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:8">
 <semantics>
  <mrow>
   <mpadded width="-3.4pt">
    <mrow></mrow>
   </mpadded>
   <mpadded width="-3.4pt">
    <mi>ε</mi>
   </mpadded>
   <msub>
    <mrow></mrow>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext></mtext>
    <ci>ε</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext></mtext>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\text{ }\!\!\varepsilon\!\!\text{ }}_{3}}
  </annotation>
 </semantics>
</math>

: RETIRED_MMX_AND_FP_INSTRUCTIONS: ALL, 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:9">
 <semantics>
  <mrow>
   <mpadded width="-3.4pt">
    <mrow></mrow>
   </mpadded>
   <mpadded width="-3.4pt">
    <mi>ε</mi>
   </mpadded>
   <msub>
    <mrow></mrow>
    <mn>4</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext></mtext>
    <ci>ε</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext></mtext>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\text{ }\!\!\varepsilon\!\!\text{ }}_{4}}
  </annotation>
 </semantics>
</math>

: DISPATCH_STALLS. These performance counters are architecturally specific to AMD Phenom and may be different for other processors. AMD allows collecting data from those four HPCs simultaneously.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> A microbenchmarks, which is a small program, attempts to collect data from the above selected HPCs. Collected data on each processor core are used in the following equation.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:10">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>c</mi>
     <mi>o</mi>
     <mi>r</mi>
     <mi>e</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msub>
          <mi>F</mi>
          <mn>1</mn>
         </msub>
         <mrow>
          <mo>(</mo>
          <mrow>
           <msub>
            <mi>g</mi>
            <mn>1</mn>
           </msub>
           <mrow>
            <mo>(</mo>
            <msub>
             <mi>r</mi>
             <mn>1</mn>
            </msub>
            <mo>)</mo>
           </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi mathvariant="normal">…</mi>
           <mi mathvariant="normal">…</mi>
          </mrow>
          <mo>,</mo>
          <mrow>
           <msub>
            <mi>g</mi>
            <mi>n</mi>
           </msub>
           <mrow>
            <mo>(</mo>
            <msub>
             <mi>r</mi>
             <mi>n</mi>
            </msub>
            <mo>)</mo>
           </mrow>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>i</mi>
         <mi>f</mi>
         <mrow></mrow>
         <mi>c</mi>
         <mi>o</mi>
         <mi>n</mi>
         <mi>d</mi>
         <mi>i</mi>
         <mi>t</mi>
         <mi>i</mi>
         <mi>o</mi>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msub>
          <mi>F</mi>
          <mn>2</mn>
         </msub>
         <mrow>
          <mo>(</mo>
          <mrow>
           <msub>
            <mi>g</mi>
            <mn>1</mn>
           </msub>
           <mrow>
            <mo>(</mo>
            <msub>
             <mi>r</mi>
             <mn>1</mn>
            </msub>
            <mo>)</mo>
           </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi mathvariant="normal">…</mi>
           <mi mathvariant="normal">…</mi>
          </mrow>
          <mo>,</mo>
          <mrow>
           <msub>
            <mi>g</mi>
            <mi>n</mi>
           </msub>
           <mrow>
            <mo>(</mo>
            <msub>
             <mi>R</mi>
             <mi>n</mi>
            </msub>
            <mo>)</mo>
           </mrow>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>e</mi>
         <mi>l</mi>
         <mi>s</mi>
         <mi>e</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>o</ci>
      <ci>r</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <matrix>
      <matrixrow>
       <list>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <cn type="integer">1</cn>
         </apply>
         <vector>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>g</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>normal-…</ci>
           <ci>normal-…</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>g</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <ci>n</ci>
           </apply>
          </apply>
         </vector>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>f</ci>
         <mtext></mtext>
         <ci>c</ci>
         <ci>o</ci>
         <ci>n</ci>
         <ci>d</ci>
         <ci>i</ci>
         <ci>t</ci>
         <ci>i</ci>
         <ci>o</ci>
         <ci>n</ci>
        </apply>
       </list>
      </matrixrow>
      <matrixrow>
       <list>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <cn type="integer">2</cn>
         </apply>
         <vector>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>g</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>r</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>normal-…</ci>
           <ci>normal-…</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>g</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>R</ci>
            <ci>n</ci>
           </apply>
          </apply>
         </vector>
        </apply>
        <apply>
         <times></times>
         <ci>e</ci>
         <ci>l</ci>
         <ci>s</ci>
         <ci>e</ci>
        </apply>
       </list>
      </matrixrow>
     </matrix>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{P}_{core}}=\left\{\begin{matrix}{{F}_{1}}\left({{g}_{1}}\left({{r}_{1}}%
\right),\ldots\ldots,{{g}_{n}}\left({{r}_{n}}\right)\right),if\text{ }%
condition\\
{{F}_{2}}\left({{g}_{1}}\left({{r}_{1}}\right),\ldots\ldots,{{g}_{n}}\left({{R%
}_{n}}\right)\right),else\\
\end{matrix}\right.
  </annotation>
 </semantics>
</math>

 (3)</p>

<p>Where 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:11">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ε</mi>
     <mi>i</mi>
    </msub>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <mi>y</mi>
      <mi>c</mi>
      <mi>l</mi>
      <mi>e</mi>
      <mrow></mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>u</mi>
      <mi>n</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ε</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>y</ci>
      <ci>c</ci>
      <ci>l</ci>
      <ci>e</ci>
      <mtext></mtext>
      <ci>c</ci>
      <ci>o</ci>
      <ci>u</ci>
      <ci>n</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{r}_{i}}={{\varepsilon}_{i}}/(cycle\text{ }count)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:12">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>1</mn>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mi mathvariant="normal">…</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>2</mn>
      </msub>
      <mo>*</mo>
      <msub>
       <mi>g</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <ci>normal-…</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{F}_{n}}={{P}_{0}}+{{P}_{1}}*{{g}_{1}}\left({{r}_{1}}\right)+\ldots\ldots+{{P%
}_{2}}*{{g}_{n}}({{r}_{n}})
  </annotation>
 </semantics>
</math>

 (4)</p>

<p>Equation 4 transformation can be linear, inverse, logarithmic, exponential, or square root; it depends on what makes the power predication more accurate. Piece wise linear function was chosen to analyze equation 4 from collected data because it will capture more detail about each processor core power. Finally, analyzing the collected HPCs data with piece wise linear method gives the detailed power consumption (for example, L2 cache misses has the highest contribution in power consumption versus L3).</p>

<p>The above method was used to schedule each AMD Phenom processor core in a defined power envelope. The processors core gets suspended when the core exceeds the available power envelope and it becomes available again when enough power becomes available.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>There are some restrictions and issues with this method; for example, this method does not account for temperature effect. There is a direct relationship between temperature and total power consumption (because as temperature increases the leakage power goes up) that this model does not account for because AMD Phenom does not have per-core temperature sensors. A second disadvantage is that mictobenchmarks is not complete to get a better power estimate (for instance, it does not cover the DISPATCH_STALLS HPC). A more complete microbenchmark will cause timing issues. Future work needs to be done to incorporate thermal data into the model and thread scheduling strategies as well as to reduce frequency (DVFS) of each core versus suspending the core.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> This method only covers processors but there are other subsystems, like memory, and disks, that also need to be considered in total power.</p>

<p>This method is different from many other methods using performance counters because all the cores in multi core processors are considered, the performance counters being used do not individually have high effect with power consumption and it estimates the power consumption for each core that can be used for real time scheduling of each core to be under power envelope.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h4 id="adaptive-power-estimation-model-using-performance-counters">Adaptive power estimation model using performance counters</h4>

<p>Most models like the above do not have the capability to measure power consumption at a component or subsystem level. <strong>DiPART</strong> (Disaggregated Power Analysis in Real Time) developed by Professor M. Srivastava, Y. Sun, and L. Wanner at University of California, Los Angeles enables this capability to estimate power consumption based on hardware performance counters and using only one power sensor for the whole system.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> Models are required to estimate power consumption based on performance counters. These models correlate the data for different performance counters with power consumption and static models like above examples (First-order and Piece-wise linear) have different estimation errors due to variations across identical hardware.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> DiPART is a solution to this problem because it is a self-adaptive model that can be calibrated once and be applied across different platforms.</p>

<p>The linear estimation model for DiPART requires a power sensor capable of acquiring dissipated power consumption and current measurement at run time. There are different embedded sensors like Atom-LEAP system <a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> or Qualcomm’s Snapdragon Mobil Development Platforms <a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> that can do the job for DiPART. One single power sensor can be used to calibrate the subsystem level estimation model DiPART.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>

<p>Total power of the system is the summation of the power consumption by each subsystem shown in equation 5.</p>

<p>

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:13">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>s</mi>
     <mi>y</mi>
     <mi>s</mi>
     <mi>t</mi>
     <mi>e</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mrow>
      <mi>C</mi>
      <mi>P</mi>
      <mi>U</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>P</mi>
     <mrow>
      <mi>R</mi>
      <mi>A</mi>
      <mi>M</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>P</mi>
     <mrow>
      <mi>D</mi>
      <mi>i</mi>
      <mi>s</mi>
      <mi>k</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>y</ci>
      <ci>s</ci>
      <ci>t</ci>
      <ci>e</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>P</ci>
       <ci>U</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>A</ci>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>i</ci>
       <ci>s</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{P}_{system}}={{P}_{CPU}}+{{P}_{RAM}}+{{P}_{Disk}}
  </annotation>
 </semantics>
</math>

 (5)<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>For each subsystem, power performance counters are being used. For CPU power, ten performance counters are required as follows: Task counts, Context Switch counts, CPU Migration counts, Page Fault counts, Cycles counts, Instruction counts, Branches counts, Cache Refer counts, and Cache Miss Counts. Then a linear model is used to compute the total power of CPU and coefficient values are computed with a liner regression algorithm using performance counter data and monitored power consumption data.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:14">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>C</mi>
     <mi>P</mi>
     <mi>U</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mo>∝</mo>
       <mo>,</mo>
       <mi>β</mi>
       <mo>,</mo>
       <mrow>
        <mi mathvariant="normal">…</mi>
        <mi>γ</mi>
       </mrow>
       <mo>]</mo>
      </mrow>
      <mo>*</mo>
      <mi>V</mi>
     </mrow>
     <mi>e</mi>
     <mi>c</mi>
     <mi>o</mi>
     <mi>r</mi>
     <mrow></mrow>
     <mi>o</mi>
     <mi>f</mi>
     <mrow></mrow>
     <mi>C</mi>
     <mi>P</mi>
     <mi>U</mi>
     <mrow></mrow>
     <mi>p</mi>
     <mi>e</mi>
     <mi>r</mi>
     <mi>f</mi>
     <mi>o</mi>
     <mi>r</mi>
     <mi>m</mi>
     <mi>a</mi>
     <mi>n</mi>
     <mi>c</mi>
     <mi>e</mi>
     <mrow></mrow>
     <mi>C</mi>
     <mi>o</mi>
     <mi>u</mi>
     <mi>n</mi>
     <mi>t</mi>
     <mi>e</mi>
     <mi>r</mi>
     <mi>s</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>λ</mi>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>s</mi>
      <mi>t</mi>
      <mi>a</mi>
      <mi>n</mi>
      <mi>t</mi>
      <mi>C</mi>
      <mi>P</mi>
      <mi>U</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>P</ci>
      <ci>U</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <list>
        <csymbol cd="latexml">proportional-to</csymbol>
        <ci>β</ci>
        <apply>
         <times></times>
         <ci>normal-…</ci>
         <ci>γ</ci>
        </apply>
       </list>
       <ci>V</ci>
      </apply>
      <ci>e</ci>
      <ci>c</ci>
      <ci>o</ci>
      <ci>r</ci>
      <mtext></mtext>
      <ci>o</ci>
      <ci>f</ci>
      <mtext></mtext>
      <ci>C</ci>
      <ci>P</ci>
      <ci>U</ci>
      <mtext></mtext>
      <ci>p</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>f</ci>
      <ci>o</ci>
      <ci>r</ci>
      <ci>m</ci>
      <ci>a</ci>
      <ci>n</ci>
      <ci>c</ci>
      <ci>e</ci>
      <mtext></mtext>
      <ci>C</ci>
      <ci>o</ci>
      <ci>u</ci>
      <ci>n</ci>
      <ci>t</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>o</ci>
       <ci>n</ci>
       <ci>s</ci>
       <ci>t</ci>
       <ci>a</ci>
       <ci>n</ci>
       <ci>t</ci>
       <ci>C</ci>
       <ci>P</ci>
       <ci>U</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{P}_{CPU}}=\left[\propto,\beta,\ldots\gamma\right]*Vecor\text{ }of\text{ }CPU%
\text{ }performance\text{ }Counters+{{\lambda}_{constantCPU}}
  </annotation>
 </semantics>
</math>

 (6)<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>The above performance counters can also be used for RAM power consumption model and the memory coefficient vector and the constant value is also computed during training phase with performance counter data and monitored power consumption data.</p>

<p>

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:15">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>R</mi>
     <mi>A</mi>
     <mi>M</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mpadded width="-3.4pt">
         <mrow></mrow>
        </mpadded>
        <mpadded width="-3.4pt">
         <mi mathvariant="normal">Δ</mi>
        </mpadded>
        <mrow></mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mpadded width="-3.4pt">
         <mrow></mrow>
        </mpadded>
        <mpadded width="-3.4pt">
         <mi mathvariant="normal">Γ</mi>
        </mpadded>
        <mrow></mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi mathvariant="normal">…</mi>
        <mpadded width="-3.4pt">
         <mrow></mrow>
        </mpadded>
        <mpadded width="-3.4pt">
         <mi mathvariant="normal">Θ</mi>
        </mpadded>
        <mrow></mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
      <mo>*</mo>
      <mrow></mrow>
     </mrow>
     <mi>V</mi>
     <mi>e</mi>
     <mi>c</mi>
     <mi>t</mi>
     <mi>o</mi>
     <mi>r</mi>
     <mrow></mrow>
     <mi>o</mi>
     <mi>f</mi>
     <mrow></mrow>
     <mi>P</mi>
     <mi>e</mi>
     <mi>r</mi>
     <mi>f</mi>
     <mi>o</mi>
     <mi>r</mi>
     <mi>m</mi>
     <mi>a</mi>
     <mi>n</mi>
     <mi>c</mi>
     <mi>e</mi>
     <mrow></mrow>
     <mi>C</mi>
     <mi>o</mi>
     <mi>u</mi>
     <mi>n</mi>
     <mi>t</mi>
     <mi>e</mi>
     <mi>r</mi>
     <mi>s</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>λ</mi>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>s</mi>
      <mi>t</mi>
      <mi>a</mi>
      <mi>n</mi>
      <mi>t</mi>
      <mi>R</mi>
      <mi>A</mi>
      <mi>M</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>A</ci>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <list>
        <apply>
         <times></times>
         <mtext></mtext>
         <ci>normal-Δ</ci>
         <mtext></mtext>
        </apply>
        <apply>
         <times></times>
         <mtext></mtext>
         <ci>normal-Γ</ci>
         <mtext></mtext>
        </apply>
        <apply>
         <times></times>
         <ci>normal-…</ci>
         <mtext></mtext>
         <ci>normal-Θ</ci>
         <mtext></mtext>
        </apply>
       </list>
       <mtext></mtext>
      </apply>
      <ci>V</ci>
      <ci>e</ci>
      <ci>c</ci>
      <ci>t</ci>
      <ci>o</ci>
      <ci>r</ci>
      <mtext></mtext>
      <ci>o</ci>
      <ci>f</ci>
      <mtext></mtext>
      <ci>P</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>f</ci>
      <ci>o</ci>
      <ci>r</ci>
      <ci>m</ci>
      <ci>a</ci>
      <ci>n</ci>
      <ci>c</ci>
      <ci>e</ci>
      <mtext></mtext>
      <ci>C</ci>
      <ci>o</ci>
      <ci>u</ci>
      <ci>n</ci>
      <ci>t</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>o</ci>
       <ci>n</ci>
       <ci>s</ci>
       <ci>t</ci>
       <ci>a</ci>
       <ci>n</ci>
       <ci>t</ci>
       <ci>R</ci>
       <ci>A</ci>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{P}_{RAM}}=\left[\text{ }\!\!\Delta\!\!\text{ },\text{ }\!\!\Gamma\!\!\text{ %
},\ldots\text{ }\!\!\Theta\!\!\text{ }\right]*\text{ }Vector\text{ }of\text{ }%
Performance\text{ }Counters+{{\lambda}_{constantRAM}}
  </annotation>
 </semantics>
</math>

 (7)<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>Disk power consumption model is based on input counter and output counter correlated with Input/Output events counters.</p>

<p>The same approach is taken as for CPU and RAM to estimate the coefficient and constant for disk power during training phase.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:16">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>D</mi>
     <mi>i</mi>
     <mi>s</mi>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mi>φ</mi>
       <mo>,</mo>
       <mi>χ</mi>
       <mo>]</mo>
      </mrow>
      <mo>*</mo>
      <mrow></mrow>
     </mrow>
     <mi>V</mi>
     <mi>e</mi>
     <mi>c</mi>
     <mi>t</mi>
     <mi>o</mi>
     <mi>r</mi>
     <mrow></mrow>
     <mi>o</mi>
     <mi>f</mi>
     <mrow></mrow>
     <mi>D</mi>
     <mi>i</mi>
     <mi>s</mi>
     <mi>k</mi>
     <mrow></mrow>
     <mi>p</mi>
     <mi>e</mi>
     <mi>r</mi>
     <mi>f</mi>
     <mi>o</mi>
     <mi>r</mi>
     <mi>m</mi>
     <mi>a</mi>
     <mi>n</mi>
     <mi>c</mi>
     <mi>e</mi>
     <mrow></mrow>
     <mi>c</mi>
     <mi>o</mi>
     <mi>u</mi>
     <mi>n</mi>
     <mi>t</mi>
     <mi>e</mi>
     <mi>r</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>λ</mi>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>s</mi>
      <mi>t</mi>
      <mi>a</mi>
      <mi>n</mi>
      <mi>t</mi>
      <mi>D</mi>
      <mi>i</mi>
      <mi>s</mi>
      <mi>k</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>i</ci>
      <ci>s</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <interval closure="closed">
        <ci>φ</ci>
        <ci>χ</ci>
       </interval>
       <mtext></mtext>
      </apply>
      <ci>V</ci>
      <ci>e</ci>
      <ci>c</ci>
      <ci>t</ci>
      <ci>o</ci>
      <ci>r</ci>
      <mtext></mtext>
      <ci>o</ci>
      <ci>f</ci>
      <mtext></mtext>
      <ci>D</ci>
      <ci>i</ci>
      <ci>s</ci>
      <ci>k</ci>
      <mtext></mtext>
      <ci>p</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>f</ci>
      <ci>o</ci>
      <ci>r</ci>
      <ci>m</ci>
      <ci>a</ci>
      <ci>n</ci>
      <ci>c</ci>
      <ci>e</ci>
      <mtext></mtext>
      <ci>c</ci>
      <ci>o</ci>
      <ci>u</ci>
      <ci>n</ci>
      <ci>t</ci>
      <ci>e</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>o</ci>
       <ci>n</ci>
       <ci>s</ci>
       <ci>t</ci>
       <ci>a</ci>
       <ci>n</ci>
       <ci>t</ci>
       <ci>D</ci>
       <ci>i</ci>
       <ci>s</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{P}_{Disk}}=\left[\varphi,\chi\right]*\text{ }Vector\text{ }of\text{ }Disk%
\text{ }performance\text{ }counter+{{\lambda}_{constantDisk}}
  </annotation>
 </semantics>
</math>

 (8)<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>

<p>During training the total power measured from the sensor is subtracted from the initial CPU, RAM, and Disk power model predication. Then 10% from the delta result is taken to compensate in individual subsystems CPU, RAM and disk models. This iteration will continue until estimation error for total system power is smaller than some threshold, or it hits the specified number of iterations. During this training process with some number of iteration process each subsystem model gets adjusted accordingly base on the delta percentage. Once the subsystems are trained the total system does not need to be trained.</p>

<p>The CPU, RAM, and Disk power model modification and system-level variation is required if the total delta is not less than 10%. The iteration process will continue until the individual subsystem power model prediction gets close to the monitored total power. When subsystem power consumption model has been trained the total system level power consumption model does not need to train again for the same system.</p>

<p>This method is beneficial compared to static models because of its adaptability to the variations among different systems even with exactly the same hardware. The experimental results show that estimated errors are high before training the DiPART, and that the error decreases as the number of iteration increases.</p>

<p>One major issue with this model is the dependency on power sensors to measure the total power. The other issue is the number of performance counters being used for DiPART model. These performance counters might not be available for all processors. This method was also used for CPU, RAM and disk subsystem but there are other subsystems that need to be considered in total power consumption. The main problem with adding more subsystems will be the adaptive mechanism because as the number of subsystems increases, the accuracy and training speed will decrease.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> Another issue is that the CPU, Disk and RAM are also not perfect and have some non-linearity part that was not considered in this method.</p>
<h3 id="dynamic-thermal-management">Dynamic Thermal Management</h3>

<p>As the Integrated Circuit (IC) technology size is getting smaller in nanometer scale and more transistors are put together in that small area, the total power and temperature on chip are also increasing. The high temperature on the chip, if not controlled, can damage or even burn the chip. The chip high temperature also has impacts on performance and reliability.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> High chip temperature causes more leakage power consumption, higher interconnect resistance and slower speed of transistors.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> Therefore Dynamic Thermal Management (DTM) is required for high performance embedded systems or high-end microprocessors. Thermal sensors are also not perfect for the job because of their accuracy and long delay to capture the temperature. The DTM idea is to detect and reduce the temperature of hot units spots in a chip using different techniques like activity migration, local toggling, dynamic voltage and frequency scaling.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>

<p>A new method was developed by H. Li, P. Liu, Z. Qi, L. Jin, W. Wu, S.X.D Tan, J. Yang at University of California Riverside based on observing the average power consumption of low level modules running typical workload.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> There is a direct correlation between the observation and temperature variations. This new method was a solution to replace the old technologies such as on-line tracking sensors on the chip like CMOS-based sensor technology that are less accurate and requires hardware implementation.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></p>

<p>This method is based on observing the average power in a certain amount of time which determines the temperature variations. This idea can be implemented with a fast run-time thermal simulation algorithm at architectural level.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> This method also presents a new way to compute the transient temperature changes based on the frequency domain moment matching concept. The moment matching concept is basically said that the transient behaviors of a dynamic system can be accurately described by a few dominant poles of the systems.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> The moment matching algorithm is required to compute the temperature variation response under initial temperature conditions and average power inputs for a given time.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> This method also follows circuit level thermal RC modeling at the architectural level as described in reference.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> The unit temperature variation during run-time is because of the irregular power trance generated by each unit in their architectural blocks.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> This power input is consistent of DC and small AC oscillation. It was also shown and proven that most of the energy in the power trace concentrates on the DC component. Therefore the average power can be described as a constant DC input to thermal circuit. After all a thermal moment marching (TMM) with initial condition and DC input is required to be implemented. The TMM model is as follows:</p>

<p>

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>C</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Gx+Cx=Bu
  </annotation>
 </semantics>
</math>

 (9)</p>

<p>G and C are conductive and capacitive circuit matrices, and x is the vector of node temperature.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> u is the vector of independent power source and B is the input selector matrix. This equation will be solved in frequency domain and the initial condition is required which will be the initial temperature at each node.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> The main idea is to implement the TMM algorithm which provides better reliable on-line temperature estimation for DTM applications.</p>

<p>In summary, the TMM algorithm is much faster than the previous work in this area to estimate the thermal variation because this method is using frequency domain moment matching method. The other work (like HotSpot) uses the integration method where it needs all previous points to obtain the temperature at certain running point. This will make the simulation time longer.</p>

<p>This work can also be improved by computing the average power real-time using performance counters. This method can be added to the above models using performance counters to estimate on the fly temperature variation as the programs are getting executed.</p>
<h3 id="powerbooter-and-powertutor">PowerBooter and PowerTutor</h3>

<p>This power model technique was developed by collaboration between L. Zhang, B. Tiwana, Z. Qian, Z. Wang, R.P. Dick, Z.Mao from University of Michigan and L. Yang from Google Inc. to accurately estimate power estimation online for Smartphones.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> <strong>PowerBooter</strong> is an automated power model that uses built-in battery voltage sensors and behavior of battery during discharge to monitor power consumption of total system. This method doesn’t require any especial external measurement equipment. <strong>PowerTutor</strong> is also a power measurement tool that uses PowerBooter generated data for online power estimation. There is always a limitation in <a class="uri" href="Smartphone" title="wikilink">Smartphone</a> technology battery life span that HW and SW designers need to overcome. Software designers don’t always have the best knowledge of power consumption to design better power optimized applications therefore end users always blame the battery lifespan. Therefore, there is a need for a tool that has the capability to measure power consumption on Smartphones that software designers could use to monitor their applications in real-time. Researchers have developed specific power management models for specific portable embedded systems and it takes a huge effort to reuse those models for a vast variety of modern <a class="uri" href="Smartphone" title="wikilink">Smartphone</a> technology. So the solution to this problem is PowerBooter model that can estimate real-time power consumption for individual <a class="uri" href="Smartphone" title="wikilink">Smartphone</a> subsystems such as CPU, LCD, GPS, audio, Wi-Fi and cell phone communication components. Along with PowerBooter model an on-line PowerTutor utility can use the generated data to determine the subsystem level power consumption. The model and PowerTutor utility can be used across different platforms and <a class="uri" href="Smartphone" title="wikilink">Smartphone</a> technologies.</p>

<p>This model is different from the other models discovered because it relies only on knowledge of the battery discharge voltage curve and access to battery voltage sensor which is available in all modern Smartphones.<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a> The basic idea for this model technique is to use battery state of discharge with running training software programs to control phone component power and activity states. Each individual <a class="uri" href="Smartphone" title="wikilink">Smartphone</a> component is held in a specific state for a significant period of time and the change in battery state of discharge is captured using built-in battery voltage sensors.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> The first challenging idea is to convert battery voltage readings into power consumption. This is determined by state of discharge (which is total consumed energy by battery) variation within a testing interval captured by voltage sensors that will eventually drive the following equation.</p>

<p>

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>*</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mi>t</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>t</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>S</mi>
       <mi>O</mi>
       <mi>D</mi>
       <mrow>
        <mo>(</mo>
        <msub>
         <mi>V</mi>
         <mn>1</mn>
        </msub>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>S</mi>
       <mi>O</mi>
       <mi>D</mi>
       <mrow>
        <mo>(</mo>
        <msub>
         <mi>V</mi>
         <mn>2</mn>
        </msub>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>O</ci>
       <ci>D</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>O</ci>
       <ci>D</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P*\left({{t}_{1}}-{{t}_{2}}\right)=E*(SOD\left({{V}_{1}}\right)-SOD\left({{V}_%
{2}}\right))
  </annotation>
 </semantics>
</math>

 (10)</p>

<p>Where E is the rated battery energy capacity and SOD (Vi) is the battery state of discharge at voltage Vi and P is the average power consumption in the time interval t1 and t2. The state of discharge can be estimated using look up table where the relationship between present voltage and SOD is captured. Determining the energy is also an issue because the energy is changing as the battery gets old. The new batteries have the total energy written on their back but the value can’t be true for all time. It can estimate the energy at highest and lowest discharge rate to decrease the error. The internal resistance also has significant impact on the discharged current. To decrease the effect of internal resistance all the phone components can be switched to their lowest power modes to minimize the discharge current when taking a voltage reading. Finally, this method uses a piece-wise linear function to model the non-linear relationship between SOF and battery voltage.</p>

<p>The above battery model can be all automated with 3 steps which are described in.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a> In conclusion, this method is beneficial because all Smartphones can use this method and for new Smartphones this model needs to be constructed only once and after automating the process there would be no need for any extra equipment to measure power consumption. Once the model is generated automatically or manually the PowerTutor utility can use the data to estimate power consumption in real time. Software engineers can use this utility to optimize their design or users can use this tool to make their decision about buying applications based on the power consumption.</p>

<p>The main issues are in computing the energy which adds up to accuracy of the power model. Another issue is also considering the internal resistor to read the voltage. This can be resolved in newer versions of Smartphones that provide current measurement instead of voltage. The above model needs to be modified using the current measurement.</p>

<p><strong>Appscope</strong> <a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> and <strong>DevScope</strong> <a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> are similar work to estimate <a class="uri" href="Smartphone" title="wikilink">Smartphone</a> power consumptions.</p>
<h3 id="run--time-modeling-and-estimation-of-operating-system-power-consumption">Run- time modeling and estimation of operating system power consumption</h3>

<p>The operating system (OS) is the main <a class="uri" href="software" title="wikilink">software</a> running on most computing systems and contributes a major component in dissipating power consumption. Therefore, operating system model was developed by T. Li and L.K John from University of Texas at Austin to estimate the power consumption by OS that helps power management and software applications power evaluation.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a></p>

<p>It’s been computed that software execution on hardware components can dissipate a good portion of power consumption.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a> It’s also been shown that the choice of algorithm and other higher level software code decisions during the design of software could significantly affect system power. Many of these software applications rely on operating system; therefore, overlooking the estimated power consumption by OS could cause huge error in energy estimation. Estimating OS power consumption could help software designers optimize their code design to be more energy efficient. For example, software engineer; can observe the power consumption when using different compiling techniques to handle TLB misses and paging.<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> A good OS model needs to have the following properties to be good enough for thermal or power management tools. The model needs to be highly reliable, fast, and it also should have run-time estimation capability that does not increase overhead. The model should be simple and easily adoptable across different platforms.</p>

<p>The purposed run-time power estimation requires a first order linear operation on a single power metric, reducing estimation overhead.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a> The Instruction per Cycle (IPC) can be used as the metric to characterize the performance of modern processors. In paper <a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> shows how various components in the CPU and memory systems contributes to the total OS routine power. Data-path and pipeline structure along with clocks are consuming the most power. A linear model can be derived from IPC that tracks the OS routine power. A simple Energy equation 

<math display="inline" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:19">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mo>*</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=P*T
  </annotation>
 </semantics>
</math>

 can be used to estimate a given piece of software energy consumption, where P is the average power and T is the execution time of that program.</p>

<p>The challenging part is to compute the average power P for each individual routine of operation system. One can use the correlation between IPC and OS routine average power or hardware performance counters can be used. The profiling method (data gathered from benchmark testing) can also be used to predict the energy consumption. The linear power model in <a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a> is as follows

<math display="block" id="Run-time_estimation_of_system_and_sub-system_level_power_consumption:20">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>O</mi>
     <mi>S</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>K</mi>
       <mn>1</mn>
      </msub>
      <mo>*</mo>
      <mrow></mrow>
     </mrow>
     <mi>I</mi>
     <mi>P</mi>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>O</mi>
       <mi>S</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>K</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <cn type="integer">1</cn>
       </apply>
       <mtext></mtext>
      </apply>
      <ci>I</ci>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>O</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{P}_{OS}}={{K}_{1}}*\text{ }IP{{C}_{OS}}+{{K}_{0}}
  </annotation>
 </semantics>
</math>

. This is a simple linear model that shows a strong correlation between IPC and OS routine power. In this approach profiling is also required to generate data needed to build the model. After the model is generated for one system, then it is not needed again for the same system.</p>
<h3 id="virtual-machine-power-metering-and-provisioning">Virtual Machine Power Metering and Provisioning</h3>

<p>Joulemeter is a proposed solution by Aman Kansal, Feng Zhao, and Jie Liu from Microsoft Inc. and Nupur Kothari from University of Southern California, Los Angeles and Arka Bhattacharya from Indian Institute of Technology to measure virtual machine power which cannot be measured directly in hardware.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a> This method is used for power management for virtualized data centers. Most servers today have power metering and the old servers use power distribution units (PDUs). This method uses those individual power meters to save significant reduction in power provisioning costs.</p>

<p>This method uses power models in software to track VM energy usage on each significant hardware resource, using hypervisor-observable hardware power states.<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a> Joulemeter can also solve the power capping problem for VMs which will reduce power provisioning costs significantly. The largest power consuming subsystems in computer servers are the processor, memory and disk. Servers also have idle energy consumption which sometimes can be large, but it is static and it can be measured. Power models are presented for each of subsystems CPU, memory and disk in reference <a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a> in detail. This power model is the core technique for Joulemeter. Figure 4 in reference <a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a> shows the block diagram of Joulemeter where System Resource &amp; Power Tracing module reads the full server CPU, disk and power usage. The VM resource tracking module tracks all the work load using hypervisor counters. The base model training module implements the learning methods described in <a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a> as well as refinement module. The energy calculation module finally takes the out of base model training module and model refinement module to output the VM energy usage using the energy equations described in reference.<a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p>

<p>The benefits of this method are safe isolation of co-located workloads, enabling multiple workloads to be consolidated on fewer servers, resulting in improved resource utilization and reduced idle power costs. Joulemeter can also be used to solve the power capping problem for VMs which will saved significant amount of power provisioning costs in data centers.</p>
<h2 id="direct-power-measurement">Direct Power measurement</h2>

<p>One can use different types of sensors to gather voltage, current, frequency or temperature and then use those data to estimate power consumption.</p>
<h3 id="low-power-energy-aware-processing-embedded-sensor-system">Low Power Energy Aware Processing embedded sensor system</h3>

<p>The LEAP (Low Power Energy Aware Processing) has been developed by D. McIntire, K. Ho, B. Yip, A. Singh, W. Wu, and W.J. Kaiser at University of California Los Angeles to make sure the embedded network sensor systems are energy optimized for their applications. The LEAP system as described in reference <a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a> offers a detailed energy dissipation monitoring and sophisticated power control scheduling for all subsystems including the sensor systems. LEAP is a multiprocessor architecture based on hardware and software system partitioning. It is an independent energy monitoring and power control method for each individual subsystem. The goal of LEAP is to control microprocessors to achieve the lowest per task operating energy. Many modern embedded networked sensors are required to do many things like image processing, statistical high performance computing and communication. To make sure all of these applications are working efficiently a real-time energy monitoring and scheduling feature is required and LEAP can offer this feature for those systems.</p>

<p>LEAP (ENS) system was designed to offer high accuracy and low overhead energy measurement capability. LEAP enables energy aware applications through scheduling and energy profiling of high energy efficiency components including multiple wireless network interfaces, storage elements, and sensing capabilities.<a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a> The biggest advantage of LEAP system is its Energy Management and Preprocessing (EMAP) capability. The experimental results shows that the optimal choice of sensor systems, processor, wireless interface, and memory technology is not application dependent but it could be hardware allocation issue. EMAP has the capability to partition devices into many power domains with the capability to monitor, enable or disable power to each domain, as well as to respond to trigger events or conditions that restore or remove power in each domain. EMAP collects data periodically and transfers them to the host process and power management schedule is then provided by host processor to EMAP.</p>

<p>Figure 1 in reference <a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a> shows the LEAP architecture and EMAP architecture. The LEAP and EMAP are complex platforms which require hardware and software. All of the detailed design approaches are described in reference.<a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a></p>

<p>In conclusion, LEAP differs from previous methods like PowerScope <a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a> because it provides both real-time power consumption information and a standard application execution environment on the same platform. As a result, LEAP eliminates the need for synchronization between the device under test and an external power measurement unit. LEAP also provides power information of individual subsystems, such as CPU, GPU and RAM, through direct measurement, thereby enabling accurate assessments of software and hardware effects on the power behavior of individual components.<a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a></p>
<h3 id="power-model-validation-through-thermal-measurements">Power model validation through thermal measurements</h3>

<p>One of the challenges for HW or SW designers is to validate their simulation data with empirical data. They require some type of utility or tool to measure power consumption and compare with their simulation data. One of these methods to capture real time data to validate power or thermal models is an infrared measurement setup developed by F.J. Mesa-Martinez, J.Nayfach-Battilana and J. Renau at University of California Santa Cruz. Their approach is to capture thermal maps using infrared cameras with high spatial resolution and high frame rate. Then a genetic algorithm finds a power equation for each floorplan block of processor that produces the capture thermal map to give detailed information about power breakdown (leakage and dynamic).<a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a> They also developed an image processing filter to increase the thermal image accuracy. The biggest challenge for this approach is to obtain a detailed power map from the thermal measurements. There is no direct mapping between measured information and power. A genetic algorithm was developed described in reference <a class="footnoteRef" href="#fn77" id="fnref77"><sup>77</sup></a> that iterates multiple thermal traces and compares them with the results from thermal simulator to find the best power correlation.</p>

<p>The first step is to measure the temperature using IR camera and within the oil coolant that flows over the top of the chip surface, the detailed setup information is described in reference.<a class="footnoteRef" href="#fn78" id="fnref78"><sup>78</sup></a> Oil is chosen because of ease in modeling and accuracy. The infrared cameras must be calibrated to compensate for different material thermal emissions, lens configurations, and other factors in reference.<a class="footnoteRef" href="#fn79" id="fnref79"><sup>79</sup></a> A second filter is also applied to compensate for the optical distortion induced by lens setup. A very accurate thermal model is required in this approach to account for effects of the liquid cooling setup accurately. The model equations are described in reference.<a class="footnoteRef" href="#fn80" id="fnref80"><sup>80</sup></a></p>

<p>Designers can use this method to validate their simulation or optimize their design especially because this method provides the breakdown information about leakage and dynamic power consumption. This method is also helpful in chip packaging design, heat sink, and cooling system. This method also shows designers which part of floorplan blocks propagates heat faster or slower.</p>
<h2 id="conclusion">Conclusion</h2>

<p>Estimating power consumption is critical for hardware, software developers, and other computing system users like Internet companies to save energy or to optimize their HW/SW to be more energy efficient. It is also critical because one can use the available resources accordingly. Simulators are only good during design but their estimation also needs to be verified. Simulators in general have high errors due to manufacturing of hardware components. Power meters measure power consumption for the whole system but does not give detailed breakdowns about dissipated power so designers can optimize their application or hardware. This paper analyzed different methods that researchers have discovered in recent years to resolve some of the issues above.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Energy_consumption" title="wikilink">Category:Energy consumption</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"></li>
<li id="fn42"></li>
<li id="fn43"></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47"></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
<li id="fn49"></li>
<li id="fn50"></li>
<li id="fn51"></li>
<li id="fn52"><a href="#fnref52">↩</a></li>
<li id="fn53"></li>
<li id="fn54"></li>
<li id="fn55"></li>
<li id="fn56"><a href="#fnref56">↩</a></li>
<li id="fn57"><a href="#fnref57">↩</a></li>
<li id="fn58"></li>
<li id="fn59"><a href="#fnref59">↩</a></li>
<li id="fn60"></li>
<li id="fn61"></li>
<li id="fn62"></li>
<li id="fn63"></li>
<li id="fn64"><a href="#fnref64">↩</a></li>
<li id="fn65"></li>
<li id="fn66"></li>
<li id="fn67"></li>
<li id="fn68"></li>
<li id="fn69"></li>
<li id="fn70"><a href="#fnref70">↩</a></li>
<li id="fn71"></li>
<li id="fn72"></li>
<li id="fn73"></li>
<li id="fn74"><a href="#fnref74">↩</a></li>
<li id="fn75"><a href="#fnref75">↩</a></li>
<li id="fn76"><a href="#fnref76">↩</a></li>
<li id="fn77"></li>
<li id="fn78"></li>
<li id="fn79"></li>
<li id="fn80"></li>
</ol>
</section>
</body>
</html>
