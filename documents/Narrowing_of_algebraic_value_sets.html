<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="962">Narrowing of algebraic value sets</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Narrowing of algebraic value sets</h1>
<hr/>

<p>Like <a href="logic_programming" title="wikilink">logic programming</a>, <strong>narrowing</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <strong>of algebraic value sets</strong> gives a method of reasoning about the values in unsolved or partially solved equations. Where logic programming relies on <a href="Resolution_(logic)" title="wikilink">resolution</a>, the algebra of value sets relies on narrowing rules. Narrowing rules allow the elimination of values from a solution set which are inconsistent with the equations being solved.</p>

<p>Unlike logic programming, narrowing of algebraic value sets makes no use of <a class="uri" href="backtracking" title="wikilink">backtracking</a>. Instead all values are contained in value sets, and are considered in parallel.</p>

<p>The approach is also similar to the use of <a href="Constraint_satisfaction" title="wikilink">constraints</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> in <a href="constraint_logic_programming" title="wikilink">constraint logic programming</a>, but without the logic processing basis.</p>

<p><a href="#Probabilistic_value_sets" title="wikilink">Probabilistic value sets</a> is a natural extension of value sets to <a href="Probability" title="wikilink">deductive probability</a>. The value set construct holds the information required to calculate probabilities of calculated values based on probabilities of initial values.</p>
<h2 id="history">History</h2>

<p>Early programming languages were <a href="Imperative_programming" title="wikilink">imperative</a>. These implement functionality by allowing change to be represented. The assignment statement allows a variable to change its value.</p>

<p>In mathematics a variable's value may not change. This is fundamental to the mathematical approach. <a href="Functional_programming" title="wikilink">Functional</a> languages based on <a href="lambda_calculus" title="wikilink">lambda calculus</a> allow this mathematical approach to programming. Functional languages developed by implementing <a href="lazy_evaluation" title="wikilink">lazy evaluation</a>, and allowing functions to be passed as parameters.</p>

<p>Lazy evaluation is an essential feature of modern <a href="functional_programming" title="wikilink">functional programming</a> languages such as <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>. Haskell is the latest in a series of languages based on <a href="lambda_calculus" title="wikilink">lambda calculus</a> and <a href="let_expression" title="wikilink">let expressions</a>. These languages provide rich functionality through lazy evaluation, and a <a href="Polymorphism_(computer_science)" title="wikilink">polymorphic type system</a> using <a href="Hindley–Milner_type_system" title="wikilink">type inference</a>. Functional programming languages also naturally support <a href="higher-order_function" title="wikilink">higher-order functions</a>.</p>

<p><a href="Logic_programming" title="wikilink">Logic programming</a> based on <a href="Resolution_(logic)" title="wikilink">Resolution</a> developed alongside functional programming. Logic programming is a form of <a href="relational_programming" title="wikilink">relational programming</a> that makes deductions about values. <a href="Constraint_logic_programming" title="wikilink">Constraint logic programming</a> extends logic programming, by supporting <a href="Constraint_satisfaction" title="wikilink">constraints</a>. Constraint logic programming languages such as <a class="uri" href="ECLiPSe" title="wikilink">ECLiPSe</a> provide the ability to solve complex logic problems. However ECLiPSe is not <a href="Lazy_evaluation" title="wikilink">lazy</a>.</p>

<p>Logic programming languages, although they have greater deduction abilities, never gained the power and flexibility of functional languages.</p>

<p>Narrowing is a technique that allows logical deduction, with the flexibility of functional languages.</p>
<h2 id="introduction">Introduction</h2>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> an expression represents a single value. A <a href="Function_(mathematics)" title="wikilink">function</a> maps one or more values to one unique value.</p>

<p>Inverses of functions are not always well defined as functions. Sometimes extra conditions are required to make an inverse of a function fit the definition of a function.</p>

<p>Some Boolean operations, in particular do not have inverses that may be defined as functions. In particular the <a class="uri" href="disjunction" title="wikilink">disjunction</a> "or" has inverses that allow two values. In natural language "or" represents alternate possibilities.</p>

<p>Narrowing is based on value sets that allow multiple values to be packaged and considered as a single value. This allows the inverses of functions to always be considered as functions.</p>

<p>To achieve this value sets must record the context to which a value belongs. A variable may only take on a single value in each <a href="possible_world" title="wikilink">possible world</a>. The value sets tag each value in the value set with the world to which it belongs.</p>

<p>Possible worlds belong to world sets. A world set is a set of all mutually exclusive worlds. Combining values from different possible worlds is impossible, because that would mean combining mutually exclusive possible worlds.</p>

<p>The application of functions to value sets creates combinations of value sets from different worlds. Narrowing reduces those worlds by eliminating combinations of different worlds from the same world set. Narrowing rules also detect situations where some combinations of worlds are shown to be impossible.</p>

<p>No back tracking is required in the use of narrowing. By packaging the possible values in a value set all combinations of values may be considered at the same time. Evaluation proceeds as for a functional language, combining combinations of values in value sets, with narrowing rules eliminating impossible values from the sets.</p>
<h2 id="introduction-to-value-sets">Introduction to value sets</h2>

<p>A <em>value set</em> is an object, which represents the set of values a variable may have. The value set behaves mathematically as a single value, while internally representing multiple values. To achieve this the value set tracks the value along with the context, or world, in which they occurred.</p>
<h3 id="multiple-solutions-to-an-equation">Multiple solutions to an equation</h3>

<p>In mathematics, an expression must represent a single value. For example consider the equation,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:0">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=4
  </annotation>
 </semantics>
</math>

 which implies,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=2x=-2
  </annotation>
 </semantics>
</math>

</p>

<p>But this is a bit long winded, and it does not allow us to work with multiple values at the same time. If further conditions or constraints are added to x we would like to consider each value to see if it matches the constraint. So naively we would like to write,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\pm 2
  </annotation>
 </semantics>
</math>

</p>

<p>Naively then,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mn>4</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
    <set>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <cn type="integer">4</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+x\in\{4,0,-4\}
  </annotation>
 </semantics>
</math>

</p>

<p>but this is wrong. Each x must represent a single value in the expression. Either x is 2 or x = −2. This can be resolved by keeping track of the two values so that we make sure that the values are used consistently, and this is what a value set does.</p>
<h3 id="representation">Representation</h3>

<p>The value set for 'x' is written as,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:4">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{2::x_{1},-2::x_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>It is container <em>V</em> which has a set of tag, value pairs,</p>
<ul>
<li>

<math display="inline" id="Narrowing_of_algebraic_value_sets:5">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">2</cn>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2::x_{1}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Narrowing_of_algebraic_value_sets:6">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>2</mn>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <cn type="integer">2</cn>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -2::x_{2}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The value 2 is associated with the <a href="Possible_worlds" title="wikilink">possible world</a> 

<math display="inline" id="Narrowing_of_algebraic_value_sets:7">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

. The value −2 is associated with the possible world 

<math display="inline" id="Narrowing_of_algebraic_value_sets:8">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

. This means that the value cannot be both 2 and −2 at the same time. In the world 

<math display="inline" id="Narrowing_of_algebraic_value_sets:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 the value of the value set must be 2. In the world 

<math display="inline" id="Narrowing_of_algebraic_value_sets:10">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 the value of the value set must be −2.</p>

<p>The solution of the equation,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:11">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=4
  </annotation>
 </semantics>
</math>

</p>

<p>is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:12">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{2::x_{1},-2::x_{2}\})
  </annotation>
 </semantics>
</math>

</p>
<h3 id="possible-worlds">Possible worlds</h3>

<p>A possible world is used here as an informal term. Formally a possible world is defined by a Boolean condition. A possible world may be considered the set of possibilities for the world that match the condition.</p>

<p>The term "possible world" is used to make the description of value sets easier to follow.</p>
<h3 id="world-sets">World sets</h3>

<p>A world set is a set of possible worlds that represent all possibilities. So 

<math display="inline" id="Narrowing_of_algebraic_value_sets:13">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{1},x_{2}\}
  </annotation>
 </semantics>
</math>

 is a world set as either x = 2 (in world 

<math display="inline" id="Narrowing_of_algebraic_value_sets:14">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

) or x= −2 (in world 

<math display="inline" id="Narrowing_of_algebraic_value_sets:15">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

). There are no other possibilities.</p>

<p>Worlds from the same world set are mutually exclusive, so it is not possible that the propositions for both worlds 

<math display="inline" id="Narrowing_of_algebraic_value_sets:16">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Narrowing_of_algebraic_value_sets:17">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 are true at the same time.</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mn>2</mn>
    <mi mathvariant="italic">and</mi>
    <mi>x</mi>
    <mo>=</mo>
    <mo>-</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mtext>false</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <cn type="integer">2</cn>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <minus></minus>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <mtext>false</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x=2\and x=-2)=\text{false}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="application-of-functions">Application of functions</h3>

<p>The rule for the application of functions to value sets is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:19">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <msub>
        <mi>m</mi>
        <mi>v</mi>
       </msub>
      </mpadded>
      <msub>
       <mi>n</mi>
       <mi>v</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>m</mi>
       <mi>l</mi>
      </msub>
      <mo>∩</mo>
      <msub>
       <mi>n</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <msub>
      <mi>m</mi>
      <mi>v</mi>
     </msub>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>m</mi>
      <mi>l</mi>
     </msub>
     <mo>∈</mo>
     <mi>M</mi>
     <mi mathvariant="italic">and</mi>
     <msub>
      <mi>n</mi>
      <mi>v</mi>
     </msub>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>n</mi>
      <mi>l</mi>
     </msub>
     <mo>∈</mo>
     <mi>N</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>v</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>v</ci>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>l</ci>
       </apply>
       <intersect></intersect>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>l</ci>
      </apply>
      <in></in>
      <csymbol cd="unknown">M</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>l</ci>
      </apply>
      <in></in>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)\ V(N)=V(\{(m_{v}\ n_{v},m_{l}\cap n_{l}):m_{v}::m_{l}\in M\and n_{v}::n_{%
l}\in N\})
  </annotation>
 </semantics>
</math>

</p>

<p>For example,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:20">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <plus></plus>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+x=V(\{2::x_{1},-2::x_{2}\})+V(\{2::x_{1},-2::x_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:21">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>+</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>+</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>2</mn>
     <mo>+</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>2</mn>
     <mo>+</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <minus></minus>
      <cn type="integer">2</cn>
      <plus></plus>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <minus></minus>
      <cn type="integer">2</cn>
      <plus></plus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">2</cn>
      <plus></plus>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">2</cn>
      <plus></plus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =V(\{-2+-2::x_{1}\cap x_{1},-2+2::x_{1}\cap x_{2},2+-2::x_{1}\cap x_{2},2+2::x%
_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:22">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>-</mo>
     <mn>4</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>0</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>0</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mi mathvariant="italic">and</mi>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>2</mn>
     <mo>+</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <minus></minus>
      <cn type="integer">4</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">0</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">0</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <csymbol cd="unknown">and</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">2</cn>
      <plus></plus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =V(\{-4::x_{1}\cap x_{1},0::x_{1}\cap x_{2},0::x_{2}\and x_{1},2+2::x_{2}\cap x%
_{1}\})
  </annotation>
 </semantics>
</math>

</p>

<p>The intersection of the possible world with itself is the possible world,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>∩</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\cap x_{1}=x_{1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:24">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>∩</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}\cap x_{2}=x_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>The intersection of the possible world with another possible world from the same world set is empty,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>∩</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\cap x_{2}=\{\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:26">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>∩</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}\cap x_{1}=\{\}
  </annotation>
 </semantics>
</math>

</p>

<p>So,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:27">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>-</mo>
     <mn>4</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>0</mn>
     <mo>:</mo>
     <mo>:</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>,</mo>
     <mn>0</mn>
     <mo>:</mo>
     <mo>:</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>,</mo>
     <mn>4</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <minus></minus>
      <cn type="integer">4</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">0</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-,</ci>
      <cn type="integer">0</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-,</ci>
      <cn type="integer">4</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =V(\{-4::x_{1},0::\{\},0::\{\},4::x_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>The empty worlds rule allows tagged values from empty worlds to be dropped</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:28">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>K</mi>
     <mi mathvariant="italic">and</mi>
     <mi>l</mi>
     <mo>≠</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-:</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">K</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">l</csymbol>
      <neq></neq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(K)=V(\{(v,l):(v,l)\in K\and l\neq\{\}\}
  </annotation>
 </semantics>
</math>

</p>

<p>giving,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:29">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>-</mo>
     <mn>4</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>4</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <minus></minus>
      <cn type="integer">4</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">4</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =V(\{-4::x_{1},4::x_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>Giving the result that 

<math display="inline" id="Narrowing_of_algebraic_value_sets:30">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>x</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+x
  </annotation>
 </semantics>
</math>

 is either −4 or 4, as expected.</p>
<h3 id="application-to-booleans">Application to Booleans</h3>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:31">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi mathvariant="italic">and</mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>italic- and</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\and b
  </annotation>
 </semantics>
</math>

</p>

<p>Is a relationship between <em>a</em>, <em>b</em> and <em>true</em> that implies that both <em>a</em> and <em>b</em> must be true.</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:32">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab
  </annotation>
 </semantics>
</math>

</p>

<p>Allows multiple values for <em>a</em> and <em>b</em>. If <em>a</em> is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:33">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>false</mo>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mo>true</mo>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <ci>false</ci>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>true</ci>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=V(\{\operatorname{false}::a_{1},\operatorname{true}::a_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>then for <em>b</em></p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:34">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>true</mo>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mo>false</mo>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mo>true</mo>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <ci>true</ci>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>false</ci>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>true</ci>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=V(\{\operatorname{true}::a_{1},\operatorname{false}::a_{2},\operatorname{%
true}::a_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>This means that if <em>a</em> is <em>false</em> then <em>b</em> must be <em>true</em>.</p>

<p>Now consider,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:35">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=2x=-2
  </annotation>
 </semantics>
</math>

</p>

<p>gives,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:36">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi mathvariant="normal">_</mi>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">_</csymbol>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\_::a_{1},2::a_{2}\})
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:37">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">_</mi>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">_</csymbol>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{-2::a_{1},\_::a_{2},-2::a_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>unifying these two value sets gives,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:38">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>-</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>2</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">2</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{-2::a_{1},2::a_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>The pair 

<math display="inline" id="Narrowing_of_algebraic_value_sets:39">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>2</mn>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <cn type="integer">2</cn>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -2::a_{2}
  </annotation>
 </semantics>
</math>

 is dropped because of the "assert equal" rule,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:40">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>l</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>m</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>v</mi>
    </msub>
    <mo>≠</mo>
    <msub>
     <mi>n</mi>
     <mi>v</mi>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>m</mi>
     <mi>l</mi>
    </msub>
    <mo>∩</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>l</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>l</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>v</ci>
     </apply>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>l</ci>
     </apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall m_{v}\forall m_{l}\forall n_{v}\forall n_{l}((m_{v},m_{l})\in M\and(n_%
{v},n_{l})\in N)\to(m_{v}\neq n_{v}\to m_{l}\cap n_{l}=\{\})
  </annotation>
 </semantics>
</math>

</p>

<p>Its value 

<math display="inline" id="Narrowing_of_algebraic_value_sets:41">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>2</mn>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <cn type="integer">2</cn>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -2::a_{2}
  </annotation>
 </semantics>
</math>

 did not match with 

<math display="inline" id="Narrowing_of_algebraic_value_sets:42">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>:</mo>
   <mo>:</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">2</cn>
    <ci>normal-:</ci>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2::a_{2}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="dependent-worlds">Dependent worlds</h3>

<p>Consider the problem,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:43">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>3</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>4</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">1</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">3</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">4</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=V(\{1::x_{1},3::x_{2},4::x_{3}\})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:44">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>8</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>9</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">8</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">9</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=V(\{8::y_{1},9::y_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>*</mo>
    <mi>Y</mi>
   </mrow>
   <mo><</mo>
   <mn>25</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <cn type="integer">25</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X*Y<25
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>+</mo>
    <mi>Y</mi>
   </mrow>
   <mo>></mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <cn type="integer">10</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X+Y>10
  </annotation>
 </semantics>
</math>

</p>

<p>Firstly calculate the value set for 

<math display="inline" id="Narrowing_of_algebraic_value_sets:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>*</mo>
    <mi>Y</mi>
   </mrow>
   <mo><</mo>
   <mn>25</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <cn type="integer">25</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X*Y<25
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:48">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>8</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>24</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>32</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>9</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>27</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>36</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo><</mo>
   <mn>25</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">8</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">24</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">32</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">9</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">27</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">36</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <lt></lt>
    <cn type="integer">25</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{8::x_{1}\cap y_{1},24::x_{2}\cap y_{1},32::x_{3}\cap y_{1},9::x_{1}\cap y_%
{2},27::x_{2}\cap y_{2},36::x_{3}\cap y_{2}\})<25
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:49">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>8</mn>
     <mo><</mo>
     <mn>25</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>24</mn>
     <mo><</mo>
     <mn>25</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>32</mn>
     <mo><</mo>
     <mn>25</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>9</mn>
     <mo><</mo>
     <mn>25</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>27</mn>
     <mo><</mo>
     <mn>25</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>36</mn>
     <mo><</mo>
     <mn>25</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo><</mo>
   <mn>25</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">8</cn>
      <lt></lt>
      <cn type="integer">25</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">24</cn>
      <lt></lt>
      <cn type="integer">25</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">32</cn>
      <lt></lt>
      <cn type="integer">25</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">9</cn>
      <lt></lt>
      <cn type="integer">25</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">27</cn>
      <lt></lt>
      <cn type="integer">25</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">36</cn>
      <lt></lt>
      <cn type="integer">25</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <lt></lt>
    <cn type="integer">25</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{8<25::x_{1}\cap y_{1},24<25::x_{2}\cap y_{1},32<25::x_{3}\cap y_{1},9<25::%
x_{1}\cap y_{2},27<25::x_{2}\cap y_{2},36<25::x_{3}\cap y_{2}\})<25
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:50">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>true</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mtext>true</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mtext>false</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mtext>true</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mtext>false</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mtext>false</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>true</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>true</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>false</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>true</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>false</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>false</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{\text{true}::x_{1}\cap y_{1},\text{true}::x_{2}\cap y_{1},\text{false}::x_%
{3}\cap y_{1},\text{true}::x_{1}\cap y_{2},\text{false}::x_{2}\cap y_{2},\text%
{false}::x_{3}\cap y_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>As this statement is asserted true, all the false values are dropped giving,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:51">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>true</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mtext>true</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mtext>true</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>true</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>true</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>true</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{\text{true}::x_{1}\cap y_{1},\text{true}::x_{2}\cap y_{2},\text{true}::x_{%
1}\cap y_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>The worlds,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:52">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>∩</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{3}\cap y_{1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:53">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>∩</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}\cap y_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:54">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>∩</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{3}\cap y_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>are impossible. The worlds are empty.</p>

<p>If a world set is included in a calculation then every world from the world set must be included in the result. If a world is not found, it is called a dependent world, and must be empty. The world 

<math display="inline" id="Narrowing_of_algebraic_value_sets:55">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{3}
  </annotation>
 </semantics>
</math>

 is not represented in this value, and so must be empty. The value set for 

<math display="inline" id="Narrowing_of_algebraic_value_sets:56">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is now smaller,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:57">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>3</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">1</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">3</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=V(\{1::x_{1},3::x_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>The second condition is now simpler, because of the smaller value set.</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>+</mo>
    <mi>Y</mi>
   </mrow>
   <mo>></mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <cn type="integer">10</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X+Y>10
  </annotation>
 </semantics>
</math>

</p>

<p>Then the value sets are,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:59">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>3</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">1</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">3</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=V(\{1::x_{1},3::x_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:60">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>8</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>9</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">8</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">9</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=V(\{8::y_{1},9::y_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>And the calculation is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:61">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>+</mo>
     <mn>8</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>3</mn>
     <mo>+</mo>
     <mn>8</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>2</mn>
     <mo>+</mo>
     <mn>9</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mn>1</mn>
     <mo>+</mo>
     <mn>9</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">1</cn>
      <plus></plus>
      <cn type="integer">8</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">3</cn>
      <plus></plus>
      <cn type="integer">8</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">2</cn>
      <plus></plus>
      <cn type="integer">9</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">1</cn>
      <plus></plus>
      <cn type="integer">9</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <gt></gt>
    <cn type="integer">10</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{1+8::x_{1}\cap y_{1},3+8::x_{2}\cap y_{1},2+9::x_{1}\cap y_{2},1+9::x_{2}%
\cap y_{2}\})>10
  </annotation>
 </semantics>
</math>

</p>

<p>But 

<math display="inline" id="Narrowing_of_algebraic_value_sets:62">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>∩</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}\cap y_{2}
  </annotation>
 </semantics>
</math>

 is empty. So,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:63">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>9</mn>
     <mo>></mo>
     <mn>10</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>11</mn>
     <mo>></mo>
     <mn>10</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mn>10</mn>
     <mo>></mo>
     <mn>10</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">9</cn>
      <gt></gt>
      <cn type="integer">10</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">11</cn>
      <gt></gt>
      <cn type="integer">10</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <cn type="integer">10</cn>
      <gt></gt>
      <cn type="integer">10</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{9>10::x_{1}\cap y_{1},11>10::x_{2}\cap y_{1},10>10::x_{1}\cap y_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>So 

<math display="inline" id="Narrowing_of_algebraic_value_sets:64">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>∩</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\cap y_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Narrowing_of_algebraic_value_sets:65">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>∩</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\cap y_{2}
  </annotation>
 </semantics>
</math>

 are empty,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:66">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>11</mn>
     <mo>></mo>
     <mn>10</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">11</cn>
      <gt></gt>
      <cn type="integer">10</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{11>10::x_{2}\cap y_{1}\})
  </annotation>
 </semantics>
</math>

</p>

<p>Now 

<math display="inline" id="Narrowing_of_algebraic_value_sets:67">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Narrowing_of_algebraic_value_sets:68">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{2}
  </annotation>
 </semantics>
</math>

 are not represented, and are removed as dependent worlds. So,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:69">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>3</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">3</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">3</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=V(\{3::x_{2}\})=3
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:70">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>8</mn>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>8</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Y</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">8</cn>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">8</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=V(\{8::y_{1}\})=8
  </annotation>
 </semantics>
</math>

</p>

<p>Every calculation made may reduce the size of value sets by removing dependent worlds, but add a new value set whose size is the product of the sizes of the input value sets. Then calculations should proceed first where the product of the sizes of the input value sets is smallest.</p>
<h3 id="pizza-beer-whiskey">Pizza, beer, whiskey</h3>

<p>After a hard day's work attempting to meet some crazy deadline with the project from hell, there comes that desperate time at 10 PM when we all need pizza, beer, and whiskey. Pizza shops are open at,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:71">
 <semantics>
  <mrow>
   <mtext>PizzaShop</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mtext>Carlton</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mtext>Richmond</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>p</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mtext>South Melbourne</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>p</mi>
       <mn>3</mn>
      </msub>
      <mo>,</mo>
      <mtext>Footscray</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>p</mi>
       <mn>4</mn>
      </msub>
      <mo>,</mo>
      <mtext>St Kilda</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>p</mi>
       <mn>5</mn>
      </msub>
      <mo>,</mo>
      <mtext>Toorak</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>p</mi>
       <mn>6</mn>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>PizzaShop</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <mtext>Carlton</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <mtext>Richmond</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-,</ci>
       <mtext>South Melbourne</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>normal-,</ci>
       <mtext>Footscray</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">4</cn>
       </apply>
       <ci>normal-,</ci>
       <mtext>St Kilda</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">5</cn>
       </apply>
       <ci>normal-,</ci>
       <mtext>Toorak</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">6</cn>
       </apply>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{PizzaShop}(V(\{\text{Carlton}::p_{1},\text{Richmond}::p_{2},\text{South %
Melbourne}::p_{3},\text{Footscray}::p_{4},\text{St Kilda}::p_{5},\text{Toorak}%
::p_{6}\}))
  </annotation>
 </semantics>
</math>

</p>

<p>Beer you can get at,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:72">
 <semantics>
  <mrow>
   <mtext>BottleshopWithBeer</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mtext>South Melbourne</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mtext>St Kilda</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>b</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mtext>Carlton</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>b</mi>
       <mn>3</mn>
      </msub>
      <mo>,</mo>
      <mtext>Docklands</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>b</mi>
       <mn>4</mn>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>BottleshopWithBeer</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <mtext>South Melbourne</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <mtext>St Kilda</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-,</ci>
       <mtext>Carlton</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>normal-,</ci>
       <mtext>Docklands</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">4</cn>
       </apply>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{BottleshopWithBeer}(V(\{\text{South Melbourne}::b_{1},\text{St Kilda}::b%
_{2},\text{Carlton}::b_{3},\text{Docklands}::b_{4}\}))
  </annotation>
 </semantics>
</math>

</p>

<p>Whiskey,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:73">
 <semantics>
  <mrow>
   <mtext>BottleshopWithWhiskey</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mtext>Essendon</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>w</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mtext>South Melbourne</mtext>
      <mo>:</mo>
      <mo>:</mo>
      <msub>
       <mi>w</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>BottleshopWithWhiskey</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <mtext>Essendon</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <mtext>South Melbourne</mtext>
       <ci>normal-:</ci>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{BottleshopWithWhiskey}(V(\{\text{Essendon}::w_{1},\text{South Melbourne}%
::w_{2}\}))
  </annotation>
 </semantics>
</math>

</p>

<p>The cops are about and we are not getting any younger. Where to go?</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:74">
 <semantics>
  <mrow>
   <mrow>
    <mtext>WhereToGo</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mtext>PizzaShop</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mtext>BottleshopWithBeer</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mtext>BottleshopWithWhiskey</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>WhereToGo</mtext>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>PizzaShop</mtext>
     <ci>x</ci>
     <ci>italic- and</ci>
     <mtext>BottleshopWithBeer</mtext>
     <ci>x</ci>
     <ci>italic- and</ci>
     <mtext>BottleshopWithWhiskey</mtext>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{WhereToGo}(x)=\text{PizzaShop}(x)\and\text{BottleshopWithBeer}(x)\and%
\text{BottleshopWithWhiskey}(x)
  </annotation>
 </semantics>
</math>

</p>

<p><strong>If the constraints are applied in the order left to right</strong>,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:75">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>Carlton</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mtext>Richmond</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>p</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mtext>South Melbourne</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>p</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mtext>Footscray</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>p</mi>
      <mn>4</mn>
     </msub>
     <mo>,</mo>
     <mtext>St Kilda</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>p</mi>
      <mn>5</mn>
     </msub>
     <mo>,</mo>
     <mtext>Toorak</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>p</mi>
      <mn>6</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>Carlton</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>Richmond</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>South Melbourne</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>Footscray</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>St Kilda</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">5</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>Toorak</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">6</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\text{Carlton}::p_{1},\text{Richmond}::p_{2},\text{South Melbourne}::p_{%
3},\text{Footscray}::p_{4},\text{St Kilda}::p_{5},\text{Toorak}::p_{6}\})
  </annotation>
 </semantics>
</math>

</p>

<p>Then we need to unify this with,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:76">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>South Melbourne</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mtext>St Kilda</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mtext>Carlton</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mtext>Docklands</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>4</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>South Melbourne</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>St Kilda</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>Carlton</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>Docklands</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\text{South Melbourne}::b_{1},\text{St Kilda}::b_{2},\text{Carlton}::b_{%
3},\text{Docklands}::b_{4}\})
  </annotation>
 </semantics>
</math>

</p>

<p>This will create 24 combinations from which the matching ones are,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:77">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>South Melbourne</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>p</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mtext>St Kilda</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>p</mi>
      <mn>5</mn>
     </msub>
     <mo>,</mo>
     <mtext>Carlton</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>3</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>South Melbourne</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>St Kilda</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">5</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>Carlton</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">3</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\text{South Melbourne}::b_{1}\cap p_{3},\text{St Kilda}::b_{2}\cap p_{5}%
,\text{Carlton}::b_{3}\cap p_{1}\})
  </annotation>
 </semantics>
</math>

</p>

<p>Finally we need to unify with whiskey.</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:78">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>Essendon</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>w</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mtext>South Melbourne</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>w</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>Essendon</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>South Melbourne</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\text{Essendon}::w_{1},\text{South Melbourne}::w_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>Which gives 6 combinations. The matching one is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:79">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>South Melbourne</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>p</mi>
      <mn>3</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>w</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>South Melbourne</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">3</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\text{South Melbourne}::b_{1}\cap p_{3}\cap w_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>A total of 30 combinations were generated.</p>

<p><strong>If the constraints are applied in the order right to left</strong>,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:80">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>Essendon</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>w</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mtext>South Melbourne</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>w</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>Essendon</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>South Melbourne</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\text{Essendon}::w_{1},\text{South Melbourne}::w_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>Then we need to unify this with,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:81">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>South Melbourne</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mtext>St Kilda</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mtext>Carlton</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mtext>Docklands</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>4</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>South Melbourne</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>St Kilda</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>Carlton</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-,</ci>
      <mtext>Docklands</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">4</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\text{South Melbourne}::b_{1},\text{St Kilda}::b_{2},\text{Carlton}::b_{%
3},\text{Docklands}::b_{4}\})
  </annotation>
 </semantics>
</math>

</p>

<p>This will create 8 combinations from which the matching one is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:82">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>South Melbourne</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <msub>
      <mi>w</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>South Melbourne</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\text{South Melbourne}::b_{1}\cap w_{2}\})
  </annotation>
 </semantics>
</math>

</p>

<p>Finally we need to unify with pizza.</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:83">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mtext>Carlton</mtext>
    <mo>:</mo>
    <mo>:</mo>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mtext>Richmond</mtext>
    <mo>:</mo>
    <mo>:</mo>
    <msub>
     <mi>p</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mtext>South Melbourne</mtext>
    <mo>:</mo>
    <mo>:</mo>
    <msub>
     <mi>p</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <mtext>Footscray</mtext>
    <mo>:</mo>
    <mo>:</mo>
    <msub>
     <mi>p</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <mtext>St Kilda</mtext>
    <mo>:</mo>
    <mo>:</mo>
    <msub>
     <mi>p</mi>
     <mn>5</mn>
    </msub>
    <mo>,</mo>
    <mtext>Toorak</mtext>
    <mo>:</mo>
    <mo>:</mo>
    <msub>
     <mi>p</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <mtext>Carlton</mtext>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <mtext>Richmond</mtext>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <mtext>South Melbourne</mtext>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-,</ci>
     <mtext>Footscray</mtext>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-,</ci>
     <mtext>St Kilda</mtext>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>normal-,</ci>
     <mtext>Toorak</mtext>
     <ci>normal-:</ci>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\{\text{Carlton}::p_{1},\text{Richmond}::p_{2},\text{South Melbourne}::p_{3}%
,\text{Footscray}::p_{4},\text{St Kilda}::p_{5},\text{Toorak}::p_{6}\}
  </annotation>
 </semantics>
</math>

</p>

<p>Which gives 6 combinations. The matching one is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:84">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>South Melbourne</mtext>
     <mo>:</mo>
     <mo>:</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>∩</mo>
     <mpadded width="+5pt">
      <msub>
       <mi>w</mi>
       <mn>2</mn>
      </msub>
     </mpadded>
     <mo>∩</mo>
     <msub>
      <mi>p</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>South Melbourne</mtext>
      <ci>normal-:</ci>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(\{\text{South Melbourne}::b_{1}\cap w_{2}\ \cap p_{3}\})
  </annotation>
 </semantics>
</math>

</p>

<p>The result is the same but only 14 combinations were generated to arrive at the conclusion.</p>

<p>Every calculation combines value sets to create a value set which is the product of the sizes of the input value sets. The value set will then be trimmed down. And every calculation has an equal chance of narrowing the calculation. So by controlling the order and proceeding with calculations with the smallest product of sizes, there will be less calculation and less <a href="combinatorial_explosion" title="wikilink">combinatorial explosion</a>.</p>
<h2 id="let-expressions-and-multiple-values">Let expressions and multiple values</h2>

<p>A general solution to the problem of inverses of functions that are not functions is needed. What is required is a representation of a value that is constrained to be a member of a set of values. A <a href="let_expression" title="wikilink">let expression</a> may be used to represent a value that is a member of a set,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:85">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo>in</mo>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>let</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <ci>in</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}x\in X\operatorname{in}x
  </annotation>
 </semantics>
</math>

</p>

<p>In this expression 

<math display="inline" id="Narrowing_of_algebraic_value_sets:86">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

 is a constraint. A constraint is a Boolean expression that a variable must satisfy. The <em>let</em> expression allows the constraint be represented in an expression. If there was a general rule for function application of constraint expressions, then a constraint could be treated like a value.</p>

<p>Under function application, of one let expression to another,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:87">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo>in</mo>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>y</mi>
    <mo>∈</mo>
    <mi>Y</mi>
    <mo>in</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">y</csymbol>
     <in></in>
     <csymbol cd="unknown">Y</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{let}x\in X\operatorname{in}x)\ (\operatorname{let}y\in Y%
\operatorname{in}y)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:88">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>X</mi>
    <mi mathvariant="italic">and</mi>
    <mi>y</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>italic- and</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Y</ci>
      <apply>
       <ci>in</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}x\in X\and y\in Y\operatorname{in}x\ y
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:89">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi>Y</mi>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(x,y)\in X\times Y\operatorname{in}x\ y
  </annotation>
 </semantics>
</math>

</p>

<p>But a different rule applies for applying the let expression to itself. Note that the let expression does not restrict the scope of the variable x, so x is the same variable in the two let expressions.</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:90">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo>in</mo>
    <mi>x</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo>in</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{let}x\in X\operatorname{in}x)\ (\operatorname{let}x\in X%
\operatorname{in}x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:91">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>X</ci>
      <apply>
       <ci>in</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}x\in X\operatorname{in}x\ x
  </annotation>
 </semantics>
</math>

</p>

<p>There appears no simple rule for combining let expressions. What is required is a general form of expression that represents a variable whose value is a member of a set of values. The expression should be based on the variable and the set.</p>

<p>Function application applied to this form should give another expression in the same form. In this way any expression on functions of multiple values may be treated as if it had one value.</p>

<p>It is not sufficient for the form to represent only the set of values. Each value must have a condition that determines when the expression takes the value. The resulting construct is a set of pairs of conditions and values, called a "value set".</p>
<h2 id="theory-of-value-sets">Theory of value sets</h2>

<p>A "value set" <em>K</em> is defined as a set of pairs, each pair consisting of a value and a set of dependent conditions. The set of dependent conditions is used by the "condition function", to determine if the value set takes that value.</p>

<p>The condition function is defined by 3 axioms,</p>
<ol>
<li>Each pair 

<math display="inline" id="Narrowing_of_algebraic_value_sets:92">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>v</mi>
   <mo>,</mo>
   <mi>l</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>l</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,l)
  </annotation>
 </semantics>
</math>

 means that the value of the value set 

<math display="inline" id="Narrowing_of_algebraic_value_sets:93">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(K)
  </annotation>
 </semantics>
</math>

 is <em>v</em> if the condition function applied to the list, 

<math display="inline" id="Narrowing_of_algebraic_value_sets:94">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(l)
  </annotation>
 </semantics>
</math>

, is true.</li>
<li>One of the conditions is true.</li>
<li>Only one of the conditions is true.</li>
</ol>

<p>The condition is represented as a function applied to a set of dependent conditions, to allow the structure of the condition to be controlled. Also the set of conditions is used in <a href="#Narrowing_by_exclusion_of_dependent_values" title="wikilink">narrowing by exclusion of dependent values</a>. However for most purposes the value set may be thought of as a set of value, condition pairs. The condition function translates the set into the condition.</p>

<p>Formally,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Definition</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Condition function</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:95">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>l</mi>
     </mrow>
    </msub>
    <mi>z</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mo stretchy="false">(</mo>
   <mo>∀</mo>
   <mi>r</mi>
   <mo>∀</mo>
   <mi>z</mi>
   <mo>∀</mo>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>l</mi>
   <mo>→</mo>
   <mi>z</mi>
   <mo>=</mo>
   <mi>u</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <vector>
        <ci>r</ci>
        <ci>z</ci>
        <ci>u</ci>
       </vector>
       <ci>l</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <eq></eq>
    <ci>normal-(</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">l</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">z</csymbol>
    <eq></eq>
    <csymbol cd="unknown">u</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(l)=({\bigwedge_{(r,z,u)\in l}z=u}))=(\forall r\forall z\forall u(r,z,u)\in l%
\to z=u)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Value condition</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:96">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∀</mo>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>v</mi>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">v</csymbol>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\forall l((v,l)\in K\and C(l)\to v=V(K)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Complete set</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:97">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>l</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo>,</mo>
        <mi>l</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>v</ci>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <ci>l</ci>
        <interval closure="open">
         <ci>v</ci>
         <ci>l</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>italic- and</ci>
     <ci>C</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists v\exists l(v,l)\in K\and C(l)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Exclusion</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:98">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>l</mi>
    <mn>1</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>l</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>l</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <neq></neq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v_{1}\forall l_{1}\forall v_{2}\forall l_{2}((v_{1},l_{1})\in K\and(v_%
{2},l_{2})\in K\and(v_{1},l_{1})\neq(v_{2},l_{2}))\to\neg(C(l_{1})\and C(l_{2}))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h3 id="value-function">Value function</h3>

<p>Using the value condition and complete set axioms,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:99">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>l</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo>,</mo>
        <mi>l</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>v</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>v</ci>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>l</ci>
         <interval closure="open">
          <ci>v</ci>
          <ci>l</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <ci>italic- and</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists v\exists l(v,l)\in K\and C(l)\and v=V(K)
  </annotation>
 </semantics>
</math>

</p>

<p>As a let expression this becomes,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:100">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(K)=\operatorname{let}(v,l)\in K\and C(l)\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>
<h3 id="single-value">Single value</h3>

<p>The value set to represent a single value is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:101">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo>,</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <set>
      <interval closure="open">
       <ci>k</ci>
       <list></list>
      </interval>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=V(\{(k,\{\})\})
  </annotation>
 </semantics>
</math>

</p>

<p>The derivation is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:102">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <set>
     <interval closure="open">
      <ci>k</ci>
      <list></list>
     </interval>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{(k,\{\})\})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:103">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <set>
       <interval closure="open">
        <ci>k</ci>
        <list></list>
       </interval>
      </set>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(v,l)\in\{(k,\{\})\}\and C(l)\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:104">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mi>v</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>italic- and</ci>
      <ci>C</ci>
      <list></list>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}v=k\and C(\{\})\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:105">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mi>v</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>k</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}v=k\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:106">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =k
  </annotation>
 </semantics>
</math>

</p>
<h3 id="element-of-a-set">Element of a set</h3>

<p>The value set to represent an element of a set is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:107">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>∀</mo>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo>in</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>let</mo>
   <mi>R</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>R</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mi>w</mi>
     <mo>∈</mo>
     <mi>X</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <ci>let</ci>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-,</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-{</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">R</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">w</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-}</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-:</ci>
      <csymbol cd="unknown">w</csymbol>
      <in></in>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">R</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\forall X(\operatorname{let}x\in X\operatorname{in}x)=\operatorname{%
let}R=V(\{(w,\{(R,x,w)\}):w\in X\})\operatorname{in}R
  </annotation>
 </semantics>
</math>

</p>

<p>This rather strange definition adds the value set in as part of the dependent condition. This is used in <a href="#Narrowing_by_exclusion_of_dependent_values" title="wikilink">narrowing by exclusion of dependent values</a>.</p>

<p>Note also that,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:108">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=V(R)
  </annotation>
 </semantics>
</math>

</p>

<p>is the value of the expression. Both <em>R</em> and <em>x</em> must be included in the dependent condition, because <em>R</em> identifies the value set to which the dependent condition belongs, and <em>x</em> provides the variable used to carry the value in the let expression.</p>

<p>If the addition of <em>R</em> to the dependent condition is ignored, the expression takes on a simpler and more understandable form,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:109">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>∀</mo>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo>in</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">_</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mi>w</mi>
     <mo>∈</mo>
     <mi>X</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-,</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-{</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">_</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">w</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-}</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-:</ci>
      <csymbol cd="unknown">w</csymbol>
      <in></in>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\forall X(\operatorname{let}x\in X\operatorname{in}x)=V(\{(w,\{(\_,x,%
w)\}):w\in X\})
  </annotation>
 </semantics>
</math>

</p>

<p>The derivation is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:110">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>r</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>:</mo>
       <mi>w</mi>
       <mo>∈</mo>
       <mi>X</mi>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-,</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-{</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">r</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">w</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-:</ci>
        <csymbol cd="unknown">w</csymbol>
        <in></in>
        <csymbol cd="unknown">X</csymbol>
        <ci>normal-}</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{(w,\{(r,x,w):w\in X\})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:111">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>r</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mi>w</mi>
      <mo>∈</mo>
      <mi>X</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <interval closure="open">
        <ci>w</ci>
        <set>
         <vector>
          <ci>r</ci>
          <ci>x</ci>
          <ci>w</ci>
         </vector>
        </set>
       </interval>
       <apply>
        <in></in>
        <ci>w</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(v,l)\in\{(w,\{(r,x,w)\}):w\in X\}\and C(l)\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:112">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mo>let</mo>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>X</mi>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">_</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </munder>
    <mi>z</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <ci>let</ci>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <csymbol cd="unknown">X</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <vector>
        <ci>r</ci>
        <ci>z</ci>
        <ci>u</ci>
       </vector>
       <set>
        <vector>
         <ci>normal-_</ci>
         <ci>x</ci>
         <ci>v</ci>
        </vector>
       </set>
      </apply>
     </apply>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">v</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}v\in X\and({\bigwedge_{(r,z,u)\in\{(\_,x,v)\}}z=u})%
\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:113">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mo>let</mo>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>X</mi>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>r</mi>
    <mo>∀</mo>
    <mi>z</mi>
    <mo>∀</mo>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">_</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>→</mo>
    <mi>z</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <ci>let</ci>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <csymbol cd="unknown">X</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">_</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">v</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}v\in X\and(\forall r\forall z\forall u(r,z,u)\in\{(\_,x,v)%
\}\to z=u)\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:114">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mi>v</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>X</mi>
    <mi mathvariant="italic">and</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>italic- and</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>v</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}v\in X\and x=v\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:115">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo>in</mo>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>X</ci>
      <apply>
       <ci>in</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}x\in X\operatorname{in}x
  </annotation>
 </semantics>
</math>

</p>
<h3 id="application-of-functions-1">Application of functions</h3>

<p>Function application of value sets is given by,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:116">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <msub>
          <mi>m</mi>
          <mi>v</mi>
         </msub>
        </mpadded>
        <msub>
         <mi>n</mi>
         <mi>v</mi>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>m</mi>
         <mi>l</mi>
        </msub>
        <mo>∪</mo>
        <msub>
         <mi>n</mi>
         <mi>l</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>m</mi>
         <mi>v</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>m</mi>
         <mi>l</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mi>M</mi>
        <mi mathvariant="italic">and</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>n</mi>
          <mi>v</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>n</mi>
          <mi>l</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∈</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>M</ci>
     <ci>V</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>v</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>v</ci>
        </apply>
       </apply>
       <apply>
        <union></union>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>l</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </interval>
      <apply>
       <and></and>
       <apply>
        <in></in>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>v</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>l</ci>
         </apply>
        </interval>
        <apply>
         <times></times>
         <ci>M</ci>
         <ci>italic- and</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>v</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>l</ci>
          </apply>
         </interval>
        </apply>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)\ V(N)=V(\{(m_{v}\ n_{v},m_{l}\cup n_{l}):(m_{v},m_{l})\in M\and(n_{v},n_{%
l})\in N\})
  </annotation>
 </semantics>
</math>

</p>

<p>Derivation,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:117">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>M</ci>
    <ci>V</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)\ V(N)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:118">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mo>let</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>v</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>M</mi>
   <mi mathvariant="italic">and</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <msub>
    <mi>m</mi>
    <mi>v</mi>
   </msub>
   <mo rspace="7.5pt" stretchy="false">)</mo>
   <mo stretchy="false">(</mo>
   <mo>let</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mi>v</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>N</mi>
   <mi mathvariant="italic">and</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <msub>
    <mi>n</mi>
    <mi>v</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <ci>let</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">M</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-)</ci>
    <ci>normal-(</ci>
    <ci>let</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">N</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(m_{v},m_{l})\in M\and C(m_{l})\operatorname{in}m_{v})\ (%
\operatorname{let}(n_{v},n_{l})\in N\and C(n_{l})\operatorname{in}n_{v})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:119">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mo>let</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>v</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>M</mi>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mi>v</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>N</mi>
   <mi mathvariant="italic">and</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mpadded width="+5pt">
    <msub>
     <mi>m</mi>
     <mi>v</mi>
    </msub>
   </mpadded>
   <msub>
    <mi>n</mi>
    <mi>v</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <ci>let</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">M</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">N</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(m_{v},m_{l})\in M\and(n_{v},n_{l})\in N\and C(n_{l})\and C%
(n_{l})\operatorname{in}m_{v}\ n_{v})
  </annotation>
 </semantics>
</math>

</p>

<p>Then using,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:120">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>l</ci>
    </apply>
    <ci>italic- and</ci>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(m_{l})\and C(n_{l})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:121">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <msub>
       <mi>m</mi>
       <mi>l</mi>
      </msub>
     </mrow>
    </munder>
    <mi>z</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <msub>
       <mi>n</mi>
       <mi>l</mi>
      </msub>
     </mrow>
    </munder>
    <mi>z</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>z</ci>
        <ci>u</ci>
       </interval>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>l</ci>
       </apply>
      </apply>
     </apply>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>z</ci>
        <ci>u</ci>
       </interval>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>l</ci>
       </apply>
      </apply>
     </apply>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =({\bigwedge_{(z,u)\in m_{l}}z=u})\and({\bigwedge_{(z,u)\in n_{l}}z=u})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:122">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <msub>
        <mi>m</mi>
        <mi>l</mi>
       </msub>
       <mo>∪</mo>
       <msub>
        <mi>n</mi>
        <mi>l</mi>
       </msub>
      </mrow>
     </mrow>
    </munder>
    <mi>z</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>z</ci>
        <ci>u</ci>
       </interval>
       <apply>
        <union></union>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>l</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =({\bigwedge_{(z,u)\in m_{l}\cup n_{l}}z=u})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:123">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>m</mi>
       <mi>l</mi>
      </msub>
      <mo>∪</mo>
      <msub>
       <mi>n</mi>
       <mi>l</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <union></union>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>l</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =C(m_{l}\cup n_{l})
  </annotation>
 </semantics>
</math>

</p>

<p>get,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:124">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mo>let</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>v</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>M</mi>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mi>v</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>N</mi>
   <mi mathvariant="italic">and</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo>∪</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mpadded width="+5pt">
    <msub>
     <mi>m</mi>
     <mi>v</mi>
    </msub>
   </mpadded>
   <msub>
    <mi>n</mi>
    <mi>v</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <ci>let</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">M</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">N</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(m_{v},m_{l})\in M\and(n_{v},n_{l})\in N\and C(n_{l}\cup n_%
{l})\operatorname{in}m_{v}\ n_{v})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:125">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <msub>
         <mi>m</mi>
         <mi>v</mi>
        </msub>
       </mpadded>
       <msub>
        <mi>n</mi>
        <mi>v</mi>
       </msub>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>m</mi>
        <mi>l</mi>
       </msub>
       <mo>∪</mo>
       <msub>
        <mi>n</mi>
        <mi>l</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>m</mi>
        <mi>v</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>m</mi>
        <mi>l</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mi>M</mi>
       <mi mathvariant="italic">and</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>n</mi>
         <mi>v</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>n</mi>
         <mi>l</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∈</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>v</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>v</ci>
         </apply>
        </apply>
        <apply>
         <union></union>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>l</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>l</ci>
         </apply>
        </apply>
       </interval>
       <apply>
        <and></and>
        <apply>
         <in></in>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <ci>v</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <ci>l</ci>
          </apply>
         </interval>
         <apply>
          <times></times>
          <ci>M</ci>
          <ci>italic- and</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>n</ci>
            <ci>v</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>n</ci>
            <ci>l</ci>
           </apply>
          </interval>
         </apply>
        </apply>
        <apply>
         <in></in>
         <share href="#.cmml">
         </share>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(v,l)\in\{(m_{v}\ n_{v},m_{l}\cup n_{l}):(m_{v},m_{l})\in M%
\and(n_{v},n_{l})\in N\}\and C(l)\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:126">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <msub>
          <mi>m</mi>
          <mi>v</mi>
         </msub>
        </mpadded>
        <msub>
         <mi>n</mi>
         <mi>v</mi>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>m</mi>
         <mi>l</mi>
        </msub>
        <mo>∪</mo>
        <msub>
         <mi>n</mi>
         <mi>l</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>m</mi>
         <mi>v</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>m</mi>
         <mi>l</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mi>M</mi>
        <mi mathvariant="italic">and</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>n</mi>
          <mi>v</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>n</mi>
          <mi>l</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∈</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>v</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>v</ci>
        </apply>
       </apply>
       <apply>
        <union></union>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>l</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </interval>
      <apply>
       <and></and>
       <apply>
        <in></in>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>v</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>l</ci>
         </apply>
        </interval>
        <apply>
         <times></times>
         <ci>M</ci>
         <ci>italic- and</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>v</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>l</ci>
          </apply>
         </interval>
        </apply>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =V(\{(m_{v}\ n_{v},m_{l}\cup n_{l}):(m_{v},m_{l})\in M\and(n_{v},n_{l})\in N\})
  </annotation>
 </semantics>
</math>

</p>
<h3 id="exclusion">Exclusion</h3>

<p>The exclusion is a rule that determines when conditions must be false,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:127">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>s</mi>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>v</mi>
    <mo>∀</mo>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>M</mi>
     <mi mathvariant="italic">and</mi>
     <mi>v</mi>
     <mo>∉</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">M</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">v</csymbol>
      <notin></notin>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)\in s\iff(\forall v\forall l((v,l)\in M\and v\not\in s)\to\neg C(l))
  </annotation>
 </semantics>
</math>

</p>

<p>This may be derived from,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:128">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>M</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)\in s
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:129">
 <semantics>
  <mrow>
   <mo>→</mo>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∀</mo>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>M</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to\forall v\forall l((v,l)\in M\and C(l))\to(v=V[M]\and V(M)\in s)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:130">
 <semantics>
  <mrow>
   <mo>→</mo>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∀</mo>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to\forall v\forall l((v,l)\in M\and C(l))\to v\in S
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:131">
 <semantics>
  <mrow>
   <mo>→</mo>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∀</mo>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mi>v</mi>
    <mo>∉</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <notin></notin>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <not></not>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to\forall v\forall l((v,l)\in M\and v\not\in S)\to\neg C(l)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="simplification">Simplification</h3>

<p>The simplification rule allows values whose condition is false to be dropped.</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:132">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>K</mi>
     <mi mathvariant="italic">and</mi>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-:</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">K</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(K)=V(\{(v,l):(v,l)\in K\and C(l)\}
  </annotation>
 </semantics>
</math>

</p>

<p>Derivation</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:133">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mi>K</mi>
       <mi mathvariant="italic">and</mi>
       <mi>C</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>l</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <ci>v</ci>
      <ci>l</ci>
     </interval>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>v</ci>
       <ci>l</ci>
      </interval>
      <apply>
       <times></times>
       <ci>K</ci>
       <ci>italic- and</ci>
       <ci>C</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\{(v,l):(v,l)\in K\and C(l)\})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:134">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mi>K</mi>
       <mi mathvariant="italic">and</mi>
       <mi>C</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>l</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <interval closure="open">
        <ci>v</ci>
        <ci>l</ci>
       </interval>
       <apply>
        <in></in>
        <interval closure="open">
         <ci>v</ci>
         <ci>l</ci>
        </interval>
        <apply>
         <times></times>
         <ci>K</ci>
         <ci>italic- and</ci>
         <ci>C</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </apply>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(v,l)\in\{(v,l):(v,l)\in K\and C(l)\}\and C(l)\operatorname%
{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:135">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(v,l)\in K\and C(l)\and C(l)\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:136">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{let}(v,l)\in K\and C(l)\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:137">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =V(K)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="summary-of-results">Summary of results</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Rule</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Value function</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:138">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>let</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>in</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <ci>let</ci>
      <ci>v</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>italic- and</ci>
      <ci>C</ci>
      <ci>l</ci>
      <apply>
       <ci>in</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(K)=\operatorname{let}(v,l)\in K\and C(l)\operatorname{in}v
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Single value</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:139">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo>,</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <set>
      <interval closure="open">
       <ci>k</ci>
       <list></list>
      </interval>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=V(\{(k,\{\})\})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Set element</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:140">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>∀</mo>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo>in</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>let</mo>
   <mi>R</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>R</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mi>w</mi>
     <mo>∈</mo>
     <mi>X</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <ci>let</ci>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-,</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-{</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">R</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">w</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-}</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-:</ci>
      <csymbol cd="unknown">w</csymbol>
      <in></in>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">R</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\forall X(\operatorname{let}x\in X\operatorname{in}x)=\operatorname{%
let}R=V(\{(w,\{(R,x,w)\}):w\in X\})\operatorname{in}R
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Function application</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:141">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <msub>
          <mi>m</mi>
          <mi>v</mi>
         </msub>
        </mpadded>
        <msub>
         <mi>n</mi>
         <mi>v</mi>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>m</mi>
         <mi>l</mi>
        </msub>
        <mo>∪</mo>
        <msub>
         <mi>n</mi>
         <mi>l</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>m</mi>
         <mi>v</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>m</mi>
         <mi>l</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mi>M</mi>
        <mi mathvariant="italic">and</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>n</mi>
          <mi>v</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>n</mi>
          <mi>l</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∈</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>M</ci>
     <ci>V</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>v</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>v</ci>
        </apply>
       </apply>
       <apply>
        <union></union>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>l</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </interval>
      <apply>
       <and></and>
       <apply>
        <in></in>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>v</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>l</ci>
         </apply>
        </interval>
        <apply>
         <times></times>
         <ci>M</ci>
         <ci>italic- and</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>v</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>l</ci>
          </apply>
         </interval>
        </apply>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)\ V(N)=V(\{(m_{v}\ n_{v},m_{l}\cup n_{l}):(m_{v},m_{l})\in M\and(n_{v},n_{%
l})\in N\})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Exclusion</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:142">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>s</mi>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>v</mi>
    <mo>∀</mo>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>M</mi>
     <mi mathvariant="italic">and</mi>
     <mi>v</mi>
     <mo>∉</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">M</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">v</csymbol>
      <notin></notin>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)\in s\iff(\forall v\forall l((v,l)\in M\and v\not\in s)\to\neg C(l))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Simplification</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:143">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo>,</mo>
        <mi>l</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mi>K</mi>
        <mi mathvariant="italic">and</mi>
        <mi>C</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>l</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <interval closure="open">
       <ci>v</ci>
       <ci>l</ci>
      </interval>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>v</ci>
        <ci>l</ci>
       </interval>
       <apply>
        <times></times>
        <ci>K</ci>
        <ci>italic- and</ci>
        <ci>C</ci>
        <ci>l</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(K)=V(\{(v,l):(v,l)\in K\and C(l)\})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Assert equal</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:144">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>v</mi>
    <mo>∀</mo>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>N</mi>
     <mi mathvariant="italic">and</mi>
     <mi>v</mi>
     <mo>∉</mo>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">N</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">v</csymbol>
      <notin></notin>
      <csymbol cd="unknown">S</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)=V(N)\to(\forall v\forall l((v,l)\in N\and v\not\in S(M))\to\neg C(l))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h2 id="a-value-sets-identity">A value sets identity</h2>

<p>By defining the <a href="#Application_of_functions" title="wikilink">application of functions</a> to value sets the definition of equality of value sets has also been redefined. The old definition of equality still exists, because value sets are constructed as a set of pairs. Two sets are equal if they contain the same elements. This definition of equality for value sets is at best misleading.</p>

<p>What is needed is to use the name, or identity of the variable from which the value set is constructed as part of the structure of the value set. This would make value sets distinct, unless they are based on the same variable.</p>

<p>In mathematics, quantification is over values, not formulas. To proceed further with the exact definition of value sets, quantification over formulas is needed, in a way that allows the comparison of the identity of formulas. The distinction between the formula representing a value and the identity of the formula is the <a href="use–mention_distinction" title="wikilink">use–mention distinction</a>. The notation,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:145">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mi>x</mi>
    <mi mathvariant="normal">#</mi>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>normal-#</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\#u
  </annotation>
 </semantics>
</math>

</p>

<p>is introduced to mean quantification over formula <em>x</em> where <em>x</em> refers to the value, as a use, and <em>u</em> refers to the identity of the formula as represented or mentioned.</p>

<p>Using this notation the <a href="#Element_of_a_set" title="wikilink">element of a set</a> definition would be,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:146">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mi mathvariant="normal">#</mi>
   <mi>u</mi>
   <mo>∀</mo>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo>in</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>let</mo>
   <mi>R</mi>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo>,</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>R</mi>
         <mo>,</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>w</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi>w</mi>
      <mo>∈</mo>
      <mi>X</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>in</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">#</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <ci>let</ci>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">w</csymbol>
        <ci>normal-,</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-{</ci>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">R</csymbol>
          <ci>normal-,</ci>
          <csymbol cd="unknown">x</csymbol>
          <ci>normal-,</ci>
          <csymbol cd="unknown">w</csymbol>
          <ci>normal-)</ci>
         </cerror>
         <ci>normal-}</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-:</ci>
       <csymbol cd="unknown">w</csymbol>
       <in></in>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>in</ci>
    <csymbol cd="unknown">R</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\#u\forall X(\operatorname{let}x\in X\operatorname{in}x)=%
\operatorname{let}R=V((u,\{(w,\{(R,x,w)\}):w\in X\}))\operatorname{in}R
  </annotation>
 </semantics>
</math>

</p>

<p>Every reference to a value set would then need to be changed to take account of the extra level of structure in the value set, which would make the description harder to read. For the sake of readability this extra level of structure has been omitted from the definition of value sets.</p>
<h2 id="narrowing">Narrowing</h2>

<p>"Narrowing" is determining when conditions for values must be <em>false</em>. Narrowing starts when the value of two value sets is asserted equal.</p>
<h3 id="narrowing-by-asserting-equal">Narrowing by asserting equal</h3>

<p>Assertion that two value sets are equal gives the narrowing rule,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:147">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>l</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>m</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>v</mi>
    </msub>
    <mo>≠</mo>
    <msub>
     <mi>n</mi>
     <mi>v</mi>
    </msub>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>m</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>l</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>l</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>v</ci>
     </apply>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-→</ci>
     <not></not>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall m_{v}\forall m_{l}\forall n_{v}\forall n_{l}((m_{v},m_{l})\in M\and(n_%
{v},n_{l})\in N)\to(m_{v}\neq n_{v}\to\neg(C(m_{l})\and C(n_{l})))
  </annotation>
 </semantics>
</math>

</p>

<p>For the derivation, start with,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:148">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)=V(N)
  </annotation>
 </semantics>
</math>

</p>

<p>The value condition gives,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:149">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>m</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>m</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>v</mi>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <msub>
     <mi>n</mi>
     <mi>v</mi>
    </msub>
    <mo>∀</mo>
    <msub>
     <mi>n</mi>
     <mi>l</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mi>v</mi>
      </msub>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>N</mi>
     <mi mathvariant="italic">and</mi>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <msub>
     <mi>n</mi>
     <mi>v</mi>
    </msub>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>l</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">v</csymbol>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>v</ci>
     </apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>v</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">k</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">N</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>v</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall m_{v}\forall m_{l}((m_{v},m_{l})\in M\and C(m_{l})\to v=V(M))\and(%
\forall n_{v}\forall n_{l}((n_{v},k)\in N\and C(n_{l}))\to n_{v}=V(N))\and V(M%
)=V(N)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:150">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>l</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>m</mi>
       <mi>v</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>m</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>M</mi>
     <mi mathvariant="italic">and</mi>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>m</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <msub>
     <mi>m</mi>
     <mi>v</mi>
    </msub>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mi>v</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>N</mi>
     <mi mathvariant="italic">and</mi>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <msub>
     <mi>n</mi>
     <mi>v</mi>
    </msub>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="italic">and</mi>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>l</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>l</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>v</ci>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">M</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>v</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>v</ci>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">N</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>v</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">and</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall m_{v}\forall m_{l}\forall n_{v}\forall n_{l}(((m_{v},m_{l})\in M\and C%
(m_{l}))\to m_{v}=V(M))\and(((n_{v},n_{l})\in N\and C(n_{l}))\to n_{v}=V(N))%
\and V(M)=V(N)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:151">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>l</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>m</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>v</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>l</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>l</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">j</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">v</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall m_{v}\forall m_{l}\forall n_{v}\forall n_{l}((m_{v},m_{l})\in M\and(n_%
{v},n_{l})\in N)\to(C(j)\and C(k)\to v=u)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:152">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>m</mi>
    <mi>l</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>v</mi>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>n</mi>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>m</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>v</mi>
    </msub>
    <mo>≠</mo>
    <msub>
     <mi>n</mi>
     <mi>v</mi>
    </msub>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>m</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>l</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>l</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>v</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>l</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>v</ci>
     </apply>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-→</ci>
     <not></not>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>l</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall m_{v}\forall m_{l}\forall n_{v}\forall n_{l}((m_{v},m_{l})\in M\and(n_%
{v},n_{l})\in N)\to(m_{v}\neq n_{v}\to\neg(C(m_{l})\and C(n_{l})))
  </annotation>
 </semantics>
</math>

</p>
<h3 id="narrowing-by-conjunction">Narrowing by conjunction</h3>

<p>If any base condition is false, all the conditions obtained from it are false.</p>

<p>This comes from the definition of the Condition function,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:153">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>l</mi>
     </mrow>
    </munder>
    <mi>z</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <vector>
        <ci>r</ci>
        <ci>z</ci>
        <ci>u</ci>
       </vector>
       <ci>l</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(l)=({\bigwedge_{(r,z,u)\in l}z=u}))
  </annotation>
 </semantics>
</math>

</p>

<p>The base condition for (r, z, u) is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:154">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo>=</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">r</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">z</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">u</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <eq></eq>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\{(r,z,u)\}=(z=u)
  </annotation>
 </semantics>
</math>

</p>

<p>So if this is false 

<math display="inline" id="Narrowing_of_algebraic_value_sets:155">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(l)
  </annotation>
 </semantics>
</math>

 is false.</p>
<h3 id="narrowing-by-crossed-conditions">Narrowing by crossed conditions</h3>

<p>If a dependent condition list has two different base conditions from the same value set it must be false.</p>

<p>To derive this, start with the exclusion rule which is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:156">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>l</mi>
    <mn>1</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>l</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⟹</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>l</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <neq></neq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <implies></implies>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v_{1}\forall l_{1}\forall v_{2}\forall l_{2}((v_{1},l_{1})\in K\and(v_%
{2},l_{2})\in K\and(v_{1},l_{1})\neq(v_{2},l_{2}))\implies\neg(C(l_{1})\and C(%
l_{2}))
  </annotation>
 </semantics>
</math>

</p>

<p>Then for any set of dependent conditions <em>l</em>,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:157">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mpadded width="+5pt">
    <mi>l</mi>
   </mpadded>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>l</mi>
   <mi mathvariant="italic">and</mi>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>≠</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">l</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">l</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((K,x,v_{1})\in l\ \and(K,x,v_{2})\in l\and v_{1}\neq v_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:158">
 <semantics>
  <mrow>
   <mo>⟹</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>K</mi>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>K</mi>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>l</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>l</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <implies></implies>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">K</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">K</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">K</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">K</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <neq></neq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \implies(v_{1},\{(K,x,v_{1})\})\in K\and(v_{2},\{(K,x,v_{2})\})\in K\and(v_{1}%
,l_{1})\neq(v_{2},l_{2}))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:159">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⟹</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>K</mi>
         <mo>,</mo>
         <mi>x</mi>
         <mo>,</mo>
         <msub>
          <mi>v</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="italic">and</mi>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>K</mi>
         <mo>,</mo>
         <mi>x</mi>
         <mo>,</mo>
         <msub>
          <mi>v</mi>
          <mn>2</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <implies></implies>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>C</ci>
      <set>
       <vector>
        <ci>K</ci>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">1</cn>
        </apply>
       </vector>
      </set>
      <ci>italic- and</ci>
      <ci>C</ci>
      <set>
       <vector>
        <ci>K</ci>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">2</cn>
        </apply>
       </vector>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \implies\neg(C(\{(K,x,v_{1})\})\and C(\{(K,x,v_{2})\}))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:160">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⟹</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <implies></implies>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <not></not>
     <ci>C</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \implies\neg C(l)
  </annotation>
 </semantics>
</math>

</p>

<p>So if a dependent condition list is based on two conditions from the same value set, the condition value of that dependent condition list is false.</p>
<h3 id="narrowing-by-exclusion-of-dependent-values">Narrowing by exclusion of dependent values</h3>

<p>Each value set puts a constraint on the base value set from which it is constructed. If a base values set includes values that are not present as dependent values in the value set, the conditions for these values must be false.</p>

<p>To derive this, start with the complete set rule,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:161">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo rspace="7.5pt">∃</mo>
      <mrow>
       <mi>l</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo>,</mo>
        <mi>l</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>K</mi>
   <mo>→</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>v</ci>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>l</ci>
         <interval closure="open">
          <ci>v</ci>
          <ci>l</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>K</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists v\exists\ l(v,l)\in K\to C(l)
  </annotation>
 </semantics>
</math>

</p>

<p>The condition function is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:162">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>l</mi>
     </mrow>
    </munder>
    <mi>z</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <vector>
        <ci>r</ci>
        <ci>z</ci>
        <ci>u</ci>
       </vector>
       <ci>l</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(l)=({\bigwedge_{(r,z,u)\in l}z=u}))
  </annotation>
 </semantics>
</math>

</p>

<p>A particular dependent condition may be chosen, as being implied by the whole condition,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:163">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>L</mi>
     </mpadded>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>l</mi>
   <mo>→</mo>
   <mi>z</mi>
   <mo>=</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>C</ci>
       <ci>l</ci>
      </apply>
     </apply>
     <vector>
      <ci>L</ci>
      <ci>z</ci>
      <ci>u</ci>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>l</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>z</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall L\ C(l)\to(L,z,u)\in l\to z=u
  </annotation>
 </semantics>
</math>

</p>

<p>So</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:164">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>v</mi>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mpadded width="+5pt">
          <mi>l</mi>
         </mpadded>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>v</mi>
          <mo>,</mo>
          <mi>l</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>K</mi>
   <mo>→</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>l</mi>
   <mo>→</mo>
   <mi>z</mi>
   <mo>=</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>L</ci>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>v</ci>
         <apply>
          <exists></exists>
          <apply>
           <times></times>
           <ci>l</ci>
           <interval closure="open">
            <ci>v</ci>
            <ci>l</ci>
           </interval>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>K</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <vector>
      <ci>L</ci>
      <ci>z</ci>
      <ci>u</ci>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>l</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>z</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall L\exists v\exists l\ (v,l)\in K\to C(l)\to(L,z,u)\in l\to z=u
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="Narrowing_of_algebraic_value_sets:165">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=V(L)
  </annotation>
 </semantics>
</math>

. The expression may be rearranged to define the set of values that 

<math display="inline" id="Narrowing_of_algebraic_value_sets:166">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(L)
  </annotation>
 </semantics>
</math>

 might take,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:167">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo>,</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>w</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mi>K</mi>
      <mi mathvariant="italic">and</mi>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="italic">and</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>L</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∈</mo>
     <mi>l</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <interval closure="open">
      <ci>K</ci>
      <ci>L</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>w</ci>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>v</ci>
        <ci>l</ci>
       </interval>
       <apply>
        <times></times>
        <ci>K</ci>
        <ci>italic- and</ci>
        <ci>C</ci>
        <ci>l</ci>
        <ci>italic- and</ci>
        <vector>
         <ci>L</ci>
         <ci>z</ci>
         <ci>w</ci>
        </vector>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(K,L)=\{w:(v,l)\in K\and C(l)\and(L,z,w)\in l\}
  </annotation>
 </semantics>
</math>

</p>

<p>and so,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:168">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo>,</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <interval closure="open">
      <ci>K</ci>
      <ci>L</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(L)\in E(K,L)
  </annotation>
 </semantics>
</math>

</p>

<p>Then using the exclusion rule,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:169">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>s</mi>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>v</mi>
    <mo>∀</mo>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>M</mi>
     <mi mathvariant="italic">and</mi>
     <mi>v</mi>
     <mo>∉</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <in></in>
      <csymbol cd="unknown">M</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">v</csymbol>
      <notin></notin>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(M)\in s\iff(\forall v\forall l((v,l)\in M\and v\not\in s)\to\neg C(l))
  </annotation>
 </semantics>
</math>

</p>

<p>gives,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:170">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∀</mo>
   <mi>K</mi>
   <mo>∀</mo>
   <mi>L</mi>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∀</mo>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>L</mi>
    <mi mathvariant="italic">and</mi>
    <mi>v</mi>
    <mo>∉</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo>,</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">K</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">l</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">L</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <notin></notin>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">L</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <not></not>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall K\forall L\forall v\forall l((v,l)\in L\and v\not\in E(K,L))\to\neg C%
(l))
  </annotation>
 </semantics>
</math>

</p>

<p>This is the narrowing exclusion rule. 

<math display="inline" id="Narrowing_of_algebraic_value_sets:171">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo>,</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <interval closure="open">
     <ci>K</ci>
     <ci>L</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(K,L)
  </annotation>
 </semantics>
</math>

 is the set of values in the base value <em>L</em> set which are represented in the value set <em>K</em>. Conditions for other values must be false.</p>
<h2 id="probabilistic-value-sets">Probabilistic value sets</h2>

<p>The value set records the dependent conditions that the condition function may be applied to in order to deduce the truth of the proposition that the value set has a particular value. The same structure may be used to give the probability of a value set being equal to a particular value. The condition function is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:172">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>l</mi>
     </mrow>
    </munder>
    <mi>z</mi>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <vector>
        <ci>r</ci>
        <ci>z</ci>
        <ci>u</ci>
       </vector>
       <ci>l</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(l)=({\bigwedge_{(r,z,u)\in l}z=u}))
  </annotation>
 </semantics>
</math>

</p>

<p>The probability function is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:173">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>l</mi>
     </mrow>
    </munder>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo>=</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <vector>
        <ci>r</ci>
        <ci>z</ci>
        <ci>u</ci>
       </vector>
       <ci>l</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <eq></eq>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(l)=({\prod_{(r,z,u)\in l}P(z=u)}))
  </annotation>
 </semantics>
</math>

</p>

<p>This is the probability of each base case holding the particular value, if the events are independent.</p>

<p>The probability function is defined by 3 axioms,</p>
<ol>
<li>Each pair 

<math display="inline" id="Narrowing_of_algebraic_value_sets:174">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>v</mi>
   <mo>,</mo>
   <mi>l</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>l</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,l)
  </annotation>
 </semantics>
</math>

 means that the probability of the value set 

<math display="inline" id="Narrowing_of_algebraic_value_sets:175">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(K)
  </annotation>
 </semantics>
</math>

 is <em>v</em> is the probability function applied to the list, 

<math display="inline" id="Narrowing_of_algebraic_value_sets:176">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(l)
  </annotation>
 </semantics>
</math>

.</li>
<li>The sum of the probabilities over the whole value set is 1.</li>
<li>The probability of any two pairs in the value set is zero.</li>
</ol>

<p>The probability function gives probabilities for results based on initial probabilities given by <a href="#Boolean_inductive_inference" title="wikilink">Boolean inductive inference</a>.</p>

<p>Formally,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Definition</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Probability function</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:177">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>l</mi>
     </mrow>
    </msub>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo>=</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <vector>
        <ci>r</ci>
        <ci>z</ci>
        <ci>u</ci>
       </vector>
       <ci>l</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <eq></eq>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(l)=({\prod_{(r,z,u)\in l}P(z=u)}))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Value condition</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:178">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>K</mi>
    </mrow>
   </msub>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>v</ci>
       <ci>l</ci>
      </interval>
      <ci>K</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall vP(v=V(K))=\sum_{(v,l)\in K}P(l)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Complete set</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:179">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>K</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>v</ci>
        <ci>l</ci>
       </interval>
       <ci>K</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{(v,l)\in K}P(l)=1
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Allowed values</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:180">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mi>K</mi>
       <mi mathvariant="italic">and</mi>
       <mi>v</mi>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mo>gset</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>K</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <and></and>
       <apply>
        <in></in>
        <interval closure="open">
         <ci>v</ci>
         <ci>l</ci>
        </interval>
        <apply>
         <times></times>
         <ci>K</ci>
         <ci>italic- and</ci>
         <ci>v</ci>
        </apply>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <apply>
         <ci>gset</ci>
         <apply>
          <times></times>
          <ci>V</ci>
          <ci>K</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{(v,l)\in K\and v\in\operatorname{gset}(V(K))}P(l)=1
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Exclusion</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Narrowing_of_algebraic_value_sets:181">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>l</mi>
    <mn>1</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>l</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>K</mi>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>l</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>l</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <neq></neq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v_{1}\forall l_{1}\forall v_{2}\forall l_{2}((v_{1},l_{1})\in K\and(v_%
{2},l_{2})\in K\and(v_{1},l_{1})\neq(v_{2},l_{2}))\to P(C(l_{1})\and C(l_{2}))=0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Probabilities for each value in a value set may be calculated from probabilities in base value sets using the probability function and the value condition. Base value sets are either for a single value, or multiple value value set.</p>
<h3 id="probability-for-a-single-value">Probability for a single value</h3>

<p>The value set to represent a single value is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:182">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo>,</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <set>
      <interval closure="open">
       <ci>k</ci>
       <list></list>
      </interval>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=V(\{(k,\{\})\})
  </annotation>
 </semantics>
</math>

</p>

<p>The complete set rule is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:183">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>K</mi>
    </mrow>
   </munder>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>v</ci>
       <ci>l</ci>
      </interval>
      <ci>K</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{(v,l)\in K}P(l)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:184">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo>,</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mo stretchy="false">}</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>v</ci>
        <ci>l</ci>
       </interval>
       <set>
        <interval closure="open">
         <ci>k</ci>
         <list></list>
        </interval>
       </set>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sum_{(v,l)\in\{(k,\{\})\}}P(l)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:185">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>P</ci>
     <list></list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =P(\{\})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:186">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =1
  </annotation>
 </semantics>
</math>

</p>

<p>Which is consistent with the axiom.</p>
<h3 id="probabilities-for-multiple-values">Probabilities for multiple values</h3>

<p>The value set to represent multiple values is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:187">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>∀</mo>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>let</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo>in</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">_</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>:</mo>
     <mi>w</mi>
     <mo>∈</mo>
     <mi>X</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>let</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>in</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">V</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-,</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-{</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">_</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">x</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">w</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-}</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-:</ci>
      <csymbol cd="unknown">w</csymbol>
      <in></in>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\forall X(\operatorname{let}x\in X\operatorname{in}x)=V(\{(w,\{(\_,x,%
w)\}):w\in X\})
  </annotation>
 </semantics>
</math>

</p>

<p>The probability is given by the allowed values rule,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:188">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mi>K</mi>
       <mi mathvariant="italic">and</mi>
       <mi>v</mi>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mo>gset</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>K</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <and></and>
       <apply>
        <in></in>
        <interval closure="open">
         <ci>v</ci>
         <ci>l</ci>
        </interval>
        <apply>
         <times></times>
         <ci>K</ci>
         <ci>italic- and</ci>
         <ci>v</ci>
        </apply>
       </apply>
       <apply>
        <in></in>
        <share href="#.cmml">
        </share>
        <apply>
         <ci>gset</ci>
         <apply>
          <times></times>
          <ci>V</ci>
          <ci>K</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{(v,l)\in K\and v\in\operatorname{gset}(V(K))}P(l)=1
  </annotation>
 </semantics>
</math>

</p>

<p>which simplifies to,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:189">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mrow>
      <mo>gset</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>K</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>v</ci>
      <apply>
       <ci>gset</ci>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>K</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{v\in\operatorname{gset}(V(K))}P(x=v)=1
  </annotation>
 </semantics>
</math>

</p>

<p>If prior estimates of probabilities for values are given then they will be proportional to the posterior probabilities, if the value is in the value set.</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:190">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∈</mo>
   <mo>gset</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>w</mi>
   <mo>*</mo>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <ci>gset</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">w</csymbol>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\in\operatorname{gset}(V(K)),P(x=v)=w*P_{i}(x=v)
  </annotation>
 </semantics>
</math>

</p>

<p>If the value is not in the value set the probabilities will be zero,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:191">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∉</mo>
   <mo>gset</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <notin></notin>
    <ci>gset</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\not\in\operatorname{gset}(V(K)),P(x=v)=0
  </annotation>
 </semantics>
</math>

</p>

<p>So,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:192">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mrow>
      <mo>gset</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>K</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </munder>
   <mi>w</mi>
   <mo>*</mo>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>v</ci>
      <apply>
       <ci>gset</ci>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>K</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">w</csymbol>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{v\in\operatorname{gset}(V(K))}w*P_{i}(x=v)=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:193">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <mrow>
        <mo>gset</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>V</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>K</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mi>P</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>=</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>v</ci>
        <apply>
         <ci>gset</ci>
         <apply>
          <times></times>
          <ci>V</ci>
          <ci>K</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <eq></eq>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=\frac{1}{\sum_{v\in\operatorname{gset}(V(K))}P_{i}(x=v)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:194">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∈</mo>
   <mo>gset</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>P</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>=</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <mrow>
        <mo>gset</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>V</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>K</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mi>P</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>=</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <ci>gset</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <eq></eq>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>v</ci>
        <apply>
         <ci>gset</ci>
         <apply>
          <times></times>
          <ci>V</ci>
          <ci>K</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <eq></eq>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\in\operatorname{gset}(V(K)),P(x=v)=\frac{P_{i}(x=v)}{\sum_{v\in%
\operatorname{gset}(V(K))}P_{i}(x=v)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:195">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∉</mo>
   <mo>gset</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <notin></notin>
    <ci>gset</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\not\in\operatorname{gset}(V(K)),P(x=v)=0
  </annotation>
 </semantics>
</math>

</p>

<p>If the prior probabilities are all the same the probabilities are,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:196">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∈</mo>
   <mo>gset</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo>gset</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>K</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <ci>gset</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <abs></abs>
      <apply>
       <ci>gset</ci>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>K</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\in\operatorname{gset}(V(K)),P(x=v)=\frac{1}{|\operatorname{gset}(V(K%
))|}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="probabilities-of-general-value-sets">Probabilities of general value sets</h3>

<p>A general value set is created out of the application of base value sets. The value condition rule and the probability function may be combined to give,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:197">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>=</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mi>K</mi>
      <mi mathvariant="italic">and</mi>
      <mi>v</mi>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mo>gset</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>K</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </munder>
   <mrow>
    <mo stretchy="false">(</mo>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>l</mi>
     </mrow>
    </munder>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo>=</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>v</ci>
        <ci>l</ci>
       </interval>
       <apply>
        <times></times>
        <ci>K</ci>
        <ci>italic- and</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <apply>
        <ci>gset</ci>
        <apply>
         <times></times>
         <ci>V</ci>
         <ci>K</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <vector>
        <ci>r</ci>
        <ci>z</ci>
        <ci>u</ci>
       </vector>
       <ci>l</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <eq></eq>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall vP(v=V(K))=\sum_{(v,l)\in K\and v\in\operatorname{gset}(V(K))}({\prod_%
{(r,z,u)\in l}P(z=u)}))
  </annotation>
 </semantics>
</math>

</p>
<h2 id="accessing-the-value-set">Accessing the value set</h2>

<p>Narrowing allows the elimination of values that do not satisfy a variable's constraints. Considered as the basis for an algorithm for solving equations, this narrowing gives a set of values consistent with the constraints on a variable. However in mathematics there is no way to access this set of values.</p>

<p>If 

<math display="inline" id="Narrowing_of_algebraic_value_sets:198">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(x)
  </annotation>
 </semantics>
</math>

 is an expression constraining a variable <em>x</em> then the set of values that the variable may take is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:199">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>z</mi>
   <mo>:</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{z:E(z)\}
  </annotation>
 </semantics>
</math>

</p>

<p>Define the <em>gset</em> of <em>x</em> to be the set of values that satisfy the constraints on <em>x</em>. Consider defining <em>gset</em> as,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:200">
 <semantics>
  <mrow>
   <mrow>
    <mo>gset</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>z</mi>
    <mo>:</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>gset</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>z</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gset}(x)=\{z:E(z)\}
  </annotation>
 </semantics>
</math>

</p>

<p>This definition depends on knowing the expression <em>E</em>, which is the condition giving all the constraints on <em>x</em>. Within mathematics <em>E</em> may not be obtained from <em>x</em>. So there is no mathematical function that may be applied to a variable to request the set of values. So may the <em>gset</em> function be added to mathematics?</p>
<h3 id="meta-math-definition">Meta math definition</h3>

<p>A meta-mathematical definition of <em>gset</em> may be possible. Imagine that what we know of as mathematics is actually implemented by a <a href="Meta_programming" title="wikilink">meta function</a> called <em>math</em>. <em>math</em> takes an <a href="abstract_syntax_tree" title="wikilink">abstract syntax tree</a> and gives meaning to the variables and mathematical structures and adds existential quantifiers for variables not explicitly quantified.</p>

<p><em>math</em> would be an expression in a meta mathematical environment with its own variables. To distinguish these meta-variables from math variables represent them by capital letters and the mathematical variables by lower case letters.</p>

<p>Now suppose there is an extended implementation of mathematics implemented by the <em>xmath</em> function, defined as,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:201">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>xmath</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>E</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>∀</mo>
     <mi>M</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>let</mo>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>M</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>math</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>E</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>in</mo>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi mathvariant="normal">_</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>xmath</ci>
      <ci>E</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>let</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>math</ci>
       <ci>E</ci>
      </apply>
      <apply>
       <ci>in</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>normal-_</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{xmath}[E]=\forall M,\operatorname{let}T[M]=\operatorname{math}[E%
]\operatorname{in}T[\_]
  </annotation>
 </semantics>
</math>

</p>

<p>Using <em>xmath</em>, <em>gset</em> may be defined by,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:202">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>x</mi>
      <mi mathvariant="normal">#</mi>
      <mi>u</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>∃</mo>
     <mi>N</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>gset</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>let</mo>
     <mi>M</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>u</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo>in</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>z</mi>
       <mo>:</mo>
       <mrow>
        <mi>z</mi>
        <mo>=</mo>
        <mrow>
         <mi>N</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>u</mi>
          <mo stretchy="false">]</mo>
         </mrow>
         <mi mathvariant="italic">and</mi>
         <mi>T</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>N</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>normal-#</ci>
        <ci>u</ci>
       </apply>
      </apply>
      <apply>
       <exists></exists>
       <ci>N</ci>
      </apply>
      <apply>
       <ci>gset</ci>
       <ci>x</ci>
      </apply>
     </list>
     <apply>
      <times></times>
      <apply>
       <ci>let</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <ci>in</ci>
       <apply>
        <ci>normal-:</ci>
        <ci>z</ci>
        <apply>
         <eq></eq>
         <ci>z</ci>
         <apply>
          <times></times>
          <ci>N</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <ci>u</ci>
          </apply>
          <ci>italic- and</ci>
          <ci>T</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\#u,\exists N,\operatorname{gset}(x)=\operatorname{let}M[u]=x%
\operatorname{in}\{z:z=N[u]\and T[N]\}
  </annotation>
 </semantics>
</math>

</p>

<p>Here <a href="#A_value_sets_identity" title="wikilink">again</a> the notation,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:203">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mi>x</mi>
    <mi mathvariant="normal">#</mi>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>normal-#</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\#u
  </annotation>
 </semantics>
</math>

</p>

<p>is used to mean quantification over variables <em>x</em> where <em>x</em> refers to the value, and <em>u</em> refers to the unique identity of the variable.</p>
<h3 id="example">Example</h3>

<p>For example take the constraint expression 

<math display="inline" id="Narrowing_of_algebraic_value_sets:204">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=4
  </annotation>
 </semantics>
</math>

. Then,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:205">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=4
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:206">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <mi>s</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>gset</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>italic- and</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <ci>gset</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and s=\operatorname{gset}(x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:207">
 <semantics>
  <mrow>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mi mathvariant="normal">#</mi>
    <mi>u</mi>
    <mo>,</mo>
    <mo>∃</mo>
    <mi>N</mi>
    <mo>gset</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mo>let</mo>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>u</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
    <mo>in</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>z</mi>
     <mo>:</mo>
     <mi>z</mi>
     <mo>=</mo>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>u</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>N</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">#</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-,</ci>
     <exists></exists>
     <csymbol cd="unknown">N</csymbol>
     <ci>gset</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <ci>let</ci>
     <csymbol cd="unknown">M</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>in</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">z</csymbol>
      <eq></eq>
      <csymbol cd="unknown">N</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">u</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">T</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">N</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and(\forall x\#u,\exists N\operatorname{gset}(x)=\operatorname{let}M[u]=x%
\operatorname{in}\{z:z=N[u]\and T[N]\})
  </annotation>
 </semantics>
</math>

</p>

<p>Then the <em>xmath</em> expression is,</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:208">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>M</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mo>let</mo>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>M</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>let</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>M</ci>
      </apply>
     </apply>
    </list>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall M,\operatorname{let}T[M]=
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Narrowing_of_algebraic_value_sets:209">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mo>∃</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <exists></exists>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <eq></eq>
     <cn type="integer">4</cn>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x,\exists s,(x^{2}=4
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Narrowing_of_algebraic_value_sets:210">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <mi>s</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>gset</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>italic-and</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <ci>gset</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and s=\operatorname{gset}(x)
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Narrowing_of_algebraic_value_sets:211">
 <semantics>
  <mrow>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mi mathvariant="normal">#</mi>
    <mi>u</mi>
    <mo>,</mo>
    <mo>∃</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mo>gset</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mo>let</mo>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>u</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
    <mo>in</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>z</mi>
     <mo>:</mo>
     <mi>z</mi>
     <mo>=</mo>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>u</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>N</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">and</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">#</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-,</ci>
     <exists></exists>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-,</ci>
     <ci>gset</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <ci>let</ci>
     <csymbol cd="unknown">M</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>in</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">z</csymbol>
      <eq></eq>
      <csymbol cd="unknown">N</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">u</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">T</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">N</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \and(\forall x\#u,\exists N,\operatorname{gset}(x)=\operatorname{let}M[u]=x%
\operatorname{in}\{z:z=N[u]\and T[N]\})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>

<math display="inline" id="Narrowing_of_algebraic_value_sets:212">
 <semantics>
  <mrow>
   <mrow>
    <mo>in</mo>
    <mi>T</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi mathvariant="normal">_</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>in</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>normal-_</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{in}T[\_]
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Then where u is the unique identity of the variable x, represented here as the number 1 (for the first variable used in a call to <em>gset</em>),</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:213">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mi mathvariant="italic">and</mi>
    <mi>s</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>z</mi>
    <mo>:</mo>
    <mrow>
     <mi>z</mi>
     <mo>=</mo>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mn>1</mn>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi mathvariant="italic">and</mi>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>N</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>M</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>italic- and</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>z</ci>
      <apply>
       <eq></eq>
       <ci>z</ci>
       <apply>
        <times></times>
        <ci>N</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>italic- and</ci>
        <ci>T</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M[1]=x\and s=\{z:z=N[1]\and T[N]\}
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="Narrowing_of_algebraic_value_sets:214">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[N]
  </annotation>
 </semantics>
</math>

 invokes <em>T</em> with M as N.</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:215">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>z</mi>
    <mo>:</mo>
    <mrow>
     <mi>z</mi>
     <mo>=</mo>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mn>1</mn>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi mathvariant="italic">and</mi>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mn>4</mn>
      <mi mathvariant="italic">and</mi>
      <mi>x</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mn>1</mn>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>z</ci>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <ci>z</ci>
       <apply>
        <times></times>
        <ci>N</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>italic- and</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <ci>italic- and</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <ci>N</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\{z:z=N[1]\and x^{2}=4\and x=N[1]\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Narrowing_of_algebraic_value_sets:216">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>z</mi>
    <mo>:</mo>
    <mrow>
     <msup>
      <mi>z</mi>
      <mn>2</mn>
     </msup>
     <mo>=</mo>
     <mn>4</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>z</ci>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\{z:z^{2}=4\}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Functional_programming" title="wikilink">Functional programming</a>
<ul>
<li><a href="Lazy_evaluation" title="wikilink">Lazy evaluation</a></li>
<li><a href="Polymorphism_(computer_science)" title="wikilink">Polymorphic type system</a></li>
<li><a href="Hindley–Milner_type_system" title="wikilink">Type inference</a></li>
<li><a href="Higher-order_function" title="wikilink">Higher-order function</a></li>
<li><a href="Haskell_(programming_language)" title="wikilink">Haskell</a></li>
</ul></li>
<li><a href="Lambda_calculus" title="wikilink">Lambda calculus</a>
<ul>
<li><a href="Deductive_lambda_calculus" title="wikilink">Deductive lambda calculus</a></li>
<li><a href="Let_expression" title="wikilink">Let expression</a></li>
</ul></li>
<li><a href="Logic_programming" title="wikilink">Logic programming</a>
<ul>
<li><a href="Resolution_(logic)" title="wikilink">Resolution (logic)</a></li>
<li><a href="Constraint_logic_programming" title="wikilink">Constraint logic programming</a></li>
<li><a href="Constraint_satisfaction" title="wikilink">constraints</a></li>
<li><a class="uri" href="ECLiPSe" title="wikilink">ECLiPSe</a></li>
</ul></li>
<li><a class="uri" href="Mathematics" title="wikilink">Mathematics</a>
<ul>
<li><a href="Function_(mathematics)" title="wikilink">Function (mathematics)</a></li>
<li><a class="uri" href="Algebra" title="wikilink">Algebra</a></li>
<li><a class="uri" href="Disjunction" title="wikilink">Disjunction</a></li>
</ul></li>
<li><a href="Relational_programming" title="wikilink">Relational programming</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a> <a href="Category:Constraint_programming" title="wikilink">Category:Constraint programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
