<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1812">Dependent type</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dependent type</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a> and <a class="uri" href="logic" title="wikilink">logic</a>, a <strong>dependent type</strong> is a type that depends on a value. It is an overlapping feature of <a href="type_theory" title="wikilink">type theory</a> and <a href="type_system" title="wikilink">type systems</a>. In <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a>, dependent types are used to encode logic's <a href="Generalized_quantifier" title="wikilink">quantifiers</a> like "for all" and "there exists". In <a href="functional_programming_languages" title="wikilink">functional programming languages</a> like <a href="ATS_(programming_language)" title="wikilink">ATS</a>, <a href="Agda_(theorem_prover)" title="wikilink">Agda</a>, <a href="Idris_(programming_language)" title="wikilink">Idris</a> and <a href="Epigram_(programming_language)" title="wikilink">Epigram</a>, dependent types prevent bugs by allowing very expressive types.</p>

<p>Two common examples of dependent types are dependent functions and dependent pairs. A dependent function's return type may depend on the <em>value</em> (not just type) of an argument. A function that takes a positive integer "n" may return an array of length "n". (Note that this is different from <a href="Polymorphism_(computer_science)" title="wikilink">polymorphism</a> where the type is an argument.) A dependent pair may have a second value that depends on the first. It can be used to encode a pair of integers where the second one is greater than the first.</p>

<p>Dependent types add complexity to a type system. Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result; hence <a href="type_checking" title="wikilink">type checking</a> may become <a href="Undecidable_problem" title="wikilink">undecidable</a>.</p>
<h2 id="history">History</h2>

<p>Dependent types were created to deepen the connection between programming and logic.</p>

<p>In 1934, <a href="Haskell_Curry" title="wikilink">Haskell Curry</a> noticed that the types used in mathematical programming languages followed the same pattern as axioms in <a href="Propositional_calculus" title="wikilink">propositional logic</a>. Going further, for every proof in the logic, there was a matching function (term) in the programming language. One of Curry's examples was the correspondence between <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> and <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p><a href="Predicate_logic" title="wikilink">Predicate logic</a> is an extension of propositional logic, adding quantifiers. Howard and de Bruijn extended lambda calculus to match this more powerful logic by creating types for dependent functions, which correspond to "for all", and dependent pairs, which correspond to "there exists".<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>(Because of this and other work by Howard, propositions-as-types is known as the <a href="Curry-Howard_correspondence" title="wikilink">Curry-Howard correspondence</a>.)</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Dependent types can be, very loosely speaking, imagined to be similar to the type of an indexed family of sets. More formally, given a type 

<math display="inline" id="Dependent_type:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>:</mo>
   <mi class="ltx_font_mathcaligraphic">ùí∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>A</ci>
    <ci>ùí∞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A:\mathcal{U}
  </annotation>
 </semantics>
</math>

 in a universe of types 

<math display="inline" id="Dependent_type:1">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùí∞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùí∞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

, one may have a <strong>family of types</strong> 

<math display="inline" id="Dependent_type:2">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>‚Üí</mo>
    <mi class="ltx_font_mathcaligraphic">ùí∞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>B</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>A</ci>
     <ci>ùí∞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B:A\to\mathcal{U}
  </annotation>
 </semantics>
</math>

 which assigns to each term 

<math display="inline" id="Dependent_type:3">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>:</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a:A
  </annotation>
 </semantics>
</math>

 a type 

<math display="inline" id="Dependent_type:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mi class="ltx_font_mathcaligraphic">ùí∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>a</ci>
    </apply>
    <ci>ùí∞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(a):\mathcal{U}
  </annotation>
 </semantics>
</math>

. A function whose codomain varies depending on its argument is a <strong>dependent function</strong>, and the type of this function is called a <strong>dependent type</strong>, <strong>dependent product type</strong> or <strong>pi-type</strong>. For this example, the dependent type would be written as</p>

<p>

<math display="block" id="Dependent_type:5">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Œ†</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Œ†</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </apply>
    <ci>B</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{(x:A)}B(x)
  </annotation>
 </semantics>
</math>

 or as</p>

<p>

<math display="block" id="Dependent_type:6">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œ†</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Œ†</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">B</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi(x:A),B(x)
  </annotation>
 </semantics>
</math>

 If <em>B</em> is a constant, the dependent type becomes an ordinary function 

<math display="inline" id="Dependent_type:7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>‚Üí</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to B
  </annotation>
 </semantics>
</math>

. That is, 

<math display="inline" id="Dependent_type:8">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Œ†</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Œ†</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{(x:A)}B
  </annotation>
 </semantics>
</math>

 is judgementally equal to the <a href="function_type" title="wikilink">function type</a> 

<math display="inline" id="Dependent_type:9">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>‚Üí</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to B
  </annotation>
 </semantics>
</math>

.</p>

<p>The name 'pi-type' comes from the idea that these may be viewed as a <a href="Cartesian_product" title="wikilink">Cartesian product</a> of types. Pi-types can also be understood as <a href="model_theory" title="wikilink">models</a> of <a href="Universal_quantification#As_adjoint" title="wikilink">universal quantifiers</a>.</p>

<p>For example, writing 

<math display="inline" id="Dependent_type:10">
 <semantics>
  <mrow>
   <mtext>Vec</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>‚Ñù</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Vec</mtext>
    <interval closure="open">
     <ci>‚Ñù</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Vec}({\mathbb{R}},n)
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Dependent_type:11">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-tuples of <a href="real_numbers" title="wikilink">real numbers</a>, then 

<math display="inline" id="Dependent_type:12">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Œ†</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>:</mo>
     <mi>‚Ñï</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mtext>Vec</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>‚Ñù</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Œ†</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </apply>
    <mtext>Vec</mtext>
    <interval closure="open">
     <ci>‚Ñù</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{(n:{\mathbb{N}})}\mbox{Vec}({\mathbb{R}},n)
  </annotation>
 </semantics>
</math>

 would be the type of functions which, given a <a href="natural_number" title="wikilink">natural number</a> <em>n</em>, return a tuple of real numbers of size <em>n</em>. The usual function space arises as a special case when the range type does not actually depend on the input, <em>e.g.</em> 

<math display="inline" id="Dependent_type:13">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <msub>
     <mi mathvariant="normal">Œ†</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>:</mo>
      <mi>‚Ñï</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
   </mpadded>
   <mi>‚Ñù</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Œ†</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </apply>
    <ci>‚Ñù</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{(n:{\mathbb{N}})}\;{\mathbb{R}}
  </annotation>
 </semantics>
</math>

 is the type of functions from natural numbers to the real numbers, which is written as 

<math display="inline" id="Dependent_type:14">
 <semantics>
  <mrow>
   <mi>‚Ñï</mi>
   <mo>‚Üí</mo>
   <mi>‚Ñù</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <ci>‚Ñï</ci>
    <ci>‚Ñù</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbb{N}}\to{\mathbb{R}}
  </annotation>
 </semantics>
</math>

 in the simply typed lambda calculus.</p>

<p><a href="Polymorphism_(computer_science)" title="wikilink">Polymorphic functions</a> are an important example of dependent functions, that is, functions having dependent type. Given a type, these functions act on elements of that type (or on elements of a type constructed (derived, inherited) from that type). A polymorphic function returning elements of type <em>C</em> would have a polymorphic type written as</p>

<p>

<math display="block" id="Dependent_type:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Œ†</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>:</mo>
      <mi class="ltx_font_mathcaligraphic">ùí∞</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mi>A</mi>
   </mrow>
   <mo>‚Üí</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ†</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="unknown">U</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </apply>
     <ci>A</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{(A:\mathcal{U})}A\to C
  </annotation>
 </semantics>
</math>

</p>
<h2 id="dependent-pair-type">Dependent pair type</h2>

<p>The <a href="Dual_(category_theory)" title="wikilink">opposite</a> of the dependent type is the <strong>dependent pair type</strong>, <strong>dependent sum type</strong> or <strong>sigma-type</strong>. It is analogous to the <a class="uri" href="coproduct" title="wikilink">coproduct</a> or <a href="disjoint_union" title="wikilink">disjoint union</a>. Sigma-types can also be understood as models of <a href="Universal_quantification#As_adjoint" title="wikilink">existential quantifiers</a>. Notationally, it is written as</p>

<p>

<math display="block" id="Dependent_type:16">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Œ£</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Œ£</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </apply>
    <ci>B</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{(x:A)}B(x)
  </annotation>
 </semantics>
</math>

 The dependent pair type captures the idea of a pair, where the type of the second term is dependent on the first. Thus, if</p>

<p>

<math display="block" id="Dependent_type:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Œ£</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ£</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </apply>
     <ci>B</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b):\Sigma_{(x:A)}B(x)
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Dependent_type:18">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>:</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a:A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependent_type:19">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>:</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>b</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b:B(a)
  </annotation>
 </semantics>
</math>

. If <em>B</em> is a constant, then the dependent pair type becomes (is judgementally equal to) the <a href="product_type" title="wikilink">product type</a>, that is, an ordinary Cartesian product 

<math display="inline" id="Dependent_type:20">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>√ó</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\times B
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="example-as-existential-quantification">Example as existential quantification</h3>

<p>Let 

<math display="inline" id="Dependent_type:21">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Œ£</mi>
    <mi>A</mi>
    <msub>
     <mi>B</mi>
     <mi>a</mi>
    </msub>
   </mrow>
   <mo>:</mo>
   <mi class="ltx_font_mathcaligraphic">ùí∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>normal-Œ£</ci>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <ci>ùí∞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma AB_{a}:\mathcal{U}
  </annotation>
 </semantics>
</math>

 be sigma-type quantifying over type 

<math display="inline" id="Dependent_type:22">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>:</mo>
   <mi class="ltx_font_mathcaligraphic">ùí∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>A</ci>
    <ci>ùí∞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A:\mathcal{U}
  </annotation>
 </semantics>
</math>

 with predicate 

<math display="inline" id="Dependent_type:23">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>‚Üí</mo>
    <mi class="ltx_font_mathcaligraphic">ùí∞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>B</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>A</ci>
     <ci>ùí∞</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B:A\rightarrow\mathcal{U}
  </annotation>
 </semantics>
</math>

. There exists an 

<math display="inline" id="Dependent_type:24">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Dependent_type:25">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>a</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{a}
  </annotation>
 </semantics>
</math>

 holds <a href="if_and_only_if" title="wikilink">if and only if</a> 

<math display="inline" id="Dependent_type:26">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œ£</mi>
   <mi>A</mi>
   <msub>
    <mi>B</mi>
    <mi>a</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Œ£</ci>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma AB_{a}
  </annotation>
 </semantics>
</math>

 is inhabited. For example, <em>a</em> is less than <em>b</em> iff there exists a natural number <em>n</em> and a proof that <em>a</em>+<em>n</em>=<em>b</em>.</p>

<p>

<math display="block" id="Dependent_type:27">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>‚â§</mo>
   <mi>b</mi>
   <mo>‚áî</mo>
   <mi mathvariant="normal">Œ£</mi>
   <mi>‚Ñï</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Œª</mi>
    <mi>n</mi>
    <mo>‚Üí</mo>
    <mi>a</mi>
    <mo>+</mo>
    <mi>n</mi>
    <mo>=</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <leq></leq>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">Œ£</csymbol>
    <csymbol cd="unknown">N</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Œª</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-‚Üí</ci>
     <csymbol cd="unknown">a</csymbol>
     <plus></plus>
     <csymbol cd="unknown">n</csymbol>
     <eq></eq>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\leq b\iff\Sigma\mathbb{N}(\lambda n\rightarrow a+n=b)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="systems-of-the-lambda-cube">Systems of the lambda cube</h2>

<p><a href="Henk_Barendregt" title="wikilink">Henk Barendregt</a> developed the <a href="lambda_cube" title="wikilink">lambda cube</a> as a means of classifying type systems along three axes. The eight corners of the resulting cube-shaped diagram each correspond to a type system, with <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> in the least expressive corner, and <a href="calculus_of_constructions" title="wikilink">calculus of constructions</a> in the most expressive. The three axes of the cube correspond to three different augmentations of the simply typed lambda calculus: the addition of dependent types, the addition of polymorphism, and the addition of higher <a href="kind_(type_theory)" title="wikilink">kinded</a> type constructors (functions from types to types, for example). The lambda cube is generalized further by <a href="pure_type_system" title="wikilink">pure type systems</a>.</p>
<h3 id="first-order-dependent-type-theory">First order dependent type theory</h3>

<p>The system 

<math display="inline" id="Dependent_type:28">
 <semantics>
  <mrow>
   <mi>Œª</mi>
   <mi mathvariant="normal">Œ†</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Œª</ci>
    <ci>normal-Œ†</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\Pi
  </annotation>
 </semantics>
</math>

 of pure first order dependent types, corresponding to the logical framework <a href="LF_(logical_framework)" title="wikilink">LF</a>, is obtained by generalising the function space type of the <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> to the dependent product type.</p>
<h3 id="second-order-dependent-type-theory">Second order dependent type theory</h3>

<p>The system 

<math display="inline" id="Dependent_type:29">
 <semantics>
  <mrow>
   <mi>Œª</mi>
   <mi mathvariant="normal">Œ†</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Œª</ci>
    <ci>normal-Œ†</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\Pi 2
  </annotation>
 </semantics>
</math>

 of second order dependent types is obtained from 

<math display="inline" id="Dependent_type:30">
 <semantics>
  <mrow>
   <mi>Œª</mi>
   <mi mathvariant="normal">Œ†</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Œª</ci>
    <ci>normal-Œ†</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\Pi
  </annotation>
 </semantics>
</math>

 by allowing quantification over type constructors. In this theory the dependent product operator subsumes both the 

<math display="inline" id="Dependent_type:31">
 <semantics>
  <mo>‚Üí</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚Üí</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 operator of simply typed lambda calculus and the 

<math display="inline" id="Dependent_type:32">
 <semantics>
  <mo>‚àÄ</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

 binder of <a href="System_F" title="wikilink">System F</a>.</p>
<h3 id="higher-order-dependently-typed-polymorphic-lambda-calculus">Higher order dependently typed polymorphic lambda calculus</h3>

<p>The higher order system 

<math display="inline" id="Dependent_type:33">
 <semantics>
  <mrow>
   <mi>Œª</mi>
   <mi mathvariant="normal">Œ†</mi>
   <mi>œâ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Œª</ci>
    <ci>normal-Œ†</ci>
    <ci>œâ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\Pi\omega
  </annotation>
 </semantics>
</math>

 extends 

<math display="inline" id="Dependent_type:34">
 <semantics>
  <mrow>
   <mi>Œª</mi>
   <mi mathvariant="normal">Œ†</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Œª</ci>
    <ci>normal-Œ†</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\Pi 2
  </annotation>
 </semantics>
</math>

 to all four forms of abstraction from the <a href="lambda_cube" title="wikilink">lambda cube</a>: functions from terms to terms, types to types, terms to types and types to terms. The system corresponds to the <a href="Calculus_of_constructions" title="wikilink">Calculus of constructions</a> whose derivative, the <a href="calculus_of_inductive_constructions" title="wikilink">calculus of inductive constructions</a> is the underlying system of <a href="Coq" title="wikilink">the Coq proof assistant</a>.</p>
<h2 id="simultaneous-programming-language-and-logic">Simultaneous Programming language and Logic</h2>

<p>The <a href="Curry‚ÄìHoward_correspondence" title="wikilink">Curry‚ÄìHoward correspondence</a> implies that types can be constructed that express arbitrarily complex mathematical properties. If the user can supply a <a href="constructive_proof" title="wikilink">constructive proof</a> that a type is <em>inhabited</em> (i.e., that a value of that type exists) then a compiler can check the proof and convert it into executable computer code that computes the value by carrying out the construction. The proof checking feature makes dependently typed languages closely related to <a href="proof_assistant" title="wikilink">proof assistants</a>. The code-generation aspect provides a powerful approach to formal <a href="program_verification" title="wikilink">program verification</a> and <a href="proof-carrying_code" title="wikilink">proof-carrying code</a>, since the code is derived directly from a mechanically verified mathematical proof.</p>
<h2 id="comparison-of-languages-with-dependent-types">Comparison of languages with dependent types</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Language</p></th>
<th style="text-align: left;">
<p>Actively developed</p></th>
<th style="text-align: left;">
<p>Paradigm</p></th>
<th style="text-align: left;">
<p><a href="Tactic_(proof_assistant)" title="wikilink">Tactics</a></p></th>
<th style="text-align: left;">
<p><a href="Proof_term" title="wikilink">Proof terms</a></p></th>
<th style="text-align: left;">
<p><a href="Termination_checking" title="wikilink">Termination checking</a></p></th>
<th style="text-align: left;">
<p>Types can depend on</p></th>
<th style="text-align: left;">
<p><a href="Universe_(mathematics)" title="wikilink">Universes</a></p></th>
<th style="text-align: left;">
<p><a href="Proof_irrelevance" title="wikilink">Proof irrelevance</a></p></th>
<th style="text-align: left;">
<p><a href="Program_extraction" title="wikilink">Program extraction</a></p></th>
<th style="text-align: left;">
<p>Extraction erases irrelevant terms</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Agda_(theorem_prover)" title="wikilink">Agda</a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p></td>
<td style="text-align: left;">
<p><a href="Purely_functional" title="wikilink">Purely functional</a></p></td>
<td style="text-align: left;">
<p>Few/limited<mtpl></mtpl></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Any term</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Proof-irrelevant arguments (experimental)<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="ATS_(programming_language)" title="wikilink">ATS</a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p></td>
<td style="text-align: left;">
<p>Functional / imperative</p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Cayenne_(programming_language)" title="wikilink">Cayenne</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Purely functional</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Any term</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Coq" title="wikilink">Coq</a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p></td>
<td style="text-align: left;">
<p>Purely functional</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Any term</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Dependent_ML" title="wikilink">Dependent ML</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Natural numbers</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="http://code.google.com/p/guru-lang/">Guru</a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p></td>
<td style="text-align: left;">
<p>Purely functional<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Any term</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Idris_(programming_language)" title="wikilink">Idris</a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p></td>
<td style="text-align: left;">
<p>Purely functional<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Any term</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Matita" title="wikilink">Matita</a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p></td>
<td style="text-align: left;">
<p>Purely functional</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Any term</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="NuPRL" title="wikilink">NuPRL</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Purely functional</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Any term</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="F*_(programming_language)" title="wikilink">F*</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Functional /imperative</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Prototype_Verification_System" title="wikilink">PVS</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="http://sage.soe.ucsc.edu/">Sage</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Hybrid typechecking</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Twelf" title="wikilink">Twelf</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p><a href="Logic_programming" title="wikilink">Logic programming</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Any (LF) term</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="http://www.cs.bu.edu/~hwxi/Xanadu/Xanadu.html">Xanadu</a></p></td>
<td style="text-align: left;">

<p><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p></td>
<td style="text-align: left;">
<p>Imperative</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Typed_lambda_calculus" title="wikilink">Typed lambda calculus</a></li>
</ul>
<h2 id="footnotes">Footnotes</h2>
<references group="fn">
</references>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Norell, Ulf. <em><a href="http://www.cse.chalmers.se/~ulfn/papers/thesis.pdf">Towards a practical programming language based on dependent type theory</a></em>. PhD thesis, Department of Computer Science and Engineering, Chalmers University of Technology, SE-412 96 G√∂teborg, Sweden, September 2007.</li>
<li>Oury, Nicolas and Swierstra, Wouter (2008). <a href="http://www.cs.ru.nl/~wouters/Publications/ThePowerOfPi.pdf">"The Power of Pi"</a>. Accepted for presentation at ICFP, 2008.</li>
<li>Norell, Ulf (2008). <a href="http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf">Dependently Typed Programming in Agda</a>.</li>
</ul>
<h2 id="external">External</h2>
<ul>
<li><a href="http://sneezy.cs.nott.ac.uk/darcs/DTP08/">Dependently Typed Programming 2008</a></li>
<li><a href="http://sneezy.cs.nott.ac.uk/darcs/dtp10/">Dependently Typed Programming 2010</a></li>
<li><a href="http://www.cs.ru.nl/dtp11/">Dependently Typed Programming 2011</a></li>
<li><a href="http://www.haskell.org/haskellwiki/Dependent_type">"Dependent type"</a> at the Haskell Wiki</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Dependently_typed_programming" title="wikilink"> </a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">‚Ü©</a></li>
<li id="fn14"><a href="#fnref14">‚Ü©</a></li>
<li id="fn15"><a href="#fnref15">‚Ü©</a></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">‚Ü©</a></li>
<li id="fn18"><a href="#fnref18">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
