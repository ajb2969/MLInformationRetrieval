   2–3 tree      2–3 tree   In computer science , a 2–3 tree is a tree data structure , where every node with children ( internal node ) has either two children (2-node) and one data element or three children (3-nodes) and two data elements. Nodes on the outside of the tree ( leaf nodes ) have no children and one or two data elements. 1 2 2−3 trees were invented by John Hopcroft in 1970. 3  Image:2-3-4 tree 2-node.svg|2 node Image:2-3-4-tree 3-node.svg|3 node  2–3 trees are an isometry of AA trees , meaning that they are equivalent data structures. In other words, for every 2–3 tree, there exists at least one AA tree with data elements in the same order. 2–3 trees are balanced, meaning that each right, center, and left subtree contains the same or close to the same amount of data.  Definitions  We say that a node is a 2-node if and only if it has one data element and two children if it is an internal node.  We say that a node is a 3-node if and only if it has two data elements and three children if it is an internal node.  We say that   T   T   T   is a 2-3 tree if and only if one of the following statements hold:      T   T   T   is empty. In other words,   T   T   T   does not have any nodes.     T   T   T   is a 2-node   r   r   r   with data element   a   a   a   . If   r   r   r   has left child   L   L   L   and right child   R   R   R   , then   L   L   L   and   R   R   R   are non-empty 2-3 trees of the same height ,   a   a   a   is greater than each element in   L   L   L   , and   a   a   a   is less than each data element in   R   R   R   .     T   T   T   is a 3-node   r   r   r   with data elements   a   a   a   and   b   b   b   , where    a  <  b      a  b    a   . If   r   r   r   has left child   L   L   L   , middle child   M   M   M   , and right child   R   R   R   , then   L   L   L   ,   M   M   M   , and   R   R   R   are non-empty 2-3 trees of equal height,   a   a   a   is greater than each data element in   L   L   L   and less than each data element in   M   M   M   , and   b   b   b   is greater than each data element in   M   M   M   and less than each data element in   R   R   R   .   Properties   Every internal node is a 2-node or a 3-node.  All leaves are at the same level.  All data is kept in sorted order.   Operations  Searching  Searching for an item in a 2-3 tree is similar to searching for an item in a binary search tree . Since the data elements in each node is ordered, a search function will be directed to the correct subtree and eventually to the correct node which contains the item.   Let   T   T   T   be a 2-3 tree and   d   d   d   be the data element we want to find. If   T   T   T   is empty, then   d   d   d   is not in   T   T   T   and we're done.  Let   r   r   r   be the root of   T   T   T   .  Suppose   r   r   r   is a leaf. If   d   d   d   is not in   r   r   r   , then   d   d   d   is not in   T   T   T   . Otherwise,   d   d   d   is in   T   T   T   . In particular,   d   d   d   can be found at a leaf node. We need no further steps and we're done.  Suppose   r   r   r   is a 2-node with left child   L   L   L   and right child   R   R   R   . Let   e   e   e   be the data element in   r   r   r   . There are three cases: If   d   d   d   is equal to   e   e   e   , then we've found   d   d   d   in   T   T   T   and we're done. If    d  <  e      d  e    d   , then set   T   T   T   to   L   L   L   , which by definition is a 2-3 tree, and go back to step 2. If    d  >  e      d  e    d>e   , then set   T   T   T   to   R   R   R   and go back to step 2.  Suppose   r   r   r   is a 3-node with left child   L   L   L   , middle child   M   M   M   , and right child   R   R   R   . Let   a   a   a   and   b   b   b   be the two data elements of   r   r   r   , where    a  <  b      a  b    a   . There are four cases: If   d   d   d   is equal to   a   a   a   or   b   b   b   , then   d   d   d   is in   T   T   T   and we're done. If    d  <  a      d  a    d   , then set   T   T   T   to   L   L   L   and go back to step 2. If    a  <  d  <  b        a  d       b     a   , then set   T   T   T   to   M   M   M   and go back to step 2. If    d  >  b      d  b    d>b   , then set   T   T   T   to   R   R   R   and go back to step 2.   Insertion  Insertion works by searching for the proper location of the key and adds it there. If the node becomes a 4-node then the node is split from two 2-nodes and the middle key is moved up to the parent. The diagram illustrates the process. framed|none|800px|Insertion of a number in a 2-3 tree for the 3 possible cases.  See also   2–3–4 tree    Finger tree    2–3 heap    (a,b)-tree   References  External links   2–3 Tree Java Applet  2–3 Tree In-depth description  2–3 Tree in F#  2–3 Tree in Python   "  Category:B-tree     ↩  , p.145-147 ↩  ↩     