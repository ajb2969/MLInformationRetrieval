   Count-distinct problem      Count-distinct problem   In computer science, the count-distinct problem 1 (also known in applied mathematics as the cardinality estimation problem ) is the problem of finding the number of distinct elements in a data stream with repeated elements. This is a well-known problem with numerous applications. The elements might represent IP addresses of packets passing through a router , unique visitors to a web site, elements in a large database, motifs in a DNA sequence, or elements of RFID / sensor networks .  Formal definition   Instance : A stream of elements     x  1   ,   x  2   ,  …  ,   x  s       subscript  x  1    subscript  x  2   normal-…   subscript  x  s     x_{1},x_{2},\ldots,x_{s}   with repetitions, and an integer   m   m   m   . Let   n   n   n   be the number of distinct elements, namely    n  =   |   {   x  1   ,   x  2   ,  …  ,   x  s   }   |       n      subscript  x  1    subscript  x  2   normal-…   subscript  x  s       n=|\left\{{x_{1},x_{2},\ldots,x_{s}}\right\}|   , and let these elements be    {   e  1   ,   e  2   ,  …  ,   e  n   }      subscript  e  1    subscript  e  2   normal-…   subscript  e  n     \left\{{e_{1},e_{2},\ldots,e_{n}}\right\}   .  Objective : Find an estimate    n  ^     normal-^  n    \widehat{n}   of   n   n   n   using only   m   m   m   storage units, where    m  ≪  n     much-less-than  m  n    m\ll n   .   An example of an instance for the cardinality estimation problem is the stream    a  ,  b  ,  a  ,  c  ,  d  ,  b  ,  d     a  b  a  c  d  b  d    a,b,a,c,d,b,d   . For this instance,    n  =   |   {  a  ,  b  ,  c  ,  d  }   |   =  4        n     a  b  c  d         4     n=|\left\{{a,b,c,d}\right\}|=4   .  Naive solution  The naive solution to the problem is as follows:  Initialize a counter,    c   c   c    , to zero,     c  ←  0     normal-←  c  0    c\leftarrow 0    .  Initialize an efficient dictionary data structure,    D   D   D    , such as hash table or search tree in which insertion and membership can be performed quickly.  For each element     x  i     subscript  x  i    x_{i}    , a membership query is issued.  If     x  i     subscript  x  i    x_{i}    is not a member of    D   D   D    (      x  i   ∉  D       subscript  x  i   D    x_{i}\notin D    )  Add     x  i     subscript  x  i    x_{i}    to    D   D   D     Increase    c   c   c    by one,     c  ←   c  +  1      normal-←  c    c  1     c\leftarrow c+1     Otherwise (      x  i   ∈  D       subscript  x  i   D    x_{i}\in D    ) do nothing.  Output     n  =  c      n  c    n=c    .  As long as the number of distinct elements is not too big,   D   D   D   fits in main memory and an exact answer can be retrieved. However, this approach does not scale for bounded storage, or if the computation performed for each element    x  i     subscript  x  i    x_{i}   should be minimized. In such a case, several streaming algorithms have been proposed which use a fixed number of storage units.  Streaming algorithms  To handle the bounded storage constraint, streaming algorithms use a randomization to produce a non-exact estimation of the distinct number of elements,   n   n   n   . State-of-the-art estimators hash every element    e  j     subscript  e  j    e_{j}   into a low dimensional data sketch using a hash function,    h   (   e  j   )       h   subscript  e  j     h(e_{j})   . The different techniques can be classified according to the data sketches they store.  Min/max sketches  Min/max sketches 2  3 store only the minimum/maximum hashed values. Examples of known min/max sketch estimators: Chassaing et al. 4 presents max sketch which is the minimum-variance unbiased estimator for the problem. The continuous max sketches estimator 5 is the maximum likelihood estimator. The estimator of choice in practice is the HyperLogLog algorithm. 6  The intuition behind such estimators is that each sketch carries information about the desired quantity. For example, when every element    e  j     subscript  e  j    e_{j}   is associated with a uniform RV,     h   (   e  j   )    ∼   U   (  0  ,  1  )       similar-to    h   subscript  e  j      U   0  1      h(e_{j})\sim U(0,1)   , the expected minimum value of     h   (   e  1   )    ,   h   (   e  2   )    ,  …  ,   h   (   e  n   )         h   subscript  e  1      h   subscript  e  2    normal-…    h   subscript  e  n      h(e_{1}),h(e_{2}),\ldots,h(e_{n})   is    1  /   (   n  +  1   )       1    n  1     1/(n+1)   . The hash function guarantees that    h   (   e  j   )       h   subscript  e  j     h(e_{j})   is identical for all the appearances of    e  j     subscript  e  j    e_{j}   . Thus, the existence of duplicates does not affect the value of the extreme order statistics.  There are other estimation techniques other than min/max sketches. The first paper on count-distinct estimation by Flajolet et al. 7 describes a bit pattern sketch. In this case, the elements are hashed into a bit vector and the sketch holds the logical OR of all hashed values. The first asymptotically space- and time-optimal algorithm for this problem was given by Daniel M. Kane , Jelani Nelson, and David P. Woodruff. 8  Bottom- m sketches  Bottom- m sketches 9 are a generalization of min sketches, which maintain the   m   m   m   minimal values, where    m  ≥  1      m  1    m\geq 1   . See Cosma et al. 10 for a theoretical overview of count-distinct estimation algorithms, and Metwally 11 for a practical overview with comparative simulation results.  Weighted count-distinct problem  In its weighted version, each element is associated with a weight and the goal is to estimate the total sum of weights. Formally,   Instance : A stream of weighted elements     x  1   ,   x  2   ,  …  ,   x  s       subscript  x  1    subscript  x  2   normal-…   subscript  x  s     x_{1},x_{2},\ldots,x_{s}   with repetitions, and an integer   m   m   m   . Let   n   n   n   be the number of distinct elements, namely    n  =   |   {   x  1   ,   x  2   ,  …  ,   x  s   }   |       n      subscript  x  1    subscript  x  2   normal-…   subscript  x  s       n=|\left\{{x_{1},x_{2},\ldots,x_{s}}\right\}|   , and let these elements be    {   e  1   ,   e  2   ,  …  ,   e  n   }      subscript  e  1    subscript  e  2   normal-…   subscript  e  n     \left\{{e_{1},e_{2},\ldots,e_{n}}\right\}   . Finally, let    w  j     subscript  w  j    w_{j}   be the weight of    e  j     subscript  e  j    e_{j}   .  Objective : Find an estimate    w  ^     normal-^  w    \widehat{w}   of    w  =    ∑   j  =  1   n    w  j        w    superscript   subscript     j  1    n    subscript  w  j      w=\sum_{j=1}^{n}w_{j}   using only   m   m   m   storage units, where    m  ≪  n     much-less-than  m  n    m\ll n   .   An example of an instance for the weighted problem is     a   (  3  )    ,   b   (  4  )    ,   a   (  3  )    ,   c   (  2  )    ,   d   (  3  )    ,   b   (  4  )    ,   d   (  3  )         a  3     b  4     a  3     c  2     d  3     b  4     d  3     a(3),b(4),a(3),c(2),d(3),b(4),d(3)   . For this instance,      e  1   =  a   ,     e  2   =  b   ,     e  3   =  c   ,    e  4   =  d        formulae-sequence     subscript  e  1   a    formulae-sequence     subscript  e  2   b    formulae-sequence     subscript  e  3   c      subscript  e  4   d       e_{1}=a,e_{2}=b,e_{3}=c,e_{4}=d   , the weights are      w  1   =  3   ,     w  2   =  4   ,     w  3   =  2   ,    w  4   =  3        formulae-sequence     subscript  w  1   3    formulae-sequence     subscript  w  2   4    formulae-sequence     subscript  w  3   2      subscript  w  4   3       w_{1}=3,w_{2}=4,w_{3}=2,w_{4}=3   and     ∑   w  j    =  12         subscript  w  j    12    \sum{w_{j}}=12   .  As an application example,     x  1   ,   x  2   ,  …  ,   x  s       subscript  x  1    subscript  x  2   normal-…   subscript  x  s     x_{1},x_{2},\ldots,x_{s}   could be IP packets received by a server. Each packet belongs to one of   n   n   n   IP flows     e  1   ,   e  2   ,  …  ,   e  n       subscript  e  1    subscript  e  2   normal-…   subscript  e  n     e_{1},e_{2},\ldots,e_{n}   . The weight    w  j     subscript  w  j    w_{j}   can be the load imposed by flow    e  j     subscript  e  j    e_{j}   on the server. Thus,     ∑   j  =  1   n    w  j       superscript   subscript     j  1    n    subscript  w  j     \sum_{j=1}^{n}{w_{j}}   represents the total load imposed on the server by all the flows to which packets     x  1   ,   x  2   ,  …  ,   x  s       subscript  x  1    subscript  x  2   normal-…   subscript  x  s     x_{1},x_{2},\ldots,x_{s}   belong.  Solving the weighted count-distinct problem  Any extreme order statistics estimator (min/max sketches) for the unweighted problem can be generalized to an estimator for the weighted problem . 12 For example, the weighted estimator proposed by Cohen et al. 13 can be obtained when the continuous max sketches estimator is extended to solve the weighted problem. In particular, the HyperLogLog algorithm 14 can be extended to solve the weighted problem. The extended HyperLogLog algorithm offers the best performance, in terms of statistical accuracy and memory usage, among all the other known algorithms for the weighted problem.  See also   HyperLogLog  Count–min sketch  Streaming algorithm  Maximum likelihood  Minimum-variance unbiased estimator   References  "  Category:Statistical algorithms     ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩  ↩   ↩  ↩       