   MMH-Badger MAC      MMH-Badger MAC   Badger is a Message Authentication Code (MAC) based on the idea of universal hashing and was developed by Boesgaard, Christensen, and Zenner. 1 It is constructed by strengthening the ∆-universal hash family MMH using an ϵ-almost strongly universal (ASU) hash function family after the application of ENH (see below), where the value of ϵ is    1  /   (    2  32   -  5   )       1     superscript  2  32   5     1/(2^{32}-5)   . 2 Since Badger is a MAC function based on the universal hash function approach, the conditions needed for the security of Badger are the same as those for other universal hash functions such as UMAC .  Introduction  The Badger MAC processes a message of length up to     2  64   -  1       superscript  2  64   1    2^{64}-1   bits and returns an authentication  tag of length    u  ⋅  32     normal-⋅  u  32    u\cdot 32   bits, where    1  ≤  u  ≤  5        1  u       5     1\leq u\leq 5   . According to the security needs, user can choose the value of   u   u   u   , that is the number of parallel hash trees in Badger. One can choose larger values of u , but those values do not influence further the security of MAC. The algorithm uses a 128-bit key and the limited message length to be processed under this key is    2  64     superscript  2  64    2^{64}   . 3  The key setup has to be run only once per key in order to run the Badger algorithm under a given key, since the resulting internal state of the MAC can be saved to be used with any other message that will be processed later.  ENH  Hash families can be combined in order to obtain new hash families. For the ϵ-AU, ϵ-A∆U, and ϵ-ASU families, the latter are contained in the former. For instance, an A∆U family is also an AU family, an ASU is also an A∆U family, and so forth. On the other hand, a stronger family can be reduced to a weaker one, as long as a performance gain can be reached. A method to reduce ∆-universal hash function to universal hash functions will be described in the following.  Theorem 2 4  Let    H  △     superscript  H  normal-△    H^{\triangle}   be an ϵ-AΔU hash family from a set A to a set B . Consider a message     (  m  ,   m  b   )   ∈   A  ×  B        m   subscript  m  b      A  B     (m,m_{b})\in A\times B   . Then the family H consisting of the functions     h   (  m  ,   m  b   )    =     H  △    (  m  )    +   m  b          h   m   subscript  m  b          superscript  H  normal-△   m    subscript  m  b      h(m,m_{b})=H^{\triangle}(m)+m_{b}   is ϵ-AU.  If    m  ≠   m  ′       m   superscript  m  normal-′     m\neq m^{\prime}   , then the probability that     h   (  m  ,   m  b   )    =   h   (   m  ′   ,   m  b  ′   )          h   m   subscript  m  b       h    superscript  m  normal-′    subscript   superscript  m  normal-′   b       h(m,m_{b})=h(m^{\prime},m^{\prime}_{b})   is at most ϵ, since    H  △     superscript  H  normal-△    H^{\triangle}   is an ϵ-A∆U family. If    m  =   m  ′       m   superscript  m  normal-′     m=m^{\prime}   but     m  b   ≠   m  b  ′        subscript  m  b    superscript   subscript  m  b   normal-′     m_{b}\neq m_{b}^{\prime}   , then the probability is trivially 0. The proof for Theorem 2 was described in 5  The ENH-family is constructed based on the universal hash family NH (which is also used in UMAC ):       N   H  K    (  M  )    =     ∑   i  =  1    ℓ  2      (    k   (    2  i   -  1   )     +  w    m   (    2  i   -  1   )     )   ×   (    k   2  i     +  w    m   2  i     )     mod   2   2  w           N   subscript  H  K   M    modulo    superscript   subscript     i  1      normal-ℓ  2        subscript   w    subscript  k      2  i   1     subscript  m      2  i   1       subscript   w    subscript  k    2  i     subscript  m    2  i        superscript  2    2  w       NH_{K}(M)=\sum_{i=1}^{\frac{\ell}{2}}(k_{(2i-1)}+_{w}m_{(2i-1)})\times(k_{2i}+%
 _{w}m_{2i})\mod 2^{2w}     Where ‘    +  w     subscript   w    +_{w}   ’ means ‘addition modulo    2  w     superscript  2  w    2^{w}   ’, and      m  i   ,   k  i    ∈   {  0  ,  …  ,    2  w   -  1   }         subscript  m  i    subscript  k  i     0  normal-…     superscript  2  w   1      m_{i},k_{i}\in\big\{0,\ldots,2^{w}-1\big\}   . It is a    2   -  w      superscript  2    w     2^{-w}   -A∆U hash family.  Lemma 1 6  The following version of NH is    2   -  w      superscript  2    w     2^{-w}   -A∆U:       N   H  K    (  M  )    =     (    k  1    +  w    m  1    )   ×   (    k  2    +  w    m  2    )    mod   2   2  w           N   subscript  H  K   M    modulo      subscript   w    subscript  k  1    subscript  m  1      subscript   w    subscript  k  2    subscript  m  2      superscript  2    2  w       NH_{K}(M)=(k_{1}+_{w}m_{1})\times(k_{2}+_{w}m_{2})\mod 2^{2w}     Choosing w=32 and applying Theorem 1, one can obtain the    2   -  32      superscript  2    32     2^{-32}   -AU function family ENH, which will be the basic building block of the badger MAC:       E  N   H    k  1   ,   k  2      (   m  1   ,   m  2   ,   m  3   ,   m  4   )    =     (    m  1    +  32    k  1    )    (    m  2    +  32    k  2    )     +  64    m  3    +  64     2  32    m  4           E  N   subscript  H    subscript  k  1    subscript  k  2       subscript  m  1    subscript  m  2    subscript  m  3    subscript  m  4       subscript   64       subscript   32    subscript  m  1    subscript  k  1      subscript   32    subscript  m  2    subscript  k  2      subscript  m  3      superscript  2  32    subscript  m  4       ENH_{k_{1},k_{2}}(m_{1},m_{2},m_{3},m_{4})=(m_{1}+_{32}k_{1})(m_{2}+_{32}k_{2}%
 )+_{64}m_{3}+_{64}2^{32}m_{4}     where all arguments are 32-bits long and the output has 64-bits.  Construction  Badger is constructed using the strongly universality hash family and can be described as       ℋ  =    H  *   ×  F    ,      ℋ     superscript  H    F     \mathcal{H}=H^{*}\times F,    7  where an    ϵ   H  *      subscript  ϵ   superscript  H      \epsilon_{H^{*}}   -AU universal function family H* is used to hash messages of any size onto a fixed size and an    ϵ  F     subscript  ϵ  F    \epsilon_{F}   -ASU function family F is used to guarantee the strong universality of the overall construction. NH and ENH are used to construct H* . The maximum input size of the function family H* is     2  64   -  1       superscript  2  64   1    2^{64}-1   and the output size is 128 bits, split into 64 bits each for the message and the hash. The collision probability for the H* -function ranges from    2   -  32      superscript  2    32     2^{-32}   to    2   -  26.14      superscript  2    26.14     2^{-26.14}   . To construct the strongly universal function family F , the ∆-universal hash family MMH* is transformed into a strongly universal hash family by adding another key.  Two steps on Badger  There are two steps that have to be executed for every message: processing phase and finalize phase.  Processing phase 8 In this phase, the data is hashed to a 64-bit string. A core function   h   h   h          {  0  ,  1  }   64   ×    {  0  ,  1  }   128    →    {  0  ,  1  }   64      normal-→     superscript   0  1   64    superscript   0  1   128     superscript   0  1   64     \big\{0,1\big\}^{64}\times\big\{0,1\big\}^{128}\to\big\{0,1\big\}^{64}   is used in this processing phase, that hashes a 128-bit string     m  2   ∥   m  1      fragments   subscript  m  2   parallel-to   subscript  m  1     m_{2}\parallel m_{1}   to a 64-bit string    h   (  k  ,   m  2   ,   m  1   )       h   k   subscript  m  2    subscript  m  1      h(k,m_{2},m_{1})   as follows:       h   (  k  ,   m  2   ,   m  1   )    =     (    L   (   m  1   )     +  32    L   (  k  )     )   ⋅   (    U   (   m  1   )     +  32    U   (  k  )     )     +  64     m  2           h   k   subscript  m  2    subscript  m  1       subscript   64    normal-⋅    subscript   32     L   subscript  m  1      L  k      subscript   32     U   subscript  m  1      U  k      subscript  m  2      h(k,m_{2},m_{1})=(L(m_{1})+_{32}L(k))\cdot(U(m_{1})+_{32}U(k))+_{64}m_{2}\,     for any n ,    +  n     subscript   n    +_{n}   means addition modulo    2  n     superscript  2  n    2^{n}   . Given a 2n -bit string x , L(x) means least significant n bits, and U(x) means most significant n bits.  A message can be processed by using this function. Denote level_key [j][i] by    k  j  i     superscript   subscript  k  j   i    k_{j}^{i}   .  Pseudo-code of the processing phase is as follow.  L=|M|
 if L=0
 M^1=⋯=M^u=0
 Go to finalization
 r=L mod 64
 if r≠0:
 M=0^(64-r)∥M
 for i=1 to u:
 M^i=M
 v^'=max{1,⌈log_2 L⌉-6}
 for j=1 to v^':
 divide M^i into 64-bit blocks, M^i=m_t^i∥⋯∥m_1^i
 if t is even:
 M^i=h(k_j^i,m_t^i,m_(t-1)^i )∥⋯∥h(k_j^i,m_2^i,m_1^i )
 else
 M^i=m_t^i∥h(k_j^i,m_(t-1)^i,m_(t-2)^i )∥⋯∥h(k_j^i,m_2^i,m_1^i )  Finalize phase 9 In this phase, the 64-string resulting from the processing phase is transformed into the desired MAC tag. This finalization phase uses the Rabbit  stream cipher and uses both key setup and IV setup by taking the finalization key final_key[j][i] as    k  j  i     superscript   subscript  k  j   i    k_{j}^{i}   .  Pseudo-code of the finalization phase  RabbitKeySetup(K)
 RabbitIVSetup(N)
 for i=1 to u:
 Q^i=0^7∥L∥M^i
 divide Q^i into 27-bit blocks, Q^i=q_5^i∥⋯∥q_1^i
 S^i=(∑_(j=1)^5 (q_j^i K_j^i))+K_6^i mod p
 S=S^u∥⋯∥S^1
 S=S ⨁ RabbitNextbit(u∙32)
 return S  Notation:  From the pseudocode above, k denotes the key in the Rabbit Key Setup(K) which initializes Rabbit with the 128-bit key k . M denotes the message to be hashed and | M | denotes the length of the message in bits. q_i denotes a message M that is divided into i blocks. For the given 2n -bit string x then L( x ) and U( x ) respectively denoted its least significant n bits and most significant n bits.  Performance  Boesgard, Christensen and Zenner report the performance of Badger measured on a 1.0 GHz Pentium III and on a 1.7 GHz Pentium 4 processor. 10 The speed-optimized versions were programmed in assembly language inlined in C and compiled using the Intel C++ 7.1 compiler.  The following table presents Badger's properties for various restricted message lengths. “Memory req.” denotes the amount of memory required to store the internal state including key material and the inner state of the Rabbit  stream cipher . “Setup” denotes the key setup, and “Fin.” denotes finalization with IV-setup.      Max. Message Size   Forgery Bound   Memory Reg.   Setup Pentium III   Fin. Pentium III   Setup Pentium III   Fin. Pentium III           2  11     superscript  2  11    2^{11}   bytes (e.g.IPsec)       2   -  57.7      superscript  2    57.7     2^{-57.7}      400 bytes   1133 cycles   409 cycles   1774 cycles   776 cycles         2  15     superscript  2  15    2^{15}   bytes (e.g.TLS)       2   -  56.6      superscript  2    56.6     2^{-56.6}      528 bytes   1370 cycles   421 cycles   2100 cycles   778 cycles         2  32     superscript  2  32    2^{32}   bytes       2   -  54.2      superscript  2    54.2     2^{-54.2}      1072 bytes   2376 cycles   421 cycles   3488 cycles   778 cycles          2  61   -  1       superscript  2  61   1    2^{61}-1   bytes       2   -  52.2      superscript  2    52.2     2^{-52.2}      2000 bytes   4093 cycles   433 cycles   5854 cycles   800 cycles     MMH (Multilinear Modular Hashing)  The name MMH stands for Multilinear-Modular-Hashing. Applications in Multimedia are for example to verify the integrity of an on-line multimedia title. The performance of MMH is based on the improved support of integer scalar products in modern microprocessors.  MMH uses single precision scalar products as its most basic operation. It consists of a (modified) inner product between the message and a key modulo a prime    p   p   p   . The construction of MMH works in the finite field     F  p     subscript  F  p    F_{p}   for some prime integer   p   p   p   .  MMH*  MMH* involves a construction of a family of hash functions consisting of multilinear functions on    F  p  k     superscript   subscript  F  p   k    F_{p}^{k}   for some positive integer   k   k   k   . The family MMH* of functions from    F  p  k     superscript   subscript  F  p   k    F_{p}^{k}   to    F  p     subscript  F  p    F_{p}   is defined as follows.       MMH  *   =   {   g  x   :   F  p  k   →   F  p   |  x  ∈   F  p  k   }      fragments   superscript  MMH      fragments  normal-{   subscript  g  x   normal-:   superscript   subscript  F  p   k   normal-→   subscript  F  p   normal-|  x    superscript   subscript  F  p   k   normal-}     \mathrm{MMH}^{*}=\{g_{x}:F_{p}^{k}\rightarrow F_{p}|x\in F_{p}^{k}\}\,     where x, m are vectors, and the functions    g  x     subscript  g  x    g_{x}   are defined as follows.        g   x    (  m  )        subscript  g  x   m    \!g_{x}(m)   =     m  x   mod  p     modulo    m  x   p    mx\mod p   =      ∑   i  =  1   n      m  i     x  i     mod  p     modulo    superscript   subscript     i  1    n      subscript  m  i    subscript  x  i     p    \sum_{i=1}^{n}m_{i}\,x_{i}\mod p     In the case of MAC,   m   m   m   is a message and   x   x   x   is a key where    m  =   (   m  1   ,  …  ,   m  k   )       m    subscript  m  1   normal-…   subscript  m  k      m=(m_{1},\ldots,m_{k})   and     x  =    (   x  1   ,  …  ,   x  k   )   ,   x  i     ,    m  i   ∈   F  p       formulae-sequence    x     subscript  x  1   normal-…   subscript  x  k     subscript  x  i        subscript  m  i    subscript  F  p      x=(x_{1},\ldots,x_{k}),x_{i},m_{i}\in\!F_{p}   .  MMH* should satisfy the security requirements of a MAC, enabling say Ana and Bob to communicate in an authenticated way. They have a secret key   x   x   x   . Say Charles listens to the conversation between Ana and Bob and wants to change the message into his own message to Bob which should pass as a message from Ana. So, his message    m  ′     superscript  m  normal-′    m^{\prime}   and Ana's message   m   m   m   will differ in at least one bit (e.g.     m  1   ≠   m  1  ′        subscript  m  1    subscript   superscript  m  normal-′   1     m_{1}\neq m^{\prime}_{1}   ).  Assume that Charles knows that the function is of the form     g  x    (  m  )        subscript  g  x   m    g_{x}(m)   and he knows Ana's message   m   m   m   but he does not know the key x then the probability that Charles can change the message or send his own message can be explained by the following theorem.  Theorem 1 11 :The family MMH* is ∆-universal.  Proof:  Take    a  ∈   F  p       a   subscript  F  p     a\in F_{p}   , and let    m  ,   m  ′      m   superscript  m  normal-′     m,m^{\prime}   be two different messages. Assume without loss of generality that     m  1   ≠   m  1  ′        subscript  m  1    subscript   superscript  m  normal-′   1     m_{1}\neq m^{\prime}_{1}   . Then for any choice of     x  2   ,   x  3   ,  …  ,   x  s       subscript  x  2    subscript  x  3   normal-…   subscript  x  s     x_{2},x_{3},\ldots,x_{s}   , there is       Pr   x  1     [      g  x    (  m  )    -    g  x    (   m  ′   )     ≡   a  mod  p    ]       subscript  Pr   subscript  x  1           subscript  g  x   m      subscript  g  x    superscript  m  normal-′      modulo  a  p      \displaystyle{\Pr}_{x_{1}}[g_{x}(m)-g_{x}(m^{\prime})\equiv a\mod p]     To explain the theorem above, take    F  p     subscript  F  p    F_{p}   for   p   p   p   prime represent the field as     F  p   =     {  0  ,  1  ,  …  ,   p  -  1   }   ⏟   p        subscript  F  p    subscript   normal-⏟   0  1  normal-…    p  1     p     F_{p}=\underbrace{\big\{0,1,\ldots,p-1\big\}}_{p}   . If one takes an element in    F  p     subscript  F  p    F_{p}   , let say    0  ∈   F  p       0   subscript  F  p     0\in F_{p}   then the probability that     x  1   =  0       subscript  x  1   0    x_{1}=0   is        Pr    x  1   ∈   F  p      (    x  1   =  0   )    =   1  p         subscript  Pr     subscript  x  1    subscript  F  p        subscript  x  1   0      1  p     {\Pr}_{x_{1}\in\!{F_{p}}}(x_{1}=0)=\frac{1}{p}     So, what one actually needs to compute is       Pr    (   x  1   ,  …  ,   x  k   )   ∈   F  p  k      (     g  x    (  m  )    ≡     g  x    (   m  ′   )    mod  p    )       subscript  Pr      subscript  x  1   normal-…   subscript  x  k     superscript   subscript  F  p   k          subscript  g  x   m    modulo     subscript  g  x    superscript  m  normal-′    p      {\Pr}_{(x_{1},\ldots,x_{k})\in\!{F_{p}^{k}}}(g_{x}(m)\equiv g_{x}(m^{\prime})%
 \mod p)     But,       Pr    (   x  1   ,  …  ,   x  k   )   ∈   F  p  k      (     g  x    (  m  )    ≡     g  x    (   m  ′   )    mod  p    )       subscript  Pr      subscript  x  1   normal-…   subscript  x  k     superscript   subscript  F  p   k          subscript  g  x   m    modulo     subscript  g  x    superscript  m  normal-′    p      \displaystyle{\Pr}_{(x_{1},\ldots,x_{k})\in\!{F_{p}^{k}}}(g_{x}(m)\equiv g_{x}%
 (m^{\prime})\mod p)     From the proof above,    1  p      1  p    \frac{1}{p}   is the collision  probability of the attacker in 1 round, so on average   p   p   p   verification queries will suffice to get one message accepted. To reduce the collision  probability , it is necessary to choose large p or to concatenate   n   n   n   such MACs using   n   n   n   independent keys so that the collision  probability becomes    1   p  n       1   superscript  p  n     \frac{1}{p^{n}}   . In this case the number of keys are increased by a factor of   n   n   n   and the output is also increased by   n   n   n   .  MMH*32  Halevi and Krawczyk 12 construct a variant called    M  M   H  32  *       M  M   subscript   superscript  H    32     MMH^{*}_{32}   . The construction works with 32-bit integers and with the prime  integer     p  =    2  32   +  15       p     superscript  2  32   15     p=2^{32}+15   . Actually the prime  p can be chosen to be any prime which satisfies     2  31   -  1       superscript  2  31   1    2^{31}-1   or    MMH  32  *     subscript   superscript  MMH    32    \mathrm{MMH}^{*}_{32}   .        M  M   H  32  *    =   {    g  x     (    {  0  ,  1  }   32   )   k    }   →   F  p    ,          M  M   subscript   superscript  H    32        subscript  g  x    superscript   superscript   0  1   32   k       normal-→     subscript  F  p      MMH^{*}_{32}=\big\{g_{x}(\big\{0,1\big\}^{32})^{k}\big\}\to F_{p},   is defined as follows:       {  0  ,  1  }   32     superscript   0  1   32    \big\{0,1\big\}^{32}     where    {  0  ,  1  ,  …  ,    2  32   -  1   }     0  1  normal-…     superscript  2  32   1     \big\{0,1,\ldots,2^{32}-1\big\}   means    g  x     subscript  g  x    g_{x}   (i.e., binary representation)  The functions     g  x    (  m  )        subscript  g  x   m    \displaystyle g_{x}(m)   are defined as follows.      x  =   (   x  1   ,  …  ,   x  k   )       x    subscript  x  1   normal-…   subscript  x  k      x=(x_{1},\ldots,x_{k})     where      m  =   (  m  ,  …  ,   m  k   )       m   m  normal-…   subscript  m  k      m=(m,\ldots,m_{k})   ,    2   -  32      superscript  2    32     2^{-32}     By theorem 1, the collision  probability is about ϵ =    M  M   H  32  *       M  M   subscript   superscript  H    32     MMH^{*}_{32}   , and the family of    2   -  32      superscript  2    32     2^{-32}   can be defined as ϵ-almost ∆ Universal with ϵ =    1  /  p      1  p    1/p   .  The value of k  The value of k that describes the length of the message and key vectors has several effects:   Since the costly modular reduction over k is multiply and add operations increasing k should decrease the speed.  Since the key x consist of k 32-bit integers increasing k will results in a longer key.  The probability of breaking the system is    p  ≈   2  k       p   superscript  2  k     p\approx 2^{k}   and $p\approx 2^k$ so increasing k makes the system harder to break.   Performance  Below are the timing results for various implementations of MMH 13 in 1997, designed by Halevi and Krawczyk.   A 150 MHz PowerPC 604 RISC machine running AIX       150 MHz PowerPC 604   Message in Memory   Message in Cache       64-bit   390 Mbit/second   417 Mbit/second     32-bit output   597 Mbit/second   820 Mbit/second      A 150 MHz Pentium-Pro machine running Windows NT       150 MHz PowerPC 604   Message in Memory   Message in Cache       64-bit   296 Mbit/second   356 Mbit/second     32-bit output   556 Mbit/second   813 Mbit/second      A 200 MHz Pentium-Pro machine running Linux       150 MHz PowerPC 604   Message in Memory   Message in Cache       64-bit   380 Mbit/second   500 Mbit/second     32-bit output   645 Mbit/second   1080 Mbit/second     See also   UMAC  VMAC  Poly1305-AES   References  "  Category:Message authentication codes     ↩  ↩  ↩         ↩       