   Range concatenation grammars      Range concatenation grammars   Range concatenation grammar (RCG) is a grammar formalism developed by Pierre Boullier 1 in 1998 as an attempt to characterize a number of phenomena of natural language, such as Chinese numbers and German word order scrambling, which are outside the bounds of the Mildly context-sensitive languages . 2  From a theoretical point of view, any language that can be parsed in polynomial time belongs to the subset of RCG called positive range concatenation grammars, and reciprocally. 3  Though intended as a variant on Groenink's Literal movement grammars , RCGs treat the grammatical process more as a proof than as a production. Whereas LMGs produce a terminal string from a start predicate, RCGs aim to reduce a start predicate (which predicates of a terminal string) to the empty string, which constitutes a proof of the terminal strings membership in the language.  Description  Formal definition  A Positive Range Concatenation Grammar (PRCG) is a tuple    G  =   (  N  ,  T  ,  V  ,  S  ,  P  )       G   N  T  V  S  P     G=(N,~{}T,~{}V,~{}S,~{}P)   , where:      N   N   N   ,   T   T   T   and   V   V   V   are disjoint finite sets of (respectively) predicate names , terminal symbols and variable names . Each predicate name has an associated arity given by the function     d  i  m   :   N  →   ℕ  ∖   {  0  }        normal-:    d  i  m    normal-→  N    ℕ   0       dim:N\rightarrow\mathbb{N}\setminus\{0\}   .      S  ∈  N      S  N    S\in N   is the start predicate name and verify     d  i  m   (  S  )    =  1        d  i  m  S   1    dim(S)=1   .     P   P   P   is a finite set of clauses of the form     ψ  0   →    ψ  1   …   ψ  m       normal-→   subscript  ψ  0      subscript  ψ  1   normal-…   subscript  ψ  m      \psi_{0}\rightarrow\psi_{1}\ldots\psi_{m}   , where the    ψ  i     subscript  ψ  i    \psi_{i}   are predicates of the form     A  i    (   α  1   ,  …  ,   α   d  i  m   (   A  i   )     )        subscript  A  i     subscript  α  1   normal-…   subscript  α    d  i  m   subscript  A  i        A_{i}(\alpha_{1},\ldots,\alpha_{dim(A_{i})})   with     A  i   ∈  N       subscript  A  i   N    A_{i}\in N   and     α  i   ∈    (   T  ∪  V   )   ⋆        subscript  α  i    superscript    T  V   normal-⋆     \alpha_{i}\in(T\cup V)^{\star}   .   A Negative Range Concatenation Grammar (NRCG) is defined like a PRCG, but with the addition that some predicates occurring in the right-hand side of a clause can have the form      A  i    (   α  1   ,  …  ,   α   d  i  m   (   A  i   )     )    ¯     normal-¯     subscript  A  i     subscript  α  1   normal-…   subscript  α    d  i  m   subscript  A  i         \overline{A_{i}(\alpha_{1},\ldots,\alpha_{dim(A_{i})})}   . Such predicates are called negative predicates .  A Range Concatenation Grammar is a positive or a negative one. Although PRCGs are technically NRCGs, the terms are used to highlight the absence (PRCG) or presence (NRCG) of negative predicates.  A range in a word    w  ∈   T  ⋆       w   superscript  T  normal-⋆     w\in T^{\star}   is a couple     ⟨  l  ,  r  ⟩   w     subscript   l  r   w    \langle l,r\rangle_{w}   , with    0  ≤  l  ≤  r  ≤  n        0  l       r       n     0\leq l\leq r\leq n   , where   n   n   n   is the length of   w   w   w   . Two ranges     ⟨   l  1   ,   r  1   ⟩   w     subscript    subscript  l  1    subscript  r  1    w    \langle l_{1},r_{1}\rangle_{w}   and     ⟨   l  2   ,   r  2   ⟩   w     subscript    subscript  l  2    subscript  r  2    w    \langle l_{2},r_{2}\rangle_{w}   can be concatenated iff     r  1   =   l  2        subscript  r  1    subscript  l  2     r_{1}=l_{2}   , and we then have       ⟨   l  1   ,   r  1   ⟩   w   ⋅    ⟨   l  2   ,   r  2   ⟩   w    =    ⟨   l  1   ,   r  2   ⟩   w        normal-⋅   subscript    subscript  l  1    subscript  r  1    w    subscript    subscript  l  2    subscript  r  2    w     subscript    subscript  l  1    subscript  r  2    w     \langle l_{1},r_{1}\rangle_{w}\cdot\langle l_{2},r_{2}\rangle_{w}=\langle l_{1%
 },r_{2}\rangle_{w}   .  For a word    w  =    w  1    w  2   …   w  n        w     subscript  w  1    subscript  w  2   normal-…   subscript  w  n      w=w_{1}w_{2}\ldots w_{n}   , with     w  i   ∈  T       subscript  w  i   T    w_{i}\in T   , the dotted notation for ranges is      ⟨  l  ,  r  ⟩   w   =        w  1   …   w   l  -  1     ∙   w  l    …   w   r  -  1     ∙   w  r    …   w  n         subscript   l  r   w      normal-∙     normal-∙     subscript  w  1   normal-…   subscript  w    l  1      subscript  w  l    normal-…   subscript  w    r  1      subscript  w  r    normal-…   subscript  w  n      \langle l,r\rangle_{w}=w_{1}\ldots w_{l-1}\bullet w_{l}\ldots w_{r-1}\bullet w%
 _{r}\ldots w_{n}   .  Recognition of strings  Like LMGs, RCG clauses have the general schema     A   (   x  1   ,  …  ,   x  n   )    →  α     normal-→    A    subscript  x  1   normal-…   subscript  x  n     α    A(x_{1},...,x_{n})\to\alpha   , where in an RCG,   α   α   \alpha   is either the empty string or a string of predicates. The arguments    x  i     subscript  x  i    x_{i}   consist of strings of terminal symbols and/or variable symbols, which pattern match against actual argument values like in LMG. Adjacent variables constitute a family of matches against partitions, so that the argument    x  y      x  y    xy   , with two variables, matches the literal string    a  b      a  b    ab   in three different ways     x  =  ϵ   ,    y  =   a  b    ;    x  =  a   ,    y  =  b   ;    x  =   a  b    ,   y  =  ϵ          formulae-sequence    x  ϵ    formulae-sequence    y    a  b     formulae-sequence    x  a    formulae-sequence    y  b    formulae-sequence    x    a  b      y  ϵ         x=\epsilon,\ y=ab;\ x=a,\ y=b;\ x=ab,\ y=\epsilon   .  Predicate terms come in two forms, positive (which produce the empty string on success), and negative (which produce the empty string on failure/if the positive term does not produce the empty string). Negative terms are denoted the same as positive terms, with an overbar, as in     A   (   x  1   ,  …  ,   x  n   )    ¯     normal-¯    A    subscript  x  1   normal-…   subscript  x  n       \overline{A(x_{1},...,x_{n})}   .  The rewrite semantics for RCGs is rather simple, identical to the corresponding semantics of LMGs. Given a predicate string    A   (   α  1   ,  …  ,   α  n   )       A    subscript  α  1   normal-…   subscript  α  n      A(\alpha_{1},...,\alpha_{n})   , where the symbols    α  i     subscript  α  i    \alpha_{i}   are terminal strings, if there is a rule     A   (   x  1   ,  …  ,   x  n   )    →  β     normal-→    A    subscript  x  1   normal-…   subscript  x  n     β    A(x_{1},...,x_{n})\to\beta   in the grammar that the predicate string matches, the predicate string is replaced by   β   β   \beta   , substituting for the matched variables in each    x  i     subscript  x  i    x_{i}   .  For example, given the rule     A   (  x  ,   a  y  b   )    →   B   (   a  x  b   ,  y  )       normal-→    A   x    a  y  b       B     a  x  b   y      A(x,ayb)\to B(axb,y)   , where   x   x   x   and   y   y   y   are variable symbols and   a   a   a   and   b   b   b   are terminal symbols, the predicate string    A   (  a  ,   a  b  b   )       A   a    a  b  b      A(a,abb)   can be rewritten as    B   (   a  a  b   ,  b  )       B     a  a  b   b     B(aab,b)   , because    A   (  a  ,   a  b  b   )       A   a    a  b  b      A(a,abb)   matches    A   (  x  ,   a  y  b   )       A   x    a  y  b      A(x,ayb)   when     x  =  a   ,   y  =  b      formulae-sequence    x  a     y  b     x=a,\ y=b   . Similarly, if there were a rule     A   (  x  ,   a  y  b   )    →   A   (  x  ,  x  )   A   (  y  ,  y  )       normal-→    A   x    a  y  b       A   x  x   A   y  y      A(x,ayb)\to A(x,x)\ A(y,y)   ,    A   (  a  ,   a  b  b   )       A   a    a  b  b      A(a,abb)   could be rewritten as    A   (  a  ,  a  )   A   (  b  ,  b  )       A   a  a   A   b  b     A(a,a)\ A(b,b)   .  A proof/recognition of a string   α   α   \alpha   is done by showing that    S   (  α  )       S  α    S(\alpha)   produces the empty string. For the individual rewrite steps, when multiple alternative variable matches are possible, any rewrite which could lead the whole proof to succeed is considered. Thus, if there is at least one way to produce the empty string from the initial string    S   (  α  )       S  α    S(\alpha)   , the proof is considered a success, regardless of how many other ways to fail exist.  Example  RCGs are capable of recognizing the non-linear index language    {   w  w  w   :   w  ∈    {  a  ,  b  }   *    }     conditional-set    w  w  w     w   superscript   a  b        \{www:w\in\{a,b\}^{*}\}   as follows:  Letting x, y, and z be variable symbols:       S   (   x  y  z   )    →   A   (  x  ,  y  ,  z  )       normal-→    S    x  y  z      A   x  y  z      S(xyz)\to A(x,y,z)        A   (   a  x   ,   a  y   ,   a  z   )    →   A   (  x  ,  y  ,  z  )       normal-→    A     a  x     a  y     a  z       A   x  y  z      A(ax,ay,az)\to A(x,y,z)        A   (   b  x   ,   b  y   ,   b  z   )    →   A   (  x  ,  y  ,  z  )       normal-→    A     b  x     b  y     b  z       A   x  y  z      A(bx,by,bz)\to A(x,y,z)        A   (  ϵ  ,  ϵ  ,  ϵ  )    →  ϵ     normal-→    A   ϵ  ϵ  ϵ    ϵ    A(\epsilon,\epsilon,\epsilon)\to\epsilon     The proof for abbabbabb is then       S   (   a  b  b  a  b  b  a  b  b   )    ⇒   A   (   a  b  b   ,   a  b  b   ,   a  b  b   )    ⇒   A   (   b  b   ,   b  b   ,   b  b   )    ⇒   A   (  b  ,  b  ,  b  )    ⇒   A   (  ϵ  ,  ϵ  ,  ϵ  )    ⇒  ϵ       normal-⇒    S    a  b  b  a  b  b  a  b  b      A     a  b  b     a  b  b     a  b  b       normal-⇒      A     b  b     b  b     b  b       normal-⇒      A   b  b  b      normal-⇒      A   ϵ  ϵ  ϵ      normal-⇒    ϵ     S(abbabbabb)\Rightarrow A(abb,abb,abb)\Rightarrow A(bb,bb,bb)\Rightarrow A(b,b%
 ,b)\Rightarrow A(\epsilon,\epsilon,\epsilon)\Rightarrow\epsilon     Or, using the more correct dotted notation for ranges:      S   (  ∙  a  b  b  a  b  b  a  b  b  ∙  )   ⇒  A   (  ∙  a  b  b  ∙  a  b  b  a  b  b  ,  a  b  b  ∙  a  b  b  ∙  a  b  b  ,  a  b  b  a  b  b  ∙  a  b  b  ∙  )   ⇒  A   (  a  ∙  b  b  ∙  a  b  b  a  b  b  ,  a  b  b  a  ∙  b  b  ∙  a  b  b  ,  a  b  b  a  b  b  a  ∙  b  b  ∙  )      fragments  S   fragments  normal-(  normal-∙  a  b  b  a  b  b  a  b  b  normal-∙  normal-)   normal-⇒  A   fragments  normal-(  normal-∙  a  b  b  normal-∙  a  b  b  a  b  b  normal-,  a  b  b  normal-∙  a  b  b  normal-∙  a  b  b  normal-,  a  b  b  a  b  b  normal-∙  a  b  b  normal-∙  normal-)   normal-⇒  A   fragments  normal-(  a  normal-∙  b  b  normal-∙  a  b  b  a  b  b  normal-,  a  b  b  a  normal-∙  b  b  normal-∙  a  b  b  normal-,  a  b  b  a  b  b  a  normal-∙  b  b  normal-∙  normal-)     S(\bullet{}abbabbabb\bullet{})\Rightarrow A(\bullet{}abb\bullet{}abbabb,abb%
 \bullet{}abb\bullet{}abb,abbabb\bullet{}abb\bullet{})\Rightarrow A(a\bullet{}%
 bb\bullet{}abbabb,abba\bullet{}bb\bullet{}abb,abbabba\bullet{}bb\bullet{})       ⇒  A   (  a  b  ∙  b  ∙  a  b  b  a  b  b  ,  a  b  b  a  b  ∙  b  ∙  a  b  b  ,  a  b  b  a  b  b  a  b  ∙  b  ∙  )   ⇒  A   (  ϵ  ,  ϵ  ,  ϵ  )   ⇒  ϵ     fragments  normal-⇒  A   fragments  normal-(  a  b  normal-∙  b  normal-∙  a  b  b  a  b  b  normal-,  a  b  b  a  b  normal-∙  b  normal-∙  a  b  b  normal-,  a  b  b  a  b  b  a  b  normal-∙  b  normal-∙  normal-)   normal-⇒  A   fragments  normal-(  ϵ  normal-,  ϵ  normal-,  ϵ  normal-)   normal-⇒  ϵ    \Rightarrow A(ab\bullet{}b\bullet{}abbabb,abbab\bullet{}b\bullet{}abb,abbabbab%
 \bullet{}b\bullet{})\Rightarrow A(\epsilon,\epsilon,\epsilon)\Rightarrow\epsilon     References    "  Category:Formal languages  Category:Grammar frameworks     ↩  ↩  citing http://mjn.host.cs.st-andrews.ac.uk/publications/2001d.pdf ↩     