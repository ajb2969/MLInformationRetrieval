   Interior point method      Interior point method   Interior point methods (also referred to as barrier methods ) are a certain class of algorithms that solves linear and nonlinear convex optimization problems. John von Neumann 1 suggested an interior point method of linear programming which was neither a polynomial time method nor an efficient method in practice. In fact, it turned out to be slower in practice compared to simplex method which is not a polynomial time method. In 1984, Narendra Karmarkar developed a method for linear programming called Karmarkar's algorithm which runs in provably polynomial time and is also very efficient in practice. It enabled solutions of linear programming problems which were beyond the capabilities of simplex method. Contrary to the simplex method, it reaches a best solution by traversing the interior of the feasible region . The method can be generalized to convex programming based on a self-concordant  barrier function used to encode the convex set .  Any convex optimization problem can be transformed into minimizing (or maximizing) a linear function over a convex set by converting to the epigraph form. 2 The idea of encoding the feasible set using a barrier and designing barrier methods was studied by Anthony V. Fiacco, Garth P. McCormick, and others in the early 1960s. These ideas were mainly developed for general nonlinear programming , but they were later abandoned due to the presence of more competitive methods for this class of problems (e.g. sequential quadratic programming ).  Yurii Nesterov and Arkadi Nemirovski came up with a special class of such barriers that can be used to encode any convex set. They guarantee that the number of iterations of the algorithm is bounded by a polynomial in the dimension and accuracy of the solution. 3  Karmarkar's breakthrough revitalized the study of interior point methods and barrier problems, showing that it was possible to create an algorithm for linear programming characterized by polynomial complexity and, moreover, that was competitive with the simplex method. Already Khachiyan 's ellipsoid method was a polynomial time algorithm; however, it was too slow to be of practical interest.  The class of primal-dual path-following interior point methods is considered the most successful. Mehrotra's predictor-corrector algorithm provides the basis for most implementations of this class of methods. 4  Primal-dual interior point method for nonlinear optimization  The primal-dual method's idea is easy to demonstrate for constrained nonlinear optimization . For simplicity consider the all-inequality version of a nonlinear optimization problem:   minimize    f   (  x  )       f  x    f(x)~{}   subject to        c  i    (  x  )    ≥    0    for   i   =  1   ,    …  ,  m  ,  x   ∈   ℝ  n     ,     formulae-sequence         subscript  c  i   x     0  for  i        1       normal-…  m  x    superscript  ℝ  n      c_{i}(x)\geq 0~{}~{}\text{for}~{}i=1,\ldots,m,~{}~{}x\in\mathbb{R}^{n},   where    f  :    ℝ  n   →   ℝ  ,   c  i     :    ℝ  n   →   ℝ   (  1  )          normal-:  f   normal-→   superscript  ℝ  n    ℝ   subscript  c  i       normal-:     normal-→   superscript  ℝ  n    ℝ  1       f:\mathbb{R}^{n}\rightarrow\mathbb{R},c_{i}:\mathbb{R}^{n}\rightarrow\mathbb{R%
 }~{}~{}~{}~{}~{}~{}(1)   .   The logarithmic barrier function associated with (1) is       B   (  x  ,  μ  )    =     f   (  x  )    -    μ     ∑   i  =  1   m    ln   (    c  i    (  x  )    )        (  2  )          B   x  μ         f  x     μ    superscript   subscript     i  1    m        subscript  c  i   x       2     B(x,\mu)=f(x)-\mu~{}\sum_{i=1}^{m}\ln(c_{i}(x))~{}~{}~{}~{}~{}(2)     Here   μ   μ   \mu   is a small positive scalar, sometimes called the "barrier parameter". As   μ   μ   \mu   converges to zero the minimum of    B   (  x  ,  μ  )       B   x  μ     B(x,\mu)   should converge to a solution of (1).  The barrier function gradient is       g  b   =    g  -   μ    ∑   i  =  1   m     1    c  i    (  x  )      ∇   c  i     (  x  )        (  3  )         subscript  g  b      g    μ    superscript   subscript     i  1    m       1     subscript  c  i   x     normal-∇   subscript  c  i    x      3     g_{b}=g-\mu\sum_{i=1}^{m}\frac{1}{c_{i}(x)}\nabla c_{i}(x)~{}~{}~{}~{}~{}~{}(3)     where   g   g   g   is the gradient of the original function    f   (  x  )       f  x    f(x)   and    ∇   c  i      normal-∇   subscript  c  i     \nabla c_{i}   is the gradient of    c  i     subscript  c  i    c_{i}   .  In addition to the original ("primal") variable   x   x   x   we introduce a Lagrange multiplier inspired dual variable    λ  ∈   ℝ  m       λ   superscript  ℝ  m     \lambda\in\mathbb{R}^{m}            c  i    (  x  )    λ  i    =  μ   ,    ∀  i   =   1  ,  …  ,  m   (  4  )        formulae-sequence       subscript  c  i   x   subscript  λ  i    μ      for-all  i    1  normal-…  m  4      c_{i}(x)\lambda_{i}=\mu,\forall i=1,\ldots,m~{}~{}~{}~{}~{}~{}~{}(4)     (4) is sometimes called the "perturbed complementarity" condition, for its resemblance to "complementary slackness" in KKT conditions .  We try to find those    (   x  μ   ,   λ  μ   )      subscript  x  μ    subscript  λ  μ     (x_{\mu},\lambda_{\mu})   for which the gradient of the barrier function is zero.  Applying (4) to (3) we get an equation for the gradient:       g  -    A  T   λ    =   0   (  5  )          g     superscript  A  T   λ     0  5     g-A^{T}\lambda=0~{}~{}~{}~{}~{}~{}(5)   where the matrix   A   A   A   is the constraint    c   (  x  )       c  x    c(x)    Jacobian .  The intuition behind (5) is that the gradient of    f   (  x  )       f  x    f(x)   should lie in the subspace spanned by the constraints' gradients. The "perturbed complementarity" with small   μ   μ   \mu   (4) can be understood as the condition that the solution should either lie near the boundary      c  i    (  x  )    =  0         subscript  c  i   x   0    c_{i}(x)=0   or that the projection of the gradient   g   g   g   on the constraint component     c  i    (  x  )        subscript  c  i   x    c_{i}(x)   normal should be almost zero.  Applying Newton's method to (4) and (5) we get an equation for    (  x  ,  λ  )     x  λ    (x,\lambda)   update    (   p  x   ,   p  λ   )      subscript  p  x    subscript  p  λ     (p_{x},p_{\lambda})   :        (     W     -   A  T         Λ  A     C     )    (      p  x        p  λ      )    =   (       -  g   +    A  T   λ          μ  1   -   C  λ       )           W     superscript  A  T        normal-Λ  A   C       subscript  p  x      subscript  p  λ            g      superscript  A  T   λ          μ  1     C  λ        \begin{pmatrix}W&-A^{T}\\
 \Lambda A&C\end{pmatrix}\begin{pmatrix}p_{x}\\
 p_{\lambda}\end{pmatrix}=\begin{pmatrix}-g+A^{T}\lambda\\
 \mu 1-C\lambda\end{pmatrix}     where   W   W   W   is the Hessian matrix of    f   (  x  )       f  x    f(x)   and   Λ   normal-Λ   \Lambda   is a diagonal matrix of   λ   λ   \lambda   and   C   C   C   is a diagonal matrix where    C   i  i      subscript  C    i  i     C_{ii}   is     c  i    (  x  )        subscript  c  i   x    c_{i}(x)   .  Because of (1), (4) the condition      λ  ≥  0      λ  0    \lambda\geq 0     should be enforced at each step. This can be done by choosing appropriate   α   α   \alpha   :       (  x  ,  λ  )   →   (   x  +   α   p  x     ,   λ  +   α   p  λ     )      normal-→   x  λ      x    α   subscript  p  x       λ    α   subscript  p  λ        (x,\lambda)\rightarrow(x+\alpha p_{x},\lambda+\alpha p_{\lambda})   .  See also   Augmented Lagrangian method  Penalty method  Karush–Kuhn–Tucker conditions   References  Bibliography           "  Category:Optimization algorithms and methods     ↩  ↩  ↩  ↩     