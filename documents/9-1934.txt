   Blom's scheme      Blom's scheme   Blom's scheme is a symmetric threshold key exchange protocol in cryptography . The scheme was proposed by the Swedish cryptographer Rolf Blom in a series of articles in the early 1980s. 1 2  A trusted party gives each participant a secret key and a public identifier, which enables any two participants to independently create a shared key for communicating. However, if an attacker can compromise the keys of at least k users, he can break the scheme and reconstruct every shared key. Blom's scheme is a form of threshold secret sharing .  Blom's scheme is currently used by the HDCP copy protection scheme to generate shared keys for high-definition content sources and receivers, such as HD DVD players and high-definition televisions .  The protocol  The key exchange protocol involves a trusted party (Trent) and a group of   n   n   \scriptstyle n   users. Let Alice and Bob be two users of the group.  Protocol setup  Trent chooses a random and secret symmetric matrix     D   k  ,  k      subscript  D   k  k     \scriptstyle D_{k,k}   over the finite field     G  F   (  p  )       G  F  p    \scriptstyle GF(p)   , where p is a prime number.   D   D   \scriptstyle D   is required when a new user is to be added to the key sharing group.  For example:        k      =  3       p      =  17       D      =     (     1    6    2      6    3    8      2    8    2     )    mod  17          k    absent  3     p    absent  17     D    absent      1  6  2    6  3  8    2  8  2    mod  17       \begin{aligned}\displaystyle k&\displaystyle=3\\
 \displaystyle p&\displaystyle=17\\
 \displaystyle D&\displaystyle=\begin{pmatrix}1&6&2\\
 6&3&8\\
 2&8&2\end{pmatrix}\ \mathrm{mod}\ 17\end{aligned}     Inserting a new participant  New users Alice and Bob want to join the key exchanging group. Trent chooses public identifiers for each of them; i.e., k-element vectors:        I  Alice   ,   I  Bob    ∈   G  F   (  p  )          subscript  I  Alice    subscript  I  Bob      G  F  p     I_{\mathrm{Alice}},I_{\mathrm{Bob}}\in GF(p)   .  For example:        I  Alice   =   (     3      10      11     )    ,    I  Bob   =   (     1      3      15     )       formulae-sequence     subscript  I  Alice     3    10    11        subscript  I  Bob     1    3    15       I_{\mathrm{Alice}}=\begin{pmatrix}3\\
 10\\
 11\end{pmatrix},I_{\mathrm{Bob}}=\begin{pmatrix}1\\
 3\\
 15\end{pmatrix}     Trent then computes their private keys:         g  Alice       =   D   I  Alice          g  Bob       =   D   I  Bob            subscript  g  Alice     absent    D   subscript  I  Alice        subscript  g  Bob     absent    D   subscript  I  Bob        \begin{aligned}\displaystyle g_{\mathrm{Alice}}&\displaystyle=DI_{\mathrm{%
 Alice}}\\
 \displaystyle g_{\mathrm{Bob}}&\displaystyle=DI_{\mathrm{Bob}}\end{aligned}     Using   D   D   D   as described above:         g  Alice       =    (     1    6    2      6    3    8      2    8    2     )    (     3      10      11     )    =     (     85      136      108     )    mod  17   =   (     0      0      6     )         g  Bob       =    (     1    6    2      6    3    8      2    8    2     )    (     1      3      15     )    =     (     49      135      56     )    mod  17   =   (     15      16      5     )           subscript  g  Alice       absent      1  6  2    6  3  8    2  8  2      3    10    11              85    136    108    mod  17          0    0    6         subscript  g  Bob       absent      1  6  2    6  3  8    2  8  2      1    3    15              49    135    56    mod  17          15    16    5         \begin{aligned}\displaystyle g_{\mathrm{Alice}}&\displaystyle=\begin{pmatrix}1%
 &6&2\\
 6&3&8\\
 2&8&2\end{pmatrix}\begin{pmatrix}3\\
 10\\
 11\end{pmatrix}=\begin{pmatrix}85\\
 136\\
 108\end{pmatrix}\ \mathrm{mod}\ 17=\begin{pmatrix}0\\
 0\\
 6\end{pmatrix}\\
 \displaystyle g_{\mathrm{Bob}}&\displaystyle=\begin{pmatrix}1&6&2\\
 6&3&8\\
 2&8&2\end{pmatrix}\begin{pmatrix}1\\
 3\\
 15\end{pmatrix}=\begin{pmatrix}49\\
 135\\
 56\end{pmatrix}\ \mathrm{mod}\ 17=\begin{pmatrix}15\\
 16\\
 5\end{pmatrix}\end{aligned}     Each will use their private key to compute shared keys with other participants of the group.  Computing a shared key between Alice and Bob  Now Alice and Bob wish to communicate with one another. Alice has Bob's identifier    I  Bob     subscript  I  Bob    \scriptstyle I_{\mathrm{Bob}}   and her private key    g  Alice     subscript  g  Alice    \scriptstyle g_{\mathrm{Alice}}   .  She computes the shared key     k   Alice  /  Bob    =    g  Alice  t    I  Bob         subscript  k    Alice  Bob       superscript   subscript  g  Alice   t    subscript  I  Bob      \scriptstyle k_{\mathrm{Alice/Bob}}=g_{\mathrm{Alice}}^{t}I_{\mathrm{Bob}}   , where   t   t   \scriptstyle t   denotes matrix transpose . Bob does the same, using his private key and her identifier, giving the same result:       k   Alice  /  Bob    =   k   Alice  /  Bob   t   =    (    g  Alice  t    I  Bob    )   t   =    (    I  Alice  t    D  t    I  Bob    )   t   =    I  Bob  t   D   I  Alice    =   k   Bob  /  Alice           subscript  k    Alice  Bob     superscript   subscript  k    Alice  Bob    t         superscript     superscript   subscript  g  Alice   t    subscript  I  Bob    t         superscript     superscript   subscript  I  Alice   t    superscript  D  t    subscript  I  Bob    t           superscript   subscript  I  Bob   t   D   subscript  I  Alice          subscript  k    Bob  Alice       k_{\mathrm{Alice/Bob}}=k_{\mathrm{Alice/Bob}}^{t}=(g_{\mathrm{Alice}}^{t}I_{%
 \mathrm{Bob}})^{t}=(I_{\mathrm{Alice}}^{t}D^{t}I_{\mathrm{Bob}})^{t}=I_{%
 \mathrm{Bob}}^{t}DI_{\mathrm{Alice}}=k_{\mathrm{Bob/Alice}}     They will each generate their shared key as follows:         k   Alice  /  Bob        =     (     0      0      6     )   t    (     1      3      15     )    =    0  ×  1   +   0  ×  3   +   6  ×  15    =    90   mod  17   =  5        k   Bob  /  Alice        =     (     15      16      5     )   t    (     3      10      11     )    =    15  ×  3   +   16  ×  10   +   5  ×  11    =    260   mod  17   =  5          subscript  k    Alice  Bob        absent     superscript    0    0    6    t     1    3    15              0  1     0  3     6  15           90  mod  17        5       subscript  k    Bob  Alice        absent     superscript    15    16    5    t     3    10    11              15  3     16  10     5  11           260  mod  17        5       \begin{aligned}\displaystyle k_{\mathrm{Alice/Bob}}&\displaystyle=\begin{%
 pmatrix}0\\
 0\\
 6\end{pmatrix}^{t}\begin{pmatrix}1\\
 3\\
 15\end{pmatrix}=0\times 1+0\times 3+6\times 15=90\ \mathrm{mod}\ 17=5\\
 \displaystyle k_{\mathrm{Bob/Alice}}&\displaystyle=\begin{pmatrix}15\\
 16\\
 5\end{pmatrix}^{t}\begin{pmatrix}3\\
 10\\
 11\end{pmatrix}=15\times 3+16\times 10+5\times 11=260\ \mathrm{mod}\ 17=5\end{aligned}     Attack resistance  In order to ensure at least k keys must be compromised before every shared key can be computed by an attacker, identifiers must be k-linearly independent: all sets of k randomly selected user identifiers must be linearly independent. Otherwise, a group of malicious users can compute the key of any other member whose identifier is linearly dependent to theirs. To ensure this property, the identifiers shall be preferably chosen from a MDS-Code matrix (maximum distance separable error correction code matrix). The rows of the MDS-Matrix would be the identifiers of the users. A MDS-Code matrix can be chosen in practice using the code-matrix of the Reed–Solomon error correction code (this error correction code requires only easily understandable mathematics and can be computed extremely quickly). 3  References    "  Category:Secret sharing  Category:Key management  Category:Cryptography     Blom, Rolf. Non-public key distribution. In Proc. CRYPTO 82, pages 231–236, New York, 1983. Plenum Press ↩  Blom, Rolf. "An optimal class of symmetric key generation systems", Report LiTH-ISY-I-0641, Linköping University, 1984 1 ↩  ↩     