<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1961">Color normalization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Color normalization</h1>
<hr/>

<p><strong>Color normalization</strong> is a topic in <a href="computer_vision" title="wikilink">computer vision</a> concerned with artificial <a href="color_vision" title="wikilink">color vision</a> and object recognition. In general, the distribution of color values in an image depends on the illumination - which may vary i.e. depending on different lighting conditions or different cameras. Colour normalisation allows for object recognition techniques based on colour, to compensate for these variations.</p>
<h2 id="main-concepts">Main concepts</h2>
<h3 id="color-constancy">Color constancy</h3>

<p><a href="Color_constancy" title="wikilink">Color constancy</a> is a feature of the human internal model of perception, which provides us with the ability to assign a relatively constant color to objects even under different illumination conditions. This is helpful for object recognition as well as identification of light sources in an environment. For example, humans see an object approximately as the same color during the day when the sun is bright as well as during noon when the sun is dim.</p>
<h3 id="applications">Applications</h3>

<p>Color normalization has been used for object recognition on color images in the field of <a class="uri" href="Robotics" title="wikilink">Robotics</a>, <a class="uri" href="Bioinformatics" title="wikilink">Bioinformatics</a> and general <a href="Artificial_Intelligence" title="wikilink">Artificial Intelligence</a>, when it is important to remove all intensity values from the image while preserving color values. One example is in case of a scene shot by a <a class="uri" href="surveillance" title="wikilink">surveillance</a> camera over the day, where it is important to remove shadows or lighting changes on same color pixels and recognize the people that passed.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Another example is automated screening tools used for the detection of diabetic retinopathy<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> as well as molecular diagnosis of cancer states,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> where it is important to include color information during classification.</p>
<h2 id="known-issues">Known issues</h2>

<p>The main issue about certain applications of color normalization is that the end result looks unnatural or too distant from the original colors.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In cases where there is a subtle variation between important aspects, this can be problematic. More specifically, the side effect can be that pixels become divergent and not reflect the actual color value of the image. A way of combating this issue is to use color normalization in combination with <a href="thresholding_(image_processing)" title="wikilink">thresholding (image processing)</a> to correctly and consistently segment a colored image.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="transformations-and-algorithms">Transformations and algorithms</h2>

<p>There is a vast array of different transformations and algorithms for achieving color normalization and a limited list is presented here. It is important to note that the performance of an algorithm is dependent on the task and one algorithm which performs better than another in one task, might perform worse in another (<a href="No_free_lunch_theorem" title="wikilink">No free lunch theorem</a>). Additionally, the choice of the algorithm depends on the preferences of the user for the end-result i.e. more natural-looking color image.</p>
<h3 id="grey-world">Grey world</h3>

<p>The grey world normalization makes the assumption that changes in the lighting spectrum can be modelled by three constant factors applied to the red, green and blue channels of color.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> More specifically, a change in illuminated color can be modelled as a scaling α, β and γ in the R, G and B color channels and as such the grey world algorithm is invariant to illumination color variations. Therefore a constancy solution can be achieved by dividing each color channel by its average value as shown in the following formula:</p>

<p>

<math display="inline" id="Color_normalization:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>α</mi>
     <mi>R</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>β</mi>
     <mi>G</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>γ</mi>
     <mi>B</mi>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mrow>
      <mi>α</mi>
      <mi>R</mi>
     </mrow>
     <mrow>
      <mfrac>
       <mi>α</mi>
       <mi>n</mi>
      </mfrac>
      <mrow>
       <mstyle displaystyle="false">
        <msub>
         <mo largeop="true" symmetric="true">∑</mo>
         <mi>i</mi>
        </msub>
       </mstyle>
       <mi>R</mi>
      </mrow>
     </mrow>
    </mfrac>
    <mo>,</mo>
    <mfrac>
     <mrow>
      <mi>β</mi>
      <mi>G</mi>
     </mrow>
     <mrow>
      <mfrac>
       <mi>β</mi>
       <mi>n</mi>
      </mfrac>
      <mrow>
       <mstyle displaystyle="false">
        <msub>
         <mo largeop="true" symmetric="true">∑</mo>
         <mi>i</mi>
        </msub>
       </mstyle>
       <mi>G</mi>
      </mrow>
     </mrow>
    </mfrac>
    <mo>,</mo>
    <mfrac>
     <mrow>
      <mi>γ</mi>
      <mi>B</mi>
     </mrow>
     <mrow>
      <mfrac>
       <mi>γ</mi>
       <mi>n</mi>
      </mfrac>
      <mrow>
       <mstyle displaystyle="false">
        <msub>
         <mo largeop="true" symmetric="true">∑</mo>
         <mi>i</mi>
        </msub>
       </mstyle>
       <mi>B</mi>
      </mrow>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <vector>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <ci>γ</ci>
      <ci>B</ci>
     </apply>
    </vector>
    <vector>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>α</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>i</ci>
        </apply>
        <ci>R</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>G</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>β</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>i</ci>
        </apply>
        <ci>G</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>γ</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>i</ci>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\alpha R,\beta G,\gamma B\right)\rightarrow\left(\frac{\alpha R}{\frac{%
\alpha}{n}\sum_{i}R},\frac{\beta G}{\frac{\beta}{n}\sum_{i}G},\frac{\gamma B}{%
\frac{\gamma}{n}\sum_{i}B}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>As mentioned above, grey world color normalization is invariant to illuminated color variations α, β and γ, however it has one important problem: it does not account for all variations of illumination intensity and it is not dynamic; when new objects appear in the scene it fails.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> To solve this problem there are several variants of the grey world algorithm.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Additionally there is an iterative variation of the grey world normalization, however it was not found to perform significantly better.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="histogram-equalization">Histogram equalization</h3>

<p><a href="Histogram_equalization" title="wikilink">Histogram equalization</a> is a non-linear transform which maintains pixel rank and is capable of normalizing for any monotonically increasing color transform function. It is considered to be a more powerful normalization transformation than the grey world method. The results of histogram equalization tend to have an exaggerated blue channel and look unnatural, due to the fact that in most images the distribution of the pixel values is usually more similar to a Gaussian distribution, rather than uniform.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="histogram-specification">Histogram specification</h3>

<p>Histogram specification transforms the red, green and blue histograms to match the shapes of three specific histograms, rather than simply equalizing them. It refers to a class of image transforms which aims to obtain images of which the histograms have a desired shape.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> As specified, firstly it is necessary to convert the image so that it has a particular histogram. Assume an image x. The following formula is the equalization transform of this image:</p>

<p>

<math display="inline" id="Color_normalization:1">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi>x</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>u</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>x</ci>
       </apply>
       <ci>u</ci>
       <ci>d</ci>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=f(x)=\int\limits_{0}^{x}p_{x}(u)du
  </annotation>
 </semantics>
</math>

</p>

<p>Then assume wanted image z. The equalization transform of this image is:</p>

<p>

<math display="inline" id="Color_normalization:2">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi>z</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>z</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>u</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <ci>z</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>z</ci>
       </apply>
       <ci>u</ci>
       <ci>d</ci>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=g(z)=\int\limits_{0}^{z}p_{z}(u)du
  </annotation>
 </semantics>
</math>

</p>

<p>Of course p_z (u) is the histogram of the output image. The formula to find the inverse of the above transform is:</p>

<p>

<math display="inline" id="Color_normalization:3">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=g^{-1}(y^{\prime})
  </annotation>
 </semantics>
</math>


</p>

<p>Therefore, since images y and y' have the same equalized histogram they are actually the same image, meaning y = y' and the transform from the given image x to the wanted image z is:</p>

<p>

<math display="inline" id="Color_normalization:4">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>z</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=g^{-1}(y^{\prime})=g^{-1}(y)=g^{-1}(f(x))
  </annotation>
 </semantics>
</math>

</p>

<p>Histogram specification has the advantage of producing more realistic looking images,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> as it does not exaggerate the blue channel like <a href="histogram_equalization" title="wikilink">histogram equalization</a>.</p>
<h3 id="comprehensive-color-normalization">Comprehensive Color Normalization</h3>

<p>The comprehensive color normalization is shown to increase localization and object classification results in combination with color indexing.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> It is an iterative algorithm which works in two stages. The first stage is to use the red, green and blue color space with the intensity normalized, to normalize each pixel. The second stage is to normalize each color channel separately, so that the sum of the color components is equal to one third of the number of pixels. The iterations continue until convergence, meaning no additional changes. Formally:</p>

<p>Normalize the color image</p>

<p>

<math display="inline" id="Color_normalization:5">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msubsup>
      <mi>f</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mrow>
       <mn>1...</mn>
       <mi>N</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mrow>
       <mn>1...</mn>
       <mi>M</mi>
      </mrow>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <apply>
        <times></times>
        <cn type="float">1...</cn>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <apply>
        <times></times>
        <cn type="float">1...</cn>
        <ci>M</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{(t)}=[f_{ij}^{(t)}]_{i=1...N,j=1...M}
  </annotation>
 </semantics>
</math>

</p>

<p>which consists of color vectors</p>

<p>

<math display="inline" id="Color_normalization:6">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>f</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>r</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <mo>,</mo>
      <msubsup>
       <mi>g</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <mo>,</mo>
      <msubsup>
       <mi>b</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{ij}^{(t)}=(r_{ij}^{(t)},g_{ij}^{(t)},b_{ij}^{(t)})^{T}.
  </annotation>
 </semantics>
</math>

</p>

<p>For the first step explained above, compute:</p>

<p>

<math display="inline" id="Color_normalization:7">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msubsup>
     <mi>r</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>+</mo>
    <msubsup>
     <mi>g</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>+</mo>
    <msubsup>
     <mi>b</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{ij}:=r_{ij}^{(t)}+g_{ij}^{(t)}+b_{ij}^{(t)}
  </annotation>
 </semantics>
</math>

</p>

<p>which leads to</p>

<p>

<math display="inline" id="Color_normalization:8">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>r</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <msubsup>
      <mi>r</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msubsup>
     <mi>g</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <msubsup>
      <mi>g</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{ij}^{(t+1)}=\frac{r_{ij}^{(t)}}{S_{ij}},g_{ij}^{(t+1)}=\frac{g_{ij}^{(t)}}{%
S_{ij}}
  </annotation>
 </semantics>
</math>


</p>

<p>and</p>

<p>

<math display="inline" id="Color_normalization:9">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>b</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <msubsup>
      <mi>b</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{ij}^{(t+1)}=\frac{b_{ij}^{(t)}}{S_{ij}}.
  </annotation>
 </semantics>
</math>

</p>

<p>For the second step explained above, compute:</p>

<p>

<math display="inline" id="Color_normalization:10">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>3</mn>
     <mrow>
      <mi>N</mi>
      <mi>M</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </msubsup>
      <msubsup>
       <mi>r</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime}=\frac{3}{NM}\sum_{i=1}^{N}\sum_{j=1}^{M}r_{ij}^{(t)}
  </annotation>
 </semantics>
</math>

</p>

<p>and normalize</p>

<p>

<math display="inline" id="Color_normalization:11">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>r</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <msubsup>
      <mi>r</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <msup>
      <mi>r</mi>
      <mo>′</mo>
     </msup>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{ij}^{(t+2)}=\frac{r_{ij}^{(t+1)}}{r^{\prime}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Of course the same process is done for b' and g'. Then these two steps are repeated until the changes between iteration t and t+2 are less than some set threshold.</p>

<p>Comprehensive color normalization, just like the <a href="histogram_equalization" title="wikilink">histogram equalization</a> method previously mentioned, produces results that may look less natural due to the reduction in the number of color values.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://fourier.eng.hmc.edu/e161/lectures/contrast_transform/contrast_transform.html">Image Enhancement by Contrast Transform</a></li>
<li><a href="http://web.media.mit.edu/~wad/color/constancy.html">Color Constancy MIT</a></li>
</ul>

<p>"</p>

<p><a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Artificial_intelligence" title="wikilink">Category:Artificial intelligence</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
</ol>
</section>
</body>
</html>
