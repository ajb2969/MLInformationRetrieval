<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="701">Biology Monte Carlo method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Biology Monte Carlo method</h1>
<hr>'''Biology [[Monte Carlo methods]] (BioMOCA)''' have been developed at the [[University of Illinois at Urbana-Champaign]] to simulate ion transport in an electrolyte environment through ion channels or nano-pores embedded in membranes.<ref name="Straaten">T.A. van der Straaten, G. Kathawala, A. Trellakis, R.S. Eisenberg, and U. Ravai
<p>oli, Molecular Simulation, 31, 151 (2005) It is a 3-D particle-based <a href="Monte_Carlo" title="wikilink">Monte Carlo</a> simulator for analyzing and studying the ion transport problem in ion channel systems or similar nanopores in wet/biological environments. The system simulated consists of a protein forming an ion channel (or an artificial nanopores like a Carbon Nano Tube, CNT), with a membrane (i.e. lipid bilayer) that separates two ion baths on either side. BioMOCA is based on two methodologies, namely the <a href="Boltzmann_equation" title="wikilink">Boltzmann transport</a> Monte Carlo (BTMC)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and particle-particle-particle-mesh (P<sup>3</sup>M).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The first one uses Monte Carlo method to solve the Boltzmann equation, while the later splits the electrostatic forces into short-range and long-range components.</p>
<h2 id="backgrounds">Backgrounds</h2>

<p>In full-atomic <a href="molecular_dynamics" title="wikilink">molecular dynamics</a> simulations of <a href="ion_channel" title="wikilink">ion channels</a>, most of the computational cost is for following the trajectory of water molecules in the system. However, in BioMOCA the water is treated as a continuum dielectric background media. In addition to that, the <a class="uri" href="protein" title="wikilink">protein</a> atoms of the ion channel are also modeled as static point charges embedded in a finite volume with a given dielectric coefficient. So is the <a href="lipid_membrane" title="wikilink">lipid membrane</a>, which is treated as a static dielectric region inaccessible to ions. In fact the only non-static particles in the system are ions. Their motion is assumed classical, interacting with other ions through electrostatic interactions and pairwise <a href="Lennard-Jones_potential" title="wikilink">Lennard-Jones potential</a>. They also interact with the water background media, which is modeled using a scattering mechanism.</p>

<p>The ensemble of ions in the simulation region, are propagated synchronously in time and 3-D space by integrating the equations of motion using the second-order accurate leap-frog scheme. Ion positions <em>r</em> and forces <em>F</em> are defined at time steps <em>t</em>, and <em>t</em> + <em>dt</em>. The ion velocities are defined at <em>t</em> – <em>dt</em>/2, <em>t</em> + <em>dt</em>/2. The governing finite difference equations of motion are</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>v</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mfrac>
       <mrow>
        <mi>d</mi>
        <mi>t</mi>
       </mrow>
       <mn>2</mn>
      </mfrac>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>v</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mfrac>
        <mrow>
         <mi>d</mi>
         <mi>t</mi>
        </mrow>
        <mn>2</mn>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mover accent="true">
      <mi>F</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>d</ci>
         <ci>t</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>F</ci>
      </apply>
      <ci>t</ci>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{v}(t+\frac{dt}{2})=\vec{v}(t-\frac{dt}{2})+\vec{F}(t)\,dt
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mrow>
        <mi>d</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mover accent="true">
      <mi>v</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mfrac>
        <mrow>
         <mi>d</mi>
         <mi>t</mi>
        </mrow>
        <mn>2</mn>
       </mfrac>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>d</ci>
         <ci>t</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}(t+dt)=\vec{r}(t-dt)+\vec{v}(t+\frac{dt}{2})\,dt
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>F</em> is the sum of electrostatic and pairwise ion-ion interaction forces.</p>
<h3 id="electrostatic-field-solution">Electrostatic field solution</h3>

<p>The <a href="electrostatic_potential" title="wikilink">electrostatic potential</a> is computed at regular time intervals by solving the <a href="Poisson’s_equation" title="wikilink">Poisson’s equation</a></p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ε</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>∇</mo>
       <mi>ϕ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>ρ</mi>
        <mtext>ions</mtext>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>r</mi>
        <mo>,</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>ρ</mi>
        <mtext>perm</mtext>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>r</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-∇</ci>
     <apply>
      <times></times>
      <ci>ε</ci>
      <ci>r</ci>
      <apply>
       <ci>normal-∇</ci>
       <ci>ϕ</ci>
      </apply>
      <interval closure="open">
       <ci>r</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <mtext>ions</mtext>
       </apply>
       <interval closure="open">
        <ci>r</ci>
        <ci>t</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ρ</ci>
        <mtext>perm</mtext>
       </apply>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla(\varepsilon(r)\nabla\phi(r,t))=-(\rho_{\text{ions}}(r,t)+\rho_{\text{%
perm}}(r))
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Biology_Monte_Carlo_method:3">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mtext>ions</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <mtext>ions</mtext>
    </apply>
    <interval closure="open">
     <ci>r</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\text{ions}}(r,t)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Biology_Monte_Carlo_method:4">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mtext>perm</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <mtext>perm</mtext>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{\text{perm}}(r)
  </annotation>
 </semantics>
</math>

 are the charge density of ions and permanent charges on the protein, respectively. 

<math display="inline" id="Biology_Monte_Carlo_method:5">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϵ</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon(r)
  </annotation>
 </semantics>
</math>

 is the local <a href="dielectric_constant" title="wikilink">dielectric constant</a> or <a class="uri" href="permittivity" title="wikilink">permittivity</a>, and 

<math display="inline" id="Biology_Monte_Carlo_method:6">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <interval closure="open">
     <ci>r</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(r,t)
  </annotation>
 </semantics>
</math>

 is the local electrostatic potential. Solving this equation provides a self-consistent way to include applied bias and the effects of image charges induced at dielectric boundaries.</p>

<p>The ion and partial charges on protein residues are assigned to a finite rectangular grid using the cloud-in-cell (CIC) scheme.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Solving the Poisson equation on the grid counts for the particlemesh component of the P<sup>3</sup>M scheme. However, this discretization leads to an unavoidable truncation of the short-range component of electrostatic force, which can be corrected by computing the short-range charge-charge <a href="Coulomb's_law" title="wikilink">Coulombic interactions</a>.</p>
<h3 id="dielectric-coefficient">Dielectric coefficient</h3>

<p>Assigning the appropriate values for dielectric permittivity of the protein, membrane, and aqueous regions is of great importance. The dielectric coefficient determines the strength of the interactions between charged particles and also the <a href="dielectric" title="wikilink">dielectric boundary forces</a> (DBF) on ions approaching a boundary between two regions of different permittivity. However, in nano scales the task of assigning specific permittivity is problematic and not straightforward.</p>

<p>The protein or membrane environment could respond to an external field in a number of different ways.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Field induced dipoles, reorientation of permanent dipoles, protonation and deprotonation of protein residues, larger scale reorganization of ionized side-chains and water <a class="uri" href="molecules" title="wikilink">molecules</a>, both within the interior and on the surface of the protein, are all examples of how complicated the assignment of permittivity is. In MD simulations, where all the charges, <a class="uri" href="dipoles" title="wikilink">dipoles</a>, and field induced atomic dipoles are treated explicitly then it is suggested that a dielectric value of 1 is appropriate. However, in reduced-particle ion simulation programs, such as ours, where the protein, membrane, and water are continuum backgrounds and treated implicitly, and on top of that, the ion motion takes place on the same time-scale as the protein’s response to its presence, it is very difficult to assign the dielectric coefficients. In fact, changing the dielectric coefficients could easily alter the channel characteristics, such as ion permeation and selectivity The assignment of dielectric coefficient for water is another key issue. The water molecules inside ion channels could be very ordered due to tapered size of the pore, which is often lined with highly charged residues, or hydrogen bond formation between water molecules and protein.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> As a result, the dielectric constant of water inside an ion channel could be quite different from the value under bulk conditions. To make the matter even more complicated, the dielectric coefficients of water inside <a href="nanopore" title="wikilink">nanopores</a> is not necessarily an isotropic scalar value, but an <a class="uri" href="anisotropic" title="wikilink">anisotropic</a> tensor having different values in different directions.</p>
<h3 id="anisotropic-permittivity">Anisotropic permittivity</h3>

<p>It has become evident that the <a class="uri" href="macroscopic" title="wikilink">macroscopic</a> properties of a system do not necessarily extend to the molecular length scales. In a recent research study carried by Reza Toghraee, R. Jay Mashl, and Eric Jakobsson at the University of Illinois, Urbana-Champaign,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> they used Molecular Dynamics simulations to study the properties of water in featureless hydrophobic cylinders with diameters ranging from 1 to 12 nm. This study showed that water undergoes distinct transitions in structure, dielectric properties, and <a href="Electrical_mobility" title="wikilink">mobility</a> as the tube diameter is varied. In particular they found that the dielectric properties in the range of 1 to 10 nm is quite different from bulk water and is in fact anisotropic in nature. Though, such featureless <a class="uri" href="hydrophobic" title="wikilink">hydrophobic</a> channels do not represent actual ion channels and more research has to be done in this area before one could use such data for ion channels, it is evident that water properties like <a class="uri" href="permittivity" title="wikilink">permittivity</a> inside an ion channel or nano-pore could be much more complicated that it has been thought before. While a high axial dielectric constant shields ion’s electrostatic charges in the axial direction (along the channel), low radial dielectric constant increases the interaction between the mobile ion and the partial charges, or the dielectric charge images on the channel, conveying stronger selectivity in ion channels.</p>

<p>Solving the <a href="Poisson_equation" title="wikilink">Poisson equation</a> based on an anisotropic permittivity has been incorporated into BioMOCA using the box integration discretization method,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> which has been briefly described below.</p>
<h2 id="calculations">Calculations</h2>
<h3 id="box-integration-discretization">Box integration discretization</h3>

<p>In order to use box integration for discretizing a D-dimensional Poisson equation</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ε</mi>
      <mrow>
       <mo>∇</mo>
       <mi>φ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>ρ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-∇</ci>
     <apply>
      <times></times>
      <ci>ε</ci>
      <apply>
       <ci>normal-∇</ci>
       <ci>φ</ci>
      </apply>
     </apply>
    </apply>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla(\varepsilon\nabla\varphi)=\rho
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Biology_Monte_Carlo_method:8">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 being a diagonal <em>D</em> × <em>D</em> tensor, this differential equation is reformulated as an integral equation. Integration the above equation over a D-dimensional region 

<math display="inline" id="Biology_Monte_Carlo_method:9">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

, and using Gauss theorem, then the integral formulation is obtained</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∮</mo>
     <mrow>
      <mo>∂</mo>
      <mi mathvariant="normal">Ω</mi>
     </mrow>
    </msub>
    <mrow>
     <mover accent="true">
      <mi>n</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ε</mi>
       <mrow>
        <mo>∇</mo>
        <mi>φ</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mi>ρ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">contour-integral</csymbol>
      <apply>
       <partialdiff></partialdiff>
       <ci>normal-Ω</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ε</ci>
       <apply>
        <ci>normal-∇</ci>
        <ci>φ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <ci>ρ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oint_{\partial\Omega}\hat{n}(\varepsilon\nabla\varphi)=-\int_{\Omega}\rho
  </annotation>
 </semantics>
</math>

</p>

<p>In this appendix it is assumed to be a two-dimensional case. Upgrading to a three-dimensional system would be straightforward and legitimate as the Gauss theorem is also valid for the one and three dimensions. 

<math display="inline" id="Biology_Monte_Carlo_method:11">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 is assumed to be given on the rectangular regions between nodes, while 

<math display="inline" id="Biology_Monte_Carlo_method:12">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is defined on the grid nodes (as illustrated on figure at the right).</p>
<figure><b>(Figure)</b>
<figcaption>Box integration for a two-dimensional tensor product grid. The integration region is indicated by the dashed rectangle. Charges are assumed to be given on the same nodes as potential</figcaption>
</figure>

<p>The integration regions 

<math display="inline" id="Biology_Monte_Carlo_method:13">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>


 are then chosen as rectangles centered around node and extending to the 4 nearest neighbor nodes. The gradient 

<math display="inline" id="Biology_Monte_Carlo_method:14">
 <semantics>
  <mrow>
   <mo>∇</mo>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-∇</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla\varphi
  </annotation>
 </semantics>
</math>

 is then approximated using centered difference normal to the boundary of the integration region 

<math display="inline" id="Biology_Monte_Carlo_method:15">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

, and average 

<math display="inline" id="Biology_Monte_Carlo_method:16">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 over the integration surface 

<math display="inline" id="Biology_Monte_Carlo_method:17">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial\Omega
  </annotation>
 </semantics>
</math>

 . This approach allows us to approximate the left hand side of the Poisson equation above in first order as</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∮</mo>
     <mrow>
      <mo>∂</mo>
      <mi mathvariant="normal">Ω</mi>
     </mrow>
    </msub>
    <mrow>
     <mover accent="true">
      <mi>n</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ε</mi>
       <mrow>
        <mo>∇</mo>
        <mi>φ</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>φ</mi>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>φ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
     <msubsup>
      <mi>h</mi>
      <mi>i</mi>
      <mi>x</mi>
     </msubsup>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mfrac>
        <msubsup>
         <mi>h</mi>
         <mi>j</mi>
         <mi>y</mi>
        </msubsup>
        <mn>2</mn>
       </mfrac>
       <msubsup>
        <mi>ϵ</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
        <mi>x</mi>
       </msubsup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <msubsup>
         <mi>h</mi>
         <mrow>
          <mi>j</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mi>y</mi>
        </msubsup>
        <mn>2</mn>
       </mfrac>
       <msubsup>
        <mi>ε</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
        <mi>x</mi>
       </msubsup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">contour-integral</csymbol>
      <apply>
       <partialdiff></partialdiff>
       <ci>normal-Ω</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ε</ci>
       <apply>
        <ci>normal-∇</ci>
        <ci>φ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <list>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>j</ci>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>h</ci>
          <ci>y</ci>
         </apply>
         <ci>j</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ϵ</ci>
         <ci>x</ci>
        </apply>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>h</ci>
          <ci>y</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ε</ci>
         <ci>x</ci>
        </apply>
        <list>
         <ci>i</ci>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oint_{\partial\Omega}\hat{n}(\varepsilon\nabla\varphi)=\frac{\varphi_{i+1,j}-%
\varphi_{i,j}}{h_{i}^{x}}\left(\frac{h^{y}_{j}}{2}\epsilon^{x}_{i,j}+\frac{h^{%
y}_{j-1}}{2}\varepsilon^{x}_{i,j-1}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:19">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>φ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>φ</mi>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
     <msubsup>
      <mi>h</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mi>x</mi>
     </msubsup>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mfrac>
        <msubsup>
         <mi>h</mi>
         <mi>j</mi>
         <mi>y</mi>
        </msubsup>
        <mn>2</mn>
       </mfrac>
       <msubsup>
        <mi>ϵ</mi>
        <mrow>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
        <mi>x</mi>
       </msubsup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <msubsup>
         <mi>h</mi>
         <mrow>
          <mi>j</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mi>y</mi>
        </msubsup>
        <mn>2</mn>
       </mfrac>
       <msubsup>
        <mi>ε</mi>
        <mrow>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
        <mi>x</mi>
       </msubsup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <list>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>j</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>h</ci>
          <ci>y</ci>
         </apply>
         <ci>j</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ϵ</ci>
         <ci>x</ci>
        </apply>
        <list>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>j</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>h</ci>
          <ci>y</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ε</ci>
         <ci>x</ci>
        </apply>
        <list>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}-\frac{\varphi_{i,j}-\varphi_{i-1,j}}{h_{i-1}^{x}}\left(\frac{h^{y}_{j}}{2}%
\epsilon^{x}_{i-1,j}+\frac{h^{y}_{j-1}}{2}\varepsilon^{x}_{i-1,j-1}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:20">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>φ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>φ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
     <msubsup>
      <mi>h</mi>
      <mi>j</mi>
      <mi>y</mi>
     </msubsup>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mfrac>
        <msubsup>
         <mi>h</mi>
         <mi>i</mi>
         <mi>x</mi>
        </msubsup>
        <mn>2</mn>
       </mfrac>
       <msubsup>
        <mi>ε</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
        <mi>y</mi>
       </msubsup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <msubsup>
         <mi>h</mi>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mi>x</mi>
        </msubsup>
        <mn>2</mn>
       </mfrac>
       <msubsup>
        <mi>ε</mi>
        <mrow>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
        <mi>y</mi>
       </msubsup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <list>
         <ci>i</ci>
         <apply>
          <plus></plus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>j</ci>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>h</ci>
          <ci>x</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ε</ci>
         <ci>y</ci>
        </apply>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>h</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ε</ci>
         <ci>y</ci>
        </apply>
        <list>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>j</ci>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}+\frac{\varphi_{i,j+1}-\varphi_{i,j}}{h_{j}^{y}}\left(\frac{h^{x}_{i}}{2}%
\varepsilon^{y}_{i,j}+\frac{h^{x}_{i-1}}{2}\varepsilon^{y}_{i-1,j}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:21">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>φ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>φ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mrow>
         <mi>j</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
      </msub>
     </mrow>
     <msubsup>
      <mi>h</mi>
      <mrow>
       <mi>j</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mi>y</mi>
     </msubsup>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mfrac>
        <msubsup>
         <mi>h</mi>
         <mi>i</mi>
         <mi>x</mi>
        </msubsup>
        <mn>2</mn>
       </mfrac>
       <msubsup>
        <mi>ε</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
        <mi>y</mi>
       </msubsup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <msubsup>
         <mi>h</mi>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mi>x</mi>
        </msubsup>
        <mn>2</mn>
       </mfrac>
       <msubsup>
        <mi>ε</mi>
        <mrow>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mrow>
        <mi>y</mi>
       </msubsup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <list>
         <ci>i</ci>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>h</ci>
          <ci>x</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ε</ci>
         <ci>y</ci>
        </apply>
        <list>
         <ci>i</ci>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>h</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ε</ci>
         <ci>y</ci>
        </apply>
        <list>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}-\frac{\varphi_{i,j}-\varphi_{i,j-1}}{h_{j-1}^{y}}\left(\frac{h^{x}_{i}}{2}%
\varepsilon^{y}_{i,j-1}+\frac{h^{x}_{i-1}}{2}\varepsilon^{y}_{i-1,j-1}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Biology_Monte_Carlo_method:22">
 <semantics>
  <msup>
   <mi>ε</mi>
   <mi>x</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ε</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon^{x}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Biology_Monte_Carlo_method:23">
 <semantics>
  <msup>
   <mi>ε</mi>
   <mi>y</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ε</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon^{y}
  </annotation>
 </semantics>
</math>

 are the two components of the diagonal of the tensor 

<math display="inline" id="Biology_Monte_Carlo_method:24">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

. Discretizing the right-hand side of the Poisson equation is fairly simple. 

<math display="inline" id="Biology_Monte_Carlo_method:25">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 is discretized on the same grid nodes, as it's been done for 

<math display="inline" id="Biology_Monte_Carlo_method:26">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mi>i</mi>
     </msub>
    </msub>
    <mi>ρ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mtext>Volume</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>ρ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ω</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>ρ</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>Volume</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ρ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Omega_{i}}\rho=\text{Volume}(\Omega_{i})\rho_{i}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="ion-size">Ion size</h3>

<p>The finite size of ions is accounted for in BioMOCA using pairwise <a href="Coulomb's_law" title="wikilink">repulsive forces</a> derived from the 6–12 <a href="Lennard-Jones_potential" title="wikilink">Lennard-Jones potential</a>. A truncated-shifted form of the Lennard-Jones potential is used in the simulator to mimic ionic core repulsion. The modified form of the Lennard-Jones pairwise potential that retains only the repulsive component is given by</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mrow>
      <mi>L</mi>
      <mi>J</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mn>4</mn>
         <msub>
          <mi>ϵ</mi>
          <mrow>
           <mi>L</mi>
           <mi>J</mi>
          </mrow>
         </msub>
         <mrow>
          <mo>(</mo>
          <mrow>
           <msup>
            <mrow>
             <mo>(</mo>
             <mstyle displaystyle="false">
              <mfrac>
               <msub>
                <mi>σ</mi>
                <mrow>
                 <mi>i</mi>
                 <mi>j</mi>
                </mrow>
               </msub>
               <msub>
                <mi>r</mi>
                <mrow>
                 <mi>i</mi>
                 <mi>j</mi>
                </mrow>
               </msub>
              </mfrac>
             </mstyle>
             <mo>)</mo>
            </mrow>
            <mn>12</mn>
           </msup>
           <mo>-</mo>
           <msup>
            <mrow>
             <mo>(</mo>
             <mstyle displaystyle="false">
              <mfrac>
               <msub>
                <mi>σ</mi>
                <mrow>
                 <mi>i</mi>
                 <mi>j</mi>
                </mrow>
               </msub>
               <msub>
                <mi>r</mi>
                <mrow>
                 <mi>i</mi>
                 <mi>j</mi>
                </mrow>
               </msub>
              </mfrac>
             </mstyle>
             <mo>)</mo>
            </mrow>
            <mn>6</mn>
           </msup>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msub>
         <mi>ϵ</mi>
         <mrow>
          <mi>L</mi>
          <mi>J</mi>
         </mrow>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>r</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
        <mo><</mo>
        <mrow>
         <msup>
          <mn>2</mn>
          <mrow>
           <mn>1</mn>
           <mo>/</mo>
           <mn>6</mn>
          </mrow>
         </msup>
         <msub>
          <mi>σ</mi>
          <mrow>
           <mi>i</mi>
           <mi>j</mi>
          </mrow>
         </msub>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>r</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
        <mo>></mo>
        <mrow>
         <msup>
          <mn>2</mn>
          <mrow>
           <mn>1</mn>
           <mo>/</mo>
           <mn>6</mn>
          </mrow>
         </msup>
         <msub>
          <mi>σ</mi>
          <mrow>
           <mi>i</mi>
           <mi>j</mi>
          </mrow>
         </msub>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϵ</ci>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>J</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>σ</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
         </apply>
         <cn type="integer">12</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>σ</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
         </apply>
         <cn type="integer">6</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>J</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">6</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <apply>
      <gt></gt>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">6</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{LJ}(r_{ij})=\begin{cases}4\epsilon_{LJ}\left(\left(\frac{\sigma_{ij}}{r_{ij%
}}\right)^{12}-\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right)+\epsilon_{LJ%
}&r_{ij}<2^{1/6}\sigma_{ij}\\
0&r_{ij}>2^{1/6}\sigma_{ij}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Here, 

<math display="inline" id="Biology_Monte_Carlo_method:29">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mrow>
    <mi>L</mi>
    <mi>J</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{LJ}
  </annotation>
 </semantics>
</math>

 is the Lennard-Jones energy parameter and 

<math display="inline" id="Biology_Monte_Carlo_method:30">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>σ</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>σ</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{ij}=(\sigma_{i}+\sigma_{j})/2
  </annotation>
 </semantics>
</math>

 is the average of the individual Lennard-Jones distance parameters for particles <em>i</em> and <em>j</em>. Using a truncated form of the potential is computationally efficient while preventing the ions from overlapping or coalescing, something that would be clearly unphysical.</p>
<h3 id="ion-protein-interaction">Ion-protein interaction</h3>

<p>Availability of high-resolution X-ray crystallographic measurements of complete <a href="molecular_structures" title="wikilink">molecular structures</a> provides information about the type and location of all atoms that forms the protein. In BioMOCA the protein atoms are modeled as static point charges embedded in a finite volume inaccessible to the ions and associated with a user-defined dielectric coefficient. Moreover, a number of force-field parameters are available that provide information about the charge and radii of atoms in different amino-acid groups. The conjunction of the molecular structure and force fields provide the coordinates, radii, and charge of each atom in the protein channel. BioMOCA uses such information in the standard PQR (Position-Charge-Radius) format to map the protein system onto a rectangular grid.</p>

<p>Ideally, the steric interactions between protein atoms and the ions in the aqueous medium are to use a repulsive potential like <a class="uri" href="Lennard-Jones" title="wikilink">Lennard-Jones</a> to prevent ions from penetrating the protein. As this approach could add a significant load to the amount of calculations, a simpler approach is chosen that treats the protein surfaces as predetermined hard wall boundaries. Many recent open source molecular biology packages have built-in facilities that determine the volume accessible to ions in a protein system. The Adaptive Poisson Boltzmann Solver (APBS) scheme<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> has been incorporated to BioMOCA to obtain the accessible volume region and therefore partition the simulation domain into continuous regions.</p>

<p>Ions are deemed to have access to protein and lipid regions and if any point within the finite-size of ionic sphere crosses the protein or membrane boundary, a collision is assumed and the ion is reflected diffusively.</p>
<h3 id="ion-water-interactions">Ion-water interactions</h3>

<p>As a reduced particle approach, BioMOCA replaces the explicit water molecules with continuum background and handles the ion-water interactions using BTMC method, in which, appropriate scattering rates should be chosen. In other words, ion trajectories are randomly interrupted by scattering events that account for the ions’ <a href="Molecular_diffusion" title="wikilink">diffusive motion</a> in water.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> In between these scattering events, ions follow the Newtonian forces. The free flight times, <em>T<sub>f</sub></em>, are generated statistically from the total scattering rate according to</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:31">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <msub>
      <mi>T</mi>
      <mi>f</mi>
     </msub>
    </msubsup>
    <mrow>
     <mi>λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <mi>p</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <ln></ln>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-→</ci>
        <ci>p</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\ln(r)=\int^{T_{f}}_{0}\lambda(\vec{p}(t))\,dt
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>r</em> is a random number uniformly distributed on the unit interval. 

<math display="inline" id="Biology_Monte_Carlo_method:32">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

, a function of <a class="uri" href="momentum" title="wikilink">momentum</a>, is the total <a class="uri" href="scattering" title="wikilink">scattering</a> rate for all <a class="uri" href="collision" title="wikilink">collision</a> mechanisms. At the end of each free flight, the ion’s velocity is reselected randomly from a Maxwellian distribution. As the correct scattering mechanism for ion-water interactions in nonbulk electrolyte solutions has yet to be developed, a position dependent scattering rate linked to the local diffusivity is used in our model. This dependency on position comes from the fact that water molecules can have different order of organization in different regions, which will affect the <a href="scattering_rate" title="wikilink">scattering rate</a>.</p>
<h3 id="position-dependent-diffusivity">Position-dependent diffusivity</h3>

<p>It is widely accepted that the ions and water molecules do not have the same mobility or diffusivity in confined regions as in bulk.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> In fact, it is more likely to have a lessening in the <a href="electron_mobility" title="wikilink">effective mobility</a> of ions in ion channels.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> In reduced particle methods where the channel water is assumed as implicit continuum background, a mean ion mobility is needed to reveal how ions could diffuse due to local <a href="electrostatic_forces" title="wikilink">electrostatic forces</a> and random events. In Transport Monte Carlo simulations, the total scattering rate (

<math display="inline" id="Biology_Monte_Carlo_method:33">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

), is assumed to only result from ion-water interactions; it is related to ion diffusivity with the expression</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:34">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>k</mi>
     <mi>T</mi>
    </mrow>
    <mrow>
     <mi>m</mi>
     <mi>D</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=\frac{kT}{mD}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>m</em> is the mass of the ion and <em>D</em> is its diffusion constant. As the equation indicates, reduced diffusivity of ions inside the lumen of the channel renders to increased incidence of scattering events.</p>
<h3 id="hydration-shells">Hydration shells</h3>

<p>In addition to having a diffusive effect on <a href="ion_transport" title="wikilink">ion transport</a>, water molecules also form hydration shells around individual ions due to their polar nature. The hydration shell not only shields the charge on ions from other ions but also modulates the ion radial distribution function causing the formation of peaks and troughs. The average minimum distance between two ions is increased as there is always at least one layer of water molecules present between them, acting as a physical deterrent preventing two ions from getting too close to each other, in a manner that is similar to the short-range repulsive component of the Lennard-Jones potential.</p>

<p>The theory of hydration shells is well developed in the physical chemistry literature however a simple model is required that captures the essential effects with as little computational overhead as possible. For this purpose the same pairwise potential discussed by Im and Roux<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> is implemented to include the effect of hydration shells.</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:35">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mrow>
     <mi>h</mi>
     <mi>y</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <msub>
          <mi>c</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mi>r</mi>
        </mrow>
        <msub>
         <mi>c</mi>
         <mn>2</mn>
        </msub>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mi>c</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mn>3</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>c</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mi>r</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>π</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>4</mn>
     </msub>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <msub>
         <mi>c</mi>
         <mn>1</mn>
        </msub>
        <mi>r</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mn>6</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <exp></exp>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>r</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>c</ci>
      <ci>o</ci>
      <ci>s</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>r</ci>
       </apply>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>r</ci>
       </apply>
       <cn type="integer">6</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{hy}=c_{0}\exp\left(\frac{c_{1}-r}{c_{2}}\right)cos(c_{3}(c_{1}-r)\pi)+c_{4}%
\left(\frac{c_{1}}{r}\right)^{6}
  </annotation>
 </semantics>
</math>

</p>

<p>The coefficients <em>c<sub>i</sub></em> were determined empirically for a 1 M <a class="uri" href="KCl" title="wikilink">KCl</a> solution, using MD simulations to benchmark the ion radial distribution functions against Equilibrium <a href="Monte_Carlo_simulations" title="wikilink">Monte Carlo simulations</a>. The effect of hydration shells was found to be important in simulations at higher salt concentrations where the conductance of many ion channels, porin among them, is observed to saturate as the salt concentration in the electrolyte baths is further increased. Earlier simulations that did not include a model of hydration shells did not reproduce the conductance saturation behavior. This suggests an additional repulsive potential acting to prevent ion crowding, and hence limiting the concentration of ions and current density in the confined space of the pore even at high bath salt concentration. When the repulsive potential was included moderate channel <a href="Electrical_conductance" title="wikilink">conductance</a> was observed.</p>
<h2 id="conditions-and-methods">Conditions and methods</h2>
<h3 id="boundary-conditions">Boundary conditions</h3>

<p>The electrical and physiological properties of ion channels are experimentally measured by inserting the channel into a lipid membrane separating two baths containing solutions of specific concentrations. A constant electrostatic bias is applied across the channel by immersing the electrodes in the two baths. Formulating <a href="boundary_conditions" title="wikilink">boundary conditions</a> that accurately represent these contact regions may require enormously large bath regions and is a challenging task. Beyond a Debye length from the membrane the electrostatic potential and ion densities do not vary appreciably. This assumption has been supported by the results of continuum results presented earlier.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> For typical salt concentrations used in ion channel simulations, the <a href="Debye_length" title="wikilink">Debye length</a> is of the order of 10 Å. Using the assumption, <a href="Dirichlet_boundary_conditions" title="wikilink">Dirichlet boundary conditions</a> are imposed on the potential at the two domain boundary planes that are transverse to the channel, taking care that these planes are sufficiently far from the membrane.</p>

<p>The other problem in duplicating the experimental conditions is the problem of maintaining fixed charge density in the two baths. This problem is treated by maintaining the specified density in two buffer regions extending from the boundary plane toward the membrane. The number of ions needed to maintain the density in the two buffer regions is calculated at the start of the simulations. The count of the ions in these buffers is sampled throughout the simulation and an ion is injected whenever a deficit is observed. The initial velocity of the injected particle is decided according to Maxwellian distribution. It should be noted that the ions can leave the system only by exiting through the two Dirichlet boundary planes and an ion is not removed artificially from these buffer regions. The reflections from the <a href="Neumann_boundary_condition" title="wikilink">Neumann boundary planes</a> are treated as <a href="Reflection_seismology" title="wikilink">elastic reflections</a>.</p>
<h3 id="multi-grids-and-grid-focusing-method">Multi-grids and grid focusing method</h3>

<p>In all most any of the methods in simulation of ion channels, the major computational cost comes from the calculation of electrostatic forces acting on the ions. In continuum models, for instance, where <a href="Charge_density" title="wikilink">ionic density</a> exist rather than explicit ions, the electrostatic potential is calculated in a self-consistent manner by solving the Poisson equation. In MD simulations, on the other hand, the <a href="electrostatic_forces" title="wikilink">electrostatic forces</a> acting on the particles are calculated by explicit evaluation of the Coulombic force term, often splitting the short-range and long-range electrostatic forces so they could be computed with different methods. In our model as a reduced particle method, the longrange electrostatic forces are evaluated by solving the <a href="Poisson_equation" title="wikilink">Poisson equation</a> and augmenting the forces so obtained with a short-range component. By solving the Poisson equation it is possible to self-consistently include the forces arising from the bias to the system, while this is a difficult issue to be addressed in MD simulations.</p>

<p>Currently there are two Poisson solvers implemented in BioMOCA based on the <a href="finite_difference_method" title="wikilink">finite difference method</a>. One uses the pre-conditioned <a href="conjugate_gradient_method" title="wikilink">Conjugate Gradient scheme</a> (pCG) and is used by default. The later is borrowed from an APBS solver, which uses a V-multi-grid scheme. Other than the numerical approach to solve the Poisson equation, the main difference between the two solvers is on how they address the <a class="uri" href="permittivity" title="wikilink">permittivity</a> in the system. In the first solver, a dielectric value is assigned to each cell in the grid, while in the APBS solver the dielectric coefficients are defined on the grid nodes. As discussed earlier box integration method is used in the pCG solver, which allows us to treat the Poisson equation in the most accurate way. Even though a full multigrid solver based on box-integration method has been under development, there is a neat way to reuse the already exiting code and treat the ion channel systems.</p>

<p>Ion channel simulations require the presence of large bath regions for accurate treatment of screening.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> There being of such bath regions make the mesh domain of Poisson equation large and leads to either a large number of grid points with fine mesh resolution or a small number of grid points with very coarse discretization. From bulk simulations a coarse mesh is sufficient for describing the baths using the P<sup>3</sup>M scheme. However, a fine resolution is required in the channel domain because of the highly charged nature of these regions and the presence of spatially varying dielectric regions. Besides the ultimate interest is to study the channel behavior in terms of ion <a href="Semipermeable_membrane" title="wikilink">permeability</a>, selectivity, gating, density, etc.… In other words, it is better off to put more computational resources in the channel region, and bare minimum in the baths to reduce the overall computational cost and speed up our simulations from weeks to perhaps days instead. A scheme based on the grid focusing method has been developed that makes it possible to satisfy the requirement of large bath region and a fine grid resolution in channel at the same time in a computationally effective way. This methodology also allows us to have multiple fine mesh domains, which may be needed to describe multiple pore channels like OmpF porin, or an array of ion channels sharing the same bath regions or even having yet finer meshes inside a fine mesh for relatively large channels with narrow ion passages like <a href="Nicotinic_acetylcholine_receptor" title="wikilink">Nicotine receptor channel</a>.<ref boundary_conditions"="" ks'="" name="Hai-Long&gt;Hai-Long Wang, Reza Toghraee, D. Papke, X. L. Cheng, J. A. McCammons, U. Ravaioli, and S. M. Sine, Biophysical Journal, 96, 3582, (2009)&lt;/p&gt;
&lt;p&gt;The first grid is coarse mesh spanning the entire problem domain including the bath regions and the channel region. The second grid (and so on for any other grids, 3rd, 4th, etc.) is a relatively much finer mesh that spans a sub-domain of the system containing the region that requires fine resolution like the channel pore. The Poisson equation is first solved on the coarse mesh with all the Dirichlet and Neumann boundary conditions, taking into account the applied bias. Next the &lt;a href=" title="wikilink">boundary conditions</ref></p></ref></hr></body></html> for the secondary meshes are obtained by interpolating from the first or previous solutions of the Poisson equation. The Poisson equation is solved again for the finer meshes using the new boundary conditions. In this way, electrostatic fields with different mesh discretization for different regions can be generated.
<h3 id="emf-and-dbf">EMF and DBF</h3>

<p>The <a href="Electromotive_force" title="wikilink">electro-motive-force</a> (EMF) is the measurement of the energy needed for a charged particle like ion to cross the ion channel embedded in a membrane. Part of this potential energy barrier is due the interaction between the crossing ion and the permanent/partial charges on the protein residues. The other part comes from the induced dipoles in the protein/membrane dielectric medium, and is referred as dielectric-boundary-force (DBF). To compute the DBF alone, one may turn off all the static charges on the protein residues and drag the ion through the pore and compute the energy barrier using</p>

<p>

<math display="block" id="Biology_Monte_Carlo_method:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mrow>
      <mi>D</mi>
      <mi>B</mi>
      <mi>F</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mo>-</mo>
     <mrow>
      <mi>d</mi>
      <mover accent="true">
       <mi>z</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mover accent="true">
    <mi>E</mi>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>B</ci>
       <ci>F</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <int></int>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{DBF}=\int-d\hat{z}.\vec{E}
  </annotation>
 </semantics>
</math>

</p>

<p>It is important to note that EMF or DBF measurements are just qualitative measurements, as an ion does not necessarily cross the channel through the center of its lumen in a straight line and it is often accompanied by other ions moving in the same or opposite directions, which dramatically changes the dynamics of the system. Moreover, unlike steered MD calculations where the protein residues dynamically reposition themselves as an ion or ions are bouncing across the channel, in our EMF or DBF calculations protein is modeled as a static continuum, which further affects the energy calculations in a more quantitative way. Another issue that additionally impacts the measurements is absence of water hydration molecules, which move with the ion and shield part of its charge. Having said all of above, still computing EMF or DBF is valuable to address channel selectivity or gating. Computing either of these two energy barriers is available as an option in BioMOCA.</p>
<h3 id="visualization-using-vmd">Visualization using VMD</h3>

<p> <a href="Visual_Molecular_Dynamics" title="wikilink">VMD</a><ref gramicidin"="" name="&gt;http://www.ks.uiuc.edu/Research/vmd was equipped with the option of loading BioMOCA structures. This is a very useful feature as one could load both the protein structure (i.e. PDB or PQR file) along with the structures generated by BioMOCA to make comparisons. Figure at the right shows how BioMOCA has generated a structure for &lt;a href=" title="wikilink">Gramicidin channel</ref></p> with a membrane wrapped around it. Furthermore, BioMOCA also dumps the ion trajectories in standard formats so they could be later loaded to molecular visualization tools such as VMD and watched frame by frame in a movie format.
<h3 id="recording-trajectories-in-binary">Recording trajectories in binary</h3>

<p>Other than counting the number of ions crossing the channel, sometimes it is desirable to study their behavior at different regions of the channel. Such examples would be the average occupancy of ions or their average moving velocity inside the channel or a nanopore. BioMOCA has been equipped with the option of dumping every ions position, average and instantaneous velocities, <a href="potential_energy" title="wikilink">potential</a> and <a href="kinetic_energy" title="wikilink">kinetic energies</a>, average and instantaneous displacements and other info at every step (or few steps) of the simulations in ASCII format, so such trajectory information could be studied later on to gather further statistics. From a technical point of view however, dumping such information for tens of ions, even at every few hundreds of time steps, could slow down the simulations and end up with huge files accumulating to tens of gigabytes. Loading such files later on from disk storage is also a very time consuming and computationally inefficient procedure. Over and above that, recoding the numerical information in <a class="uri" href="ASCII" title="wikilink">ASCII</a> format does not hold its machine precision and has loss of accuracy.</p>

<p>Solving such problems is actually an easy task and it is simply to avoid using <a class="uri" href="ASCII" title="wikilink">ASCII</a> format and use binary format instead. Not only it preserves the machine accuracy but also writing and reading to file system is a lot faster. The computational overhead to dump the trajectories becomes negligible and the trajectory files become about two orders of magnitude smaller in size. The downside might be that programming and decoding the data could become very tricky, but once it’s done correctly and with care, the advantages of using binary format are well worth the extra effort. BioMOCA is now equipped with the tools to record the trajectory information in <a href="binary_format" title="wikilink">binary format</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a></li>
<li><a class="uri" href="Biology" title="wikilink">Biology</a></li>
<li><a href="Computational_biology" title="wikilink">Computational biology</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:University_of_Illinois_at_Urbana–Champaign" title="wikilink">Category:University of Illinois at Urbana–Champaign</a> <a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a> <a href="Category:Statistical_mechanics" title="wikilink">Category:Statistical mechanics</a> <a href="Category:Computational_physics" title="wikilink">Category:Computational physics</a> <a href="Category:Probabilistic_complexity_theory" title="wikilink">Category:Probabilistic complexity theory</a> <a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">C. Jacoboni, P. Lugli, The Monte Carlo Method for Semiconductor Device Simulation, Springer Verlag, New York (1989)<a href="#fnref1">↩</a></li>
<li id="fn2">R. Hockney, J. Eastwood, Computer Simulation Using Particles, McGraw-Hill, New York (1981)<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6">A. Warshel, S.T. Russell, Q. Rev. Biol., 17, 283 (1984)<a href="#fnref6">↩</a></li>
<li id="fn7">C.N. Schutz, A. Warshel, Proteins, 44, 400 (2001)<a href="#fnref7">↩</a></li>
<li id="fn8">A. Warshel, A. Papazyan, Curr Opin Struct Biol., 8, 211 (1998)<a href="#fnref8">↩</a></li>
<li id="fn9">B. Roux, T. Allen, S. Berneche, W. Im, Q. Rev. Biophys., 37, 15 (2004)<a href="#fnref9">↩</a></li>
<li id="fn10">Reza Toghraee, J. R. Mashl, K.I. Lee, E. Jakobsson, U. Ravaioli, J. of Computational Electronics, 8, 98, (2009)<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="Siegfried_Selberherr" title="wikilink">S. Selberherr</a>, Analysis and Simulation of Semiconductor Devices, New York, Springer-Verlag Wien, (1984). ISBN 3-211-81800-6<a href="#fnref11">↩</a></li>
<li id="fn12">N.A. Baker, D. Sept, M.J. Holst, J.A. McCammon, IBM J. Res. Develop., 45, 427 (2001)<a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17">W. Im, B. Roux, J. Mol. Biol., 322, 851 (2002)<a href="#fnref17">↩</a></li>
<li id="fn18">T. A. van der Straaten, J. M. Tang, U. Ravaioli, R. S. Eisenberg and N. Aluru, J. Comp. Elect. 2, 29 (2003)<a href="#fnref18">↩</a></li>
<li id="fn19"></li>
</ol>
</section>


