<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="398">Repetition code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Repetition code</h1>
<hr/>

<p>In <a href="coding_theory" title="wikilink">coding theory</a>, the <strong>repetition code</strong> is one of the most basic <a href="error-correcting_code" title="wikilink">error-correcting codes</a>. In order to transmit a message over a noisy channel that may corrupt the transmission in a few places, the idea of the repetition code is to just repeat the message several times. The hope is that the channel corrupts only a minority of these repetitions. This way the receiver will notice that a transmission error occurred since the received data stream is not the repetition of a single message, and moreover, the receiver can recover the original message by looking at the received message in the data stream that occurs most often.</p>

<p>The repetition code is generally a very naive method of encoding data across a channel, and it is not preferred for <em>Additive White Gaussian Noise Channels</em> (<a class="uri" href="AWGN" title="wikilink">AWGN</a>), due to its worse-than-the-present error performance. Repetition codes generally offer a poor compromise between data rate and bit error rate, and other forms of <a href="error_correcting_codes" title="wikilink">error correcting codes</a> can provide superior performance in these areas. The chief attraction of the repetition code is the ease of implementation.</p>

<p>There are two parts to the repetition code, as for any other code: the encoder and decoder, which will be described in detail.</p>
<h2 id="repetition-coder">Repetition Coder</h2>

<p>The encoder is a simple device that repeats, 

<math display="inline" id="Repetition_code:0">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 times, a particular bit to the waveform modulator when the bit is received from the source stream.</p>

<p>For example, if we have a 

<math display="inline" id="Repetition_code:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">3</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (3,1)
  </annotation>
 </semantics>
</math>

 repetition code, then encoding the signal 

<math display="inline" id="Repetition_code:2">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>101001</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">101001</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=101001
  </annotation>
 </semantics>
</math>

 yields a code 

<math display="inline" id="Repetition_code:3">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mn>111000111000000111</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <cn type="integer">111000111000000111</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=111000111000000111
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="repetition-decoder">Repetition Decoder</h2>

<p>Repetition decoding is usually done using <a href="Majority_logic_decoding" title="wikilink">Majority logic detection</a>. To determine the value of a particular bit, we look at the received copies of the bit in the stream and choose the value that occurs more frequently.</p>

<p>For example, suppose we have a 

<math display="inline" id="Repetition_code:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">3</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (3,1)
  </annotation>
 </semantics>
</math>

 repetition code and we are decoding the signal 

<math display="inline" id="Repetition_code:5">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mn>110001111</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <cn type="integer">110001111</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=110001111
  </annotation>
 </semantics>
</math>

. The decoded message is 

<math display="inline" id="Repetition_code:6">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>101</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">101</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=101
  </annotation>
 </semantics>
</math>

, as we have most occurrence of 1's (two to one), 0's (two to one), and 1's (three to zero) in the first, second, and third code sequences, respectively.</p>

<p>This approach discards any 'soft' probability information obtained when decoding each received bit, and the performance of the code can be improved by retaining this probability information and using it to derive a joint probability across all n bits of the actual information bit value.</p>
<h2 id="repetition-codes-on-fading-channel">Repetition Codes on Fading Channel</h2>
<figure><b>(Figure)</b>
<figcaption>Repetition Code On Fading Channel Graph.jpg</figcaption>
</figure>

<p>For fading channels repetition codes perform well with increasing repetition factor. In this figure, the coding gains for various repetition factors are seen.</p>
<h2 id="repetition-codes-on-gaussian-channel">Repetition Codes on Gaussian Channel</h2>
<figure><b>(Figure)</b>
<figcaption>Repetition Code On AWGN Channel Graph.jpg</figcaption>
</figure>

<p>For the <a class="uri" href="AWGN" title="wikilink">AWGN</a> channels perform worse for longer repetition factors. In this figure, the coding gains are progressively worse with the increasing parameter.</p>
<h2 id="code-parameters">Code parameters</h2>

<p>The minimum <a href="Hamming_distance" title="wikilink">Hamming distance</a> (

<math display="inline" id="Repetition_code:7">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{min}
  </annotation>
 </semantics>
</math>

) is 

<math display="inline" id="Repetition_code:8">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 for an 

<math display="inline" id="Repetition_code:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>r</mi>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>r</ci>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r,1)
  </annotation>
 </semantics>
</math>

 repetition code, and there are two valid code words - all ones and all zeros, so the <a href="minimum_weight" title="wikilink">minimum weight</a> (

<math display="inline" id="Repetition_code:10">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{min}
  </annotation>
 </semantics>
</math>

) is r. This gives the repetition code an error correcting capacity of 

<math display="inline" id="Repetition_code:11">
 <semantics>
  <mfrac>
   <mi>r</mi>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{r}{2}
  </annotation>
 </semantics>
</math>

 (i.e. it will correct up to 

<math display="inline" id="Repetition_code:12">
 <semantics>
  <mfrac>
   <mi>r</mi>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{r}{2}
  </annotation>
 </semantics>
</math>

 errors in any code word).</p>
<h2 id="applications">Applications</h2>

<p>Due to the simplicity of the channel encoding and decoding for repetition codes, they find applications in fading channels and non-AWGN environments. Repetition codes can be viewed as a method of space-<a href="time_diversity" title="wikilink">time diversity</a> as well.</p>

<p>Most modulation techniques transmit a bit or chip over many cycles of a sinusoid carrier signal. The <a href="low-pass_filter" title="wikilink">low-pass filter</a> used to average the relevant parameter (amplitude, phase, or frequency) over the entire bit-time or chip-time can be seen as a kind of repetition decoder.</p>

<p>Some <a href="UART" title="wikilink">UARTs</a>, such as the ones used in the <a class="uri" href="FlexRay" title="wikilink">FlexRay</a> protocol, use a majority filter to ignore brief noise spikes. This spike-rejection filter can be seen as a kind of repetition decoder.</p>

<p>Despite their poor performance as stand-alone codes, use in <a href="Turbo_code" title="wikilink">Turbo code</a>-like iteratively decoded <a href="concatenated_error_correction_codes" title="wikilink">concatenated coding</a> schemes, such as <a href="repeat-accumulate_code" title="wikilink">repeat-accumulate</a> (RA) and accumulate-repeat-accumulate (ARA) codes, allows for surprisingly good error correction performance.</p>

<p>Repetition codes are one of the few known codes whose <a href="code_rate" title="wikilink">code rate</a> can be automatically adjusted to varying <a href="channel_capacity" title="wikilink">channel capacity</a>, by sending more or less parity information as required to overcome the channel noise, and it is the only such code known for non-<a href="binary_erasure_channel" title="wikilink">erasure channels</a>. Practical adaptive codes for erasure channels have been invented only recently, and are known as <a href="fountain_code" title="wikilink">fountain codes</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="majority_logic_decoding" title="wikilink">majority logic decoding</a></li>
<li><a href="Hamming_code" title="wikilink">Hamming code</a></li>
<li><a href="Convolutional_code" title="wikilink">Convolutional code</a></li>
<li><a href="triple_modular_redundancy" title="wikilink">triple modular redundancy</a></li>
</ul>
<ol>
<li></li>
</ol>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Fault_tolerance" title="wikilink">Category:Fault tolerance</a></p>
</body>
</html>
