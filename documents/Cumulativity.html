<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1872">Cumulativity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cumulativity</h1>
<hr/>

<p>In <a href="semantics" title="wikilink">linguistic semantics</a>, an expression X is said to have <strong>cumulative reference</strong> if and only if the following holds: If X is true of both of <em>a</em> and <em>b</em>, then it is also true of the combination of <em>a</em> and <em>b</em>. Example: If two separate entities can be said to be "water", then combining them into one entity will yield more "water". If two separate entities can be said to be "a house", their combination cannot be said to be "a house". Hence, "water" has cumulative reference, while the expression "a house" does not. The <a href="english_plural" title="wikilink">plural</a> form "houses", however, <em>does</em> have cumulative reference. If two (groups of) entities are both "houses", then their combination will still be "houses".</p>

<p>Cumulativity has proven relevant to the linguistic treatment of the <a href="mass_noun" title="wikilink">mass/count</a> distinction and for the characterization of grammatical <a class="uri" href="telicity" title="wikilink">telicity</a>.</p>

<p>Formally, a cumulativity predicate <em>CUM</em> can be defined as follows, where capital <em>X</em> is a <a href="Variable_(mathematics)" title="wikilink">variable</a> over <a href="set_(mathematics)" title="wikilink">sets</a>, <em>U</em> is the <a href="universe_of_discourse" title="wikilink">universe of discourse</a>, <em>p</em> is a <a href="mereology" title="wikilink">mereological</a> part <a href="mathematical_structure" title="wikilink">structure</a> on <em>U</em>, and 

<math display="inline" id="Cumulativity:0">
<semantics>
<msub>
<mo>⊕</mo>
<mi>p</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \oplus_{p}
  </annotation>
</semantics>
</math>

 is the <a href="mereology" title="wikilink">mereological</a> sum operation.</p>
<center>

<p>
<math display="inline" id="Cumulativity:1">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mo>∀</mo>
<mi>X</mi>
<mo>⊆</mo>
<msub>
<mi>U</mi>
<mi>p</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>C</mi>
<mi>U</mi>
<mi>M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>⇔</mo>
<mo>∃</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mi>x</mi>
<mo>≠</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mo>∀</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>∧</mo>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>⇒</mo>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<msub>
<mo>⊕</mo>
<mi>p</mi>
</msub>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">X</csymbol>
<subset></subset>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>U</ci>
<ci>p</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">C</csymbol>
<csymbol cd="unknown">U</csymbol>
<csymbol cd="unknown">M</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">X</csymbol>
<ci>normal-)</ci>
</cerror>
<csymbol cd="latexml">iff</csymbol>
<exists></exists>
<csymbol cd="unknown">x</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">X</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<and></and>
<csymbol cd="unknown">X</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<and></and>
<csymbol cd="unknown">x</csymbol>
<neq></neq>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<and></and>
<csymbol cd="latexml">for-all</csymbol>
<csymbol cd="unknown">x</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">y</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">X</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<and></and>
<csymbol cd="unknown">X</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-⇒</ci>
<csymbol cd="unknown">X</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>p</ci>
</apply>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\forall X\subseteq U_{p})(CUM(X)\iff\exists x,y(X(x)\wedge X(y)\wedge x\neq y%
)\wedge\forall x,y(X(x)\wedge X(y)\Rightarrow X(x\oplus_{p}y)))
  </annotation>
</semantics>
</math>
</p>
</center>

<p>In later work, Krifka has generalized the notion to <em>n</em>-ary predicates, based on the phenomenon of <em>cumulative quantification</em>. For example, the two following sentences appear to be equivalent:</p>
<dl>
<dd>John ate an apple and Mary ate a pear.
</dd>
<dd>John and Mary ate an apple and a pear.
</dd>
</dl>

<p>This shows that the relation "eat" is cumulative. In general, an <em>n</em>-ary predicate <em>R</em> is <em>cumulative</em> if and only if the following holds:</p>
<center>

<p>
<math display="inline" id="Cumulativity:2">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>∀</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>y</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>R</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∧</mo>
<mrow>
<mi>R</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>y</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mrow>
<mi>R</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>⊕</mo>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo>⊕</mo>
<msub>
<mi>y</mi>
<mi>n</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<vector>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>n</ci>
</apply>
</vector>
<apply>
<and></and>
<apply>
<times></times>
<ci>R</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</vector>
</apply>
<apply>
<times></times>
<ci>R</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>n</ci>
</apply>
</vector>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>R</ci>
<vector>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>n</ci>
</apply>
</apply>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\forall x_{1},\ldots,x_{n},y_{1},\ldots,y_{n})(R(x_{1},\ldots,x_{n})\wedge R(%
y_{1},\ldots,y_{n}))\rightarrow R(x_{1}\oplus y_{1},\ldots,x_{n}\oplus y_{n})
  </annotation>
</semantics>
</math>
</p>
</center>
<h2 id="references">References</h2>

<p><a href="Manfred_Krifka" title="wikilink">Krifka, Manfred</a> (1989). "Nominal reference, temporal constitution and quantification in event semantics". In Renate Bartsch, Johan van Benthem and Peter van Emde Boas (eds.), <em>Semantics and Contextual Expressions</em> 75-115. Dordrecht: <a class="uri" href="Foris" title="wikilink">Foris</a>.</p>

<p>Krifka, Manfred. 1999. "At least some determiners aren’t determiners". In <em>The semantics/pragmatics interface from different points of view</em>, ed. K. Turner, 257–291. North-Holland: <a class="uri" href="Elsevier" title="wikilink">Elsevier</a> Science.</p>

<p>Scha, Remko. 1981. "Distributive, collective, and cumulative quantification". In <em>Formal methods in the study of language</em>, ed. T. Janssen and M. Stokhof, 483–512. Amsterdam: <a href="Mathematical_Centre_Tracts" title="wikilink">Mathematical Centre Tracts</a>.</p>

<p>"</p>

<p><a class="uri" href="Category:Grammar" title="wikilink">Category:Grammar</a> <a class="uri" href="Category:Semantics" title="wikilink">Category:Semantics</a></p>
</body>
</html>
