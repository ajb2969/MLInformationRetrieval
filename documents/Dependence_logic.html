<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="833">Dependence logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dependence logic</h1>
<hr/>

<p><strong>Dependence logic</strong> is a logical formalism, created by Jouko Väänänen,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> which adds <em>dependence atoms</em> to the language of <a href="First_Order_Logic" title="wikilink">first-order logic</a>. A dependence atom is an expression of the form 

<math display="inline" id="Dependence_logic:0">
 <semantics>
  <mrow>
   <mi></mi>
   <mo rspace="0pt">=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\!\!(t_{1}\ldots t_{n})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Dependence_logic:1">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{1}\ldots t_{n}
  </annotation>
 </semantics>
</math>

 are terms, and corresponds to the statement that the value of 

<math display="inline" id="Dependence_logic:2">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{n}
  </annotation>
 </semantics>
</math>

 is <a href="Functional_dependency" title="wikilink">functionally dependent</a> on the values of 

<math display="inline" id="Dependence_logic:3">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{1}\ldots t_{n-1}
  </annotation>
 </semantics>
</math>

.</p>

<p>Dependence logic is a <a href="Logics_of_imperfect_information" title="wikilink">logic of imperfect information</a>, like <a href="Branching_quantifier" title="wikilink"> branching quantifier logic</a> or <a href="independence-friendly_logic" title="wikilink">independence-friendly logic</a>: in other words, its <a href="Game_semantics" title="wikilink">game theoretic semantics</a> can be obtained from that of first-order logic by restricting the availability of information to the players, thus allowing for non-linearly ordered patterns of dependence and independence between variables. However, dependence logic differs from these logics in that it separates the notions of dependence and independence from the notion of quantification.</p>
<h2 id="syntax">Syntax</h2>

<p>The syntax of dependence logic is an extension of that of first-order logic. For a fixed <a href="Signature_(logic)" title="wikilink">signature</a> σ = (<em>S</em><sub>func</sub>, <em>S</em><sub>rel</sub>, ar), the set of all well-formed dependence logic formulas is defined according to the following rules:</p>
<h3 id="terms">Terms</h3>

<p>Terms in dependence logic are defined <a href="First_order_logic#Terms" title="wikilink">precisely as in first-order logic</a>.</p>
<h3 id="atomic-formulas">Atomic formulas</h3>

<p>There are three types of atomic formulas in dependence logic:</p>
<ol>
<li>A <em>relational atom</em> is an expression of the form 

<math display="inline" id="Dependence_logic:4">
 <semantics>
  <mrow>
   <mi>R</mi>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rt_{1}\ldots t_{n}
  </annotation>
 </semantics>
</math>

 for any n-ary relation 

<math display="inline" id="Dependence_logic:5">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!R
  </annotation>
 </semantics>
</math>

 in our signature and for any n-uple of terms 

<math display="inline" id="Dependence_logic:6">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{1}\ldots t_{n}
  </annotation>
 </semantics>
</math>

;</li>
<li>An <em>equality atom</em> is an expression of the form 

<math display="inline" id="Dependence_logic:7">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>t</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{1}=t_{2}
  </annotation>
 </semantics>
</math>

, for any two terms 

<math display="inline" id="Dependence_logic:8">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:9">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{2}
  </annotation>
 </semantics>
</math>

;</li>
<li>A <em>dependence atom</em> is an expression of the form 

<math display="inline" id="Dependence_logic:10">
 <semantics>
  <mrow>
   <mi></mi>
   <mo rspace="0pt">=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\!\!(t_{1}\ldots t_{n})
  </annotation>
 </semantics>
</math>

, for any 

<math display="inline" id="Dependence_logic:11">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

 and for any n-uple of terms 

<math display="inline" id="Dependence_logic:12">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{1}\ldots t_{n}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Nothing else is an atomic formula of dependence logic.</p>

<p>Relational and equality atoms are also called <em>first order atoms</em>.</p>
<h3 id="complex-formulas-and-sentences">Complex formulas and sentences</h3>

<p>For a fixed signature σ, the set of all formulas 

<math display="inline" id="Dependence_logic:13">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 of dependence logic and their respective sets of free variables 

<math display="inline" id="Dependence_logic:14">
 <semantics>
  <mrow>
   <mtext>Free</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Free</mtext>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Free}(\phi)
  </annotation>
 </semantics>
</math>

 are defined as follows:</p>
<ol>
<li>Any atomic formula 

<math display="inline" id="Dependence_logic:15">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 is a formula, and 

<math display="inline" id="Dependence_logic:16">
 <semantics>
  <mrow>
   <mtext>Free</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Free</mtext>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Free}(\phi)
  </annotation>
 </semantics>
</math>

 is the set of all variables occurring in it;</li>
<li>If 

<math display="inline" id="Dependence_logic:17">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 is a formula, so is 

<math display="inline" id="Dependence_logic:18">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:19">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Free</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ϕ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mtext>Free</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Free</mtext>
     <apply>
      <times></times>
      <not></not>
      <ci>ϕ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>Free</mtext>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Free}(\lnot\phi)=\mbox{Free}(\phi)
  </annotation>
 </semantics>
</math>

;</li>
<li>If 

<math display="inline" id="Dependence_logic:20">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:21">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ψ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\psi
  </annotation>
 </semantics>
</math>

 are formulas, so is 

<math display="inline" id="Dependence_logic:22">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>ϕ</mi>
   </mpadded>
   <mo>∨</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi\vee\psi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:23">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Free</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ϕ</mi>
      <mo>∨</mo>
      <mi>ψ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mtext>Free</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ϕ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mtext>Free</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ψ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Free</mtext>
     <apply>
      <or></or>
      <ci>ϕ</ci>
      <ci>ψ</ci>
     </apply>
    </apply>
    <apply>
     <union></union>
     <apply>
      <times></times>
      <mtext>Free</mtext>
      <ci>ϕ</ci>
     </apply>
     <apply>
      <times></times>
      <mtext>Free</mtext>
      <ci>ψ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Free}(\phi\vee\psi)=\mbox{Free}(\phi)\cup\mbox{Free}(\psi)
  </annotation>
 </semantics>
</math>

;</li>
<li>If 

<math display="inline" id="Dependence_logic:24">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 is a formula and 

<math display="inline" id="Dependence_logic:25">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>x</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!x
  </annotation>
 </semantics>
</math>

 is a variable, 

<math display="inline" id="Dependence_logic:26">
 <semantics>
  <mrow>
   <mo lspace="0.8pt">∃</mo>
   <mrow>
    <mi>x</mi>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\exists x\phi
  </annotation>
 </semantics>
</math>

 is also a formula and 

<math display="inline" id="Dependence_logic:27">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Free</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>v</mi>
       <mi>ϕ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mtext>Free</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ϕ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>\</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>v</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Free</mtext>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>ϕ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-\</ci>
     <apply>
      <times></times>
      <mtext>Free</mtext>
      <ci>ϕ</ci>
     </apply>
     <set>
      <ci>v</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Free}(\exists v\phi)=\mbox{Free}(\phi)\backslash\{v\}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Nothing is a dependence logic formula unless it can be obtained through a finite number of applications of these four rules.</p>

<p>A formula 

<math display="inline" id="Dependence_logic:28">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Dependence_logic:29">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Free</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Free</mtext>
     <ci>ϕ</ci>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Free}(\phi)=\emptyset
  </annotation>
 </semantics>
</math>

 is a <em>sentence</em> of dependence logic.</p>
<h4 id="conjunction-and-universal-quantification">Conjunction and universal quantification</h4>

<p>In the above presentation of the syntax of dependence logic, conjunction and universal quantification are not treated as primitive operators; rather, they are defined in terms of disjunction and negation and existential quantification respectively, by means of <a href="De_Morgan's_Laws" title="wikilink">De Morgan's Laws</a>.</p>

<p>Therefore, 

<math display="inline" id="Dependence_logic:30">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>ϕ</mi>
   </mpadded>
   <mo>∧</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi\wedge\psi
  </annotation>
 </semantics>
</math>

 is taken as a shorthand for 

<math display="inline" id="Dependence_logic:31">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi mathvariant="normal">¬</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ϕ</mi>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ψ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <ci>ϕ</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>ψ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\lnot(\lnot\phi\vee\lnot\psi)
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Dependence_logic:32">
 <semantics>
  <mrow>
   <mo lspace="0.8pt">∀</mo>
   <mrow>
    <mi>x</mi>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\forall x\phi
  </annotation>
 </semantics>
</math>

 is taken as a shorthand for 

<math display="inline" id="Dependence_logic:33">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi mathvariant="normal">¬</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>ϕ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>ϕ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\lnot(\exists x(\lnot\phi))
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="semantics">Semantics</h2>

<p>The <em>team semantics</em> for dependence logic is a variant of <a href="Wilfrid_Hodges" title="wikilink">Wilfrid Hodges</a>' compositional semantics for <a href="Independence-friendly_logic" title="wikilink">IF logic</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> There exist equivalent game-theoretic semantics for dependence logic, both in terms of <a href="Extensive_form_game#Imperfect_information" title="wikilink">imperfect information games</a> and in terms of perfect information games.</p>
<h3 id="teams">Teams</h3>

<p>Let 

<math display="inline" id="Dependence_logic:34">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>σ</mi>
    <mo>,</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒜</ci>
    <vector>
     <ci>A</ci>
     <ci>σ</ci>
     <ci>I</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}=(A,\sigma,I)
  </annotation>
 </semantics>
</math>

 be a <a href="Structure_(mathematical_logic)" title="wikilink">first-order structure</a> and let 

<math display="inline" id="Dependence_logic:35">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>v</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <set>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=\{v_{1}\ldots v_{n}\}
  </annotation>
 </semantics>
</math>

 be a finite set of variables. Then a team over 

<math display="inline" id="Dependence_logic:36">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 with domain 

<math display="inline" id="Dependence_logic:37">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!V
  </annotation>
 </semantics>
</math>

 is a set of assignments over 

<math display="inline" id="Dependence_logic:38">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 with domain 

<math display="inline" id="Dependence_logic:39">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!V
  </annotation>
 </semantics>
</math>

, that is, a set of functions 

<math display="inline" id="Dependence_logic:40">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>μ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Dependence_logic:41">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!V
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Dependence_logic:42">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!A
  </annotation>
 </semantics>
</math>

.</p>

<p>It may be helpful to visualize such a team as a <a href="Relation_(database)" title="wikilink">database relation</a> with attributes 

<math display="inline" id="Dependence_logic:43">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1}\ldots v_{n}
  </annotation>
 </semantics>
</math>

 and with only one data type, corresponding to the domain 

<math display="inline" id="Dependence_logic:44">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!A
  </annotation>
 </semantics>
</math>

 of the structure: for example, if the team 

<math display="inline" id="Dependence_logic:45">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

 consists of four assignments 

<math display="inline" id="Dependence_logic:46">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>μ</mi>
    <mn>4</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{1}\ldots\mu_{4}
  </annotation>
 </semantics>
</math>

 with domain 

<math display="inline" id="Dependence_logic:47">
 <semantics>
  <mrow>
   <mo lspace="0.8pt" stretchy="false">{</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>3</mn>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">3</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\{v_{1},v_{2},v_{3}\}
  </annotation>
 </semantics>
</math>

 then one may represent it as the relation</p>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:48">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>v</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!v_{1}
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:49">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>v</mi>
   </mpadded>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!v_{2}
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:50">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>v</mi>
   </mpadded>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!v_{3}
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:51">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>μ</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:52">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{1}(v_{1})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:53">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{1}(v_{2})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:54">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{1}(v_{3})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:55">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>μ</mi>
   </mpadded>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:56">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{2}(v_{1})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:57">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{2}(v_{2})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:58">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{2}(v_{3})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:59">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>μ</mi>
   </mpadded>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{3}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:60">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>3</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{3}(v_{1})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:61">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>3</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{3}(v_{2})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:62">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>3</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{3}(v_{3})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:63">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>μ</mi>
   </mpadded>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{4}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:64">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>4</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{4}(v_{1})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:65">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>4</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{4}(v_{2})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Dependence_logic:66">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>μ</mi>
    </mpadded>
    <mn>4</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu_{4}(v_{3})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<h3 id="positive-and-negative-satisfaction">Positive and negative satisfaction</h3>

<p>Team semantics can be defined in terms of two relations 

<math display="inline" id="Dependence_logic:67">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{T}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:68">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 between structures, teams and formulas.</p>

<p>Given a structure 

<math display="inline" id="Dependence_logic:69">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

, a team 

<math display="inline" id="Dependence_logic:70">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 over it and a dependence logic formula 

<math display="inline" id="Dependence_logic:71">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 whose <a href="Free_variables_and_bound_variables" title="wikilink">free variables</a> are contained in the domain of 

<math display="inline" id="Dependence_logic:72">
 <semantics>
  <mpadded lspace="-3.4pt" width="-3.4pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\!X
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Dependence_logic:73">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="0.8pt" stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>𝒜</ci>
     <ci>X</ci>
     <ci>ϕ</ci>
    </vector>
    <ci>𝒯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!(\mathcal{A},X,\phi)\in\mathcal{T}
  </annotation>
 </semantics>
</math>

 we say that 

<math display="inline" id="Dependence_logic:74">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

 is a <em>trump</em> for 

<math display="inline" id="Dependence_logic:75">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dependence_logic:76">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

, and we write that 

<math display="inline" id="Dependence_logic:77">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}\phi
  </annotation>
 </semantics>
</math>

; and analogously, if 

<math display="inline" id="Dependence_logic:78">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="0.8pt" stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>𝒜</ci>
     <ci>X</ci>
     <ci>ϕ</ci>
    </vector>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!(\mathcal{A},X,\phi)\in\mathcal{C}
  </annotation>
 </semantics>
</math>

 we say that 

<math display="inline" id="Dependence_logic:79">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

 is a <em>cotrump</em> for 

<math display="inline" id="Dependence_logic:80">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dependence_logic:81">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

, and we write that 

<math display="inline" id="Dependence_logic:82">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}\phi
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Dependence_logic:83">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}\phi
  </annotation>
 </semantics>
</math>

 one can also say that 

<math display="inline" id="Dependence_logic:84">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 is <em>positively satisfied</em> by 

<math display="inline" id="Dependence_logic:85">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dependence_logic:86">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

, and if instead 

<math display="inline" id="Dependence_logic:87">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}\phi
  </annotation>
 </semantics>
</math>

 one can say that 

<math display="inline" id="Dependence_logic:88">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 is <em>negatively satisfied</em> by 

<math display="inline" id="Dependence_logic:89">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dependence_logic:90">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

.</p>

<p>The necessity of considering positive and negative satisfaction separately is a consequence of the fact that in dependence logic, as in the logic of <a href="branching_quantifier" title="wikilink">branching quantifiers</a> or in <a href="Independence-friendly_logic" title="wikilink">IF logic</a>, the law of the excluded middle does not hold; alternatively, one may assume that all formulas are in negation normal form, using De Morgan's relations in order to define universal quantification and conjunction from existential quantification and disjunction respectively, and consider positive satisfaction alone.</p>

<p>Given a sentence 

<math display="inline" id="Dependence_logic:91">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

, we say that 

<math display="inline" id="Dependence_logic:92">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 is <em>true</em> in 

<math display="inline" id="Dependence_logic:93">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Dependence_logic:94">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi mathvariant="normal">∅</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>+</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <set>
       <emptyset></emptyset>
      </set>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{\{\emptyset\}}^{+}\phi
  </annotation>
 </semantics>
</math>

, and we say that 

<math display="inline" id="Dependence_logic:95">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 is <em>false</em> in 

<math display="inline" id="Dependence_logic:96">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Dependence_logic:97">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi mathvariant="normal">∅</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>-</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <set>
       <emptyset></emptyset>
      </set>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{\{\emptyset\}}^{-}\phi
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="semantic-rules">Semantic rules</h3>

<p>As for the case of <a href="Alfred_Tarski" title="wikilink">Alfred Tarski</a>'s satisfiability relation for first-order formulas, the positive and negative satisfiability relations of the team semantics for dependence logic are defined by <a href="structural_induction" title="wikilink">structural induction</a> over the formulas of the language. Since the negation operator interchanges positive and negative satisfiability, the two inductions corresponding to 

<math display="inline" id="Dependence_logic:98">
 <semantics>
  <msup>
   <mo lspace="0.8pt">⊧</mo>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <csymbol cd="latexml">models</csymbol>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\models^{+}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:99">
 <semantics>
  <msup>
   <mo lspace="0.8pt">⊧</mo>
   <mo>-</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <csymbol cd="latexml">models</csymbol>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\models^{-}
  </annotation>
 </semantics>
</math>

 need to be performed simultaneously:</p>
<h4 id="positive-satisfiability">Positive satisfiability</h4>
<ol>
<li>

<math display="inline" id="Dependence_logic:100">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <mrow>
    <mi>R</mi>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}Rt_{1}\ldots t_{n}
  </annotation>
 </semantics>
</math>

 if and only if
<ol>
<li>

<math display="inline" id="Dependence_logic:101">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!R
  </annotation>
 </semantics>
</math>

 is a n-ary symbol in the signature of 

<math display="inline" id="Dependence_logic:102">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

;</li>
<li>All variables occurring in the terms 

<math display="inline" id="Dependence_logic:103">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>t</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{1}\ldots t_{n}
  </annotation>
 </semantics>
</math>

 are in the domain of 

<math display="inline" id="Dependence_logic:104">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

;</li>
<li>For every assignment 

<math display="inline" id="Dependence_logic:105">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>μ</mi>
   </mpadded>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>μ</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu\in X
  </annotation>
 </semantics>
</math>

, the evaluation of the tuple 

<math display="inline" id="Dependence_logic:106">
 <semantics>
  <mrow>
   <mo lspace="0.8pt" stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!(t_{1}\ldots t_{n})
  </annotation>
 </semantics>
</math>

 according to 

<math display="inline" id="Dependence_logic:107">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>μ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu
  </annotation>
 </semantics>
</math>

 is in the interpretation of 

<math display="inline" id="Dependence_logic:108">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!R
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dependence_logic:109">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

;</li>
</ol></li>
<li>

<math display="inline" id="Dependence_logic:110">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">models</csymbol>
       <ci>X</ci>
      </apply>
      <plus></plus>
     </apply>
     <ci>𝒜</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}t_{1}=t_{2}
  </annotation>
 </semantics>
</math>

 if and only if
<ol>
<li>All variables occurring in the terms 

<math display="inline" id="Dependence_logic:111">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:112">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{2}
  </annotation>
 </semantics>
</math>

 are in the domain of 

<math display="inline" id="Dependence_logic:113">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

;</li>
<li>For every assignment 

<math display="inline" id="Dependence_logic:114">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>μ</mi>
   </mpadded>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>μ</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu\in X
  </annotation>
 </semantics>
</math>

, the evaluations of 

<math display="inline" id="Dependence_logic:115">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:116">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{2}
  </annotation>
 </semantics>
</math>

 according to 

<math display="inline" id="Dependence_logic:117">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 are the same;</li>
</ol></li>
<li>

<math display="inline" id="Dependence_logic:118">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <mo rspace="0pt">=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <plus></plus>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}=\!\!(t_{1}\ldots t_{n})
  </annotation>
 </semantics>
</math>

 if and only if any two assignments 

<math display="inline" id="Dependence_logic:119">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>s</mi>
    </mpadded>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </list>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!s,s^{\prime}\in X
  </annotation>
 </semantics>
</math>

 whose evaluations of the tuple 

<math display="inline" id="Dependence_logic:120">
 <semantics>
  <mrow>
   <mo lspace="0.8pt" stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!(t_{1}\ldots t_{n-1})
  </annotation>
 </semantics>
</math>

 coincide assign the same value to 

<math display="inline" id="Dependence_logic:121">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{n}
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Dependence_logic:122">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}\lnot\phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Dependence_logic:123">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}\phi
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Dependence_logic:124">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <mrow>
    <mi>ϕ</mi>
    <mo>∨</mo>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <apply>
     <or></or>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}\phi\vee\psi
  </annotation>
 </semantics>
</math>

 if and only if there exist teams 

<math display="inline" id="Dependence_logic:125">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!Y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:126">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>Z</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!Z
  </annotation>
 </semantics>
</math>

 such that
<ol>
<li>

<math display="inline" id="Dependence_logic:127">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mi>Y</mi>
    <mo>∪</mo>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <union></union>
     <ci>Y</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=Y\cup Z
  </annotation>
 </semantics>
</math>

'</li>
<li>

<math display="inline" id="Dependence_logic:128">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>Y</mi>
    <mo>+</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>Y</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{Y}^{+}\phi
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Dependence_logic:129">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>Z</mi>
    <mo>+</mo>
   </msubsup>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>Z</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{Z}^{+}\psi
  </annotation>
 </semantics>
</math>

;</li>
</ol></li>
<li>

<math display="inline" id="Dependence_logic:130">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>x</mi>
     <mi>ϕ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}\exists x\phi
  </annotation>
 </semantics>
</math>

 if and only if there exists a function 

<math display="inline" id="Dependence_logic:131">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>F</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!F
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Dependence_logic:132">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

 to the domain of 

<math display="inline" id="Dependence_logic:133">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Dependence_logic:134">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>F</mi>
       <mo>/</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <divide></divide>
         <ci>F</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X[F/x]}^{+}\phi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Dependence_logic:135">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>X</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>F</mi>
      <mo>/</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <divide></divide>
       <ci>F</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>s</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X[F/x]=\{s[F(s)/x]:s\in X\}
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<h4 id="negative-satisfiability">Negative satisfiability</h4>
<ol>
<li>

<math display="inline" id="Dependence_logic:136">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mrow>
    <mi>R</mi>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}Rt_{1}\ldots t_{n}
  </annotation>
 </semantics>
</math>

 if and only if
<ol>
<li>

<math display="inline" id="Dependence_logic:137">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!R
  </annotation>
 </semantics>
</math>

 is a n-ary symbol in the signature of 

<math display="inline" id="Dependence_logic:138">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

;</li>
<li>All variables occurring in the terms 

<math display="inline" id="Dependence_logic:139">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>t</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{1}\ldots t_{n}
  </annotation>
 </semantics>
</math>

 are in the domain of 

<math display="inline" id="Dependence_logic:140">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

;</li>
<li>For every assignment 

<math display="inline" id="Dependence_logic:141">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>μ</mi>
   </mpadded>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>μ</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu\in X
  </annotation>
 </semantics>
</math>

, the evaluation of the tuple 

<math display="inline" id="Dependence_logic:142">
 <semantics>
  <mrow>
   <mo lspace="0.8pt" stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!(t_{1}\ldots t_{n})
  </annotation>
 </semantics>
</math>

 according to 

<math display="inline" id="Dependence_logic:143">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>μ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu
  </annotation>
 </semantics>
</math>

 is not in the interpretation of 

<math display="inline" id="Dependence_logic:144">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>R</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!R
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dependence_logic:145">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

;</li>
</ol></li>
<li>

<math display="inline" id="Dependence_logic:146">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">models</csymbol>
       <ci>X</ci>
      </apply>
      <minus></minus>
     </apply>
     <ci>𝒜</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}t_{1}=t_{2}
  </annotation>
 </semantics>
</math>

 if and only if
<ol>
<li>All variables occurring in the terms 

<math display="inline" id="Dependence_logic:147">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:148">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{2}
  </annotation>
 </semantics>
</math>

 are in the domain of 

<math display="inline" id="Dependence_logic:149">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

;</li>
<li>For every assignment 

<math display="inline" id="Dependence_logic:150">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>μ</mi>
   </mpadded>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>μ</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu\in X
  </annotation>
 </semantics>
</math>

, the evaluations of 

<math display="inline" id="Dependence_logic:151">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:152">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!t_{2}
  </annotation>
 </semantics>
</math>

 according to 

<math display="inline" id="Dependence_logic:153">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 are different;</li>
</ol></li>
<li>

<math display="inline" id="Dependence_logic:154">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mo rspace="0pt">=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}=\!\!(t_{1}\ldots t_{n})
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Dependence_logic:155">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

 is the empty team;</li>
<li>

<math display="inline" id="Dependence_logic:156">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}\lnot\phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Dependence_logic:157">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}\phi
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Dependence_logic:158">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mrow>
    <mi>ϕ</mi>
    <mo>∨</mo>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <apply>
     <or></or>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}\phi\vee\psi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Dependence_logic:159">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}\phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:160">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}\psi
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Dependence_logic:161">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>-</mo>
   </msubsup>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>x</mi>
     <mi>ϕ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{-}\exists x\phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Dependence_logic:162">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>A</mi>
       <mo>/</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <divide></divide>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <minus></minus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X[A/x]}^{-}\phi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Dependence_logic:163">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>X</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>A</mi>
      <mo>/</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>m</mi>
       <mo>/</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>A</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <divide></divide>
       <ci>A</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <ci>m</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X[A/x]=\{s[m/x]:s\in A\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:164">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!A
  </annotation>
 </semantics>
</math>

 is the domain of 

<math display="inline" id="Dependence_logic:165">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<h2 id="dependence-logic-and-other-logics">Dependence logic and other logics</h2>
<h3 id="dependence-logic-and-first-order-logic">Dependence logic and first-order logic</h3>

<p>Dependence logic is a <a href="conservative_extension" title="wikilink">conservative extension</a> of first-order logic:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> in other words, for every first order sentence 

<math display="inline" id="Dependence_logic:166">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 and structure 

<math display="inline" id="Dependence_logic:167">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 we have that 

<math display="inline" id="Dependence_logic:168">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi mathvariant="normal">∅</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>+</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <set>
       <emptyset></emptyset>
      </set>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{\{\emptyset\}}^{+}\phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Dependence_logic:169">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 is true in 

<math display="inline" id="Dependence_logic:170">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 according to the usual first order semantics. Furthermore, for any first order <em>formula</em> 

<math display="inline" id="Dependence_logic:171">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dependence_logic:172">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msubsup>
    <mo>⊧</mo>
    <mi>X</mi>
    <mo>+</mo>
   </msubsup>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <plus></plus>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}^{+}\phi
  </annotation>
 </semantics>
</math>

 if and only if all assignments 

<math display="inline" id="Dependence_logic:173">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>μ</mi>
   </mpadded>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>μ</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mu\in X
  </annotation>
 </semantics>
</math>

 satisfy 

<math display="inline" id="Dependence_logic:174">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dependence_logic:175">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}
  </annotation>
 </semantics>
</math>

 according to the usual first order semantics.</p>

<p>However, dependence logic is strictly more expressive than first order logic:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> for example, the sentence</p>

<p>

<math display="block" id="Dependence_logic:176">
 <semantics>
  <mrow>
   <mo lspace="0.8pt">∃</mo>
   <mi>z</mi>
   <mo>∀</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>∃</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>∃</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo rspace="0pt">=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo rspace="0pt">=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>↔</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>≠</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">z</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <exists></exists>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <exists></exists>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-↔</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <neq></neq>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\exists z\forall x_{1}\forall x_{2}\exists y_{1}\exists y_{2}(=\!\!(x_{1},y_%
{1})\wedge=\!\!(x_{2},y_{2})\wedge(x_{1}=x_{2}\leftrightarrow y_{1}=y_{2})%
\wedge y_{1}\not=z)
  </annotation>
 </semantics>
</math>

 is true in a model 

<math display="inline" id="Dependence_logic:177">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 if and only if the domain of this model is infinite, even though no first order formula 

<math display="inline" id="Dependence_logic:178">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 has this property.</p>
<h3 id="dependence-logic-and-second-order-logic">Dependence logic and second-order logic</h3>

<p>Every dependence logic sentence is equivalent to some sentence in the existential fragment of second-order logic,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> that is, to some second-order sentence of the form</p>

<p>

<math display="block" id="Dependence_logic:179">
 <semantics>
  <mrow>
   <mo lspace="0.8pt">∃</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>n</mi>
      </msub>
      <mi>ψ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>R</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi>R</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>n</ci>
       </apply>
       <ci>ψ</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\exists R_{1}\ldots\exists R_{n}\psi(R_{1}\ldots R_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Dependence_logic:180">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>ψ</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>R</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ψ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\psi(R_{1}\ldots R_{n})
  </annotation>
 </semantics>
</math>

 does not contain second-order quantifiers. Conversely, every second-order sentence in the above form is equivalent to some dependence logic sentence.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>As for open formulas, dependence logic corresponds to the downwards monotone fragment of existential second-order logic, in the sense that a nonempty class of teams is definable by a dependence logic formula if and only if the corresponding class of relations is downwards monotone and definable by an existential second-order formula.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="dependence-logic-and-branching-quantifiers">Dependence logic and branching quantifiers</h3>

<p>Branching quantifiers are expressible in terms of dependence atoms: for example, the expression</p>

<p>

<math display="block" id="Dependence_logic:181">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>Q</mi>
       <mi>H</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>∀</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mrow>
           <mo>∃</mo>
           <msub>
            <mi>y</mi>
            <mn>1</mn>
           </msub>
          </mrow>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>∀</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mn>2</mn>
          </msub>
          <mrow>
           <mo>∃</mo>
           <msub>
            <mi>y</mi>
            <mn>2</mn>
           </msub>
          </mrow>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>H</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </vector>
     <ci>ϕ</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <exists></exists>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <exists></exists>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <ci>ϕ</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q_{H}x_{1},x_{2},y_{1},y_{2})\phi(x_{1},x_{2},y_{1},y_{2})\equiv\begin{%
pmatrix}\forall x_{1}\exists y_{1}\\
\forall x_{2}\exists y_{2}\end{pmatrix}\phi(x_{1},x_{2},y_{1},y_{2})
  </annotation>
 </semantics>
</math>

 is equivalent to the dependence logic sentence 

<math display="inline" id="Dependence_logic:182">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>∃</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>∀</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>∃</mo>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo rspace="0pt">=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo rspace="0pt">=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <exists></exists>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <exists></exists>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x_{1}\exists y_{1}\forall x_{2}\exists y_{2}(=\!\!(x_{1},y_{1})\wedge=%
\!\!(x_{2},y_{2})\wedge\phi)
  </annotation>
 </semantics>
</math>

, in the sense that the former expression is true in a model if and only if the latter expression is true.</p>

<p>Conversely, any dependence logic sentence is equivalent to some sentence in the logic of branching quantifiers, since all existential second-order sentences are expressible in branching quantifier logic.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="dependence-logic-and-if-logic">Dependence logic and IF logic</h3>

<p>Any dependence logic sentence is logically equivalent to some IF logic sentence, and vice versa.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>However, the issue is subtler when it comes to open formulas. Translations between IF logic and dependence logic formulas, and vice versa, exist as long as the domain of the team is fixed: in other words, for all sets of variables 

<math display="inline" id="Dependence_logic:183">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>V</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>v</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <set>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!V=\{v_{1}\ldots v_{n}\}
  </annotation>
 </semantics>
</math>

 and all IF logic formulas 

<math display="inline" id="Dependence_logic:184">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 with free variables in 

<math display="inline" id="Dependence_logic:185">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!V
  </annotation>
 </semantics>
</math>

 there exists a dependence logic formula 

<math display="inline" id="Dependence_logic:186">
 <semantics>
  <msup>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>ϕ</mi>
   </mpadded>
   <mi>D</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ϕ</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi^{D}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Dependence_logic:187">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <msubsup>
     <mo>⊧</mo>
     <mi>X</mi>
     <mo>+</mo>
    </msubsup>
    <mi>ϕ</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <msubsup>
     <mo>⊧</mo>
     <mi>X</mi>
     <mo>+</mo>
    </msubsup>
    <msup>
     <mi>ϕ</mi>
     <mi>D</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">models</csymbol>
       <ci>X</ci>
      </apply>
      <plus></plus>
     </apply>
     <ci>𝒜</ci>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">models</csymbol>
       <ci>X</ci>
      </apply>
      <plus></plus>
     </apply>
     <ci>𝒜</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\models_{X}^{+}\phi\Leftrightarrow\mathcal{A}\models_{X}^{+}\phi^{D}
  </annotation>
 </semantics>
</math>

 for all structures 

<math display="inline" id="Dependence_logic:188">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and for all teams 

<math display="inline" id="Dependence_logic:189">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

 with domain 

<math display="inline" id="Dependence_logic:190">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!V
  </annotation>
 </semantics>
</math>

, and conversely, for every dependence logic formula 

<math display="inline" id="Dependence_logic:191">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ψ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\psi
  </annotation>
 </semantics>
</math>

 with free variables in 

<math display="inline" id="Dependence_logic:192">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!V
  </annotation>
 </semantics>
</math>

 there exists an IF logic formula 

<math display="inline" id="Dependence_logic:193">
 <semantics>
  <msup>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>ψ</mi>
   </mpadded>
   <mi>I</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ψ</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\psi^{I}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Dependence_logic:194">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <msubsup>
     <mo>⊧</mo>
     <mi>X</mi>
     <mo>+</mo>
    </msubsup>
    <mi>ψ</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    <msubsup>
     <mo>⊧</mo>
     <mi>X</mi>
     <mo>+</mo>
    </msubsup>
    <msup>
     <mi>ψ</mi>
     <mi>I</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">models</csymbol>
       <ci>X</ci>
      </apply>
      <plus></plus>
     </apply>
     <ci>𝒜</ci>
     <ci>ψ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">models</csymbol>
       <ci>X</ci>
      </apply>
      <plus></plus>
     </apply>
     <ci>𝒜</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ψ</ci>
      <ci>I</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\models_{X}^{+}\psi\Leftrightarrow\mathcal{A}\models_{X}^{+}\psi^{I}
  </annotation>
 </semantics>
</math>

 for all structures 

<math display="inline" id="Dependence_logic:195">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 and for all teams 

<math display="inline" id="Dependence_logic:196">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X
  </annotation>
 </semantics>
</math>

 with domain 

<math display="inline" id="Dependence_logic:197">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!V
  </annotation>
 </semantics>
</math>

. These translations cannot be compositional.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="properties">Properties</h2>

<p>Dependence logic formulas are <em>downwards closed</em>: if 

<math display="inline" id="Dependence_logic:198">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msub>
    <mo>⊧</mo>
    <mi>X</mi>
   </msub>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>X</ci>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}\phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:199">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>Y</mi>
   </mpadded>
   <mo>⊆</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>Y</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!Y\subseteq X
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Dependence_logic:200">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msub>
    <mo>⊧</mo>
    <mi>Y</mi>
   </msub>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>Y</ci>
    </apply>
    <ci>𝒜</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{Y}\psi
  </annotation>
 </semantics>
</math>

. Furthermore, the empty team (but <em>not</em> the team containing the empty assignment) satisfies all formulas of Dependence Logic, both positively and negatively.</p>

<p>The law of the excluded middle fails in dependence logic: for example, the formula 

<math display="inline" id="Dependence_logic:201">
 <semantics>
  <mrow>
   <mo lspace="0.8pt">∃</mo>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo rspace="0pt">=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\exists y(=\!\!(y)\wedge y=x)
  </annotation>
 </semantics>
</math>

 is neither positively nor negatively satisfied by the team 

<math display="inline" id="Dependence_logic:202">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>X</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <cn type="integer">0</cn>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!X=\{(x:0),(x:1)\}
  </annotation>
 </semantics>
</math>

. Furthermore, disjunction is not idempotent and does not distribute over conjunction.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Both the <a href="compactness_theorem" title="wikilink">compactness theorem</a> and the <a href="Lowenheim-skolem_theorem" title="wikilink">Löwenheim-Skolem theorem</a> are true for dependence logic. <a href="Craig_interpolation" title="wikilink">Craig's interpolation theorem</a> also holds, but, due to the nature of negation in dependence logic, in a slightly modified formulation: if two dependence logic formulas 

<math display="inline" id="Dependence_logic:203">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:204">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 are <em>contradictory</em>, that is, it is never the case that both 

<math display="inline" id="Dependence_logic:205">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:206">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ψ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\psi
  </annotation>
 </semantics>
</math>

 hold in the same model, then there exists a <em>first order</em> sentence 

<math display="inline" id="Dependence_logic:207">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>θ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\theta
  </annotation>
 </semantics>
</math>

 in the common language of the two sentences such that 

<math display="inline" id="Dependence_logic:208">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Dependence_logic:209">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>θ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\theta
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:210">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>θ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\theta
  </annotation>
 </semantics>
</math>

 is contradictory with 

<math display="inline" id="Dependence_logic:211">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ψ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\psi
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>As IF logic,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Dependence logic can define its own truth operator:<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> more precisely, there exists a formula 

<math display="inline" id="Dependence_logic:212">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>τ</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>τ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\tau(x)
  </annotation>
 </semantics>
</math>

 such that for every sentence 

<math display="inline" id="Dependence_logic:213">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 of dependence logic and all models 

<math display="inline" id="Dependence_logic:214">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">ℳ</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℳ</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}_{\omega}
  </annotation>
 </semantics>
</math>

 which satisfy <a href="Peano's_axioms" title="wikilink">Peano's axioms</a>, if 

<math display="inline" id="Dependence_logic:215">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mmultiscripts>
    <mi>ϕ</mi>
    <none></none>
    <mo>′</mo>
    <mprescripts></mprescripts>
    <none></none>
    <mo>′</mo>
   </mmultiscripts>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ϕ</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!{}^{\prime}\phi^{\prime}
  </annotation>
 </semantics>
</math>

 is the <a href="Gödel_numbering" title="wikilink">Gödel number</a> of 

<math display="inline" id="Dependence_logic:216">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>ϕ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\phi
  </annotation>
 </semantics>
</math>

 then</p>

<p>

<math display="block" id="Dependence_logic:217">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℳ</mi>
    <mi>ω</mi>
   </msub>
   <mpadded width="-1.7pt">
    <msubsup>
     <mo>⊧</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi mathvariant="normal">∅</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>+</mo>
    </msubsup>
   </mpadded>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <plus></plus>
     </apply>
     <set>
      <emptyset></emptyset>
     </set>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℳ</ci>
     <ci>ω</ci>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}_{\omega}\models^{+}_{\{\emptyset\}}\!\phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Dependence_logic:218">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℳ</mi>
    <mi>ω</mi>
   </msub>
   <msubsup>
    <mo>⊧</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi mathvariant="normal">∅</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>+</mo>
   </msubsup>
   <mi>τ</mi>
   <mrow>
    <msup>
     <mo stretchy="false">(</mo>
     <mo>′</mo>
    </msup>
    <msup>
     <mi>ϕ</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℳ</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <plus></plus>
     </apply>
     <set>
      <emptyset></emptyset>
     </set>
    </apply>
    <csymbol cd="unknown">τ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-(</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}_{\omega}\models^{+}_{\{\emptyset\}}\tau(^{\prime}\phi^{\prime}).
  </annotation>
 </semantics>
</math>

</p>

<p>This does not contradict <a href="Tarski's_undefinability_theorem#General_form_of_the_theorem" title="wikilink">Tarski's undefinability theorem</a>, since the negation of dependence logic is not the usual contradictory one.</p>
<h2 id="complexity">Complexity</h2>

<p>As a consequence of <a href="Fagin's_theorem" title="wikilink">Fagin's theorem</a>, the properties of finite structures definable in dependence logic correspond exactly to NP properties. Furthermore, Durand and Kontinen showed that restricting the number of universal quantifiers or the arity of dependence atoms in sentences gives rise to hierarchy theorems with respect to expressive power.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>The inconsistency problem of dependence logic is <a href="Semidecidability#Semidecidability" title="wikilink">semidecidable</a>, and in fact equivalent to the inconsistency problem for first-order logic. However, the decision problem for dependence logic is non-<a href="Arithmetical_hierarchy" title="wikilink">arithmetical</a>, and is in fact complete with respect to the 

<math display="inline" id="Dependence_logic:219">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{2}
  </annotation>
 </semantics>
</math>

 class of the <a href="Levy_hierarchy" title="wikilink">Levy hierarchy</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="variants-and-extensions">Variants and extensions</h2>
<h3 id="team-logic">Team logic</h3>

<p>Team logic<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> extends dependence logic with a <em>contradictory negation</em> 

<math display="inline" id="Dependence_logic:220">
 <semantics>
  <mrow>
   <mi></mi>
   <mo rspace="0pt">∼</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim\!\!\phi
  </annotation>
 </semantics>
</math>

. Its expressive power is equivalent to that of full second-order logic.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="modal-dependence-logic">Modal dependence logic</h3>

<p>The dependence atom, or a suitable variant thereof, can be added to the language of <a href="modal_logic" title="wikilink">modal logic</a>, thus obtaining <em>modal dependence logic</em>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h3 id="intuitionistic-dependence-logic">Intuitionistic dependence logic</h3>

<p>As it is, dependence logic lacks an implication. The <em>intuitionistic implication</em> 

<math display="inline" id="Dependence_logic:221">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\rightarrow\psi
  </annotation>
 </semantics>
</math>

, whose name derives from the similarity between its definition and that of the implication of <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a>, can be defined as follows:<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>

<math display="block" id="Dependence_logic:222">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msub>
    <mo>⊧</mo>
    <mi>X</mi>
   </msub>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <ci>𝒜</ci>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{X}\phi\rightarrow\psi
  </annotation>
 </semantics>
</math>

 if and only if for all 

<math display="inline" id="Dependence_logic:223">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>Y</mi>
   </mpadded>
   <mo>⊆</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>Y</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!Y\subseteq X
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Dependence_logic:224">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msub>
    <mo>⊧</mo>
    <mi>Y</mi>
   </msub>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>Y</ci>
    </apply>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{Y}\phi
  </annotation>
 </semantics>
</math>

 it holds that 

<math display="inline" id="Dependence_logic:225">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   </mpadded>
   <msub>
    <mo>⊧</mo>
    <mi>Y</mi>
   </msub>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>Y</ci>
    </apply>
    <ci>𝒜</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\mathcal{A}\models_{Y}\psi
  </annotation>
 </semantics>
</math>

.</p>

<p>Intuitionistic dependence logic, that is, dependence logic supplemented with the intuitionistic implication, is equivalent to second-order logic.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h3 id="independence-logic">Independence logic</h3>

<p>Instead of dependence atoms, independence logic adds to the language of first-order logic independence atoms 

<math display="inline" id="Dependence_logic:226">
 <semantics>
  <mrow>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
   <msub>
    <mo>⊥</mo>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
   </msub>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">bottom</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{1}}\bot_{\vec{t_{3}}}\vec{t_{2}}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Dependence_logic:227">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{1}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dependence_logic:228">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>t</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{2}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:229">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>t</mi>
    <mn>3</mn>
   </msub>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{3}}
  </annotation>
 </semantics>
</math>

 are tuples of terms. The semantics of these atoms is defined as follows:</p>

<p>

<math display="block" id="Dependence_logic:230">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <msub>
    <mo>⊧</mo>
    <mi>X</mi>
   </msub>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <msub>
     <mo>⊥</mo>
     <mover accent="true">
      <msub>
       <mi>t</mi>
       <mn>3</mn>
      </msub>
      <mo stretchy="false">→</mo>
     </mover>
    </msub>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>X</ci>
    </apply>
    <ci>𝒜</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">bottom</csymbol>
      <apply>
       <ci>normal-→</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\models_{X}\vec{t_{1}}\bot_{\vec{t_{3}}}\vec{t_{2}}
  </annotation>
 </semantics>
</math>

 if and only if for all 

<math display="inline" id="Dependence_logic:231">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </list>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,s^{\prime}\in X
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Dependence_logic:232">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>s</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{3}}\langle s\rangle=\vec{t_{3}}\langle s^{\prime}\rangle
  </annotation>
 </semantics>
</math>

 there exists 

<math display="inline" id="Dependence_logic:233">
 <semantics>
  <mrow>
   <msup>
    <mi>s</mi>
    <mi>′′</mi>
   </msup>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>′′</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime\prime}\in X
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Dependence_logic:234">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msup>
      <mi>s</mi>
      <mi>′′</mi>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>s</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>′′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{3}}\langle s^{\prime\prime}\rangle=\vec{t_{3}}\langle s\rangle
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dependence_logic:235">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msup>
      <mi>s</mi>
      <mi>′′</mi>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>s</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>′′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{1}}\langle s^{\prime\prime}\rangle=\vec{t_{1}}\langle s\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:236">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msup>
      <mi>s</mi>
      <mi>′′</mi>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>′′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{2}}\langle s^{\prime\prime}\rangle=\vec{t_{2}}\langle s^{\prime}\rangle
  </annotation>
 </semantics>
</math>

. Independence logic corresponds to existential second-order logic, in the sense that a non-empty class of teams is definable by an independence logic formula if and only if the corresponding class of relations is definable by an existential second-order formula.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Therefore, on the level of open formulas, independence logic is strictly stronger in expressive power than dependence logic. However, on the level of sentences these logics are equivalent.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h3 id="inclusionexclusion-logic">Inclusion/exclusion logic</h3>

<p>Inclusion/exclusion logic extends first-order logic with inclusion atoms 

<math display="inline" id="Dependence_logic:237">
 <semantics>
  <mrow>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>⊆</mo>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{1}}\subseteq\vec{t_{2}}
  </annotation>
 </semantics>
</math>

 and exclusion atoms 

<math display="inline" id="Dependence_logic:238">
 <semantics>
  <mrow>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>∣</mo>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{1}}\mid\vec{t_{2}}
  </annotation>
 </semantics>
</math>

 where in both formulas 

<math display="inline" id="Dependence_logic:239">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{1}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dependence_logic:240">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>t</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{2}}
  </annotation>
 </semantics>
</math>

 are term tuples of the same length. The semantics of these atoms is defined as follows:</p>
<ul>
<li>

<math display="inline" id="Dependence_logic:241">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <msub>
    <mo>⊧</mo>
    <mi>X</mi>
   </msub>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>⊆</mo>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <ci>X</ci>
     </apply>
     <ci>𝒜</ci>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\models_{X}\vec{t_{1}}\subseteq\vec{t_{2}}
  </annotation>
 </semantics>
</math>

 if and only if for all 

<math display="inline" id="Dependence_logic:242">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in X
  </annotation>
 </semantics>
</math>

 there exists 

<math display="inline" id="Dependence_logic:243">
 <semantics>
  <mrow>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}\in X
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Dependence_logic:244">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>s</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{1}}\langle s\rangle=\vec{t_{2}}\langle s^{\prime}\rangle
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Dependence_logic:245">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <msub>
    <mo>⊧</mo>
    <mi>X</mi>
   </msub>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>∣</mo>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\models_{X}\vec{t_{1}}\mid\vec{t_{2}}
  </annotation>
 </semantics>
</math>

 if and only if for all 

<math display="inline" id="Dependence_logic:246">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </list>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,s^{\prime}\in X
  </annotation>
 </semantics>
</math>

 it holds that 

<math display="inline" id="Dependence_logic:247">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>s</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>t</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{t_{1}}\langle s\rangle\neq\vec{t_{2}}\langle s^{\prime}\rangle
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Inclusion/exclusion logic has the same expressive power as independence logic, already on the level of open formulas.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Inclusion logic and exclusion logic are obtained by adding only inclusion atoms or exclusion atoms to first-order logic, respectively. Inclusion logic sentences correspond in expressive power to greatest fixed-point logic sentences; hence inclusion logic captures (least) fixed-point logic on finite models, and PTIME over finite ordered models.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> Exclusion logic in turn corresponds to dependence logic in expressive power.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h3 id="generalized-quantifiers">Generalized quantifiers</h3>

<p>Another way of extending dependence logic is to add some generalized quantifiers to the language of dependence logic. Very recently there has been some study of dependence logic with monotone generalized quantifiers<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> and dependence logic with a certain majority quantifier, the latter leading to a new descriptive complexity characterization of the counting hierarchy.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Game_semantics" title="wikilink">Game semantics</a></li>
<li><a href="Branching_quantifier" title="wikilink">Branching quantifier</a></li>
<li><a href="Independence-friendly_logic" title="wikilink">Independence-friendly logic</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://link.springer.com/journal/11225/101/2/page/1">Special issue of Studia Logica on "Dependence and Independence in Logic", containing a number of articles on Dependence Logic</a></li>
<li><a href="https://www.knaw.nl/en/news/calendar/dependence-logic?set_language=en">Presentations in Academy Colloquium Dependence Logic, Amsterdam, 2014</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Systems_of_formal_logic" title="wikilink">Category:Systems of formal logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#refVaananen07" title="wikilink">Väänänen 2007</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#refHodges97" title="wikilink">Hodges 1997</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §3.2</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §3.2</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §4</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §6.1</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §6.3</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#refKontVaan09" title="wikilink">Kontinen and Väänänen 2009</a><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#refEnderton70" title="wikilink">Enderton 1970</a><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#refWalkoe70" title="wikilink">Walkoe 1970</a><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §3.6</a><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#refKontVaan09b" title="wikilink">Kontinen and Väänänen 2009 bis</a><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §3</a><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §6.2</a><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#refHintikka02" title="wikilink">Hintikka 2002</a><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §6.4</a><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#refDurKon12" title="wikilink">Durand and Kontinen</a><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §7</a><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#refVaananen07" title="wikilink">Väänänen 2007, §8</a><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#refKontNurmi09" title="wikilink">Kontinen and Nurmi 2009</a><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#refSevenster09" title="wikilink">Sevenster 2009</a><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#refVaananen08" title="wikilink">Väänänen 2008</a><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#refLohmVoll10" title="wikilink">Lohmann and Vollmer 2010</a><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#refAbrVaan09" title="wikilink">Abramsky and Väänänen 2009</a><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#refYang10" title="wikilink">Yang 2010</a><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#refGal12" title="wikilink">Galliani 2012</a><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#refGrVaan12" title="wikilink">Grädel and Väänänen</a><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#refGal12" title="wikilink">Galliani 2012</a><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#refGalHella13" title="wikilink">Galliani and Hella 2013</a><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#refGal12" title="wikilink">Galliani 2012</a><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#refEng12" title="wikilink">Engström</a><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#refDurEbb11" title="wikilink">Durand, Ebbing, Kontinen, Vollmer 2011</a><a href="#fnref32">↩</a></li>
</ol>
</section>
</body>
</html>
