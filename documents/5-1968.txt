   Recursive least squares filter      Recursive least squares filter   The Recursive least squares (RLS) is an adaptive filter which recursively finds the coefficients that minimize a weighted linear least squares  cost function relating to the input signals. This is in contrast to other algorithms such as the least mean squares (LMS) that aim to reduce the mean square error . In the derivation of the RLS, the input signals are considered deterministic , while for the LMS and similar algorithm they are considered stochastic . Compared to most of its competitors, the RLS exhibits extremely fast convergence. However, this benefit comes at the cost of high computational complexity.  Motivation  RLS was discovered by Gauss but lay unused or ignored until 1950 when Plackett rediscovered the original work of Gauss from 1821. In general, the RLS can be used to solve any problem that can be solved by adaptive filters . For example, suppose that a signal d(n) is transmitted over an echoey, noisy channel that causes it to be received as       x   (  n  )    =     ∑   k  =  0   q     b  n    (  k  )   d   (   n  -  k   )     +   v   (  n  )           x  n       superscript   subscript     k  0    q      subscript  b  n   k  d    n  k       v  n      x(n)=\sum_{k=0}^{q}b_{n}(k)d(n-k)+v(n)     where    v   (  n  )       v  n    v(n)   represents additive noise . We will attempt to recover the desired signal    d   (  n  )       d  n    d(n)   by use of a    p  +  1      p  1    p+1   -tap FIR filter,   𝐰   𝐰   \mathbf{w}   :        d  ^    (  n  )    =    ∑   k  =  0   p     w  n    (  k  )   x   (   n  -  k   )     =    𝐰  n  T    𝐱  n             normal-^  d   n     superscript   subscript     k  0    p      subscript  w  n   k  x    n  k             superscript   subscript  𝐰  n   T    subscript  𝐱  n       \hat{d}(n)=\sum_{k=0}^{p}w_{n}(k)x(n-k)=\mathbf{w}_{n}^{\mathit{T}}\mathbf{x}_%
 {n}     where     𝐱  n   =    [   x   (  n  )     x   (   n  -  1   )    …   x   (   n  -  p   )    ]   T        subscript  𝐱  n    superscript     x  n     x    n  1    normal-…    x    n  p     T     \mathbf{x}_{n}=[x(n)\quad x(n-1)\quad\ldots\quad x(n-p)]^{T}   is the vector containing the    p  +  1      p  1    p+1   most recent samples of    x   (  n  )       x  n    x(n)   . Our goal is to estimate the parameters of the filter   𝐰   𝐰   \mathbf{w}   , and at each time n we refer to the new least squares estimate by    𝐰  n     subscript  𝐰  n    \mathbf{w}_{n}   . As time evolves, we would like to avoid completely redoing the least squares algorithm to find the new estimate for    𝐰   n  +  1      subscript  𝐰    n  1     \mathbf{w}_{n+1}   , in terms of    𝐰  n     subscript  𝐰  n    \mathbf{w}_{n}   .  The benefit of the RLS algorithm is that there is no need to invert matrices, thereby saving computational power. Another advantage is that it provides intuition behind such results as the Kalman filter .  Discussion  The idea behind RLS filters is to minimize a cost function    C   C   C   by appropriately selecting the filter coefficients    𝐰  n     subscript  𝐰  n    \mathbf{w}_{n}   , updating the filter as new data arrives. The error signal    e   (  n  )       e  n    e(n)   and desired signal    d   (  n  )       d  n    d(n)   are defined in the negative feedback diagram below:  (Figure)  AdaptiveFilter C.png   The error implicitly depends on the filter coefficients through the estimate     d  ^    (  n  )        normal-^  d   n    \hat{d}(n)   :       e   (  n  )    =    d   (  n  )    -    d  ^    (  n  )           e  n       d  n      normal-^  d   n      e(n)=d(n)-\hat{d}(n)     The weighted least squares error function   C   C   C   —the cost function we desire to minimize—being a function of e(n) is therefore also dependent on the filter coefficients:       C   (   𝐰  n   )    =    ∑   i  =  0   n     λ   n  -  i     e  2    (  i  )           C   subscript  𝐰  n      superscript   subscript     i  0    n      superscript  λ    n  i     superscript  e  2   i      C(\mathbf{w}_{n})=\sum_{i=0}^{n}\lambda^{n-i}e^{2}(i)   where    0  <  λ  ≤  1        0  λ       1     0<\lambda\leq 1   is the "forgetting factor" which gives exponentially less weight to older error samples.  The cost function is minimized by taking the partial derivatives for all entries   k   k   k   of the coefficient vector    𝐰  n     subscript  𝐰  n    \mathbf{w}_{n}   and setting the results to zero          ∂  C    (   𝐰  n   )      ∂   w  n     (  k  )     =    ∑   i  =  0   n    2   λ   n  -  i    e   (  i  )      ∂  e    (  i  )      ∂   w  n     (  k  )       =   -    ∑   i  =  0   n    2   λ   n  -  i    e   (  i  )   x   (   i  -  k   )      =  0    k  =   0  ,  1  ,  ⋯  ,  p       formulae-sequence            C    subscript  𝐰  n         subscript  w  n    k      superscript   subscript     i  0    n     2   superscript  λ    n  i    e  i        e   i        subscript  w  n    k               superscript   subscript     i  0    n     2   superscript  λ    n  i    e  i  x    i  k           0      k   0  1  normal-⋯  p      \frac{\partial C(\mathbf{w}_{n})}{\partial w_{n}(k)}=\sum_{i=0}^{n}\,2\lambda^%
 {n-i}e(i)\,\frac{\partial e(i)}{\partial w_{n}(k)}={-}\sum_{i=0}^{n}\,2\lambda%
 ^{n-i}e(i)\,x(i-k)=0\qquad k=0,1,\cdots,p   Next, replace    e   (  n  )       e  n    e(n)   with the definition of the error signal         ∑   i  =  0   n     λ   n  -  i     [    d   (  i  )    -    ∑   l  =  0   p     w  n    (  l  )   x   (   i  -  l   )      ]   x   (   i  -  k   )     =  0    k  =   0  ,  1  ,  ⋯  ,  p       formulae-sequence      superscript   subscript     i  0    n      superscript  λ    n  i     delimited-[]      d  i     superscript   subscript     l  0    p      subscript  w  n   l  x    i  l       x    i  k     0     k   0  1  normal-⋯  p      \sum_{i=0}^{n}\lambda^{n-i}\left[d(i)-\sum_{l=0}^{p}w_{n}(l)x(i-l)\right]x(i-k%
 )=0\qquad k=0,1,\cdots,p   Rearranging the equation yields         ∑   l  =  0   p     w  n    (  l  )    [    ∑   i  =  0   n      λ   n  -  i     x   (   i  -  l   )   x   (   i  -  k   )     ]     =    ∑   i  =  0   n     λ   n  -  i    d   (  i  )   x   (   i  -  k   )       k  =   0  ,  1  ,  ⋯  ,  p       formulae-sequence      superscript   subscript     l  0    p      subscript  w  n   l   delimited-[]    superscript   subscript     i  0    n      superscript  λ    n  i    x    i  l   x    i  k          superscript   subscript     i  0    n      superscript  λ    n  i    d  i  x    i  k        k   0  1  normal-⋯  p      \sum_{l=0}^{p}w_{n}(l)\left[\sum_{i=0}^{n}\lambda^{n-i}\,x(i-l)x(i-k)\right]=%
 \sum_{i=0}^{n}\lambda^{n-i}d(i)x(i-k)\qquad k=0,1,\cdots,p   This form can be expressed in terms of matrices        𝐑  x    (  n  )    𝐰  n    =    𝐫   d  x     (  n  )           subscript  𝐑  x   n   subscript  𝐰  n       subscript  𝐫    d  x    n     \mathbf{R}_{x}(n)\,\mathbf{w}_{n}=\mathbf{r}_{dx}(n)   where     𝐑  x    (  n  )        subscript  𝐑  x   n    \mathbf{R}_{x}(n)   is the weighted sample covariance matrix for    x   (  n  )       x  n    x(n)   , and     𝐫   d  x     (  n  )        subscript  𝐫    d  x    n    \mathbf{r}_{dx}(n)   is the equivalent estimate for the cross-covariance between    d   (  n  )       d  n    d(n)   and    x   (  n  )       x  n    x(n)   . Based on this expression we find the coefficients which minimize the cost function as       𝐰  n   =    𝐑  x   -  1     (  n  )    𝐫   d  x     (  n  )         subscript  𝐰  n      superscript   subscript  𝐑  x     1    n   subscript  𝐫    d  x    n     \mathbf{w}_{n}=\mathbf{R}_{x}^{-1}(n)\,\mathbf{r}_{dx}(n)   This is the main result of the discussion.  Choosing   λ   λ   \lambda     The smaller   λ   λ   \lambda   is, the smaller contribution of previous samples. This makes the filter more sensitive to recent samples, which means more fluctuations in the filter co-efficients. The    λ  =  1      λ  1    \lambda=1   case is referred to as the growing window RLS algorithm . In practice,   λ   λ   \lambda   is usually chosen between 0.98 and 1. 1  Recursive algorithm  The discussion resulted in a single equation to determine a coefficient vector which minimizes the cost function. In this section we want to derive a recursive solution of the form       𝐰  n   =    𝐰   n  -  1    +   Δ   𝐰   n  -  1           subscript  𝐰  n      subscript  𝐰    n  1      normal-Δ   subscript  𝐰    n  1        \mathbf{w}_{n}=\mathbf{w}_{n-1}+\Delta\mathbf{w}_{n-1}   where    Δ   𝐰   n  -  1        normal-Δ   subscript  𝐰    n  1      \Delta\mathbf{w}_{n-1}   is a correction factor at time    n  -  1      n  1    {n-1}   . We start the derivation of the recursive algorithm by expressing the cross covariance     𝐫   d  x     (  n  )        subscript  𝐫    d  x    n    \mathbf{r}_{dx}(n)   in terms of     𝐫   d  x     (   n  -  1   )        subscript  𝐫    d  x      n  1     \mathbf{r}_{dx}(n-1)                𝐫   d  x     (  n  )        subscript  𝐫    d  x    n    \mathbf{r}_{dx}(n)           =    ∑   i  =  0   n     λ   n  -  i    d   (  i  )   𝐱   (  i  )         absent    superscript   subscript     i  0    n      superscript  λ    n  i    d  i  𝐱  i      =\sum_{i=0}^{n}\lambda^{n-i}d(i)\mathbf{x}(i)              =     ∑   i  =  0    n  -  1      λ   n  -  i    d   (  i  )   𝐱   (  i  )     +    λ  0   d   (  n  )   𝐱   (  n  )         absent      superscript   subscript     i  0      n  1       superscript  λ    n  i    d  i  𝐱  i       superscript  λ  0   d  n  𝐱  n      =\sum_{i=0}^{n-1}\lambda^{n-i}d(i)\mathbf{x}(i)+\lambda^{0}d(n)\mathbf{x}(n)              =    λ   𝐫   d  x     (   n  -  1   )    +   d   (  n  )   𝐱   (  n  )         absent      λ   subscript  𝐫    d  x      n  1      d  n  𝐱  n      =\lambda\mathbf{r}_{dx}(n-1)+d(n)\mathbf{x}(n)          where    𝐱   (  i  )       𝐱  i    \mathbf{x}(i)   is the    p  +  1      p  1    {p+1}   dimensional data vector       𝐱   (  i  )    =    [   x   (  i  )    ,   x   (   i  -  1   )    ,  …  ,   x   (   i  -  p   )    ]   T         𝐱  i    superscript     x  i     x    i  1    normal-…    x    i  p     T     \mathbf{x}(i)=[x(i),x(i-1),\dots,x(i-p)]^{T}   Similarly we express     𝐑  x    (  n  )        subscript  𝐑  x   n    \mathbf{R}_{x}(n)   in terms of     𝐑  x    (   n  -  1   )        subscript  𝐑  x     n  1     \mathbf{R}_{x}(n-1)   by             𝐑  x    (  n  )        subscript  𝐑  x   n    \mathbf{R}_{x}(n)           =    ∑   i  =  0   n     λ   n  -  i    𝐱   (  i  )    𝐱  T    (  i  )         absent    superscript   subscript     i  0    n      superscript  λ    n  i    𝐱  i   superscript  𝐱  T   i      =\sum_{i=0}^{n}\lambda^{n-i}\mathbf{x}(i)\mathbf{x}^{T}(i)              =    λ   𝐑  x    (   n  -  1   )    +   𝐱   (  n  )    𝐱  T    (  n  )         absent      λ   subscript  𝐑  x     n  1      𝐱  n   superscript  𝐱  T   n      =\lambda\mathbf{R}_{x}(n-1)+\mathbf{x}(n)\mathbf{x}^{T}(n)          In order to generate the coefficient vector we are interested in the inverse of the deterministic auto-covariance matrix. For that task the Woodbury matrix identity comes in handy. With           A   A   A           =   λ   𝐑  x    (   n  -  1   )        absent    λ   subscript  𝐑  x     n  1      =\lambda\mathbf{R}_{x}(n-1)   is    (   p  +  1   )      p  1    (p+1)   -by-    (   p  +  1   )      p  1    (p+1)           U   U   U           =   𝐱   (  n  )        absent    𝐱  n     =\mathbf{x}(n)   is    (   p  +  1   )      p  1    (p+1)   -by-1        V   V   V           =    𝐱  T    (  n  )        absent     superscript  𝐱  T   n     =\mathbf{x}^{T}(n)   is 1-by-    (   p  +  1   )      p  1    (p+1)           C   C   C           =   𝐈  1       absent   subscript  𝐈  1     =\mathbf{I}_{1}   is the 1-by-1 identity matrix       The Woodbury matrix identity follows             𝐑  x   -  1     (  n  )        superscript   subscript  𝐑  x     1    n    \mathbf{R}_{x}^{-1}(n)         =     =           [    λ   𝐑  x    (   n  -  1   )    +   𝐱   (  n  )    𝐱  T    (  n  )     ]    -  1      superscript   delimited-[]      λ   subscript  𝐑  x     n  1      𝐱  n   superscript  𝐱  T   n       1     \left[\lambda\mathbf{R}_{x}(n-1)+\mathbf{x}(n)\mathbf{x}^{T}(n)\right]^{-1}            =     =           λ   -  1     𝐑  x   -  1     (   n  -  1   )        superscript  λ    1     superscript   subscript  𝐑  x     1      n  1     \lambda^{-1}\mathbf{R}_{x}^{-1}(n-1)              -    λ   -  1     𝐑  x   -  1     (   n  -  1   )   𝐱   (  n  )           superscript  λ    1     superscript   subscript  𝐑  x     1      n  1   𝐱  n     -\lambda^{-1}\mathbf{R}_{x}^{-1}(n-1)\mathbf{x}(n)                {   1  +    𝐱  T    (  n  )    λ   -  1     𝐑  x   -  1     (   n  -  1   )   𝐱   (  n  )     }    -  1     𝐱  T    (  n  )    λ   -  1     𝐑  x   -  1     (   n  -  1   )        superscript     1     superscript  𝐱  T   n   superscript  λ    1     superscript   subscript  𝐑  x     1      n  1   𝐱  n       1     superscript  𝐱  T   n   superscript  λ    1     superscript   subscript  𝐑  x     1      n  1     \left\{1+\mathbf{x}^{T}(n)\lambda^{-1}\mathbf{R}_{x}^{-1}(n-1)\mathbf{x}(n)%
 \right\}^{-1}\mathbf{x}^{T}(n)\lambda^{-1}\mathbf{R}_{x}^{-1}(n-1)          To come in line with the standard literature, we define            𝐏   (  n  )       𝐏  n    \mathbf{P}(n)           =    𝐑  x   -  1     (  n  )        absent     superscript   subscript  𝐑  x     1    n     =\mathbf{R}_{x}^{-1}(n)              =     λ   -  1    𝐏   (   n  -  1   )    -   𝐠   (  n  )    𝐱  T    (  n  )    λ   -  1    𝐏   (   n  -  1   )         absent       superscript  λ    1    𝐏    n  1      𝐠  n   superscript  𝐱  T   n   superscript  λ    1    𝐏    n  1       =\lambda^{-1}\mathbf{P}(n-1)-\mathbf{g}(n)\mathbf{x}^{T}(n)\lambda^{-1}\mathbf%
 {P}(n-1)          where the gain vector     g   (  n  )       g  n    g(n)   is            𝐠   (  n  )       𝐠  n    \mathbf{g}(n)           =    λ   -  1    𝐏   (   n  -  1   )   𝐱   (  n  )     {   1  +    𝐱  T    (  n  )    λ   -  1    𝐏   (   n  -  1   )   𝐱   (  n  )     }    -  1         absent     superscript  λ    1    𝐏    n  1   𝐱  n   superscript     1     superscript  𝐱  T   n   superscript  λ    1    𝐏    n  1   𝐱  n       1       =\lambda^{-1}\mathbf{P}(n-1)\mathbf{x}(n)\left\{1+\mathbf{x}^{T}(n)\lambda^{-1%
 }\mathbf{P}(n-1)\mathbf{x}(n)\right\}^{-1}              =   𝐏   (   n  -  1   )   𝐱   (  n  )     {   λ  +    𝐱  T    (  n  )   𝐏   (   n  -  1   )   𝐱   (  n  )     }    -  1         absent    𝐏    n  1   𝐱  n   superscript     λ     superscript  𝐱  T   n  𝐏    n  1   𝐱  n       1       =\mathbf{P}(n-1)\mathbf{x}(n)\left\{\lambda+\mathbf{x}^{T}(n)\mathbf{P}(n-1)%
 \mathbf{x}(n)\right\}^{-1}          Before we move on, it is necessary to bring    𝐠   (  n  )       𝐠  n    \mathbf{g}(n)   into another form            𝐠   (  n  )    {   1  +    𝐱  T    (  n  )    λ   -  1    𝐏   (   n  -  1   )   𝐱   (  n  )     }       𝐠  n     1     superscript  𝐱  T   n   superscript  λ    1    𝐏    n  1   𝐱  n       \mathbf{g}(n)\left\{1+\mathbf{x}^{T}(n)\lambda^{-1}\mathbf{P}(n-1)\mathbf{x}(n%
 )\right\}           =    λ   -  1    𝐏   (   n  -  1   )   𝐱   (  n  )        absent     superscript  λ    1    𝐏    n  1   𝐱  n     =\lambda^{-1}\mathbf{P}(n-1)\mathbf{x}(n)             𝐠   (  n  )    +   𝐠   (  n  )    𝐱  T    (  n  )    λ   -  1    𝐏   (   n  -  1   )   𝐱   (  n  )          𝐠  n     𝐠  n   superscript  𝐱  T   n   superscript  λ    1    𝐏    n  1   𝐱  n     \mathbf{g}(n)+\mathbf{g}(n)\mathbf{x}^{T}(n)\lambda^{-1}\mathbf{P}(n-1)\mathbf%
 {x}(n)           =    λ   -  1    𝐏   (   n  -  1   )   𝐱   (  n  )        absent     superscript  λ    1    𝐏    n  1   𝐱  n     =\lambda^{-1}\mathbf{P}(n-1)\mathbf{x}(n)          Subtracting the second term on the left side yields            𝐠   (  n  )       𝐠  n    \mathbf{g}(n)           =     λ   -  1    𝐏   (   n  -  1   )   𝐱   (  n  )    -   𝐠   (  n  )    𝐱  T    (  n  )    λ   -  1    𝐏   (   n  -  1   )   𝐱   (  n  )         absent       superscript  λ    1    𝐏    n  1   𝐱  n     𝐠  n   superscript  𝐱  T   n   superscript  λ    1    𝐏    n  1   𝐱  n      =\lambda^{-1}\mathbf{P}(n-1)\mathbf{x}(n)-\mathbf{g}(n)\mathbf{x}^{T}(n)%
 \lambda^{-1}\mathbf{P}(n-1)\mathbf{x}(n)              =    λ   -  1     [    𝐏   (   n  -  1   )    -   𝐠   (  n  )    𝐱  T    (  n  )   𝐏   (   n  -  1   )     ]   𝐱   (  n  )        absent     superscript  λ    1     delimited-[]      𝐏    n  1      𝐠  n   superscript  𝐱  T   n  𝐏    n  1      𝐱  n     =\lambda^{-1}\left[\mathbf{P}(n-1)-\mathbf{g}(n)\mathbf{x}^{T}(n)\mathbf{P}(n-%
 1)\right]\mathbf{x}(n)          With the recursive definition of    𝐏   (  n  )       𝐏  n    \mathbf{P}(n)   the desired form follows       𝐠   (  n  )    =   𝐏   (  n  )   𝐱   (  n  )          𝐠  n     𝐏  n  𝐱  n     \mathbf{g}(n)=\mathbf{P}(n)\mathbf{x}(n)   Now we are ready to complete the recursion. As discussed            𝐰  n     subscript  𝐰  n    \mathbf{w}_{n}           =   𝐏   (  n  )    𝐫   d  x     (  n  )        absent    𝐏  n   subscript  𝐫    d  x    n     =\mathbf{P}(n)\,\mathbf{r}_{dx}(n)              =    λ  𝐏   (  n  )    𝐫   d  x     (   n  -  1   )    +   d   (  n  )   𝐏   (  n  )   𝐱   (  n  )         absent      λ  𝐏  n   subscript  𝐫    d  x      n  1      d  n  𝐏  n  𝐱  n      =\lambda\mathbf{P}(n)\,\mathbf{r}_{dx}(n-1)+d(n)\mathbf{P}(n)\,\mathbf{x}(n)          The second step follows from the recursive definition of     𝐫   d  x     (  n  )        subscript  𝐫    d  x    n    \mathbf{r}_{dx}(n)   . Next we incorporate the recursive definition of    𝐏   (  n  )       𝐏  n    \mathbf{P}(n)   together with the alternate form of    𝐠   (  n  )       𝐠  n    \mathbf{g}(n)   and get            𝐰  n     subscript  𝐰  n    \mathbf{w}_{n}           =    λ   [     λ   -  1    𝐏   (   n  -  1   )    -   𝐠   (  n  )    𝐱  T    (  n  )    λ   -  1    𝐏   (   n  -  1   )     ]    𝐫   d  x     (   n  -  1   )    +   d   (  n  )   𝐠   (  n  )         absent      λ   delimited-[]       superscript  λ    1    𝐏    n  1      𝐠  n   superscript  𝐱  T   n   superscript  λ    1    𝐏    n  1       subscript  𝐫    d  x      n  1      d  n  𝐠  n      =\lambda\left[\lambda^{-1}\mathbf{P}(n-1)-\mathbf{g}(n)\mathbf{x}^{T}(n)%
 \lambda^{-1}\mathbf{P}(n-1)\right]\mathbf{r}_{dx}(n-1)+d(n)\mathbf{g}(n)              =     𝐏   (   n  -  1   )    𝐫   d  x     (   n  -  1   )    -   𝐠   (  n  )    𝐱  T    (  n  )   𝐏   (   n  -  1   )    𝐫   d  x     (   n  -  1   )     +   d   (  n  )   𝐠   (  n  )         absent        𝐏    n  1    subscript  𝐫    d  x      n  1      𝐠  n   superscript  𝐱  T   n  𝐏    n  1    subscript  𝐫    d  x      n  1       d  n  𝐠  n      =\mathbf{P}(n-1)\mathbf{r}_{dx}(n-1)-\mathbf{g}(n)\mathbf{x}^{T}(n)\mathbf{P}(%
 n-1)\mathbf{r}_{dx}(n-1)+d(n)\mathbf{g}(n)              =    𝐏   (   n  -  1   )    𝐫   d  x     (   n  -  1   )    +   𝐠   (  n  )    [    d   (  n  )    -    𝐱  T    (  n  )   𝐏   (   n  -  1   )    𝐫   d  x     (   n  -  1   )     ]         absent      𝐏    n  1    subscript  𝐫    d  x      n  1      𝐠  n   delimited-[]      d  n      superscript  𝐱  T   n  𝐏    n  1    subscript  𝐫    d  x      n  1          =\mathbf{P}(n-1)\mathbf{r}_{dx}(n-1)+\mathbf{g}(n)\left[d(n)-\mathbf{x}^{T}(n)%
 \mathbf{P}(n-1)\mathbf{r}_{dx}(n-1)\right]          With     𝐰   n  -  1    =   𝐏   (   n  -  1   )    𝐫   d  x     (   n  -  1   )         subscript  𝐰    n  1      𝐏    n  1    subscript  𝐫    d  x      n  1      \mathbf{w}_{n-1}=\mathbf{P}(n-1)\mathbf{r}_{dx}(n-1)   we arrive at the update equation            𝐰  n     subscript  𝐰  n    \mathbf{w}_{n}           =    𝐰   n  -  1    +   𝐠   (  n  )    [    d   (  n  )    -    𝐱  T    (  n  )    𝐰   n  -  1      ]         absent     subscript  𝐰    n  1      𝐠  n   delimited-[]      d  n      superscript  𝐱  T   n   subscript  𝐰    n  1           =\mathbf{w}_{n-1}+\mathbf{g}(n)\left[d(n)-\mathbf{x}^{T}(n)\mathbf{w}_{n-1}\right]              =    𝐰   n  -  1    +   𝐠   (  n  )   α   (  n  )         absent     subscript  𝐰    n  1      𝐠  n  α  n      =\mathbf{w}_{n-1}+\mathbf{g}(n)\alpha(n)          where     α   (  n  )    =    d   (  n  )    -    𝐱  T    (  n  )    𝐰   n  -  1            α  n       d  n      superscript  𝐱  T   n   subscript  𝐰    n  1        \alpha(n)=d(n)-\mathbf{x}^{T}(n)\mathbf{w}_{n-1}   is the a priori error. Compare this with the a posteriori error; the error calculated after the filter is updated:       e   (  n  )    =    d   (  n  )    -    𝐱  T    (  n  )    𝐰  n           e  n       d  n      superscript  𝐱  T   n   subscript  𝐰  n       e(n)=d(n)-\mathbf{x}^{T}(n)\mathbf{w}_{n}     That means we found the correction factor       Δ   𝐰   n  -  1     =   𝐠   (  n  )   α   (  n  )          normal-Δ   subscript  𝐰    n  1       𝐠  n  α  n     \Delta\mathbf{w}_{n-1}=\mathbf{g}(n)\alpha(n)     This intuitively satisfying result indicates that the correction factor is directly proportional to both the error and the gain vector, which controls how much sensitivity is desired, through the weighting factor,   λ   λ   \lambda   .  RLS algorithm summary  The RLS algorithm for a p -th order RLS filter can be summarized as      Parameters:       p  =       p  absent    p=   filter order          λ  =       λ  absent    \lambda=   forgetting factor          δ  =       δ  absent    \delta=   value to initialize    𝐏   (  0  )       𝐏  0    \mathbf{P}(0)        Initialization:        𝐰   (  n  )    =  0        𝐰  n   0    \mathbf{w}(n)=0   ,            x   (  k  )    =  0   ,   k  =    -  p   ,  …  ,   -  1        formulae-sequence      x  k   0     k     p   normal-…    1       x(k)=0,k=-p,\dots,-1   ,            d   (  k  )    =  0   ,   k  =    -  p   ,  …  ,   -  1        formulae-sequence      d  k   0     k     p   normal-…    1       d(k)=0,k=-p,\dots,-1              𝐏   (  0  )    =    δ   -  1    I         𝐏  0      superscript  δ    1    I     \mathbf{P}(0)=\delta^{-1}I   where   I   I   I   is the identity matrix of rank    p  +  1      p  1    p+1        Computation:   For    n  =   1  ,  2  ,  …       n   1  2  normal-…     n=1,2,\dots              𝐱   (  n  )    =   [      x   (  n  )         x   (   n  -  1   )        ⋮       x   (   n  -  p   )       ]         𝐱  n    delimited-[]      x  n       x    n  1      normal-⋮      x    n  p         \mathbf{x}(n)=\left[\begin{matrix}x(n)\\
 x(n-1)\\
 \vdots\\
 x(n-p)\end{matrix}\right]              α   (  n  )    =    d   (  n  )    -    𝐱  T    (  n  )   𝐰   (   n  -  1   )           α  n       d  n      superscript  𝐱  T   n  𝐰    n  1       \alpha(n)=d(n)-\mathbf{x}^{T}(n)\mathbf{w}(n-1)              𝐠   (  n  )    =   𝐏   (   n  -  1   )    𝐱  *    (  n  )     {   λ  +    𝐱  T    (  n  )   𝐏   (   n  -  1   )    𝐱  *    (  n  )     }    -  1           𝐠  n     𝐏    n  1    superscript  𝐱    n   superscript     λ     superscript  𝐱  T   n  𝐏    n  1    superscript  𝐱    n       1       \mathbf{g}(n)=\mathbf{P}(n-1)\mathbf{x}^{*}(n)\left\{\lambda+\mathbf{x}^{T}(n)%
 \mathbf{P}(n-1)\mathbf{x}^{*}(n)\right\}^{-1}              𝐏   (  n  )    =     λ   -  1    𝐏   (   n  -  1   )    -   𝐠   (  n  )    𝐱  T    (  n  )    λ   -  1    𝐏   (   n  -  1   )           𝐏  n        superscript  λ    1    𝐏    n  1      𝐠  n   superscript  𝐱  T   n   superscript  λ    1    𝐏    n  1       \mathbf{P}(n)=\lambda^{-1}\mathbf{P}(n-1)-\mathbf{g}(n)\mathbf{x}^{T}(n)%
 \lambda^{-1}\mathbf{P}(n-1)              𝐰   (  n  )    =    𝐰   (   n  -  1   )    +   α   (  n  )   𝐠   (  n  )           𝐰  n       𝐰    n  1      α  n  𝐠  n      \mathbf{w}(n)=\mathbf{w}(n-1)+\,\alpha(n)\mathbf{g}(n)   .     Note that the recursion for   P   P   P   follows an Algebraic Riccati equation and thus draws parallels to the Kalman filter . 2  Lattice recursive least squares filter (LRLS)  The Lattice Recursive Least Squares  adaptive filter is related to the standard RLS except that it requires fewer arithmetic operations (order N). It offers additional advantages over conventional LMS algorithms such as faster convergence rates, modular structure, and insensitivity to variations in eigenvalue spread of the input correlation matrix. The LRLS algorithm described is based on a posteriori errors and includes the normalized form. The derivation is similar to the standard RLS algorithm and is based on the definition of    d   (  k  )       d  k    d(k)\,\!   . In the forward prediction case, we have     d   (  k  )    =   x   (  k  )          d  k     x  k     d(k)=x(k)\,\!   with the input signal    x   (   k  -  1   )       x    k  1     x(k-1)\,\!   as the most up to date sample. The backward prediction case is     d   (  k  )    =   x   (   k  -  i  -  1   )          d  k     x    k  i  1      d(k)=x(k-i-1)\,\!   , where i is the index of the sample in the past we want to predict, and the input signal    x   (  k  )       x  k    x(k)\,\!   is the most recent sample. 3  Parameter Summary       κ  f    (  k  ,  i  )        subscript  κ  f    k  i     \kappa_{f}(k,i)\,\!   is the forward reflection coefficient       κ  b    (  k  ,  i  )        subscript  κ  b    k  i     \kappa_{b}(k,i)\,\!   is the backward reflection coefficient       e  f    (  k  ,  i  )        subscript  e  f    k  i     e_{f}(k,i)\,\!   represents the instantaneous a posteriori forward prediction error       e  b    (  k  ,  i  )        subscript  e  b    k  i     e_{b}(k,i)\,\!   represents the instantaneous a posteriori backward prediction error       ξ   b   m  i  n    d    (  k  ,  i  )        subscript   superscript  ξ  d    subscript  b    m  i  n      k  i     \xi^{d}_{b_{min}}(k,i)\,\!   is the minimum least-squares backward prediction error       ξ   f   m  i  n    d    (  k  ,  i  )        subscript   superscript  ξ  d    subscript  f    m  i  n      k  i     \xi^{d}_{f_{min}}(k,i)\,\!   is the minimum least-squares forward prediction error      γ   (  k  ,  i  )       γ   k  i     \gamma(k,i)\,\!   is a conversion factor between a priori and a posteriori errors       v  i    (  k  )        subscript  v  i   k    v_{i}(k)\,\!   are the feedforward multiplier coefficients.     ϵ   ϵ   \epsilon\,\!   is a small positive constant that can be 0.01  LRLS Algorithm Summary  The algorithm for a LRLS filter can be summarized as      Initialization:                       Computation:                                                                    Normalized lattice recursive least squares filter (NLRLS)  The normalized form of the LRLS has fewer recursions and variables. It can be calculated by applying a normalization to the internal variables of the algorithm which will keep their magnitude bounded by one. This is generally not used in real-time applications because of the number of division and square-root operations which comes with a high computational load.  NLRLS algorithm summary  The algorithm for a NLRLS filter can be summarized as      Initialization:                       Computation:                                                  See also   Adaptive filter  Kernel adaptive filter  Least mean squares filter  Zero forcing equalizer   References    Simon Haykin, Adaptive Filter Theory , Prentice Hall, 2002, ISBN 0-13-048434-2  M.H.A Davis, R.B. Vinter, Stochastic Modelling and Control , Springer, 1985, ISBN 0-412-16200-8  Weifeng Liu, Jose Principe and Simon Haykin, Kernel Adaptive Filtering: A Comprehensive Introduction , John Wiley, 2010, ISBN 0-470-44753-2  R.L.Plackett, Some Theorems in Least Squares , Biometrika, 1950, 37, 149-157, ISSN 00063444  C.F.Gauss, Theoria combinationis observationum erroribus minimis obnoxiae , 1821, Werke, 4. Gottinge   Notes  "  Category:Digital signal processing  Category:Filter theory  Category:Time series analysis     Emannual C. Ifeacor, Barrie W. Jervis. Digital signal processing: a practical approach, second edition. Indianapolis: Pearson Education Limited, 2002, p. 718 ↩  Welch, Greg and Bishop, Gary "An Introduction to the Kalman Filter" , Department of Computer Science, University of North Carolina at Chapel Hill, September 17, 1997, accessed July 19, 2011. ↩  Albu, Kadlec, Softley, Matousek, Hermanek, Coleman, Fagan "Implementation of (Normalised) RLS Lattice on Virtex" , Digital Signal Processing, 2001, accessed December 24, 2011. ↩     