<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="990">Inductive probability</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Inductive probability</h1>
<hr/>

<p><strong>Inductive probability</strong> attempts to give the probability of future events based on past events. It is the basis for <a href="inductive_reasoning" title="wikilink">inductive reasoning</a>, and gives the mathematical basis for <a class="uri" href="learning" title="wikilink">learning</a> and the perception of patterns. It is a source of <a class="uri" href="knowledge" title="wikilink">knowledge</a> about the world.</p>

<p>There are three sources of knowledge: inference, communication, and deduction. Communication relays information found using other methods. Deduction establishes new facts based on existing facts. Only inference establishes new facts from data.</p>

<p>The basis of inference is <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a>. But this theorem is sometimes hard to apply and understand. The simpler method to understand inference is in terms of quantities of information.</p>

<p>Information describing the world is written in a language. For example a simple mathematical language of propositions may be chosen. Sentences may be written down in this language as strings of characters. But in the computer it is possible to encode these sentences as strings of bits (1s and 0s). Then the language may be encoded so that the most commonly used sentences are the shortest. This internal language implicitly represents probabilities of statements.</p>

<p><a href="Occam's_razor" title="wikilink">Occam's razor</a> says the "simplest theory, consistent with the data is most likely to be correct". The "simplest theory" is interpreted as the representation of the theory written in this internal language. The theory with the shortest encoding in this internal language is most likely to be correct.</p>
<h2 id="history">History</h2>

<p>Probability and statistics was focused on probability distributions and tests of significance. Probability was formal, well defined, but limited in scope. In particular its application was limited to situations that could be defined as an experiment or trial, with a well defined population.</p>

<p><a href="Bayes's_theorem" title="wikilink">Bayes's theorem</a> is named after Rev. <a href="Thomas_Bayes" title="wikilink">Thomas Bayes</a> 1701–1761. <a href="Bayesian_inference" title="wikilink">Bayesian inference</a> broadened the application of probability to many situations where a population was not well defined. But Bayes' theorem always depended on prior probabilities, to generate new probabilities. It was unclear where these prior probabilities should come from.</p>

<p><a href="Ray_Solomonoff" title="wikilink">Ray Solomonoff</a> developed <a href="algorithmic_probability" title="wikilink">algorithmic probability</a> which gave an explanation for what randomness is and how patterns in the data may be represented by computer programs, that give shorter representations of the data circa 1964.</p>

<p><a href="Chris_Wallace_(computer_scientist)" title="wikilink">Chris Wallace</a> and D. M. Boulton developed <a href="minimum_message_length" title="wikilink">minimum message length</a> circa 1968. Later <a href="Jorma_Rissanen" title="wikilink">Jorma Rissanen</a> developed the <a href="minimum_description_length" title="wikilink">minimum description length</a> circa 1978. These methods allow <a href="information_theory" title="wikilink">information theory</a> to be related to probability, in a way that can be compared to the application of Bayes' theorem, but which give a source and explanation for the role of prior probabilities.</p>

<p><a href="Marcus_Hutter" title="wikilink">Marcus Hutter</a> combined <a href="decision_theory" title="wikilink">decision theory</a> with the work of Ray Solomonoff and <a href="Andrey_Kolmogorov" title="wikilink">Andrey Kolmogorov</a> to give a theory for the <a href="Pareto_efficiency" title="wikilink">Pareto optimal</a> behavior for an <a href="Intelligent_agent" title="wikilink">Intelligent agent</a>, circa 1998.</p>
<h3 id="minimum-descriptionmessage-length">Minimum description/message length</h3>

<p>The program with the shortest length that matches the data is the most likely to predict future data. This is the thesis behind the <a href="Minimum_message_length" title="wikilink">Minimum message length</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="Minimum_description_length" title="wikilink">Minimum description length</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> methods.</p>

<p>At first sight <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> appears different from the minimimum message/description length principle. At closer inspection it turns out to be the same. Bayes' theorem is about conditional probabilities. What is the probability that event <em>B</em> happens if firstly event <em>A</em> happens?</p>

<p>

<math display="block" id="Inductive_probability:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mi mathvariant="italic">and</mi>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>∣</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\and B)=P(B)\cdot P(A\mid B)=P(A)\cdot P(B\mid A)
  </annotation>
 </semantics>
</math>

</p>

<p>Becomes in terms of message length <em>L</em>,</p>

<p>

<math display="block" id="Inductive_probability:1">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mi mathvariant="italic">and</mi>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>∣</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(A\and B)=L(B)+L(A\mid B)=L(A)+L(B\mid A)
  </annotation>
 </semantics>
</math>

</p>

<p>What this means is that in describing an event, if all the information is given describing the event then the length of the information may be used to give the raw probability of the event. So if the information describing the occurrence of <em>A</em> is given, along with the information describing <em>B</em> given <em>A</em>, then all the information describing <em>A</em> and <em>B</em> has been given.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h4 id="overfitting">Overfitting</h4>

<p><a class="uri" href="Overfitting" title="wikilink">Overfitting</a> is where the model matches the random noise and not the pattern in the data. For example take the situation where a curve is fitted to a set of points. If polynomial with many terms is fitted then it can more closely represent the data. Then the fit will be better, and the information needed to describe the deviances from the fitted curve will be smaller. Smaller information length means more probable.</p>

<p>However the information needed to describe the curve must also be considered. The total information for a curve with many terms may be greater than for a curve with fewer terms, that has not as good a fit, but needs less information to describe the polynomial.</p>
<h3 id="inference-based-on-program-complexity">Inference based on program complexity</h3>

<p><a href="Solomonoff's_theory_of_inductive_inference" title="wikilink">Solomonoff's theory of inductive inference</a> is also inductive inference. A bit string x is observed. Then consider all programs that generate strings starting with x. Cast in the form of inductive inference, the programs are theories that imply the observation of the bit string <em>x</em>.</p>

<p>The method used here to give probabilities for inductive inference is based on <a href="Solomonoff's_theory_of_inductive_inference" title="wikilink">Solomonoff's theory of inductive inference</a>.</p>
<h4 id="detecting-patterns-in-the-data">Detecting patterns in the data</h4>

<p>If all the bits are 1, then people infer that there is a bias in the coin and that it is more likely also that the next bit is 1 also. This is described as learning from, or detecting a pattern in the data.</p>

<p>Such a pattern may be represented by a <a href="computer_program" title="wikilink">computer program</a>. A short computer program may be written that produces a series of bits which are all 1. If the length of the program <em>K</em> is 

<math display="inline" id="Inductive_probability:2">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(K)
  </annotation>
 </semantics>
</math>

 bits then its prior probability is,</p>

<p>

<math display="block" id="Inductive_probability:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>K</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(K)=2^{-L(K)}
  </annotation>
 </semantics>
</math>

</p>

<p>The length of the shortest program that represents the string of bits is called the <a href="Kolmogorov_complexity" title="wikilink">Kolmogorov complexity</a>.</p>

<p>Kolmogorov complexity is not computable. This is related to the <a href="halting_problem" title="wikilink">halting problem</a>. When searching for the shortest program some programs may go into an infinite loop.</p>
<h4 id="considering-all-theories">Considering all theories</h4>

<p>The Greek philosopher <a class="uri" href="Epicurus" title="wikilink">Epicurus</a> is quoted as saying "If more than one theory is consistent with the observations, keep all theories".<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>As in a crime novel all theories must be considered in determining the likely murderer, so with inductive probability all programs must be considered in determining the likely future bits arising from the stream of bits.</p>

<p>Programs that are already longer than <em>n</em> have no predictive power. The raw (or prior) probability that the pattern of bits is random (has no pattern) is 

<math display="inline" id="Inductive_probability:4">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-n}
  </annotation>
 </semantics>
</math>

.</p>

<p>Each program that produces the sequence of bits, but is shorter than the <em>n</em> is a theory/pattern about the bits with a probability of 

<math display="inline" id="Inductive_probability:5">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo>-</mo>
    <mi>k</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-k}
  </annotation>
 </semantics>
</math>

 where <em>k</em> is the length of the program.</p>

<p>The probability of receiving a sequence of bits <em>y</em> after receiving a series of bits x is then the conditional probability of receiving <em>y</em> given <em>x</em>, which is the probability of x with y appended, divided by the probability of x. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h4 id="universal-priors">Universal priors</h4>

<p>The programming language effects the predictions of the next bit in the string. The language acts as a <a href="prior_probability" title="wikilink">prior probability</a>. This is particularly a problem where the programming language codes for numbers and other data types. Intuitively we think that 0 and 1 are simple numbers, and that prime numbers are somehow more complex the numbers may be factorized.</p>

<p>Using the <a href="Kolmogorov_complexity" title="wikilink">Kolmogorov complexity</a> gives an unbiased estimate (a universal prior) of the prior probability of a number. As a thought experiment an <a href="intelligent_agent" title="wikilink">intelligent agent</a> may be fitted with a data input device giving a series of numbers, after applying some transformation function to the raw numbers. Another agent might have the same input device with a different transformation function. The agents do not see or know about these transformation functions. Then there appears no rational basis for preferring one function over another. A universal prior insures that although two agents may have different initial probability distributions for the data input, the difference will be bounded by a constant.</p>

<p>So universal priors do not eliminate an initial bias, but they reduce and limit it. Whenever we describe an event in a language, either using a natural language or other, the language has encoded in it our prior expectations. So some reliance on prior probabilities are inevitable.</p>

<p>A problem arises where an intelligent agents prior expectations interact with the environment to form a self reinforcing feed back loop. This is the problem of bias or prejudice. Universal priors reduce but do not eliminate this problem.</p>
<h3 id="universal-artificial-intelligence">Universal artificial intelligence</h3>

<p>The theory of <a href="universal_artificial_intelligence" title="wikilink">universal artificial intelligence</a> applies <a href="decision_theory" title="wikilink">decision theory</a> to inductive probabilities. The theory shows how the best actions to optimize a reward function may be chosen. The result is a theoretical model of intelligence. <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>It is a fundamental theory of intelligence, which optimizes the agents behavior in,</p>
<ul>
<li>Exploring the environment; performing actions to get responses that broaden the agents knowledge.</li>
<li>Competing or co-operating with another agent; games.</li>
<li>Balancing short and long term rewards.</li>
</ul>

<p>In general no agent will always provide the best actions in all situations. A particular choice made by an agent may be wrong, and the environment may provide no way for the agent to recover from an initial bad choice. However the agent is <a href="Pareto_optimal" title="wikilink">Pareto optimal</a> in the sense that no other agent will do better than this agent in this environment, without doing worse in another environment. No other agent may, in this sense, be said to be better.</p>

<p>At present the theory is limited by incomputability (the <a href="halting_problem" title="wikilink">halting problem</a>). Approximations may be used to avoid this. Processing speed and <a href="combinatorial_explosion" title="wikilink">combinatorial explosion</a> remain the primary limiting factors for <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>.</p>
<h2 id="probability">Probability</h2>

<p>Probability is the representation of uncertain or partial knowledge about the truth of statements. Probabilities are subjective and personal estimates of likely outcomes based on past experience and inferences made from the data.</p>

<p>This description of probability may seem strange at first. In natural language we refer to "the probability" that the sun will rise tomorrow. We do not refer to "your probability" that the sun will rise. But in order for inference to be correctly modeled probability must be personal, and the act of inference generates new posterior probabilities from prior probabilities.</p>

<p>Probabilities are personal because they are conditional on the knowledge of the individual. Probabilities are subjective because they always depend, to some extent, on prior probabilities assigned by the individual. Subjective should not be taken here to mean vague or undefined.</p>

<p>The term <a href="intelligent_agent" title="wikilink">intelligent agent</a> is used to refer to the holder of the probabilities. The intelligent agent may be a human or a machine. If the intelligent agent does not interact with the environment then the probability will converge over time to the frequency of the event.</p>

<p>If however the agent uses the probability to interact with the environment there may be a feedback, so that two agents in the identical environment starting with only slightly different priors, end up with completely different probabilities. In this case optimal <a href="decision_theory" title="wikilink">decision theory</a> as in <a href="Marcus_Hutter" title="wikilink">Marcus Hutter's</a> Universal Artificial Intelligence will give <a href="Pareto_optimal" title="wikilink">Pareto optimal</a> performance for the agent. This means that no other intelligent agent could do better in one environment without doing worse in another environment.</p>
<h3 id="comparison-to-deductive-probability">Comparison to deductive probability</h3>

<p>In deductive probability theories, probabilities are absolutes, independent of the individual making the assessment. But deductive probabilities are based on,</p>
<ul>
<li>Shared knowledge.</li>
<li>Assumed facts, that should be inferred from the data.</li>
</ul>

<p>For example in a trial the participants are aware the outcome of all the previous history of trials. They also assume that each outcome is equally probable. Together this allows a single unconditional value of probability to be defined.</p>

<p>But in reality each individual does not have the same information. And in general the probability of each outcome is not equal. The dice may be loaded, and this loading needs to be inferred from the data.</p>
<h3 id="probability-as-estimation">Probability as estimation</h3>

<p>The <a href="principle_of_indifference" title="wikilink">principle of indifference</a> has played a key role in probability theory. It says that if N statements are symmetric so that one condition cannot be preferred over another then all statements are equally probable.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>Taken seriously, in evaluating probability this principle leads to contradictions. Suppose there are 3 bags of gold in the distance and you are asked to select one. Then because of the distance you cant see the bag sizes. You estimate using the principle of indifference that each bag has equal amounts of gold, and each bag has one third of the gold.</p>

<p>Now, while you are not looking, I take one of the bags and divide it into 3 bags. Now there are 5 bags of gold. The principle of indifference now says each bag has one fifth of the gold. A bag that was estimated to have one third of the gold is now estimated to have one fifth of the gold.</p>

<p>Taken as a value associated with the bag the values are different therefore contradictory. But taken as an estimate given under a particular scenario, both values are separate estimates given under different circumstances and there is no reason to believe they are equal.</p>

<p>Estimates of prior probabilities are particularly suspect. Estimates will be constructed that do not follow any consistent frequency distribution. For this reason prior probabilities are considered as estimates of probabilities rather than probabilities.</p>

<p>A full theoretical treatment would associate with each probability,</p>
<ul>
<li>The statement</li>
<li>Prior knowledge</li>
<li>Prior probabilities</li>
<li>The estimation procedure used to give the probability.</li>
</ul>
<h3 id="combining-probability-approaches">Combining probability approaches</h3>

<p>Inductive probability combines two different approaches to probability.</p>
<ul>
<li>Probability and information</li>
<li>Probability and frequency</li>
</ul>

<p>Each approach gives a slightly different viewpoint. Information theory is used in relating probabilities to quantities of information. This approach is often used in giving estimates of prior probabilities.</p>

<p><a href="Frequentist_probability" title="wikilink">Frequentist probability</a> defines probabilities as objective statements about how often an event occurs. This approach may be stretched by defining the <a href="Experiment_(probability_theory)" title="wikilink">trials</a> to be over <a href="possible_world" title="wikilink">possible worlds</a>. Statements about possible worlds define <a href="Event_(probability_theory)" title="wikilink">events</a>.</p>
<h2 id="probability-and-information">Probability and information</h2>

<p>Whereas logic represents only two values; true and false as the values of statement, probability associates a number between 0.0 and 1.0 with each statement. If the probability of a statement is 0 the statement is false. If the probability of a statement is 1 the statement is true.</p>

<p>In considering some data as a string of bits the prior probabilities for a sequence of 1 and 0s, the probability of 1 and 0 is equal. Therefore each extra bit halves the probability of a sequence of bits. This leads to the conclusion that,</p>

<p>

<math display="block" id="Inductive_probability:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=2^{-L(x)}
  </annotation>
 </semantics>
</math>

 Where</p>
<ul>
<li>

<math display="inline" id="Inductive_probability:7">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)
  </annotation>
 </semantics>
</math>

 is the probability of a string of bits x</li>
<li>

<math display="inline" id="Inductive_probability:8">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x)
  </annotation>
 </semantics>
</math>


 is the length of the string of bits x.</li>
<li>

<math display="inline" id="Inductive_probability:9">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-L(x)}
  </annotation>
 </semantics>
</math>

 means 1 divided by 2 to the power of the length of the string of bits x.</li>
</ul>

<p>The prior probability of any statement is calculated from the number of bits needed to state it. See also <a href="information_theory" title="wikilink">information theory</a>.</p>
<h3 id="combining-information">Combining information</h3>

<p>Two statements A and B may be represented by two separate encodings. Then the length of the encoding is,</p>

<p>

<math display="block" id="Inductive_probability:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(A\and B)=L(A)+L(B)
  </annotation>
 </semantics>
</math>

</p>

<p>or in terms of probability,</p>

<p>

<math display="block" id="Inductive_probability:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>A</ci>
     <ci>P</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\and B)=P(A)P(B)
  </annotation>
 </semantics>
</math>

</p>

<p>But this law is not always true because there may be a shorter method of encoding B if we assume A. So the above probability law applies only if A and B are "independent".</p>
<h3 id="the-internal-language-of-information">The internal language of information</h3>

<p>The primary use of the information approach to probability is to provide estimates of the complexity of statements. Recall that Occam's razor states that "All things being equal, the simplest theory is the most likely to be correct". In order to apply this rule, first there needs to be a definition of what "simplest" means. Information theory defines simplest to mean having the shortest encoding.</p>

<p>Knowledge is represented as <a href="Statement_(logic)" title="wikilink">statements</a>. Each statement is a <a href="Boolean_algebra" title="wikilink">Boolean</a> <a href="Expression_(mathematics)" title="wikilink">expression</a>. Expressions are encoded by a function that takes a description (as against the value) of the expression and encodes it as a bit string.</p>

<p>The length of the encoding of a statement gives an estimate of the probability of a statement. This probability estimate will often be used as the prior probability of a statement.</p>

<p>Technically this estimate is not a probability because it is not constructed from a frequency distribution. The probability estimates given by it do not always obey <a href="#The_law_of_total_of_probability" title="wikilink">the law of total of probability</a>. Applying the law of total probability to various scenarios will usually give a more accurate probability estimate of the prior probability than the estimate from the length of the statement.</p>
<h4 id="encoding-expressions">Encoding expressions</h4>

<p>An expression is constructed from sub expressions,</p>
<ul>
<li>Constants (including function identifier).</li>
<li>Application of functions.</li>
<li><a href="Quantifier_(logic)" title="wikilink">quantifiers</a>.</li>
</ul>

<p>A <a href="Huffman_coding" title="wikilink">Huffman code</a> must distinguish the 3 cases. The length of each code is based on the frequency of each type of sub expressions.</p>

<p>Initially constants are all assigned the same length/probability. Later constants may be assigned a probability using the Huffman code based on the number of uses of the function id in all expressions recorded so far. In using a Huffman code the goal is to estimate probabilities, not to compress the data.</p>

<p>The length of a function application is the length of the function identifier constant plus the sum of the sizes of the expressions for each parameter.</p>

<p>The length of a quantifier is the length of the expression being quantified over.</p>
<h4 id="distribution-of-numbers">Distribution of numbers</h4>

<p>No explicit representation of natural numbers is given. However natural numbers may be constructed by applying the successor function to 0, and then applying other arithmetic functions. A distribution of natural numbers is implied by this, based on the complexity of constructing each number.</p>

<p>Rational numbers are constructed by the division of natural numbers. The simplest representation has no common factors between the numerator and the denominator. This allows the probability distribution of natural numbers may be extended to rational numbers.</p>
<h2 id="probability-and-frequency">Probability and frequency</h2>

<p>The probability of an <a href="Event_(probability_theory)" title="wikilink">event</a> may be interpreted as the frequencies of <a href="Outcome_(probability)" title="wikilink">outcomes</a> where the statement is true divided by the total number of outcomes. If the outcomes form a continuum the frequency may need to be replaced with a <a href="Probability_measure" title="wikilink">measure</a>.</p>

<p>Events are sets of outcomes. Statements may be related to events. A Boolean statement B about outcomes defines a set of outcomes b,</p>

<p>

<math display="block" id="Inductive_probability:12">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=\{x:B(x)\}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="conditional-probability">Conditional probability</h3>

<p>Each probability is always associated with the state of knowledge at a particular point in the argument. Probabilities before an inference are known as prior probabilities, and probabilities after are known as posterior probabilities.</p>

<p>Probability depends on the facts known. The truth of a fact limits the domain of outcomes to the outcomes consistent with the fact. Prior probabilities are the probabilities before a fact is known. Posterior probabilities are after a fact is known. The posterior probabilities are said to be conditional on the fact. Conditional probabilities are written,</p>

<p>

<math display="block" id="Inductive_probability:13">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(B\mid A)
  </annotation>
 </semantics>
</math>

</p>

<p>This means the probability that B is true given that A is true.</p>

<p>All probabilities are in some sense conditional. The prior probability of B is,</p>

<p>

<math display="block" id="Inductive_probability:14">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mtext>true</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <mtext>true</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(B)=P(B\mid\text{true})
  </annotation>
 </semantics>
</math>

</p>
<h3 id="the-frequentest-approach-applied-to-possible-worlds">The frequentest approach applied to possible worlds</h3>

<p>In the <a href="Frequentist_inference" title="wikilink">frequentest approach</a>, probabilities are defined as the ratio of the number of <a href="Outcome_(probability)" title="wikilink">outcomes</a> within an event to the total number of outcomes. In the <a href="possible_world" title="wikilink">possible world</a> model each possible world is an outcome, and statements about possible worlds define events. The probability of a statement being true is the number of possible worlds divided by the total number of worlds.</p>

<p>The total number of worlds may be infinite. In this case instead of counting the elements of the set a <a href="Probability_measure" title="wikilink">measure</a> must be used. In general the cardinality |S|, where S is a set, is a measure.</p>

<p>The probability of a statement A being true about possible worlds is then,</p>

<p>

<math display="block" id="Inductive_probability:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>t</mi>
     <mi>r</mi>
     <mi>u</mi>
     <mi>e</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">t</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <csymbol cd="unknown">u</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <ci>normal-|</ci>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A)=\frac{|\{x:A(x)\}|}{|x:true|}
  </annotation>
 </semantics>
</math>

</p>

<p>For a conditional probability.</p>

<p>

<math display="block" id="Inductive_probability:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="italic">and</mi>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>x</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">A</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-|</ci>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(B\mid A)=\frac{|\{x:A(x)\and B(X)\}|}{|x:A(x)|}
  </annotation>
 </semantics>
</math>

</p>

<p>then</p>

<p>

<math display="block" id="Inductive_probability:17">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mi mathvariant="italic">and</mi>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>italic- and</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\and B)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:18">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="italic">and</mi>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>t</mi>
     <mi>r</mi>
     <mi>u</mi>
     <mi>e</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>x</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">t</csymbol>
      <csymbol cd="unknown">r</csymbol>
      <csymbol cd="unknown">u</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <ci>normal-|</ci>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{|\{x:A(x)\and B(x)\}|}{|x:true|}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:19">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>x</mi>
       <mo>:</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>x</mi>
       <mo>:</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>x</mi>
       <mo>:</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mi>t</mi>
      <mi>r</mi>
      <mi>u</mi>
      <mi>e</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="latexml">conditional-set</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>x</ci>
         <ci>italic- and</ci>
         <ci>B</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="latexml">conditional-set</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="latexml">conditional-set</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="unknown">t</csymbol>
       <csymbol cd="unknown">r</csymbol>
       <csymbol cd="unknown">u</csymbol>
       <csymbol cd="unknown">e</csymbol>
       <ci>normal-|</ci>
      </cerror>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{|\{x:A(x)\and B(x)\}|}{|\{x:A(x)\}|}\frac{|\{x:A(x)\}|}{|x:true|}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:20">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =P(A)P(B\mid A)
  </annotation>
 </semantics>
</math>

</p>

<p>Using symmetry this equation may be written out as Bayes' law.</p>

<p>

<math display="block" id="Inductive_probability:21">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mi mathvariant="italic">and</mi>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>∣</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\and B)=P(A)P(B\mid A)=P(B)P(A\mid B)
  </annotation>
 </semantics>
</math>

</p>

<p>This law describes the relationship between prior and posterior probabilities when new facts are learnt.</p>

<p>Written as quantities of information <a href="Bayes'_Theorem" title="wikilink">Bayes' Theorem</a> becomes,</p>

<p>

<math display="block" id="Inductive_probability:22">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mi mathvariant="italic">and</mi>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>∣</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(A\and B)=L(A)+L(B\mid A)=L(B)+L(A\mid B)
  </annotation>
 </semantics>
</math>

</p>

<p>Two statements A and B are said to be independent if knowing the truth of A does not change the probability of B. Mathematically this is,</p>

<p>

<math display="block" id="Inductive_probability:23">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(B)=P(B\mid A)
  </annotation>
 </semantics>
</math>

</p>

<p>then <a href="Bayes'_Theorem" title="wikilink">Bayes' Theorem</a> reduces to,</p>

<p>

<math display="block" id="Inductive_probability:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>A</ci>
     <ci>P</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\and B)=P(A)P(B)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="the-law-of-total-of-probability">The law of total of probability</h3>

<p>For a set of mutually exclusive possibilities 

<math display="inline" id="Inductive_probability:25">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

, the sum of the posterior probabilities must be 1.</p>

<p>

<math display="block" id="Inductive_probability:26">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}{P(A_{i}\mid B)}=1
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting using Bayes' theorem gives the <a href="law_of_total_probability" title="wikilink">law of total probability</a></p>

<p>

<math display="block" id="Inductive_probability:27">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}{P(B\mid A_{i})P(A_{i})}=\sum_{i}{P(A_{i}\mid B)P(B)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:28">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(B)=\sum_{i}{P(B\mid A_{i})P(A_{i})}
  </annotation>
 </semantics>
</math>

</p>

<p>This result is used to give the <a href="Bayes'_theorem#extended_form" title="wikilink">extended form of Bayes' theorem</a>,</p>

<p>

<math display="block" id="Inductive_probability:29">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>∣</mo>
      <msub>
       <mi>A</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>A</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>j</mi>
     </msub>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>∣</mo>
      <msub>
       <mi>A</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>A</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A_{i}\mid B)=\frac{P(B\mid A_{i})P(A_{i})}{\sum_{j}{P(B\mid A_{j})P(A_{j})}}
  </annotation>
 </semantics>
</math>

</p>

<p>This is the usual form of Bayes' theorem used in practice, because it guarantees the sum of all the posterior probabilities for 

<math display="inline" id="Inductive_probability:30">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 is 1.</p>
<h3 id="alternate-possibilities">Alternate possibilities</h3>

<p>For mutually exclusive possibilities, the probabilities add.</p>

<p>

<math display="block" id="Inductive_probability:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(AB)=P(A)+P(B)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Inductive_probability:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\and B)=0
  </annotation>
 </semantics>
</math>

</p>

<p>Using</p>

<p>

<math display="block" id="Inductive_probability:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mi mathvariant="italic">and</mi>
         <mi>B</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mi mathvariant="italic">and</mi>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mi mathvariant="italic">and</mi>
         <mi>B</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <apply>
       <not></not>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>italic- and</ci>
      <apply>
       <not></not>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AB=(A\and\neg(A\and B))(B\and\neg(A\and B))(A\and B)
  </annotation>
 </semantics>
</math>

 Then the alternatives</p>

<p>

<math display="block" id="Inductive_probability:34">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>italic- and</ci>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\and\neg(A\and B)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:35">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi mathvariant="italic">and</mi>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>italic- and</ci>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\and\neg(A\and B)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:36">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="italic">and</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>italic- and</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\and B
  </annotation>
 </semantics>
</math>

</p>

<p>are all mutually exclusive</p>

<p>Also,</p>

<p>

<math display="block" id="Inductive_probability:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mi mathvariant="italic">and</mi>
         <mi>B</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <apply>
       <not></not>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\and\neg(A\and B))(A\and B)=A
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mi mathvariant="italic">and</mi>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>A</mi>
          <mi mathvariant="italic">and</mi>
          <mi>B</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mi mathvariant="italic">and</mi>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <apply>
        <not></not>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>italic- and</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\and\neg(A\and B))+P(A\and B)=P(A)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mi mathvariant="italic">and</mi>
         <mi>B</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mi mathvariant="italic">and</mi>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>italic- and</ci>
      <apply>
       <not></not>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A\and\neg(A\and B))=P(A)-P(A\and B)
  </annotation>
 </semantics>
</math>

</p>

<p>so, putting it all together,</p>

<p>

<math display="block" id="Inductive_probability:40">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(AB)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:41">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mrow>
         <mi mathvariant="normal">¬</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>A</mi>
           <mi mathvariant="italic">and</mi>
           <mi>B</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>B</mi>
        <mi mathvariant="italic">and</mi>
        <mrow>
         <mi mathvariant="normal">¬</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>A</mi>
           <mi mathvariant="italic">and</mi>
           <mi>B</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <apply>
        <not></not>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>italic- and</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>italic- and</ci>
       <apply>
        <not></not>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>italic- and</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =P((A\and\neg(A\and B))(B\and\neg(A\and B))(A\and B))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:42">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mi mathvariant="italic">and</mi>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mi mathvariant="italic">and</mi>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mi mathvariant="italic">and</mi>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mi mathvariant="italic">and</mi>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <not></not>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <csymbol cd="unknown">and</csymbol>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =P(A\and\neg(A\and B)+P(B\and\neg(A\and B))+P(A\and B)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:43">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>A</mi>
          <mi mathvariant="italic">and</mi>
          <mi>B</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mi mathvariant="italic">and</mi>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>P</ci>
         <ci>A</ci>
        </apply>
        <apply>
         <times></times>
         <ci>P</ci>
         <apply>
          <times></times>
          <ci>A</ci>
          <ci>italic- and</ci>
          <ci>B</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =P(A)-P(A\and B)+P(B)-P(A\and B)+P(A\and B)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:44">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mi mathvariant="italic">and</mi>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =P(A)+P(B)-P(A\and B)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="negation">Negation</h3>

<p>As,</p>

<p>

<math display="block" id="Inductive_probability:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <not></not>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>r</ci>
     <ci>u</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\neg A=true
  </annotation>
 </semantics>
</math>

 then</p>

<p>

<math display="block" id="Inductive_probability:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A)+P(\neg A)=1
  </annotation>
 </semantics>
</math>

</p>
<h3 id="implication-and-condition-probability">Implication and condition probability</h3>

<p>Implication is related to conditional probability by the following equation,</p>

<p>

<math display="block" id="Inductive_probability:47">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
   <mo>⇔</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">B</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to B\iff P(B\mid A)=1
  </annotation>
 </semantics>
</math>

</p>

<p>Derivation,</p>

<p>

<math display="block" id="Inductive_probability:48">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to B
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:49">
 <semantics>
  <mrow>
   <mo>⇔</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff P(A\to B)=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:50">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mi mathvariant="italic">and</mi>
       <mi>B</mi>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
       <not></not>
       <ci>A</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff P(A\and B\neg A)=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:51">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <times></times>
        <not></not>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff P(A\and B)+P(\neg A)=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:52">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mi mathvariant="italic">and</mi>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>italic- and</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff P(A\and B)=P(A)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:53">
 <semantics>
  <mrow>
   <mo>⇔</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff P(A)\cdot P(B\mid A)=P(A)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:54">
 <semantics>
  <mrow>
   <mo>⇔</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>∣</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff P(B\mid A)=1
  </annotation>
 </semantics>
</math>

</p>
<h2 id="bayesian-hypothesis-testing">Bayesian hypothesis testing</h2>

<p>Bayes' theorem may be used to estimate the probability of a hypothesis or theory H, given some facts F. The posterior probability of H is then</p>

<p>

<math display="block" id="Inductive_probability:55">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>∣</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">H</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">H</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>F</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H\mid F)=\frac{P(H)P(F\mid H)}{P(F)}
  </annotation>
 </semantics>
</math>

</p>

<p>or in terms of information,</p>

<p>

<math display="block" id="Inductive_probability:56">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>H</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>+</mo>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>F</mi>
       <mo>∣</mo>
       <mi>H</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>-</mo>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>F</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <minus></minus>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">L</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">H</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <plus></plus>
       <csymbol cd="unknown">L</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">F</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">H</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <minus></minus>
       <csymbol cd="unknown">L</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">F</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H\mid F)=2^{-(L(H)+L(F\mid H)-L(F))}
  </annotation>
 </semantics>
</math>

</p>

<p>By assuming the hypothesis is true, a simpler representation of the statement F may be given. The length of the encoding of this simpler representation is L(F \mid H).</p>

<p>

<math display="inline" id="Inductive_probability:57">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo>∣</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(H)+L(F\mid H)
  </annotation>
 </semantics>
</math>

 represents the amount of information needed to represent the facts F, if H is true. L(F) is the amount of information needed to represent F without the hypothesis H. The difference is how much the representation of the facts has been compressed by assuming that H is true. This is the evidence that the hypothesis H is true.</p>

<p>If L(F) is estimated from <a href="#Probability_priors_from_encoding_length" title="wikilink">encoding length</a> then the probability obtained will not be between 0 and 1. The value obtained is proportional to the probability, without being a good probability estimate. The number obtained is sometimes referred to as a relative probability, being how much more probable the theory is than not holding the theory.</p>

<p>If a full set of mutually exclusive hypothesis that provide evidence is known, a proper estimate may be given for the prior probability 

<math display="inline" id="Inductive_probability:58">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(F)
  </annotation>
 </semantics>
</math>


.</p>
<h3 id="set-of-hypothesis">Set of hypothesis</h3>

<p>Probabilities may be calculated from the extended form of Bayes' theorem. Given all mutually exclusive hypothesis 

<math display="inline" id="Inductive_probability:59">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}
  </annotation>
 </semantics>
</math>

 which give evidence, such that,</p>

<p>

<math display="block" id="Inductive_probability:60">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>H</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo>∣</mo>
    <msub>
     <mi>H</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo><</mo>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <lt></lt>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(H_{i})+L(F\mid H_{i})<L(F)
  </annotation>
 </semantics>
</math>

</p>

<p>and also the hypothesis R, that none of the hypothesis is true, then,</p>

<p>

<math display="block" id="Inductive_probability:61">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>H</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>H</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>∣</mo>
      <msub>
       <mi>H</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo stretchy="false">|</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>j</mi>
     </msub>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>H</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>∣</mo>
      <msub>
       <mi>H</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">R</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H_{i}\mid F)=\frac{P(H_{i})P(F\mid H_{i})}{P(F|R)+\sum_{j}{P(H_{j})P(F\mid H%
_{j})}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:62">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>∣</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>∣</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>j</mi>
     </msub>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>H</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>∣</mo>
      <msub>
       <mi>H</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">R</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">R</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(R\mid F)=\frac{P(F\mid R)}{P(F\mid R)+\sum_{j}{P(H_{j})P(F\mid H_{j})}}
  </annotation>
 </semantics>
</math>

</p>

<p>In terms of information,</p>

<p>

<math display="block" id="Inductive_probability:63">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>H</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>H</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>+</mo>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>F</mi>
        <mo>∣</mo>
        <msub>
         <mi>H</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>F</mi>
        <mo>∣</mo>
        <mi>R</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>j</mi>
      </msub>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>H</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>+</mo>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>F</mi>
          <mo stretchy="false">|</mo>
          <mo>∣</mo>
          <msub>
           <mi>H</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <minus></minus>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">L</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <plus></plus>
        <csymbol cd="unknown">L</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">F</csymbol>
         <ci>normal-∣</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <minus></minus>
        <csymbol cd="unknown">L</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">F</csymbol>
         <ci>normal-∣</ci>
         <csymbol cd="unknown">R</csymbol>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <minus></minus>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">L</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <ci>j</ci>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <plus></plus>
          <csymbol cd="unknown">L</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <csymbol cd="unknown">F</csymbol>
           <ci>normal-|</ci>
           <ci>normal-∣</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <ci>j</ci>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <ci>normal-)</ci>
         </cerror>
        </cerror>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H_{i}\mid F)=\frac{2^{-(L(H_{i})+L(F\mid H_{i}))}}{2^{-L(F\mid R)}+\sum_{j}{%
2^{-(L(H_{j})+L(F|\mid H_{j}))}}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:64">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>F</mi>
       <mo>∣</mo>
       <mi>R</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>F</mi>
        <mo>∣</mo>
        <mi>R</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>j</mi>
      </msub>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>H</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>+</mo>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>F</mi>
          <mo>∣</mo>
          <msub>
           <mi>H</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <minus></minus>
       <csymbol cd="unknown">L</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">F</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">R</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <minus></minus>
        <csymbol cd="unknown">L</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">F</csymbol>
         <ci>normal-∣</ci>
         <csymbol cd="unknown">R</csymbol>
         <ci>normal-)</ci>
        </cerror>
       </cerror>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <minus></minus>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">L</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <ci>j</ci>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <plus></plus>
          <csymbol cd="unknown">L</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <csymbol cd="unknown">F</csymbol>
           <ci>normal-∣</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <ci>j</ci>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <ci>normal-)</ci>
         </cerror>
        </cerror>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(R\mid F)=\frac{2^{-L(F\mid R)}}{2^{-L(F\mid R)}+\sum_{j}{2^{-(L(H_{j})+L(F%
\mid H_{j}))}}}
  </annotation>
 </semantics>
</math>

</p>

<p>In most situations it is a good approximation to assume that F is independent of R,</p>

<p>

<math display="block" id="Inductive_probability:65">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo>∣</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(F\mid R)=P(F)
  </annotation>
 </semantics>
</math>

</p>

<p>giving,</p>

<p>

<math display="block" id="Inductive_probability:66">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>H</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>H</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>+</mo>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>F</mi>
        <mo>∣</mo>
        <msub>
         <mi>H</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>F</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>j</mi>
      </msub>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>H</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>+</mo>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>F</mi>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>H</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <minus></minus>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">L</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <plus></plus>
        <csymbol cd="unknown">L</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">F</csymbol>
         <ci>normal-∣</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>F</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <minus></minus>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">L</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <ci>j</ci>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <plus></plus>
          <csymbol cd="unknown">L</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <csymbol cd="unknown">F</csymbol>
           <ci>normal-|</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <ci>j</ci>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <ci>normal-)</ci>
         </cerror>
        </cerror>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H_{i}\mid F)\approx\frac{2^{-(L(H_{i})+L(F\mid H_{i}))}}{2^{-L(F)}+\sum_{j}{%
2^{-(L(H_{j})+L(F|H_{j}))}}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:67">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>F</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>F</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>j</mi>
      </msub>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>H</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>+</mo>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>F</mi>
          <mo>∣</mo>
          <msub>
           <mi>H</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>F</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>F</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <minus></minus>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">L</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <ci>j</ci>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <plus></plus>
          <csymbol cd="unknown">L</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <ci>normal-(</ci>
           <csymbol cd="unknown">F</csymbol>
           <ci>normal-∣</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <ci>j</ci>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <ci>normal-)</ci>
         </cerror>
        </cerror>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(R\mid F)\approx\frac{2^{-L(F)}}{2^{-L(F)}+\sum_{j}{2^{-(L(H_{j})+L(F\mid H_{%
j}))}}}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="boolean-inductive-inference">Boolean inductive inference</h2>

<p><a href="Abductive_reasoning#Probabilistic_abduction" title="wikilink">Abductive inference</a> <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> starts with a set of facts <em>F</em> which is a statement (Boolean expression). <a href="Abductive_reasoning" title="wikilink">Abductive reasoning</a> is of the form,</p>
<dl>
<dd><em>A theory T implies the statement F. As the theory T is simpler than F, abduction says that there is a probability that the theory T is implied by F</em>.
</dd>
</dl>

<p>The theory <em>T</em>, also called an explanation of the condition <em>F</em>, is an answer to the ubiquitous factual "why" question. For example for the condition <em>F</em> is "Why do apples fall?". The answer is a theory <em>T</em> that implies that apples fall;</p>

<p>

<math display="block" id="Inductive_probability:68">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mfrac>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>m</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <msup>
      <mi>r</mi>
      <mn>2</mn>
     </msup>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>G</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=G\frac{m_{1}m_{2}}{r^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>Inductive inference is of the form,</p>
<dl>
<dd><em>All observed objects in a class C have a property P. Therefore there is a probability that all objects in a class C have a property P</em>.
</dd>
</dl>

<p>In terms of abductive inference, <em>all objects in a class C or set have a property P</em> is a theory that implies the observed condition, <em>All observed objects in a class C have a property P</em>.</p>

<p>So <a href="inductive_inference" title="wikilink">inductive inference</a> is a special case of abductive inference. In common usage the term inductive inference is often used to refer to both abductive and inductive inference.</p>
<h3 id="generalization-and-specialization">Generalization and specialization</h3>

<p>Inductive inference is related to <a class="uri" href="generalization" title="wikilink">generalization</a>. Generalizations may be formed from statements by replacing a specific value with membership of a category, or by replacing membership of a category with membership of a broader category. In deductive logic, generalization is a powerful method of generating new theories that may be true. In inductive inference generalization generates theories that have a probability of being true.</p>

<p>The opposite of generalization is specialization. Specialization is used in applying a general rule to a specific case. Specializations are created from generalizations by replacing membership of a category by a specific value, or by replacing a category with a sub category.</p>

<p>The <a href="Carl_Linnaeus" title="wikilink">Linnaen</a> classification of living things and objects forms the basis for generalization and specification. The ability to identify, recognize and classify is the basis for generalization. Perceiving the world as a collection of objects appears to be a key aspect of human intelligence. It is the object oriented model, in the non <a href="computer_science" title="wikilink">computer science</a> sense.</p>

<p>The object oriented model is constructed from our <a class="uri" href="perception" title="wikilink">perception</a>. In particularly <a href="Visual_perception" title="wikilink">vision</a> is based on the ability to compare two images and calculate how much information is needed to morph or map one image into another. <a href="Computer_vision" title="wikilink">Computer vision</a> uses this mapping to construct 3D images from <a href="Stereoscopy" title="wikilink">stereo image pairs</a>.</p>

<p><a href="Inductive_logic_programming" title="wikilink">Inductive logic programming</a> is a means of constructing theory that implies a condition. Plotkin's <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> "<em>relative least general generalization (rlgg)</em>" approach constructs the simplest generalization consistent with the condition.</p>
<h3 id="newtons-use-of-induction">Newton's use of induction</h3>

<p><a href="Isaac_Newton" title="wikilink">Isaac Newton</a> used inductive arguments in constructing his <a href="Newton's_law_of_universal_gravitation" title="wikilink">law of universal gravitation</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Starting with the statement,</p>
<ul>
<li>The center of an apple falls towards the center of the earth.</li>
</ul>

<p>Generalizing by replacing apple for object, and earth for object gives, in a two body system,</p>
<ul>
<li>The center of an object falls towards the center of another object.</li>
</ul>

<p>The theory explains all objects falling, so there is strong evidence for it. The second observation,</p>
<ul>
<li>The planets appear to follow an elliptical path.</li>
</ul>

<p>After some complicated mathematical <a class="uri" href="calculus" title="wikilink">calculus</a>, it can be seen that if the acceleration follows the inverse square law then objects will follow an ellipse. So induction gives evidence for the inverse square law.</p>

<p>Using <a href="Galileo_Galilei" title="wikilink">Galileo's</a> observation that all objects drop with the same speed,</p>

<p>

<math display="block" id="Inductive_probability:69">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>k</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <msup>
      <mi>r</mi>
      <mn>2</mn>
     </msup>
    </mfrac>
    <msub>
     <mi>i</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>r</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}=m_{1}a_{1}=\frac{m_{1}k_{1}}{r^{2}}i_{1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:70">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>k</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <msup>
      <mi>r</mi>
      <mn>2</mn>
     </msup>
    </mfrac>
    <msub>
     <mi>i</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>r</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{2}=m_{2}a_{2}=\frac{m_{2}k_{2}}{r^{2}}i_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Inductive_probability:71">
 <semantics>
  <msub>
   <mi>i</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Inductive_probability:72">
 <semantics>
  <msub>
   <mi>i</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{2}
  </annotation>
 </semantics>
</math>

 vectors towards the center of the other object. Then using <a href="Newton's_laws_of_motion#Newton's_third_law" title="wikilink">Newton's third law</a> 

<math display="inline" id="Inductive_probability:73">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>F</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}=-F_{2}
  </annotation>
 </semantics>
</math>


</p>

<p>

<math display="block" id="Inductive_probability:74">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mfrac>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>m</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <msup>
      <mi>r</mi>
      <mn>2</mn>
     </msup>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>G</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=G\frac{m_{1}m_{2}}{r^{2}}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="probabilities-for-inductive-inference">Probabilities for inductive inference</h3>

<p><a href="#Implication_and_condition_probability" title="wikilink">Implication determines condition probability</a> as,</p>

<p>

<math display="block" id="Inductive_probability:75">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>→</mo>
   <mi>F</mi>
   <mo>⇔</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo>∣</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\to F\iff P(F\mid T)=1
  </annotation>
 </semantics>
</math>

</p>

<p>So,</p>

<p>

<math display="block" id="Inductive_probability:76">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo>∣</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(F\mid T)=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:77">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo>∣</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(F\mid T)=0
  </annotation>
 </semantics>
</math>

</p>

<p>This result may be used in the probabilities given for Bayesian hypothesis testing. For a single theory, H = T and,</p>

<p>

<math display="block" id="Inductive_probability:78">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>F</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(T\mid F)=\frac{P(T)}{P(F)}
  </annotation>
 </semantics>
</math>

</p>

<p>or in terms of information, the relative probability is,</p>

<p>

<math display="block" id="Inductive_probability:79">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>F</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>F</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(T\mid F)=2^{-(L(T)-L(F))}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that this estimate for P(T|F) is not a true probability. If 

<math display="inline" id="Inductive_probability:80">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(T_{i})<L(F)
  </annotation>
 </semantics>
</math>

 then the theory has evidence to support it. Then for a set of theories 

<math display="inline" id="Inductive_probability:81">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>H</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{i}=H_{i}
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Inductive_probability:82">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(T_{i})<L(F)
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Inductive_probability:83">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>T</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>T</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>∣</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>j</mi>
     </msub>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>T</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">R</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(T_{i}\mid F)=\frac{P(T_{i})}{P(F\mid R)+\sum_{j}{P(T_{j})}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:84">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>∣</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo>∣</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>j</mi>
     </msub>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>T</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">R</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">R</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(R\mid F)=\frac{P(F\mid R)}{P(F\mid R)+\sum_{j}{P(T_{j})}}
  </annotation>
 </semantics>
</math>

</p>

<p>giving,</p>

<p>

<math display="block" id="Inductive_probability:85">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>T</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>T</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>F</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>j</mi>
      </msub>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>T</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>F</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>L</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>T</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(T_{i}\mid F)\approx\frac{2^{-L(T_{i})}}{2^{-L(F)}+\sum_{j}{2^{-L(T_{j})}}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:86">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>∣</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>F</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>F</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>j</mi>
      </msub>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>T</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>F</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>F</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>L</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>T</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(R\mid F)\approx\frac{2^{-L(F)}}{2^{-L(F)}+\sum_{j}{2^{-L(T_{j})}}}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="derivations">Derivations</h2>
<h3 id="derivation-of-inductive-probability">Derivation of inductive probability</h3>

<p>Make a list of all the shortest programs 

<math display="inline" id="Inductive_probability:87">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}
  </annotation>
 </semantics>
</math>

 that each produce a distinct infinite string of bits, and satisfy the relation,</p>

<p>

<math display="block" id="Inductive_probability:88">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>K</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{n}(R(K_{i}))=x
  </annotation>
 </semantics>
</math>

 where,</p>

<p>

<math display="block" id="Inductive_probability:89">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>K</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(K_{i})
  </annotation>
 </semantics>
</math>

 is the result of running the program 

<math display="inline" id="Inductive_probability:90">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Inductive_probability:91">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{n}
  </annotation>
 </semantics>
</math>

 truncates the string after <em>n</em> bits.</p>

<p>The problem is to calculate the probability that the source is produced by program 

<math display="inline" id="Inductive_probability:92">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}
  </annotation>
 </semantics>
</math>

, given that the truncated source after n bits is <em>x</em>. This is represented by the conditional probability,</p>

<p>

<math display="block" id="Inductive_probability:93">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(s=R(K_{i})\mid T_{n}(s)=x)
  </annotation>
 </semantics>
</math>

</p>

<p>Using the <a href="Bayes'_theorem#Extended_form" title="wikilink">extended form of Bayes' theorem</a></p>

<p>

<math display="block" id="Inductive_probability:94">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>∣</mo>
      <msub>
       <mi>A</mi>
       <mi>i</mi>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>A</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>∣</mo>
      <msub>
       <mi>A</mi>
       <mi>j</mi>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>A</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>⋅</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <ci>normal-⋅</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A_{i}\mid B)=\frac{P(B\mid A_{i})\,P(A_{i})}{\sum\limits_{j}P(B\mid A_{j})\,%
P(A_{j})}\cdot
  </annotation>
 </semantics>
</math>

 where,</p>

<p>

<math display="block" id="Inductive_probability:95">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=(T_{n}(s)=x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Inductive_probability:96">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}=(s=R(K_{i}))
  </annotation>
 </semantics>
</math>

</p>

<p>The extended form relies on the <a href="law_of_total_probability" title="wikilink">law of total probability</a>. This means that the 

<math display="inline" id="Inductive_probability:97">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 must be distinct possibilities, which is given by the condition that each 

<math display="inline" id="Inductive_probability:98">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}
  </annotation>
 </semantics>
</math>


 produce a different infinite string. Also one of the conditions 

<math display="inline" id="Inductive_probability:99">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 must be true. This must be true, as in the limit as <em>n</em> tends to infinity, there is always at least one program that produces 

<math display="inline" id="Inductive_probability:100">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{n}(s)
  </annotation>
 </semantics>
</math>

.</p>

<p>Then using the extended form and substituting for 

<math display="inline" id="Inductive_probability:101">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Inductive_probability:102">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 gives,</p>

<p>

<math display="block" id="Inductive_probability:103">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>T</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>=</mo>
      <mi>x</mi>
      <mo>∣</mo>
      <mi>s</mi>
      <mo>=</mo>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>K</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>=</mo>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>K</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>T</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>=</mo>
      <mi>x</mi>
      <mo>∣</mo>
      <mi>s</mi>
      <mo>=</mo>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>K</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>=</mo>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>K</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>⋅</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>n</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">s</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <eq></eq>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">s</csymbol>
       <eq></eq>
       <csymbol cd="unknown">R</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">s</csymbol>
       <eq></eq>
       <csymbol cd="unknown">R</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>n</ci>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">s</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <eq></eq>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">s</csymbol>
       <eq></eq>
       <csymbol cd="unknown">R</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>j</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">s</csymbol>
       <eq></eq>
       <csymbol cd="unknown">R</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>j</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <ci>normal-⋅</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(s=R(K_{i})\mid T_{n}(s)=x)=\frac{P(T_{n}(s)=x\mid s=R(K_{i}))\,P(s=R(K_{i}))%
}{\sum\limits_{j}P(T_{n}(s)=x\mid s=R(K_{j}))\,P(s=R(K_{j}))}\cdot
  </annotation>
 </semantics>
</math>

</p>

<p>As 

<math display="inline" id="Inductive_probability:104">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}
  </annotation>
 </semantics>
</math>

 are chosen so that 

<math display="inline" id="Inductive_probability:105">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>K</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{n}(R(K_{i}))=x
  </annotation>
 </semantics>
</math>

, then,</p>

<p>

<math display="block" id="Inductive_probability:106">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
    <mo>∣</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(T_{n}(s)=x\mid s=R(K_{i}))=1
  </annotation>
 </semantics>
</math>

</p>

<p>The a-priori probability of the string being produced from the program, given no information about the string, is based on the size of the program,</p>

<p>

<math display="block" id="Inductive_probability:107">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>K</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>I</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(s=R(K_{i}))=2^{-I(K_{i})}
  </annotation>
 </semantics>
</math>

</p>

<p>giving,</p>

<p>

<math display="block" id="Inductive_probability:108">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>K</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>K</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mfrac>
   <mo>⋅</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <csymbol cd="unknown">R</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>I</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>K</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>normal-⋅</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(s=R(K_{i})\mid T_{n}(s)=x)=\frac{2^{-I(K_{i})}}{\sum\limits_{j}2^{-I(K_{j})}}\cdot
  </annotation>
 </semantics>
</math>

</p>

<p>Programs that are the same or longer than the length of <em>x</em> provide no predictive power. Separate them out giving,</p>

<p>

<math display="inline" id="Inductive_probability:109">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>K</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>≥</mo>
       <mi>n</mi>
      </mrow>
     </mrow>
    </munder>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>K</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>j</ci>
       <apply>
        <geq></geq>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>K</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>I</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sum\limits_{j:I(K_{j})>=n}2^{-I(K_{j})}
  </annotation>
 </semantics>
</math>

</p>

<p>Then identify the two probabilities as,</p>
<dl>
<dd>Probability that <em>x</em> has a pattern <math>= \sum\limits_{j:I(K_j)<n} 2^{-i(k_j)}="" <="" math=""></n}></math></dd>
</dl>

<p>The opposite of this,</p>
<dl>
<dd>Probability that <em>x</em> is a random set of bits 

<math display="inline" id="Inductive_probability:110">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-n}
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>But the prior probability that <em>x</em> is a random set of bits is 

<math display="block" id="Inductive_probability:111">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=R(c)
  </annotation>
 </semantics>
</math>

. So,</p>

<p>

<math display="inline" id="Inductive_probability:112">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(x)
  </annotation>
 </semantics>
</math>

 is true. An <a href="intelligent_agent" title="wikilink">intelligent agent</a> has some facts about the word, represented by the bit string <em>c</em>, which gives the condition,</p>

<p>

<math display="block" id="Inductive_probability:113">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>w</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≡</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>x</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>w</ci>
     <apply>
      <equivalent></equivalent>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>w</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,E(x)=\{w:R(w)\equiv x\}
  </annotation>
 </semantics>
</math>

</p>

<p>The set of bit strings identical with any condition <em>x</em> is 

<math display="block" id="Inductive_probability:114">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>t</mi>
    <mo>:</mo>
    <mrow>
     <mi>t</mi>
     <mo>→</mo>
     <mi>C</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>t</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>t</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(C)=\{t:t\to C\}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Inductive_probability:115">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>∣</mo>
      <msub>
       <mi>A</mi>
       <mi>i</mi>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>A</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>∣</mo>
      <msub>
       <mi>A</mi>
       <mi>j</mi>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>A</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>⋅</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <ci>normal-⋅</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A_{i}\mid B)=\frac{P(B\mid A_{i})\,P(A_{i})}{\sum\limits_{j}P(B\mid A_{j})\,%
P(A_{j})}\cdot
  </annotation>
 </semantics>
</math>

</p>

<p>A theory is a simpler condition that explains (or implies) <em>C</em>. The set of all such theories is called <em>T</em>,</p>

<p>

<math display="block" id="Inductive_probability:116">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=E(C)
  </annotation>
 </semantics>
</math>

</p>
<h4 id="applying-bayes-theorem">Applying Bayes' theorem</h4>

<p><a href="Bayes'_theorem#Extended_form" title="wikilink">extended form of Bayes' theorem</a> may be applied</p>

<p>

<math display="block" id="Inductive_probability:117">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}=E(t)
  </annotation>
 </semantics>
</math>

 where,</p>

<p>

<math display="inline" id="Inductive_probability:118">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>


</p>

<p>

<math display="inline" id="Inductive_probability:119">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(C)
  </annotation>
 </semantics>
</math>

</p>

<p>To apply Bayes' theorem the following must hold,</p>
<ul>
<li>

<math display="block" id="Inductive_probability:120">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>∈</mo>
   <mrow>
    <mi>T</mi>
    <mi mathvariant="italic">and</mi>
    <mi>N</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mi>N</mi>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mi>n</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi>n</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>N</ci>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>italic- and</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>italic- and</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <neq></neq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>italic- and</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>N</ci>
      <ci>italic- and</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\in T\and N\in M\and N\neq M\and n\in E(N)\and n\in E(M)
  </annotation>
 </semantics>
</math>

 is a <a href="partition_of_a_set" title="wikilink">partition</a> of the event space.</li>
</ul>

<p>For 

<math display="block" id="Inductive_probability:121">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⟹</mo>
   <mi>N</mi>
   <mo>≠</mo>
   <mrow>
    <mi>M</mi>
    <mi mathvariant="italic">and</mi>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>N</mi>
    <mi mathvariant="italic">and</mi>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <csymbol cd="latexml">absent</csymbol>
     <ci>N</ci>
    </apply>
    <apply>
     <neq></neq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>italic- and</ci>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>italic- and</ci>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \implies N\neq M\and R(n)\equiv N\and R(n)\equiv M
  </annotation>
 </semantics>
</math>

 to be a partition, no bit string <em>n</em> may belong to two theories. To prove this assume they can and derive a contradiction,</p>

<p>

<math display="block" id="Inductive_probability:122">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⟹</mo>
   <mo>false</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <implies></implies>
    <csymbol cd="latexml">absent</csymbol>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \implies\operatorname{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Inductive_probability:123">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(w)
  </annotation>
 </semantics>
</math>


</p>

<p>

<math display="block" id="Inductive_probability:124">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∣</mo>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mrow>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>C</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∣</mo>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <in></in>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">E</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">t</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">E</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">E</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">t</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <apply>
         <times></times>
         <ci>T</ci>
         <ci>C</ci>
        </apply>
       </apply>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">E</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">j</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">E</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-∣</ci>
       <csymbol cd="unknown">E</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">j</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T(C),P(E(t)\mid E(C))=\frac{P(E(t))\cdot P(E(C)\mid E(t))}{\sum_{%
j\in T(C)}P(E(j))\cdot P(E(C)\mid E(j))}
  </annotation>
 </semantics>
</math>

</p>

<p>Secondly prove that <em>T</em> includes all outcomes consistent with the condition. As all theories consistent with <em>C</em> are included then 

<math display="inline" id="Inductive_probability:125">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(C)
  </annotation>
 </semantics>
</math>

 must be in this set.</p>

<p>So Bayes theorem may be applied as specified giving,</p>

<p>

<math display="block" id="Inductive_probability:126">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <in></in>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T(C),P(E(C)\mid E(t))=1
  </annotation>
 </semantics>
</math>

</p>

<p>Using the <a href="#Implication_and_condition_probability" title="wikilink">implication and condition probability law</a>, the definition of 

<math display="block" id="Inductive_probability:127">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>t</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>:</mo>
       <mrow>
        <mrow>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≡</mo>
        <mi>t</mi>
       </mrow>
      </mrow>
     </munder>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <ci>normal-:</ci>
        <ci>n</ci>
        <apply>
         <equivalent></equivalent>
         <apply>
          <times></times>
          <ci>R</ci>
          <ci>n</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T(C),P(E(t))=\sum_{n:R(n)\equiv t}2^{-L(n)}
  </annotation>
 </semantics>
</math>

 implies,</p>

<p>

<math display="block" id="Inductive_probability:128">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>:</mo>
       <mrow>
        <mrow>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≡</mo>
        <mi>t</mi>
       </mrow>
      </mrow>
     </msub>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mrow>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>C</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mo>:</mo>
       <mrow>
        <mrow>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≡</mo>
        <mi>j</mi>
       </mrow>
      </mrow>
     </msub>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>m</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <in></in>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <ci>normal-:</ci>
        <ci>n</ci>
        <apply>
         <equivalent></equivalent>
         <apply>
          <times></times>
          <ci>R</ci>
          <ci>n</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <apply>
         <times></times>
         <ci>T</ci>
         <ci>C</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <ci>normal-:</ci>
        <ci>m</ci>
        <apply>
         <equivalent></equivalent>
         <apply>
          <times></times>
          <ci>R</ci>
          <ci>m</ci>
         </apply>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T(C),P(E(t)\mid E(C))=\frac{\sum_{n:R(n)\equiv t}2^{-L(n)}}{\sum_%
{j\in T(C)}\sum_{m:R(m)\equiv j}2^{-L(m)})}
  </annotation>
 </semantics>
</math>

</p>

<p>The probability of each theory in T is given by,</p>

<p>

<math display="block" id="Inductive_probability:129">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>∣</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <in></in>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T(C),P(E(t)\mid E(C))=P(t\mid C)
  </annotation>
 </semantics>
</math>

</p>

<p>so,</p>

<p>

<math display="block" id="Inductive_probability:130">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>∣</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>:</mo>
       <mrow>
        <mrow>
         <mi>R</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≡</mo>
        <mi>t</mi>
       </mrow>
      </mrow>
     </msub>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mrow>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>C</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>m</mi>
        <mo>:</mo>
        <mrow>
         <mrow>
          <mi>R</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>m</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>≡</mo>
         <mi>j</mi>
        </mrow>
       </mrow>
      </msub>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>m</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <in></in>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <ci>normal-:</ci>
        <ci>n</ci>
        <apply>
         <equivalent></equivalent>
         <apply>
          <times></times>
          <ci>R</ci>
          <ci>n</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <apply>
         <times></times>
         <ci>T</ci>
         <ci>C</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>m</ci>
         <apply>
          <equivalent></equivalent>
          <apply>
           <times></times>
           <ci>R</ci>
           <ci>m</ci>
          </apply>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>L</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T(C),P(t\mid C)=\frac{\sum_{n:R(n)\equiv t}2^{-L(n)}}{\sum_{j\in T%
(C)}\sum_{m:R(m)\equiv j}2^{-L(m)}}
  </annotation>
 </semantics>
</math>

</p>

<p>Finally the probabilities of the events may be identified with the probabilities of the condition which the outcomes in the event satisfy,</p>

<p>

<math display="block" id="Inductive_probability:131">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>∣</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>:</mo>
         <mrow>
          <mi>j</mi>
          <mo>∈</mo>
          <mrow>
           <mi>T</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>C</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi mathvariant="italic">and</mi>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>E</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>j</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>></mo>
          <mrow>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>E</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>C</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </msub>
       <mrow>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>E</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>j</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>:</mo>
         <mrow>
          <mi>j</mi>
          <mo>∈</mo>
          <mrow>
           <mi>T</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>C</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi mathvariant="italic">and</mi>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>E</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>j</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>≤</mo>
          <mrow>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>E</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>C</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </msub>
       <mrow>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>j</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <in></in>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <and></and>
          <apply>
           <in></in>
           <ci>j</ci>
           <apply>
            <times></times>
            <ci>T</ci>
            <ci>C</ci>
            <ci>italic- and</ci>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>E</ci>
             <ci>j</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <gt></gt>
           <share href="#.cmml">
           </share>
           <apply>
            <times></times>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>E</ci>
             <ci>C</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <and></and>
          <apply>
           <in></in>
           <ci>j</ci>
           <apply>
            <times></times>
            <ci>T</ci>
            <ci>C</ci>
            <ci>italic- and</ci>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>E</ci>
             <ci>j</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <leq></leq>
           <share href="#.cmml">
           </share>
           <apply>
            <times></times>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>E</ci>
             <ci>C</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T(C),P(t\mid C)=\frac{P(E(t))}{(\sum_{j:j\in T(C)\and P(E(j))>P(E%
(C))}P(E(j)))+(\sum_{j:j\in T(C)\and P(E(j))\leq P(E(C))}P(j))}
  </annotation>
 </semantics>
</math>

</p>

<p>giving</p>

<p>

<math display="block" id="Inductive_probability:132">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>:</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mrow>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>C</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi mathvariant="italic">and</mi>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>E</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>j</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>≤</mo>
       <mrow>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>E</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>C</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>j</ci>
       <apply>
        <and></and>
        <apply>
         <in></in>
         <ci>j</ci>
         <apply>
          <times></times>
          <ci>T</ci>
          <ci>C</ci>
          <ci>italic- and</ci>
          <ci>P</ci>
          <apply>
           <times></times>
           <ci>E</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <apply>
          <times></times>
          <ci>P</ci>
          <apply>
           <times></times>
           <ci>E</ci>
           <ci>C</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(E(C))=\sum_{j:j\in T(C)\and P(E(j))\leq P(E(C))}P(j)
  </annotation>
 </semantics>
</math>

</p>

<p>This is the probability of the theory <em>t</em> after observing that the condition <em>C</em> holds.</p>
<h4 id="removing-theories-without-predictive-power">Removing theories without predictive power</h4>

<p>Theories that are less probable than the condition <em>C</em> have no predictive power. Separate them out giving,</p>

<p>

<math display="block" id="Inductive_probability:133">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>∣</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>C</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>:</mo>
        <mrow>
         <mi>j</mi>
         <mo>∈</mo>
         <mrow>
          <mi>T</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>C</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi mathvariant="italic">and</mi>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>E</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>j</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>></mo>
         <mrow>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>E</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>C</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>E</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <in></in>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>E</ci>
        <ci>C</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <and></and>
          <apply>
           <in></in>
           <ci>j</ci>
           <apply>
            <times></times>
            <ci>T</ci>
            <ci>C</ci>
            <ci>italic- and</ci>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>E</ci>
             <ci>j</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <gt></gt>
           <share href="#.cmml">
           </share>
           <apply>
            <times></times>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>E</ci>
             <ci>C</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T(C),P(t\mid C)=\frac{P(E(t))}{P(E(C))+\sum_{j:j\in T(C)\and P(E(%
j))>P(E(C))}P(E(j))}
  </annotation>
 </semantics>
</math>

</p>

<p>The probability of the theories without predictive power on <em>C</em> is the same as the probability of <em>C</em>. So,</p>

<p>

<math display="inline" id="Inductive_probability:134">
 <semantics>
  <mrow>
   <mo>random</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>random</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{random}(C)
  </annotation>
 </semantics>
</math>

</p>

<p>So the probability</p>

<p>

<math display="block" id="Inductive_probability:135">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>random</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>C</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>:</mo>
        <mrow>
         <mi>j</mi>
         <mo>∈</mo>
         <mrow>
          <mi>T</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>C</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi mathvariant="italic">and</mi>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>E</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>j</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>></mo>
         <mrow>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>E</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>C</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>E</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>random</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>E</ci>
        <ci>C</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <and></and>
          <apply>
           <in></in>
           <ci>j</ci>
           <apply>
            <times></times>
            <ci>T</ci>
            <ci>C</ci>
            <ci>italic- and</ci>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>E</ci>
             <ci>j</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <gt></gt>
           <share href="#.cmml">
           </share>
           <apply>
            <times></times>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>E</ci>
             <ci>C</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\operatorname{random}(C)\mid C)=\frac{P(E(C))}{P(E(C))+\sum_{j:j\in T(C)\and
P%
(E(j))>P(E(C))}P(E(j))}
  </annotation>
 </semantics>
</math>

</p>

<p>and the probability of no prediction for C, written as 

<math display="block" id="Inductive_probability:136">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>t</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>R</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>≡</mo>
       <mi>t</mi>
      </mrow>
     </mrow>
    </munder>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>n</ci>
       <apply>
        <equivalent></equivalent>
        <apply>
         <times></times>
         <ci>R</ci>
         <ci>n</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t,P(E(t))=\sum_{n:R(n)\equiv t}2^{-L(n)}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Inductive_probability:137">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>t</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>R</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>≡</mo>
       <mrow>
        <mi>t</mi>
        <mi mathvariant="italic">and</mi>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo><</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </munder>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <interval closure="open">
        <ci>t</ci>
        <ci>c</ci>
       </interval>
      </apply>
     </apply>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>n</ci>
       <apply>
        <and></and>
        <apply>
         <equivalent></equivalent>
         <apply>
          <times></times>
          <ci>R</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <times></times>
          <ci>t</ci>
          <ci>italic- and</ci>
          <ci>L</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <lt></lt>
         <share href="#.cmml">
         </share>
         <apply>
          <times></times>
          <ci>L</ci>
          <ci>c</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t,P(F(t,c))=\sum_{n:R(n)\equiv t\and L(n)<L(c)}2^{-L(n)}
  </annotation>
 </semantics>
</math>

</p>

<p>The probability of a condition was given as,</p>

<p>

<math display="block" id="Inductive_probability:138">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>∣</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>C</mi>
         <mo>,</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>:</mo>
        <mrow>
         <mi>j</mi>
         <mo>∈</mo>
         <mrow>
          <mi>T</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>C</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi mathvariant="italic">and</mi>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>F</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>j</mi>
             <mo>,</mo>
             <mi>c</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>></mo>
         <mrow>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>F</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>C</mi>
             <mo>,</mo>
             <mi>c</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>E</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>j</mi>
          <mo>,</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <in></in>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <interval closure="open">
        <ci>t</ci>
        <ci>c</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>F</ci>
        <interval closure="open">
         <ci>C</ci>
         <ci>c</ci>
        </interval>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <and></and>
          <apply>
           <in></in>
           <ci>j</ci>
           <apply>
            <times></times>
            <ci>T</ci>
            <ci>C</ci>
            <ci>italic- and</ci>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>F</ci>
             <interval closure="open">
              <ci>j</ci>
              <ci>c</ci>
             </interval>
            </apply>
           </apply>
          </apply>
          <apply>
           <gt></gt>
           <share href="#.cmml">
           </share>
           <apply>
            <times></times>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>F</ci>
             <interval closure="open">
              <ci>C</ci>
              <ci>c</ci>
             </interval>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>E</ci>
         <interval closure="open">
          <ci>j</ci>
          <ci>c</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\in T(C),P(t\mid C)=\frac{P(F(t,c))}{P(F(C,c))+\sum_{j:j\in T(C)\and P%
(F(j,c))>P(F(C,c))}P(E(j,c))}
  </annotation>
 </semantics>
</math>

</p>

<p>Bit strings for theories that are more complex than the bit string given to the agent as input have no predictive power. There probabilities are better included in the <em>random</em> case. To implement this a new definition is given as <em>F</em> in,</p>

<p>

<math display="block" id="Inductive_probability:139">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>random</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>C</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>C</mi>
         <mo>,</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>:</mo>
        <mrow>
         <mi>j</mi>
         <mo>∈</mo>
         <mrow>
          <mi>T</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>C</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi mathvariant="italic">and</mi>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>F</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>j</mi>
             <mo>,</mo>
             <mi>c</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>></mo>
         <mrow>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>F</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>C</mi>
             <mo>,</mo>
             <mi>c</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>j</mi>
          <mo>,</mo>
          <mi>c</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>random</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <interval closure="open">
        <ci>C</ci>
        <ci>c</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>F</ci>
        <interval closure="open">
         <ci>C</ci>
         <ci>c</ci>
        </interval>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <and></and>
          <apply>
           <in></in>
           <ci>j</ci>
           <apply>
            <times></times>
            <ci>T</ci>
            <ci>C</ci>
            <ci>italic- and</ci>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>F</ci>
             <interval closure="open">
              <ci>j</ci>
              <ci>c</ci>
             </interval>
            </apply>
           </apply>
          </apply>
          <apply>
           <gt></gt>
           <share href="#.cmml">
           </share>
           <apply>
            <times></times>
            <ci>P</ci>
            <apply>
             <times></times>
             <ci>F</ci>
             <interval closure="open">
              <ci>C</ci>
              <ci>c</ci>
             </interval>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>F</ci>
         <interval closure="open">
          <ci>j</ci>
          <ci>c</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\operatorname{random}(C)\mid C)=\frac{P(F(C,c))}{P(F(C,c))+\sum_{j:j\in T(C)%
\and P(F(j,c))>P(F(C,c))}P(F(j,c))}
  </annotation>
 </semantics>
</math>

</p>

<p>Using <em>F</em>, an improved version of the abductive probabilities is,</p>

<p><span class="LaTeX">$$\forall t \in T(C), P(t \mid C) = \frac{P(F(t, c))}{P(F(C, c)) + \sum_{j : j \in T(C) \and P(F(j, c)) &gt; P(F(C, c))} P(E(j, c))}$$</span></p>

<p><span class="LaTeX">$$P(\operatorname{random}(C) \mid C) = \frac{P(F(C, c))}{P(F(C, c)) + \sum_{j : j \in T(C) \and P(F(j, c)) &gt; P(F(C, c))} P(F(j, c))}$$</span></p>
<h2 id="key-people">Key people</h2>
<ul>
<li><a href="William_of_Ockham" title="wikilink">William of Ockham</a></li>
<li><a href="Thomas_Bayes" title="wikilink">Thomas Bayes</a></li>
<li><a href="Ray_Solomonoff" title="wikilink">Ray Solomonoff</a></li>
<li><a href="Andrey_Kolmogorov" title="wikilink">Andrey Kolmogorov</a></li>
<li><a href="Chris_Wallace_(computer_scientist)" title="wikilink">Chris Wallace</a></li>
<li>D. M. Boulton</li>
<li><a href="Jorma_Rissanen" title="wikilink">Jorma Rissanen</a></li>
<li><a href="Marcus_Hutter" title="wikilink">Marcus Hutter</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Abductive_reasoning" title="wikilink">Abductive reasoning</a></li>
<li><a href="Algorithmic_probability" title="wikilink">Algorithmic probability</a></li>
<li><a href="Algorithmic_information_theory" title="wikilink">Algorithmic information theory</a></li>
<li><a href="Bayesian_inference" title="wikilink">Bayesian inference</a></li>
<li><a href="Information_theory" title="wikilink">Information theory</a></li>
<li><a href="Inductive_inference" title="wikilink">Inductive inference</a></li>
<li><a href="Inductive_logic_programming" title="wikilink">Inductive logic programming</a></li>
<li><a href="Inductive_reasoning" title="wikilink">Inductive reasoning</a></li>
<li><a class="uri" href="Learning" title="wikilink">Learning</a></li>
<li><a href="Minimum_message_length" title="wikilink">Minimum message length</a></li>
<li><a href="Minimum_description_length" title="wikilink">Minimum description length</a></li>
<li><a href="Occam's_razor" title="wikilink">Occam's razor</a></li>
<li><a href="Solomonoff's_theory_of_inductive_inference" title="wikilink">Solomonoff's theory of inductive inference</a></li>
<li><a href="Universal_artificial_intelligence" title="wikilink">Universal artificial intelligence</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li>Rathmanner, S and Hutter, M., "A Philosophical Treatise of Universal Induction" in Entropy 2011, 13, 1076–1136: A very clear philosophical and mathematical analysis of Solomonoff's Theory of Inductive Inference.</li>
<li><a href="Chris_Wallace_(computer_scientist)" title="wikilink">C.S. Wallace</a>, <a href="http://www.springeronline.com/sgw/cda/frontpage/0,11855,4-10129-22-35893962-0,00.html">Statistical and Inductive Inference by Minimum Message Length</a>, Springer-Verlag (Information Science and Statistics), ISBN 0-387-23795-X, May 2005 – <a href="http://www.springer.com/west/home/statistics/theory?SGWID=4-10129-22-35893962-detailsPage=ppmmedia|toc">chapter headings</a>, <a href="http://www.csse.monash.edu.au/mml/toc.pdf">table of contents</a> and [<a class="uri" href="http://books.google.com/books?ie=ISO-8859-1&amp;id">http://books.google.com/books?ie=ISO-8859-1&amp;id;</a>;=3NmFwNHaNbUC&amp;q;=wallace+%22statistical+and+inductive+inference+by+minimum+message+length%22&amp;dq;=wallace+%22statistical+and+inductive+inference+by+minimum+message+length%22 sample pages].</li>
</ul>

<p>"</p>

<p><a href="Category:Statistical_inference" title="wikilink">Category:Statistical inference</a> <a href="Category:Inductive_reasoning" title="wikilink">Category:Inductive reasoning</a> <a class="uri" href="Category:Inference" title="wikilink">Category:Inference</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a> <a class="uri" href="Category:Probability" title="wikilink">Category:Probability</a> <a href="Category:Probability_and_statistics" title="wikilink">Category:Probability and statistics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Li, M. and Vitanyi, P., <em>An Introduction to Kolmogorov Complexity and Its Applications</em>, 3rd Edition, Springer Science and Business Media, N.Y., 2008, p 347<a href="#fnref5">↩</a></li>
<li id="fn6">Solomonoff, R., "<a href="http://world.std.com/~rjs/rayfeb60.pdf">A Preliminary Report on a General Theory of Inductive Inference</a>", Report V-131, Zator Co., Cambridge, Ma. Feb 4, 1960, <a href="http://world.std.com/~rjs/z138.pdf">revision</a>, Nov., 1960.<a href="#fnref6">↩</a></li>
<li id="fn7">Solomonoff, R., "<a href="http://world.std.com/~rjs/1964pt1.pdf">A Formal Theory of Inductive Inference, Part I</a>" <em>Information and Control</em>, Vol 7, No. 1 pp 1–22, March 1964.<a href="#fnref7">↩</a></li>
<li id="fn8">Solomonoff, R., "<a href="http://world.std.com/~rjs/1964pt2.pdf">A Formal Theory of Inductive Inference, Part II</a>" <em>Information and Control</em>, Vol 7, No. 2 pp 224–254, June 1964.<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">Isaac Newton: "In [experimental] philosophy particular propositions are inferred from the phenomena and afterwards rendered general by induction": "<a href="Philosophiae_Naturalis_Principia_Mathematica" title="wikilink">Principia</a>", Book 3, General Scholium, at p.392 in Volume 2 of Andrew Motte's English translation published 1729.<a href="#fnref17">↩</a></li>
</ol>
</section>
</body>
</html>
