<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1732">Addition chain</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Addition chain</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, an <strong>addition chain</strong> for computing a positive integer <em>n</em> can be given by a <a class="uri" href="sequence" title="wikilink">sequence</a> of <a href="natural_number" title="wikilink">natural numbers</a> <em>v</em> and a sequence of index pairs <em>w</em> such that each term in <em>v</em> is the sum of two previous terms, the indices of those terms being specified by <em>w</em>:</p>
<dl>
<dd><em>v</em> =(<em>v</em><sub>0</sub>,...,<em>v</em><sub><em>s</em></sub>), with <em>v</em><sub>0</sub> = 1 and <em>v</em><sub><em>s</em></sub> = <em>n</em>
</dd>
<dd>for each 0<em>i</em> = <em>v</em><sub><em>j</em></sub> + <em>v</em><sub><em>k</em></sub>, with <em>w</em><sub><em>i</em></sub>=(<em>j,k</em>) and 0 ≤ <em>j,k</em> ≤ <em>i</em> − 1
</dd>
</dl>

<p>Often only <em>v</em> is given since it is easy to extract <em>w</em> from <em>v</em>, but sometimes <em>w</em> is not uniquely reconstructible. An introduction is given by <a href="Donald_Knuth" title="wikilink">Knuth</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="examples">Examples</h2>

<p>As an example: <em>v</em> = (1,2,3,6,12,24,30,31) is an addition chain for 31 of length 7, since</p>
<dl>
<dd>2 = 1 + 1
</dd>
<dd>3 = 2 + 1
</dd>
<dd>6 = 3 + 3
</dd>
<dd>12 = 6 + 6
</dd>
<dd>24 = 12 + 12
</dd>
<dd>30 = 24 + 6
</dd>
<dd>31 = 30 + 1
</dd>
</dl>

<p>Addition chains can be used for <a href="addition-chain_exponentiation" title="wikilink">addition-chain exponentiation</a>: so for example we only need 7 <a href="multiplication" title="wikilink">multiplications</a> to calculate 5<sup>31</sup>:</p>
<dl>
<dd>5<sup>2</sup> = 5<sup>1</sup> × 5<sup>1</sup>
</dd>
<dd>5<sup>3</sup> = 5<sup>2</sup> × 5<sup>1</sup>
</dd>
<dd>5<sup>6</sup> = 5<sup>3</sup> × 5<sup>3</sup>
</dd>
<dd>5<sup>12</sup> = 5<sup>6</sup> × 5<sup>6</sup>
</dd>
<dd>5<sup>24</sup> = 5<sup>12</sup> × 5<sup>12</sup>
</dd>
<dd>5<sup>30</sup> = 5<sup>24</sup> × 5<sup>6</sup>
</dd>
<dd>5<sup>31</sup> = 5<sup>30</sup> × 5<sup>1</sup>
</dd>
</dl>
<h2 id="methods-for-computing-addition-chains">Methods for computing addition chains</h2>

<p>Calculating an addition chain of minimal length is not easy; a generalized version of the problem, in which one must find a chain that simultaneously forms each of a sequence of values, is NP-complete.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> There is no known algorithm which can calculate a minimal addition chain for a given number with any guarantees of reasonable timing or small memory usage. However, several techniques to calculate relatively short chains exist. One very well known technique to calculate relatively short addition chains is the <em>binary method</em>, similar to <a href="exponentiation_by_squaring" title="wikilink">exponentiation by squaring</a>. Other well-known methods are the <em>factor method</em> and <em>window method</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="chain-length">Chain length</h2>

<p>Let 

<math display="inline" id="Addition_chain:0">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(n)
  </annotation>
 </semantics>
</math>

 denote the smallest <em>s</em> so that there exists an addition chain of length <em>s</em> which computes <em>n</em>. It is known that <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>

<math display="block" id="Addition_chain:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>ν</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>2.13</mn>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mi>o</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>log</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <ci>ν</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <cn type="float">2.13</cn>
     </apply>
     <apply>
      <times></times>
      <ci>l</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>o</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}(n)+\log_{2}(\nu(n))-2.13\leq l(n)\leq\log_{2}(n)+\log_{2}(n)(1+o(1))/%
\log_{2}(\log_{2}(n))
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Addition_chain:2">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ν</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(n)
  </annotation>
 </semantics>
</math>

 is <a href="Hamming_weight" title="wikilink">Hamming weight</a> of binary expansion of <em>n</em>.</p>

<p>It is clear that <em>l</em>(2<em>n</em>) ≤ <em>l</em>(<em>n</em>)+1. Strict inequality is possible, as <em>l</em>(382) = <em>l</em>(191) = 11, observed by Knuth.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The first integer with <em>l</em>(2<em>n</em>) </p>
<h2 id="brauer-chain">Brauer chain</h2>

<p>A <strong>Brauer chain</strong> or <strong>star addition chain</strong> is an addition chain in which one of the summands is always the previous chain: that is,</p>
<dl>
<dd>for each <em>k</em>&gt;0: <em>a</em><sub><em>k</em></sub> = <em>a</em><sub><em>k-1</em></sub> + <em>a</em><sub><em>j</em></sub> for some <em>j</em> &lt; <em>k</em>.
</dd>
</dl>

<p>A <strong>Brauer number</strong> is one for which the Brauer chain is minimal.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Brauer proved that</p>
<dl>
<dd><em>l</em>*(2<sup><em>n</em></sup>−1) ≤ <em>n</em> − 1 + <em>l</em>*(<em>n</em>)
</dd>
</dl>

<p>where <em>l</em>* is the length of the shortest star chain. For many values of <em>n</em>,and in particular for <em>n</em> ≤ 2500, they are equal: <em>l</em>(<em>n</em>) = <em>l</em>*(<em>n</em>). But Hansen showed that there are some values of <em>n</em> for which <em>l</em>(<em>n</em>) ≠ <em>l</em>*(<em>n</em>), such as <em>n</em> = 2<sup>6106</sup> + 2<sup>3048</sup> + 2<sup>2032</sup> + 2<sup>2016</sup> + 1 which has <em>l</em>*(<em>n</em>) = 6110, <em>l</em>(<em>n</em>) ≤ 6109.</p>
<h2 id="scholz-conjecture">Scholz conjecture</h2>

<p>The <a href="Scholz_conjecture" title="wikilink">Scholz conjecture</a> (sometimes called the <em>Scholz–Brauer</em> or <em>Brauer–Scholz conjecture</em>), named after <a href="A._Scholz" title="wikilink">A. Scholz</a> and Alfred T. Brauer), is a <a class="uri" href="conjecture" title="wikilink">conjecture</a> from 1937 stating that</p>
<dl>
<dd><em>l</em>(2<sup><em>n</em></sup> − 1) ≤ <em>n</em> − 1 + <em>l</em>(<em>n</em>) .
</dd>
</dl>

<p>It is known to be true for Hansen numbers, a generalization of Brauer numbers; N. Clift checked by computer that all <em>n</em>≤5784688 are Hansen (while 5784689 is not).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Clift further checked that is true with equality for <em>n</em>≤64.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Addition_chain_exponentiation" title="wikilink">Addition chain exponentiation</a></li>
<li><a href="Addition-subtraction_chain" title="wikilink">Addition-subtraction chain</a></li>
<li><a href="Vectorial_addition_chain" title="wikilink">Vectorial addition chain</a></li>
<li><a href="Lucas_chain" title="wikilink">Lucas chain</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>Section C6.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a class="uri" href="http://wwwhomes.uni-bielefeld.de/achim/addition_chain.html">http://wwwhomes.uni-bielefeld.de/achim/addition_chain.html</a></li>
<li></li>
<li><a href="http://www.numdam.org/item?id=JTNB_1994__6_1_21_0">F. Bergeron, J. Berstel. S. Brlek "Efficient computation of addition chains"</a></li>
</ul>

<p>"</p>

<p><a href="Category:Addition_chains" title="wikilink">*</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">D. E. Knuth, <em>The Art of Computer Programming</em>, Vol 2, "Seminumerical Algorithms", Section 4.6.3, 3rd edition, 1997<a href="#fnref1">↩</a></li>
<li id="fn2">. A number of other papers state that finding a single addition chain is NP-complete, citing this paper, but it does not claim or prove such a result.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">A. Schönhage A lower bound on the length of addition chains, Theoret. Comput. Sci. 1 (1975), 1–12.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">Guy (2004) p.169<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
