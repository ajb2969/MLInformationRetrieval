<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1313">Proof complexity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Proof complexity</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>proof complexity</strong> is a measure of efficiency of <a href="automated_theorem_proving" title="wikilink">automated theorem proving</a> methods that is based on the size of the proofs they produce. The methods for proving contradiction in <a href="propositional_logic" title="wikilink">propositional logic</a> are the most analyzed. The two main issues considered in proof complexity are whether a proof method can produce a polynomial proof of every inconsistent formula, and whether the proofs produced by one method are always of size similar to those produced by another method.</p>
<h2 id="polynomiality-of-proofs">Polynomiality of proofs</h2>

<p>Different <a href="propositional_proof_system" title="wikilink">propositional proof system</a> for theorem proving in propositional logic, such as the <a href="sequent_calculus" title="wikilink">sequent calculus</a>, the <a href="cutting-plane_method" title="wikilink">cutting-plane method</a>, <a href="Resolution_(logic)" title="wikilink">resolution</a>, the <a href="DPLL_algorithm" title="wikilink">DPLL algorithm</a>, etc. produce different proofs when applied to the same formula. Proof complexity measures the efficiency of a method in terms of the size of the proofs it produces.</p>

<p>Two points make the study of proof complexity non-trivial:</p>
<ol>
<li>the size of a proof depends on the formula that is to be proved inconsistent;</li>
<li>proof methods are generally families of algorithms, as some of their steps are not univocally specified; for example, resolution is based on iteratively choosing a pair of clauses containing opposite literals and producing a new clause that is a consequence of them; since several such pairs may be available at each step, the algorithm has to choose one; these choices affect the proof length.</li>
</ol>

<p>The first point is taken into account by comparing the size of a proof of a formula with the size of the formula. This comparison is made using the usual assumptions of <a href="Computational_complexity_theory" title="wikilink">computational complexity</a>: first, a polynomial proof size/formula size ratio means that the proof is of size similar to that of the formula; second, this ratio is studied in the asymptotic case as the size of the formula increases.</p>

<p>The second point is taken into account by considering, for each formula, the shortest possible proof the considered method can produce.</p>

<p>The question of polynomiality of proofs is whether a method can always produce a proof of size polynomial in the size of the formula. If such a method exists, then <a href="NP_(complexity)" title="wikilink">NP</a> would be equal to <a class="uri" href="coNP" title="wikilink">coNP</a>: this is why the question of polynomiality of proofs is considered important in computational complexity. For some methods, the existence of formulae whose shortest proofs are always superpolynomial has been proved. For other methods, it is an open question.</p>
<h2 id="proof-size-comparison">Proof size comparison</h2>

<p>A second question about proof complexity is whether a method is more efficient than another. Since the proof size depends on the formula, it is possible that one method can produce a short proof of a formula and only long proofs of another formula, while a second method can have exactly the opposite behavior. The assumptions of measuring the size of the proofs relative to the size of the formula and considering only the shortest proofs are also used in this context.</p>

<p>When comparing two proof methods, two outcomes are possible:</p>
<ol>
<li>for every proof of a formula produced using the first method, there is a proof of comparable size of the same formula produced by the second method;</li>
<li>there exists a formula such that the first method can produce a short proof while all proofs obtained by the second method are consistently larger.</li>
</ol>

<p>Several proofs of the second kind involve contradictory formulae expressing the negation of the <a href="pigeonhole_principle" title="wikilink">pigeonhole principle</a>, namely that 

<math display="inline" id="Proof_complexity:0">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 pigeons can fit 

<math display="inline" id="Proof_complexity:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 holes with no hole containing two or more pigeons.</p>
<h2 id="automatizability">Automatizability</h2>

<p>A proof method is automatizable if one of the shorter proofs of a formula can always be generated in time polynomial (or sub-exponential) in the size of the proof. Some methods, but not all, are automatizable. Automatizability results are not in contrast with the assumption that the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a> does not collapses, which would happen if generating a proof in time polynomial in the size <em>of the formula</em> were always possible.</p>
<h2 id="interpolation">Interpolation</h2>

<p>Consider a tautology of the form 

<math display="inline" id="Proof_complexity:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>z</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,y)\rightarrow B(y,z)
  </annotation>
 </semantics>
</math>

. The tautology is true for every choice of 

<math display="inline" id="Proof_complexity:3">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


, and after fixing 

<math display="inline" id="Proof_complexity:4">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 the evaluation of 

<math display="inline" id="Proof_complexity:5">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Proof_complexity:6">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 are independent because are defined on disjoint sets of variables. This means that it is possible to define an <em>interpolant</em> circuit 

<math display="inline" id="Proof_complexity:7">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(y)
  </annotation>
 </semantics>
</math>

, such that both 

<math display="inline" id="Proof_complexity:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,y)\rightarrow C(y)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Proof_complexity:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>z</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(y)\rightarrow B(y,z)
  </annotation>
 </semantics>
</math>

 hold. The interpolant circuit decides either if 

<math display="inline" id="Proof_complexity:10">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,y)
  </annotation>
 </semantics>
</math>

 is false or if 

<math display="inline" id="Proof_complexity:11">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <interval closure="open">
     <ci>y</ci>
     <ci>z</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(y,z)
  </annotation>
 </semantics>
</math>

 is true, by only considering 

<math display="inline" id="Proof_complexity:12">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. The nature of the interpolant circuit can be arbitrary. Nevertheless it is possible to use a proof of the initial tautology 

<math display="inline" id="Proof_complexity:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>z</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,y)\rightarrow B(y,z)
  </annotation>
 </semantics>
</math>


 as a hint on how to construct 

<math display="inline" id="Proof_complexity:14">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. Some proof systems (e.g. resolution) are said to have <em>efficient interpolation</em> because the interpolant 

<math display="inline" id="Proof_complexity:15">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(y)
  </annotation>
 </semantics>
</math>

 is efficiently computable from any proof of the tautology 

<math display="inline" id="Proof_complexity:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>z</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,y)\rightarrow B(y,z)
  </annotation>
 </semantics>
</math>

 in such proof system. The efficiency is measured with respect to the length of the proof: it is easier to compute interpolants for longer proofs, so this property seems to be anti-monotone in the strength of the proof system.</p>

<p>Interpolation is a weak form of automatization: a way to deduce the existence of small circuits from the existence of small proofs. In particular the following three statements cannot be simultaneously true: (a) 

<math display="inline" id="Proof_complexity:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>z</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,y)\rightarrow B(y,z)
  </annotation>
 </semantics>
</math>

 has a short proof in a some proof system; (b) such proof system has efficient interpolation; (c) the interpolant circuit solves a computationally hard problem. It is clear that (a) and (b) imply that there is a small interpolant circuit, which is in contradiction with (c). Such relation allows to turn proof length upper bounds into lower bounds on computations, and dually to turn efficient interpolation algorithms into lower bounds on proof length.</p>
<h2 id="non-classical-logics">Non-classical logics</h2>

<p>The idea of comparing the size of proofs can be used for any automated reasoning procedure that generates a proof. Some research has been done about the size of proofs for propositional non-classical logics, in particular, intuitionistic, modal, and non-monotonic logics.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Automated_theorem_proving" title="wikilink">Automated theorem proving</a></li>
<li><a href="Computational_complexity_theory" title="wikilink">Computational complexity</a></li>
<li><a href="Intuitionistic_logic" title="wikilink">Intuitionistic logic</a></li>
<li><a href="Non-monotonic_logic" title="wikilink">Non-monotonic logic</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>P. Beame and <a href="Toniann_Pitassi" title="wikilink">T. Pitassi</a> (1998). <a href="http://eccc.uni-trier.de/eccc-reports/1998/TR98-067/index.html">Propositional proof complexity: past, present and future</a>. Technical Report TR98-067, Electronic Colloquium on Computational Complexity.</li>
<li>J. Krajíček, <a href="http://www.karlin.mff.cuni.cz/~krajicek/ecm.pdf">Proof complexity</a>, in: Proc. 4th European congress of mathematics (ed. A. Laptev), EMS, Zurich, pp.221-231, (2005).</li>
<li>J. Krajíček, <a href="http://www.karlin.mff.cuni.cz/~krajicek/ds1.ps">Propositional proof complexity I.</a> and <a href="http://www.karlin.mff.cuni.cz/~krajicek/ds2.ps">Proof complexity and arithmetic</a>.</li>
<li>P. Pudlák, The lengths of proofs, in: Handbook of Proof Theory (ed. S.R.Buss), Elsevier, (1998).</li>
<li>Stephen Cook and Phuong Nguyen, <a href="http://www.cup.es/us/catalogue/catalogue.asp?isbn=9780521517294">Logical Foundations of Proof Complexity</a>, Cambridge University Press, 2010 (<a href="http://www.cs.toronto.edu/~sacook/homepage/book">draft from 2008</a>)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.cmu.edu/afs/cs/project/jair/pub/volume21/dixon04a-html/node9.html">Proof Complexity</a></li>
</ul>
<ul>
<li><a href="http://list.math.cas.cz/listinfo/proof-complexity">Proof complexity mailing list.</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:Automated_theorem_proving" title="wikilink">Category:Automated theorem proving</a></p>
</body>
</html>
