<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1875">Operad theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Operad theory</h1>
<hr/>

<p><strong>Operad theory</strong> is a field of <a href="abstract_algebra" title="wikilink">abstract algebra</a> concerned with prototypical <a href="algebra_over_a_field" title="wikilink">algebras</a> that model properties such as <a class="uri" href="commutativity" title="wikilink">commutativity</a> or <a class="uri" href="anticommutativity" title="wikilink">anticommutativity</a> as well as various amounts of <a class="uri" href="associativity" title="wikilink">associativity</a>. Operads generalize the various <a class="uri" href="associativity" title="wikilink">associativity</a> properties already observed in <a href="Algebra_over_a_field" title="wikilink">algebras</a> and <a href="coalgebra" title="wikilink">coalgebras</a> such as <a href="Lie_algebra" title="wikilink">Lie algebras</a> or <a href="Poisson_algebra" title="wikilink">Poisson algebras</a> by modeling computational trees within the algebra. Algebras are to operads as <a href="group_representation" title="wikilink">group representations</a> are to <a href="group_(mathematics)" title="wikilink">groups</a>. Originating from work in <a href="algebraic_topology" title="wikilink">algebraic topology</a> by Boardman and Vogt, and <a href="J._Peter_May" title="wikilink">J. Peter May</a> (to whom their name is due), it has more recently found many applications, drawing for example on work by <a href="Maxim_Kontsevich" title="wikilink">Maxim Kontsevich</a> on <a href="graph_homology" title="wikilink">graph homology</a>.</p>

<p>An operad can be seen as a set of <a href="Operation_(mathematics)" title="wikilink">operations</a>, each one having a fixed finite number of inputs (arguments) and one output, which can be composed one with others; it is a <a href="Category_theory" title="wikilink">category-theoretic</a> analog of <a href="universal_algebra" title="wikilink">universal algebra</a>.</p>

<p>The word "operad" was also created by May as a portmanteau of "operations" and "<a href="monad_(category_theory)" title="wikilink">monad</a>" (and also because his mother was an opera singer). Regarding its creation, he wrote: "The name 'operad' is a word that I coined myself, spending a week thinking of nothing else." <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definition">Definition</h2>
<h3 id="operad-without-permutations">Operad without permutations</h3>

<p>An <strong>operad without permutations</strong> (sometimes called a <strong>non-symmetric</strong>, <strong>non-

<math display="inline" id="Operad_theory:0">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

</strong> or <strong>plain</strong> operad) consists of the following:</p>
<ul>
<li>a sequence 

<math display="inline" id="Operad_theory:1">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ℕ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <in></in>
     <ci>n</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P(n))_{n\in\mathbb{N}}
  </annotation>
 </semantics>
</math>

 of sets, whose elements are called <em>

<math display="inline" id="Operad_theory:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


-ary operations</em>,</li>
<li>an element 

<math display="inline" id="Operad_theory:3">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Operad_theory:4">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(1)
  </annotation>
 </semantics>
</math>

 called the <em>identity</em>,</li>
<li>for all positive integers 

<math display="inline" id="Operad_theory:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Operad_theory:6">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>k</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{1},\ldots,k_{n}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>a <em>composition</em> function</p>

<p>

<math display="block" id="Operad_theory:7">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mo>∘</mo>
      <mo>:</mo>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>×</mo>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>k</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>×</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>×</mo>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>k</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>→</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>P</mi>
      <mo>;</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>k</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <mi mathvariant="normal">⋯</mi>
        <mo>+</mo>
        <msub>
         <mi>k</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo>,</mo>
      <msub>
       <mi>θ</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>θ</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>↦</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <mi>θ</mi>
       <mo>∘</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>θ</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>θ</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <compose></compose>
      <ci>normal-:</ci>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <times></times>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <times></times>
      <ci>normal-⋯</ci>
      <times></times>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <ci>normal-→</ci>
     <list>
      <ci>P</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </list>
    </matrixrow>
    <matrixrow>
     <vector>
      <ci>θ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <compose></compose>
      <ci>θ</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}\circ:P(n)\times P(k_{1})\times\cdots\times P(k_{n})&\to&P;(k_{1%
}+\cdots+k_{n})\\
(\theta,\theta_{1},\ldots,\theta_{n})&\mapsto&\theta\circ(\theta_{1},\ldots,%
\theta_{n}),\end{matrix}
  </annotation>
 </semantics>
</math>

 satisfying the following coherence axioms:</p>
<ul>
<li><em>identity</em>

<math display="block" id="Operad_theory:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>θ</mi>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>θ</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>∘</mo>
    <mi>θ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>θ</ci>
      <vector>
       <cn type="integer">1</cn>
       <ci>normal-…</ci>
       <cn type="integer">1</cn>
      </vector>
     </apply>
     <ci>θ</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <compose></compose>
      <cn type="integer">1</cn>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\circ(1,\ldots,1)=\theta=1\circ\theta
  </annotation>
 </semantics>
</math>

</li>
<li><em>associativity</em>:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{align} &amp; \theta \circ (\theta_1 \circ (\theta_{1,1}, \ldots, \theta_{1,k_1}), \ldots, \theta_n \circ (\theta_{n,1}, \ldots,\theta_{n,k_n})) \\ = &amp; (\theta \circ (\theta_1, \ldots, \theta_n)) \circ (\theta_{1,1}, \ldots, \theta_{1,k_1}, \ldots, \theta_{n,1}, \ldots, \theta_{n,k_n}) \end{align} </p>

<p>(the number of arguments corresponds to the arities of the operations).</p>

<p>Alternatively, a plain operad is a <a href="multicategory_(category_theory)" title="wikilink">multicategory</a> with one object.</p>
<h3 id="operad">Operad</h3>

<p>An <strong>operad</strong> is a sequence of sets 

<math display="inline" id="Operad_theory:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
     <ci>n</ci>
    </list>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(n),{n\in\mathbb{N}}
  </annotation>
 </semantics>
</math>

, with a right action * of the <a href="symmetric_group" title="wikilink">symmetric group</a> 

<math display="inline" id="Operad_theory:10">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{n}
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Operad_theory:11">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(n)
  </annotation>
 </semantics>
</math>

, an identity element in 

<math display="inline" id="Operad_theory:12">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(1)
  </annotation>
 </semantics>
</math>

 and compositions maps 

<math display="inline" id="Operad_theory:13">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 satisfying the above associative and identity axioms, as well as</p>
<ul>
<li><em>equivariance</em>: given permutations 

<math display="inline" id="Operad_theory:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>i</mi>
    </msub>
    <mo>∈</mo>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <msub>
      <mi>k</mi>
      <mi>i</mi>
     </msub>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>t</mi>
    <mo>∈</mo>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}\in\Sigma_{k_{i}},t\in\Sigma_{n}
  </annotation>
 </semantics>
</math>

,</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>(\theta*t)\circ(\theta_{t1},\ldots,\theta_{tn}) = (\theta\circ(\theta_1,\ldots,\theta_n))*t; </p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\theta\circ(\theta_1*s_1,\ldots,\theta_n*s_n) = (\theta\circ(\theta_1,\ldots,\theta_n))*(s_1,\ldots,s_n) </p>

<p>The permutation actions in this definition are vital to most applications, including the original application to loop spaces.</p>

<p>A <strong>morphism of operads</strong> 

<math display="inline" id="Operad_theory:15">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>P</mi>
    <mo>→</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>P</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:P\to Q
  </annotation>
 </semantics>
</math>

 consists of a sequence</p>

<p>

<math display="block" id="Operad_theory:16">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>f</mi>
     <mi>n</mi>
    </msub>
    <mo>:</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>∈</mo>
    <mi>ℕ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-:</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <in></in>
     <ci>n</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f_{n}:P(n)\to Q(n))_{n\in\mathbb{N}}
  </annotation>
 </semantics>
</math>

 which:</p>
<ul>
<li>preserves the identity

<math display="block" id="Operad_theory:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(1)=1
  </annotation>
 </semantics>
</math>

</li>
<li>preserves composition: for every <em>n</em>-ary operation 

<math display="inline" id="Operad_theory:18">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 and operations 

<math display="inline" id="Operad_theory:19">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>θ</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{1},\ldots,\theta_{n}
  </annotation>
 </semantics>
</math>

,</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>f(\theta\circ(\theta_1,\ldots,\theta_n)) = f(\theta)\circ(f(\theta_1),\ldots,f(\theta_n)) </p>
<ul>
<li>preserves the permutation actions

<math display="block" id="Operad_theory:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>*</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>*</mo>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x*s)=f(x)*s
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h3 id="associativity-axiom">Associativity axiom</h3>

<p>"Associativity" means that <em>composition</em> of operations is associative (the function 

<math display="inline" id="Operad_theory:21">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 is associative), analogous to the axiom in category theory that 

<math display="inline" id="Operad_theory:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>∘</mo>
      <mi>h</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>∘</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>f</ci>
     <apply>
      <compose></compose>
      <ci>g</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <compose></compose>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\circ(g\circ h)=(f\circ g)\circ h
  </annotation>
 </semantics>
</math>

; it does <em>not</em> mean that the operations <em>themselves</em> are associative as operations. Compare with the <a href="#Associative_operad" title="wikilink">associative operad</a>, below.</p>

<p>Associativity in operad theory means that one can write <a href="Expression_(mathematics)" title="wikilink">expressions</a> involving operations without ambiguity from the omitted compositions, just as associativity for operations allows one to write products without ambiguity from the omitted parentheses.</p>

<p>For instance, suppose that 

<math display="inline" id="Operad_theory:23">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is a binary operation, which is written as 

<math display="inline" id="Operad_theory:24">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a,b)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Operad_theory:25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>a</mi>
    <mi>b</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (ab)
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="Operad_theory:26">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 may or may not be associative.</p>

<p>Then what is commonly written 

<math display="inline" id="Operad_theory:27">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((ab)c)
  </annotation>
 </semantics>
</math>

 is unambiguously written operadically as 

<math display="inline" id="Operad_theory:28">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>∘</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>θ</ci>
    <interval closure="open">
     <ci>θ</ci>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\circ(\theta,1)
  </annotation>
 </semantics>
</math>

 . This sends 

<math display="inline" id="Operad_theory:29">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b,c)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Operad_theory:30">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>a</mi>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <ci>c</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (ab,c)
  </annotation>
 </semantics>
</math>

 (apply 

<math display="inline" id="Operad_theory:31">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 on the first two, and the identity on the third), and then the 

<math display="inline" id="Operad_theory:32">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 on the left "multiplies" 

<math display="inline" id="Operad_theory:33">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Operad_theory:34">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

. This is clearer when depicted as a tree:</p>
<figure><b>(Figure)</b>
<figcaption>Tree before composition</figcaption>
</figure>

<p>which yields a 3-ary operation:</p>

<p> </p>

<p>However, the expression 

<math display="inline" id="Operad_theory:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (((ab)c)d)
  </annotation>
 </semantics>
</math>

 is <em>a priori</em> ambiguous: it could mean 

<math display="inline" id="Operad_theory:36">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>∘</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>θ</ci>
    <apply>
     <compose></compose>
     <interval closure="open">
      <ci>θ</ci>
      <cn type="integer">1</cn>
     </interval>
     <interval closure="open">
      <interval closure="open">
       <ci>θ</ci>
       <cn type="integer">1</cn>
      </interval>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\circ((\theta,1)\circ((\theta,1),1))
  </annotation>
 </semantics>
</math>

, if the inner compositions are performed first, or it could mean 

<math display="inline" id="Operad_theory:37">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>θ</mi>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∘</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <compose></compose>
     <ci>θ</ci>
     <interval closure="open">
      <ci>θ</ci>
      <cn type="integer">1</cn>
     </interval>
    </apply>
    <interval closure="open">
     <interval closure="open">
      <ci>θ</ci>
      <cn type="integer">1</cn>
     </interval>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\theta\circ(\theta,1))\circ((\theta,1),1)
  </annotation>
 </semantics>
</math>

, if the outer compositions are performed first (operations are read from right to left). Writing 

<math display="inline" id="Operad_theory:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mi>θ</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mo>=</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>z</mi>
     <mo>=</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>y</ci>
      <interval closure="open">
       <ci>θ</ci>
       <cn type="integer">1</cn>
      </interval>
     </apply>
     <apply>
      <eq></eq>
      <ci>z</ci>
      <interval closure="open">
       <interval closure="open">
        <ci>θ</ci>
        <cn type="integer">1</cn>
       </interval>
       <cn type="integer">1</cn>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\theta,y=(\theta,1),z=((\theta,1),1)
  </annotation>
 </semantics>
</math>

, this is 

<math display="inline" id="Operad_theory:39">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∘</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>y</mi>
     <mo>∘</mo>
     <mi>z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>x</ci>
    <apply>
     <compose></compose>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\circ(y\circ z)
  </annotation>
 </semantics>
</math>

 versus 

<math display="inline" id="Operad_theory:40">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>x</mi>
     <mo>∘</mo>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∘</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <compose></compose>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\circ y)\circ z
  </annotation>
 </semantics>
</math>

. That is, the tree is missing "vertical parentheses":</p>
<figure><b>(Figure)</b>
<figcaption>Tree before composition</figcaption>
</figure>

<p>If the top two rows of operations are composed first (puts an upward parenthesis at the 

<math display="inline" id="Operad_theory:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </mrow>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>d</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (ab)c\ \ d
  </annotation>
 </semantics>
</math>

 line; does the inner composition first), the following results:</p>
<figure><b>(Figure)</b>
<figcaption>Intermediate tree</figcaption>
</figure>

<p>which then evaluates unambiguously to yield a 4-ary operation. As an annotated expression:</p>

<p>

<math display="block" id="Operad_theory:42">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>c</mi>
     </mrow>
     <mo>⋅</mo>
     <mi>d</mi>
    </mrow>
   </msub>
   <mo>∘</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>θ</mi>
       <mrow>
        <mrow>
         <mi>a</mi>
         <mi>b</mi>
        </mrow>
        <mo>⋅</mo>
        <mi>c</mi>
       </mrow>
      </msub>
      <mo>,</mo>
      <msub>
       <mn>1</mn>
       <mi>d</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>θ</mi>
        <mrow>
         <mi>a</mi>
         <mo>⋅</mo>
         <mi>b</mi>
        </mrow>
       </msub>
       <mo>,</mo>
       <msub>
        <mn>1</mn>
        <mi>c</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <msub>
       <mn>1</mn>
       <mi>d</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>b</ci>
        </apply>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <ci>d</ci>
      </apply>
     </interval>
     <interval closure="open">
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <apply>
         <ci>normal-⋅</ci>
         <ci>a</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <ci>c</ci>
       </apply>
      </interval>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <ci>d</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{(ab)c\cdot d}\circ((\theta_{ab\cdot c},1_{d})\circ((\theta_{a\cdot b},%
1_{c}),1_{d}))
  </annotation>
 </semantics>
</math>

</p>
<figure><b>(Figure)</b>
<figcaption>Tree after composition</figcaption>
</figure>

<p>If the bottom two rows of operations are composed first (puts a downward parenthesis at the 

<math display="inline" id="Operad_theory:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi>b</mi>
   </mrow>
   <mi>c</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <ci>c</ci>
    <ci>d</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab\quad c\ \ d
  </annotation>
 </semantics>
</math>

 line; does the outer composition first), following results:</p>
<figure><b>(Figure)</b>
<figcaption>Intermediate tree</figcaption>
</figure>

<p>which then evaluates unambiguously to yield a 4-ary operation:</p>
<figure><b>(Figure)</b>
<figcaption>Tree after composition</figcaption>
</figure>

<p>The operad axiom of associativity is that <em>these yield the same result,</em> and thus that the expression 

<math display="inline" id="Operad_theory:44">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (((ab)c)d)
  </annotation>
 </semantics>
</math>

 is unambiguous.</p>
<h3 id="identity-axiom">Identity axiom</h3>

<p>The identity axiom (for a binary operation) can be visualized in a tree as:</p>
<figure><b>(Figure)</b>
<figcaption>The axiom of identity in an operad</figcaption>
</figure>

<p>meaning that the three operations obtained are equal: pre- or post- composing with the identity makes no difference.</p>

<p>Note that, as for categories, 

<math display="inline" id="Operad_theory:45">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>∘</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\circ 1=1
  </annotation>
 </semantics>
</math>

 is a corollary of the identity axiom.</p>
<h2 id="examples">Examples</h2>

<p> </p>
<h3 id="little-something-operads">"Little something" operads</h3>

<p>A <strong>little discs operad</strong> or, <strong>little balls operad</strong> or, more specifically, the <strong>little <em>n</em>-discs operad</strong> is a topological operad defined in terms of configurations of disjoint <em>n</em>-dimensional <a href="disc_(mathematics)" title="wikilink">discs</a> inside a unit <em>n</em>-disc centered in the <a href="Origin_(mathematics)" title="wikilink">origin</a> of <strong>R</strong><sup><em>n</em></sup>. The operadic composition for little 2-discs is illustrated in the figure.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Originally the <strong>little <em>n</em>-cubes operad</strong> or the <strong>little intervals operad</strong> (initially called little <em>n</em>-cubes <a href="PRO_(category_theory)" title="wikilink">PROPs</a>) was defined by <a href="Michael_Boardman" title="wikilink">Michael Boardman</a> and <a href="Rainer_Vogt" title="wikilink">Rainer Vogt</a> in a similar way, in terms of configurations of disjoint <a class="uri" href="axis-aligned" title="wikilink">axis-aligned</a> <em>n</em>-dimensional <a href="hypercube" title="wikilink">hypercubes</a> (n-dimensional <a href="interval_(mathematics)" title="wikilink">intervals</a>) inside the <a href="unit_hypercube" title="wikilink">unit hypercube</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Later it was generalized by May<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> to <strong>little convex bodies operad</strong>, and "little discs" is a case of "folklore" derived from the "little convex bodies".<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="associative-operad">Associative operad</h3>

<p>Another class of examples of operads are those capturing the structures of algebraic structures, such as associative algebras, commutative algebras and Lie algebras. Each of these can be exhibited as a finitely presented operad, in each of these three generated by binary operations.</p>

<p>Thus, the associative operad is generated by a binary operation 

<math display="inline" id="Operad_theory:46">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

, subject to the condition that</p>

<p>

<math display="block" id="Operad_theory:47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ψ</mi>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ψ</mi>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>ψ</mi>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi>ψ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>ψ</ci>
     <interval closure="open">
      <ci>ψ</ci>
      <cn type="integer">1</cn>
     </interval>
    </apply>
    <apply>
     <compose></compose>
     <ci>ψ</ci>
     <interval closure="open">
      <cn type="integer">1</cn>
      <ci>ψ</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi\circ(\psi,1)=\psi\circ(1,\psi).
  </annotation>
 </semantics>
</math>

</p>

<p>This condition <em>does</em> correspond to <a class="uri" href="associativity" title="wikilink">associativity</a> of the binary operation 

<math display="inline" id="Operad_theory:48">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

; writing 

<math display="inline" id="Operad_theory:49">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ψ</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(a,b)
  </annotation>
 </semantics>
</math>

 multiplicatively, the above condition is 

<math display="inline" id="Operad_theory:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (ab)c=a(bc)
  </annotation>
 </semantics>
</math>

. This associativity of the <em>operation</em> should not be confused with associativity of <em>composition</em>; see the <a href="#Axiom_of_associativity" title="wikilink">axiom of associativity</a>, above.</p>

<p>This operad is <a href="terminal_object" title="wikilink">terminal</a> in the category of non-symmetric operads, as it has exactly one <em>n</em>-ary operation for each <em>n,</em> corresponding to the unambiguous product of <em>n</em> terms

<math display="block" id="Operad_theory:51">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">⋯</mi>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\cdots x_{n}
  </annotation>
 </semantics>
</math>

. For this reason, it is sometimes written as 1 by category theorists (by analogy with the one-point set, which is terminal in the category of sets).</p>
<h3 id="terminal-symmetric-operad">Terminal symmetric operad</h3>

<p>The terminal symmetric operad is the operad whose algebras are commutative monoids, which also has one <em>n</em>-ary operation for each <em>n</em>, with each 

<math display="inline" id="Operad_theory:52">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{n}
  </annotation>
 </semantics>
</math>

 acting trivially; this triviality corresponds to commutativity, and whose <em>n</em>-ary operation is the unambiguous product of <em>n</em>-terms, where order does not matter:</p>

<p>

<math display="block" id="Operad_theory:53">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>σ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\cdots x_{n}=x_{\sigma(1)}\cdots x_{\sigma(n)}
  </annotation>
 </semantics>
</math>

 for any permutation 

<math display="inline" id="Operad_theory:54">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>∈</mo>
   <msub>
    <mi>S</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>σ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\in S_{n}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="operads-in-topology">Operads in topology</h3>

<p>In many examples the 

<math display="inline" id="Operad_theory:55">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(n)
  </annotation>
 </semantics>
</math>

 are not just sets but rather topological spaces. Some names of important examples are the <em>little n-disks</em>, <em>little n-cubes</em>, and <em>linear isometries</em> operads. The idea behind the little <em>n</em>-disks operad comes from homotopy theory, and the idea is that an element of 

<math display="inline" id="Operad_theory:56">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(n)
  </annotation>
 </semantics>
</math>

 is an arrangement of <em>n</em> disks within the unit disk. Now, the identity is the unit disk as a subdisk of itself, and composition of arrangements is by scaling the unit disk down into the disk that corresponds to the slot in the composition, and inserting the scaled contents there.</p>
<h3 id="operads-from-the-symmetric-and-braid-groups">Operads from the symmetric and braid groups</h3>

<p>There is an operad for which each 

<math display="inline" id="Operad_theory:57">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(n)
  </annotation>
 </semantics>
</math>

 is given by the <a href="symmetric_group" title="wikilink">symmetric group</a> 

<math display="inline" id="Operad_theory:58">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{n}
  </annotation>
 </semantics>
</math>

. The composite 

<math display="inline" id="Operad_theory:59">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>∘</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>σ</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\circ(\tau_{1},\dots,\tau_{n})
  </annotation>
 </semantics>
</math>

 permutes its inputs in blocks according to 

<math display="inline" id="Operad_theory:60">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, and within blocks according to the appropriate 

<math display="inline" id="Operad_theory:61">
 <semantics>
  <msub>
   <mi>τ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>τ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{i}
  </annotation>
 </semantics>
</math>

. Similarly, there is an operad for which each 

<math display="inline" id="Operad_theory:62">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(n)
  </annotation>
 </semantics>
</math>

 is given by the Artin <a href="braid_group" title="wikilink">braid group</a> 

<math display="inline" id="Operad_theory:63">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="linear-algebra">Linear algebra</h3>

<p>In <a href="linear_algebra" title="wikilink">linear algebra</a>, one can consider vector spaces to be algebras over the operad 

<math display="inline" id="Operad_theory:64">
 <semantics>
  <msup>
   <mi>𝐑</mi>
   <mi mathvariant="normal">∞</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐑</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}^{\infty}
  </annotation>
 </semantics>
</math>

 (the infinite <a href="direct_sum_of_modules" title="wikilink">direct sum</a>, so only finitely many terms are non-zero; this corresponds to only taking finite sums), which parametrizes <a href="linear_combinations" title="wikilink">linear combinations</a>: the vector 

<math display="inline" id="Operad_theory:65">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>5</mn>
   </mrow>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
    <apply>
     <minus></minus>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">0</cn>
    <ci>normal-…</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2,3,-5,0,\dots)
  </annotation>
 </semantics>
</math>

 for instance corresponds to the linear combination</p>

<p>

<math display="block" id="Operad_theory:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>v</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>3</mn>
       <msub>
        <mi>v</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>5</mn>
      <msub>
       <mi>v</mi>
       <mn>3</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>0</mn>
     <msub>
      <mi>v</mi>
      <mn>4</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">5</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2v_{1}+3v_{2}-5v_{3}+0v_{4}+\cdots.
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly, one can consider <a href="affine_combination" title="wikilink">affine combinations</a>, <a href="conical_combination" title="wikilink">conical combinations</a>, and <a href="convex_combination" title="wikilink">convex combinations</a> to correspond to the sub-operads where the terms sum to 1, the terms are all non-negative, or both, respectively. Graphically, these are the infinite affine hyperplane, the infinite hyper-octant, and the infinite simplex. This formalizes what is meant by 

<math display="inline" id="Operad_theory:67">
 <semantics>
  <msup>
   <mi>𝐑</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐑</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}^{n}
  </annotation>
 </semantics>
</math>

 being or the standard simplex being model spaces, and such observations as that every bounded <a href="convex_polytope" title="wikilink">convex polytope</a> is the image of a simplex. Here suboperads correspond to more restricted operations and thus more general theories.</p>

<p>This point of view formalizes the notion that linear combinations are the most general sort of operation on a vector space – saying that a vector space is an algebra over the operad of linear combinations is precisely the statement that <em>all possible</em> algebraic operations in a vector space are linear combinations. The basic operations of vector addition and scalar multiplication are a <a href="generating_set" title="wikilink">generating set</a> for the operad of all linear combinations, while the linear combinations operad canonically encode all possible operations on a vector space.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="PRO_(category_theory)" title="wikilink">PRO (category theory)</a></li>
<li><a href="Algebra_over_an_operad" title="wikilink">Algebra over an operad</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Abstract_algebra" title="wikilink">Category:Abstract algebra</a> <a href="Category:Category_theory" title="wikilink">Category:Category theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://www.math.uchicago.edu/~may/PAPERS/mayi.pdf">http://www.math.uchicago.edu/~may/PAPERS/mayi.pdf</a> Page 2<a href="#fnref1">↩</a></li>
<li id="fn2">Giovanni Giachetta, Luigi Mangiarotti, <a href="Sardanashvily" title="wikilink">Gennadi Sardanashvily</a> (2005) <em>Geometric and Algebraic Topological Methods in Quantum Mechanics,</em> ISBN 981-256-129-3, [<a class="uri" href="http://books.google.com/books?id=fLbisfrkWpoC&amp;pg">http://books.google.com/books?id=fLbisfrkWpoC&amp;pg;</a>;=PA474&amp;lpg;=PA474&amp;dq;=%22Little+discs+operad%22&amp;source;=web&amp;ots;=NNKTqHPeX7&amp;sig;=KVdeG4dbMj1GfggbYd3zeNVs_zQ&amp;hl;=en&amp;sa;=X&amp;oi;=book_result&amp;resnum;=4&amp;ct;=result#PPA474,M1 pp. 474,475]<a href="#fnref2">↩</a></li>
<li id="fn3"><em>Axiomatic, Enriched and Motivic Homotopy Theory</em> by J. P. C. Greenlees (2004) ISBN 1-4020-1834-7, [<a class="uri" href="http://books.google.com/books?id=8X3UnTBrl1QC&amp;pg">http://books.google.com/books?id=8X3UnTBrl1QC&amp;pg;</a>;=PA154&amp;dq;=%22Little+n-cubes+operad%22&amp;ei;=wGzuSLqZGZCKtAO-68y3Bw&amp;sig;=ACfU3U3rAMdf8zExGQJX9OamzeyhKiiGgQ#PPA154,M1 pp. 154–156]<a href="#fnref3">↩</a></li>
<li id="fn4">J. P. May, "[<a class="uri" href="http://projecteuclid.org/DPubS?verb=Display&amp;version">http://projecteuclid.org/DPubS?verb=Display&amp;version;</a>;=1.0&amp;service;=UI&amp;handle;=euclid.bams/1183538891&amp;page;=record Infinite loop space theory]", <em>Bull. Amer. Math. Soc.</em> 83 (1977), 456–494.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="Jim_Stasheff" title="wikilink">Jim Stasheff</a>, "Grafting <a href="Michael_Boardman" title="wikilink">Boardman</a>'s Cherry Trees to <a href="quantum_field_theory" title="wikilink">Quantum Field Theory</a>", 31 March 1998, <a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
