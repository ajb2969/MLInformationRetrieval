<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1280">SMA*</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>SMA*</h1>
<hr>{{ref improve|date=March 2015}}
{{Technical|date=November 2009}}
{{graph search algorithm}}

'''SMA*''' or '''Simplified Memory Bounded A*''' is a [[shortest path algorithm]] based on the [[A*]] algorithm. The main advantage of SMA* is that it uses a bounded memory, while the A* algorithm might need exponential memory. All other characteristics of SMA* are inherited from A*.

== Process ==

Like A*, it expands the most promising branches according to the heuristic. What sets SMA* apart is that it prunes nodes whose expansion has revealed less promising than expected. The approach allows the algorithm to explore branches and backtrack to explore other branches.

Expansion and pruning of nodes is driven by keeping two values of <math>f</math> for every node. Node <math>x</math> stores a value <math>f(x)</math> which estimates the cost of reaching the goal by taking a path through that node. The lower the value, the higher the priority. As in A* this value is initialized to <math>h(x)+g(x)</math>, but will then be updated to reflect changes to this estimate when its children are expanded. A fully expanded node will have an <math>f</math> value at least as high as that of its successors. In addition, the node stores the <math>f</math> value of the best forgotten successor. This value is restored if the forgotten successor is revealed to be the most promising successor.

Starting with the first node, it maintains OPEN, ordered lexicographically by <math>f</math> and depth. When choosing a node to expand, it chooses the best according to that order. When selecting a node to prune, it chooses the worst.

== Properties ==

SMA* has the following properties

* It works with a [[heuristic]], just as A*
* It is complete if the allowed memory is high enough to store the shallowest solution
* It is optimal if the allowed memory is high enough to store the shallowest optimal solution, otherwise it will return the best solution that fits in the allowed memory
* It avoids repeated states as long as the memory bound allows it
* It will use all memory available
* Enlarging the memory bound of the algorithm will only speed up the calculation
* When enough memory is available to contain the entire search tree, then calculation has an optimal speed

== Implementation ==

The implementation of SMA* is very similar to the one of A*, the only difference is that when there isn't any space left, nodes with the highest f-cost are pruned from the queue. Because those nodes are deleted, the SMA* also has to remember the f-cost of the best forgotten child with the parent node. When it seems that all explored paths are worse than such a forgotten path, the path is re-generated.<ref>{{cite conference | last = Russell | first = S. | year = 1992 | id = {{citeseerx|10.1.1.105.7839}} | title = Efficient memory-bounded search methods | booktitle = Proceedings of the 10th European Conference on Artificial intelligence | location = Vienna, Austria | editor-first = B. | editor-last = Neumann | publisher = John Wiley &amp; Sons, New York, NY | pages = 1–5 }}</ref>

Pseudo code:
<source lang="pascal">
function SMA-star(problem): path
  queue: set of nodes, ordered by f-cost;
begin
  queue.insert(problem.root-node);

  while True do begin
    if queue.empty() then return failure; //there is no solution that fits in the given memory
    node := queue.begin(); // min-f-cost-node
    if problem.is-goal(node) then return success;
    
    s := next-successor(node)
    if !problem.is-goal(s) &amp;&amp; depth(s) == max_depth then
        f(s) := inf; 
        // there is no memory left to go past s, so the entire path is useless
    else
        f(s) := max(f(node), g(s) + h(s));
        // f-value of the successor is the maximum of
        //      f-value of the parent and 
        //      heuristic of the successor + path length to the successor
    endif
    if no more successors then
       update f-cost of node and those of its ancestors if needed
    
    if node.successors ⊆ queue then queue.remove(node); 
    // all children have already been added to the queue via a shorter way
    if memory is full then begin
      badNode := shallowest node with highest f-cost;
      for parent in badNode.parents do begin
        parent.successors.remove(badNode);
        if needed then queue.insert(parent); 
      endfor
    endif

    queue.insert(s);
  endwhile
end
</source>

==References==
{{Reflist}}

{{DEFAULTSORT:Sma}}
[[Category:Graph algorithms]]
[[Category:Routing algorithms]]
[[Category:Search algorithms]]
[[Category:Game artificial intelligence]]
[[Category:Articles with example pseudocode]]"</hr></body></html>