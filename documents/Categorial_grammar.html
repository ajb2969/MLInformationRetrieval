<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="946">Categorial grammar</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Categorial grammar</h1>
<hr/>

<p><strong>Categorial grammar</strong> is a term used for a family of formalisms in <a href="natural_language" title="wikilink">natural language</a> <a class="uri" href="syntax" title="wikilink">syntax</a> motivated by the principle of <a class="uri" href="compositionality" title="wikilink">compositionality</a> and organized according to the view that syntactic constituents should generally combine as <a href="Function_(mathematics)" title="wikilink">functions</a> or according to a function-argument relationship. Most versions of categorial grammar analyze sentence structure in terms of constituencies (as opposed to dependencies) and are therefore <a href="phrase_structure_grammar" title="wikilink">phrase structure grammars</a> (as opposed to <a href="dependency_grammar" title="wikilink">dependency grammars</a>).</p>
<h2 id="basics">Basics</h2>

<p>A categorial grammar consists of two parts: a lexicon, which assigns a set of types (also called categories) to each basic symbol, and some <a href="type_inference" title="wikilink">type inference</a> rules, which determine how the type of a string of symbols follows from the types of the constituent symbols. It has the advantage that the type inference rules can be fixed once and for all, so that the specification of a particular language grammar is entirely determined by the lexicon.</p>

<p>A categorial grammar shares some features with the <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a>. Whereas the <a href="lambda_calculus" title="wikilink">lambda calculus</a> has only one function type 

<math display="inline" id="Categorial_grammar:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow B
  </annotation>
 </semantics>
</math>

, a categorial grammar typically has two function types, one type which is applied on the left, and one on the right. For example, a simple categorial grammar might have two function types 

<math display="inline" id="Categorial_grammar:1">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>/</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>B</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B/A\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Categorial_grammar:2">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>\</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-\</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\backslash B
  </annotation>
 </semantics>
</math>

. The first, 

<math display="inline" id="Categorial_grammar:3">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>/</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>B</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B/A\,\!
  </annotation>
 </semantics>
</math>


, is the type of a phrase that results in a phrase of type 

<math display="inline" id="Categorial_grammar:4">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\,\!
  </annotation>
 </semantics>
</math>

 when followed (on the right) by a phrase of type 

<math display="inline" id="Categorial_grammar:5">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,\!
  </annotation>
 </semantics>
</math>

. The second, 

<math display="inline" id="Categorial_grammar:6">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>\</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-\</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\backslash B\,\!
  </annotation>
 </semantics>
</math>

, is the type of a phrase that results in a phrase of type 

<math display="inline" id="Categorial_grammar:7">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\,\!
  </annotation>
 </semantics>
</math>

 when preceded (on the left) by a phrase of type 

<math display="inline" id="Categorial_grammar:8">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,\!
  </annotation>
 </semantics>
</math>


.</p>

<p>The notation is based upon algebra. A fraction when multiplied by (i.e. concatenated with) its denominator yields its numerator. As concatenation is not <a class="uri" href="commutative" title="wikilink">commutative</a>, it makes a difference whether the denominator occurs to the left or right. The concatenation must be on the same side as the denominator for it to cancel out.</p>

<p>The first and simplest kind of categorial grammar is called a basic categorial grammar, or sometimes an AB-grammar (after Ajdukiewicz and Bar-Hillel). Given a set of primitive types 

<math display="inline" id="Categorial_grammar:9">
 <semantics>
  <mtext>Prim</mtext>
  <annotation-xml encoding="MathML-Content">
   <mtext>Prim</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Prim}\,\!
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Categorial_grammar:10">
 <semantics>
  <mrow>
   <mtext>Tp</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>Prim</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Tp</mtext>
    <mtext>Prim</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Tp}(\text{Prim})\,\!
  </annotation>
 </semantics>
</math>

 be the set of types constructed from primitive types. In the basic case, this is the least set such that 

<math display="inline" id="Categorial_grammar:11">
 <semantics>
  <mrow>
   <mtext>Prim</mtext>
   <mo>⊆</mo>
   <mrow>
    <mtext>Tp</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>Prim</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <mtext>Prim</mtext>
    <apply>
     <times></times>
     <mtext>Tp</mtext>
     <mtext>Prim</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Prim}\subseteq\text{Tp}(\text{Prim})
  </annotation>
 </semantics>
</math>

 and if 

<math display="inline" id="Categorial_grammar:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mtext>Tp</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>Prim</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>X</ci>
     <ci>Y</ci>
    </list>
    <apply>
     <times></times>
     <mtext>Tp</mtext>
     <mtext>Prim</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y\in\text{Tp}(\text{Prim})
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Categorial_grammar:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>/</mo>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Y</mi>
      <mo>\</mo>
      <mi>X</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mtext>Tp</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>Prim</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <divide></divide>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <ci>normal-\</ci>
      <ci>Y</ci>
      <ci>X</ci>
     </apply>
    </list>
    <apply>
     <times></times>
     <mtext>Tp</mtext>
     <mtext>Prim</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X/Y),(Y\backslash X)\in\text{Tp}(\text{Prim})
  </annotation>
 </semantics>
</math>


. Think of these as purely formal expressions freely generated from the primitive types; any semantics will be added later. Some authors assume a fixed infinite set of primitive types used by all grammars, but by making the primitive types part of the grammar, the whole construction is kept finite.</p>

<p>A basic categorial grammar is a tuple 

<math display="inline" id="Categorial_grammar:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
   <mtext>Prim</mtext>
   <mo>,</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mo>◁</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>normal-Σ</ci>
    <mtext>Prim</mtext>
    <ci>S</ci>
    <ci>normal-◁</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Sigma,\text{Prim},S,\triangleleft)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Categorial_grammar:15">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma\,\!
  </annotation>
 </semantics>
</math>

 is a finite set of symbols, 

<math display="inline" id="Categorial_grammar:16">
 <semantics>
  <mtext>Prim</mtext>
  <annotation-xml encoding="MathML-Content">
   <mtext>Prim</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Prim}\,\!
  </annotation>
 </semantics>
</math>

 is a finite set of primitive types, and 

<math display="inline" id="Categorial_grammar:17">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∈</mo>
   <mrow>
    <mtext>Tp</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>Prim</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <apply>
     <times></times>
     <mtext>Tp</mtext>
     <mtext>Prim</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in\text{Tp}(\text{Prim})
  </annotation>
 </semantics>
</math>

.</p>

<p>The relation 

<math display="inline" id="Categorial_grammar:18">
 <semantics>
  <mo>◁</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-◁</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \triangleleft
  </annotation>
 </semantics>
</math>


 is the lexicon, which relates types to symbols 

<math display="inline" id="Categorial_grammar:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>◁</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mrow>
     <mtext>Tp</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mtext>Prim</mtext>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>×</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>normal-◁</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <mtext>Tp</mtext>
      <mtext>Prim</mtext>
     </apply>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\triangleleft)\subseteq\text{Tp}(\text{Prim})\times\Sigma
  </annotation>
 </semantics>
</math>

. Since the lexicon is finite, it can be specified by listing a set of pairs like 

<math display="inline" id="Categorial_grammar:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi>Y</mi>
    <mi>P</mi>
    <mi>E</mi>
   </mrow>
   <mo>◁</mo>
   <mtext>symbol</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>Y</ci>
     <ci>P</ci>
     <ci>E</ci>
    </apply>
    <mtext>symbol</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TYPE\triangleleft\text{symbol}
  </annotation>
 </semantics>
</math>

.</p>

<p>Such a grammar for English might have three basic types 

<math display="inline" id="Categorial_grammar:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>N</mi>
   <mo>,</mo>
   <mrow>
    <mi>N</mi>
    <mi>P</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mtext>and</mtext>
    <mi>S</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>and</mtext>
     <ci>S</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N,NP,\text{ and }S)\,\!
  </annotation>
 </semantics>
</math>

, assigning <a href="count_noun" title="wikilink">count nouns</a> the type 

<math display="inline" id="Categorial_grammar:22">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\,\!
  </annotation>
 </semantics>
</math>

, complete noun phrases the type 

<math display="inline" id="Categorial_grammar:23">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NP\,\!
  </annotation>
 </semantics>
</math>


, and sentences the type 

<math display="inline" id="Categorial_grammar:24">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,\!
  </annotation>
 </semantics>
</math>

. Then an <a class="uri" href="adjective" title="wikilink">adjective</a> could have the type 

<math display="inline" id="Categorial_grammar:25">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>/</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>N</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N/N\,\!
  </annotation>
 </semantics>
</math>

, because if it is followed by a noun then the whole phrase is a noun. Similarly, a <a href="determiner_(linguistics)" title="wikilink">determiner</a> has the type 

<math display="inline" id="Categorial_grammar:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mi>P</mi>
   </mrow>
   <mo>/</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>P</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NP/N\,\!
  </annotation>
 </semantics>
</math>

, because it forms a complete noun phrase when followed by a noun. Intransitive <a href="verb" title="wikilink">verbs</a> have the type 

<math display="inline" id="Categorial_grammar:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mi>P</mi>
   </mrow>
   <mo>\</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-\</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>P</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NP\backslash S
  </annotation>
 </semantics>
</math>

, and transitive verbs the type 

<math display="inline" id="Categorial_grammar:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>N</mi>
       <mi>P</mi>
      </mrow>
      <mo>\</mo>
      <mi>S</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-\</ci>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>P</ci>
      </apply>
      <ci>S</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (NP\backslash S)/NP
  </annotation>
 </semantics>
</math>


. Then a string of words is a sentence if it has overall type 

<math display="inline" id="Categorial_grammar:29">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,\!
  </annotation>
 </semantics>
</math>

.</p>

<p>For example, take the string "the bad boy made that mess". Now "the" and "that" are determiners, "boy" and "mess" are nouns, "bad" is an adjective, and "made" is a transitive verb, so the lexicon is {

<math display="inline" id="Categorial_grammar:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mi>P</mi>
    </mrow>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mo>◁</mo>
   <mtext>the</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>P</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <mtext>the</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NP/N\triangleleft\text{the}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Categorial_grammar:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mi>P</mi>
    </mrow>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mo>◁</mo>
   <mtext>that</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>P</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <mtext>that</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NP/N\triangleleft\text{that}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Categorial_grammar:32">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>◁</mo>
   <mtext>boy</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <ci>N</ci>
    <mtext>boy</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\triangleleft\text{boy}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Categorial_grammar:33">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>◁</mo>
   <mtext>mess</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <ci>N</ci>
    <mtext>mess</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\triangleleft\text{mess}
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Categorial_grammar:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mo>◁</mo>
   <mtext>bad</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <apply>
     <divide></divide>
     <ci>N</ci>
     <ci>N</ci>
    </apply>
    <mtext>bad</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N/N\triangleleft\text{bad}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Categorial_grammar:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>N</mi>
        <mi>P</mi>
       </mrow>
       <mo>\</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mi>N</mi>
    </mrow>
    <mi>P</mi>
   </mrow>
   <mo>◁</mo>
   <mtext>made</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-\</ci>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>P</ci>
       </apply>
       <ci>S</ci>
      </apply>
      <ci>N</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <mtext>made</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (NP\backslash S)/NP\triangleleft\text{made}
  </annotation>
 </semantics>
</math>

}.</p>

<p>and the sequence of types in the string is</p>

<p>

<math display="inline" id="Categorial_grammar:36">
 <semantics>
  <mrow>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mtext>the</mtext>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>N</mi>
        <mi>P</mi>
        <mo>/</mo>
        <mi>N</mi>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mtext>bad</mtext>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>N</mi>
        <mo>/</mo>
        <mi>N</mi>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mtext>boy</mtext>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>N</mi>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mtext>made</mtext>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>N</mi>
         <mi>P</mi>
         <mo>\</mo>
         <mi>S</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>/</mo>
        <mi>N</mi>
        <mi>P</mi>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mtext>that</mtext>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>N</mi>
        <mi>P</mi>
        <mo>/</mo>
        <mi>N</mi>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mtext>mess</mtext>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mi>N</mi>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>STACKED</ci>
     <mtext>the</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <divide></divide>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-,</ci>
     </cerror>
    </apply>
    <apply>
     <ci>STACKED</ci>
     <mtext>bad</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <divide></divide>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-,</ci>
     </cerror>
    </apply>
    <apply>
     <ci>STACKED</ci>
     <mtext>boy</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-,</ci>
     </cerror>
    </apply>
    <apply>
     <ci>STACKED</ci>
     <mtext>made</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">N</csymbol>
       <csymbol cd="unknown">P</csymbol>
       <ci>normal-\</ci>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <divide></divide>
      <csymbol cd="unknown">N</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-,</ci>
     </cerror>
    </apply>
    <apply>
     <ci>STACKED</ci>
     <mtext>that</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <divide></divide>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-,</ci>
     </cerror>
    </apply>
    <apply>
     <ci>STACKED</ci>
     <mtext>mess</mtext>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\text{the}\atop{NP/N,}}{\text{bad}\atop{N/N,}}{\text{boy}\atop{N,}}{\text{%
made}\atop{(NP\backslash S)/NP,}}{\text{that}\atop{NP/N,}}{\text{mess}\atop{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>now find functions and appropriate arguments and reduce them according to the two <a href="inference_rule" title="wikilink">inference rules</a> 

<math display="inline" id="Categorial_grammar:37">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>←</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>/</mo>
     <mi>Y</mi>
    </mrow>
    <mo rspace="5.3pt">,</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>X</ci>
    <list>
     <apply>
      <divide></divide>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <ci>Y</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\leftarrow X/Y,\;Y
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Categorial_grammar:38">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>←</mo>
   <mrow>
    <mi>Y</mi>
    <mo rspace="5.3pt">,</mo>
    <mrow>
     <mi>Y</mi>
     <mo>\</mo>
     <mi>X</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>X</ci>
    <list>
     <ci>Y</ci>
     <apply>
      <ci>normal-\</ci>
      <ci>Y</ci>
      <ci>X</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\leftarrow Y,\;Y\backslash X
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Categorial_grammar:39">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>N</mi>
   <mi>P</mi>
   <mo>/</mo>
   <mi>N</mi>
   <mo rspace="5.3pt">,</mo>
   <mi>N</mi>
   <mo>/</mo>
   <mi>N</mi>
   <mo rspace="5.3pt">,</mo>
   <mi>N</mi>
   <mo rspace="5.3pt">,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mi>P</mi>
    <mo>\</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mi>N</mi>
   <mi>P</mi>
   <mo rspace="5.3pt">,</mo>
   <munder accentunder="true">
    <mrow>
     <mrow>
      <mrow>
       <mi>N</mi>
       <mi>P</mi>
      </mrow>
      <mo>/</mo>
      <mi>N</mi>
     </mrow>
     <mo rspace="5.3pt">,</mo>
     <mi>N</mi>
    </mrow>
    <mo>⏟</mo>
   </munder>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <csymbol cd="unknown">N</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <divide></divide>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">N</csymbol>
    <divide></divide>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-\</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <divide></divide>
    <csymbol cd="unknown">N</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-,</ci>
    <apply>
     <ci>normal-⏟</ci>
     <list>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>P</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>N</ci>
     </list>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .\qquad NP/N,\;N/N,\;N,\;(NP\backslash S)/NP,\;\underbrace{NP/N,\;N}
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Categorial_grammar:40">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>N</mi>
   <mi>P</mi>
   <mo>/</mo>
   <mi>N</mi>
   <mo rspace="5.3pt">,</mo>
   <mi>N</mi>
   <mo>/</mo>
   <mi>N</mi>
   <mo rspace="5.3pt">,</mo>
   <mi>N</mi>
   <mo rspace="5.3pt">,</mo>
   <munder accentunder="true">
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>N</mi>
          <mi>P</mi>
         </mrow>
         <mo>\</mo>
         <mi>S</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>/</mo>
       <mi>N</mi>
      </mrow>
      <mi>P</mi>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mrow>
      <mi>N</mi>
      <mi>P</mi>
     </mrow>
    </mrow>
    <mo>⏟</mo>
   </munder>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <csymbol cd="unknown">N</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <divide></divide>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">N</csymbol>
    <divide></divide>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-,</ci>
    <apply>
     <ci>normal-⏟</ci>
     <list>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <ci>normal-\</ci>
         <apply>
          <times></times>
          <ci>N</ci>
          <ci>P</ci>
         </apply>
         <ci>S</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>P</ci>
      </apply>
     </list>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .\qquad NP/N,\;N/N,\;N,\;\underbrace{(NP\backslash S)/NP,\quad NP}
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Categorial_grammar:41">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>N</mi>
   <mi>P</mi>
   <mo>/</mo>
   <mi>N</mi>
   <mo rspace="5.3pt">,</mo>
   <munder accentunder="true">
    <mrow>
     <mrow>
      <mi>N</mi>
      <mo>/</mo>
      <mi>N</mi>
     </mrow>
     <mo rspace="5.3pt">,</mo>
     <mi>N</mi>
    </mrow>
    <mo>⏟</mo>
   </munder>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mi>P</mi>
    <mo>\</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <csymbol cd="unknown">N</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <divide></divide>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-,</ci>
    <apply>
     <ci>normal-⏟</ci>
     <list>
      <apply>
       <divide></divide>
       <ci>N</ci>
       <ci>N</ci>
      </apply>
      <ci>N</ci>
     </list>
    </apply>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-\</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .\qquad NP/N,\;\underbrace{N/N,\;N},\qquad(NP\backslash S)
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Categorial_grammar:42">
 <semantics>
  <mrow>
   <mo>.</mo>
   <munder accentunder="true">
    <mrow>
     <mrow>
      <mrow>
       <mi>N</mi>
       <mi>P</mi>
      </mrow>
      <mo>/</mo>
      <mi>N</mi>
     </mrow>
     <mo rspace="15.3pt">,</mo>
     <mi>N</mi>
    </mrow>
    <mo>⏟</mo>
   </munder>
   <mo rspace="25.3pt">,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mi>P</mi>
    <mo>\</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <apply>
     <ci>normal-⏟</ci>
     <list>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>P</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>N</ci>
     </list>
    </apply>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-\</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .\qquad\underbrace{NP/N,\;\quad N},\;\qquad(NP\backslash S)
  </annotation>
 </semantics>
</math>


<br/>


<math display="inline" id="Categorial_grammar:43">
 <semantics>
  <mrow>
   <mo>.</mo>
   <munder accentunder="true">
    <mrow>
     <mrow>
      <mi>N</mi>
      <mi>P</mi>
     </mrow>
     <mo rspace="25.3pt">,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>N</mi>
        <mi>P</mi>
       </mrow>
       <mo>\</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⏟</mo>
   </munder>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <apply>
     <ci>normal-⏟</ci>
     <list>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <ci>normal-\</ci>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>P</ci>
       </apply>
       <ci>S</ci>
      </apply>
     </list>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .\qquad\qquad\underbrace{NP,\;\qquad(NP\backslash S)}
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Categorial_grammar:44">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .\qquad\qquad\qquad\quad\;\;\;S
  </annotation>
 </semantics>
</math>

</p>

<p>The fact that the result is 

<math display="inline" id="Categorial_grammar:45">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,\!
  </annotation>
 </semantics>
</math>

 means that the string is a sentence, while the sequence of reductions shows that it must be parsed as ((the (bad boy)) (made (that mess))).</p>

<p>Categorial grammars of this form (having only function application rules) are equivalent in generative capacity to <a href="context-free_grammar" title="wikilink">context-free grammars</a> and are thus often considered inadequate for theories of natural language syntax. Unlike CFGs, categorial grammars are <a class="uri" href="lexicalized" title="wikilink">lexicalized</a>, meaning that only a small number of (mostly language-independent) rules are employed, and all other syntactic phenomena derive from the lexical entries of specific words.</p>

<p>Another appealing aspect of categorial grammars is that it is often easy to assign them a compositional semantics, by first assigning <a href="interpretation_type" title="wikilink">interpretation types</a> to all the basic categories, and then associating all the <a href="derived_category" title="wikilink">derived categories</a> with appropriate <a href="Function_(mathematics)" title="wikilink">function</a> types. The interpretation of any constituent is then simply the value of a function at an argument. With some modifications to handle <a class="uri" href="intensionality" title="wikilink">intensionality</a> and <a href="Quantification_(linguistics)" title="wikilink">quantification</a>, this approach can be used to cover a wide variety of semantic phenomena.</p>
<h2 id="lambek-calculus">Lambek calculus</h2>

<p>A Lambek grammar is an elaboration of this idea that has a concatenation operator for types, and several other inference rules. Pentus has shown that these still have the generative capacity of context-free grammars.</p>

<p>For the Lambek calculus, there is a type concatenation operator 

<math display="inline" id="Categorial_grammar:46">
 <semantics>
  <mo>⋆</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \star\,\!
  </annotation>
 </semantics>
</math>

, so that 

<math display="inline" id="Categorial_grammar:47">
 <semantics>
  <mrow>
   <mtext>Prim</mtext>
   <mo>⊆</mo>
   <mrow>
    <mtext>Tp</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>Prim</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <mtext>Prim</mtext>
    <apply>
     <times></times>
     <mtext>Tp</mtext>
     <mtext>Prim</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Prim}\subseteq\text{Tp}(\text{Prim})
  </annotation>
 </semantics>
</math>


 and if 

<math display="inline" id="Categorial_grammar:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mtext>Tp</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>Prim</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>X</ci>
     <ci>Y</ci>
    </list>
    <apply>
     <times></times>
     <mtext>Tp</mtext>
     <mtext>Prim</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y\in\text{Tp}(\text{Prim})
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Categorial_grammar:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>/</mo>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>\</mo>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>⋆</mo>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mtext>Tp</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>Prim</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <divide></divide>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <ci>normal-\</ci>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <ci>normal-⋆</ci>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </list>
    <apply>
     <times></times>
     <mtext>Tp</mtext>
     <mtext>Prim</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X/Y),(X\backslash Y),(X\star Y)\in\text{Tp}(\text{Prim})
  </annotation>
 </semantics>
</math>

.</p>

<p>The Lambek calculus consists of several deduction rules, which specify how type inclusion assertions can be derived. In the following rules, upper case roman letters stand for types, upper case Greek letters stand for sequences of types. A sequent of the form 

<math display="inline" id="Categorial_grammar:50">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>←</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>X</ci>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\leftarrow\Gamma
  </annotation>
 </semantics>
</math>

 can be read: a string is of type 

<math display="inline" id="Categorial_grammar:51">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\,\!
  </annotation>
 </semantics>
</math>

 if it consists of the concatenation of strings of each of the types in 

<math display="inline" id="Categorial_grammar:52">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\,\!
  </annotation>
 </semantics>
</math>


. If a type is interpreted as a set of strings, then the 

<math display="inline" id="Categorial_grammar:53">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 may be interpreted as 

<math display="inline" id="Categorial_grammar:54">
 <semantics>
  <mo>⊇</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">superset-of-or-equals</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \supseteq\,\!
  </annotation>
 </semantics>
</math>

, that is, "includes as a subset". A horizontal line means that the inclusion above the line implies the one below the line.</p>

<p>The process is begun by the Axiom rule, which has no antecedents and just says that any type includes itself.</p>

<p>

<math display="inline" id="Categorial_grammar:55">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
     <mi>i</mi>
     <mi>o</mi>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mi></mi>
    <mrow>
     <mi>X</mi>
     <mo>←</mo>
     <mi>X</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
     <ci>i</ci>
     <ci>o</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <divide></divide>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <ci>normal-←</ci>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Axiom)\quad{{}\over X\leftarrow X}
  </annotation>
 </semantics>
</math>

</p>

<p>The Cut rule says that inclusions can be composed.</p>

<p>

<math display="inline" id="Categorial_grammar:56">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>C</mi>
     <mi>u</mi>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi>Z</mi>
      <mo>←</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>X</mi>
       <msup>
        <mi mathvariant="normal">Δ</mi>
        <mo>′</mo>
       </msup>
      </mrow>
     </mrow>
     <mrow>
      <mi>X</mi>
      <mo>←</mo>
      <mi mathvariant="normal">Γ</mi>
     </mrow>
    </mrow>
    <mrow>
     <mi>Z</mi>
     <mo>←</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi mathvariant="normal">Γ</mi>
      <msup>
       <mi mathvariant="normal">Δ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>u</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <ci>normal-←</ci>
       <ci>Z</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>X</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Δ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-←</ci>
       <ci>X</ci>
       <ci>normal-Γ</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-←</ci>
      <ci>Z</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>normal-Γ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Cut)\quad{Z\leftarrow\Delta X\Delta^{\prime}\qquad X\leftarrow\Gamma\over Z%
\leftarrow\Delta\Gamma\Delta^{\prime}}
  </annotation>
 </semantics>
</math>

</p>

<p>The other rules come in pairs, one pair for each type construction operator, each pair consisting of one rule for the operator in the target, one in the source, of the arrow. The name of a rule consists of the operator and an arrow, with the operator on the side of the arrow on which it occurs in the conclusion.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Target</p></th>
<th style="text-align: left;">
<p>Source</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Categorial_grammar:57">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>\</mo>
    <mo>←</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mi>Y</mi>
     <mo>←</mo>
     <mrow>
      <mi>X</mi>
      <mi mathvariant="normal">Γ</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mo>\</mo>
      <mi>Y</mi>
     </mrow>
     <mo>←</mo>
     <mi mathvariant="normal">Γ</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-\</ci>
     <ci>normal-←</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-←</ci>
      <ci>Y</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>normal-Γ</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-←</ci>
      <apply>
       <ci>normal-\</ci>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
      <ci>normal-Γ</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\backslash\leftarrow)\quad{Y\leftarrow X\Gamma\over X\backslash Y\leftarrow\Gamma}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Categorial_grammar:58">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>←</mo>
    <mo>\</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi>Z</mi>
      <mo>←</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>Y</mi>
       <msup>
        <mi mathvariant="normal">Δ</mi>
        <mo>′</mo>
       </msup>
      </mrow>
     </mrow>
     <mrow>
      <mi>X</mi>
      <mo>←</mo>
      <mi mathvariant="normal">Γ</mi>
     </mrow>
    </mrow>
    <mrow>
     <mi>Z</mi>
     <mo>←</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi mathvariant="normal">Γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>X</mi>
        <mo>\</mo>
        <mi>Y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi mathvariant="normal">Δ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-←</ci>
     <ci>normal-\</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <ci>normal-←</ci>
       <ci>Z</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>Y</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Δ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-←</ci>
       <ci>X</ci>
       <ci>normal-Γ</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-←</ci>
      <ci>Z</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>normal-Γ</ci>
       <apply>
        <ci>normal-\</ci>
        <ci>X</ci>
        <ci>Y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\leftarrow\backslash)\quad{Z\leftarrow\Delta Y\Delta^{\prime}\qquad X%
\leftarrow\Gamma\over Z\leftarrow\Delta\Gamma(X\backslash Y)\Delta^{\prime}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Categorial_grammar:59">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>/</mo>
    <mo>←</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mi>Y</mi>
     <mo>←</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mi>X</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>Y</mi>
      <mo>/</mo>
      <mi>X</mi>
     </mrow>
     <mo>←</mo>
     <mi mathvariant="normal">Γ</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <divide></divide>
     <ci>normal-←</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-←</ci>
      <ci>Y</ci>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-←</ci>
      <apply>
       <divide></divide>
       <ci>Y</ci>
       <ci>X</ci>
      </apply>
      <ci>normal-Γ</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (/\leftarrow)\quad{Y\leftarrow\Gamma X\over Y/X\leftarrow\Gamma}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Categorial_grammar:60">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>←</mo>
    <mo>/</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi>Z</mi>
      <mo>←</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>Y</mi>
       <msup>
        <mi mathvariant="normal">Δ</mi>
        <mo>′</mo>
       </msup>
      </mrow>
     </mrow>
     <mrow>
      <mi>X</mi>
      <mo>←</mo>
      <mi mathvariant="normal">Γ</mi>
     </mrow>
    </mrow>
    <mrow>
     <mi>Z</mi>
     <mo>←</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>Y</mi>
        <mo>/</mo>
        <mi>X</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">Γ</mi>
      <msup>
       <mi mathvariant="normal">Δ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-←</ci>
     <divide></divide>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <ci>normal-←</ci>
       <ci>Z</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>Y</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Δ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-←</ci>
       <ci>X</ci>
       <ci>normal-Γ</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-←</ci>
      <ci>Z</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <divide></divide>
        <ci>Y</ci>
        <ci>X</ci>
       </apply>
       <ci>normal-Γ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\leftarrow/)\quad{Z\leftarrow\Delta Y\Delta^{\prime}\qquad X\leftarrow\Gamma%
\over Z\leftarrow\Delta(Y/X)\Gamma\Delta^{\prime}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Categorial_grammar:61">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋆</mo>
    <mo>←</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mo>←</mo>
      <mi mathvariant="normal">Γ</mi>
     </mrow>
     <mrow>
      <mi>Y</mi>
      <mo>←</mo>
      <msup>
       <mi mathvariant="normal">Γ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mo>⋆</mo>
      <mi>Y</mi>
     </mrow>
     <mo>←</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <msup>
       <mi mathvariant="normal">Γ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-⋆</ci>
     <ci>normal-←</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <ci>normal-←</ci>
       <ci>X</ci>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <ci>normal-←</ci>
       <ci>Y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Γ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-←</ci>
      <apply>
       <ci>normal-⋆</ci>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Γ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\star\leftarrow)\quad{X\leftarrow\Gamma\qquad Y\leftarrow\Gamma^{\prime}\over
X%
\star Y\leftarrow\Gamma\Gamma^{\prime}}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Categorial_grammar:62">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>←</mo>
    <mo>⋆</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mfrac>
    <mrow>
     <mi>Z</mi>
     <mo>←</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>X</mi>
      <mi>Y</mi>
      <msup>
       <mi mathvariant="normal">Δ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
    <mrow>
     <mi>Z</mi>
     <mo>←</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>X</mi>
        <mo>⋆</mo>
        <mi>Y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi mathvariant="normal">Δ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-←</ci>
     <ci>normal-⋆</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-←</ci>
      <ci>Z</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>X</ci>
       <ci>Y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-←</ci>
      <ci>Z</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <ci>normal-⋆</ci>
        <ci>X</ci>
        <ci>Y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\leftarrow\star)\quad{Z\leftarrow\Delta XY\Delta^{\prime}\over Z\leftarrow%
\Delta(X\star Y)\Delta^{\prime}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>For an example, here is a derivation of "type raising", which says that 

<math display="inline" id="Categorial_grammar:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>/</mo>
      <mi>A</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>\</mo>
    <mi>B</mi>
   </mrow>
   <mo>←</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <ci>normal-\</ci>
     <apply>
      <divide></divide>
      <ci>B</ci>
      <ci>A</ci>
     </apply>
     <ci>B</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B/A)\backslash B\leftarrow A
  </annotation>
 </semantics>
</math>


. The names of rules and the substitutions used are to the right.</p>

<p>

<math display="inline" id="Categorial_grammar:64">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mstyle displaystyle="true">
       <mfrac>
        <mi></mi>
        <mrow>
         <mi>B</mi>
         <mo>←</mo>
         <mi>B</mi>
        </mrow>
       </mfrac>
      </mstyle>
      <mstyle displaystyle="true">
       <mfrac>
        <mi></mi>
        <mrow>
         <mi>A</mi>
         <mo>←</mo>
         <mi>A</mi>
        </mrow>
       </mfrac>
      </mstyle>
     </mrow>
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi>B</mi>
        <mo>←</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>B</mi>
           <mo>/</mo>
           <mi>A</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo rspace="8.1pt">,</mo>
         <mi>A</mi>
        </mrow>
       </mrow>
       <mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>B</mi>
           <mo>/</mo>
           <mi>A</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>\</mo>
         <mi>B</mi>
        </mrow>
        <mo>←</mo>
        <mi>A</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </mfrac>
   </mstyle>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mtext>(Axioms)</mtext>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>←</mo>
        <mo>/</mo>
        <mo rspace="5.9pt" stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>Z</mi>
        <mo>=</mo>
        <mi>Y</mi>
        <mo>=</mo>
        <mi>B</mi>
        <mo>,</mo>
        <mi>X</mi>
        <mo>=</mo>
        <mi>A</mi>
        <mo>,</mo>
        <mi mathvariant="normal">Γ</mi>
        <mo>=</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>,</mo>
        <mi mathvariant="normal">Δ</mi>
        <mo>=</mo>
        <msup>
         <mi mathvariant="normal">Δ</mi>
         <mo>′</mo>
        </msup>
        <mo>=</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>\</mo>
        <mo>←</mo>
        <mo rspace="5.9pt" stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>Y</mi>
        <mo>=</mo>
        <mi>B</mi>
        <mo>,</mo>
        <mi>X</mi>
        <mo>=</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>B</mi>
         <mo>/</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>,</mo>
        <mi mathvariant="normal">Γ</mi>
        <mo>=</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <list>
      <apply>
       <divide></divide>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <ci>normal-←</ci>
        <ci>B</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <ci>normal-←</ci>
        <ci>A</ci>
        <ci>A</ci>
       </apply>
      </apply>
     </list>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-←</ci>
       <ci>B</ci>
       <list>
        <apply>
         <divide></divide>
         <ci>B</ci>
         <ci>A</ci>
        </apply>
        <ci>A</ci>
       </list>
      </apply>
      <apply>
       <ci>normal-←</ci>
       <apply>
        <ci>normal-\</ci>
        <apply>
         <divide></divide>
         <ci>B</ci>
         <ci>A</ci>
        </apply>
        <ci>B</ci>
       </apply>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <mtext>(Axioms)</mtext>
     </matrixrow>
     <matrixrow>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <ci>normal-←</ci>
        <divide></divide>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-[</ci>
        <csymbol cd="unknown">Z</csymbol>
        <eq></eq>
        <csymbol cd="unknown">Y</csymbol>
        <eq></eq>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-,</ci>
        <csymbol cd="unknown">X</csymbol>
        <eq></eq>
        <csymbol cd="unknown">A</csymbol>
        <ci>normal-,</ci>
        <csymbol cd="unknown">Γ</csymbol>
        <eq></eq>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">A</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-,</ci>
        <csymbol cd="unknown">Δ</csymbol>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Δ</ci>
         <ci>normal-′</ci>
        </apply>
        <eq></eq>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-]</ci>
       </cerror>
      </cerror>
     </matrixrow>
     <matrixrow>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <ci>normal-\</ci>
        <ci>normal-←</ci>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-[</ci>
        <csymbol cd="unknown">Y</csymbol>
        <eq></eq>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-,</ci>
        <csymbol cd="unknown">X</csymbol>
        <eq></eq>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">B</csymbol>
         <divide></divide>
         <csymbol cd="unknown">A</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-,</ci>
        <csymbol cd="unknown">Γ</csymbol>
        <eq></eq>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">A</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-]</ci>
       </cerror>
      </cerror>
     </matrixrow>
    </matrix>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\dfrac{}{B\leftarrow B}\qquad\dfrac{}{A\leftarrow A}}{\dfrac{B%
\leftarrow(B/A),\;\;A}{(B/A)\backslash B\leftarrow A}}\qquad\begin{matrix}%
\mbox{(Axioms)}\\
{(\leftarrow/)\,\,[Z=Y=B,X=A,\Gamma=(A),\Delta=\Delta^{\prime}=()]}\\
{(\backslash\leftarrow)\,\,[Y=B,X=(B/A),\Gamma=(A)]}\\
\end{matrix}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="relation-to-context-free-grammars">Relation to context-free grammars</h3>

<p>Recall that a <a href="context-free_grammar" title="wikilink">context-free grammar</a> is a 4-tuple:</p>

<p>

<math display="inline" id="Categorial_grammar:65">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo rspace="4.2pt">,</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo rspace="4.2pt">,</mo>
    <mo>:</mo>
    <mo>:=</mo>
    <mo rspace="4.2pt">,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Σ</csymbol>
     <ci>normal-,</ci>
     <ci>normal-:</ci>
     <csymbol cd="latexml">assign</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,\,\Sigma,\,::=,\,S)
  </annotation>
 </semantics>
</math>

 where</p>

<p>1. 

<math display="inline" id="Categorial_grammar:66">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\,
  </annotation>
 </semantics>
</math>

 is a finite set of <em>non-terminals</em> or <em>variables</em>.</p>

<p>2. 

<math display="inline" id="Categorial_grammar:67">
 <semantics>
  <mpadded width="+1.7pt">
   <mi mathvariant="normal">Σ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma\,
  </annotation>
 </semantics>
</math>

 is a finite set of <em>terminal symbols</em>.</p>

<p>3. 

<math display="inline" id="Categorial_grammar:68">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>:</mo>
   <mo rspace="4.2pt">:=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <csymbol cd="latexml">absent</csymbol>
    <csymbol cd="latexml">assign</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ::=\,
  </annotation>
 </semantics>
</math>

 is a finite set of production rules, that is, a finite relation 

<math display="inline" id="Categorial_grammar:69">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>:</mo>
    <mo>:=</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊆</mo>
   <mi>V</mi>
   <mo>×</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo>∪</mo>
     <mi mathvariant="normal">Σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-:</ci>
     <csymbol cd="latexml">assign</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <subset></subset>
    <csymbol cd="unknown">V</csymbol>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">V</csymbol>
      <union></union>
      <csymbol cd="unknown">Σ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (::=)\subseteq V\times(V\cup\Sigma)^{*}
  </annotation>
 </semantics>
</math>

.</p>

<p>4. 

<math display="inline" id="Categorial_grammar:70">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\,
  </annotation>
 </semantics>
</math>

 is the start variable.</p>

<p>From the point of view of categorial grammars, a context-free grammar can be seen as a calculus with a set of special purpose axioms for each language, but with no type construction operators and no inference rules except Cut.</p>

<p>Specifically, given a context-free grammar as above, define a categorial grammar 

<math display="inline" id="Categorial_grammar:71">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mtext>Prim</mtext>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo rspace="4.2pt">,</mo>
   <mo>◁</mo>
   <mo rspace="4.2pt">,</mo>
   <mi>S</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <mtext>Prim</mtext>
    <ci>normal-Σ</ci>
    <ci>normal-◁</ci>
    <ci>S</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\text{Prim},\,\Sigma,\,\triangleleft,\,S)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Categorial_grammar:72">
 <semantics>
  <mrow>
   <mtext>Prim</mtext>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mo>∪</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>Prim</mtext>
    <apply>
     <union></union>
     <ci>V</ci>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Prim}=V\cup\Sigma
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Categorial_grammar:73">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Tp</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>Prim</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mtext>Prim</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Tp</mtext>
     <mtext>Prim</mtext>
    </apply>
    <mtext>Prim</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Tp}(\text{Prim})=\text{Prim}\,\!
  </annotation>
 </semantics>
</math>

. Let there be an axiom 

<math display="inline" id="Categorial_grammar:74">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>←</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>x</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x\leftarrow x}
  </annotation>
 </semantics>
</math>

 for every symbol 

<math display="inline" id="Categorial_grammar:75">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mo>∪</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <union></union>
     <ci>V</ci>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in V\cup\Sigma
  </annotation>
 </semantics>
</math>

, an axiom 

<math display="inline" id="Categorial_grammar:76">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>←</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>X</ci>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {X\leftarrow\Gamma}
  </annotation>
 </semantics>
</math>

 for every production rule 

<math display="inline" id="Categorial_grammar:77">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">Γ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X::=\Gamma\,\!
  </annotation>
 </semantics>
</math>

, a lexicon entry 

<math display="inline" id="Categorial_grammar:78">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>◁</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <ci>s</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {s\triangleleft s}
  </annotation>
 </semantics>
</math>

 for every terminal symbol 

<math display="inline" id="Categorial_grammar:79">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\Sigma
  </annotation>
 </semantics>
</math>

, and Cut for the only rule. This categorial grammar generates the same language as the given CFG.</p>

<p>Of course, this is not a basic categorial grammar, since it has special axioms that depend upon the language; i.e. it is not lexicalized. Also, it makes no use at all of non-primitive types.</p>

<p>To show that any context-free language can be generated by a basic categorial grammar, recall that any context-free language can be generated by a context-free grammar in <a href="Greibach_normal_form" title="wikilink">Greibach normal form</a>.</p>

<p>The grammar is in Greibach normal form if every production rule is of the form 

<math display="inline" id="Categorial_grammar:80">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mi>s</mi>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A::=sA_{0}\ldots A_{N-1}
  </annotation>
 </semantics>
</math>

, where capital letters are variables, 

<math display="inline" id="Categorial_grammar:81">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\Sigma
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Categorial_grammar:82">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>N</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\geq 0
  </annotation>
 </semantics>
</math>

, that is, the right side of the production is a single terminal symbol followed by zero or more (non-terminal) variables.</p>

<p>Now given a CFG in Greibach normal form, define a basic categorial grammar with a primitive type for each non-terminal variable 

<math display="inline" id="Categorial_grammar:83">
 <semantics>
  <mrow>
   <mtext>Prim</mtext>
   <mo>=</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>Prim</mtext>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Prim}=V\,\!
  </annotation>
 </semantics>
</math>

, and with an entry in the lexicon 

<math display="inline" id="Categorial_grammar:84">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>/</mo>
    <msub>
     <mi>A</mi>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>/</mo>
    <mi mathvariant="normal">…</mi>
    <mo>/</mo>
    <msub>
     <mi>A</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>◁</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <apply>
     <divide></divide>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A/A_{N-1}/\ldots/A_{0}\triangleleft s
  </annotation>
 </semantics>
</math>

, for each production rule 

<math display="inline" id="Categorial_grammar:85">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mi>s</mi>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A::=sA_{0}\ldots A_{N-1}
  </annotation>
 </semantics>
</math>

. It is fairly easy to see that this basic categorial grammar generates the same language as the original CFG. Note that the lexicon of this grammar will generally assign multiple types to each symbol.</p>

<p>The same construction works for Lambek grammars, since they are an extension of basic categorial grammars. It is necessary to verify that the extra inference rules do not change the generated language. This can be done and shows that every context-free language is generated by some Lambek grammar.</p>

<p>To show the converse, that every language generated by a Lambek grammar is context-free, is much more difficult. It was an open problem for nearly thirty years, from the early 1960s until about 1991 when it was proven by Pentus.</p>

<p>The basic idea is, given a Lambek grammar, 

<math display="inline" id="Categorial_grammar:86">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mtext>Prim</mtext>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo rspace="4.2pt">,</mo>
   <mo>◁</mo>
   <mo rspace="4.2pt">,</mo>
   <mi>S</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <mtext>Prim</mtext>
    <ci>normal-Σ</ci>
    <ci>normal-◁</ci>
    <ci>S</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\text{Prim},\,\Sigma,\,\triangleleft,\,S)
  </annotation>
 </semantics>
</math>

 construct a context-free grammar 

<math display="inline" id="Categorial_grammar:87">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>V</mi>
   <mo rspace="4.2pt">,</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo rspace="4.2pt">,</mo>
   <mo>:</mo>
   <mo>:=</mo>
   <mo rspace="4.2pt">,</mo>
   <mi>S</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Σ</csymbol>
    <ci>normal-,</ci>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">S</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (V,\,\Sigma,\,::=,\,S)
  </annotation>
 </semantics>
</math>

 with the same set of terminal symbols, the same start symbol, with variables some (not all) types 

<math display="inline" id="Categorial_grammar:88">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>⊂</mo>
   <mrow>
    <mtext>Tp</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>Prim</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>V</ci>
    <apply>
     <times></times>
     <mtext>Tp</mtext>
     <mtext>Prim</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\subset\text{Tp}(\text{Prim})\,\!
  </annotation>
 </semantics>
</math>

, and with a production rule 

<math display="inline" id="Categorial_grammar:89">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mtext>s</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <mtext>s</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T::=\text{s}\,\!
  </annotation>
 </semantics>
</math>

 for each entry 

<math display="inline" id="Categorial_grammar:90">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>◁</mo>
   <mtext>s</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-◁</ci>
    <ci>T</ci>
    <mtext>s</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\triangleleft\text{s}
  </annotation>
 </semantics>
</math>

 in the lexicon, and production rules 

<math display="inline" id="Categorial_grammar:91">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">Γ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T::=\Gamma\,\!
  </annotation>
 </semantics>
</math>

 for certain sequents 

<math display="inline" id="Categorial_grammar:92">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>←</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>T</ci>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\leftarrow\Gamma
  </annotation>
 </semantics>
</math>

 that are derivable in the Lambek calculus.</p>

<p>Of course, there are infinitely many types and infinitely many derivable sequents, so in order to make a finite grammar it is necessary put a bound on the size of the types and sequents that are needed. The heart of Pentus's proof is to show that there is such a finite bound.</p>
<h3 id="notation">Notation</h3>

<p>The notation in this field is not standardized. The notations used in formal language theory, logic, category theory, and linguistics, conflict with each other. In logic, arrows point to the more general from the more particular, that is, to the conclusion from the hypotheses. In this article, this convention is followed, i.e. the target of the arrow is the more general (inclusive) type.</p>

<p>In logic, arrows usually point left to right. In this article this convention is reversed for consistency with the notation of context-free grammars, where the single non-terminal symbol is always on the left. We use the symbol 

<math display="inline" id="Categorial_grammar:93">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>:</mo>
   <mo>:=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <csymbol cd="latexml">absent</csymbol>
    <csymbol cd="latexml">assign</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ::=
  </annotation>
 </semantics>
</math>

 in a production rule as in <a href="Backus-Naur_form" title="wikilink">Backus-Naur form</a>. Some authors use an arrow, which unfortunately may point in either direction, depending on whether the grammar is thought of as generating or recognizing the language.</p>

<p>Some authors on categorial grammars write 

<math display="inline" id="Categorial_grammar:94">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>\</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-\</ci>
    <ci>B</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\backslash A
  </annotation>
 </semantics>
</math>

 instead of 

<math display="inline" id="Categorial_grammar:95">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>\</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-\</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\backslash B
  </annotation>
 </semantics>
</math>

. The convention used here follows Lambek and algebra.</p>
<h2 id="historical-notes">Historical notes</h2>

<p>The basic ideas of categorial grammar date from work by <a href="Kazimierz_Ajdukiewicz" title="wikilink">Kazimierz Ajdukiewicz</a> (in 1935) and <a href="Yehoshua_Bar-Hillel" title="wikilink">Yehoshua Bar-Hillel</a> (in 1953). In 1958, <a href="Joachim_Lambek" title="wikilink">Joachim Lambek</a> introduced a <a href="Lambek_Calculus" title="wikilink">syntactic calculus</a> that formalized the function <a href="type_constructors" title="wikilink">type constructors</a> along with various rules for the combination of functions. This calculus is a forerunner of <a href="linear_logic" title="wikilink">linear logic</a> in that it is a <a href="substructural_logic" title="wikilink">substructural logic</a>. <a href="Montague_grammar" title="wikilink">Montague grammar</a> uses an ad hoc syntactic system for English that is based on the principles of categorial grammar. Although <a href="Richard_Montague" title="wikilink">Montague's</a> work is sometimes regarded as syntactically uninteresting, it helped to bolster interest in categorial grammar by associating it with a highly successful formal treatment of natural language <a class="uri" href="semantics" title="wikilink">semantics</a>. More recent work in categorial grammar has focused on the improvement of syntactic coverage. One formalism which has received considerable attention in recent years is <a href="Mark_Steedman" title="wikilink">Steedman</a> and <a href="Anna_Szabolcsi" title="wikilink">Szabolcsi</a>'s <a href="combinatory_categorial_grammar" title="wikilink">combinatory categorial grammar</a> which builds on <a href="combinatory_logic" title="wikilink">combinatory logic</a> invented by <a href="Moses_Schönfinkel" title="wikilink">Moses Schönfinkel</a> and <a href="Haskell_Curry" title="wikilink">Haskell Curry</a>.</p>

<p>There are a number of related formalisms of this kind in linguistics, such as <a href="type_logical_grammar" title="wikilink">type logical grammar</a> and <a href="abstract_categorial_grammar" title="wikilink">abstract categorial grammar</a>.</p>
<h2 id="some-definitions">Some definitions</h2>
<dl>
<dt>Derivation: A derivation is a binary tree that encodes a proof.<br/>
Parse tree: A parse tree displays a derivation, showing the syntactic structure of a sentence.<br/>
Functor and Argument: In a right (left) function application, the node of the type A\B (B/A) is called the functor, and the node of the type A is called an argument.<br/>
Functor-argument structure</dt>
</dl>
<h2 id="refinements-of-categorial-grammar">Refinements of categorial grammar</h2>

<p>A variety of changes to categorial grammar have been proposed to improve syntactic coverage. Some of the most common ones are listed below.</p>
<h3 id="features-and-subcategories">Features and subcategories</h3>

<p>Most systems of categorial grammar subdivide categories. The most common way to do this is by tagging them with <a href="grammatical_feature" title="wikilink">features</a>, such as <a href="Grammatical_person" title="wikilink">person</a>, <a href="Grammatical_gender" title="wikilink">gender</a>, <a href="Grammatical_number" title="wikilink">number</a>, and <a href="Grammatical_tense" title="wikilink">tense</a>. Sometimes only atomic categories are tagged in this way. In Montague grammar, it is traditional to subdivide function categories using a multiple slash convention, so <em>A/B</em> and <em>A//B</em> would be two distinct categories of left-applying functions, that took the same arguments but could be distinguished between by other functions taking them as arguments.</p>
<h3 id="function-composition">Function composition</h3>

<p>Rules of function composition are included in many categorial grammars. An example of such a rule would be one that allowed the concatenation of a constituent of type <em>A/B</em> with one of type <em>B/C</em> to produce a new constituent of type <em>A/C</em>. The semantics of such a rule would simply involve the composition of the functions involved. Function composition is important in categorial accounts of <a href="logical_conjunction" title="wikilink">conjunction</a> and extraction, especially as they relate to phenomena like <a href="right_node_raising" title="wikilink">right node raising</a>. The introduction of function composition into a categorial grammar leads to many kinds of derivational ambiguity that are vacuous in the sense that they do not correspond to semantic ambiguities.</p>
<h3 id="conjunction">Conjunction</h3>

<p>Many categorial grammars include a typical conjunction rule, of the general form <em>X CONJ X → X</em>, where <em>X</em> is a category. Conjunction can generally be applied to nonstandard constituents resulting from type raising or function composition..</p>
<h3 id="discontinuity">Discontinuity</h3>

<p>The grammar is extended to handle linguistic phenomena such as discontinuous idioms, gapping and extraction.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Combinatory_categorial_grammar" title="wikilink">Combinatory categorial grammar</a></li>
<li><a href="Noncommutative_logic" title="wikilink">Noncommutative logic</a></li>
<li><a href="Pregroup_Grammar" title="wikilink">Pregroup Grammar</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Michael Moortgat, <em>Categorial Type Logics</em>, Chapter 2 in J. van Benthem and A. ter Meulen (eds.) <em>Handbook of Logic and Language</em>. Elsevier, 1997, ISBN 0-262-22053-9</li>
<li>Wojciech Buszkowski, <em>Mathematical linguistics and proof theory</em>, Chapter 12 in J. van Benthem and A. ter Meulen (eds.) <em>Handbook of Logic and Language</em>. Elsevier, 1997, ISBN 0-262-22053-9</li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://eom.springer.de/g/g044770.htm">Grammar, categorial</a> at Springer <a href="Encyclopaedia_of_Mathematics" title="wikilink">Encyclopaedia of Mathematics</a></li>
<li><a class="uri" href="http://plato.stanford.edu/entries/typelogical-grammar/">http://plato.stanford.edu/entries/typelogical-grammar/</a></li>
</ul>

<p>"</p>

<p><a href="Category:Grammar_frameworks" title="wikilink">Category:Grammar frameworks</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Computational_linguistics" title="wikilink">Category:Computational linguistics</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
</body>
</html>
