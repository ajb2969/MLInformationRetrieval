<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="352">Optimal control</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Optimal control</h1>
<hr/>

<p><strong>Optimal control theory</strong>, an extension of the <a href="calculus_of_variations" title="wikilink">calculus of variations</a>, is a <a href="mathematical_optimization" title="wikilink">mathematical optimization</a> method for deriving <a href="control_theory" title="wikilink">control policies</a>. The method is largely due to the work of <a href="Lev_Pontryagin" title="wikilink">Lev Pontryagin</a> and his collaborators in the Soviet Union<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="Richard_Bellman" title="wikilink">Richard Bellman</a> in the United States. Optimal control can be seen as a <a href="control_strategy" title="wikilink">control strategy</a> in <a href="control_theory" title="wikilink">control theory</a>.</p>
<h2 id="general-method">General method</h2>

<p>Optimal control deals with the problem of finding a control law for a given system such that a certain optimality criterion is achieved. A control problem includes a <a href="cost_functional" title="wikilink">cost functional</a> that is a <a href="function_(mathematics)" title="wikilink">function</a> of state and control variables. An <strong>optimal control</strong> is a set of <a href="differential_equation" title="wikilink">differential equations</a> describing the paths of the control variables that minimize the cost functional. The optimal control can be derived using <a href="Pontryagin's_minimum_principle" title="wikilink">Pontryagin's maximum principle</a> (a <a href="necessary_condition" title="wikilink">necessary condition</a> also known as Pontryagin's minimum principle or simply Pontryagin's Principle<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>), or by solving the <a href="Hamiltonâ€“Jacobiâ€“Bellman_equation" title="wikilink">Hamiltonâ€“Jacobiâ€“Bellman equation</a> (a <a href="sufficient_condition" title="wikilink">sufficient condition</a>).</p>

<p>We begin with a simple example. Consider a car traveling on a straight line through a hilly road. The question is, how should the driver press the accelerator pedal in order to <em>minimize</em> the total traveling time? Clearly in this example, the term <em>control law</em> refers specifically to the way in which the driver presses the accelerator and shifts the gears. The <em>system</em> consists of both the car and the road, and the <em>optimality criterion</em> is the minimization of the total traveling time. Control problems usually include ancillary <a href="Constraint_(mathematics)" title="wikilink">constraints</a>. For example the amount of available fuel might be limited, the accelerator pedal cannot be pushed through the floor of the car, speed limits, etc.</p>

<p>A proper cost functional is a mathematical expression giving the traveling time as a function of the speed, geometrical considerations, and <a href="initial_condition" title="wikilink">initial conditions</a> of the system. It is often the case that the <a href="constraint_(mathematics)" title="wikilink">constraints</a> are interchangeable with the cost functional.</p>

<p>Another optimal control problem is to find the way to drive the car so as to minimize its fuel consumption, given that it must complete a given course in a time not exceeding some amount. Yet another control problem is to minimize the total monetary cost of completing the trip, given assumed monetary prices for time and fuel.</p>

<p>A more abstract framework goes as follows. Minimize the continuous-time cost functional</p>

<p>

<math display="block" id="Optimal_control:0">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi mathvariant="normal">Î¦</mi>
     </mpadded>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mrow>
       <mtext>ğ±</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <mrow>
       <mtext>ğ±</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mi>f</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mpadded width="+1.7pt">
       <msub>
        <mi>t</mi>
        <mi>f</mi>
       </msub>
      </mpadded>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">âˆ«</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <msub>
       <mi>t</mi>
       <mi>f</mi>
      </msub>
     </msubsup>
     <mrow>
      <mpadded width="+1.7pt">
       <mi class="ltx_font_mathcaligraphic">â„’</mi>
      </mpadded>
      <mrow>
       <mo rspace="4.2pt" stretchy="false">[</mo>
       <mrow>
        <mtext>ğ±</mtext>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mtext>ğ®</mtext>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mpadded width="+1.7pt">
        <mi>t</mi>
       </mpadded>
       <mo rspace="4.2pt" stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mo>d</mo>
       <mi>t</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>normal-Î¦</ci>
      <list>
       <apply>
        <times></times>
        <mtext>x</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <mtext>x</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>f</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>f</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>â„’</ci>
       <list>
        <apply>
         <times></times>
         <mtext>x</mtext>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <mtext>u</mtext>
         <ci>t</ci>
        </apply>
        <ci>t</ci>
       </list>
       <apply>
        <ci>normal-d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\Phi\,[\,\textbf{x}(t_{0}),t_{0},\textbf{x}(t_{f}),t_{f}\,]+\int_{t_{0}}^{t_%
{f}}\mathcal{L}\,[\,\textbf{x}(t),\textbf{u}(t),t\,]\,\operatorname{d}t
  </annotation>
 </semantics>
</math>

</p>

<p>subject to the first-order dynamic constraints (the <strong>state equation</strong>)</p>

<p>

<math display="block" id="Optimal_control:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mtext>ğ±</mtext>
      <mo>Ë™</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>ğš</mtext>
     </mpadded>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mrow>
       <mtext>ğ±</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mtext>ğ®</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mpadded width="+1.7pt">
       <mi>t</mi>
      </mpadded>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-Ë™</ci>
      <mtext>x</mtext>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>a</mtext>
     <list>
      <apply>
       <times></times>
       <mtext>x</mtext>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>u</mtext>
       <ci>t</ci>
      </apply>
      <ci>t</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\textbf{x}}(t)=\textbf{a}\,[\,\textbf{x}(t),\textbf{u}(t),t\,],
  </annotation>
 </semantics>
</math>

</p>

<p>the algebraic <em>path constraints</em></p>

<p>

<math display="block" id="Optimal_control:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>ğ›</mtext>
     </mpadded>
     <mrow>
      <mo rspace="4.2pt" stretchy="false">[</mo>
      <mrow>
       <mtext>ğ±</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mtext>ğ®</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mpadded width="+1.7pt">
       <mi>t</mi>
      </mpadded>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>â‰¤</mo>
    <mtext>ğŸ</mtext>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <mtext>b</mtext>
     <list>
      <apply>
       <times></times>
       <mtext>x</mtext>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>u</mtext>
       <ci>t</ci>
      </apply>
      <ci>t</ci>
     </list>
    </apply>
    <mtext>0</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{b}\,[\,\textbf{x}(t),\textbf{u}(t),t\,]\leq\textbf{0},
  </annotation>
 </semantics>
</math>

</p>

<p>and the <a href="boundary_condition" title="wikilink">boundary conditions</a></p>

<p>

<math display="block" id="Optimal_control:3">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mi mathvariant="bold-italic">Ï•</mi>
    </mpadded>
    <mrow>
     <mo rspace="4.2pt" stretchy="false">[</mo>
     <mrow>
      <mtext>ğ±</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mtext>ğ±</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mi>f</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mpadded width="+1.7pt">
      <msub>
       <mi>t</mi>
       <mi>f</mi>
      </msub>
     </mpadded>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>bold-italic-Ï•</ci>
     <list>
      <apply>
       <times></times>
       <mtext>x</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <mtext>x</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>f</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>f</ci>
      </apply>
     </list>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\phi}\,[\,\textbf{x}(t_{0}),t_{0},\textbf{x}(t_{f}),t_{f}\,]=0
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Optimal_control:4">
 <semantics>
  <mrow>
   <mtext>ğ±</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>x</mtext>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{x}(t)
  </annotation>
 </semantics>
</math>

 is the <em>state</em>, 

<math display="inline" id="Optimal_control:5">
 <semantics>
  <mrow>
   <mtext>ğ®</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>u</mtext>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{u}(t)
  </annotation>
 </semantics>
</math>

 is the <em>control</em>, 

<math display="inline" id="Optimal_control:6">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is the independent variable (generally speaking, time), 

<math display="inline" id="Optimal_control:7">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}
  </annotation>
 </semantics>
</math>

 is the initial time, and 

<math display="inline" id="Optimal_control:8">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{f}
  </annotation>
 </semantics>
</math>

 is the terminal time. The terms 

<math display="inline" id="Optimal_control:9">
 <semantics>
  <mi mathvariant="normal">Î¦</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î¦</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_control:10">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">â„’</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>â„’</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}
  </annotation>
 </semantics>
</math>

 are called the ''endpoint cost '' and <em><a class="uri" href="Lagrangian" title="wikilink">Lagrangian</a></em>, respectively. Furthermore, it is noted that the path constraints are in general <em>inequality</em> constraints and thus may not be active (i.e., equal to zero) at the optimal solution. It is also noted that the optimal control problem as stated above may have multiple solutions (i.e., the solution may not be unique). Thus, it is most often the case that any solution 

<math display="inline" id="Optimal_control:11">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <msup>
     <mtext>ğ±</mtext>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>t</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msup>
     <mtext>ğ®</mtext>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>t</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <msup>
    <mi>t</mi>
    <mo>*</mo>
   </msup>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>x</mtext>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>u</mtext>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <times></times>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\textbf{x}^{*}(t^{*}),\textbf{u}^{*}(t^{*}),t^{*}]
  </annotation>
 </semantics>
</math>

 to the optimal control problem is <em>locally minimizing</em>.</p>
<h2 id="linear-quadratic-control">Linear quadratic control</h2>

<p>A special case of the general nonlinear optimal control problem given in the previous section is the <a href="Linear-quadratic_regulator" title="wikilink"><em>linear quadratic</em> (LQ) optimal control problem</a>. The LQ problem is stated as follows. Minimize the <em>quadratic</em> continuous-time cost functional</p>

<p>

<math display="block" id="Optimal_control:12">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mstyle>
     <msup>
      <mi>ğ±</mi>
      <mtext>T</mtext>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mi>f</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>ğ’</mi>
      <mi>f</mi>
     </msub>
     <mi>ğ±</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mi>f</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mstyle>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">âˆ«</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <msub>
        <mi>t</mi>
        <mi>f</mi>
       </msub>
      </msubsup>
      <mrow>
       <mrow>
        <mo rspace="4.2pt" stretchy="false">[</mo>
        <mrow>
         <mrow>
          <msup>
           <mi>ğ±</mi>
           <mtext>T</mtext>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>ğ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>ğ±</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <msup>
           <mi>ğ®</mi>
           <mtext>T</mtext>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>ğ‘</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>ğ®</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo rspace="4.2pt" stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">]</mo>
       </mrow>
       <mrow>
        <mo>d</mo>
        <mi>t</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ±</ci>
       <mtext>T</mtext>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğ’</ci>
       <ci>f</ci>
      </apply>
      <ci>ğ±</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>f</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>ğ±</ci>
            <mtext>T</mtext>
           </apply>
           <ci>t</ci>
           <ci>ğ</ci>
           <ci>t</ci>
           <ci>ğ±</ci>
           <ci>t</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>ğ®</ci>
            <mtext>T</mtext>
           </apply>
           <ci>t</ci>
           <ci>ğ‘</ci>
           <ci>t</ci>
           <ci>ğ®</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <ci>normal-d</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\tfrac{1}{2}\mathbf{x}^{\text{T}}(t_{f})\mathbf{S}_{f}\mathbf{x}(t_{f})+%
\tfrac{1}{2}\int_{t_{0}}^{t_{f}}[\,\mathbf{x}^{\text{T}}(t)\mathbf{Q}(t)%
\mathbf{x}(t)+\mathbf{u}^{\text{T}}(t)\mathbf{R}(t)\mathbf{u}(t)\,]\,%
\operatorname{d}t
  </annotation>
 </semantics>
</math>

</p>

<p>Subject to the <em>linear</em> first-order dynamic constraints</p>

<p>

<math display="block" id="Optimal_control:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>ğ±</mi>
      <mo>Ë™</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>ğ€</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ğ±</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>ğ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ğ®</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-Ë™</ci>
      <ci>ğ±</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>ğ€</ci>
      <ci>t</ci>
      <ci>ğ±</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ğ</ci>
      <ci>t</ci>
      <ci>ğ®</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\mathbf{x}}(t)=\mathbf{A}(t)\mathbf{x}(t)+\mathbf{B}(t)\mathbf{u}(t),
  </annotation>
 </semantics>
</math>

</p>

<p>and the initial condition</p>

<p>

<math display="block" id="Optimal_control:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ±</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>ğ±</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğ±</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ±</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(t_{0})=\mathbf{x}_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>A particular form of the LQ problem that arises in many control system problems is that of the <em>linear quadratic regulator</em> (LQR) where all of the matrices (i.e., 

<math display="inline" id="Optimal_control:15">
 <semantics>
  <mi>ğ€</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ€</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optimal_control:16">
 <semantics>
  <mi>ğ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optimal_control:17">
 <semantics>
  <mrow>
   <mo>,</mo>
   <mi>ğ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ,\mathbf{Q}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Optimal_control:18">
 <semantics>
  <mi>ğ‘</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ‘</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

) are <em>constant</em>, the initial time is arbitrarily set to zero, and the terminal time is taken in the limit 

<math display="inline" id="Optimal_control:19">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>f</mi>
   </msub>
   <mo>â†’</mo>
   <mi mathvariant="normal">âˆ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â†’</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>f</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{f}\rightarrow\infty
  </annotation>
 </semantics>
</math>

 (this last assumption is what is known as <em>infinite horizon</em>). The LQR problem is stated as follows. Minimize the infinite horizon quadratic continuous-time cost functional</p>

<p>

<math display="block" id="Optimal_control:20">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">âˆ«</mo>
      <mn>0</mn>
      <mi mathvariant="normal">âˆ</mi>
     </msubsup>
     <mrow>
      <mrow>
       <mo rspace="4.2pt" stretchy="false">[</mo>
       <mrow>
        <mrow>
         <msup>
          <mi>ğ±</mi>
          <mtext>T</mtext>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>ğğ±</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msup>
          <mi>ğ®</mi>
          <mtext>T</mtext>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>ğ‘ğ®</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo rspace="4.2pt" stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">]</mo>
      </mrow>
      <mrow>
       <mo>d</mo>
       <mi>t</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ğ±</ci>
           <mtext>T</mtext>
          </apply>
          <ci>t</ci>
          <ci>ğğ±</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ğ®</ci>
           <mtext>T</mtext>
          </apply>
          <ci>t</ci>
          <ci>ğ‘ğ®</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\tfrac{1}{2}\int_{0}^{\infty}[\,\mathbf{x}^{\text{T}}(t)\mathbf{Q}\mathbf{x}%
(t)+\mathbf{u}^{\text{T}}(t)\mathbf{R}\mathbf{u}(t)\,]\,\operatorname{d}t
  </annotation>
 </semantics>
</math>

</p>

<p>Subject to the <em>linear time-invariant</em> first-order dynamic constraints</p>

<p>

<math display="block" id="Optimal_control:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>ğ±</mi>
      <mo>Ë™</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>ğ€ğ±</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>ğğ®</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-Ë™</ci>
      <ci>ğ±</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>ğ€ğ±</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ğğ®</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\mathbf{x}}(t)=\mathbf{A}\mathbf{x}(t)+\mathbf{B}\mathbf{u}(t),
  </annotation>
 </semantics>
</math>

</p>

<p>and the initial condition</p>

<p>

<math display="block" id="Optimal_control:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ±</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>ğ±</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğ±</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ±</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(t_{0})=\mathbf{x}_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>In the finite-horizon case the matrices are restricted in that 

<math display="inline" id="Optimal_control:23">
 <semantics>
  <mi>ğ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_control:24">
 <semantics>
  <mi>ğ‘</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ‘</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

 are positive semi-definite and positive definite, respectively. In the infinite-horizon case, however, the <a href="matrix_(mathematics)" title="wikilink">matrices</a> 

<math display="inline" id="Optimal_control:25">
 <semantics>
  <mi>ğ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_control:26">
 <semantics>
  <mi>ğ‘</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ‘</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

 are not only positive-semidefinite and positive-definite, respectively, but are also <em>constant</em>. These additional restrictions on 

<math display="inline" id="Optimal_control:27">
 <semantics>
  <mi>ğ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_control:28">
 <semantics>
  <mi>ğ‘</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ‘</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

 in the infinite-horizon case are enforced to ensure that the cost functional remains positive. Furthermore, in order to ensure that the cost function is <em>bounded</em>, the additional restriction is imposed that the pair 

<math display="inline" id="Optimal_control:29">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>ğ€</mi>
   <mo>,</mo>
   <mi>ğ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>ğ€</ci>
    <ci>ğ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{A},\mathbf{B})
  </annotation>
 </semantics>
</math>

 is <em><a href="Controllability" title="wikilink">controllable</a></em>. Note that the LQ or LQR cost functional can be thought of physically as attempting to minimize the <em>control energy</em> (measured as a quadratic form).</p>

<p>The infinite horizon problem (i.e., LQR) may seem overly restrictive and essentially useless because it assumes that the operator is driving the system to zero-state and hence driving the output of the system to zero. This is indeed correct. However the problem of driving the output to a desired nonzero level can be solved <em>after</em> the zero output one is. In fact, it can be proved that this secondary LQR problem can be solved in a very straightforward manner. It has been shown in classical optimal control theory that the LQ (or LQR) optimal control has the feedback form</p>

<p>

<math display="block" id="Optimal_control:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ®</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>ğŠ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ğ±</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğ®</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>ğŠ</ci>
      <ci>t</ci>
      <ci>ğ±</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}(t)=-\mathbf{K}(t)\mathbf{x}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Optimal_control:31">
 <semantics>
  <mrow>
   <mi>ğŠ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ğŠ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}(t)
  </annotation>
 </semantics>
</math>

 is a properly dimensioned matrix, given as</p>

<p>

<math display="block" id="Optimal_control:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ğŠ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>ğ‘</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>ğ</mi>
      <mtext>T</mtext>
     </msup>
     <mi>ğ’</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğŠ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ‘</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ</ci>
      <mtext>T</mtext>
     </apply>
     <ci>ğ’</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}(t)=\mathbf{R}^{-1}\mathbf{B}^{\text{T}}\mathbf{S}(t),
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Optimal_control:33">
 <semantics>
  <mrow>
   <mi>ğ’</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ğ’</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(t)
  </annotation>
 </semantics>
</math>

 is the solution of the differential <a href="Riccati_equation" title="wikilink">Riccati equation</a>. The differential Riccati equation is given as</p>

<p>

<math display="block" id="Optimal_control:34">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>ğ’</mi>
     <mo>Ë™</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>ğ’</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>ğ€</mi>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>ğ€</mi>
        <mtext>T</mtext>
       </msup>
       <mi>ğ’</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>ğ’</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>ğğ‘</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mi>ğ</mi>
       <mtext>T</mtext>
      </msup>
      <mi>ğ’</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>ğ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-Ë™</ci>
      <ci>ğ’</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>ğ’</ci>
         <ci>t</ci>
         <ci>ğ€</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ğ€</ci>
         <mtext>T</mtext>
        </apply>
        <ci>ğ’</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>ğ’</ci>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğğ‘</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ</ci>
        <mtext>T</mtext>
       </apply>
       <ci>ğ’</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>ğ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\mathbf{S}}(t)=-\mathbf{S}(t)\mathbf{A}-\mathbf{A}^{\text{T}}\mathbf{S}(t%
)+\mathbf{S}(t)\mathbf{B}\mathbf{R}^{-1}\mathbf{B}^{\text{T}}\mathbf{S}(t)-%
\mathbf{Q}
  </annotation>
 </semantics>
</math>

</p>

<p>For the finite horizon LQ problem, the Riccati equation is integrated backward in time using the terminal boundary condition</p>

<p>

<math display="block" id="Optimal_control:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ’</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mi>f</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>ğ’</mi>
    <mi>f</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğ’</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ’</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(t_{f})=\mathbf{S}_{f}
  </annotation>
 </semantics>
</math>

</p>

<p>For the infinite horizon LQR problem, the differential Riccati equation is replaced with the <em>algebraic</em> Riccati equation (ARE) given as</p>

<p>

<math display="block" id="Optimal_control:36">
 <semantics>
  <mrow>
   <mn>ğŸ</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mi>ğ’ğ€</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>ğ€</mi>
        <mtext>T</mtext>
       </msup>
       <mi>ğ’</mi>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>ğ’ğğ‘</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mi>ğ</mi>
       <mtext>T</mtext>
      </msup>
      <mi>ğ’</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>ğ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <minus></minus>
        <ci>ğ’ğ€</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ğ€</ci>
         <mtext>T</mtext>
        </apply>
        <ci>ğ’</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ’ğğ‘</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ</ci>
        <mtext>T</mtext>
       </apply>
       <ci>ğ’</ci>
      </apply>
     </apply>
     <ci>ğ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{0}=-\mathbf{S}\mathbf{A}-\mathbf{A}^{\text{T}}\mathbf{S}+\mathbf{S}%
\mathbf{B}\mathbf{R}^{-1}\mathbf{B}^{\text{T}}\mathbf{S}-\mathbf{Q}
  </annotation>
 </semantics>
</math>

</p>

<p>Understanding that the ARE arises from infinite horizon problem, the matrices 

<math display="inline" id="Optimal_control:37">
 <semantics>
  <mi>ğ€</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ€</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optimal_control:38">
 <semantics>
  <mi>ğ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optimal_control:39">
 <semantics>
  <mi>ğ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Optimal_control:40">
 <semantics>
  <mi>ğ‘</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ‘</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

 are all <em>constant</em>. It is noted that there are in general multiple solutions to the algebraic Riccati equation and the <em>positive definite</em> (or positive semi-definite) solution is the one that is used to compute the feedback gain. The LQ (LQR) problem was elegantly solved by <a href="Rudolf_Kalman" title="wikilink">Rudolf Kalman</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="numerical-methods-for-optimal-control">Numerical methods for optimal control</h2>

<p>Optimal control problems are generally nonlinear and therefore, generally do not have analytic solutions (e.g., like the linear-quadratic optimal control problem). As a result, it is necessary to employ numerical methods to solve optimal control problems. In the early years of optimal control (circa 1950s to 1980s) the favored approach for solving optimal control problems was that of <em>indirect methods</em>. In an indirect method, the calculus of variations is employed to obtain the first-order optimality conditions. These conditions result in a two-point (or, in the case of a complex problem, a multi-point) <a href="boundary-value_problem" title="wikilink">boundary-value problem</a>. This boundary-value problem actually has a special structure because it arises from taking the derivative of a <a href="Hamiltonian_(control_theory)" title="wikilink">Hamiltonian</a>. Thus, the resulting dynamical system is a <a href="Hamiltonian_system" title="wikilink">Hamiltonian system</a> of the form</p>

<p>

<math display="block" id="Optimal_control:41">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mover accent="true">
      <mtext>ğ±</mtext>
      <mo>Ë™</mo>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo>âˆ‚</mo>
       <mi>H</mi>
      </mrow>
      <mo>/</mo>
      <mrow>
       <mo>âˆ‚</mo>
       <mi>ğ€</mi>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mover accent="true">
      <mi>ğ€</mi>
      <mo>Ë™</mo>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mo>âˆ‚</mo>
        <mi>H</mi>
       </mrow>
       <mo>/</mo>
       <mrow>
        <mo>âˆ‚</mo>
        <mtext>ğ±</mtext>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>normal-Ë™</ci>
      <mtext>x</mtext>
     </apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>H</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>ğ€</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-Ë™</ci>
      <ci>ğ€</ci>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>H</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <mtext>x</mtext>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lcl}\dot{\textbf{x}}&=&\partial H/\partial\boldsymbol{\lambda}%
\\
\dot{\boldsymbol{\lambda}}&=&-\partial H/\partial\textbf{x}\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Optimal_control:42">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">â„’</mi>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>ğ€</mi>
       <mtext>T</mtext>
      </msup>
      <mtext>ğš</mtext>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>ğ</mi>
      <mtext>T</mtext>
     </msup>
     <mtext>ğ›</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>â„’</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ€</ci>
        <mtext>T</mtext>
       </apply>
       <mtext>a</mtext>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ</ci>
       <mtext>T</mtext>
      </apply>
      <mtext>b</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\mathcal{L}+\boldsymbol{\lambda}^{\text{T}}\textbf{a}-\boldsymbol{\mu}^{%
\text{T}}\textbf{b}
  </annotation>
 </semantics>
</math>

</p>

<p>is the <em>augmented Hamiltonian</em> and in an indirect method, the boundary-value problem is solved (using the appropriate boundary or <em>transversality</em> conditions). The beauty of using an indirect method is that the state and adjoint (i.e., 

<math display="inline" id="Optimal_control:43">
 <semantics>
  <mi>ğ€</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ€</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\lambda}
  </annotation>
 </semantics>
</math>

) are solved for and the resulting solution is readily verified to be an extremal trajectory. The disadvantage of indirect methods is that the boundary-value problem is often extremely difficult to solve (particularly for problems that span large time intervals or problems with interior point constraints). A well-known software program that implements indirect methods is BNDSCO.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The approach that has risen to prominence in numerical optimal control over the past two decades (i.e., from the 1980s to the present) is that of so-called <em>direct methods</em>. In a direct method, the state and/or control are approximated using an appropriate function approximation (e.g., polynomial approximation or piecewise constant parameterization). Simultaneously, the cost functional is approximated as a <em>cost function</em>. Then, the coefficients of the function approximations are treated as optimization variables and the problem is "transcribed" to a nonlinear optimization problem of the form:</p>

<p>Minimize</p>

<p>

<math display="block" id="Optimal_control:44">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>ğ³</mtext>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <mtext>z</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\textbf{z})\,
  </annotation>
 </semantics>
</math>

</p>

<p>subject to the algebraic constraints</p>

<p>

<math display="block" id="Optimal_control:45">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mtext>ğ </mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <mtext>ğ³</mtext>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mtext>ğŸ</mtext>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mtext>ğ¡</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <mtext>ğ³</mtext>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>â‰¤</mo>
    </mtd>
    <mtd columnalign="left">
     <mtext>ğŸ</mtext>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <mtext>g</mtext>
      <mtext>z</mtext>
     </apply>
     <eq></eq>
     <mtext>0</mtext>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <mtext>h</mtext>
      <mtext>z</mtext>
     </apply>
     <leq></leq>
     <mtext>0</mtext>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{lcl}\textbf{g}(\textbf{z})&=&\textbf{0}\\
\textbf{h}(\textbf{z})&\leq&\textbf{0}\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>Depending upon the type of direct method employed, the size of the nonlinear optimization problem can be quite small (e.g., as in a direct shooting or quasilinearization method), moderate (e.g. <a href="pseudospectral_optimal_control" title="wikilink">pseudospectral optimal control</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>) or may be quite large (e.g., a direct <a href="collocation_method" title="wikilink">collocation method</a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>). In the latter case (i.e., a collocation method), the nonlinear optimization problem may be literally thousands to tens of thousands of variables and constraints. Given the size of many NLPs arising from a direct method, it may appear somewhat counter-intuitive that solving the nonlinear optimization problem is easier than solving the boundary-value problem. It is, however, the fact that the NLP is easier to solve than the boundary-value problem. The reason for the relative ease of computation, particularly of a direct collocation method, is that the NLP is <em>sparse</em> and many well-known software programs exist (e.g., <a class="uri" href="SNOPT" title="wikilink">SNOPT</a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>) to solve large sparse NLPs. As a result, the range of problems that can be solved via direct methods (particularly direct <em>collocation methods</em> which are very popular these days) is significantly larger than the range of problems that can be solved via indirect methods. In fact, direct methods have become so popular these days that many people have written elaborate software programs that employ these methods. In particular, many such programs include <em>DIRCOL</em>,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> SOCS,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> OTIS,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> GESOP/<a class="uri" href="ASTOS" title="wikilink">ASTOS</a>,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> DITAN.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> and PyGMO/PyKEP.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> In recent years, due to the advent of the <a class="uri" href="MATLAB" title="wikilink">MATLAB</a> programming language, optimal control software in MATLAB has become more common. Examples of academically developed MATLAB software tools implementing direct methods include <em><a href="http://www.schwartz-home.com/RIOTS/">RIOTS</a></em>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><em><a href="DIDO_(optimal_control)" title="wikilink">DIDO</a></em>,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <em>DIRECT</em>,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> and <em><a href="http://gpops.sourceforge.net">GPOPS</a>,</em><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> while an example of an industry developed MATLAB tool is <em><a class="uri" href="PROPT" title="wikilink">PROPT</a></em>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> These software tools have increased significantly the opportunity for people to explore complex optimal control problems both for academic research and industrial problems. Finally, it is noted that general-purpose MATLAB optimization environments such as <a class="uri" href="TOMLAB" title="wikilink">TOMLAB</a> have made coding complex optimal control problems significantly easier than was previously possible in languages such as C and <a class="uri" href="FORTRAN" title="wikilink">FORTRAN</a>.</p>
<h2 id="discrete-time-optimal-control">Discrete-time optimal control</h2>

<p>The examples thus far have shown <a href="continuous_time" title="wikilink">continuous time</a> systems and control solutions. In fact, as optimal control solutions are now often implemented <a href="Digital_data" title="wikilink">digitally</a>, contemporary control theory is now primarily concerned with <a href="discrete_time" title="wikilink">discrete time</a> systems and solutions. The Theory of <a href="Consistent_Approximations" title="wikilink">Consistent Approximations</a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> provides conditions under which solutions to a series of increasingly accurate discretized optimal control problem converge to the solution of the original, continuous-time problem. Not all discretization methods have this property, even seemingly obvious ones. For instance, using a variable step-size routine to integrate the problem's dynamic equations may generate a gradient which does not converge to zero (or point in the right direction) as the solution is approached. The direct method <em><a href="http://www.schwartz-home.com/RIOTS">RIOTS</a></em> is based on the Theory of Consistent Approximation.</p>
<h2 id="examples">Examples</h2>

<p>A common solution strategy in many optimal control problems is to solve for the costate (sometimes called the <a href="shadow_price" title="wikilink">shadow price</a>) 

<math display="inline" id="Optimal_control:46">
 <semantics>
  <mrow>
   <mi>Î»</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Î»</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(t)
  </annotation>
 </semantics>
</math>

. The costate summarizes in one number the marginal value of expanding or contracting the state variable next turn. The marginal value is not only the gains accruing to it next turn but associated with the duration of the program. It is nice when 

<math display="inline" id="Optimal_control:47">
 <semantics>
  <mrow>
   <mi>Î»</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Î»</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(t)
  </annotation>
 </semantics>
</math>

 can be solved analytically, but usually the most one can do is describe it sufficiently well that the intuition can grasp the character of the solution and an equation solver can solve numerically for the values.</p>

<p>Having obtained 

<math display="inline" id="Optimal_control:48">
 <semantics>
  <mrow>
   <mi>Î»</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Î»</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(t)
  </annotation>
 </semantics>
</math>

, the turn-t optimal value for the control can usually be solved as a differential equation conditional on knowledge of 

<math display="inline" id="Optimal_control:49">
 <semantics>
  <mrow>
   <mi>Î»</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Î»</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(t)
  </annotation>
 </semantics>
</math>

. Again it is infrequent, especially in continuous-time problems, that one obtains the value of the control or the state explicitly. Usually the strategy is to solve for thresholds and regions that characterize the optimal control and use a numerical solver to isolate the actual choice values in time.</p>
<h3 id="finite-time">Finite time</h3>

<p>Consider the problem of a mine owner who must decide at what rate to extract ore from his mine. He owns rights to the ore from date 

<math display="inline" id="Optimal_control:50">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 to date 

<math display="inline" id="Optimal_control:51">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. At date 

<math display="inline" id="Optimal_control:52">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 there is 

<math display="inline" id="Optimal_control:53">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 ore in the ground, and the instantaneous stock of ore 

<math display="inline" id="Optimal_control:54">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)
  </annotation>
 </semantics>
</math>

 declines at the rate the mine owner extracts it u(t). The mine owner extracts ore at cost 

<math display="inline" id="Optimal_control:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>u</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>/</mo>
    <mi>x</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(t)^{2}/x(t)
  </annotation>
 </semantics>
</math>

 and sells ore at a constant price 

<math display="inline" id="Optimal_control:56">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. He does not value the ore remaining in the ground at time 

<math display="inline" id="Optimal_control:57">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 (there is no "scrap value"). He chooses the rate of extraction in time u(t) to maximize profits over the period of ownership with no time discounting.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1. Discrete-time version The manager maximizes profit 

<math display="inline" id="Optimal_control:58">
 <semantics>
  <mi mathvariant="normal">Î </mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î </ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Optimal_control:59">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Î </mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
     <mrow>
      <mi>t</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <mi>p</mi>
       <msub>
        <mi>u</mi>
        <mi>t</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mfrac>
       <msubsup>
        <mi>u</mi>
        <mi>t</mi>
        <mn>2</mn>
       </msubsup>
       <msub>
        <mi>x</mi>
        <mi>t</mi>
       </msub>
      </mfrac>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Î </ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <ci>t</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi=\sum_{t=0}^{T-1}\left[pu_{t}-\frac{u_{t}^{2}}{x_{t}}\right]
  </annotation>
 </semantics>
</math>

 subject to the law of evolution for the state variable 

<math display="inline" id="Optimal_control:60">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimal_control:61">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mpadded width="-1.7pt">
     <msub>
      <mi>u</mi>
      <mi>t</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t+1}-x_{t}=-u_{t}\!
  </annotation>
 </semantics>
</math>

 Form the Hamiltonian and differentiate:</p>

<p>

<math display="block" id="Optimal_control:62">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <msub>
      <mi>u</mi>
      <mi>t</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mfrac>
     <msubsup>
      <mi>u</mi>
      <mi>t</mi>
      <mn>2</mn>
     </msubsup>
     <msub>
      <mi>x</mi>
      <mi>t</mi>
     </msub>
    </mfrac>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>Î»</mi>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>u</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>t</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î»</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=pu_{t}-\frac{u_{t}^{2}}{x_{t}}-\lambda_{t+1}u_{t}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Optimal_control:63">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>âˆ‚</mo>
     <mi>H</mi>
    </mrow>
    <mrow>
     <mo>âˆ‚</mo>
     <msub>
      <mi>u</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <msub>
     <mi>Î»</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mfrac>
      <msub>
       <mi>u</mi>
       <mi>t</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
     </mfrac>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>H</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î»</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial H}{\partial u_{t}}=p-\lambda_{t+1}-2\frac{u_{t}}{x_{t}}=0
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Optimal_control:64">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Î»</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>Î»</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mo>âˆ‚</mo>
      <mi>H</mi>
     </mrow>
     <mrow>
      <mo>âˆ‚</mo>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <msub>
        <mi>u</mi>
        <mi>t</mi>
       </msub>
       <msub>
        <mi>x</mi>
        <mi>t</mi>
       </msub>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î»</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î»</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>H</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{t+1}-\lambda_{t}=-\frac{\partial H}{\partial x_{t}}=-\left(\frac{u_{t%
}}{x_{t}}\right)^{2}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>As the mine owner does not value the ore remaining at time 

<math display="inline" id="Optimal_control:65">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Optimal_control:66">
 <semantics>
  <mrow>
   <msub>
    <mi>Î»</mi>
    <mi>T</mi>
   </msub>
   <mo>=</mo>
   <mpadded width="-1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î»</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{T}=0\!
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Using the above equations, it is easy to solve for the 

<math display="inline" id="Optimal_control:67">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_control:68">
 <semantics>
  <msub>
   <mi>Î»</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Î»</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{t}
  </annotation>
 </semantics>
</math>

 series</p>

<p>

<math display="block" id="Optimal_control:69">
 <semantics>
  <mrow>
   <msub>
    <mi>Î»</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Î»</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>+</mo>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>p</mi>
        <mo>-</mo>
        <msub>
         <mi>Î»</mi>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mn>4</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î»</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Î»</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Î»</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{t}=\lambda_{t+1}+\frac{(p-\lambda_{t+1})^{2}}{4}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimal_control:70">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>t</mi>
    </msub>
    <mfrac>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mo>-</mo>
       <mi>p</mi>
      </mrow>
      <mo>+</mo>
      <msub>
       <mi>Î»</mi>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Î»</ci>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t+1}=x_{t}\frac{2-p+\lambda_{t+1}}{2}
  </annotation>
 </semantics>
</math>

 and using the initial and turn-T conditions, the 

<math display="inline" id="Optimal_control:71">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}
  </annotation>
 </semantics>
</math>

 series can be solved explicitly, giving 

<math display="inline" id="Optimal_control:72">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{t}
  </annotation>
 </semantics>
</math>

.</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>2. Continuous-time version The manager maximizes profit 

<math display="inline" id="Optimal_control:73">
 <semantics>
  <mi mathvariant="normal">Î </mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Î </ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Optimal_control:74">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Î </mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">âˆ«</mo>
     <mn>0</mn>
     <mi>T</mi>
    </msubsup>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <mi>p</mi>
        <mi>u</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mfrac>
        <mrow>
         <mi>u</mi>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
        <mrow>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
      </mrow>
      <mo>]</mo>
     </mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Î </ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>u</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>t</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>x</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi=\int_{0}^{T}\left[pu(t)-\frac{u(t)^{2}}{x(t)}\right]dt
  </annotation>
 </semantics>
</math>

 subject to the law of evolution for the state variable 

<math display="inline" id="Optimal_control:75">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimal_control:76">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo>Ë™</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-Ë™</ci>
      <ci>x</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}(t)=-u(t)
  </annotation>
 </semantics>
</math>

 Form the Hamiltonian and differentiate:</p>

<p>

<math display="block" id="Optimal_control:77">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>u</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>-</mo>
    <mrow>
     <mi>Î»</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>u</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Î»</ci>
      <ci>t</ci>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=pu(t)-\frac{u(t)^{2}}{x(t)}-\lambda(t)u(t)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Optimal_control:78">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>âˆ‚</mo>
     <mi>H</mi>
    </mrow>
    <mrow>
     <mo>âˆ‚</mo>
     <mi>u</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <mrow>
     <mi>Î»</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mfrac>
      <mrow>
       <mi>u</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>H</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>u</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <apply>
       <times></times>
       <ci>Î»</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial H}{\partial u}=p-\lambda(t)-2\frac{u(t)}{x(t)}=0
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Optimal_control:79">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>Î»</mi>
     <mo>Ë™</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mo>âˆ‚</mo>
      <mi>H</mi>
     </mrow>
     <mrow>
      <mo>âˆ‚</mo>
      <mi>x</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mi>u</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-Ë™</ci>
       <ci>Î»</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>H</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\lambda}(t)=-\frac{\partial H}{\partial x}=-\left(\frac{u(t)}{x(t)}\right%
)^{2}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>As the mine owner does not value the ore remaining at time 

<math display="inline" id="Optimal_control:80">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Optimal_control:81">
 <semantics>
  <mrow>
   <mrow>
    <mi>Î»</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Î»</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(T)=0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Using the above equations, it is easy to solve for the differential equations governing 

<math display="inline" id="Optimal_control:82">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(t)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_control:83">
 <semantics>
  <mrow>
   <mi>Î»</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Î»</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(t)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimal_control:84">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>Î»</mi>
     <mo>Ë™</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>p</mi>
        <mo>-</mo>
        <mrow>
         <mi>Î»</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mn>4</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-Ë™</ci>
      <ci>Î»</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>p</ci>
        <apply>
         <times></times>
         <ci>Î»</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\lambda}(t)=-\frac{(p-\lambda(t))^{2}}{4}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Optimal_control:85">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mfrac>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mrow>
       <mi>Î»</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <apply>
        <times></times>
        <ci>Î»</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(t)=x(t)\frac{p-\lambda(t)}{2}
  </annotation>
 </semantics>
</math>

 and using the initial and turn-T conditions, the functions can be solved numerically.</p></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Active_inference" title="wikilink">Active inference</a></li>
<li><a class="uri" href="APMonitor" title="wikilink">APMonitor</a> (Dynamic optimization platform for Python and MATLAB)</li>
<li><a href="Bellman_equation" title="wikilink">Bellman equation</a></li>
<li><a href="Bellman_pseudospectral_method" title="wikilink">Bellman pseudospectral method</a></li>
<li><a class="uri" href="Brachistochrone" title="wikilink">Brachistochrone</a></li>
<li><a href="DIDO_(optimal_control)" title="wikilink">DIDO</a></li>
<li><a href="DNSS_point" title="wikilink">DNSS point</a></li>
<li><a href="Dynamic_programming" title="wikilink">Dynamic programming</a></li>
<li><a href="Gauss_pseudospectral_method" title="wikilink">Gauss pseudospectral method</a></li>
<li><a href="Generalized_filtering" title="wikilink">Generalized filtering</a></li>
<li><a class="uri" href="JModelica.org" title="wikilink">JModelica.org</a> (Modelica-based open source platform for dynamic optimization)</li>
<li><a href="Kalman_filter" title="wikilink">Kalman filter</a></li>
<li><a href="Linear-quadratic_regulator" title="wikilink">Linear-quadratic regulator</a></li>
<li><a href="Model_Predictive_Control" title="wikilink">Model Predictive Control</a></li>
<li><a href="PROPT" title="wikilink"> PROPT (Optimal Control Software for MATLAB)</a></li>
<li><a href="Pseudospectral_optimal_control" title="wikilink">Pseudospectral optimal control</a></li>
<li><a class="uri" href="Pursuit-evasion" title="wikilink">Pursuit-evasion</a> games</li>
<li><a href="Sliding_mode_control" title="wikilink">Sliding mode control</a></li>
<li><a class="uri" href="SNOPT" title="wikilink">SNOPT</a></li>
<li><a href="Stochastic_control" title="wikilink">Stochastic control</a></li>
<li><a href="Trajectory_optimization" title="wikilink">Trajectory optimization</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<dl>
<dt>Books</dt>
</dl>
<ul>
<li>Athans, M. A. and Falb, P. L., <em>Optimal Control</em>, McGrawâ€“Hill, New York, 1966.</li>
<li>Becerra, V.M., 2008, <a href="http://www.scholarpedia.org/article/Optimal_control"><em>Optimal control</em></a>. <a href="http://www.scholarpedia.org">Scholarpedia</a>, 3(1):5354</li>
<li>Bryson, A. E., 1969. <em>Applied Optimal Control: Optimization, Estimation, &amp; Control</em>.</li>
<li>Bryson, A.E and Ho, Y., "<em>Applied Optimal Control: Optimization, Estimation and Control (Revised Printing)</em>", John Wiley and Sons, New York, 1975.</li>
<li>Cassel, Kevin W.: Variational Methods with Applications in Science and Engineering, Cambridge University Press, 2013.</li>
<li>Evans, L.C., <em>An Introduction to Optimal Control Theory</em> (<a href="http://math.berkeley.edu/~evans/control.course.pdf">available free online</a>)</li>
<li><a href="I._Michael_Ross" title="wikilink">Ross, I. M.</a> <em>A Primer on Pontryagin's Principle in Optimal Control</em>, Collegiate Publishers, 2009. ISBN 978-0-9843571-0-9. (http://www.ElissarGlobal.com free chapter available online)</li>
<li>H. O. Fattorini and S. S. Sritharan, "Existence of Optimal Controls for Viscous Flow Problems," Proceedings of the Royal Society of London Series A, Vol. 439, 1992, pp.Â 81â€“102.</li>
<li>H. O. Fattorini and S. S. Sritharan, "Necessary and Sufficient Conditions for Optimal Controls in Viscous Flow," Proceedings of the Royal Society of Edinburgh, Series A, Vol. 124A, 1994, pp.Â 211â€“251.</li>
<li>H. O. Fattorini and S. S. Sritharan, "Optimal chattering controls for viscous flow," Nonlinear analysis, Theory, Methods and Applications, Vol. 25, No. 8, pp.Â 763â€“797, 1995.</li>
<li>H. O. Fattorini and S. S. Sritharan,"Optimal control problems with state constraints in fluid mechanics and combustion," Applied Mathematics and Optimization, Vol. 38(2), 1998, pp.Â 159â€“192.</li>
<li>Kirk, D. E., 2004. <em>Optimal Control Theory: An Introduction</em>.</li>
<li>Lebedev, L. P., and Cloud, M. J., 2003. <em>The Calculus of Variations and Functional Analysis with Optimal Control and Applications in Mechanics</em>. World Scientific. Especially chpt. 2.</li>
<li>Lewis, F. L., and Syrmos, V. L., 19nn. <em>Optimal Control</em>, 2nd ed. John Wiley &amp; Sons.</li>
<li>S. S. Sritharan, "Optimal Control of Viscous Flow", SIAM, 1998.</li>
</ul>

<p>( <a class="uri" href="http://www.nps.edu/academics/schools/gseas/sri/Sritharan-Optimal_Control_of_Viscous_Flow.pdf">http://www.nps.edu/academics/schools/gseas/sri/Sritharan-Optimal_Control_of_Viscous_Flow.pdf</a> )</p>
<ul>
<li>S. S. Sritharan, "An Optimal Control Problem in Exterior Hydrodynamics," Proceedings of the Royal Society of Edinburgh, Series 121A, 1992, pp.Â 5â€“32.</li>
<li>S. S. Sritharan,"Deterministic and stochastic control of viscous flow with linear, monotone and hyper viscosities," Applied Mathematics and Optimization, Vol. 41(2), pp.Â 255â€“308, 2000.</li>
<li>Stengel, R. F., 1994. <em><a href="http://www.princeton.edu/~stengel/OptConEst.html">Optimal Control and Estimation.</a></em> Dover.</li>
<li>Sethi, S. P., and Thompson, G. L., 2000. <em>Optimal Control Theory: Applications to Management Science and Economics</em>, 2nd edition, Springer (ISBN 0387280928 and ISBN 0-7923-8608-6). Slides are available at <a class="uri" href="http://www.utdallas.edu/~sethi/OPRE7320presentation.html">http://www.utdallas.edu/~sethi/OPRE7320presentation.html</a></li>
<li>Sontag, Eduardo D. <em>Mathematical Control Theory: Deterministic Finite Dimensional Systems. Second Edition</em>. Springer. (ISBN 0-387-984895) (<a href="http://www.math.rutgers.edu/~sontag/FTP_DIR/sontag_mathematical_control_theory_springer98.pdf">available free online</a>)</li>
<li>Zazzera, John. 1990. <em>Modern Control Theory</em>. ISBN 0-13-589763-7</li>
<li></li>
</ul>
<dl>
<dt>Journals</dt>
</dl>
<ul>
<li><em>[<a class="uri" href="http://www3.interscience.wiley.com/cgi-bin/jhome/2133?CRETRY=1&amp;SRETRY">http://www3.interscience.wiley.com/cgi-bin/jhome/2133?CRETRY=1&amp;SRETRY;</a>;=0 Optimal Control Applications and Methods.]</em> John Wiley &amp; Sons, Inc.</li>
<li>SIAM Journal of Control and Optimization.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://apmonitor.com/do">Optimal Control Course Online</a></li>
<li>Dr. BenoÃ®t CHACHUAT: <a href="http://lawww.epfl.ch/page4234.html">Automatic Control Laboratory</a> â€“ Nonlinear Programming, Calculus of Variations and Optimal Control.</li>
<li><a href="http://www.mathworks.com/products/connections/product_detail/product_61633.html">DIDO - MATLAB tool for optimal control</a></li>
<li><a href="http://www.astos.de/products/gesop">GESOP â€“ Graphical Environment for Simulation and OPtimization</a></li>
</ul>
<ul>
<li><a href="http://tomdyn.com/">PROPT â€“ MATLAB Optimal Control Software</a></li>
<li>Elmer G. Wiens: <a href="http://www.egwald.ca/optimalcontrol/index.php">Optimal Control</a> â€“ Applications of Optimal Control Theory Using the Pontryagin Maximum Principle with interactive models.</li>
<li><a href="http://www.elissarglobal.com/home/get-chapter-2-free/">Pontryagin's Principle Illustrated with Examples</a></li>
<li>[<a class="uri" href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid">http://blog.sciencenet.cn/home.php?mod=space&amp;uid;</a>;=1565&amp;do;=blog&amp;id;=209522 On Optimal Control] by Yu-Chi Ho</li>
<li><a href="https://www.youtube.com/watch?v=faQeCI1IgoQ">Pseudospectral optimal control: Part 1</a></li>
<li><a href="https://www.youtube.com/watch?v=jRmJwQI_JZw">Pseudospectral optimal control: Part 2</a></li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Optimal_control" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">L. S. <a class="uri" href="Pontryagin" title="wikilink">Pontryagin</a>, 1962. <em>The Mathematical Theory of Optimal Processes</em>.<a href="#fnref1">â†©</a></li>
<li id="fn2"><a href="I._Michael_Ross" title="wikilink">I. M. Ross</a>, 2009. <em>A Primer on Pontryagin's Principle in Optimal Control</em>, Collegiate Publishers. ISBN 978-0-9843571-0-9.<a href="#fnref2">â†©</a></li>
<li id="fn3">Kalman, Rudolf. <em>A new approach to linear filtering and prediction problems</em>. Transactions of the ASME, Journal of Basic Engineering, 82:34â€“45, 1960<a href="#fnref3">â†©</a></li>
<li id="fn4">Oberle, H. J. and Grimm, W., "BNDSCO-A Program for the Numerical Solution of Optimal Control Problems," Institute for Flight Systems Dynamics, DLR, Oberpfaffenhofen, 1989<a href="#fnref4">â†©</a></li>
<li id="fn5"><a href="#fnref5">â†©</a></li>
<li id="fn6">Betts, J. T., <em>Practical Methods for Optimal Control Using Nonlinear Programming,</em> SIAM Press, Philadelphia, Pennsylvania, 2001<a href="#fnref6">â†©</a></li>
<li id="fn7">Gill, P. E., Murray, W. M., and Saunders, M. A., <em>User's Manual for SNOPT Version 7: Software for Large-Scale Nonlinear Programming</em>, University of California, San Diego Report, 24 April 2007<a href="#fnref7">â†©</a></li>
<li id="fn8">von Stryk, O., <em>User's Guide for DIRCOL (version 2.1): A Direct Collocation Method for the Numerical Solution of Optimal Control Problems</em>, Fachgebiet Simulation und Systemoptimierung (SIM), Technische UniversitÃ¤t Darmstadt (2000, Version of November 1999).<a href="#fnref8">â†©</a></li>
<li id="fn9">Betts, J.T. and Huffman, W. P., <em>Sparse Optimal Control Software, SOCS</em>, Boeing Information and Support Services, Seattle, Washington, July 1997<a href="#fnref9">â†©</a></li>
<li id="fn10">Hargraves, C. R. and Paris, S. W., "Direct Trajectory Optimization Using Nonlinear Programming and Collocation", <em>Journal of Guidance, Control, and Dynamics</em>, Vol. 10, No. 4., 1987, pp. 338â€“342<a href="#fnref10">â†©</a></li>
<li id="fn11">Gath, P.F., Well, K.H., "Trajectory Optimization Using a Combination of Direct Multiple Shooting and Collocation", AIAA 2001â€“4047, AIAA Guidance, Navigation, and Control Conference, MontrÃ©al, QuÃ©bec, Canada, 6â€“9 August 2001<a href="#fnref11">â†©</a></li>
<li id="fn12">Vasile M., Bernelli-Zazzera F., Fornasari N., Masarati P., "Design of Interplanetary and Lunar Missions Combining Low-Thrust and Gravity Assists", Final Report of the ESA/ESOC Study Contract No. 14126/00/D/CS, September 2002<a href="#fnref12">â†©</a></li>
<li id="fn13">Izzo, Dario. "PyGMO and PyKEP: open source tools for massively parallel optimization in astrodynamics (the case of interplanetary trajectory optimization)." Proceed. Fifth International Conf. Astrodynam. Tools and Techniques, ICATT. 2012.<a href="#fnref13">â†©</a></li>
<li id="fn14">Schwartz, Adam, <em>Theory and Implementation of Methods based on Rungeâ€“Kutta Integration for Solving Optimal Control Problems</em>, University of California at Berkeley, PhD Dissertation, 1996.<a href="#fnref14">â†©</a></li>
<li id="fn15">Ross, I. M. and Fahroo, F., <em>User's Manual for DIDO: A MATLAB Package for Dynamic Optimization</em>, Dept. of Aeronautics and Astronautics, Naval Postgraduate School Technical Report, 2002<a href="#fnref15">â†©</a></li>
<li id="fn16">Williams, P., <em>User's Guide to DIRECT, Version 2.00,</em> Melbourne, Australia, 2008<a href="#fnref16">â†©</a></li>
<li id="fn17">Rao, A. V., Benson, D. A., Huntington, G. T., Francolin, C., Darby, C. L., and Patterson, M. A., <em>User's Manual for GPOPS: A MATLAB Package for Dynamic Optimization Using the <a href="Gauss_pseudospectral_method" title="wikilink">Gauss Pseudospectral Method</a></em>, University of Florida Report, August 2008.<a href="#fnref17">â†©</a></li>
<li id="fn18">Rutquist, P. and Edvall, M. M, ''PROPT â€“ MATLAB Optimal Control Software," 1260 S.E. Bishop Blvd Ste E, Pullman, WA 99163, USA: Tomlab Optimization, Inc.<a href="#fnref18">â†©</a></li>
<li id="fn19">E. Polak, <em>On the use of consistent approximations in the solution of semi-infinite optimization and optimal control problems</em> Math. Prog. 62 pp. 385â€“415 (1993).<a href="#fnref19">â†©</a></li>
</ol>
</section>
</body>
</html>
