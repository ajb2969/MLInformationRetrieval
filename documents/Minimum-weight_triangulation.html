<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="271">Minimum-weight triangulation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Minimum-weight triangulation</h1>
<hr/>

<p>In <a href="computational_geometry" title="wikilink">computational geometry</a> and <a href="computer_science" title="wikilink">computer science</a>, the <strong>minimum-weight triangulation</strong> problem is the problem of finding a <a href="triangulation_(geometry)" title="wikilink">triangulation</a> of minimal total edge length.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> That is, an input polygon or the <a href="convex_hull" title="wikilink">convex hull</a> of an input point set must be subdivided into triangles that meet edge-to-edge and vertex-to-vertex, in such a way as to minimize the sum of the perimeters of the triangles. The problem is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> for point set inputs, but may be approximated to any desired degree of accuracy. For polygon inputs, it may be solved exactly in polynomial time. The minimum weight triangulation has also sometimes been called the <strong>optimal triangulation</strong>.</p>
<h2 id="history">History</h2>

<p>The problem of minimum weight triangulation of a point set was posed by , who suggested its application to the construction of <a href="triangulated_irregular_network" title="wikilink">triangulated irregular network</a> models of land countours, and used a <a href="greedy_heuristic" title="wikilink">greedy heuristic</a> to approximate it.  conjectured that the minimum weight triangulation always coincided with the <a href="Delaunay_triangulation" title="wikilink">Delaunay triangulation</a>, but this was quickly disproved by , and indeed  showed that the weights of the two triangulations can differ by a linear factor.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The minimum-weight triangulation problem became notorious when  included it in a list of open problems in their book on <a class="uri" href="NP-completeness" title="wikilink">NP-completeness</a>, and many subsequent authors published partial results on it. Finally,  showed it to be NP-hard, and  showed that accurate approximations to it can be constructed efficiently.</p>
<h2 id="complexity">Complexity</h2>

<p>The weight of a triangulation of a set of points in the <a href="Euclidean_plane" title="wikilink">Euclidean plane</a> is defined as the sum of lengths of its edges. Its <a href="decision_variant" title="wikilink">decision variant</a> is the problem of deciding whether there exists a triangulation of weight less than a given weight; it was proven to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> by . Their proof is by <a href="Reduction_(complexity)" title="wikilink">reduction</a> from PLANAR-1-IN-3-SAT, a special case of the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a> in which a <a class="uri" href="3-CNF" title="wikilink">3-CNF</a> whose graph is <a href="planar_graph" title="wikilink">planar</a> is accepted when it has a truth assignment that satisfies exactly <a href="One-in-three_3SAT" title="wikilink">one literal in each clause</a>. The proof uses complex <a href="Gadget_(computer_science)" title="wikilink">gadgets</a>, and involves <a href="Computer-assisted_proof" title="wikilink">computer assistance</a> to verify the correct behavior of these gadgets.</p>

<p>It is not known whether the minimum-weight triangulation decision problem is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, since this depends on the known open problem whether the <a href="sum_of_radicals" title="wikilink">sum of radicals</a> may be computed in polynomial time. However, Mulzer and Rote remark that the problem is NP-complete if the edge weights are rounded to integer values.</p>

<p>Although NP-hard, the minimum weight triangulation may be constructed in subexponential time by a <a href="dynamic_programming" title="wikilink">dynamic programming</a> algorithm that considers all possible <a href="planar_separator_theorem" title="wikilink">simple cycle separators</a> of 

<math display="inline" id="Minimum-weight_triangulation:0">
<semantics>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<msqrt>
<mi>n</mi>
</msqrt>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<root></root>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O(\sqrt{n})
  </annotation>
</semantics>
</math>

 points within the triangulation, recursively finds the optimal triangulation on each side of the cycle, and chooses the cycle separator leading to the smallest total weight. The total time for this method is 

<math display="inline" id="Minimum-weight_triangulation:1">
<semantics>
<msup>
<mn>2</mn>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msqrt>
<mi>n</mi>
</msqrt>
<mrow>
<mi>log</mi>
<mi>n</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<times></times>
<ci>O</ci>
<apply>
<times></times>
<apply>
<root></root>
<ci>n</ci>
</apply>
<apply>
<log></log>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{O(\sqrt{n}\log n)}
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="approximation">Approximation</h2>

<p>Several authors have proven results relating the minimum weight triangulation to other triangulations in terms of the <a href="approximation_ratio" title="wikilink">approximation ratio</a>, the worst-case ratio of the total edge length of the alternative triangulation to the total length of the minimum weight triangulation. In this vein, it is known that the <a href="Delaunay_triangulation" title="wikilink">Delaunay triangulation</a> has an approximation ratio of 

<math display="inline" id="Minimum-weight_triangulation:2">
<semantics>
<mrow>
<mi mathvariant="normal">Θ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-Θ</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
</semantics>
</math>

,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and that the <a href="greedy_triangulation" title="wikilink">greedy triangulation</a> (the triangulation formed by adding edges in order from shortest to longest, at each step including an edge whenever it does not cross an earlier edge) has an approximation ratio of 

<math display="inline" id="Minimum-weight_triangulation:3">
<semantics>
<mrow>
<mi mathvariant="normal">Θ</mi>
<mrow>
<mo stretchy="false">(</mo>
<msqrt>
<mi>n</mi>
</msqrt>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-Θ</ci>
<apply>
<root></root>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Theta(\sqrt{n})
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Nevertheless, for randomly distributed point sets, both the Delaunay and greedy triangulations are within a logarithmic factor of the minimum weight.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The hardness result of Mulzer and Rote also implies the NP-hardness of finding an approximate solution with relative approximation error at most O(1/n<sup>2</sup>). Thus, a <a href="fully_polynomial_approximation_scheme" title="wikilink">fully polynomial approximation scheme</a> for minimum weight triangulation is unlikely. However, a quasi-polynomial approximation scheme is possible: for any constant ε &gt; 0, a solution with approximation ratio 1 + ε can be found in <a href="quasi-polynomial_time" title="wikilink">quasi-polynomial time</a> exp(O((log <em>n</em>)<sup>9</sup>).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="heuristics">Heuristics</h2>

<p>Because of the difficulty of finding the exact solutions of the minimum-weight triangulation, many authors have studied heuristics that may in some cases find the solution although they cannot be proven to work in all cases. In particular, much of this research has focused on the problem of finding sets of edges that are guaranteed to belong to the minimum-weight triangulation. If a subgraph of the minimum-weight triangulation found in this way turns out to be connected, then the remaining untriangulated space may be viewed as forming a simple polygon, and the entire triangulation may be found by using <a href="dynamic_programming" title="wikilink">dynamic programming</a> to find the optimal triangulation of this polygonal space. The same dynamic programming approach can also be extended to the case that the subgraph has a bounded number of connected components<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and the same approach of finding a connected graph and then applying dynamic programming to fill in the polygonal gaps surrounding the graph edges has also been used as part of heuristics for finding low-weight but not minimum-weight triangulations.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>The graph formed by connecting two points whenever they are each other's nearest neighbors is necessarily a subgraph of the minimum-weight triangulation.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> However, this mutual nearest neighbor graph is a <a href="Matching_(graph_theory)" title="wikilink">matching</a>, and hence is never connected. A related line of research finds large subgraphs of the minimum-weight triangulation by using circle-based <a href="Beta_skeleton" title="wikilink"><em>β</em>-skeletons</a>, the geometric graphs formed by including an edge between two points <em>u</em> and <em>v</em> whenever there does not exist a third point <em>w</em> forming an angle <em>uwv</em> greater than some parameter θ. It has been shown that, for sufficiently small values of θ, the graph formed in this way is a subgraph of the minimum-weight triangulation.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> However, the choice of θ needed to ensure this is smaller than the angle θ = 90ª for which the <em>β</em>-skeleton is always connected.</p>

<p>A more sophisticated technique called the LMT-skeleton was proposed by . It is formed by an iterative process, in which two sets of edges are maintained, a set of edges known to belong to the minimum-weight triangulation and a set of edges that are candidates to belong to it. Initially, the set of known edges is initialized to the <a href="convex_hull" title="wikilink">convex hull</a> of the input, and all remaining pairs of vertices form candidate edges. Then, in each iteration of the construction process, candidate edges are removed whenever there is no pair of triangles formed by the remaining edges forming a quadrilateral for which the candidate edge is the shortest diagonal, and candidate edges are moved to the set of known edges when there is no other candidate edge that crosses them. The LMT-skeleton is defined to be the set of known edges produced after this process stops making any more changes. It is guaranteed to be a subgraph of the minimum-weight triangulation, can be constructed efficiently, and in experiments on sets of up to 200 points it was frequently connected.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> However it has been shown that on the average for large point sets it has a linear number of connected components.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Other heuristics that have been applied to the minimum weight triangulation problem include <a href="genetic_algorithm" title="wikilink">genetic algorithms</a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> <a href="branch_and_bound" title="wikilink">branch and bound</a>,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> and <a href="ant_colony_optimization_algorithms" title="wikilink">ant colony optimization algorithms</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="variations">Variations</h2>

<p>A <a href="polygon_triangulation" title="wikilink">polygon triangulation</a> of minimal weight may be constructed in cubic time using the <a href="dynamic_programming" title="wikilink">dynamic programming</a> approach, reported independently by  and . In this method, the vertices are numbered consecutively around the boundary of the polygon, and for each diagonal from vertex <em>i</em> to vertex <em>j</em> that lies within the polygon, the optimal triangulation is calculated by considering all possible triangles <em>ijk</em> within the polygon, adding the weights of the optimal triangulations below the diagonals <em>ik</em> and <em>jk</em>, and choosing the vertex <em>k</em> that leads to the minimum total weight. That is, if MWT(<em>i</em>,<em>j</em>) denotes the weight of the minimum-weight triangulation of the polygon below edge <em>ij</em>, then the overall algorithm performs the following steps:</p>
<ul>
<li>For each possible value of <em>i</em>, from <em>n</em> − 1 down to 1, do:
<ul>
<li>For each possible value of <em>j</em>, from <em>i</em> + 1 to <em>n</em>, do:
<ul>
<li>If <em>ij</em> is an edge of the polygon, set MWT(<em>i</em>,<em>j</em>) = length(<em>ij</em>)</li>
<li>Else if <em>ij</em> is not an interior diagonal of the polygon, set MWT(<em>i</em>,<em>j</em>) = +∞</li>
<li>Else set MWT(<em>i</em>,<em>j</em>) = length(<em>ij</em>) + min<sub><em>i</em>  MWT(<em>i</em>,<em>k</em>) + MWT(<em>k,j</em>)</sub></li>
</ul></li>
</ul></li>
</ul>

<p>After this iteration completes, MWT(1,<em>n</em>) will store the total weight of the minimum weight triangulation. The triangulation itself may be obtained by recursively searching through this array, starting from MWT(1,<em>n</em>), at each step choosing the triangle <em>ijk</em> that leads to the minimum value for MWT(<em>i</em>,<em>j</em>) and recursively searching MWT(<em>i</em>,<em>k</em>) and MWT(<em>j</em>,<em>k</em>).</p>

<p>Similar dynamic programming methods may also be adapted to point set inputs where all but a constant number of points lie on the <a href="convex_hull" title="wikilink">convex hull</a> of the input,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> and to point sets that lie on a constant number of nested convex polygons or on a constant number of lines no two of which cross within the convex hull.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>It is also possible to formulate a version of the point set or polygon triangulation problems in which one is allowed to add <a href="Steiner_point" title="wikilink">Steiner points</a>, extra vertices, in order to reduce the total edge length of the resulting triangulations. In some cases, the resulting triangulation may be shorter than the minimum weight triangulation by as much as a linear factor. It is possible to approximate the minimum weight Steiner triangulation of a point set to within a constant factor of optimal, but the constant factor in the approximation is large.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Related problems that have also been studied include the construction of minimum-weight <a href="pseudotriangulation" title="wikilink">pseudotriangulations</a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> and the characterization of the graphs of minimum-weight triangulations.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>. As cited by  and .</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://code.google.com/p/minimum-weight-triangulator/">Minimum Weight Triangulation using an LMT Skeleton source code</a>'</li>
</ul>

<p>"</p>

<p><a href="Category:NP-hard_problems" title="wikilink">Category:NP-hard problems</a> <a href="Category:Triangulation_(geometry)" title="wikilink">Category:Triangulation (geometry)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">For surveys of the problem, see , , and .<a href="#fnref1">↩</a></li>
<li id="fn2">See also .<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">. A weaker bound was given by .<a href="#fnref4">↩</a></li>
<li id="fn5">A family of examples proving that the approximation ratio is 

<math display="inline" id="Minimum-weight_triangulation:4">
<semantics>
<mrow>
<mi mathvariant="normal">Ω</mi>
<mrow>
<mo stretchy="false">(</mo>
<msqrt>
<mi>n</mi>
</msqrt>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-Ω</ci>
<apply>
<root></root>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Omega(\sqrt{n})
  </annotation>
</semantics>
</math>

 was given by , and the matching upper bound is by . As with the approximation ratio for Delaunay triangulation, a weaker bound was also given by .<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">. For earlier results on weaker approximation algorithms, see  and .<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">; .<a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
<li id="fn11">; ; ; .<a href="#fnref11">↩</a></li>
<li id="fn12">; ; ; .<a href="#fnref12">↩</a></li>
<li id="fn13">.<a href="#fnref13">↩</a></li>
<li id="fn14">; .<a href="#fnref14">↩</a></li>
<li id="fn15">.<a href="#fnref15">↩</a></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17">; ; .<a href="#fnref17">↩</a></li>
<li id="fn18">; .<a href="#fnref18">↩</a></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20">; .<a href="#fnref20">↩</a></li>
<li id="fn21">.<a href="#fnref21">↩</a></li>
</ol>
</section>
</body>
</html>
