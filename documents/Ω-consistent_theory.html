<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1064">Ω-consistent theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ω-consistent theory</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, an <strong>ω-consistent</strong> (or <strong>omega-consistent</strong>, also called <strong>numerically segregative</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) <strong>theory</strong> is a <a href="theory_(mathematical_logic)" title="wikilink">theory</a> (collection of <a href="sentence_(mathematical_logic)" title="wikilink">sentences</a>) that is not only (syntactically) <a href="Theory_(mathematical_logic)#Consistency_and_completeness" title="wikilink">consistent</a> (that is, does not prove a <a class="uri" href="contradiction" title="wikilink">contradiction</a>), but also avoids proving certain infinite combinations of sentences that are intuitively contradictory. The name is due to <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a>, who introduced the concept in the course of proving the <a href="Gödel's_incompleteness_theorems" title="wikilink">incompleteness theorem</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="definition">Definition</h2>

<p>A theory <em>T</em> is said to <a href="Interpretability" title="wikilink">interpret</a> the language of arithmetic if there is a translation of formulas of arithmetic into the language of <em>T</em> so that <em>T</em> is able to prove the basic axioms of the natural numbers under this translation.</p>

<p>A <em>T</em> that interprets arithmetic is <strong>ω-inconsistent</strong> if, for some property <em>P</em> of natural numbers (defined by a formula in the language of <em>T</em>), <em>T</em> proves <em>P</em>(0), <em>P</em>(1), <em>P</em>(2), and so on (that is, for every standard natural number <em>n</em>, <em>T</em> proves that <em>P</em>(<em>n</em>) holds), but <em>T</em> also proves that there is some (necessarily nonstandard) natural number <em>n</em> such that <em>P</em>(<em>n</em>) <em>fails</em>. This may not lead directly to an outright contradiction, because <em>T</em> may not be able to prove for any <em>specific</em> value of <em>n</em> that <em>P</em>(<em>n</em>) fails, only that there <em>is</em> such an <em>n</em>.</p>

<p><em>T</em> is <strong>ω-consistent</strong> if it is <em>not</em> ω-inconsistent.</p>

<p>There is a weaker but closely related property of Σ<sub>1</sub>-soundness. A theory <em>T</em> is <strong>Σ<sub>1</sub>-sound</strong> (or <strong>1-consistent</strong>, in another terminology) if every Σ<sup>0</sup><sub>1</sub>-sentence<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> provable in <em>T</em> is true in the standard model of arithmetic <strong>N</strong> (i.e., the structure of the usual natural numbers with addition and multiplication). If <em>T</em> is strong enough to formalize a reasonable model of <a href="theory_of_computation" title="wikilink">computation</a>, Σ<sub>1</sub>-soundness is equivalent to demanding that whenever <em>T</em> proves that a computer program <em>C</em> halts, then <em>C</em> actually halts. Every ω-consistent theory is Σ<sub>1</sub>-sound, but not vice versa.</p>

<p>More generally, we can define an analogous concept for higher levels of the <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a>. If Γ is a set of arithmetical sentences (typically Σ<sup>0</sup><sub><em>n</em></sub> for some <em>n</em>), a theory <em>T</em> is <strong>Γ-sound</strong> if every Γ-sentence provable in <em>T</em> is true in the standard model. When Γ is the set of all arithmetical formulas, Γ-soundness is called just (arithmetical) soundness. If the language of <em>T</em> consists <em>only</em> of the language of arithmetic (as opposed to, for example, set theory), then a sound system is one whose model can be thought of as the set ω, the usual set of mathematical natural numbers. The case of general <em>T</em> is different, see <a href="#ω-logic" title="wikilink">ω-logic</a> below.</p>

<p>Σ<sub><em>n</em></sub>-soundness has the following computational interpretation: if the theory proves that a program <em>C</em> using a Σ<sub><em>n</em>−1</sub>-<a href="oracle_machine" title="wikilink">oracle</a> halts, then <em>C</em> actually halts.</p>
<h2 id="examples">Examples</h2>
<h3 id="consistent-ω-inconsistent-theories">Consistent, ω-inconsistent theories</h3>

<p>Write PA for the theory <a href="Peano_axioms" title="wikilink">Peano arithmetic</a>, and Con(PA) for the statement of arithmetic that formalizes the claim "PA is consistent". Con(PA) could be of the form "For every natural number <em>n</em>, <em>n</em> is not the <a href="Gödel_number" title="wikilink">Gödel number</a> of a proof from PA that 0=1". (This formulation uses 0=1 instead of a direct contradiction; that gives the same result, because PA certainly proves ¬0=1, so if it proved 0=1 as well we would have a contradiction, and on the other hand, if PA proves a contradiction, then it proves anything, including 0=1.)</p>

<p>Now, assuming PA is really consistent, it follows that PA + ¬Con(PA) is also consistent, for if it were not, then PA would prove Con(PA) (since an inconsistent theory proves every sentence), contradicting <a href="Gödel's_second_incompleteness_theorem" title="wikilink">Gödel's second incompleteness theorem</a>. However, PA + ¬Con(PA) is <em>not</em> ω-consistent. This is because, for any particular natural number <em>n</em>, PA + ¬Con(PA) proves that <em>n</em> is not the Gödel number of a proof that 0=1 (PA itself proves that fact; the extra assumption ¬Con(PA) is not needed). However, PA + ¬Con(PA) proves that, for <em>some</em> natural number <em>n</em>, <em>n</em> <em>is</em> the Gödel number of such a proof (this is just a direct restatement of the claim ¬Con(PA) ).</p>

<p>In this example, the axiom ¬Con(PA) is Σ<sub>1</sub>, hence the system PA + ¬Con(PA) is in fact Σ<sub>1</sub>-unsound, not just ω-inconsistent.</p>
<h3 id="arithmetically-sound-ω-inconsistent-theories">Arithmetically sound, ω-inconsistent theories</h3>

<p>Let <em>T</em> be PA together with the axioms <em>c</em> ≠ <em>n</em> for each natural number <em>n</em>, where <em>c</em> is a new constant added to the language. Then <em>T</em> is arithmetically sound (as any nonstandard model of PA can be expanded to a model of <em>T</em>), but ω-inconsistent (as it proves 

<math display="inline" id="Ω-consistent_theory:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <mi>c</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\,c=x
  </annotation>
 </semantics>
</math>

, and <em>c</em> ≠ <em>n</em> for every number <em>n</em>).</p>

<p>Σ<sub>1</sub>-sound ω-inconsistent theories using only the language of arithmetic can be constructed as follows. Let <em>I</em>Σ<sub><em>n</em></sub> be the subtheory of PA with the induction schema restricted to Σ<sub><em>n</em></sub>-formulas, for any <em>n</em> &gt; 0. The theory <em>I</em>Σ<sub><em>n</em> + 1</sub> is finitely axiomatizable, let thus <em>A</em> be its single axiom, and consider the theory <em>T</em> = <em>I</em>Σ<sub><em>n</em></sub> + ¬<em>A</em>. We can assume that <em>A</em> is an instance of the induction schema, which has the form</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Ω-consistent_theory:1">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>w</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo>∀</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mo>∀</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">0</cn>
      <ci>normal-,</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-,</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall w\,[B(0,w)\land\forall x\,(B(x,w)\to B(x+1,w))\to\forall x\,B(x,w)].
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>If we denote the formula</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Ω-consistent_theory:2">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>w</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo>∀</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">0</cn>
      <ci>normal-,</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-,</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall w\,[B(0,w)\land\forall x\,(B(x,w)\to B(x+1,w))\to B(n,w)]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>by <em>P</em>(<em>n</em>), then for every natural number <em>n</em>, the theory <em>T</em> (actually, even the pure predicate calculus) proves <em>P</em>(<em>n</em>). On the other hand, <em>T</em> proves the formula 

<math display="inline" id="Ω-consistent_theory:3">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mi mathvariant="normal">¬</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>x</ci>
     <not></not>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\,\neg P(x)
  </annotation>
 </semantics>
</math>

, because it is <a href="Logical_equivalence" title="wikilink">logically equivalent</a> to the axiom ¬<em>A</em>. Therefore <em>T</em> is ω-inconsistent.</p>

<p>It is possible to show that <em>T</em> is Π<sub><em>n</em> + 3</sub>-sound. In fact, it is Π<sub><em>n</em> + 3</sub>-<a href="conservative_extension" title="wikilink">conservative</a> over the (obviously sound) theory <em>I</em>Σ<sub><em>n</em></sub>. The argument is more complicated (it relies on the provability of the Σ<sub><em>n</em> + 2</sub>-reflection principle for <em>I</em>Σ<sub><em>n</em></sub> in <em>I</em>Σ<sub><em>n</em> + 1</sub>).</p>
<h3 id="arithmetically-unsound-ω-consistent-theories">Arithmetically unsound, ω-consistent theories</h3>

<p>Let ω-Con(PA) be the arithmetical sentence formalizing the statement "PA is ω-consistent". Then the theory PA + ¬ω-Con(PA) is unsound (Σ<sub>3</sub>-unsound, to be precise), but ω-consistent. The argument is similar to the first example: a suitable version of the Hilbert-Bernays-Löb derivability conditions holds for the "provability predicate" ω-Prov(<em>A</em>) = ¬ω-Con(PA + ¬<em>A</em>), hence it satisfies an analogue of Gödel's second incompleteness theorem.</p>
<h2 id="ω-logic">ω-logic</h2>

<p>The concept of theories of arithmetic whose integers are the true mathematical integers is captured by <strong>ω-logic</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Let <em>T</em> be a theory in a countable language which includes a unary predicate symbol <em>N</em> intended to hold just of the natural numbers, as well as specified names 0, 1, 2, …, one for each (standard) natural number (which may be separate constants, or constant terms such as 0, 1, 1+1, 1+1+1, …, etc.). Note that <em>T</em> itself could be referring to more general objects, such as real numbers or sets; thus in a model of <em>T</em> the objects satisfying <em>N</em>(<em>x</em>) are those that <em>T</em> interprets as natural numbers, not all of which need be named by one of the specified names.</p>

<p>The system of ω-logic includes all axioms and rules of the usual first-order predicate logic, together with, for each <em>T</em>-formula <em>P</em>(<em>x</em>) with a specified free variable <em>x</em>, an <a href="infinitary_logic" title="wikilink">infinitary</a> <strong>ω-rule</strong> of the form:</p>
<dl>
<dd>From 

<math display="inline" id="Ω-consistent_theory:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>P</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(0),P(1),P(2),\ldots
  </annotation>
 </semantics>
</math>

 infer 

<math display="inline" id="Ω-consistent_theory:5">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">N</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\,(N(x)\to P(x))
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>That is, if the theory asserts (i.e. proves) <em>P</em>(<em>n</em>) separately for each natural number <em>n</em> given by its specified name, then it also asserts <em>P</em> collectively for all natural numbers at once via the evident finite universally quantified counterpart of the infinitely many antecedents of the rule. For a theory of arithmetic, meaning one with intended domain the natural numbers such as <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>, the predicate <em>N</em> is redundant and may be omitted from the language, with the consequent of the rule for each <em>P</em> simplifying to 

<math display="inline" id="Ω-consistent_theory:6">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\,P(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>An ω-model of <em>T</em> is a model of <em>T</em> whose domain includes the natural numbers and whose specified names and symbol <em>N</em> are standardly interpreted, respectively as those numbers and the predicate having just those numbers as its domain (whence there are no nonstandard numbers). If <em>N</em> is absent from the language then what would have been the domain of <em>N</em> is required to be that of the model, i.e. the model contains only the natural numbers. (Other models of <em>T</em> may interpret these symbols nonstandardly; the domain of <em>N</em> need not even be countable, for example.) These requirements make the ω-rule sound in every ω-model. As a corollary to the <a href="omitting_types_theorem" title="wikilink">omitting types theorem</a>, the converse also holds: the theory <em>T</em> has an ω-model if and only if it is consistent in ω-logic.</p>

<p>There is a close connection of ω-logic to ω-consistency. A theory consistent in ω-logic is also ω-consistent (and arithmetically sound). The converse is false, as consistency in ω-logic is a much stronger notion than ω-consistency. However, the following characterization holds: a theory is ω-consistent if and only if its closure under <em>unnested</em> applications of the ω-rule is consistent.</p>
<h2 id="relation-to-other-consistency-principles">Relation to other consistency principles</h2>

<p>If the theory <em>T</em> is <a href="recursively_enumerable" title="wikilink">recursively axiomatizable</a>, ω-consistency has the following characterization, due to <a href="Craig_Smoryński" title="wikilink">C. Smoryński</a>:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<dl>
<dd><em>T</em> is ω-consistent if and only if 

<math display="inline" id="Ω-consistent_theory:7">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>+</mo>
   <msub>
    <mi>RFN</mi>
    <mi>T</mi>
   </msub>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>Th</mi>
     <msubsup>
      <mi mathvariant="normal">Π</mi>
      <mn>2</mn>
      <mn>0</mn>
     </msubsup>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ℕ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>RFN</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Th</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Π</ci>
        <cn type="integer">0</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T+\mathrm{RFN}_{T}+\mathrm{Th}_{\Pi^{0}_{2}}(\mathbb{N})
  </annotation>
 </semantics>
</math>

 is consistent.
</dd>
</dl>

<p>Here, 

<math display="inline" id="Ω-consistent_theory:8">
 <semantics>
  <mrow>
   <msub>
    <mi>Th</mi>
    <msubsup>
     <mi mathvariant="normal">Π</mi>
     <mn>2</mn>
     <mn>0</mn>
    </msubsup>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ℕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Th</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Π</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Th}_{\Pi^{0}_{2}}(\mathbb{N})
  </annotation>
 </semantics>
</math>

 is the set of all Π<sup>0</sup><sub>2</sub>-sentences valid in the standard model of arithmetic, and 

<math display="inline" id="Ω-consistent_theory:9">
 <semantics>
  <msub>
   <mi>RFN</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>RFN</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{RFN}_{T}
  </annotation>
 </semantics>
</math>

 is the <a href="reflection_principle" title="wikilink">uniform reflection principle</a> for <em>T</em>, which consists of the axioms</p>

<p>

<math display="block" id="Ω-consistent_theory:10">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Prov</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">⌜</mi>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">⌝</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Prov</ci>
      <ci>T</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">⌜</csymbol>
      <csymbol cd="unknown">φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">⌝</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">φ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\,(\mathrm{Prov}_{T}(\ulcorner\varphi(\dot{x})\urcorner)\to\varphi(x))
  </annotation>
 </semantics>
</math>

 for every formula 

<math display="inline" id="Ω-consistent_theory:11">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 with one free variable. In particular, a finitely axiomatizable theory <em>T</em> in the language of arithmetic is ω-consistent if and only if <em>T</em> + PA is 

<math display="inline" id="Ω-consistent_theory:12">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{2}
  </annotation>
 </semantics>
</math>

-sound.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li>Kurt Gödel (1931). 'Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme I'. In <em>Monatshefte für Mathematik</em>. Translated into English as <a href="On_Formally_Undecidable_Propositions_of_Principia_Mathematica_and_Related_Systems" title="wikilink">On Formally Undecidable Propositions of Principia Mathematica and Related Systems</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Proof_theory" title="wikilink">Omega consistent theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="W.V.O._Quine" title="wikilink">W.V.O. Quine</a>, <em>Set Theory and its Logic</em><a href="#fnref1">↩</a></li>
<li id="fn2">Smorynski, "The incompleteness theorems", <em>Handbook of Mathematical Logic</em>, 1977, p. 851.<a href="#fnref2">↩</a></li>
<li id="fn3">The definition of this symbolism can be found at <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a>.<a href="#fnref3">↩</a></li>
<li id="fn4">J. Barwise (ed.), <em>Handbook of Mathematical Logic</em>, North-Holland, Amsterdam, 1977.<a href="#fnref4">↩</a></li>
<li id="fn5"> Reviewed in <a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
