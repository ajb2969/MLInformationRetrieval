<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="51">Consistency</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Consistency</h1>
<hr/>

<p>In <a href="classical_logic" title="wikilink">classical</a> <a href="deductive_logic" title="wikilink">deductive</a> <a class="uri" href="logic" title="wikilink">logic</a>, a <strong>consistent</strong> <a href="theory_(mathematical_logic)" title="wikilink">theory</a> is one that does not contain a <a class="uri" href="contradiction" title="wikilink">contradiction</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The lack of contradiction can be defined in either semantic or syntactic terms. The semantic definition states that a theory is consistent <a href="if_and_only_if" title="wikilink">if and only if</a> it has a <a href="Model_theory#First-order_logic" title="wikilink">model</a>, i.e. there exists an <a href="interpretation_(logic)" title="wikilink">interpretation</a> under which all <a href="Well-formed_formula" title="wikilink">formulas</a> in the theory are true. This is the sense used in traditional <a href="Term_logic" title="wikilink">Aristotelian logic</a>, although in contemporary mathematical logic the term <strong>satisfiable</strong> is used instead. The syntactic definition states that a theory is consistent if and only if there is no <a href="Formula_(mathematical_logic)" title="wikilink">formula</a> <em>P</em> such that both <em>P</em> and its negation are provable from the axioms of the theory under its associated deductive system.</p>

<p>If these semantic and syntactic definitions are equivalent for any theory formulated using a particular deductive <a href="Mathematical_logic#Formal_logical_systems" title="wikilink">logic</a>, the logic is called <strong><a href="Completeness_(logic)" title="wikilink">complete</a></strong>. The completeness of the <a href="sentential_calculus" title="wikilink">sentential calculus</a> was proved by <a href="Paul_Bernays" title="wikilink">Paul Bernays</a> in 1918<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <a href="Emil_Post" title="wikilink">Emil Post</a> in 1921,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> while the completeness of <a href="predicate_calculus" title="wikilink">predicate calculus</a> was proved by <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a> in 1930,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and consistency proofs for arithmetics restricted with respect to the <a href="Mathematical_induction" title="wikilink">induction axiom schema</a> were proved by Ackermann (1924), von Neumann (1927) and Herbrand (1931).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Stronger logics, such as <a href="second-order_logic" title="wikilink">second-order logic</a>, are not complete.</p>

<p>A <strong>consistency proof</strong> is a <a href="mathematical_proof" title="wikilink">mathematical proof</a> that a particular theory is consistent. The early development of mathematical <a href="proof_theory" title="wikilink">proof theory</a> was driven by the desire to provide finitary consistency proofs for all of mathematics as part of <a href="Hilbert's_program" title="wikilink">Hilbert's program</a>. Hilbert's program was strongly impacted by <a href="Gödel's_incompleteness_theorems" title="wikilink">incompleteness theorems</a>, which showed that sufficiently strong proof theories cannot prove their own consistency (provided that they are in fact consistent).</p>

<p>Although consistency can be proved by means of model theory, it is often done in a purely syntactical way, without any need to reference some model of the logic. The <a class="uri" href="cut-elimination" title="wikilink">cut-elimination</a> (or equivalently the <a href="Normalization_property" title="wikilink">normalization</a> of the <a href="Curry-Howard" title="wikilink">underlying calculus</a> if there is one) implies the consistency of the calculus: since there is obviously no cut-free proof of falsity, there is no contradiction in general.</p>
<h2 id="consistency-and-completeness-in-arithmetic-and-set-theory">Consistency and completeness in arithmetic and set theory</h2>

<p>In theories of arithmetic, such as <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>, there is an intricate relationship between the consistency of the theory and its <a href="completeness_(logic)" title="wikilink">completeness</a>. A theory is complete if, for every formula φ in its language, at least one of φ or ¬ φ is a logical consequence of the theory.</p>

<p><a href="Presburger_arithmetic" title="wikilink">Presburger arithmetic</a> is an axiom system for the natural numbers under addition. It is both consistent and complete.</p>

<p><a href="Gödel's_incompleteness_theorems" title="wikilink">Gödel's incompleteness theorems</a> show that any sufficiently strong effective theory of arithmetic cannot be both complete and consistent. Gödel's theorem applies to the theories of <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a> (PA) and <a href="Primitive_recursive_arithmetic" title="wikilink">Primitive recursive arithmetic</a> (PRA), but not to <a href="Presburger_arithmetic" title="wikilink">Presburger arithmetic</a>.</p>

<p>Moreover, Gödel's second incompleteness theorem shows that the consistency of sufficiently strong effective theories of arithmetic can be tested in a particular way. Such a theory is consistent if and only if it does <em>not</em> prove a particular sentence, called the Gödel sentence of the theory, which is a formalized statement of the claim that the theory is indeed consistent. Thus the consistency of a sufficiently strong, effective, consistent theory of arithmetic can never be proven in that system itself. The same result is true for effective theories that can describe a strong enough fragment of arithmetic – including set theories such as <a href="Zermelo–Fraenkel_set_theory" title="wikilink">Zermelo–Fraenkel set theory</a>. These set theories cannot prove their own Gödel sentences – provided that they are consistent, which is generally believed.</p>

<p>Because consistency of ZF is not provable in ZF, the weaker notion <strong>relative consistency</strong> is interesting in set theory (and in other sufficiently expressive axiomatic systems). If <em>T</em> is a <a href="theory_(mathematical_logic)" title="wikilink">theory</a> and <em>A</em> is an additional <a class="uri" href="axiom" title="wikilink">axiom</a>, <em>T</em> + <em>A</em> is said to be consistent relative to <em>T</em> (or simply that <em>A</em> is consistent with <em>T</em>) if it can be proved that if <em>T</em> is consistent then <em>T</em> + <em>A</em> is consistent. If both <em>A</em> and ¬<em>A</em> are consistent with <em>T</em>, then <em>A</em> is said to be <a href="Independence_(mathematical_logic)" title="wikilink">independent</a> of <em>T</em>.</p>
<h2 id="first-order-logic">First-order logic</h2>
<h3 id="notation">Notation</h3>

<p>⊢ (Turnstile symbol) in the following context of <a href="Mathematical_logic" title="wikilink">Mathematical logic</a>, means "provable from". That is, a ⊢ b reads: b is provable from a (in some specified formal system) -- see <a href="List_of_logic_symbols" title="wikilink">List of logic symbols</a>) . In other cases, the turnstile symbol may stand to mean infers; derived from. See: <a href="List_of_mathematical_symbols" title="wikilink">List of mathematical symbols</a>.</p>
<h3 id="definition">Definition</h3>

<p>A set of <a class="uri" href="formulas" title="wikilink">formulas</a> 

<math display="inline" id="Consistency:0">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 in first-order logic is <strong>consistent</strong> (written Con

<math display="inline" id="Consistency:1">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

) <a href="if_and_only_if" title="wikilink">if and only if</a> there is no formula 

<math display="inline" id="Consistency:2">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Consistency:3">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>⊢</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Φ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\vdash\phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Consistency:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Φ</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\vdash\lnot\phi
  </annotation>
 </semantics>
</math>

. Otherwise 

<math display="inline" id="Consistency:5">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is <strong>inconsistent</strong> and is written Inc

<math display="inline" id="Consistency:6">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Consistency:7">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is said to be <strong>simply consistent</strong> <a href="if_and_only_if" title="wikilink">if and only if</a> for no formula 

<math display="inline" id="Consistency:8">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Consistency:9">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

, both 

<math display="inline" id="Consistency:10">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 and the <a class="uri" href="negation" title="wikilink">negation</a> of 

<math display="inline" id="Consistency:11">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 are theorems of 

<math display="inline" id="Consistency:12">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Consistency:13">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is said to be <strong>absolutely consistent</strong> or <strong>Post consistent</strong> if and only if at least one formula of 

<math display="inline" id="Consistency:14">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is not a theorem of 

<math display="inline" id="Consistency:15">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Consistency:16">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is said to be <strong>maximally consistent</strong> if and only if for every formula 

<math display="inline" id="Consistency:17">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

, if Con (

<math display="inline" id="Consistency:18">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>∪</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>normal-Φ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\cup\phi
  </annotation>
 </semantics>
</math>

) then 

<math display="inline" id="Consistency:19">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\in\Phi
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Consistency:20">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is said to <strong>contain witnesses</strong> if and only if for every formula of the form 

<math display="inline" id="Consistency:21">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mi>x</mi>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\phi
  </annotation>
 </semantics>
</math>

 there exists a term 

<math display="inline" id="Consistency:22">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Consistency:23">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>x</mi>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mfrac>
     <mi>t</mi>
     <mi>x</mi>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <apply>
      <divide></divide>
      <ci>t</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">Φ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists x\phi\to\phi{t\over x})\in\Phi
  </annotation>
 </semantics>
</math>

. See <a href="First-order_logic" title="wikilink">First-order logic</a>.</p>
<h3 id="basic-results">Basic results</h3>
<ol>
<li>The following are equivalent:
<ol>
<li>Inc

<math display="inline" id="Consistency:24">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

</li>
<li>For all 

<math display="inline" id="Consistency:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mo rspace="5.3pt">,</mo>
     <mi mathvariant="normal">Φ</mi>
    </mrow>
    <mo>⊢</mo>
    <mi>ϕ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <ci>ϕ</ci>
     <ci>normal-Φ</ci>
    </list>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi,\;\Phi\vdash\phi.
  </annotation>
 </semantics>
</math>

</li>
</ol></li>
<li>Every satisfiable set of formulas is consistent, where a set of formulas 

<math display="inline" id="Consistency:26">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is satisfiable if and only if there exists a model 

<math display="inline" id="Consistency:27">
 <semantics>
  <mi>ℑ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℑ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{I}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Consistency:28">
 <semantics>
  <mrow>
   <mi>ℑ</mi>
   <mo>⊨</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⊨</ci>
    <ci>ℑ</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{I}\vDash\Phi
  </annotation>
 </semantics>
</math>

.</li>
<li>For all 

<math display="inline" id="Consistency:29">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Consistency:30">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

:
<ol>
<li>if not 

<math display="inline" id="Consistency:31">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>⊢</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Φ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\vdash\phi
  </annotation>
 </semantics>
</math>

, then Con

<math display="inline" id="Consistency:32">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ϕ</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>normal-Φ</ci>
    <set>
     <apply>
      <times></times>
      <not></not>
      <ci>ϕ</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\Phi\cup\{\lnot\phi\}\right)
  </annotation>
 </semantics>
</math>

;</li>
<li>if Con 

<math display="inline" id="Consistency:33">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Consistency:34">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>⊢</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Φ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\vdash\phi
  </annotation>
 </semantics>
</math>

, then Con

<math display="inline" id="Consistency:35">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>normal-Φ</ci>
    <set>
     <ci>ϕ</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\Phi\cup\{\phi\}\right)
  </annotation>
 </semantics>
</math>

;</li>
<li>if Con 

<math display="inline" id="Consistency:36">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

, then Con

<math display="inline" id="Consistency:37">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>normal-Φ</ci>
    <set>
     <ci>ϕ</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\Phi\cup\{\phi\}\right)
  </annotation>
 </semantics>
</math>

 or Con

<math display="inline" id="Consistency:38">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>ϕ</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>normal-Φ</ci>
    <set>
     <apply>
      <times></times>
      <not></not>
      <ci>ϕ</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\Phi\cup\{\lnot\phi\}\right)
  </annotation>
 </semantics>
</math>

.</li>
</ol></li>
<li>Let 

<math display="inline" id="Consistency:39">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 be a maximally consistent set of formulas and contain <a href="Witness_(mathematics)" title="wikilink">witnesses</a>. For all 

<math display="inline" id="Consistency:40">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Consistency:41">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

:
<ol>
<li>if 

<math display="inline" id="Consistency:42">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>⊢</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Φ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\vdash\phi
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Consistency:43">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\in\Phi
  </annotation>
 </semantics>
</math>

,</li>
<li>either 

<math display="inline" id="Consistency:44">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\in\Phi
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Consistency:45">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <not></not>
     <ci>ϕ</ci>
    </apply>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\phi\in\Phi
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Consistency:46">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ϕ</mi>
     <mi>ψ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\psi)\in\Phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Consistency:47">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\in\Phi
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Consistency:48">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ψ</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi\in\Phi
  </annotation>
 </semantics>
</math>

,</li>
<li>if 

<math display="inline" id="Consistency:49">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">Φ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\psi)\in\Phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Consistency:50">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\in\Phi
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Consistency:51">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ψ</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi\in\Phi
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Consistency:52">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>x</mi>
     <mi>ϕ</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\phi\in\Phi
  </annotation>
 </semantics>
</math>

 if and only if there is a term 

<math display="inline" id="Consistency:53">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Consistency:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mfrac>
     <mi>t</mi>
     <mi>x</mi>
    </mfrac>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <divide></divide>
      <ci>t</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi{t\over x}\in\Phi
  </annotation>
 </semantics>
</math>

.</li>
</ol></li>
</ol>
<h3 id="henkins-theorem">Henkin's theorem</h3>

<p>Let 

<math display="inline" id="Consistency:55">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 be a maximally consistent set of 

<math display="inline" id="Consistency:56">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

-formulas containing <a href="Witness_(mathematics)#Henkin_witnesses" title="wikilink">witnesses</a>.</p>

<p>Define a binary relation 

<math display="inline" id="Consistency:57">
 <semantics>
  <mo>∼</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">similar-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim
  </annotation>
 </semantics>
</math>

 on the set of 

<math display="inline" id="Consistency:58">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

-terms such that 

<math display="inline" id="Consistency:59">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
   <mo>∼</mo>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}\sim t_{1}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Consistency:60">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="2.8pt" width="+2.8pt">
     <mi>t</mi>
    </mpadded>
    <mn>0</mn>
   </msub>
   <mo>≡</mo>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>normal-Φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;t_{0}\equiv t_{1}\in\Phi
  </annotation>
 </semantics>
</math>

; and let 

<math display="inline" id="Consistency:61">
 <semantics>
  <mpadded width="-1.7pt">
   <mover accent="true">
    <mi>t</mi>
    <mo>¯</mo>
   </mover>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{t}\!
  </annotation>
 </semantics>
</math>

 denote the equivalence class of terms containing 

<math display="inline" id="Consistency:62">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>t</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\!
  </annotation>
 </semantics>
</math>

; and let 

<math display="inline" id="Consistency:63">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi mathvariant="normal">Φ</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mo rspace="5.3pt" stretchy="false">{</mo>
    <mpadded width="+2.8pt">
     <mover accent="true">
      <mi>t</mi>
      <mo>¯</mo>
     </mover>
    </mpadded>
    <mo rspace="5.3pt" stretchy="false">|</mo>
    <mrow>
     <mi>t</mi>
     <mo>∈</mo>
     <msup>
      <mi>T</mi>
      <mi>S</mi>
     </msup>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>normal-Φ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <in></in>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{\Phi}:=\{\;\overline{t}\;|\;t\in T^{S}\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Consistency:64">
 <semantics>
  <mpadded width="-1.7pt">
   <msup>
    <mi>T</mi>
    <mi>S</mi>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{S}\!
  </annotation>
 </semantics>
</math>

 is the set of terms based on the symbol set 

<math display="inline" id="Consistency:65">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>S</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\!
  </annotation>
 </semantics>
</math>

.</p>

<p>Define the 

<math display="inline" id="Consistency:66">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

-structure 

<math display="inline" id="Consistency:67">
 <semantics>
  <msub>
   <mi>𝔗</mi>
   <mi mathvariant="normal">Φ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔗</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{T}_{\Phi}
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Consistency:68">
 <semantics>
  <mpadded width="-1.7pt">
   <msub>
    <mi>T</mi>
    <mi mathvariant="normal">Φ</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{\Phi}\!
  </annotation>
 </semantics>
</math>

 the <strong>term-structure</strong> corresponding to 

<math display="inline" id="Consistency:69">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 by:</p>
<ol>
<li>for 

<math display="inline" id="Consistency:70">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-ary 

<math display="inline" id="Consistency:71">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>R</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\in S
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Consistency:72">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <msub>
     <mi>𝔗</mi>
     <mi mathvariant="normal">Φ</mi>
    </msub>
   </msup>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo>¯</mo>
   </mover>
   <mi mathvariant="normal">…</mi>
   <mover accent="true">
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔗</ci>
      <ci>normal-Φ</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\mathfrak{T}_{\Phi}}\overline{t_{0}}\ldots\overline{t_{n-1}}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Consistency:73">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="2.8pt" width="+2.8pt">
     <mi>R</mi>
    </mpadded>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;Rt_{0}\ldots t_{n-1}\in\Phi
  </annotation>
 </semantics>
</math>

;</li>
<li>for 

<math display="inline" id="Consistency:74">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-ary 

<math display="inline" id="Consistency:75">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in S
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Consistency:76">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <msub>
      <mi>𝔗</mi>
      <mi mathvariant="normal">Φ</mi>
     </msub>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>¯</mo>
      </mover>
      <mi mathvariant="normal">…</mi>
      <mover accent="true">
       <msub>
        <mi>t</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>¯</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mover accent="true">
    <mrow>
     <mi>f</mi>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔗</ci>
       <ci>normal-Φ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\mathfrak{T}_{\Phi}}(\overline{t_{0}}\ldots\overline{t_{n-1}}):=\overline{%
ft_{0}\ldots t_{n-1}}
  </annotation>
 </semantics>
</math>

;</li>
<li>for 

<math display="inline" id="Consistency:77">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in S
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Consistency:78">
 <semantics>
  <mrow>
   <msup>
    <mi>c</mi>
    <msub>
     <mi>𝔗</mi>
     <mi mathvariant="normal">Φ</mi>
    </msub>
   </msup>
   <mo>:=</mo>
   <mover accent="true">
    <mi>c</mi>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔗</ci>
      <ci>normal-Φ</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{\mathfrak{T}_{\Phi}}:=\overline{c}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Let 

<math display="inline" id="Consistency:79">
 <semantics>
  <mrow>
   <msub>
    <mi>ℑ</mi>
    <mi mathvariant="normal">Φ</mi>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝔗</mi>
     <mi mathvariant="normal">Φ</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>β</mi>
     <mi mathvariant="normal">Φ</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℑ</ci>
     <ci>normal-Φ</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔗</ci>
      <ci>normal-Φ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>normal-Φ</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{I}_{\Phi}:=(\mathfrak{T}_{\Phi},\beta_{\Phi})
  </annotation>
 </semantics>
</math>

 be the <strong>term interpretation</strong> associated with 

<math display="inline" id="Consistency:80">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Consistency:81">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>β</mi>
     <mi mathvariant="normal">Φ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>normal-Φ</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{\Phi}(x):=\bar{x}
  </annotation>
 </semantics>
</math>

.</p>
<center>

<p>For all 

<math display="inline" id="Consistency:82">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Consistency:83">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="2.8pt" width="+2.8pt">
     <mi>ℑ</mi>
    </mpadded>
    <mi mathvariant="normal">Φ</mi>
   </msub>
   <mo>⊨</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⊨</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℑ</ci>
     <ci>normal-Φ</ci>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\mathfrak{I}_{\Phi}\vDash\phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Consistency:84">
 <semantics>
  <mrow>
   <mpadded lspace="2.8pt" width="+2.8pt">
    <mi>ϕ</mi>
   </mpadded>
   <mo>∈</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\phi\in\Phi
  </annotation>
 </semantics>
</math>

.</p>
</center>
<h3 id="sketch-of-proof">Sketch of proof</h3>

<p>There are several things to verify. First, that 

<math display="inline" id="Consistency:85">
 <semantics>
  <mo>∼</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">similar-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim
  </annotation>
 </semantics>
</math>

 is an <a href="equivalence_relation" title="wikilink">equivalence relation</a>. Then, it needs to be verified that (1), (2), and (3) are well defined. This falls out of the fact that 

<math display="inline" id="Consistency:86">
 <semantics>
  <mo>∼</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">similar-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sim
  </annotation>
 </semantics>
</math>

 is an equivalence relation and also requires a proof that (1) and (2) are independent of the choice of 

<math display="inline" id="Consistency:87">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0},\ldots,t_{n-1}
  </annotation>
 </semantics>
</math>

 class representatives. Finally, 

<math display="inline" id="Consistency:88">
 <semantics>
  <mrow>
   <msub>
    <mi>ℑ</mi>
    <mi mathvariant="normal">Φ</mi>
   </msub>
   <mo>⊨</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⊨</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℑ</ci>
     <ci>normal-Φ</ci>
    </apply>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{I}_{\Phi}\vDash\Phi
  </annotation>
 </semantics>
</math>

 can be verified by induction on formulas.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Equiconsistency" title="wikilink">Equiconsistency</a></li>
<li><a href="Hilbert's_problems" title="wikilink">Hilbert's problems</a></li>
<li><a href="Hilbert's_second_problem" title="wikilink">Hilbert's second problem</a></li>
<li><a href="Jan_Łukasiewicz" title="wikilink">Jan Łukasiewicz</a></li>
<li><a href="Paraconsistent_logic" title="wikilink">Paraconsistent logic</a></li>
<li><a class="uri" href="ω-consistency" title="wikilink">ω-consistency</a></li>
<li><a href="Gentzen's_consistency_proof" title="wikilink">Gentzen's consistency proof</a></li>
</ul>
<h2 id="footnotes">Footnotes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li><a href="Stephen_Kleene" title="wikilink">Stephen Kleene</a>, 1952 10th impression 1991, <em>Introduction to Metamathematics</em>, North-Holland Publishing Company, Amsterday, New York, ISBN 0-7204-2103-9.</li>
<li><a href="Hans_Reichenbach" title="wikilink">Hans Reichenbach</a>, 1947, <em>Elements of Symbolic Logic</em>, Dover Publications, Inc. New York, ISBN 0-486-24004-5,</li>
<li><a href="Alfred_Tarski" title="wikilink">Alfred Tarski</a>, 1946, <em>Introduction to Logic and to the Methodology of Deductive Sciences, Second Edition</em>, Dover Publications, Inc., New York, ISBN 0-486-28462-X.</li>
<li><a href="Jean_van_Heijenoort" title="wikilink">Jean van Heijenoort</a>, 1967, <em>From Frege to Gödel: A Source Book in Mathematical Logic</em>, Harvard University Press, Cambridge, MA, ISBN 0-674-32449-8 (pbk.)</li>
<li><a href="The_Cambridge_Dictionary_of_Philosophy" title="wikilink">The Cambridge Dictionary of Philosophy</a>, <em>consistency</em></li>
<li>H.D. Ebbinghaus, J. Flum, W. Thomas, <strong>Mathematical Logic</strong></li>
<li>Jevons, W.S., 1870, <em>Elementary Lessons in Logic</em></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Chris Mortensen, <a href="http://plato.stanford.edu/entries/mathematics-inconsistent/">Inconsistent Mathematics</a>, <a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a></li>
</ul>

<p>"</p>

<p><a href="Category:Proof_theory" title="wikilink">Category:Proof theory</a> <a href="Category:Hilbert's_problems" title="wikilink">Category:Hilbert's problems</a> <a class="uri" href="Category:Metalogic" title="wikilink">Category:Metalogic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Tarski 1946 states it this way: "A deductive theory is called CONSISTENT or NON-CONTRADICTORY if no two asserted statements of this theory contradict each other, or in other words, if of any two contradictory sentences . . . at least one cannot be proved," (p. 135) where Tarski defines <em>contradictory</em> as follows: "With the help of the word <em>not</em> one forms the NEGATION of any sentence; two sentences, of which the first is a negation of the second, are called CONTRADICTORY SENTENCES" (p. 20). This definition requires a notion of "proof". Gödel in his 1931 defines the notion this way: "The class of <em>provable formulas</em> is defined to be the smallest class of formulas that contains the axioms and is closed under the relation "immediate consequence", i.e. formula <em>c</em> of <em>a</em> and <em>b</em> is defined as an <em>immediate consequence</em> in terms of <em>modus ponens</em> or substitution; cf Gödel 1931 van Heijenoort 1967:601. Tarski defines "proof" informally as "statements follow one another in a definite order according to certain principles . . . and accompanied by considerations intended to establish their validity[true conclusion for all true premises -- Reichenbach 1947:68]" cf Tarski 1946:3. Kleene 1952 defines the notion with respect to either an induction or as to paraphrase) a finite sequence of formulas such that each formula in the sequence is either an axiom or an "immediate consequence" of the preceding formulas; "A ''proof is said to be a proof <em>of</em> its last formula, and this formula is said to be <em>(formally) provable</em> or be a ''(formal) theorem" cf Kleene 1952:83.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Paraconsistent_logic" title="wikilink">Paraconsistent logic</a> <em>tolerates</em> contradictions, but toleration of contradiction does not entail consistency.<a href="#fnref2">↩</a></li>
<li id="fn3">van Heijenoort 1967:265 states that Bernays determined the <em>independence</em> of the axioms of <em>Principia Mathematica</em>, a result not published until 1926, but he says nothing about Bernays proving their <em>consistency</em>.<a href="#fnref3">↩</a></li>
<li id="fn4">Post proves both consistency and completeness of the propositional calculus of PM, cf van Heijenoort's commentary and Post's 1931 <em>Introduction to a general theory of elementary propositons</em> in van Heijenoort 1967:264ff. Also Tarski 1946:134ff.<a href="#fnref4">↩</a></li>
<li id="fn5">cf van Heijenoort's commentary and Gödel's 1930 <em>The completeness of the axioms of the functional calculus of logic</em> in van Heijenoort 1967:582ff<a href="#fnref5">↩</a></li>
<li id="fn6">cf van Heijenoort's commentary and Herbrand's 1930 <em>On the consistency of arithmetic</em> in van Heijenoort 1967:618ff.<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
