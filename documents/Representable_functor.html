<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="801">Representable functor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Representable functor</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, particularly <a href="category_theory" title="wikilink">category theory</a>, a <strong>representable functor</strong> is a <a class="uri" href="functor" title="wikilink">functor</a> of a special form from an arbitrary <a href="category_(mathematics)" title="wikilink">category</a> into the <a href="category_of_sets" title="wikilink">category of sets</a>. Such functors give representations of an abstract category in terms of known structures (i.e. <a href="Set_(mathematics)" title="wikilink">sets</a> and <a href="function_(mathematics)" title="wikilink">functions</a>) allowing one to utilize, as much as possible, knowledge about the category of sets in other settings.</p>

<p>From another point of view, representable functors for a category <em>C</em> are the functors <em>given</em> with <em>C</em>. Their theory is a vast generalisation of <a href="upper_set" title="wikilink">upper sets</a> in <a href="poset" title="wikilink">posets</a>, and of <a href="Cayley's_theorem" title="wikilink">Cayley's theorem</a> in <a href="group_theory" title="wikilink">group theory</a>.</p>
<h2 id="definition">Definition</h2>

<p>Let <strong>C</strong> be a <a href="locally_small_category" title="wikilink">locally small category</a> and let <strong>Set</strong> be the <a href="category_of_sets" title="wikilink">category of sets</a>. For each object <em>A</em> of <strong>C</strong> let Hom(<em>A</em>,–) be the <a href="hom_functor" title="wikilink">hom functor</a> that maps objects <em>X</em> to the set Hom(<em>A</em>,<em>X</em>).</p>

<p>A <a class="uri" href="functor" title="wikilink">functor</a> <em>F</em> : <strong>C</strong> → <strong>Set</strong> is said to be <strong>representable</strong> if it is <a href="naturally_isomorphic" title="wikilink">naturally isomorphic</a> to Hom(<em>A</em>,–) for some object <em>A</em> of <strong>C</strong>. A <strong>representation</strong> of <em>F</em> is a pair (<em>A</em>, Φ) where</p>
<dl>
<dd>Φ : Hom(<em>A</em>,–) → <em>F</em>
</dd>
</dl>

<p>is a natural isomorphism.</p>

<p>A <a href="contravariant_functor" title="wikilink">contravariant functor</a> <em>G</em> from <strong>C</strong> to <strong>Set</strong> is the same thing as a functor <em>G</em> : <strong>C</strong><sup>op</sup> → <strong>Set</strong> and is commonly called a <a href="presheaf_(category_theory)" title="wikilink">presheaf</a>. A presheaf is representable when it is naturally isomorphic to the contravariant hom-functor Hom(–,<em>A</em>) for some object <em>A</em> of <strong>C</strong>.</p>
<h2 id="universal-elements">Universal elements</h2>

<p>According to <a href="Yoneda's_lemma" title="wikilink">Yoneda's lemma</a>, natural transformations from Hom(<em>A</em>,–) to <em>F</em> are in one-to-one correspondence with the elements of <em>F</em>(<em>A</em>). Given a natural transformation Φ : Hom(<em>A</em>,–) → <em>F</em> the corresponding element <em>u</em> ∈ <em>F</em>(<em>A</em>) is given by</p>

<p>

<math display="block" id="Representable_functor:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Φ</mi>
      <mi>A</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>id</mi>
       <mi>A</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>id</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=\Phi_{A}(\mathrm{id}_{A}).\,
  </annotation>
 </semantics>
</math>

 Conversely, given any element <em>u</em> ∈ <em>F</em>(<em>A</em>) we may define a natural transformation Φ : Hom(<em>A</em>,–) → <em>F</em> via</p>

<p>

<math display="block" id="Representable_functor:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Φ</mi>
     <mi>X</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>X</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>f</ci>
     </apply>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{X}(f)=(Ff)(u)\,
  </annotation>
 </semantics>
</math>

 where <em>f</em> is an element of Hom(<em>A</em>,<em>X</em>). In order to get a representation of <em>F</em> we want to know when the natural transformation induced by <em>u</em> is an isomorphism. This leads to the following definition:</p>
<dl>
<dd>A <strong>universal element</strong> of a functor <em>F</em> : <strong>C</strong> → <strong>Set</strong> is a pair (<em>A</em>,<em>u</em>) consisting of an object <em>A</em> of <strong>C</strong> and an element <em>u</em> ∈ <em>F</em>(<em>A</em>) such that for every pair (<em>X</em>,<em>v</em>) with <em>v</em> ∈ <em>F</em>(<em>X</em>) there exists a unique morphism <em>f</em> : <em>A</em> → <em>X</em> such that (<em>Ff</em>)<em>u</em> = <em>v</em>.
</dd>
</dl>

<p>A universal element may be viewed as a <a href="universal_morphism" title="wikilink">universal morphism</a> from the one-point set {•} to the functor <em>F</em> or as an <a href="initial_object" title="wikilink">initial object</a> in the <a href="category_of_elements" title="wikilink">category of elements</a> of <em>F</em>.</p>

<p>The natural transformation induced by an element <em>u</em> ∈ <em>F</em>(<em>A</em>) is an isomorphism if and only if (<em>A</em>,<em>u</em>) is a universal element of <em>F</em>. We therefore conclude that representations of <em>F</em> are in one-to-one correspondence with universal elements of <em>F</em>. For this reason, it is common to refer to universal elements (<em>A</em>,<em>u</em>) as representations.</p>
<h2 id="examples">Examples</h2>
<ul>
<li>Consider the contravariant functor <em>P</em> : <strong>Set</strong> → <strong>Set</strong> which maps each set to its <a href="power_set" title="wikilink">power set</a> and each function to its <a href="inverse_image" title="wikilink">inverse image</a> map. To represent this functor we need a pair (<em>A</em>,<em>u</em>) where <em>A</em> is a set and <em>u</em> is a subset of <em>A</em>, i.e. an element of <em>P</em>(<em>A</em>), such that for all sets <em>X</em>, the hom-set Hom(<em>X</em>,<em>A</em>) is isomorphic to <em>P</em>(<em>X</em>) via Φ<sub><em>X</em></sub>(<em>f</em>) = (<em>Pf</em>)<em>u</em> = <em>f</em><sup>−1</sup>(<em>u</em>). Take <em>A</em> = {0,1} and <em>u</em> = {1}. Given a subset <em>S</em> ⊆ <em>X</em> the corresponding function from <em>X</em> to <em>A</em> is the <a href="indicator_function" title="wikilink">characteristic function</a> of <em>S</em>.</li>
<li><a href="Forgetful_functor" title="wikilink">Forgetful functors</a> to <strong>Set</strong> are very often representable. In particular, a forgetful functor is represented by (<em>A</em>, <em>u</em>) whenever <em>A</em> is a <a href="free_object" title="wikilink">free object</a> over a <a href="singleton_set" title="wikilink">singleton set</a> with generator <em>u</em>.
<ul>
<li>The forgetful functor <strong>Grp</strong> → <strong>Set</strong> on the <a href="category_of_groups" title="wikilink">category of groups</a> is represented by (<strong>Z</strong>, 1).</li>
<li>The forgetful functor <strong>Ring</strong> → <strong>Set</strong> on the <a href="category_of_rings" title="wikilink">category of rings</a> is represented by (<strong>Z</strong>[<em>x</em>], <em>x</em>), the <a href="polynomial_ring" title="wikilink">polynomial ring</a> in one <a href="Variable_(mathematics)" title="wikilink">variable</a> with <a class="uri" href="integer" title="wikilink">integer</a> <a href="coefficient" title="wikilink">coefficients</a>.</li>
<li>The forgetful functor <strong>Vect</strong> → <strong>Set</strong> on the <a href="category_of_real_vector_spaces" title="wikilink">category of real vector spaces</a> is represented by (<strong>R</strong>, 1).</li>
<li>The forgetful functor <strong>Top</strong> → <strong>Set</strong> on the <a href="category_of_topological_spaces" title="wikilink">category of topological spaces</a> is represented by any singleton topological space with its unique element.</li>
</ul></li>
<li>A <a href="group_(mathematics)" title="wikilink">group</a> <em>G</em> can be considered a category (even a <a class="uri" href="groupoid" title="wikilink">groupoid</a>) with one object which we denote by •. A functor from <em>G</em> to <strong>Set</strong> then corresponds to a <a href="G-set" title="wikilink"><em>G</em>-set</a>. The unique hom-functor Hom(•,–) from <em>G</em> to <strong>Set</strong> corresponds to the canonical <em>G</em>-set <em>G</em> with the action of left multiplication. Standard arguments from group theory show that a functor from <em>G</em> to <strong>Set</strong> is representable if and only if the corresponding <em>G</em>-set is simply transitive (i.e. a <a href="torsor" title="wikilink"><em>G</em>-torsor</a> or <a href="heap_(mathematics)" title="wikilink">heap</a>). Choosing a representation amounts to choosing an identity for the heap.</li>
<li>Let <em>C</em> be the category of <a href="CW-complex" title="wikilink">CW-complexes</a> with morphisms given by homotopy classes of continuous functions. For each natural number <em>n</em> there is a contravariant functor <em>H</em><sup><em>n</em></sup> : <em>C</em> → <strong>Ab</strong> which assigns each CW-complex its <em>n</em><sup>th</sup> <a href="cohomology_group" title="wikilink">cohomology group</a> (with integer coefficients). Composing this with the <a href="forgetful_functor" title="wikilink">forgetful functor</a> we have a contravariant functor from <em>C</em> to <strong>Set</strong>. <a href="Brown's_representability_theorem" title="wikilink">Brown's representability theorem</a> in algebraic topology says that this functor is represented by a CW-complex <em>K</em>(<strong>Z</strong>,<em>n</em>) called an <a href="Eilenberg–Mac_Lane_space" title="wikilink">Eilenberg–Mac Lane space</a>.</li>
</ul>
<h2 id="properties">Properties</h2>
<h3 id="uniqueness">Uniqueness</h3>

<p>Representations of functors are unique up to a unique isomorphism. That is, if (<em>A</em><sub>1</sub>,Φ<sub>1</sub>) and (<em>A</em><sub>2</sub>,Φ<sub>2</sub>) represent the same functor, then there exists a unique isomorphism φ : <em>A</em><sub>1</sub> → <em>A</em><sub>2</sub> such that</p>

<p>

<math display="block" id="Representable_functor:2">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Φ</mi>
     <mn>1</mn>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mo>∘</mo>
    <msub>
     <mi mathvariant="normal">Φ</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Hom</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>φ</mi>
     <mo>,</mo>
     <mo>-</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Φ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <ci>φ</ci>
      <minus></minus>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{1}^{-1}\circ\Phi_{2}=\mathrm{Hom}(\varphi,-)
  </annotation>
 </semantics>
</math>

 as natural isomorphisms from Hom(<em>A</em><sub>2</sub>,–) to Hom(<em>A</em><sub>1</sub>,–). This fact follows easily from <a href="Yoneda's_lemma" title="wikilink">Yoneda's lemma</a>.</p>

<p>Stated in terms of universal elements: if (<em>A</em><sub>1</sub>,<em>u</em><sub>1</sub>) and (<em>A</em><sub>2</sub>,<em>u</em><sub>2</sub>) represent the same functor, then there exists a unique isomorphism φ : <em>A</em><sub>1</sub> → <em>A</em><sub>2</sub> such that</p>

<p>

<math display="block" id="Representable_functor:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mi>φ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>u</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>u</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>φ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (F\varphi)u_{1}=u_{2}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="preservation-of-limits">Preservation of limits</h3>

<p>Representable functors are naturally isomorphic to Hom functors and therefore share their properties. In particular, (covariant) representable functors <a href="Limit_(category_theory)#Preservation_of_limits" title="wikilink">preserve all limits</a>. It follows that any functor which fails to preserve some limit is not representable.</p>

<p>Contravariant representable functors take colimits to limits.</p>
<h3 id="left-adjoint">Left adjoint</h3>

<p>Any functor <em>K</em> : <em>C</em> → <strong>Set</strong> with a <a href="left_adjoint" title="wikilink">left adjoint</a> <em>F</em> : <strong>Set</strong> → <em>C</em> is represented by (<em>FX</em>, η<sub><em>X</em></sub>(•)) where <em>X</em> = {•} is a <a href="singleton_set" title="wikilink">singleton set</a> and η is the unit of the adjunction.</p>

<p>Conversely, if <em>K</em> is represented by a pair (<em>A</em>, <em>u</em>) and all small <a href="copower" title="wikilink">copowers</a> of <em>A</em> exist in <em>C</em> then <em>K</em> has a left adjoint <em>F</em> which sends each set <em>I</em> to the <em>I</em>th copower of <em>A</em>.</p>

<p>Therefore, if <em>C</em> is a category with all small copowers, a functor <em>K</em> : <em>C</em> → <strong>Set</strong> is representable if and only if it has a left adjoint.</p>
<h2 id="relation-to-universal-morphisms-and-adjoints">Relation to universal morphisms and adjoints</h2>

<p>The categorical notions of <a href="universal_morphism" title="wikilink">universal morphisms</a> and <a href="adjoint_functor" title="wikilink">adjoint functors</a> can both be expressed using representable functors.</p>

<p>Let <em>G</em> : <em>D</em> → <em>C</em> be a functor and let <em>X</em> be an object of <em>C</em>. Then (<em>A</em>,φ) is a universal morphism from <em>X</em> to <em>G</em> <a href="if_and_only_if" title="wikilink">if and only if</a> (<em>A</em>,φ) is a representation of the functor Hom<sub><em>C</em></sub>(<em>X</em>,<em>G</em>–) from <em>D</em> to <strong>Set</strong>. It follows that <em>G</em> has a left-adjoint <em>F</em> if and only if Hom<sub><em>C</em></sub>(<em>X</em>,<em>G</em>–) is representable for all <em>X</em> in <em>C</em>. The natural isomorphism Φ<sub><em>X</em></sub> : Hom<sub><em>D</em></sub>(<em>FX</em>,–) → Hom<sub><em>C</em></sub>(<em>X</em>,<em>G</em>–) yields the adjointness; that is</p>

<p>

<math display="block" id="Representable_functor:4">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Hom</mi>
      <mi class="ltx_font_mathcaligraphic">𝒟</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mi>X</mi>
      </mrow>
      <mo>,</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mi>Hom</mi>
      <mi class="ltx_font_mathcaligraphic">𝒞</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <mrow>
       <mi>G</mi>
       <mi>Y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Φ</ci>
     <list>
      <ci>X</ci>
      <ci>Y</ci>
     </list>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>𝒟</ci>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>X</ci>
       </apply>
       <ci>Y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>𝒞</ci>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>Y</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{X,Y}\colon\mathrm{Hom}_{\mathcal{D}}(FX,Y)\to\mathrm{Hom}_{\mathcal{C}}(%
X,GY)
  </annotation>
 </semantics>
</math>

 is a bijection for all <em>X</em> and <em>Y</em>.</p>

<p>The dual statements are also true. Let <em>F</em> : <em>C</em> → <em>D</em> be a functor and let <em>Y</em> be an object of <em>D</em>. Then (<em>A</em>,φ) is a universal morphism from <em>F</em> to <em>Y</em> if and only if (<em>A</em>,φ) is a representation of the functor Hom<sub><em>D</em></sub>(<em>F</em>–,<em>Y</em>) from <em>C</em> to <strong>Set</strong>. It follows that <em>F</em> has a right-adjoint <em>G</em> if and only if Hom<sub><em>D</em></sub>(<em>F</em>–,<em>Y</em>) is representable for all <em>Y</em> in <em>D</em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Subobject_classifier" title="wikilink">Subobject classifier</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Representable_functors" title="wikilink"> </a></p>
</body>
</html>
