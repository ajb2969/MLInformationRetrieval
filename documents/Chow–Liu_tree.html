<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="16">Chow–Liu tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Chow–Liu tree</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>400 px|A first-order dependency tree representing the product on the left.</figcaption>
</figure>

<p>In probability theory and statistics <strong>Chow–Liu tree</strong> is an efficient method for constructing a second-<a href="Orders_of_approximation" title="wikilink">order</a> product approximation of a <a href="joint_probability_distribution" title="wikilink">joint probability distribution</a>, first described in a paper by . The goals of such a decomposition, as with such <a href="Bayesian_networks" title="wikilink">Bayesian networks</a> in general, may be either <a href="data_compression" title="wikilink">data compression</a> or <a class="uri" href="inference" title="wikilink">inference</a>.</p>
<h2 id="the-chowliu-representation">The Chow–Liu representation</h2>

<p>The Chow–Liu method describes a <a href="joint_probability_distribution" title="wikilink">joint probability distribution</a> 

<math display="inline" id="Chow–Liu_tree:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X_{1},X_{2},\ldots,X_{n})
  </annotation>
 </semantics>
</math>

 as a product of second-order conditional and marginal distributions. For example, the six-dimensional distribution 

<math display="inline" id="Chow–Liu_tree:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>5</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">6</cn>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X_{1},X_{2},X_{3},X_{4},X_{5},X_{6})
  </annotation>
 </semantics>
</math>

 might be approximated as</p>

<p>

<math display="block" id="Chow–Liu_tree:2">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>5</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>6</mn>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mn>5</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>5</mn>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>4</mn>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}(X_{1},X_{2},X_{3},X_{4},X_{5},X_{6})=P(X_{6}|X_{5})P(X_{5}|X_{2})P(%
X_{4}|X_{2})P(X_{3}|X_{2})P(X_{2}|X_{1})P(X_{1})
  </annotation>
 </semantics>
</math>

</p>

<p>where each new term in the product introduces just one new variable, and the product can be represented as a first-order dependency tree, as shown in the figure. The Chow–Liu algorithm (below) determines which conditional probabilities are to be used in the product approximation. In general, unless there are no third-order or higher-order interactions, the Chow–Liu approximation is indeed an <em>approximation</em>, and cannot capture the complete structure of the original distribution.  provides a modern analysis of the Chow–Liu tree as a <a href="Bayesian_network" title="wikilink">Bayesian network</a>.</p>
<h2 id="the-chowliu-algorithm">The Chow–Liu algorithm</h2>

<p>Chow and Liu show how to select second-order terms for the product approximation so that, among all such second-order approximations (first-order dependency trees), the constructed approximation 

<math display="inline" id="Chow–Liu_tree:3">
 <semantics>
  <msup>
   <mi>P</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}
  </annotation>
 </semantics>
</math>

 has the minimum <a href="Kullback–Leibler_distance" title="wikilink">Kullback–Leibler distance</a> to the actual distribution 

<math display="inline" id="Chow–Liu_tree:4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, and is thus the <em>closest</em> approximation in the classical <a href="information_theory" title="wikilink">information-theoretic</a> sense. The Kullback–Leibler distance between a second-order product approximation and the actual distribution is shown to be</p>

<p>

<math display="block" id="Chow–Liu_tree:5">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>∥</mo>
    <msup>
     <mi>P</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>;</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>j</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <sum></sum>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-;</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <sum></sum>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(P\parallel P^{\prime})=-\sum I(X_{i};X_{j(i)})+\sum H(X_{i})-H(X_{1},X_{2},%
\ldots,X_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Chow–Liu_tree:6">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>;</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>j</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(X_{i};X_{j(i)})
  </annotation>
 </semantics>
</math>

 is the <a href="mutual_information" title="wikilink">mutual information</a> between variable 

<math display="inline" id="Chow–Liu_tree:7">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 and its parent 

<math display="inline" id="Chow–Liu_tree:8">
 <semantics>
  <msub>
   <mi>X</mi>
   <mrow>
    <mi>j</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{j(i)}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Chow–Liu_tree:9">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X_{1},X_{2},\ldots,X_{n})
  </annotation>
 </semantics>
</math>

 is the <a href="joint_entropy" title="wikilink">joint entropy</a> of variable set 

<math display="inline" id="Chow–Liu_tree:10">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{X_{1},X_{2},\ldots,X_{n}\}
  </annotation>
 </semantics>
</math>

. Since the terms 

<math display="inline" id="Chow–Liu_tree:11">
 <semantics>
  <mrow>
   <mo largeop="true" symmetric="true">∑</mo>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <sum></sum>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum H(X_{i})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Chow–Liu_tree:12">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X_{1},X_{2},\ldots,X_{n})
  </annotation>
 </semantics>
</math>

 are independent of the dependency ordering in the tree, only the sum of the pairwise <a href="mutual_information" title="wikilink">mutual informations</a>, 

<math display="inline" id="Chow–Liu_tree:13">
 <semantics>
  <mrow>
   <mo largeop="true" symmetric="true">∑</mo>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mo>;</mo>
     <msub>
      <mi>X</mi>
      <mrow>
       <mi>j</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <sum></sum>
    <apply>
     <times></times>
     <ci>I</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum I(X_{i};X_{j(i)})
  </annotation>
 </semantics>
</math>

, determines the quality of the approximation. Thus, if every branch (edge) on the tree is given a weight corresponding to the mutual information between the variables at its vertices, then the tree which provides the optimal second-order approximation to the target distribution is just the <em>maximum-weight tree</em>. The equation above also highlights the role of the dependencies in the approximation: When no dependencies exist, and the first term in the equation is absent, we have only an approximation based on first-order marginals, and the distance between the approximation and the true distribution is due to the redundancies that are not accounted for when the variables are treated as independent. As we specify second-order dependencies, we begin to capture some of that structure and reduce the distance between the two distributions.</p>

<p>Chow and Liu provide a simple algorithm for constructing the optimal tree; at each stage of the procedure the algorithm simply adds the maximum <a href="mutual_information" title="wikilink">mutual information</a> pair to the tree. See the original paper, , for full details. A more efficient tree construction algorithm for the common case of sparse data was outlined in .</p>

<p>Chow and Wagner proved in a later paper  that the learning of the Chow–Liu tree is consistent given samples (or observations) drawn i.i.d. from a tree-structured distribution. In other words, the probability of learning an incorrect tree decays to zero as the number of samples tends to infinity. The main idea in the proof is the continuity of the mutual information in the pairwise marginal distribution. Recently, the exponential rate of convergence of the error probability was provided.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="variations-on-chowliu-trees">Variations on Chow–Liu trees</h2>

<p>The obvious problem which occurs when the actual distribution is not in fact a second-order dependency tree can still in some cases be addressed by fusing or aggregating together densely connected subsets of variables to obtain a "large-node" Chow–Liu tree , or by extending the idea of greedy maximum branch weight selection to non-tree (multiple parent) structures . (Similar techniques of variable substitution and construction are common in the <a href="Bayes_network" title="wikilink">Bayes network</a> literature, e.g., for dealing with loops. See .)</p>

<p>Generalizations of the Chow–Liu tree are the so called <a href="t-cherry_junction_trees" title="wikilink">t-cherry junction trees</a>. It is proved that the t-cherry junction trees provide a better or at least as good approximation for a discrete multivariate probability distribution as the Chow–Liu tree gives. For the third order t-cherry junction tree see , for the <em>k</em>th-order t-cherry junction tree see . The second order t-cherry junction tree is in fact the Chow–Liu tree.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bayesian_network" title="wikilink">Bayesian network</a></li>
<li><a href="Knowledge_representation" title="wikilink">Knowledge representation</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Knowledge_representation" title="wikilink">Category:Knowledge representation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A Large-Deviation Analysis for the Maximum-Likelihood Learning of Tree Structures. V. Y. F. Tan, A. Anandkumar, L. Tong and A. Willsky. In the International symposium on information theory (ISIT), July 2009.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
