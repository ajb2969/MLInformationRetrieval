<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="895">Inversive congruential generator</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Inversive congruential generator</h1>
<hr/>

<p><strong>Inversive congruential generators</strong> are a type of nonlinear congruential <a href="pseudorandom_number_generator" title="wikilink">pseudorandom number generator</a>, which use the <a href="modular_multiplicative_inverse" title="wikilink">modular multiplicative inverse</a> (if it exists) to generate the next number in a sequence. The standard formula for an inversive congruential generator, modulo some prime <em>q</em> is:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Inversive_congruential_generator:0">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}=
  </annotation>
 </semantics>
</math>

 seed</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Inversive_congruential_generator:1">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>‚â°</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <msubsup>
        <mi>x</mi>
        <mi>i</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
      </mrow>
      <mo>+</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i+1}\equiv(ax_{i}^{-1}+c)\mod q
  </annotation>
 </semantics>
</math>

 ¬†</p></td>
<td style="text-align: left;">
<p>| if 

<math display="inline" id="Inversive_congruential_generator:2">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>‚â†</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\neq 0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Inversive_congruential_generator:3">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i+1}=c
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>if 

<math display="inline" id="Inversive_congruential_generator:4">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=0
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>Such a generator is denoted symbolically as ICG(q,a,c,seed) and is said to be an ICG with parameters <em>q</em>,<em>a</em>,<em>c</em> and seed <em>seed</em>.</p>
<h2 id="period">Period</h2>

<p>The sequence 

<math display="inline" id="Inversive_congruential_generator:5">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{n})_{n\geq 0}
  </annotation>
 </semantics>
</math>

 must have 

<math display="inline" id="Inversive_congruential_generator:6">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=x_{j}
  </annotation>
 </semantics>
</math>

 after finitely many steps and since the next element depends only on its direct predecessor also 

<math display="inline" id="Inversive_congruential_generator:7">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i+1}=x_{j+1}
  </annotation>
 </semantics>
</math>

 etc. The maximum length that the <a href="periodic_function" title="wikilink">period</a> <em>T</em> for a function modulo <em>q</em> can have is . If the <a class="uri" href="polynomial" title="wikilink">polynomial</a> 

<math display="inline" id="Inversive_congruential_generator:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mi>c</mi>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mi>a</mi>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <msub>
     <mi>ùîΩ</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>x</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùîΩ</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{2}-cx-a\in\mathbb{F}_{q}[x]
  </annotation>
 </semantics>
</math>


 (polynomial ring over 

<math display="inline" id="Inversive_congruential_generator:9">
 <semantics>
  <msub>
   <mi>ùîΩ</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ùîΩ</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{q}
  </annotation>
 </semantics>
</math>

) is <a href="Primitive_polynomial_(ring_theory)#Formal_statements" title="wikilink">primitive</a>, then the sequence will have the maximum length. Such polynomials are called inversive maximal period (IMP) polynomials. The sufficient condition for maximum sequence period is a proper choice of parameters <em>a</em> and <em>c</em> according to the <a class="uri" href="algorithm" title="wikilink">algorithm</a> described in.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Eichenauer-Herrmann, Lehn, Grothe and <a href="Harald_Niederreiter" title="wikilink">Niederreiter</a> have shown that inversive congruential generators have good uniformity properties, in particular with regard to lattice structure and serial correlations.</p>
<h2 id="example">Example</h2>

<p>ICG(5,2,3,1) gives the sequence:(1,0,3,2,4,1,.....) (as in 

<math display="inline" id="Inversive_congruential_generator:10">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>‚àà</mo>
   <msub>
    <mi>ùîΩ</mi>
    <mn>5</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùîΩ</ci>
     <cn type="integer">5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in\mathbb{F}_{5}
  </annotation>
 </semantics>
</math>

, 1 and 4 are their own inverse, 2 is the inverse of 3 and conversely). In this example 

<math display="inline" id="Inversive_congruential_generator:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mn>3</mn>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>x</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{2}-3x-2
  </annotation>
 </semantics>
</math>

 is irreducible in 

<math display="inline" id="Inversive_congruential_generator:12">
 <semantics>
  <mrow>
   <msub>
    <mi>ùîΩ</mi>
    <mn>5</mn>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùîΩ</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{5}[x]
  </annotation>
 </semantics>
</math>

 as neither 0,1,2,3 or 4 are roots, and therefore the period is equal to .In order to show that <em>f</em> is primitive one should show that <em>x</em> is a <a href="primitive_element_(finite_field)" title="wikilink">primitive element</a> of 

<math display="inline" id="Inversive_congruential_generator:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ùîΩ</mi>
     <mn>5</mn>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùîΩ</ci>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{5}[x]/(f)
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="compound-inversive-generator">Compound Inversive Generator</h2>

<p>The construction of a Compound Inversive Generator (CIG) relies on combining two or more congruential inversive generators according to the method described below.</p>

<p>Let 

<math display="inline" id="Inversive_congruential_generator:14">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>r</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},\dots,p_{r}
  </annotation>
 </semantics>
</math>

 be distinct prime integers, each 

<math display="inline" id="Inversive_congruential_generator:15">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>j</mi>
   </msub>
   <mo>‚â•</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>j</ci>
    </apply>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{j}\geq 5
  </annotation>
 </semantics>
</math>

. For each index j,1‚â§ j ‚â§ r, let 

<math display="inline" id="Inversive_congruential_generator:16">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{n})_{n\geq 0}
  </annotation>
 </semantics>
</math>

 be a sequence of elements of 

<math display="inline" id="Inversive_congruential_generator:17">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>‚àà</mo>
   <msub>
    <mi>ùîΩ</mi>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùîΩ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in\mathbb{F}_{p_{j}}
  </annotation>
 </semantics>
</math>

, that is periodic with period length 

<math display="inline" id="Inversive_congruential_generator:18">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{j}
  </annotation>
 </semantics>
</math>


. In other words,

<math display="inline" id="Inversive_congruential_generator:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <msubsup>
     <mi>x</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo stretchy="false">|</mo>
    <mn>0</mn>
    <mo>‚â§</mo>
    <mi>n</mi>
    <mo>‚â§</mo>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>=</mo>
   <mo>‚àà</mo>
   <msub>
    <mi>ùîΩ</mi>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>j</ci>
     </apply>
     <ci>normal-|</ci>
     <cn type="integer">0</cn>
     <leq></leq>
     <csymbol cd="unknown">n</csymbol>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-}</ci>
    </cerror>
    <eq></eq>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùîΩ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{n}^{(j)}|0\leq n\leq p_{j}\}=\in\mathbb{F}_{p_{j}}
  </annotation>
 </semantics>
</math>

.</p>

<p>For each index j, 1‚â§ j ‚â§ r, we consider 

<math display="inline" id="Inversive_congruential_generator:20">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mo>/</mo>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{j}=T/p_{j}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Inversive_congruential_generator:21">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">‚ãØ</mi>
    <msub>
     <mi>p</mi>
     <mi>r</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚ãØ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=p_{1}\cdots p_{r}
  </annotation>
 </semantics>
</math>

 is the period length of the following sequence 

<math display="inline" id="Inversive_congruential_generator:22">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{n})_{n\geq 0}
  </annotation>
 </semantics>
</math>

.</p>

<p>The sequence 

<math display="inline" id="Inversive_congruential_generator:23">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>‚â•</mo>
    <mn>0</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{n})_{n\geq 0}
  </annotation>
 </semantics>
</math>


 of compound pseudorandom numbers is defined as the sum</p>

<p>

<math display="block" id="Inversive_congruential_generator:24">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>T</mi>
       <mn>1</mn>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mn>2</mn>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mi>r</mi>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>r</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=T_{1}x_{n}^{(1)}+T_{2}x_{n}^{(2)}+\dots+T_{r}x_{n}^{(r)}\mod T
  </annotation>
 </semantics>
</math>

. The compound approach allows combining Inversive Congruential Generators, provided they have full period, in parallel generation systems.</p>
<h2 id="example-1">Example</h2>

<p>Let 

<math display="inline" id="Inversive_congruential_generator:25">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}=5
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Inversive_congruential_generator:26">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>7</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>=</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
    <eq></eq>
    <cn type="integer">7</cn>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <eq></eq>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{2}=7(r=2)
  </annotation>
 </semantics>
</math>

. To simplify, take 

<math display="inline" id="Inversive_congruential_generator:27">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>x</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>‚â•</mo>
     <mn>0</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <vector>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
     <ci>normal-‚Ä¶</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{n}^{(1)})_{n\geq 0}=(0,1,2,3,4,\dots)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Inversive_congruential_generator:28">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>x</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>‚â•</mo>
     <mn>0</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>5</mn>
    <mo>,</mo>
    <mn>6</mn>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <vector>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
     <cn type="integer">5</cn>
     <cn type="integer">6</cn>
     <ci>normal-‚Ä¶</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{n}^{(2)})_{n\geq 0}=(0,1,2,3,4,5,6,\dots)
  </annotation>
 </semantics>
</math>


. We compute for every 1‚â§ j‚â§ 35, 

<math display="inline" id="Inversive_congruential_generator:29">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>7</mn>
      <msubsup>
       <mi>x</mi>
       <mi>j</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>5</mn>
      <msubsup>
       <mi>x</mi>
       <mi>j</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>35</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">7</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">5</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">35</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}=7x_{j}^{(1)}+5x_{j}^{(2)}\mod 35
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Inversive_congruential_generator:30">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>‚â•</mo>
     <mn>0</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>12</mn>
    <mo>,</mo>
    <mn>24</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>13</mn>
    <mo>,</mo>
    <mn>25</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>14</mn>
    <mo>,</mo>
    <mn>26</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>15</mn>
    <mo>,</mo>
    <mn>27</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>16</mn>
    <mo>,</mo>
    <mn>28</mn>
    <mo>,</mo>
    <mn>5</mn>
    <mo>,</mo>
    <mn>17</mn>
    <mo>,</mo>
    <mn>29</mn>
    <mo>,</mo>
    <mn>6</mn>
    <mo>,</mo>
    <mn>18</mn>
    <mo>,</mo>
    <mn>30</mn>
    <mo>,</mo>
    <mn>7</mn>
    <mo>,</mo>
    <mn>19</mn>
    <mo>,</mo>
    <mn>31</mn>
    <mo>,</mo>
    <mn>8</mn>
    <mo>,</mo>
    <mn>20</mn>
    <mo>,</mo>
    <mn>32</mn>
    <mo>,</mo>
    <mn>9</mn>
    <mo>,</mo>
    <mn>21</mn>
    <mo>,</mo>
    <mn>33</mn>
    <mo>,</mo>
    <mn>10</mn>
    <mo>,</mo>
    <mn>22</mn>
    <mo>,</mo>
    <mn>34</mn>
    <mo>,</mo>
    <mn>11</mn>
    <mo>,</mo>
    <mn>23</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <geq></geq>
      <ci>n</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <vector>
     <cn type="integer">0</cn>
     <cn type="integer">12</cn>
     <cn type="integer">24</cn>
     <cn type="integer">1</cn>
     <cn type="integer">13</cn>
     <cn type="integer">25</cn>
     <cn type="integer">2</cn>
     <cn type="integer">14</cn>
     <cn type="integer">26</cn>
     <cn type="integer">3</cn>
     <cn type="integer">15</cn>
     <cn type="integer">27</cn>
     <cn type="integer">4</cn>
     <cn type="integer">16</cn>
     <cn type="integer">28</cn>
     <cn type="integer">5</cn>
     <cn type="integer">17</cn>
     <cn type="integer">29</cn>
     <cn type="integer">6</cn>
     <cn type="integer">18</cn>
     <cn type="integer">30</cn>
     <cn type="integer">7</cn>
     <cn type="integer">19</cn>
     <cn type="integer">31</cn>
     <cn type="integer">8</cn>
     <cn type="integer">20</cn>
     <cn type="integer">32</cn>
     <cn type="integer">9</cn>
     <cn type="integer">21</cn>
     <cn type="integer">33</cn>
     <cn type="integer">10</cn>
     <cn type="integer">22</cn>
     <cn type="integer">34</cn>
     <cn type="integer">11</cn>
     <cn type="integer">23</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{n})_{n\geq 0}=(0,12,24,1,13,25,2,14,26,3,15,27,4,16,28,5,17,29,6,18,30,7,1%
9,31,8,20,32,9,21,33,10,22,34,11,23)
  </annotation>
 </semantics>
</math>

 (we have to do the 35 different sums to obtain 0+0 and we begin the same sequence again, the period is 

<math display="inline" id="Inversive_congruential_generator:31">
 <semantics>
  <mrow>
   <mrow>
    <mn>5</mn>
    <mo>√ó</mo>
    <mn>7</mn>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>35</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">5</cn>
     <cn type="integer">7</cn>
    </apply>
    <cn type="integer">35</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   5\times 7=35\,
  </annotation>
 </semantics>
</math>

). This method allows obtaining very long period and modular operations may be carried out with relatively small moduli.</p>
<h2 id="advantages-of-cig">Advantages of CIG</h2>

<p>The CIG are accepted for practical purposes for a number of reason.</p>

<p>Firstly, binary sequences produced in this way are free of undesirable statistical deviations. Inversive sequences extensively tested with variety of statistical tests remain stable under the variation of parameter.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Secondly, there exists a steady and simple way of parameter choice, based on the Chou algorithm <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> that guarantees maximum period length.</p>

<p>Thirdly, compound approach has the same properties as single inversive generators <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> but it also provides period length significantly greater than obtained by a single Inversive Congruential Generator. They seem to be designed for application with multiprocessor parallel hardware platforms.</p>

<p>There exists an algorithm <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> which allows designing compound generators with predictable period length, predictable linear complexity level, with excellent statistical properties of produced bit streams.</p>

<p>The procedure of designing this complex structure starts with defining finite field of <em>p</em> elements and ends with choosing the parameters <em>a</em> and <em>c</em> for each Inversive Congruential Generator being the component of the compound generator. It means that each generator is associated to a fixed IMP polynomial. Such a condition is sufficient for maximum period of each Inversive Congruential Generator<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and finally for maximum period of the compound generator. The construction of IMP polynomials is the most efficient approach to find parameters for Inversive Congruential Generator with maximum period length.</p>
<h2 id="discrepancy-and-its-boundaries">Discrepancy and its boundaries</h2>

<p>Equidistribution and statistical independence properties of the generated sequences, which are very important for their usability in a <a href="stochastic_process" title="wikilink">stochastic simulation</a>, can be analyzed based on the <strong>discrepancy</strong> of s-tuples of successive pseudorandom numbers with 

<math display="inline" id="Inversive_congruential_generator:32">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Inversive_congruential_generator:33">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=2
  </annotation>
 </semantics>
</math>


 respectively.</p>

<p>The discrepancy computes the distance of a generator from a uniform one, a low discrepancy means that the sequence generated can be used for <a href="cryptography" title="wikilink">cryptographic</a> purposes and the first aim of the Inversive congruential generator is to provide pseudorandom numbers.</p>
<h2 id="definition">Definition</h2>

<p>For 

<math display="inline" id="Inversive_congruential_generator:34">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 arbitrary points 

<math display="inline" id="Inversive_congruential_generator:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ùê≠</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>ùê≠</mi>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </list>
    <interval closure="closed-open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{t}}_{1},\dots,{\mathbf{t}}_{N-1}\in[0,1)
  </annotation>
 </semantics>
</math>

 the discrepancy is defined by 

<math display="inline" id="Inversive_congruential_generator:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ùê≠</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>ùê≠</mi>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>sup</mi>
     <mi>J</mi>
    </msub>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>F</mi>
        <mi>N</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>J</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>J</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>N</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê≠</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê≠</ci>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>sup</ci>
      <ci>J</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>N</ci>
        </apply>
        <ci>J</ci>
       </apply>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>J</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{N}({\mathbf{t}}_{1},\dots,{\mathbf{t}}_{N-1})={\rm sup}_{J}|F_{N}(J)-V(J)|
  </annotation>
 </semantics>
</math>

, where the supremum is extended over all subintervals 

<math display="inline" id="Inversive_congruential_generator:37">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Inversive_congruential_generator:38">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <interval closure="closed-open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1)^{s}
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Inversive_congruential_generator:39">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>J</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>N</ci>
    </apply>
    <ci>J</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{N}(J)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Inversive_congruential_generator:40">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{-1}
  </annotation>
 </semantics>
</math>

 times the number of points among 

<math display="inline" id="Inversive_congruential_generator:41">
 <semantics>
  <mrow>
   <msub>
    <mi>ùê≠</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>ùê≠</mi>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùê≠</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùê≠</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{t}}_{1},\dots,{\mathbf{t}}_{N-1}
  </annotation>
 </semantics>
</math>

 falling into <em>J</em> and <em>V(J)</em> denotes the <em>s</em>-dimensional volume of <em>J</em>.</p>

<p>Until now, we had sequences of integers from 0 to <em>T-1</em>, in order to have sequences of 

<math display="inline" id="Inversive_congruential_generator:42">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>s</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <interval closure="closed-open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1)^{s}
  </annotation>
 </semantics>
</math>

, one can divide a sequences of integers by its period <em>T</em>.</p>

<p>From this definition, we can say that if the sequence 

<math display="inline" id="Inversive_congruential_generator:43">
 <semantics>
  <mrow>
   <msub>
    <mi>ùê≠</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>ùê≠</mi>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùê≠</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùê≠</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{t}}_{1},\dots,{\mathbf{t}}_{N-1}
  </annotation>
 </semantics>
</math>


 is perfectly random then its well distributed on the interval 

<math display="inline" id="Inversive_congruential_generator:44">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>s</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <interval closure="closed-open">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=[0,1)^{s}
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Inversive_congruential_generator:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>J</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>J</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(J)=1
  </annotation>
 </semantics>
</math>

 and all points are in <em>J</em> so 

<math display="inline" id="Inversive_congruential_generator:46">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>J</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>N</ci>
      </apply>
      <ci>J</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>N</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{N}(J)=N/N=1
  </annotation>
 </semantics>
</math>

 hence 

<math display="inline" id="Inversive_congruential_generator:47">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ùê≠</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>ùê≠</mi>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>N</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê≠</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê≠</ci>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{N}({\mathbf{t}}_{1},\dots,{\mathbf{t}}_{N-1})=0
  </annotation>
 </semantics>
</math>

 but instead if the sequence is concentrated close to one point then the subinterval <em>J</em> is very small 

<math display="inline" id="Inversive_congruential_generator:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚âà</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>j</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(j)\approx 0
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Inversive_congruential_generator:49">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚âà</mo>
   <mrow>
    <mi>N</mi>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mo>‚âà</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>N</ci>
      </apply>
      <ci>j</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>N</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{N}(j)\approx N/N\approx 1
  </annotation>
 </semantics>
</math>

 so 

<math display="inline" id="Inversive_congruential_generator:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ùê≠</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>ùê≠</mi>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>N</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê≠</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ùê≠</ci>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{N}({\mathbf{t}}_{1},\dots,{\mathbf{t}}_{N-1})=1
  </annotation>
 </semantics>
</math>

 Then we have from the better and worst case: 

<math display="inline" id="Inversive_congruential_generator:51">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>‚â§</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ùê≠</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>ùê≠</mi>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>N</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ùê≠</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-‚Ä¶</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ùê≠</ci>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </vector>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq D_{N}({\mathbf{t}}_{1},\dots,{\mathbf{t}}_{N-1})\leq 1
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="notations">Notations</h2>

<p>Some further notation is necessary. For integers 

<math display="inline" id="Inversive_congruential_generator:52">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>‚â•</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\geq 1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Inversive_congruential_generator:53">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>‚â•</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\geq 2
  </annotation>
 </semantics>
</math>


 let 

<math display="inline" id="Inversive_congruential_generator:54">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>k</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}(q)
  </annotation>
 </semantics>
</math>

 be the set of nonzero lattice points 

<math display="inline" id="Inversive_congruential_generator:55">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>h</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚àà</mo>
   <msup>
    <mi>Z</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
    </vector>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (h_{1},\dots,h_{k})\in Z^{k}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Inversive_congruential_generator:56">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>q</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo><</mo>
   <msub>
    <mi>h</mi>
    <mi>j</mi>
   </msub>
   <mo><</mo>
   <mrow>
    <mi>q</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <ci>q</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>q</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -q/2<h_{j}<q/2
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Inversive_congruential_generator:57">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>‚â§</mo>
   <mi>j</mi>
   <mo>‚â§</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>j</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq j\leq k
  </annotation>
 </semantics>
</math>

.</p>

<p>Define</p>

<p>

<math display="block" id="Inversive_congruential_generator:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>h</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>q</mi>
        <mrow>
         <mi>sin</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mi>œÄ</mi>
            <mrow>
             <mo stretchy="false">|</mo>
             <mi>h</mi>
             <mo stretchy="false">|</mo>
            </mrow>
           </mrow>
           <mo>/</mo>
           <mi>q</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>for</mtext>
         <mi>h</mi>
        </mrow>
        <mo>‚àà</mo>
        <mrow>
         <msub>
          <mi>C</mi>
          <mn>1</mn>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>q</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>for</mtext>
         <mi>h</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <interval closure="open">
      <ci>h</ci>
      <ci>q</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <ci>q</ci>
      <apply>
       <sin></sin>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>œÄ</ci>
         <apply>
          <abs></abs>
          <ci>h</ci>
         </apply>
        </apply>
        <ci>q</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <mtext>for</mtext>
       <ci>h</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>for</mtext>
       <ci>h</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(h,q)=\begin{cases}q\sin(\pi|h|/q)&\text{for }h\in C_{1}(q)\\
1&\text{for }h=0\par
\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Inversive_congruential_generator:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê°</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>h</mi>
       <mi>j</mi>
      </msub>
      <mo>,</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <interval closure="open">
      <ci>ùê°</ci>
      <ci>q</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>j</ci>
       </apply>
       <ci>q</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(\mathbf{h},q)=\prod_{j=1}^{k}r(h_{j},q)
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Inversive_congruential_generator:60">
 <semantics>
  <mrow>
   <mi>ùê°</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>h</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>ùê°</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{h}}=(h_{1},\dots,h_{k})\in C_{k}(q)
  </annotation>
 </semantics>
</math>

. For real 

<math display="inline" id="Inversive_congruential_generator:61">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 the abbreviation 

<math display="inline" id="Inversive_congruential_generator:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>œÄ</mi>
       </mrow>
       <mo>‚ãÖ</mo>
       <mi>i</mi>
      </mrow>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>exp</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-‚ãÖ</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>œÄ</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(t)={\rm exp}(2\pi\cdot it)
  </annotation>
 </semantics>
</math>

 is used, and 

<math display="inline" id="Inversive_congruential_generator:63">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>‚ãÖ</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚ãÖ</ci>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\cdot v
  </annotation>
 </semantics>
</math>

 stands for the standard inner product of 

<math display="inline" id="Inversive_congruential_generator:64">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>,</mo>
   <mrow>
    <mi>v</mi>
    <mi>i</mi>
    <mi>n</mi>
    <msup>
     <mi>R</mi>
     <mi>k</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>u</ci>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>i</ci>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u,vinR^{k}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="higher-bound">Higher bound</h2>

<p>Let 

<math display="inline" id="Inversive_congruential_generator:65">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>‚â•</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\geq 1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Inversive_congruential_generator:66">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>‚â•</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\geq 2
  </annotation>
 </semantics>
</math>

 be integers. Let 

<math display="inline" id="Inversive_congruential_generator:67">
 <semantics>
  <mrow>
   <msub>
    <mi>ùê≠</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo>/</mo>
    <mi>q</mi>
   </mrow>
   <mo>‚àà</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
      <ci>q</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <interval closure="closed-open">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{t}}_{n}=y_{n}/q\in[0,1)^{k}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Inversive_congruential_generator:68">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo>‚àà</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <mrow>
      <mi>q</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <minus></minus>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
     </set>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}\in\{0,1,\dots,q-1\}^{k}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Inversive_congruential_generator:69">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>‚â§</mo>
   <mi>n</mi>
   <mo><</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq n<N
  </annotation>
 </semantics>
</math>

.</p>

<p>Then the discrepancy of the points 

<math display="inline" id="Inversive_congruential_generator:70">
 <semantics>
  <mrow>
   <msub>
    <mi>ùê≠</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>ùê≠</mi>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùê≠</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùê≠</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{t}}_{0},\dots,{\mathbf{t}}_{N-1}
  </annotation>
 </semantics>
</math>

 satisfies</p>

<p>

<math display="block" id="Inversive_congruential_generator:71">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ùê≠</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>ùê≠</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>ùê≠</mi>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>N</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{N}(\mathbf{t}_{0},\mathbf{t}_{1},\dots,\mathbf{t}_{N-1})
  </annotation>
 </semantics>
</math>

 ‚â§ 

<math display="inline" id="Inversive_congruential_generator:72">
 <semantics>
  <mfrac>
   <mi>k</mi>
   <mi>q</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>k</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{k}{q}
  </annotation>
 </semantics>
</math>

 + 

<math display="inline" id="Inversive_congruential_generator:73">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mi>N</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Inversive_congruential_generator:74">
 <semantics>
  <msub>
   <mo largeop="true" symmetric="true">‚àë</mo>
   <mrow>
    <mi>h</mi>
    <mo>‚àà</mo>
    <mrow>
     <msub>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\C</mtext>
      </merror>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <sum></sum>
    <apply>
     <in></in>
     <ci>h</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>\C</mtext>
       <ci>k</ci>
      </apply>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{h\in\C_{k}(q)}
  </annotation>
 </semantics>
</math>



<math display="inline" id="Inversive_congruential_generator:75">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùê°</mi>
      <mo>,</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mrow>
    <mo mathsize="260%" stretchy="false">|</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>ùê°</mi>
        <mo>‚ãÖ</mo>
        <msub>
         <mi>ùê≠</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo mathsize="260%" stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>r</ci>
      <interval closure="open">
       <ci>ùê°</ci>
       <ci>q</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <apply>
        <ci>normal-‚ãÖ</ci>
        <ci>ùê°</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ùê≠</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{r(\mathbf{h},q)}\Bigg|\sum_{n=0}^{N-1}e(\mathbf{h}\cdot\mathbf{t}_{n}%
)\Bigg|
  </annotation>
 </semantics>
</math>

</p>
<h2 id="lower-bound">Lower bound</h2>

<p>The discrepancy of 

<math display="inline" id="Inversive_congruential_generator:76">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 arbitrary points 

<math display="inline" id="Inversive_congruential_generator:77">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ùê≠</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>ùê≠</mi>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>‚àà</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <interval closure="closed-open">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}_{1},\dots,\mathbf{t}_{N-1}\in[0,1)^{k}
  </annotation>
 </semantics>
</math>

 satisfies</p>

<p>

<math display="block" id="Inversive_congruential_generator:78">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ùê≠</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>ùê≠</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>ùê≠</mi>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>N</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê≠</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{N}(\mathbf{t}_{0},\mathbf{t}_{1},\dots,\mathbf{t}_{N-1})
  </annotation>
 </semantics>
</math>

 ‚â• 

<math display="inline" id="Inversive_congruential_generator:79">
 <semantics>
  <mrow>
   <mfrac>
    <mi>œÄ</mi>
    <mrow>
     <mn>2</mn>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>œÄ</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>l</mi>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mstyle displaystyle="false">
       <msubsup>
        <mo largeop="true" symmetric="true">‚àè</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>k</mi>
       </msubsup>
      </mstyle>
      <mrow>
       <mi>max</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo>,</mo>
        <msub>
         <mi>h</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mrow>
    <mo mathsize="260%" stretchy="false">|</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>ùê°</mi>
        <mo>‚ãÖ</mo>
        <msub>
         <mi>ùê≠</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo mathsize="260%" stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>œÄ</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>N</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <ci>œÄ</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>l</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <ci>max</ci>
        <interval closure="open">
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <ci>j</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <apply>
        <ci>normal-‚ãÖ</ci>
        <ci>ùê°</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ùê≠</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\pi}{2N((\pi+1)^{l}-1)\prod_{j=1}^{k}{\rm max}(1,h_{j})}\Bigg|\sum_{n=0}%
^{N-1}e(\mathbf{h}\cdot\mathbf{t}_{n})\Bigg|
  </annotation>
 </semantics>
</math>

</p>

<p>for any nonzero lattice point 

<math display="inline" id="Inversive_congruential_generator:80">
 <semantics>
  <mrow>
   <mi>ùê°</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>h</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚àà</mo>
   <msup>
    <mi>Z</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>ùê°</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{h}}=(h_{1},\dots,h_{k})\in Z^{k}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Inversive_congruential_generator:81">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 denotes the number of nonzero coordinates of 

<math display="inline" id="Inversive_congruential_generator:82">
 <semantics>
  <mi>ùê°</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê°</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{h}}
  </annotation>
 </semantics>
</math>

.</p>

<p>These two theorems show that the CIG is not perfect because the discrepancy is greater strictly than a positive value but also the CIG is not the worst generator as the discrepancy is lower than a value less than 1.</p>

<p>There exist also theorems which bound the average value of the discrepancy for Compound Inversive Generators and also ones which take values such that the discrepancy is bounded by some value depending on the parameters. For more details see the original paper.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Pseudorandom_number_generator" title="wikilink">Pseudorandom number generator</a></li>
<li><a href="List_of_random_number_generators" title="wikilink">List of random number generators</a></li>
<li><a href="Linear_congruential_generator" title="wikilink">Linear congruential generator</a></li>
<li><a href="Generalized_inversive_congruential_pseudorandom_numbers" title="wikilink">Generalized inversive congruential pseudorandom numbers</a></li>
<li><a href="Naor-Reingold_Pseudorandom_Function" title="wikilink">Naor-Reingold Pseudorandom Function</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://random.mat.sbg.ac.at/generators/wsc95/inversive/node2.html">Inversive Generators</a> at the <a href="University_of_Salzburg" title="wikilink">University of Salzburg</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Pseudorandom_number_generators" title="wikilink">Category:Pseudorandom number generators</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
</ol>
</section>
</body>
</html>
