<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1955">Non-linear least squares</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Non-linear least squares</h1>
<hr/>

<p><strong>Non-linear least squares</strong> is the form of <a href="least_squares" title="wikilink">least squares</a> analysis used to fit a set of <em>m</em> observations with a model that is non-linear in <em>n</em> unknown parameters (<em>m</em> &gt; <em>n</em>). It is used in some forms of <a href="non-linear_regression" title="wikilink">non-linear regression</a>. The basis of the method is to approximate the model by a linear one and to refine the parameters by successive iterations. There are many similarities to <a href="linear_least_squares_(mathematics)" title="wikilink">linear least squares</a>, but also some <a href="least_squares#Differences_between_linear_and_non-linear_least_squares" title="wikilink">significant differences</a>.</p>
<h2 id="theory">Theory</h2>

<p>Consider a set of 

<math display="inline" id="Non-linear_least_squares:0">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 data points, 

<math display="inline" id="Non-linear_least_squares:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>m</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>m</ci>
     </apply>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1}),(x_{2},y_{2}),\dots,(x_{m},y_{m}),
  </annotation>
 </semantics>
</math>

 and a curve (model function) 

<math display="inline" id="Non-linear_least_squares:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>𝜷</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>𝜷</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=f(x,\boldsymbol{\beta}),
  </annotation>
 </semantics>
</math>

 that in addition to the variable 

<math display="inline" id="Non-linear_least_squares:3">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 also depends on 

<math display="inline" id="Non-linear_least_squares:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 parameters, 

<math display="inline" id="Non-linear_least_squares:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝜷</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>β</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>β</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>β</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝜷</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}=(\beta_{1},\beta_{2},\dots,\beta_{n}),
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Non-linear_least_squares:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mo>≥</mo>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\geq n.
  </annotation>
 </semantics>
</math>

 It is desired to find the vector 

<math display="inline" id="Non-linear_least_squares:7">
 <semantics>
  <mi>𝜷</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜷</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}
  </annotation>
 </semantics>
</math>

 of parameters such that the curve fits best the given data in the least squares sense, that is, the sum of squares</p>

<p>

<math display="block" id="Non-linear_least_squares:8">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </munderover>
    <msubsup>
     <mi>r</mi>
     <mi>i</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\sum_{i=1}^{m}r_{i}^{2}
  </annotation>
 </semantics>
</math>

 is minimized, where the <a href="errors_and_residuals_in_statistics" title="wikilink">residuals</a> (errors) <em>r<sub>i</sub></em> are given by</p>

<p>

<math display="block" id="Non-linear_least_squares:9">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>𝜷</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>𝜷</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}=y_{i}-f(x_{i},\boldsymbol{\beta})
  </annotation>
 </semantics>
</math>

</p>

<p>for 

<math display="inline" id="Non-linear_least_squares:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>m</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2,\dots,m.
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="Maxima_and_minima" title="wikilink">minimum</a> value of <em>S</em> occurs when the <a class="uri" href="gradient" title="wikilink">gradient</a> is zero. Since the model contains <em>n</em> parameters there are <em>n</em> gradient equations:</p>

<p>

<math display="block" id="Non-linear_least_squares:11">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>S</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>2</mn>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>i</mi>
   </munder>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>0</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>S</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <eq></eq>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <eq></eq>
    <cn type="integer">0</cn>
    <ci></ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">j</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial S}{\partial\beta_{j}}=2\sum_{i}r_{i}\frac{\partial r_{i}}{%
\partial\beta_{j}}=0\quad(j=1,\ldots,n).
  </annotation>
 </semantics>
</math>

</p>

<p>In a non-linear system, the derivatives 

<math display="inline" id="Non-linear_least_squares:12">
 <semantics>
  <mfrac>
   <mrow>
    <mo>∂</mo>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mrow>
    <mo>∂</mo>
    <msub>
     <mi>β</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial r_{i}}{\partial\beta_{j}}
  </annotation>
 </semantics>
</math>

 are functions of both the independent variable and the parameters, so these gradient equations do not have a closed solution. Instead, initial values must be chosen for the parameters. Then, the parameters are refined iteratively, that is, the values are obtained by successive approximation,</p>

<p>

<math display="block" id="Non-linear_least_squares:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>β</mi>
     <mi>j</mi>
    </msub>
    <mo>≈</mo>
    <msubsup>
     <mi>β</mi>
     <mi>j</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>β</mi>
      <mi>j</mi>
      <mi>k</mi>
     </msubsup>
     <mo>+</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <msub>
       <mi>β</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>β</ci>
        <ci>k</ci>
       </apply>
       <ci>j</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{j}\approx\beta_{j}^{k+1}=\beta^{k}_{j}+\Delta\beta_{j}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Here, <em>k</em> is an iteration number and the vector of increments, 

<math display="inline" id="Non-linear_least_squares:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mpadded width="+1.7pt">
    <mi>𝜷</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>𝜷</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\boldsymbol{\beta}\,
  </annotation>
 </semantics>
</math>

 is known as the shift vector. At each iteration the model is linearized by approximation to a first-order <a href="Taylor_series" title="wikilink">Taylor series</a> expansion about 

<math display="inline" id="Non-linear_least_squares:15">
 <semantics>
  <mpadded width="-1.7pt">
   <msup>
    <mi>𝜷</mi>
    <mi>k</mi>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝜷</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{k}\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Non-linear_least_squares:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>𝜷</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msup>
        <mi>𝜷</mi>
        <mi>k</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>j</mi>
      </munder>
      <mrow>
       <mfrac>
        <mrow>
         <mrow>
          <mo>∂</mo>
          <mi>f</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo>,</mo>
          <msup>
           <mi>𝜷</mi>
           <mi>k</mi>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mo>∂</mo>
         <msub>
          <mi>β</mi>
          <mi>j</mi>
         </msub>
        </mrow>
       </mfrac>
       <mrow>
        <mo>(</mo>
        <mrow>
         <msub>
          <mi>β</mi>
          <mi>j</mi>
         </msub>
         <mo>-</mo>
         <msubsup>
          <mi>β</mi>
          <mi>j</mi>
          <mi>k</mi>
         </msubsup>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msup>
        <mi>𝜷</mi>
        <mi>k</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>j</mi>
      </munder>
      <mrow>
       <mpadded width="+1.7pt">
        <msub>
         <mi>J</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
       </mpadded>
       <mi mathvariant="normal">Δ</mi>
       <msub>
        <mi>β</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>𝜷</ci>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝜷</ci>
         <ci>k</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <apply>
           <partialdiff></partialdiff>
           <ci>f</ci>
          </apply>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>𝜷</ci>
            <ci>k</ci>
           </apply>
          </interval>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>β</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>β</ci>
           <ci>k</ci>
          </apply>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝜷</ci>
         <ci>k</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>J</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i},\boldsymbol{\beta})\approx f(x_{i},\boldsymbol{\beta}^{k})+\sum_{j}%
\frac{\partial f(x_{i},\boldsymbol{\beta}^{k})}{\partial\beta_{j}}\left(\beta_%
{j}-\beta^{k}_{j}\right)\approx f(x_{i},\boldsymbol{\beta}^{k})+\sum_{j}J_{ij}%
\,\Delta\beta_{j}.
  </annotation>
 </semantics>
</math>

 The <a href="Jacobian_matrix_and_determinant" title="wikilink">Jacobian</a>, <strong>J</strong>, is a function of constants, the independent variable <em>and</em> the parameters, so it changes from one iteration to the next. Thus, in terms of the linearized model, 

<math display="inline" id="Non-linear_least_squares:17">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>J</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial r_{i}}{\partial\beta_{j}}=-J_{ij}
  </annotation>
 </semantics>
</math>

 and the residuals are given by</p>

<p>

<math display="block" id="Non-linear_least_squares:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>-</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>s</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <mpadded width="+5pt">
         <msub>
          <mi>J</mi>
          <mrow>
           <mi>i</mi>
           <mi>s</mi>
          </mrow>
         </msub>
        </mpadded>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>β</mi>
         <mi>s</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="7.5pt">;</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <msup>
         <mi>𝜷</mi>
         <mi>k</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>s</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>J</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>s</ci>
         </apply>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝜷</ci>
         <ci>k</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}=\Delta y_{i}-\sum_{s=1}^{n}J_{is}\ \Delta\beta_{s};\ \Delta y_{i}=y_{i}-%
f(x_{i},\boldsymbol{\beta}^{k}).
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting these expressions into the gradient equations, they become</p>

<p>

<math display="block" id="Non-linear_least_squares:19">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>J</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mi mathvariant="normal">Δ</mi>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
         </mrow>
         <mo>-</mo>
         <mrow>
          <munderover>
           <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
           <mrow>
            <mi>s</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>n</mi>
          </munderover>
          <mrow>
           <mpadded width="+5pt">
            <msub>
             <mi>J</mi>
             <mrow>
              <mi>i</mi>
              <mi>s</mi>
             </mrow>
            </msub>
           </mpadded>
           <mi mathvariant="normal">Δ</mi>
           <msub>
            <mi>β</mi>
            <mi>s</mi>
           </msub>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>J</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>normal-Δ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>s</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>J</ci>
            <apply>
             <times></times>
             <ci>i</ci>
             <ci>s</ci>
            </apply>
           </apply>
           <ci>normal-Δ</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>β</ci>
            <ci>s</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -2\sum_{i=1}^{m}J_{ij}\left(\Delta y_{i}-\sum_{s=1}^{n}J_{is}\ \Delta\beta_{s}%
\right)=0
  </annotation>
 </semantics>
</math>

</p>

<p>which, on rearrangement, become <em>n</em> simultaneous linear equations, the <strong>normal equations</strong></p>

<p>

<math display="block" id="Non-linear_least_squares:20">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>m</mi>
   </munderover>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>s</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </munderover>
   <msub>
    <mi>J</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mpadded width="+5pt">
    <msub>
     <mi>J</mi>
     <mrow>
      <mi>i</mi>
      <mi>s</mi>
     </mrow>
    </msub>
   </mpadded>
   <mi mathvariant="normal">Δ</mi>
   <msub>
    <mi>β</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>m</mi>
   </munderover>
   <mpadded width="+5pt">
    <msub>
     <mi>J</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mpadded>
   <mi mathvariant="normal">Δ</mi>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">Δ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>s</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">Δ</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">j</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{m}\sum_{s=1}^{n}J_{ij}J_{is}\ \Delta\beta_{s}=\sum_{i=1}^{m}J_{ij}%
\ \Delta y_{i}\qquad(j=1,\dots,n).\,
  </annotation>
 </semantics>
</math>

</p>

<p>The normal equations are written in matrix notation as</p>

<p>

<math display="block" id="Non-linear_least_squares:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>𝐉</mi>
        <mi>𝐓</mi>
       </msup>
       <mi>𝐉</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>𝚫</mi>
     <mi>𝜷</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+5pt">
      <msup>
       <mi>𝐉</mi>
       <mi>𝐓</mi>
      </msup>
     </mpadded>
     <mi>𝚫</mi>
     <mi>𝐲</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐉</ci>
     </apply>
     <ci>𝚫</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐉</ci>
      <ci>𝐓</ci>
     </apply>
     <ci>𝚫</ci>
     <ci>𝐲</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\left(J^{T}J\right)\Delta\boldsymbol{\beta}=J^{T}\ \Delta y}.
  </annotation>
 </semantics>
</math>

</p>

<p>When the observations are not equally reliable, a weighted sum of squares may be minimized,</p>

<p>

<math display="block" id="Non-linear_least_squares:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>W</mi>
       <mrow>
        <mi>i</mi>
        <mi>i</mi>
       </mrow>
      </msub>
      <msubsup>
       <mi>r</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\sum_{i=1}^{m}W_{ii}r_{i}^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Each element of the <a href="diagonal_matrix" title="wikilink">diagonal</a> weight matrix <strong>W</strong> should, ideally, be equal to the reciprocal of the error <a class="uri" href="variance" title="wikilink">variance</a> of the measurement.<ref>This implies that the observations are uncorrelated. If the observations are <a class="uri" href="correlated" title="wikilink">correlated</a>, the expression</ref></p>

<p>

<math display="block" id="Non-linear_least_squares:23">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>k</mi>
    </munder>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <msub>
       <mi>r</mi>
       <mi>k</mi>
      </msub>
      <msub>
       <mi>W</mi>
       <mrow>
        <mi>k</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mpadded width="+1.7pt">
       <msub>
        <mi>r</mi>
        <mi>j</mi>
       </msub>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>k</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\sum_{k}\sum_{j}r_{k}W_{kj}r_{j}\,
  </annotation>
 </semantics>
</math>

</p>

<p>applies. In this case the weight matrix should ideally be equal to the inverse of the error <a href="variance-covariance_matrix" title="wikilink">variance-covariance matrix</a> of the observations. The normal equations are then</p>

<p>

<math display="block" id="Non-linear_least_squares:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>𝐉</mi>
        <mi>𝐓</mi>
       </msup>
       <mi>𝐖𝐉</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>𝚫</mi>
     <mi>𝜷</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>𝐉</mi>
      <mi>𝐓</mi>
     </msup>
     <mpadded width="+5pt">
      <mi>𝐖</mi>
     </mpadded>
     <mi>𝚫</mi>
     <mi>𝐲</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐖𝐉</ci>
     </apply>
     <ci>𝚫</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐉</ci>
      <ci>𝐓</ci>
     </apply>
     <ci>𝐖</ci>
     <ci>𝚫</ci>
     <ci>𝐲</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\left(J^{T}WJ\right)\Delta\boldsymbol{\beta}=J^{T}W\ \Delta y}.
  </annotation>
 </semantics>
</math>

</p>

<p>These equations form the basis for the <a href="Gauss–Newton_algorithm" title="wikilink">Gauss–Newton algorithm</a> for a non-linear least squares problem.</p>
<h2 id="geometrical-interpretation">Geometrical interpretation</h2>

<p>In linear least squares the <a href="Optimization_(mathematics)" title="wikilink">objective function</a>, <em>S</em>, is a <a href="quadratic_function#Bivariate_quadratic_function" title="wikilink">quadratic function</a> of the parameters.</p>

<p>

<math display="block" id="Non-linear_least_squares:25">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>i</mi>
       <mi>i</mi>
      </mrow>
     </msub>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mrow>
         <munder>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mi>j</mi>
         </munder>
         <mrow>
          <msub>
           <mi>X</mi>
           <mrow>
            <mi>i</mi>
            <mi>j</mi>
           </mrow>
          </msub>
          <msub>
           <mi>β</mi>
           <mi>j</mi>
          </msub>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <ci>j</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>β</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\sum_{i}W_{ii}\left(y_{i}-\sum_{j}X_{ij}\beta_{j}\right)^{2}
  </annotation>
 </semantics>
</math>

 When there is only one parameter the graph of <em>S</em> with respect to that parameter will be a <a class="uri" href="parabola" title="wikilink">parabola</a>. With two or more parameters the contours of <em>S</em> with respect to any pair of parameters will be concentric <a href="ellipse" title="wikilink">ellipses</a> (assuming that the normal equations matrix 

<math display="inline" id="Non-linear_least_squares:26">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐗</mi>
    <mi>𝐓</mi>
   </msup>
   <mi>𝐖𝐗</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐗</ci>
     <ci>𝐓</ci>
    </apply>
    <ci>𝐖𝐗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X^{T}WX}
  </annotation>
 </semantics>
</math>

 is <a href="positive-definite_matrix" title="wikilink">positive definite</a>). The minimum parameter values are to be found at the centre of the ellipses. The geometry of the general objective function can be described as paraboloid elliptical. In NLLSQ the objective function is quadratic with respect to the parameters only in a region close to its minimum value, where the truncated Taylor series is a good approximation to the model.</p>

<p>

<math display="block" id="Non-linear_least_squares:27">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>≈</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>i</mi>
       <mi>i</mi>
      </mrow>
     </msub>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mrow>
         <munder>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mi>j</mi>
         </munder>
         <mrow>
          <msub>
           <mi>J</mi>
           <mrow>
            <mi>i</mi>
            <mi>j</mi>
           </mrow>
          </msub>
          <msub>
           <mi>β</mi>
           <mi>j</mi>
          </msub>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <ci>j</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>J</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>β</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\approx\sum_{i}W_{ii}\left(y_{i}-\sum_{j}J_{ij}\beta_{j}\right)^{2}
  </annotation>
 </semantics>
</math>

 The more the parameter values differ from their optimal values, the more the contours deviate from elliptical shape. A consequence of this is that initial parameter estimates should be as close as practicable to their (unknown!) optimal values. It also explains how divergence can come about as the Gauss–Newton algorithm is convergent only when the objective function is approximately quadratic in the parameters.</p>
<h2 id="computation">Computation</h2>
<h3 id="initial-parameter-estimates">Initial parameter estimates</h3>

<p>Problems of ill-conditioning and divergence can be ameliorated by finding initial parameter estimates that are near to the optimal values. A good way to do this is by <a href="computer_simulation" title="wikilink">computer simulation</a>. Both the observed and calculated data are displayed on a screen. The parameters of the model are adjusted by hand until the agreement between observed and calculated data is reasonably good. Although this will be a subjective judgment, it is sufficient to find a good starting point for the non-linear refinement.</p>
<h3 id="solution">Solution</h3>

<p>Any method among the ones described <a href="#Algorithms" title="wikilink">below</a> can be applied to find a solution.</p>
<h3 id="convergence-criteria">Convergence criteria</h3>

<p>The common sense criterion for convergence is that the sum of squares does not decrease from one iteration to the next. However this criterion is often difficult to implement in practice, for various reasons. A useful convergence criterion is</p>

<p>

<math display="block" id="Non-linear_least_squares:28">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>S</mi>
       <mi>k</mi>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>S</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <msup>
      <mi>S</mi>
      <mi>k</mi>
     </msup>
    </mfrac>
    <mo>|</mo>
   </mrow>
   <mo><</mo>
   <mn>0.0001.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.0001.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\frac{S^{k}-S^{k+1}}{S^{k}}\right|<0.0001.
  </annotation>
 </semantics>
</math>

 The value 0.0001 is somewhat arbitrary and may need to be changed. In particular it may need to be increased when experimental errors are large. An alternative criterion is</p>

<p>

<math display="block" id="Non-linear_least_squares:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>|</mo>
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>β</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <msub>
        <mi>β</mi>
        <mi>j</mi>
       </msub>
      </mfrac>
      <mo>|</mo>
     </mrow>
     <mo><</mo>
     <mn>0.001</mn>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <abs></abs>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <cn type="float">0.001</cn>
    </apply>
    <apply>
     <eq></eq>
     <ci>j</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>n</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\frac{\Delta\beta_{j}}{\beta_{j}}\right|<0.001,\qquad j=1,\dots,n.
  </annotation>
 </semantics>
</math>

</p>

<p>Again, the numerical value is somewhat arbitrary; 0.001 is equivalent to specifying that each parameter should be refined to 0.1% precision. This is reasonable when it is less than the largest relative standard deviation on the parameters.</p>
<h3 id="calculation-of-the-jacobian-by-numerical-approximation">Calculation of the Jacobian by numerical approximation</h3>

<p>There are models for which it is either very difficult or even impossible to derive analytical expressions for the elements of the Jacobian. Then, the numerical approximation</p>

<p>

<math display="block" id="Non-linear_least_squares:30">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo>∂</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>𝜷</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>≈</mo>
   <mfrac>
    <mrow>
     <mi>δ</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>𝜷</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>δ</mi>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <partialdiff></partialdiff>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>𝜷</ci>
      </interval>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>𝜷</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial f(x_{i},\boldsymbol{\beta})}{\partial\beta_{j}}\approx\frac{%
\delta f(x_{i},\boldsymbol{\beta})}{\delta\beta_{j}}
  </annotation>
 </semantics>
</math>

 is obtained by calculation of 

<math display="inline" id="Non-linear_least_squares:31">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mi>𝜷</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>𝜷</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i},\boldsymbol{\beta})\,
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Non-linear_least_squares:32">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>β</mi>
    <mi>j</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{j}\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-linear_least_squares:33">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>j</mi>
   </msub>
   <mo>+</mo>
   <mrow>
    <mi>δ</mi>
    <mpadded width="+1.7pt">
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{j}+\delta\beta_{j}\,
  </annotation>
 </semantics>
</math>

. The increment,

<math display="inline" id="Non-linear_least_squares:34">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mpadded width="+1.7pt">
    <msub>
     <mi>β</mi>
     <mi>j</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta\beta_{j}\,
  </annotation>
 </semantics>
</math>

, size should be chosen so the numerical derivative is not subject to approximation error by being too large, or <a class="uri" href="round-off" title="wikilink">round-off</a> error by being too small.</p>
<h3 id="parameter-errors-confidence-limits-residuals-etc.">Parameter errors, confidence limits, residuals etc.</h3>

<p>Some information is given in <a href="linear_least_squares_(mathematics)#Weighted_linear_least_squares" title="wikilink">the corresponding section</a> on the <a href="linear_least_squares_(mathematics)" title="wikilink">linear least squares</a> page.</p>
<h3 id="multiple-minima">Multiple minima</h3>

<p>Multiple minima can occur in a variety of circumstances some of which are:</p>
<ul>
<li>A parameter is raised to a power of two or more. For example, when fitting data to a <a class="uri" href="Lorentzian" title="wikilink">Lorentzian</a> curve</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Non-linear_least_squares:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>𝜷</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mi>α</mi>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mi>γ</mi>
         <mo>-</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mi>β</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>𝜷</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <ci>α</ci>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>γ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <ci>β</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i},\boldsymbol{\beta})=\frac{\alpha}{1+\left(\frac{\gamma-x_{i}}{\beta}%
\right)^{2}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Non-linear_least_squares:36">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is the height, 

<math display="inline" id="Non-linear_least_squares:37">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 is the position and 

<math display="inline" id="Non-linear_least_squares:38">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is the half-width at half height, there are two solutions for the half-width, 

<math display="inline" id="Non-linear_least_squares:39">
 <semantics>
  <mover accent="true">
   <mi>β</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\beta}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-linear_least_squares:40">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mover accent="true">
    <mi>β</mi>
    <mo stretchy="false">^</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <ci>normal-^</ci>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\hat{\beta}
  </annotation>
 </semantics>
</math>

 which give the same optimal value for the objective function.</p>
<ul>
<li>Two parameters can be interchanged without changing the value of the model. A simple example is when the model contains the product of two parameters, since 

<math display="inline" id="Non-linear_least_squares:41">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\beta
  </annotation>
 </semantics>
</math>

 will give the same value as 

<math display="inline" id="Non-linear_least_squares:42">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\alpha
  </annotation>
 </semantics>
</math>

.</li>
<li>A parameter is in a trigonometric function, such as 

<math display="inline" id="Non-linear_least_squares:43">
 <semantics>
  <mrow>
   <mi>sin</mi>
   <mpadded width="+1.7pt">
    <mi>β</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <sin></sin>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sin\beta\,
  </annotation>
 </semantics>
</math>

, which has identical values at 

<math display="inline" id="Non-linear_least_squares:44">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>β</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
    <mi>π</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-^</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
     <ci>π</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\beta}+2n\pi
  </annotation>
 </semantics>
</math>

. See <a href="Levenberg–Marquardt_algorithm#Example" title="wikilink">Levenberg–Marquardt algorithm</a> for an example.</li>
</ul>

<p>Not all multiple minima have equal values of the objective function. False minima, also known as local minima, occur when the objective function value is greater than its value at the so-called global minimum. To be certain that the minimum found is the global minimum, the refinement should be started with widely differing initial values of the parameters. When the same minimum is found regardless of starting point, it is likely to be the global minimum.</p>

<p>When multiple minima exist there is an important consequence: the objective function will have a maximum value somewhere between two minima. The normal equations matrix is not positive definite at a maximum in the objective function, as the gradient is zero and no unique direction of descent exists. Refinement from a point (a set of parameter values) close to a maximum will be ill-conditioned and should be avoided as a starting point. For example, when fitting a Lorentzian the normal equations matrix is not positive definite when the half-width of the band is zero.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="transformation-to-a-linear-model">Transformation to a linear model</h3>

<p>A non-linear model can sometimes be transformed into a linear one. For example, when the model is a simple exponential function,</p>

<p>

<math display="block" id="Non-linear_least_squares:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>𝜷</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>α</mi>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>β</mi>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>𝜷</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>β</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i},\boldsymbol{\beta})=\alpha e^{\beta x_{i}}
  </annotation>
 </semantics>
</math>

 it can be transformed into a linear model by taking logarithms.</p>

<p>

<math display="block" id="Non-linear_least_squares:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>log</mi>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>𝜷</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>log</mi>
     <mi>α</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>β</mi>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <log></log>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>𝜷</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <log></log>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log f(x_{i},\boldsymbol{\beta})=\log\alpha+\beta x_{i}
  </annotation>
 </semantics>
</math>

 Graphically this corresponds to working on a <a href="semi-log_plot" title="wikilink">semi-log plot</a>. The sum of squares becomes</p>

<p>

<math display="block" id="Non-linear_least_squares:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>log</mi>
         <msub>
          <mi>y</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>log</mi>
         <mi>α</mi>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>β</mi>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <log></log>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <log></log>
        <ci>α</ci>
       </apply>
       <apply>
        <times></times>
        <ci>β</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\sum_{i}(\log y_{i}-\log\alpha-\beta x_{i})^{2}.\!
  </annotation>
 </semantics>
</math>

 This procedure should be avoided unless the errors are multiplicative and <a href="log_normal_distribution" title="wikilink">log-normally distributed</a> because it can give misleading results. This comes from the fact that whatever the experimental errors on <strong>y</strong> might be, the errors on <strong>log y</strong> are different. Therefore, when the transformed sum of squares is minimized different results will be obtained both for the parameter values and their calculated standard deviations. However, with multiplicative errors that are log-normally distributed, this procedure gives unbiased and consistent parameter estimates.</p>

<p>Another example is furnished by <a href="Michaelis–Menten_kinetics#Equation_optimization" title="wikilink">Michaelis–Menten kinetics</a>, used to determine two parameters 

<math display="inline" id="Non-linear_least_squares:48">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>max</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <max></max>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{\max}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-linear_least_squares:49">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{m}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Non-linear_least_squares:50">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>V</mi>
      <mi>max</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>S</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>m</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>S</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <max></max>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=\frac{V_{\max}[S]}{K_{m}+[S]}
  </annotation>
 </semantics>
</math>

. The <a href="Lineweaver–Burk_plot" title="wikilink">Lineweaver–Burk plot</a></p>

<p>

<math display="block" id="Non-linear_least_squares:51">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>v</mi>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>V</mi>
      <mi>max</mi>
     </msub>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <msub>
      <mi>K</mi>
      <mi>m</mi>
     </msub>
     <mrow>
      <msub>
       <mi>V</mi>
       <mi>max</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>S</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>v</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <max></max>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <max></max>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{v}=\frac{1}{V_{\max}}+\frac{K_{m}}{V_{\max}[S]}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Non-linear_least_squares:52">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mi>v</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{v}
  </annotation>
 </semantics>
</math>

 against 

<math display="inline" id="Non-linear_least_squares:53">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{[S]}
  </annotation>
 </semantics>
</math>

 is linear in the parameters 

<math display="inline" id="Non-linear_least_squares:54">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <msub>
    <mi>V</mi>
    <mi>max</mi>
   </msub>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <max></max>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{V_{\max}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Non-linear_least_squares:55">
 <semantics>
  <mfrac>
   <msub>
    <mi>K</mi>
    <mi>m</mi>
   </msub>
   <msub>
    <mi>V</mi>
    <mi>max</mi>
   </msub>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <max></max>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{K_{m}}{V_{\max}}
  </annotation>
 </semantics>
</math>

, but very sensitive to data error and strongly biased toward fitting the data in a particular range of the independent variable 

<math display="inline" id="Non-linear_least_squares:56">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>S</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [S]
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="solution-1">Solution</h2>
<h3 id="gaussnewton-method">Gauss–Newton method</h3>

<p>The normal equations</p>

<p>

<math display="block" id="Non-linear_least_squares:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msup>
       <mi>𝐉</mi>
       <mi>𝐓</mi>
      </msup>
      <mi>𝐖𝐉</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi>𝚫</mi>
    <mi>𝜷</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msup>
       <mi>𝐉</mi>
       <mi>𝐓</mi>
      </msup>
      <mi>𝐖</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi>𝚫</mi>
    <mi>𝐲</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐖𝐉</ci>
     </apply>
     <ci>𝚫</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐖</ci>
     </apply>
     <ci>𝚫</ci>
     <ci>𝐲</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\left(J^{T}WJ\right)\Delta\boldsymbol{\beta}=\left(J^{T}W\right)\Delta
y}
  </annotation>
 </semantics>
</math>

 may be solved for 

<math display="inline" id="Non-linear_least_squares:58">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>𝜷</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>𝜷</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\boldsymbol{\beta}
  </annotation>
 </semantics>
</math>

 by <a href="Cholesky_decomposition" title="wikilink">Cholesky decomposition</a>, as described in <a href="linear_least_squares_(mathematics)#Computation" title="wikilink">linear least squares</a>. The parameters are updated iteratively</p>

<p>

<math display="block" id="Non-linear_least_squares:59">
 <semantics>
  <mrow>
   <msup>
    <mi>𝜷</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝜷</mi>
     <mi>k</mi>
    </msup>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>𝜷</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>𝜷</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{k+1}=\boldsymbol{\beta}^{k}+\Delta\boldsymbol{\beta}
  </annotation>
 </semantics>
</math>

 where <em>k</em> is an iteration number. While this method may be adequate for simple models, it will fail if divergence occurs. Therefore protection against divergence is essential.</p>
<h4 id="shift-cutting">Shift-cutting</h4>

<p>If divergence occurs, a simple expedient is to reduce the length of the shift vector, 

<math display="inline" id="Non-linear_least_squares:60">
 <semantics>
  <mrow>
   <mi>𝚫</mi>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝚫</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Delta\beta}
  </annotation>
 </semantics>
</math>

, by a fraction, <em>f</em></p>

<p>

<math display="block" id="Non-linear_least_squares:61">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝜷</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>𝜷</mi>
      <mi>k</mi>
     </msup>
     <mo>+</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi mathvariant="normal">Δ</mi>
      <mi>𝜷</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>normal-Δ</ci>
      <ci>𝜷</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{k+1}=\boldsymbol{\beta}^{k}+f\ \Delta\boldsymbol{\beta}.
  </annotation>
 </semantics>
</math>

 For example the length of the shift vector may be successively halved until the new value of the objective function is less than its value at the last iteration. The fraction, <em>f</em> could be optimized by a <a href="line_search" title="wikilink">line search</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> As each trial value of <em>f</em> requires the objective function to be re-calculated it is not worth optimizing its value too stringently.</p>

<p>When using shift-cutting, the direction of the shift vector remains unchanged. This limits the applicability of the method to situations where the direction of the shift vector is not very different from what it would be if the objective function were approximately quadratic in the parameters, 

<math display="inline" id="Non-linear_least_squares:62">
 <semantics>
  <mrow>
   <msup>
    <mi>𝜷</mi>
    <mi>k</mi>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝜷</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{k}.
  </annotation>
 </semantics>
</math>

</p>
<h4 id="marquardt-parameter">Marquardt parameter</h4>

<p>If divergence occurs and the direction of the shift vector is so far from its "ideal" direction that shift-cutting is not very effective, that is, the fraction, <em>f</em> required to avoid divergence is very small, the direction must be changed. This can be achieved by using the <a href="Levenberg–Marquardt_algorithm" title="wikilink">Marquardt</a> parameter.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In this method the normal equations are modified</p>

<p>

<math display="block" id="Non-linear_least_squares:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>𝐉</mi>
        <mi>𝐓</mi>
       </msup>
       <mi>𝐖𝐉</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>λ</mi>
       <mi>𝐈</mi>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi>𝚫</mi>
    <mi>𝜷</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msup>
       <mi>𝐉</mi>
       <mi>𝐓</mi>
      </msup>
      <mi>𝐖</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi>𝚫</mi>
    <mi>𝐲</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐉</ci>
        <ci>𝐓</ci>
       </apply>
       <ci>𝐖𝐉</ci>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>𝐈</ci>
      </apply>
     </apply>
     <ci>𝚫</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐖</ci>
     </apply>
     <ci>𝚫</ci>
     <ci>𝐲</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\left(J^{T}WJ+\lambda I\right)\Delta\boldsymbol{\beta}=\left(J^{T}W%
\right)\Delta y}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Non-linear_least_squares:64">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is the Marquardt parameter and <strong>I</strong> is an identity matrix. Increasing the value of 

<math display="inline" id="Non-linear_least_squares:65">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 has the effect of changing both the direction and the length of the shift vector. The shift vector is rotated towards the direction of <a href="steepest_descent" title="wikilink">steepest descent</a></p>
<dl>
<dd>when 

<math display="inline" id="Non-linear_least_squares:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>𝐈</mi>
     </mrow>
     <mo>≫</mo>
     <mrow>
      <msup>
       <mi>𝐉</mi>
       <mi>𝐓</mi>
      </msup>
      <mi>𝐖𝐉</mi>
     </mrow>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>𝚫</mi>
      <mi>𝜷</mi>
     </mrow>
     <mo>≈</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mi>λ</mi>
      </mrow>
      <msup>
       <mi>𝐉</mi>
       <mi>𝐓</mi>
      </msup>
      <mpadded width="+5pt">
       <mi>𝐖</mi>
      </mpadded>
      <mi>𝚫</mi>
      <mi>𝐲</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">much-greater-than</csymbol>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>𝐈</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐖𝐉</ci>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <ci>𝚫</ci>
      <ci>𝜷</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>λ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐖</ci>
      <ci>𝚫</ci>
      <ci>𝐲</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\mathbf{I\gg{}J^{T}WJ},\ \mathbf{\Delta\boldsymbol{\beta}}\approx 1/%
\lambda\mathbf{J^{T}W\ \Delta y}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>

<math display="inline" id="Non-linear_least_squares:67">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐉</mi>
    <mi>𝐓</mi>
   </msup>
   <mpadded width="+5pt">
    <mi>𝐖</mi>
   </mpadded>
   <mi>𝚫</mi>
   <mi>𝐲</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐉</ci>
     <ci>𝐓</ci>
    </apply>
    <ci>𝐖</ci>
    <ci>𝚫</ci>
    <ci>𝐲</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{J^{T}W\ \Delta y}
  </annotation>
 </semantics>
</math>

 is the steepest descent vector. So, when 

<math display="inline" id="Non-linear_least_squares:68">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 becomes very large, the shift vector becomes a small fraction of the steepest descent vector.</p>

<p>Various strategies have been proposed for the determination of the Marquardt parameter. As with shift-cutting, it is wasteful to optimize this parameter too stringently. Rather, once a value has been found that brings about a reduction in the value of the objective function, that value of the parameter is carried to the next iteration, reduced if possible, or increased if need be. When reducing the value of the Marquardt parameter, there is a cut-off value below which it is safe to set it to zero, that is, to continue with the unmodified Gauss–Newton method. The cut-off value may be set equal to the smallest singular value of the Jacobian.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A bound for this value is given by 

<math display="inline" id="Non-linear_least_squares:69">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mtext>trace</mtext>
   </mrow>
   <msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msup>
       <mi>𝐉</mi>
       <mi>𝐓</mi>
      </msup>
      <mi>𝐖𝐉</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>𝟏</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <mtext>trace</mtext>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐖𝐉</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\mbox{trace}\mathbf{\left(J^{T}WJ\right)^{-1}}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="qr-decomposition">QR decomposition</h3>

<p>The minimum in the sum of squares can be found by a method that does not involve forming the normal equations. The residuals with the linearized model can be written as</p>

<p>

<math display="block" id="Non-linear_least_squares:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐫</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>𝚫</mi>
      <mi>𝐲</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>𝐉</mi>
      </mpadded>
      <mi>𝚫</mi>
      <mi>𝜷</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐫</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>𝚫</ci>
      <ci>𝐲</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝐉</ci>
      <ci>𝚫</ci>
      <ci>𝜷</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r=\Delta y-J\ \Delta\boldsymbol{\beta}}.
  </annotation>
 </semantics>
</math>

 The Jacobian is subjected to an orthogonal decomposition; the <a href="QR_decomposition" title="wikilink">QR decomposition</a> will serve to illustrate the process.</p>

<p>

<math display="block" id="Non-linear_least_squares:71">
 <semantics>
  <mrow>
   <mi>𝐉</mi>
   <mo>=</mo>
   <mi>𝐐𝐑</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐉</ci>
    <ci>𝐐𝐑</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{J=QR}
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>Q</strong> is an <a href="Orthogonal_matrix" title="wikilink">orthogonal</a> 

<math display="inline" id="Non-linear_least_squares:72">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times m
  </annotation>
 </semantics>
</math>

 matrix and <strong>R</strong> is an 

<math display="inline" id="Non-linear_least_squares:73">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times n
  </annotation>
 </semantics>
</math>

 matrix which is <a href="block_matrix" title="wikilink">partitioned</a> into an 

<math display="inline" id="Non-linear_least_squares:74">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 block, 

<math display="inline" id="Non-linear_least_squares:75">
 <semantics>
  <msub>
   <mi>𝐑</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐑</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}_{n}
  </annotation>
 </semantics>
</math>

, and a 

<math display="inline" id="Non-linear_least_squares:76">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>-</mo>
   <mrow>
    <mi>n</mi>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-n\times n
  </annotation>
 </semantics>
</math>

 zero block. 

<math display="inline" id="Non-linear_least_squares:77">
 <semantics>
  <msub>
   <mi>𝐑</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐑</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}_{n}
  </annotation>
 </semantics>
</math>

 is upper triangular.</p>

<p>

<math display="block" id="Non-linear_least_squares:78">
 <semantics>
  <mrow>
   <mi>𝐑</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>𝐑</mi>
        <mi>n</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>𝟎</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐑</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐑</ci>
       <ci>n</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}=\begin{bmatrix}\mathbf{R}_{n}\\
\mathbf{0}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The residual vector is left-multiplied by 

<math display="inline" id="Non-linear_least_squares:79">
 <semantics>
  <msup>
   <mi>𝐐</mi>
   <mi>T</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐐</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}^{T}
  </annotation>
 </semantics>
</math>


.</p>

<p>

<math display="block" id="Non-linear_least_squares:80">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐐</mi>
     <mi>𝐓</mi>
    </msup>
    <mi>𝐫</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <msup>
       <mi>𝐐</mi>
       <mi>𝐓</mi>
      </msup>
     </mpadded>
     <mi>𝚫</mi>
     <mi>𝐲</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>𝐑</mi>
     </mpadded>
     <mi>𝚫</mi>
     <mi>𝜷</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mrow>
           <mpadded width="+5pt">
            <msup>
             <mi>𝐐</mi>
             <mi>𝐓</mi>
            </msup>
           </mpadded>
           <mi>𝚫</mi>
           <mi>𝐲</mi>
          </mrow>
          <mo>-</mo>
          <mrow>
           <mpadded width="+5pt">
            <mi>𝐑</mi>
           </mpadded>
           <mi>𝚫</mi>
           <mi>𝜷</mi>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mi>n</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mpadded width="+5pt">
           <msup>
            <mi>𝐐</mi>
            <mi>𝐓</mi>
           </msup>
          </mpadded>
          <mi>𝚫</mi>
          <mi>𝐲</mi>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mi>n</mi>
        </mrow>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐐</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐫</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐐</ci>
        <ci>𝐓</ci>
       </apply>
       <ci>𝚫</ci>
       <ci>𝐲</ci>
      </apply>
      <apply>
       <times></times>
       <ci>𝐑</ci>
       <ci>𝚫</ci>
       <ci>𝜷</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>𝐐</ci>
           <ci>𝐓</ci>
          </apply>
          <ci>𝚫</ci>
          <ci>𝐲</ci>
         </apply>
         <apply>
          <times></times>
          <ci>𝐑</ci>
          <ci>𝚫</ci>
          <ci>𝜷</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝐐</ci>
          <ci>𝐓</ci>
         </apply>
         <ci>𝚫</ci>
         <ci>𝐲</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q^{T}r=Q^{T}\ \Delta y-R\ \Delta\boldsymbol{\beta}}=\begin{bmatrix}%
\mathbf{\left(Q^{T}\ \Delta y-R\ \Delta\boldsymbol{\beta}\right)}_{n}\\
\mathbf{\left(Q^{T}\ \Delta y\right)}_{m-n}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>This has no effect on the sum of squares since 

<math display="inline" id="Non-linear_least_squares:81">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐫</mi>
     <mi>𝐓</mi>
    </msup>
    <msup>
     <mi>𝐐𝐐</mi>
     <mi>𝐓</mi>
    </msup>
    <mi>𝐫</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐫</mi>
     <mi>𝐓</mi>
    </msup>
    <mi>𝐫</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>S</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐫</ci>
       <ci>𝐓</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐐𝐐</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐫</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐫</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝐫</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\mathbf{r^{T}QQ^{T}r=r^{T}r}
  </annotation>
 </semantics>
</math>

 because <strong>Q</strong> is <a class="uri" href="orthogonal" title="wikilink">orthogonal</a> The minimum value of <em>S</em> is attained when the upper block is zero. Therefore the shift vector is found by solving</p>

<p>

<math display="block" id="Non-linear_least_squares:82">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <msub>
       <mi>𝐑</mi>
       <mi>𝐧</mi>
      </msub>
     </mpadded>
     <mi>𝚫</mi>
     <mi>𝜷</mi>
    </mrow>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mpadded width="+5pt">
        <msup>
         <mi>𝐐</mi>
         <mi>𝐓</mi>
        </msup>
       </mpadded>
       <mi>𝚫</mi>
       <mi>𝐲</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>𝐧</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐑</ci>
      <ci>𝐧</ci>
     </apply>
     <ci>𝚫</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐐</ci>
       <ci>𝐓</ci>
      </apply>
      <ci>𝚫</ci>
      <ci>𝐲</ci>
     </apply>
     <ci>𝐧</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R_{n}\ \Delta\boldsymbol{\beta}=\left(Q^{T}\ \Delta y\right)_{n}}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>These equations are easily solved as <strong>R</strong> is upper triangular.</p>
<h3 id="singular-value-decomposition">Singular value decomposition</h3>

<p>A variant of the method of orthogonal decomposition involves <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a>, in which <strong>R</strong> is diagonalized by further orthogonal transformations.</p>

<p>

<math display="block" id="Non-linear_least_squares:83">
 <semantics>
  <mrow>
   <mi>𝐉</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝐔</mi>
    <mi>𝚺</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>𝐕</mi>
      <mi>𝐓</mi>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐉</ci>
    <apply>
     <times></times>
     <ci>𝐔</ci>
     <ci>𝚺</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐕</ci>
      <ci>𝐓</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{J=U\boldsymbol{\Sigma}V^{T}}\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Non-linear_least_squares:84">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 is orthogonal, 

<math display="inline" id="Non-linear_least_squares:85">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\Sigma}
  </annotation>
 </semantics>
</math>

 is a diagonal matrix of singular values and 

<math display="inline" id="Non-linear_least_squares:86">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 is the orthogonal matrix of the eigenvectors of 

<math display="inline" id="Non-linear_least_squares:87">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐉</mi>
    <mi>𝐓</mi>
   </msup>
   <mi>𝐉</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐉</ci>
     <ci>𝐓</ci>
    </apply>
    <ci>𝐉</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{J^{T}J}
  </annotation>
 </semantics>
</math>

 or equivalently the right singular vectors of 

<math display="inline" id="Non-linear_least_squares:88">
 <semantics>
  <mi>𝐉</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐉</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{J}
  </annotation>
 </semantics>
</math>

. In this case the shift vector is given by</p>

<p>

<math display="block" id="Non-linear_least_squares:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝚫</mi>
     <mi>β</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>𝐕</mi>
     <msup>
      <mi>𝚺</mi>
      <mrow>
       <mo>-</mo>
       <mn>𝟏</mn>
      </mrow>
     </msup>
     <msub>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mpadded width="+5pt">
         <msup>
          <mi>𝐔</mi>
          <mi>𝐓</mi>
         </msup>
        </mpadded>
        <mi>𝚫</mi>
        <mi>𝐲</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝚫</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝐕</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝚺</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐔</ci>
        <ci>𝐓</ci>
       </apply>
       <ci>𝚫</ci>
       <ci>𝐲</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\boldsymbol{\Delta}\beta=V\boldsymbol{\Sigma}^{-1}\left(U^{T}\ %
\boldsymbol{\Delta}y\right)}_{n}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>The relative simplicity of this expression is very useful in theoretical analysis of non-linear least squares. The application of singular value decomposition is discussed in detail in Lawson and Hanson.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="gradient-methods">Gradient methods</h3>

<p>There are many examples in the scientific literature where different methods have been used for non-linear data-fitting problems.</p>
<ul>
<li>Inclusion of second derivatives in The Taylor series expansion of the model function. This is <a href="Newton's_method_in_optimization" title="wikilink">Newton's method in optimization</a>.</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Non-linear_least_squares:90">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>𝜷</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>f</mi>
        <mi>k</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <mi>𝜷</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mi>j</mi>
       </msub>
       <mrow>
        <mpadded width="+1.7pt">
         <msub>
          <mi>J</mi>
          <mrow>
           <mi>i</mi>
           <mi>j</mi>
          </mrow>
         </msub>
        </mpadded>
        <mi mathvariant="normal">Δ</mi>
        <msub>
         <mi>β</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
       <mrow>
        <msub>
         <mo largeop="true" symmetric="true">∑</mo>
         <mi>j</mi>
        </msub>
        <mrow>
         <msub>
          <mo largeop="true" symmetric="true">∑</mo>
          <mi>k</mi>
         </msub>
         <mrow>
          <mi mathvariant="normal">Δ</mi>
          <mpadded width="+1.7pt">
           <msub>
            <mi>β</mi>
            <mi>j</mi>
           </msub>
          </mpadded>
          <mi mathvariant="normal">Δ</mi>
          <mpadded width="+1.7pt">
           <msub>
            <mi>β</mi>
            <mi>k</mi>
           </msub>
          </mpadded>
          <msub>
           <mi>H</mi>
           <mrow>
            <mi>j</mi>
            <msub>
             <mi>k</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>i</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </msub>
           </mrow>
          </msub>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mrow>
       <mi>j</mi>
       <msub>
        <mi>k</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>i</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
     </msub>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <mrow>
        <msup>
         <mo>∂</mo>
         <mn>2</mn>
        </msup>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <mi>𝜷</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <mpadded width="+1.7pt">
         <msub>
          <mi>β</mi>
          <mi>j</mi>
         </msub>
        </mpadded>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>β</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>𝜷</ci>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>k</ci>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <ci>𝜷</ci>
       </interval>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>J</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>j</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <ci>k</ci>
         </apply>
         <apply>
          <times></times>
          <ci>normal-Δ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>β</ci>
           <ci>j</ci>
          </apply>
          <ci>normal-Δ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>β</ci>
           <ci>k</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>H</ci>
           <apply>
            <times></times>
            <ci>j</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>k</ci>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <partialdiff></partialdiff>
         <cn type="integer">2</cn>
        </apply>
        <ci>f</ci>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <ci>𝜷</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i},\boldsymbol{\beta})=f^{k}(x_{i},\boldsymbol{\beta})+\sum_{j}J_{ij}\,%
\Delta\beta_{j}+\frac{1}{2}\sum_{j}\sum_{k}\Delta\beta_{j}\,\Delta\beta_{k}\,H%
_{jk_{(i)}},\ H_{jk_{(i)}}=\frac{\partial^{2}f(x_{i},\boldsymbol{\beta})}{%
\partial\beta_{j}\,\partial\beta_{k}}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>The matrix <strong>H</strong> is known as the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a>. Although this model has better convergence properties near to the minimum, it is much worse when the parameters are far from their optimal values. Calculation of the Hessian adds to the complexity of the algorithm. This method is not in general use.
</dd>
</dl>
<ul>
<li><a href="Davidon–Fletcher–Powell_formula" title="wikilink">Davidon–Fletcher–Powell method</a>. This method, a form of pseudo-Newton method, is similar to the one above but calculates the Hessian by successive approximation, to avoid having to use analytical expressions for the second derivatives.</li>
<li><a href="Steepest_descent" title="wikilink">Steepest descent</a>. Although a reduction in the sum of squares is guaranteed when the shift vector points in the direction of steepest descent, this method often performs poorly. When the parameter values are far from optimal the direction of the steepest descent vector, which is normal (perpendicular) to the contours of the objective function, is very different from the direction of the Gauss–Newton vector. This makes divergence much more likely, especially as the minimum along the direction of steepest descent may correspond to a small fraction of the length of the steepest descent vector. When the contours of the objective function are very eccentric, due to there being high correlation between parameters. the steepest descent iterations, with shift-cutting, follow a slow, zig-zag trajectory towards the minimum.</li>
<li><a href="Conjugate_gradient_method" title="wikilink">Conjugate gradient search</a>. This is an improved steepest descent based method with good theoretical convergence properties, although it can fail on finite-precision digital computers even when used on quadratic problems.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
</ul>
<ul>
<li><a href="Gauss-Newton" title="wikilink">Gauss–Newton</a> and its variants such as <a class="uri" href="Levenberg–Marquardt" title="wikilink">Levenberg–Marquardt</a>. These are popular algorithms for solving nonlinear least squares, in particular for applications in inverse problems such as generating computational models of oil and gas reservoirs for consistency with observed production data.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
</ul>
<h3 id="direct-search-methods">Direct search methods</h3>

<p>Direct search methods depend on evaluations of the objective function at a variety of parameter values and do not use derivatives at all. They offer alternatives to the use of numerical derivatives in the Gauss–Newton method and gradient methods.</p>
<ul>
<li>Alternating variable search.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Each parameter is varied in turn by adding a fixed or variable increment to it and retaining the value that brings about a reduction in the sum of squares. The method is simple and effective when the parameters are not highly correlated. It has very poor convergence properties, but may be useful for finding initial parameter estimates.</li>
</ul>
<ul>
<li><a href="Nelder–Mead_method" title="wikilink">Nelder–Mead (simplex) search</a> A <a class="uri" href="simplex" title="wikilink">simplex</a> in this context is a <a class="uri" href="polytope" title="wikilink">polytope</a> of <em>n</em> + 1 vertices in <em>n</em> dimensions; a triangle on a plane, a tetrahedron in three-dimensional space and so forth. Each vertex corresponds to a value of the objective function for a particular set of parameters. The shape and size of the simplex is adjusted by varying the parameters in such a way that the value of the objective function at the highest vertex always decreases. Although the sum of squares may initially decrease rapidly, it can converge to a nonstationary point on quasiconvex problems, by an example of M. J. D. Powell.</li>
</ul>

<p>More detailed descriptions of these, and other, methods are available, in <em><a href="Numerical_Recipes" title="wikilink">Numerical Recipes</a></em>, together with computer code in various languages.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Least_squares_support_vector_machine" title="wikilink">Least squares support vector machine</a></li>
<li><a href="Curve_fitting" title="wikilink">Curve fitting</a></li>
<li><a href="Nonlinear_programming" title="wikilink">Nonlinear programming</a></li>
<li><a href="Optimization_(mathematics)" title="wikilink">Optimization (mathematics)</a></li>
<li><a href="Levenberg–Marquardt_algorithm" title="wikilink">Levenberg–Marquardt algorithm</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>C. T. Kelley, <em>Iterative Methods for Optimization</em>, SIAM Frontiers in Applied Mathematics, no 18, 1999, ISBN 0-89871-433-8. <a href="http://www.siam.org/books/textbooks/fr18_book.pdf">Online copy</a></li>
<li>T. Strutz: <em>Data Fitting and Uncertainty (A practical introduction to weighted least squares and beyond)</em>. Vieweg+Teubner, ISBN 978-3-8348-1022-9.</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Regression_analysis" title="wikilink">Category:Regression analysis</a> <a href="Category:Least_squares" title="wikilink">Category:Least squares</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">In the absence of <a href="round-off_error" title="wikilink">round-off error</a> and of experimental error in the independent variable the normal equations matrix would be singular<a href="#fnref1">↩</a></li>
<li id="fn2">M.J. Box, D. Davies and W.H. Swann, Non-Linear optimisation Techniques, Oliver &amp; Boyd, 1969<a href="#fnref2">↩</a></li>
<li id="fn3">This technique was proposed independently by Levenberg (1944), Girard (1958), Wynne (1959), Morrison (1960) and Marquardt (1963). Marquardt's name alone is used for it in much of the scientific literature.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">R. Fletcher, UKAEA Report AERE-R 6799, H.M. Stationery Office, 1971<a href="#fnref5">↩</a></li>
<li id="fn6">C.L. Lawson and R.J. Hanson, Solving Least Squares Problems, Prentice–Hall, 1974<a href="#fnref6">↩</a></li>
<li id="fn7">M. J. D. Powell, Computer Journal, (1964), <strong>7</strong>, 155.<a href="#fnref7">↩</a></li>
<li id="fn8">History matching production data and uncertainty assessment with an efficient TSVD parameterization algorithm, Journal of Petroleum Science and Engineering, <a class="uri" href="http://www.sciencedirect.com/science/article/pii/S0920410513003227">http://www.sciencedirect.com/science/article/pii/S0920410513003227</a><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
</ol>
</section>
</body>
</html>
